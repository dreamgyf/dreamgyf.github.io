<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Framework层的ContentProvider全解析"><meta name="keywords" content="Android源码,ContentProvider"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Framework层的ContentProvider全解析 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ContentResolver"><span class="toc-number">2.1.</span> <span class="toc-text">ContentResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Uri格式"><span class="toc-number">2.2.</span> <span class="toc-text">Uri格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#获取ContentProvider"><span class="toc-number">3.</span> <span class="toc-text">获取ContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityThread-acquireProvider"><span class="toc-number">3.1.</span> <span class="toc-text">ActivityThread.acquireProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ActivityThread-acquireExistingProvider"><span class="toc-number">3.1.1.</span> <span class="toc-text">ActivityThread.acquireExistingProvider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-getContentProvider"><span class="toc-number">3.1.2.</span> <span class="toc-text">AMS.getContentProvider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ActivityThread-installProvider"><span class="toc-number">3.1.3.</span> <span class="toc-text">ActivityThread.installProvider</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#启动ContentProvider"><span class="toc-number">4.</span> <span class="toc-text">启动ContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程已启动"><span class="toc-number">4.1.</span> <span class="toc-text">进程已启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程未启动"><span class="toc-number">4.2.</span> <span class="toc-text">进程未启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-attachApplicationLocked"><span class="toc-number">4.2.1.</span> <span class="toc-text">AMS.attachApplicationLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ActivityThread-handleBindApplication"><span class="toc-number">4.2.2.</span> <span class="toc-text">ActivityThread.handleBindApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityThread-installContentProviders"><span class="toc-number">4.3.</span> <span class="toc-text">ActivityThread.installContentProviders</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ActivityThread-installProvider-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">ActivityThread.installProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#本地启动ContentProvider"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">本地启动ContentProvider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取处理远程ContentProvider"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">获取处理远程ContentProvider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActivityThread-installProviderAuthoritiesLocked"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">ActivityThread.installProviderAuthoritiesLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-publishContentProviders"><span class="toc-number">4.3.2.</span> <span class="toc-text">AMS.publishContentProviders</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ContentProvider引用计数"><span class="toc-number">5.</span> <span class="toc-text">ContentProvider引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ActivityThread层的引用计数"><span class="toc-number">5.1.</span> <span class="toc-text">ActivityThread层的引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#增加引用计数"><span class="toc-number">5.1.1.</span> <span class="toc-text">增加引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少引用计数"><span class="toc-number">5.1.2.</span> <span class="toc-text">减少引用计数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMS层的引用计数"><span class="toc-number">5.2.</span> <span class="toc-text">AMS层的引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-refContentProvider"><span class="toc-number">5.2.1.</span> <span class="toc-text">AMS.refContentProvider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-incProviderCountLocked"><span class="toc-number">5.2.2.</span> <span class="toc-text">AMS.incProviderCountLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMS-decProviderCountLocked"><span class="toc-number">5.2.3.</span> <span class="toc-text">AMS.decProviderCountLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ContentProvider死亡杀死调用方进程的过程"><span class="toc-number">6.</span> <span class="toc-text">ContentProvider死亡杀死调用方进程的过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Framework层的ContentProvider全解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ContentProvider/">ContentProvider</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在四大组件中，可能我们平时用到最少的便是<code>ContentProvider</code>了，<code>ContentProvider</code>是用来帮助应用管理其自身和其他应用所存储数据的访问，并提供与其他应用共享数据的方法，使用<code>ContentProvider</code>可以安全的在应用之间共享和修改数据，比如说访问图库，通讯录等</p>
<p>在之前的文章中，我们提到了<code>ContentProvider</code>的启动时机，不妨顺水推舟，干脆把这一块分析个明白，本篇文章并不会教大家怎样使用<code>ContentProvider</code>，只将精力集中在<code>ContentProvider</code>在系统层面的启动与交互上</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>想要通过<code>ContentProvider</code>访问应用数据，我们通常需要借助<code>ContentResolver</code>的API，我们可以通过<code>Context.getContentResolver</code>方法获取其实例对象</p>
<p><code>ContentResolver</code>是一个抽象类，它的抽象方法由<code>ContextImpl.ApplicationContentResolver</code>继承实现，我们实际上获取到的也是这个实例对象</p>
<h2 id="Uri格式"><a href="#Uri格式" class="headerlink" title="Uri格式"></a>Uri格式</h2><p><code>ContentProvider</code>的使用需要先获得提供者的Uri，它的格式如下：</p>
<ol>
<li>Scheme：固定为<code>content://</code></li>
<li>Authority：为提供者在<code>AndroidManifest</code>里设置的<code>android:authorities</code>属性</li>
<li>资源相对路径</li>
<li>资源ID</li>
</ol>
<p>其中，资源相对路径和资源ID不是必须的，要看资源存储的数量及形式</p>
<p>举个栗子，外部存储中某张图片的Uri为：<code>content://media/external/images/media/${id}</code>，其中<code>media</code>为Authority，<code>/external/images/media</code>为外部存储图片的相对路径，<code>id</code>为这张图片资源在数据库中存储的<code>id</code></p>
<h1 id="获取ContentProvider"><a href="#获取ContentProvider" class="headerlink" title="获取ContentProvider"></a>获取ContentProvider</h1><p><code>ContentProvider</code>作为共享数据的桥梁，最主要的几个功能无非是增、删、改、查，我们就以查作为入口来分析<code>ContentProvider</code>对象是怎么获取的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContentResolver.query</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @RequiresPermission.Read @NonNull Uri uri,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] projection, @Nullable Bundle queryArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取unstableProvider</span></span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用远程对象query</span></span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, mAttributionTag, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            <span class="comment">//尝试获取stableProvider</span></span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用远程对象query</span></span><br><span class="line">            qCursor = stableProvider.query(mPackageName, mAttributionTag, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qCursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force query execution.  Might fail and throw a runtime exception here.</span></span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap the cursor object into CursorWrapperInner object.</span></span><br><span class="line">        <span class="comment">//将qCursor和provider包装成CursorWrapperInner对象返回</span></span><br><span class="line">        <span class="keyword">final</span> IContentProvider provider = (stableProvider != <span class="keyword">null</span>) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        <span class="keyword">final</span> CursorWrapperInner wrapper = <span class="keyword">new</span> CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = <span class="keyword">null</span>;</span><br><span class="line">        qCursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Arbitrary and not worth documenting, as Activity</span></span><br><span class="line">        <span class="comment">// Manager will kill this process shortly anyway.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (qCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qCursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.setRemote(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unstableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseUnstableProvider(unstableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseProvider(stableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这个方法大致分成以下几个步骤：</p>
<ol>
<li>获取<code>unstableProvider</code>远程对象</li>
<li>调用<code>unstableProvider</code>对象的<code>query</code>方法，获取<code>qCursor</code></li>
<li>如果<code>query</code>过程中远程对象死亡，尝试获取<code>stableProvider</code>并调用<code>query</code>方法获取<code>qCursor</code></li>
<li>获取<code>stableProvider</code>（如果之前没获取的话）</li>
<li>将<code>qCursor</code>和<code>stableProvider</code>包装成<code>CursorWrapperInner</code>对象返回</li>
<li>释放资源</li>
</ol>
<p>既然<code>ContentProvider</code>可以在应用之前共享数据，那它必然是支持跨进程的，没错，用的还是我们熟悉的<code>Binder</code>通信，<code>IContentProvider</code>对象即是给调用方进程使用的远程<code>Binder</code>对象，回顾这个方法我们发现，<code>IContentProvider</code>远程对象是通过<code>acquireUnstableProvider</code>或<code>acquireProvider</code>获取的，我们接下来看看这两个方法做了什么</p>
<p>这里有一个关于<code>unstable</code>和<code>stable</code>的概念，对于通过这两种方式获取的<code>ContentProvider</code>分别会有<code>unstableCount</code>和<code>stableCount</code>两种引用计数，如果远程<code>ContentProvider</code>所在进程死亡，且其<code>stableCount &gt; 0</code>的话，则会将其通过<code>stable</code>方式关联的调用方进程一同杀死，具体的流程我们会在后面分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireProvider(mContext, auth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acquireUnstableProvider(mContext, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acquireProvider(mContext, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContextImpl.ApplicationContentResolver 内实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContextImpl.ApplicationContentResolver 内实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityThread-acquireProvider"><a href="#ActivityThread-acquireProvider" class="headerlink" title="ActivityThread.acquireProvider"></a>ActivityThread.acquireProvider</h2><p>Android系统是通过<code>Authority</code>来区分不同的<code>ContentProvider</code>的，经过一些简单的判断处理后，最终调用了<code>ActivityThread.acquireProvider</code>方法去获取<code>ContentProvider</code>，而<code>acquireUnstableProvider</code>和<code>acquireProvider</code>的区别只是最后一个布尔值入参不同罢了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从本地缓存中获取ContentProvider对象</span></span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is a possible race here.  Another thread may try to acquire</span></span><br><span class="line">    <span class="comment">// the same provider at the same time.  When this happens, we want to ensure</span></span><br><span class="line">    <span class="comment">// that the first one wins.</span></span><br><span class="line">    <span class="comment">// Note that we cannot hold the lock while acquiring and installing the</span></span><br><span class="line">    <span class="comment">// provider since it might take a long time to run and it could also potentially</span></span><br><span class="line">    <span class="comment">// be re-entrant in the case where the provider is in the same process.</span></span><br><span class="line">    ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">            <span class="comment">//使用AMS获取ContentProvider对象</span></span><br><span class="line">            holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                    getApplicationThread(), c.getOpPackageName(), auth, userId, stable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">    <span class="comment">// any ties in the race.</span></span><br><span class="line">    <span class="comment">//安装ContentProvider</span></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法大概做了以下几件事：</p>
<ol>
<li>首先从缓存中尝试获取<code>IContentProvider</code>对象</li>
<li>使用<code>AMS</code>获取<code>ContentProviderHolder</code>对象</li>
<li>安装<code>ContentProvider</code></li>
<li>返回<code>IContentProvider</code>对象</li>
</ol>
<h3 id="ActivityThread-acquireExistingProvider"><a href="#ActivityThread-acquireExistingProvider" class="headerlink" title="ActivityThread.acquireExistingProvider"></a>ActivityThread.acquireExistingProvider</h3><p>我们首先看通过<code>acquireExistingProvider</code>方法尝试从缓存中获取<code>IContentProvider</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//从缓存Map中查找</span></span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IContentProvider provider = pr.mProvider;</span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="comment">//判断远端进程是否已被杀死</span></span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class="line">            <span class="comment">// The hosting process of the provider has died; we can't</span></span><br><span class="line">            <span class="comment">// use this one.</span></span><br><span class="line">            <span class="comment">//清理ContentProvider</span></span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only increment the ref count if we have one.  If we don't then the</span></span><br><span class="line">        <span class="comment">// provider is not reference counted and never needs to be released.</span></span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//更新引用计数</span></span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>Authority</code>和<code>userId</code>来从Map中查找是否已存在对应的<code>ProviderClientRecord</code>对象，然后从中取出<code>IContentProvider</code>对象，再检查其中的远程<code>Binder</code>对象是否已被杀死，最后一切无误，增加<code>ContentProvider</code>的引用计数</p>
<h3 id="AMS-getContentProvider"><a href="#AMS-getContentProvider" class="headerlink" title="AMS.getContentProvider"></a>AMS.getContentProvider</h3><p>如果这一步没有获取到，程序会继续从<code>AMS</code>获取<code>ContentProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IApplicationThread caller, String callingPackage, String name, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String msg = <span class="string">"null IApplicationThread when getting content provider "</span></span><br><span class="line">                + name;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span></span><br><span class="line">    <span class="comment">// with cross-user grant.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">if</span> (callingPackage != <span class="keyword">null</span> &amp;&amp; mAppOpsService.checkPackage(callingUid, callingPackage)</span><br><span class="line">            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Given calling package "</span> + callingPackage</span><br><span class="line">                + <span class="string">" does not match caller's uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, callingUid, callingPackage,</span><br><span class="line">            <span class="keyword">null</span>, stable, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一些检查后调用<code>getContentProviderImpl</code>方法，这个方法有点长，我们分段来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方所在进程记录</span></span><br><span class="line">        ProcessRecord r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                        + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") when getting content provider "</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> checkCrossUser = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First check if this content provider has been published...</span></span><br><span class="line">        <span class="comment">//检查需要的ContentProvider是否已被发布</span></span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">        <span class="comment">// If that didn't work, check if it exists for user 0 and then</span></span><br><span class="line">        <span class="comment">// verify that it's a singleton provider before using it.</span></span><br><span class="line">        <span class="comment">//如果没找到，尝试从系统用户中查找已发布的ContentProvider</span></span><br><span class="line">        <span class="comment">//并确保它是可用的单例组件，条件如下：</span></span><br><span class="line">        <span class="comment">//是用户级应用程序且组件设置了单例flag且拥有INTERACT_ACROSS_USERS权限 或 App运行在system进程中 或 组件设置了单例flag且是同一个App</span></span><br><span class="line">        <span class="keyword">if</span> (cpr == <span class="keyword">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">            <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cpi = cpr.info;</span><br><span class="line">                <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r == <span class="keyword">null</span> ? callingUid : r.uid,</span><br><span class="line">                                cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                    userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                    checkCrossUser = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cpr = <span class="keyword">null</span>;</span><br><span class="line">                    cpi = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断ContentProvider所在进程是否已死亡</span></span><br><span class="line">        ProcessRecord dyingProc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span> &amp;&amp; cpr.proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            providerRunning = !cpr.proc.killed;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note if killedByAm is also set, this means the provider process has just been</span></span><br><span class="line">            <span class="comment">// killed by AM (in ProcessRecord.kill()), but appDiedLocked() hasn't been called</span></span><br><span class="line">            <span class="comment">// yet. So we need to call appDiedLocked() here and let it clean up.</span></span><br><span class="line">            <span class="comment">// (See the commit message on I2c4ba1e87c2d47f2013befff10c49b3dc337a9a7 to see</span></span><br><span class="line">            <span class="comment">// how to test this case.)</span></span><br><span class="line">            <span class="keyword">if</span> (cpr.proc.killed &amp;&amp; cpr.proc.killedByAm) &#123;</span><br><span class="line">                Slog.wtf(TAG, cpr.proc.toString() + <span class="string">" was killed by AM but isn't really dead"</span>);</span><br><span class="line">                <span class="comment">// Now we are going to wait for the death before starting the new process.</span></span><br><span class="line">                dyingProc = cpr.proc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，第一部分，检查目标<code>ContentProvider</code>是否已被发布并记录在了<code>mProviderMap</code>中，注意这里的<code>mProviderMap</code>是<code>AMS</code>中的一个成员变量，一系列Map的一个集合，和<code>ActivityThread</code>中的<code>mProviderMap</code>不是一个东西。如果在当前用户中找不到，且当前用户不是系统用户（UserHandle.USER_SYSTEM == 0），则尝试从系统用户中查找合法可用的单例<code>ContentProvider</code>，符合以下任一一个条件的<code>ContentProvider</code>即可被视作单例<code>ContentProvider</code>：</p>
<ul>
<li>App是用户级应用程序（uid &gt;= 10000）且<code>ContentProvider</code>组件设置了单例flag（<code>android:singleUser</code>）且App拥有<code>INTERACT_ACROSS_USERS</code>权限</li>
<li>App运行在<code>system</code>进程中</li>
<li><code>ContentProvider</code>组件设置了单例flag（<code>android:singleUser</code>）且是同一个App</li>
</ul>
<p>至于为什么跨用户访问需要单例这个条件，这个和多用户相关，我也不是很清楚，以后如果分析到了多用户这块再回来补充。目前国内厂商的应用分身、手机分身功能大部分用的就是多用户技术</p>
<p>接着通过目标<code>ContentProviderRecord</code>是否存在和其所在进程是否还存活判断目标<code>ContentProvider</code>是否在运行中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ContentProvider正在运行中</span></span><br><span class="line">        <span class="keyword">if</span> (providerRunning) &#123;</span><br><span class="line">            cpi = cpr.info;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果此ContentProvider可以在调用者进程中直接运行（同一个App的同进程 或 同一个App且Provider组件支持多进程）</span></span><br><span class="line">            <span class="comment">//直接返回一个新的ContentProviderHolder让调用者进程自己启动ContentProvider</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                ... <span class="comment">//权限检查</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// This provider has been published or is in the process</span></span><br><span class="line">                <span class="comment">// of being published...  but it is also allowed to run</span></span><br><span class="line">                <span class="comment">// in the caller's process, so don't make a connection</span></span><br><span class="line">                <span class="comment">// and just let the caller instantiate its own instance.</span></span><br><span class="line">                ContentProviderHolder holder = cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// don't give caller the provider object, it needs</span></span><br><span class="line">                <span class="comment">// to make its own.</span></span><br><span class="line">                holder.provider = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't expose providers between normal apps and instant apps</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (AppGlobals.getPackageManager()</span><br><span class="line">                        .resolveContentProvider(name, <span class="number">0</span> <span class="comment">/*flags*/</span>, userId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//权限检查</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In this case the provider instance already exists, so we can</span></span><br><span class="line">            <span class="comment">// return it right away.</span></span><br><span class="line">            <span class="comment">//获取连接并更新引用计数</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">                    stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span> &amp;&amp; (conn.stableCount+conn.unstableCount) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; r != <span class="keyword">null</span> &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_LOW_APP_ADJ) &#123;</span><br><span class="line">                    <span class="comment">// If this is a perceptible app accessing the provider,</span></span><br><span class="line">                    <span class="comment">// make sure to count it as being accessed and thus</span></span><br><span class="line">                    <span class="comment">// back up on the LRU list.  This is good because</span></span><br><span class="line">                    <span class="comment">// content providers are often expensive to start.</span></span><br><span class="line">                    <span class="comment">//更新进程优先级</span></span><br><span class="line">                    mProcessList.updateLruProcessLocked(cpr.proc, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verifiedAdj = cpr.proc.verifiedAdj;</span><br><span class="line">            <span class="comment">//更新进程adj</span></span><br><span class="line">            <span class="keyword">boolean</span> success = updateOomAdjLocked(cpr.proc, <span class="keyword">true</span>,</span><br><span class="line">                    OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER);</span><br><span class="line">            <span class="comment">// XXX things have changed so updateOomAdjLocked doesn't actually tell us</span></span><br><span class="line">            <span class="comment">// if the process has been successfully adjusted.  So to reduce races with</span></span><br><span class="line">            <span class="comment">// it, we will check whether the process still exists.  Note that this doesn't</span></span><br><span class="line">            <span class="comment">// completely get rid of races with LMK killing the process, but should make</span></span><br><span class="line">            <span class="comment">// them much smaller.</span></span><br><span class="line">            <span class="keyword">if</span> (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123;</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> there is still a race here where a signal could be</span></span><br><span class="line">            <span class="comment">// pending on the process even though we managed to update its</span></span><br><span class="line">            <span class="comment">// adj level.  Not sure what to do about this, but at least</span></span><br><span class="line">            <span class="comment">// the race is now smaller.</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// Uh oh...  it looks like the provider's process</span></span><br><span class="line">                <span class="comment">// has been killed on us.  We need to wait for a new</span></span><br><span class="line">                <span class="comment">// process to be started, and make sure its death</span></span><br><span class="line">                <span class="comment">// doesn't kill our process.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Existing provider "</span> + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" is crashing; detaching "</span> + r);</span><br><span class="line">                <span class="comment">//ContentProvider所在进程被杀了，更新引用计数</span></span><br><span class="line">                <span class="keyword">boolean</span> lastRef = decProviderCountLocked(conn, cpr, token, stable);</span><br><span class="line">                <span class="comment">//仍有别的地方对这个ContentProvider有引用，直接返回null（需要等待进程清理干净才能重启）</span></span><br><span class="line">                <span class="keyword">if</span> (!lastRef) &#123;</span><br><span class="line">                    <span class="comment">// This wasn't the last ref our process had on</span></span><br><span class="line">                    <span class="comment">// the provider...  we will be killed during cleaning up, bail.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We'll just start a new process to host the content provider</span></span><br><span class="line">                <span class="comment">//将运行状态标为false，使得重新启动ContentProvider所在进程</span></span><br><span class="line">                providerRunning = <span class="keyword">false</span>;</span><br><span class="line">                conn = <span class="keyword">null</span>;</span><br><span class="line">                dyingProc = cpr.proc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cpr.proc.verifiedAdj = cpr.proc.setAdj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分，如果目标<code>ContentProvider</code>正在运行中，首先检查目标<code>ContentProvider</code>是否可以在调用者进程中直接运行，需要满足以下任一一个条件：</p>
<ul>
<li>调用者和目标<code>ContentProvider</code>是同一个App中的同进程</li>
<li>调用者和目标<code>ContentProvider</code>属同一个App且<code>ContentProvider</code>组件支持多进程（<code>android:multiprocess</code>）</li>
</ul>
<p>在这种情况下，直接返回一个新的<code>ContentProviderHolder</code>让调用者进程自己处理获得<code>ContentProvider</code>即可，具体逻辑在<code>ActivityThread.installProvider</code>方法中，后面会分析</p>
<p>如果不满足这种情况，即调用方进程和目标<code>ContentProvider</code>不在一个进程中，需要跨进程调用，获取<code>ContentProviderConnection</code>连接并更新引用计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ContentProvider未在运行</span></span><br><span class="line">        <span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">            <span class="comment">//通过PMS获取ContentProvider信息</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cpi = AppGlobals.getPackageManager().</span><br><span class="line">                    resolveContentProvider(name,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cpi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If the provider is a singleton AND</span></span><br><span class="line">            <span class="comment">// (it's a call within the same user || the provider is a</span></span><br><span class="line">            <span class="comment">// privileged app)</span></span><br><span class="line">            <span class="comment">// Then allow connecting to the singleton provider</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags)</span><br><span class="line">                    &amp;&amp; isValidSingletonCall(r == <span class="keyword">null</span> ? callingUid : r.uid,</span><br><span class="line">                            cpi.applicationInfo.uid);</span><br><span class="line">            <span class="keyword">if</span> (singleton) &#123;</span><br><span class="line">                userId = UserHandle.USER_SYSTEM;</span><br><span class="line">            &#125;</span><br><span class="line">            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//各项检查</span></span><br><span class="line"></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            <span class="comment">//通过Class（android:name属性）获取ContentProviderRecord</span></span><br><span class="line">            cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="comment">//此ContentProvider是第一次运行</span></span><br><span class="line">            <span class="keyword">boolean</span> firstClass = cpr == <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                ... <span class="comment">//权限处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取应用信息</span></span><br><span class="line">                    ApplicationInfo ai =</span><br><span class="line">                        AppGlobals.getPackageManager().</span><br><span class="line">                            getApplicationInfo(</span><br><span class="line">                                    cpi.applicationInfo.packageName,</span><br><span class="line">                                    STOCK_PM_FLAGS, userId);</span><br><span class="line">                    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"No package info for content provider "</span></span><br><span class="line">                                + cpi.name);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ai = getAppInfoForUser(ai, userId);</span><br><span class="line">                    <span class="comment">//新建ContentProvider记录</span></span><br><span class="line">                    cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, ai, comp, singleton);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                    <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(ident);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyingProc == cpr.proc &amp;&amp; dyingProc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The old stable connection's client should be killed during proc cleaning up,</span></span><br><span class="line">                <span class="comment">// so do not re-use the old ContentProviderRecord, otherwise the new clients</span></span><br><span class="line">                <span class="comment">// could get killed unexpectedly.</span></span><br><span class="line">                <span class="comment">//旧的ContentProvider进程在死亡过程中，不要复用旧的ContentProviderRecord，避免出现预期之外的问题</span></span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(cpr);</span><br><span class="line">                <span class="comment">// This is sort of "firstClass"</span></span><br><span class="line">                firstClass = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果此ContentProvider可以在调用者进程中直接运行（同一个App的同进程 或 同一个App且Provider组件支持多进程）</span></span><br><span class="line">            <span class="comment">//直接返回一个新的ContentProviderHolder让调用者进程自己启动ContentProvider</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                <span class="comment">// If this is a multiprocess provider, then just return its</span></span><br><span class="line">                <span class="comment">// info and allow the caller to instantiate it.  Only do</span></span><br><span class="line">                <span class="comment">// this if the provider is the same user as the caller's</span></span><br><span class="line">                <span class="comment">// process, or can run as root (so can be in any process).</span></span><br><span class="line">                <span class="keyword">return</span> cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is single process, and our app is now connecting to it.</span></span><br><span class="line">            <span class="comment">// See if we are already in the process of launching this</span></span><br><span class="line">            <span class="comment">// provider.</span></span><br><span class="line">            <span class="comment">//查找正在启动中的ContentProvider</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mLaunchingProviders.size();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the provider is not already being launched, then get it</span></span><br><span class="line">            <span class="comment">// started.</span></span><br><span class="line">            <span class="comment">//目标ContentProvider不在启动中</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Content provider is now in use, its package can't be stopped.</span></span><br><span class="line">                    <span class="comment">//将App状态置为unstopped，设置休眠状态为false</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                                cpr.appInfo.packageName, <span class="keyword">false</span>, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                                + cpr.appInfo.packageName + <span class="string">": "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Use existing process if already started</span></span><br><span class="line">                    <span class="comment">//获取目标ContentProvider所在进程记录</span></span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123; <span class="comment">//进程存活</span></span><br><span class="line">                        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                            <span class="comment">//将ContentProviderRecord保存到进程已发布ContentProvider列表中</span></span><br><span class="line">                            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//调度ActivityThread直接安装ContentProvider</span></span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//进程死亡</span></span><br><span class="line">                        <span class="comment">//启动App（App启动过程中会自动启动ContentProvider）</span></span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>,</span><br><span class="line">                                <span class="keyword">new</span> HostingRecord(<span class="string">"content provider"</span>,</span><br><span class="line">                                    <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                            cpi.name)),</span><br><span class="line">                                ZYGOTE_POLICY_FLAG_EMPTY, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    <span class="comment">//将目标ContentProvider添加到启动中列表</span></span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure the provider is published (the same provider class</span></span><br><span class="line">            <span class="comment">// may be published under multiple names).</span></span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">            <span class="comment">//获取连接并更新引用计数</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">                    stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grantImplicitAccess(userId, <span class="keyword">null</span> <span class="comment">/*intent*/</span>, callingUid,</span><br><span class="line">                UserHandle.getAppId(cpi.applicationInfo.uid));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三部分，如果目标<code>ContentProvider</code>未在运行，先通过<code>PMS</code>获取<code>ContentProvider</code>信息，接着尝试通过Class（<code>android:name</code>属性）获取<code>ContentProviderRecord</code>，如果获取不到，说明这个<code>ContentProvider</code>是第一次运行（开机后），这种情况下需要新建<code>ContentProviderRecord</code>，如果获取到了，但是其所在进程被标记为正在死亡，此时同样需要新建<code>ContentProviderRecord</code>，不要复用旧的<code>ContentProviderRecord</code>，避免出现预期之外的问题</p>
<p>接下来同样检查目标<code>ContentProvider</code>是否可以在调用者进程中直接运行，如果可以直接返回一个新的<code>ContentProviderHolder</code>让调用者进程自己启动获取<code>ContentProvider</code></p>
<p>接着检查正在启动中的<code>ContentProvider</code>列表，如果不在列表中，我们可能需要手动启动它，此时又有两种情况：</p>
<ol>
<li><code>ContentProvider</code>所在进程已启动：如果进程已发布<code>ContentProvider</code>列表中不包含这个<code>ContentProviderRecord</code>，则将其添加到列表中，然后调用目标进程中的<code>ApplicationThread.scheduleInstallProvider</code>方法安装启动<code>ContentProvider</code></li>
<li><code>ContentProvider</code>所在进程未启动：启动目标进程，目标进程启动过程中会自动安装启动<code>ContentProvider</code>（<code>ActivityThread.handleBindApplication</code>方法中）</li>
</ol>
<p>最后更新<code>mProviderMap</code>，获取<code>ContentProviderConnection</code>连接并更新引用计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the provider to be published...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout =</span><br><span class="line">            SystemClock.uptimeMillis() + ContentResolver.CONTENT_PROVIDER_READY_TIMEOUT_MILLIS;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ContentProvider启动过程中进程死亡，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//计算最大等待时间</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> wait = Math.max(<span class="number">0L</span>, timeout - SystemClock.uptimeMillis());</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放锁，等待ContentProvider启动完成</span></span><br><span class="line">                cpr.wait(wait);</span><br><span class="line">                <span class="comment">//等待时间已过，ContentProvider还是没能启动完成并发布，超时</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    timedOut = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timedOut) &#123;</span><br><span class="line">        ... <span class="comment">//超时处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新的ContentProviderHolder</span></span><br><span class="line">    <span class="keyword">return</span> cpr.newHolder(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四部分，如果<code>ContentProvider</code>已存在，直接新建一个<code>ContentProviderHolder</code>返回，如果<code>ContentProvider</code>之前不存在，现在正在启动中，则以当前时间加上<code>CONTENT_PROVIDER_READY_TIMEOUT_MILLIS</code>推算出一个超时时间，给目标<code>ContentProviderRecord</code>上锁后，调用<code>wait</code>方法等待，直到<code>ContentProvider</code>成功发布后<code>notify</code>解除<code>wait</code>状态（在<code>AMS.publishContentProviders</code>方法中，之后会分析到），或一直等待直到超时。<code>wait</code>状态解除后，判断内部<code>ContentProvider</code>是否已被赋值，如果没有，则可以断定超时，此时返回<code>null</code>，如有，则返回一个新的<code>ContentProviderHolder</code></p>
<h3 id="ActivityThread-installProvider"><a href="#ActivityThread-installProvider" class="headerlink" title="ActivityThread.installProvider"></a>ActivityThread.installProvider</h3><p>由于这个方法同时包含了启动安装本地<code>ContentProvider</code>和获取安装远程<code>ContentProvider</code>的逻辑，所以放到后面<code>启动ContentProvider</code>章节里一起分析</p>
<h1 id="启动ContentProvider"><a href="#启动ContentProvider" class="headerlink" title="启动ContentProvider"></a>启动ContentProvider</h1><p>从前面的章节<code>获取ContentProvider</code>中，我们已经归纳出<code>ContentProvider</code>的启动分为两种情况，接着我们就来分析在这两种情况下，<code>ContentProvider</code>的启动路径</p>
<h2 id="进程已启动"><a href="#进程已启动" class="headerlink" title="进程已启动"></a>进程已启动</h2><p>在进程已启动的情况下，如果进程已发布<code>ContentProvider</code>列表中不包含这个<code>ContentProviderRecord</code>，则将其添加到列表中，然后调用目标进程中的<code>ApplicationThread.scheduleInstallProvider</code>方法安装启动<code>ContentProvider</code></p>
<p><code>ApplicationThread.scheduleInstallProvider</code>会通过<code>Hander</code>发送一条<code>what</code>值为<code>H.INSTALL_PROVIDER</code>的消息，我们根据这个<code>what</code>值搜索，发现会走到<code>ActivityThread.handleInstallProvider</code>方法中，在这个方法内又会调用<code>installContentProviders</code>方法安装启动<code>ContentProvider</code></p>
<h2 id="进程未启动"><a href="#进程未启动" class="headerlink" title="进程未启动"></a>进程未启动</h2><p>在进程未启动的情况下，直接启动目标进程，在之前的文章 <a href="https://juejin.cn/post/7172464885492613128#heading-7" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 里，我们分析了App的启动流程，其中有两个地方对启动<code>ContentProvider</code>至关重要</p>
<h3 id="AMS-attachApplicationLocked"><a href="#AMS-attachApplicationLocked" class="headerlink" title="AMS.attachApplicationLocked"></a>AMS.attachApplicationLocked</h3><p>在这个方法中会调用<code>generateApplicationProvidersLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//normalMode一般情况下均为true</span></span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ProviderInfo&gt; <span class="title">generateApplicationProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PMS获取App中同一个进程内的所有的ContentProvider组件信息</span></span><br><span class="line">        providers = AppGlobals.getPackageManager()</span><br><span class="line">                .queryContentProviders(app.processName, app.uid,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS</span><br><span class="line">                                | MATCH_DEBUG_TRIAGED_MISSING, <span class="comment">/*metadastaKey=*/</span> <span class="keyword">null</span>)</span><br><span class="line">                .getList();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> userId = app.userId;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="comment">//有必要的情况下进行Map扩容</span></span><br><span class="line">        app.pubProviders.ensureCapacity(N + app.pubProviders.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> keep logic in sync with installEncryptionUnawareProviders</span></span><br><span class="line">            ProviderInfo cpi =</span><br><span class="line">                (ProviderInfo)providers.get(i);</span><br><span class="line">            <span class="comment">//对于单例ContentProvider，需要在默认用户中启动，如果不是默认用户的话则直接将其丢弃掉，不启动</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags);</span><br><span class="line">            <span class="keyword">if</span> (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                <span class="comment">// This is a singleton provider, but a user besides the</span></span><br><span class="line">                <span class="comment">// default user is asking to initialize a process it runs</span></span><br><span class="line">                <span class="comment">// in...  well, no, it doesn't actually run in this process,</span></span><br><span class="line">                <span class="comment">// it runs in the process of the default user.  Get rid of it.</span></span><br><span class="line">                providers.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//新建ContentProviderRecord并将其加入到缓存中</span></span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, app.info, comp, singleton);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将ContentProviderRecord保存到进程已发布ContentProvider列表中</span></span><br><span class="line">            app.pubProviders.put(cpi.name, cpr);</span><br><span class="line">            <span class="keyword">if</span> (!cpi.multiprocess || !<span class="string">"android"</span>.equals(cpi.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">                app.addPackage(cpi.applicationInfo.packageName,</span><br><span class="line">                        cpi.applicationInfo.longVersionCode, mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            notifyPackageUse(cpi.applicationInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是获取需要启动的<code>ContentProvider</code>的<code>ContentProviderRecord</code>，如果是第一次启动这个<code>ContentProvider</code>则需要新建一个<code>ContentProviderRecord</code>并将其存入缓存，然后将其保存到进程已发布<code>ContentProvider</code>列表中，以供后面使用。同时这个方法返回了需要启动的<code>ProviderInfo</code>列表，<code>AMS.attachApplicationLocked</code>方法可以根据这个列表判断是否有需要启动的<code>ContentProvider</code>并设置<code>ContentProvider</code>启动超时检测</p>
<h3 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication"></a>ActivityThread.handleBindApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">        <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">        <span class="comment">// app's custom Application class</span></span><br><span class="line">        <span class="comment">//在非受限模式下启动ContentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Application的onCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">        <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">        <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法中直接调用了<code>installContentProviders</code>方法安装启动<code>ContentProvider</code></p>
<p>另外提一点，为什么我要把<code>Application</code>的创建和<code>onCreate</code>也放进来呢？现在市面上有很多库，包括很多教程告诉我们，可以通过注册<code>ContentProvider</code>的方式初始化SDK，获取全局<code>Context</code>，比如说著名的内存泄漏检测工具<code>LeakCanary</code>的新版本，想要使用它，直接添加它的依赖就行了，不需要对代码做哪怕一点的改动，究其原理，就是因为<code>ContentProvider</code>的启动时机是在<code>Application</code>创建后，<code>Application.onCreate</code>调用前，并且<code>ContentProvider</code>内的<code>Context</code>成员变量大概率就是<code>Application</code>，大家以后在开发过程中也可以妙用这一点</p>
<h2 id="ActivityThread-installContentProviders"><a href="#ActivityThread-installContentProviders" class="headerlink" title="ActivityThread.installContentProviders"></a>ActivityThread.installContentProviders</h2><p>好了，现在这两种情况最终都走到了<code>ActivityThread.installContentProviders</code>方法中，那我们接下来就好好分析<code>ContentProvider</code>实际的启动安装流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="comment">//逐个启动</span></span><br><span class="line">        ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发布ContentProvider</span></span><br><span class="line">        ActivityManager.getService().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，便利所有待启动的<code>ContentProvider</code>信息列表，逐个启动安装<code>ContentProvider</code>，最后一起发布</p>
<h3 id="ActivityThread-installProvider-1"><a href="#ActivityThread-installProvider-1" class="headerlink" title="ActivityThread.installProvider"></a>ActivityThread.installProvider</h3><p>我们先看<code>installProvider</code>方法，我们在上一章中分析到，获取<code>ContentProvider</code>的时候也会调用这个方法，这次我们就结合起来一起分析</p>
<p>通过上文的代码，我们发现，有两处地方会调用<code>installProvider</code>方法，方法的入参有三种形式，分别为：</p>
<ul>
<li><p><code>holder</code>不为<code>null</code>，<code>info</code>不为<code>null</code>，<code>holder.provider</code>为<code>null</code>：在<code>ActivityThread.acquireProvider</code>方法中被调用，路径为 没有获取到已存在的<code>ContentProvider</code> -&gt; <code>AMS.getContentProvider</code> -&gt; <code>AMS.getContentProviderImpl</code> -&gt; 发现目标<code>ContentProvider</code>可以在调用者进程中直接运行 -&gt; 直接返回一个新的<code>ContentProviderHolder</code>（包含<code>ProviderInfo</code>） -&gt; <code>ActivityThread.installProvider</code>，在这种情况下<code>installProvider</code>方法会在本地启动安装<code>ContentProvider</code></p>
</li>
<li><p><code>holder</code>为<code>null</code>，<code>info</code>不为<code>null</code>：在<code>ActivityThread.installContentProviders</code>方法中被调用，两条路径，一是App进程启动后自动执行，二是在<code>AMS.getContentProvider</code>方法中发现目标进程已启动但是<code>ContentProvider</code>未启动，调用<code>ActivityThread.scheduleInstallProvider</code>方法执行，在这种情况下<code>installProvider</code>方法会在本地启动安装<code>ContentProvider</code></p>
</li>
<li><p><code>holder</code>不为<code>null</code>，<code>holder.provider</code>不为<code>null</code>：在<code>ActivityThread.acquireProvider</code>方法中被调用，路径为 没有获取到已存在的<code>ContentProvider</code> -&gt; <code>AMS.getContentProvider</code> -&gt; <code>AMS.getContentProviderImpl</code> -&gt; 获取到目标进程的远程<code>ContentProvider</code>引用 -&gt; 包装成<code>ContentProviderHolder</code>返回 -&gt; <code>ActivityThread.installProvider</code>，在这种情况下<code>installProvider</code>方法直接可以获取到远程<code>ContentProvider</code>引用，然后进行处理</p>
</li>
</ul>
<p>我们将这三种情况分成两种case分别分析</p>
<h4 id="本地启动ContentProvider"><a href="#本地启动ContentProvider" class="headerlink" title="本地启动ContentProvider"></a>本地启动ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123; <span class="comment">//启动本地ContentProvider</span></span><br><span class="line">        Context c = <span class="keyword">null</span>;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">        <span class="comment">//首先获取Context，一般情况下就是Application</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Split Apks动态加载相关</span></span><br><span class="line">        <span class="keyword">if</span> (info.splitName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = c.createContextForSplit(info.splitName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            <span class="comment">//获取应用信息</span></span><br><span class="line">            LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// System startup case.</span></span><br><span class="line">                packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过AppComponentFactory实例化ContentProvider</span></span><br><span class="line">            localProvider = packageInfo.getAppFactory()</span><br><span class="line">                    .instantiateProvider(cl, info.name);</span><br><span class="line">            <span class="comment">//Transport类，继承自ContentProviderNative（Binder服务端）</span></span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">            <span class="comment">//初始化ContentProvider，调用其onCreate方法</span></span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(<span class="keyword">null</span>, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to get provider "</span> + info.name</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取外部ContentProvider</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//对于本地ContentProvider来说，这里的实际类型是Transport，继承自ContentProviderNative（Binder服务端）</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123; <span class="comment">//本地启动ContentProvider的情况</span></span><br><span class="line">            ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">            ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经存在相应的ContentProvider记录，使用其内部已存在的ContentProvider</span></span><br><span class="line">                provider = pr.mProvider;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则使用新创建的ContentProvider</span></span><br><span class="line">                holder = <span class="keyword">new</span> ContentProviderHolder(info);</span><br><span class="line">                holder.provider = provider;</span><br><span class="line">                <span class="comment">//对于本地ContentProvider来说，不存在释放引用这种情况</span></span><br><span class="line">                holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//创建ProviderClientRecord并将其保存到mProviderMap本地缓存中</span></span><br><span class="line">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                <span class="comment">//保存ProviderClientRecord到本地缓存中</span></span><br><span class="line">                mLocalProviders.put(jBinder, pr);</span><br><span class="line">                mLocalProvidersByName.put(cname, pr);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = pr.mHolder;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取远程ContentProvider的情况</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里找到了<code>ContentProvider</code>创建并启动的入口，首先通过传入的<code>Context</code>（实际上就是<code>Application</code>）判断并确定创建并给<code>ContentProvider</code>使用的的<code>Context</code>是什么（一般情况下也是<code>Application</code>），然后获取到应用信息<code>LoadedApk</code>，再通过它得到<code>AppComponentFactory</code>（前面的文章中介绍过，如果没有在<code>AndroidManifest</code>中设置<code>android:appComponentFactory</code>属性，使用的便是默认的<code>AppComponentFactory</code>），接着通过<code>AppComponentFactory.instantiateProvider</code>方法实例化<code>ContentProvider</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ContentProvider <span class="title">instantiateProvider</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ContentProvider) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的话就是通过<code>ClassName</code>反射调用默认构造函数实例化<code>ContentProvider</code>对象，最后再调用<code>ContentProvider.attachInfo</code>方法初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info)</span> </span>&#123;</span><br><span class="line">    attachInfo(context, info, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="keyword">boolean</span> testing)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        ...</span><br><span class="line">        ContentProvider.<span class="keyword">this</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细内容我们就不分析了，只需要知道这里给<code>mContext</code>赋了值，然后调用了<code>ContentProvider.onCreate</code>方法就可以了</p>
<p>到了这一步，<code>ContentProvider</code>就算是启动完成了，接下来需要执行一些安装步骤，其实也就是对缓存等进行一些处理。在<code>ContentProvider</code>实例化后，会调用其<code>getIContentProvider</code>方法给<code>provider</code>变量赋值，这里获得的对象其实是一个<code>Transport</code>对象，继承自<code>ContentProviderNative</code>，是一个<code>Binder</code>服务端对象，在<code>ContentProvider</code>初始化后，会对<code>Transport</code>对象调用<code>asBinder</code>方法获得<code>Binder</code>对象，这里获得的其实还是自己本身，接着从缓存中尝试获取<code>ProviderClientRecord</code>对象，如果获取到了，说明已经存在了相应的<code>ContentProvider</code>，使用<code>ProviderClientRecord</code>内部的<code>ContentProvider</code>，刚刚新创建的那个就可以丢弃了，如果没获取到，就去新建<code>ContentProviderHolder</code>以及<code>ProviderClientRecord</code>，然后将他们添加到各种缓存中，至此，<code>ContentProvider</code>的安装过程也到此结束</p>
<h4 id="获取处理远程ContentProvider"><a href="#获取处理远程ContentProvider" class="headerlink" title="获取处理远程ContentProvider"></a>获取处理远程ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123; <span class="comment">//启动本地ContentProvider</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取外部ContentProvider</span></span><br><span class="line">        <span class="comment">//实际类型为ContentProviderProxy</span></span><br><span class="line">        provider = holder.provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//对于外部ContentProvider来说，这里的实际类型是BinderProxy</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123; <span class="comment">//本地启动ContentProvider的情况</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取远程ContentProvider的情况</span></span><br><span class="line">            ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">            <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123; <span class="comment">//如果ContentProvider引用已存在</span></span><br><span class="line">                <span class="comment">// We need to transfer our new reference to the existing</span></span><br><span class="line">                <span class="comment">// ref count, releasing the old one...  but only if</span></span><br><span class="line">                <span class="comment">// release is needed (that is, it is not running in the</span></span><br><span class="line">                <span class="comment">// system process).</span></span><br><span class="line">                <span class="comment">//对于远程ContentProvider来说，如果目标App为system应用（UID为ROOT_UID或SYSTEM_UID）</span></span><br><span class="line">                <span class="comment">//并且目标App不为设置（包名不为com.android.settings），则noReleaseNeeded为true</span></span><br><span class="line">                <span class="keyword">if</span> (!noReleaseNeeded) &#123;</span><br><span class="line">                    <span class="comment">//增加已存在的ContentProvider引用的引用计数</span></span><br><span class="line">                    incProviderRefLocked(prc, stable);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//释放传入的引用，移除ContentProviderConnection相关信息，更新引用计数</span></span><br><span class="line">                        ActivityManager.getService().removeContentProvider(</span><br><span class="line">                                holder.connection, stable);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//创建ProviderClientRecord并将其保存到mProviderMap本地缓存中</span></span><br><span class="line">                ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                        provider, localProvider, holder);</span><br><span class="line">                <span class="keyword">if</span> (noReleaseNeeded) &#123; <span class="comment">//同上，目标App为system应用，不需要释放引用</span></span><br><span class="line">                    <span class="comment">//新建一个ProviderRefCount，但引用计数初始化为一个较大的数值</span></span><br><span class="line">                    <span class="comment">//这样后续无论调用方进程的ContentProvider引用计数如何变动都不会影响到AMS</span></span><br><span class="line">                    prc = <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//需要释放引用的情况下</span></span><br><span class="line">                    <span class="comment">//正常的新建初始化一个ProviderRefCount</span></span><br><span class="line">                    prc = stable</span><br><span class="line">                            ? <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                            : <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//保存至缓存</span></span><br><span class="line">                mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = prc.holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>holder.provider</code>不为<code>null</code>的情况，直接获取远程<code>ContentProvider</code>引用，然后进行处理就可以了。这里获取到的<code>IContentProvider</code>的实际类型是<code>ContentProviderProxy</code>，然后对其调用<code>asBinder</code>方法，获取到的是<code>BinderProxy</code>对象，接着从缓存中尝试获取<code>ProviderRefCount</code>对象，如果缓存中已经有相应的引用对象了，则在需要释放引用（<code>!noReleaseNeeded</code>）的情况下使用原有的引用，释放参数传入进来的<code>ContentProvider</code>引用</p>
<p>这里<code>noReleaseNeeded</code>是在<code>ContentProviderRecord</code>构造时赋值的，为<code>true</code>的条件是目标App为system应用（<code>UID</code>为<code>ROOT_UID</code>或<code>SYSTEM_UID</code>）并且目标App不为设置（包名不为<code>com.android.settings</code>）</p>
<p>如果缓存中没有查找到相应的<code>ProviderRefCount</code>对象，新建<code>ProviderClientRecord</code>和<code>ProviderRefCount</code>对象，并将他们保存到缓存中，至于为什么在<code>noReleaseNeeded</code>的情况下，新建的<code>ProviderRefCount</code>的引用计数初始值为1000，我猜测是因为<code>noReleaseNeeded</code>代表了不需要释放引用，所以这里干脆设置一个比较大的值，这样无论调用方进程的<code>ContentProvider</code>引用计数怎样变动，都不会再调用到<code>AMS</code>的方法中去处理引用的变化，在非常早期的<code>Android</code>版本中（<code>Android 4.0.1</code>），这个值曾被设置为<code>10000</code></p>
<p>至此，远程<code>ContentProvider</code>的安装也结束了</p>
<h4 id="ActivityThread-installProviderAuthoritiesLocked"><a href="#ActivityThread-installProviderAuthoritiesLocked" class="headerlink" title="ActivityThread.installProviderAuthoritiesLocked"></a>ActivityThread.installProviderAuthoritiesLocked</h4><p>接下来我们再简单的看一下两种case都会走到的<code>installProviderAuthoritiesLocked</code>方法吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProviderClientRecord <span class="title">installProviderAuthoritiesLocked</span><span class="params">(IContentProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProvider localProvider, ContentProviderHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String auths[] = holder.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(holder.info.applicationInfo.uid);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ProviderClientRecord pcr = <span class="keyword">new</span> ProviderClientRecord(</span><br><span class="line">            auths, provider, localProvider, holder);</span><br><span class="line">    <span class="keyword">for</span> (String auth : auths) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord existing = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Content provider "</span> + pcr.mHolder.info.name</span><br><span class="line">                    + <span class="string">" already published as "</span> + auth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProviderMap.put(key, pcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，新建了一个<code>ProviderClientRecord</code>并将其添加到<code>mProviderMap</code>缓存中，这里的操作对应着最前面的<code>acquireExistingProvider</code>方法，有了这个缓存，以后就可以直接拿，而不用再复杂的经过一系列的<code>AMS</code>跨进程操作了</p>
<h3 id="AMS-publishContentProviders"><a href="#AMS-publishContentProviders" class="headerlink" title="AMS.publishContentProviders"></a>AMS.publishContentProviders</h3><p><code>ContentProvider</code>全部启动安装完后，便要调用<code>AMS.publishContentProviders</code>将他们发布出去，供外部使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                    + <span class="string">") when publishing content providers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ContentProviderHolder src = providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//App进程启动时或AMS.getContentProvider中已经将相应ContentProviderRecord添加到了pubProviders中</span></span><br><span class="line">            ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//保存至缓存中</span></span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ContentProvider已经启动完毕，将其从正在启动的ContentProvider列表中移除</span></span><br><span class="line">                <span class="keyword">int</span> launchingCount = mLaunchingProviders.size();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">boolean</span> wasInLaunchingProviders = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        wasInLaunchingProviders = <span class="keyword">true</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                        launchingCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除ContentProvider启动超时监听</span></span><br><span class="line">                <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                    mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Make sure the package is associated with the process.</span></span><br><span class="line">                <span class="comment">// XXX We shouldn't need to do this, since we have added the package</span></span><br><span class="line">                <span class="comment">// when we generated the providers in generateApplicationProvidersLocked().</span></span><br><span class="line">                <span class="comment">// But for some reason in some cases we get here with the package no longer</span></span><br><span class="line">                <span class="comment">// added...  for now just patch it in to make things happy.</span></span><br><span class="line">                r.addPackage(dst.info.applicationInfo.packageName,</span><br><span class="line">                        dst.info.applicationInfo.longVersionCode, mProcessStats);</span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.setProcess(r);</span><br><span class="line">                    <span class="comment">//让出锁，通知其他wait的地方</span></span><br><span class="line">                    <span class="comment">//对应着AMS.getContentProvider的第四部分：等待ContentProvider启动完成</span></span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                dst.mRestartCount = <span class="number">0</span>;</span><br><span class="line">                updateOomAdjLocked(r, <span class="keyword">true</span>, OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER);</span><br><span class="line">                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                        src.info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历整个待发布的<code>ContentProvider</code>列表，从<code>ProcessRecord.pubProviders</code>中查找相对应的<code>ContentProviderRecord</code>，我们在之前的章节中已经分析过了，App进程启动时或<code>AMS.getContentProvider</code>中已经将相应<code>ContentProviderRecord</code>添加到了<code>pubProviders</code>中，然后就是将其保存到各个缓存中，由于<code>ContentProvider</code>已经启动完毕，所以需要将其从正在启动的<code>ContentProvider</code>列表中移除，在<code>ContentProvider</code>正常启动的情况下，我们需要将<code>ContentProvider</code>的启动超时监听移除，最后，获取<code>ContentProviderRecord</code>同步锁，将准备好的<code>ContentProvider</code>赋值到<code>ContentProviderRecord</code>中，接着调用<code>notifyAll</code>方法通知其他调用过<code>wait</code>的地方，将锁让出，这里对应的就是<code>AMS.getContentProvider</code>的第四部分：等待<code>ContentProvider</code>启动完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//这里的cpr和在publishContentProviders获得的dst是一个对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//释放锁，等待ContentProvider启动完成</span></span><br><span class="line">            cpr.wait(wait);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>ContentProvider</code>一发布，这里就会收到通知，解除<code>wait</code>状态，获得到<code>ContentProvider</code>，返回出去，是不是感觉一切都串起来了？</p>
<h1 id="ContentProvider引用计数"><a href="#ContentProvider引用计数" class="headerlink" title="ContentProvider引用计数"></a>ContentProvider引用计数</h1><p><code>ContentProvider</code>的获取与启动分析完了，接下来我们聊聊它的引用计数，为下一小节分析<code>ContentProvider</code>死亡杀死调用方进程的过程做准备</p>
<p><code>ActivityThread</code>层的引用计数是和<code>AMS</code>层的引用计数分开的，<code>ActivityThread</code>记录的是目标<code>ContentProvider</code>在本进程中有多少处正在使用，而<code>AMS</code>记录的是目标<code>ContentProvider</code>正在被多少个进程使用</p>
<h2 id="ActivityThread层的引用计数"><a href="#ActivityThread层的引用计数" class="headerlink" title="ActivityThread层的引用计数"></a>ActivityThread层的引用计数</h2><h3 id="增加引用计数"><a href="#增加引用计数" class="headerlink" title="增加引用计数"></a>增加引用计数</h3><p>我们先从<code>ActivityThread</code>层增加引用计数开始说起，在<code>ActivityThread</code>获取<code>ContentProvider</code>时，便会调用<code>incProviderRefLocked</code>方法来增加引用计数，具体的时机为<code>acquireExistingProvider</code>或<code>installProvider</code>时，代码我就不重复放了，大家看前面几个小节就行（后同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incProviderRefLocked</span><span class="params">(ProviderRefCount prc, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">        <span class="comment">//增加ActivityThread的stable引用计数</span></span><br><span class="line">        prc.stableCount += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//本进程对目标ContentProvider产生了stable引用关系</span></span><br><span class="line">        <span class="keyword">if</span> (prc.stableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// We are acquiring a new stable reference on the provider.</span></span><br><span class="line">            <span class="keyword">int</span> unstableDelta;</span><br><span class="line">            <span class="comment">//正在移除ContentProvider引用中（释放ContentProvider后发现stable和unstable引用计数均为0）</span></span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// We have a pending remove operation, which is holding the</span></span><br><span class="line">                <span class="comment">// last unstable reference.  At this point we are converting</span></span><br><span class="line">                <span class="comment">// that unstable reference to our new stable reference.</span></span><br><span class="line">                <span class="comment">//当ActivityThread释放一个stable的ContentProvider时，如果释放完后，</span></span><br><span class="line">                <span class="comment">//发现stable和unstable引用计数均为0，则会暂时保留一个unstable引用</span></span><br><span class="line">                <span class="comment">//所以这里需要为 -1 ，将这个unstable引用移除</span></span><br><span class="line">                unstableDelta = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// Cancel the removal of the provider.</span></span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// There is a race! It fails to remove the message, which</span></span><br><span class="line">                <span class="comment">// will be handled in completeRemoveProvider().</span></span><br><span class="line">                <span class="comment">//取消移除ContentProvider引用</span></span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对于正常情况，只需要增加stable引用计数，不需要动unstable引用计数</span></span><br><span class="line">                unstableDelta = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//AMS层修改引用计数</span></span><br><span class="line">                ActivityManager.getService().refContentProvider(</span><br><span class="line">                        prc.holder.connection, <span class="number">1</span>, unstableDelta);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//增加ActivityThread的unstable引用计数</span></span><br><span class="line">        prc.unstableCount += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//本进程对目标ContentProvider产生了unstable引用关系</span></span><br><span class="line">        <span class="keyword">if</span> (prc.unstableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// We are acquiring a new unstable reference on the provider.</span></span><br><span class="line">            <span class="comment">//正在移除ContentProvider引用中（释放ContentProvider后发现stable和unstable引用计数均为0）</span></span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// Oh look, we actually have a remove pending for the</span></span><br><span class="line">                <span class="comment">// provider, which is still holding the last unstable</span></span><br><span class="line">                <span class="comment">// reference.  We just need to cancel that to take new</span></span><br><span class="line">                <span class="comment">// ownership of the reference.</span></span><br><span class="line">                <span class="comment">//取消移除ContentProvider引用</span></span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// First unstable ref, increment our count in the</span></span><br><span class="line">                <span class="comment">// activity manager.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//增加AMS层的unstable引用计数</span></span><br><span class="line">                    ActivityManager.getService().refContentProvider(</span><br><span class="line">                            prc.holder.connection, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑需要配合着<code>ContentProvider</code>释放引用那里一起看才好理解，我先提前解释一下</p>
<p>首先，<code>removePending</code>这个变量表示此<code>ContentProvider</code>正在移除中，当<code>ActivityThread</code>减少引用计数，检查到<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>后被赋值为<code>true</code>，并且会向<code>Handler</code>发送一条<code>what</code>值为<code>REMOVE_PROVIDER</code>的延时消息，在一定时间后便会触发<code>ContentProvider</code>移除操作，清理本地缓存，再将<code>removePending</code>重新置为<code>false</code>，所以当这里<code>removePending</code>为<code>true</code>则说明此<code>ContentProvider</code>还没完全被移除，我们把这个消息取消掉继续使用这个<code>ContentProvider</code></p>
<p>对于<code>stable</code>引用的情况下，当<code>ActivityThread</code>减少引用计数，检查到<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>后，会暂时保留一个<code>unstable</code>引用，等到后面真正触发到了移除<code>ContentProvider</code>的时候再将这个<code>unstable</code>引用移除，所以在增加引用计数的时候需要考虑到这一点，在这种情况下要将<code>AMS</code>层的<code>unstable</code>引用计数减一</p>
<p>对于其他的情况就是正常的增加<code>ActivityThread</code>层引用计数，然后调用<code>AMS.refContentProvider</code>方法操作<code>AMS</code>层的引用计数</p>
<h3 id="减少引用计数"><a href="#减少引用计数" class="headerlink" title="减少引用计数"></a>减少引用计数</h3><p><code>ContentProvider</code>使用完后会调用<code>ActivityThread.releaseProvider</code>方法，以<code>query</code>方法为例，最后会调用<code>releaseUnstableProvider</code>和<code>releaseProvider</code>方法，最终都会走到这里来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseProvider</span><span class="params">(IContentProvider provider, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder jBinder = provider.asBinder();</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The provider has no ref count, no release is needed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> lastRef = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            <span class="comment">//引用计数已经为0，无法再减了</span></span><br><span class="line">            <span class="keyword">if</span> (prc.stableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减少ActivityThread的stable引用计数</span></span><br><span class="line">            prc.stableCount -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (prc.stableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// What we do at this point depends on whether there are</span></span><br><span class="line">                <span class="comment">// any unstable refs left: if there are, we just tell the</span></span><br><span class="line">                <span class="comment">// activity manager to decrement its stable count; if there</span></span><br><span class="line">                <span class="comment">// aren't, we need to enqueue this provider to be removed,</span></span><br><span class="line">                <span class="comment">// and convert to holding a single unstable ref while</span></span><br><span class="line">                <span class="comment">// doing so.</span></span><br><span class="line">                lastRef = prc.unstableCount == <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果是最后的引用，则暂时保留一个unstable引用</span></span><br><span class="line">                    ActivityManager.getService().refContentProvider(</span><br><span class="line">                            prc.holder.connection, -<span class="number">1</span>, lastRef ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//引用计数已经为0，无法再减了</span></span><br><span class="line">            <span class="keyword">if</span> (prc.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减少ActivityThread的unstable引用计数</span></span><br><span class="line">            prc.unstableCount -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (prc.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this is the last reference, we need to enqueue</span></span><br><span class="line">                <span class="comment">// this provider to be removed instead of telling the</span></span><br><span class="line">                <span class="comment">// activity manager to remove it at this point.</span></span><br><span class="line">                lastRef = prc.stableCount == <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果是最后的引用，则不进入到这里，暂时保留一个unstable引用</span></span><br><span class="line">                <span class="keyword">if</span> (!lastRef) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//减少AMS引用计数</span></span><br><span class="line">                        ActivityManager.getService().refContentProvider(</span><br><span class="line">                                prc.holder.connection, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastRef) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// Schedule the actual remove asynchronously, since we don't know the context</span></span><br><span class="line">                <span class="comment">// this will be called in.</span></span><br><span class="line">                <span class="comment">//表面此ContentProvider正在移除中</span></span><br><span class="line">                prc.removePending = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//发送延时消息，等待一定时间后移除ContentProvider</span></span><br><span class="line">                Message msg = mH.obtainMessage(H.REMOVE_PROVIDER, prc);</span><br><span class="line">                mH.sendMessageDelayed(msg, CONTENT_PROVIDER_RETAIN_TIME);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Duplicate remove pending of provider "</span> + prc.holder.info.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在减完引用计数后，如果发现是最后一个引用，即<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>，此时无论是<code>stable</code>还是<code>unstable</code>都会让<code>AMS</code>暂时保留一个<code>unstable</code>引用，然后发送一条<code>what</code>值为<code>REMOVE_PROVIDER</code>的延时消息，等待一定时间后移除<code>ContentProvider</code>，当时间到了触发这条消息时，会调用到<code>ActivityThread.completeRemoveProvider</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">completeRemoveProvider</span><span class="params">(ProviderRefCount prc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prc.removePending) &#123;</span><br><span class="line">            <span class="comment">// There was a race!  Some other client managed to acquire</span></span><br><span class="line">            <span class="comment">// the provider before the removal was completed.</span></span><br><span class="line">            <span class="comment">// Abort the removal.  We will do it later.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// More complicated race!! Some client managed to acquire the</span></span><br><span class="line">        <span class="comment">// provider and release it before the removal was completed.</span></span><br><span class="line">        <span class="comment">// Continue the removal, and abort the next remove message.</span></span><br><span class="line">        prc.removePending = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">final</span> IBinder jBinder = prc.holder.provider.asBinder();</span><br><span class="line">        ProviderRefCount existingPrc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (existingPrc == prc) &#123;</span><br><span class="line">            mProviderRefCountMap.remove(jBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mProviderMap.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProviderClientRecord pr = mProviderMap.valueAt(i);</span><br><span class="line">            IBinder myBinder = pr.mProvider.asBinder();</span><br><span class="line">            <span class="keyword">if</span> (myBinder == jBinder) &#123;</span><br><span class="line">                mProviderMap.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//处理AMS层引用计数</span></span><br><span class="line">        ActivityManager.getService().removeContentProvider(</span><br><span class="line">                prc.holder.connection, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将进程内所持有的<code>ContentProvider</code>相关缓存清除，然后调用<code>AMS.removeContentProvider</code>方法通知<code>AMS</code>移除<code>ContentProvider</code>，处理相应的引用计数。这里我们发现，调用<code>AMS.removeContentProvider</code>方法传入的最后一个参数<code>stable</code>为<code>false</code>，因为我们之前在<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>的情况下，保留了一个<code>unstable</code>引用，所以这时移除的<code>ContentProvider</code>引用也是<code>unstable</code>引用</p>
<h2 id="AMS层的引用计数"><a href="#AMS层的引用计数" class="headerlink" title="AMS层的引用计数"></a>AMS层的引用计数</h2><p>接着我们来看<code>AMS</code>层的引用计数</p>
<h3 id="AMS-refContentProvider"><a href="#AMS-refContentProvider" class="headerlink" title="AMS.refContentProvider"></a>AMS.refContentProvider</h3><p>我们就先从我们刚刚分析的<code>ActivityThread</code>层的引用计数修改后续：<code>refContentProvider</code> 看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refContentProvider</span><span class="params">(IBinder connection, <span class="keyword">int</span> stable, <span class="keyword">int</span> unstable)</span> </span>&#123;</span><br><span class="line">    ContentProviderConnection conn;</span><br><span class="line">    ...</span><br><span class="line">    conn = (ContentProviderConnection)connection;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn.numStableIncs += stable;</span><br><span class="line">        &#125;</span><br><span class="line">        stable = conn.stableCount + stable;</span><br><span class="line">        <span class="keyword">if</span> (stable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"stableCount &lt; 0: "</span> + stable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unstable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn.numUnstableIncs += unstable;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable = conn.unstableCount + unstable;</span><br><span class="line">        <span class="keyword">if</span> (unstable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unstableCount &lt; 0: "</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((stable+unstable) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ref counts can't go to zero here: stable="</span></span><br><span class="line">                    + stable + <span class="string">" unstable="</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.stableCount = stable;</span><br><span class="line">        conn.unstableCount = unstable;</span><br><span class="line">        <span class="keyword">return</span> !conn.dead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，应该不需要再多做分析了吧？就是简单的修改<code>ContentProviderConnection</code>的引用计数值</p>
<h3 id="AMS-incProviderCountLocked"><a href="#AMS-incProviderCountLocked" class="headerlink" title="AMS.incProviderCountLocked"></a>AMS.incProviderCountLocked</h3><p>接下来我们看<code>AMS</code>层引用计数的增加，<code>AMS.incProviderCountLocked</code>这个方法的触发时机是在<code>AMS.getContentProviderImpl</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ContentProviderConnection <span class="title">incProviderCountLocked</span><span class="params">(ProcessRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, String callingTag, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r.conProviders.size(); i++) &#123;</span><br><span class="line">            ContentProviderConnection conn = r.conProviders.get(i);</span><br><span class="line">            <span class="comment">//如果连接已存在，在其基础上增加引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (conn.provider == cpr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">                    conn.stableCount++;</span><br><span class="line">                    conn.numStableIncs++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    conn.unstableCount++;</span><br><span class="line">                    conn.numUnstableIncs++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建ContentProviderConnection连接</span></span><br><span class="line">        ContentProviderConnection conn = <span class="keyword">new</span> ContentProviderConnection(cpr, r, callingPackage);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        conn.startAssociationIfNeeded();</span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numStableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numUnstableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加连接</span></span><br><span class="line">        cpr.connections.add(conn);</span><br><span class="line">        r.conProviders.add(conn);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        startAssociationLocked(r.uid, r.processName, r.getCurProcState(),</span><br><span class="line">                cpr.uid, cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.addExternalProcessHandleLocked(externalProcessToken, callingUid, callingTag);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用方进程已存在对应<code>ContentProviderConnection</code>连接，则在其基础上增加引用计数，否则新建连接，然后初始化引用计数值</p>
<h3 id="AMS-decProviderCountLocked"><a href="#AMS-decProviderCountLocked" class="headerlink" title="AMS.decProviderCountLocked"></a>AMS.decProviderCountLocked</h3><p>然后是减少引用计数，之前在<code>ActivityThread</code>减引用到0后，会延时调用<code>ActivityThread.completeRemoveProvider</code>方法，在这个方法中会调用到<code>AMS.removeContentProvider</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContentProvider</span><span class="params">(IBinder connection, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ContentProviderConnection conn = (ContentProviderConnection)connection;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//减少引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (decProviderCountLocked(conn, <span class="keyword">null</span>, <span class="keyword">null</span>, stable)) &#123;</span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_REMOVE_PROVIDER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中便会调用<code>AMS.decProviderCountLocked</code>减少引用计数，然后更新进程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">decProviderCountLocked</span><span class="params">(ContentProviderConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cpr = conn.provider;</span><br><span class="line">        <span class="comment">//减少引用计数值</span></span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount == <span class="number">0</span> &amp;&amp; conn.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//停止关联</span></span><br><span class="line">            conn.stopAssociation();</span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            cpr.connections.remove(conn);</span><br><span class="line">            conn.client.conProviders.remove(conn);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.setProcState &lt; PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                <span class="comment">// The client is more important than last activity -- note the time this</span></span><br><span class="line">                <span class="comment">// is happening, so we keep the old provider process around a bit as last</span></span><br><span class="line">                <span class="comment">// activity to avoid thrashing it.</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cpr.proc.lastProviderTime = SystemClock.uptimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//停止关联</span></span><br><span class="line">            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid,</span><br><span class="line">                    cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.removeExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减少引用计数值，如果<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>，则将这个连接移除</p>
<h1 id="ContentProvider死亡杀死调用方进程的过程"><a href="#ContentProvider死亡杀死调用方进程的过程" class="headerlink" title="ContentProvider死亡杀死调用方进程的过程"></a>ContentProvider死亡杀死调用方进程的过程</h1><p>我们前面提到过，<code>ContentProvider</code>所在进程死亡会将与其所有有<code>stable</code>关联的调用方进程杀死，这是怎么做到的呢？在之前的文章中，我们介绍过进程启动时，在调用<code>AMS.attachApplicationLocked</code>时会注册一个App进程死亡回调，我们就从进程死亡，触发死亡回调开始分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册App进程死亡回调</span></span><br><span class="line">    AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</span><br><span class="line">            app, pid, thread);</span><br><span class="line">    thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">    app.deathRecipient = adr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册了死亡回调后，如果对应<code>binder</code>进程死亡，便会回调<code>IBinder.DeathRecipient.binderDied</code>方法，我们来看一下<code>AppDeathRecipient</code>对这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</span><br><span class="line"></span><br><span class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</span><br><span class="line">            IApplicationThread thread) &#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mPid = pid;</span><br><span class="line">        mAppThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接转手调用<code>AMS.appDiedLocked</code>方法，然后经过<code>handleAppDiedLocked</code>调用到<code>cleanUpApplicationRecordLocked</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> restart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove published content providers.</span></span><br><span class="line">    <span class="comment">//清除已发布的ContentProvider</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.pubProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderRecord cpr = app.pubProviders.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cpr.proc != app) &#123;</span><br><span class="line">            <span class="comment">// If the hosting process record isn't really us, bail out</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> alwaysRemove = app.bad || !allowRestart;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> inLaunching = removeDyingProviderLocked(app, cpr, alwaysRemove);</span><br><span class="line">        <span class="keyword">if</span> (!alwaysRemove &amp;&amp; inLaunching &amp;&amp; cpr.hasConnectionOrHandle()) &#123;</span><br><span class="line">            <span class="comment">// We left the provider in the launching list, need to</span></span><br><span class="line">            <span class="comment">// restart it.</span></span><br><span class="line">            restart = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cpr.provider = <span class="keyword">null</span>;</span><br><span class="line">        cpr.setProcess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    app.pubProviders.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of any launching providers waiting for this process.</span></span><br><span class="line">    <span class="comment">//清除正在启动中的ContentProvider</span></span><br><span class="line">    <span class="keyword">if</span> (cleanupAppInLaunchingProvidersLocked(app, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        mProcessList.noteProcessDiedLocked(app);</span><br><span class="line">        restart = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unregister from connected content providers.</span></span><br><span class="line">    <span class="comment">//清除已连接的ContentProvider</span></span><br><span class="line">    <span class="keyword">if</span> (!app.conProviders.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = app.conProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ContentProviderConnection conn = app.conProviders.get(i);</span><br><span class="line">            conn.provider.connections.remove(conn);</span><br><span class="line">            stopAssociationLocked(app.uid, app.processName, conn.provider.uid,</span><br><span class="line">                    conn.provider.appInfo.longVersionCode, conn.provider.name,</span><br><span class="line">                    conn.provider.info.processName);</span><br><span class="line">        &#125;</span><br><span class="line">        app.conProviders.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法中遍历了<code>ProcessRecord.pubProviders</code>，逐个对发布的<code>ContentProvider</code>调用<code>removeDyingProviderLocked</code>方法执行移除操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">removeDyingProviderLocked</span><span class="params">(ProcessRecord proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderRecord cpr, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inLaunching = mLaunchingProviders.contains(cpr);</span><br><span class="line">    <span class="keyword">if</span> (inLaunching &amp;&amp; !always &amp;&amp; ++cpr.mRestartCount &gt; ContentProviderRecord.MAX_RETRY_COUNT) &#123;</span><br><span class="line">        <span class="comment">// It's being launched but we've reached maximum attempts, force the removal</span></span><br><span class="line">        always = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inLaunching || always) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">            cpr.launchingApp = <span class="keyword">null</span>;</span><br><span class="line">            cpr.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(cpr.uid);</span><br><span class="line">        <span class="comment">// Don't remove from provider map if it doesn't match</span></span><br><span class="line">        <span class="comment">// could be a new content provider is starting</span></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">if</span> (mProviderMap.getProviderByClass(cpr.name, userId) == cpr) &#123;</span><br><span class="line">            mProviderMap.removeProviderByClass(cpr.name, userId);</span><br><span class="line">        &#125;</span><br><span class="line">        String names[] = cpr.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            <span class="comment">// Don't remove from provider map if it doesn't match</span></span><br><span class="line">            <span class="comment">// could be a new content provider is starting</span></span><br><span class="line">            <span class="comment">//移除缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mProviderMap.getProviderByName(names[j], userId) == cpr) &#123;</span><br><span class="line">                mProviderMap.removeProviderByName(names[j], userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cpr.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">        <span class="keyword">if</span> (conn.waiting) &#123;</span><br><span class="line">            <span class="comment">// If this connection is waiting for the provider, then we don't</span></span><br><span class="line">            <span class="comment">// need to mess with its process unless we are always removing</span></span><br><span class="line">            <span class="comment">// or for some reason the provider is not currently launching.</span></span><br><span class="line">            <span class="keyword">if</span> (inLaunching &amp;&amp; !always) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord capp = conn.client;</span><br><span class="line">        conn.dead = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!capp.isPersistent() &amp;&amp; capp.thread != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; capp.pid != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; capp.pid != MY_PID) &#123;</span><br><span class="line">                <span class="comment">//当调用方与被杀死的目标ContentProvider进程间有stable连接</span></span><br><span class="line">                <span class="comment">//并且调用方App进程非persistent进程并且非system_server进程中的情况下</span></span><br><span class="line">                <span class="comment">//杀死调用方进程</span></span><br><span class="line">                capp.kill(<span class="string">"depends on provider "</span></span><br><span class="line">                        + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" in dying proc "</span> + (proc != <span class="keyword">null</span> ? proc.processName : <span class="string">"??"</span>)</span><br><span class="line">                        + <span class="string">" (adj "</span> + (proc != <span class="keyword">null</span> ? proc.setAdj : <span class="string">"??"</span>) + <span class="string">")"</span>,</span><br><span class="line">                        ApplicationExitInfo.REASON_DEPENDENCY_DIED,</span><br><span class="line">                        ApplicationExitInfo.SUBREASON_UNKNOWN,</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capp.thread != <span class="keyword">null</span> &amp;&amp; conn.provider.provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知调用方移除ContentProvider</span></span><br><span class="line">                capp.thread.unstableProviderDied(conn.provider.provider.asBinder());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In the protocol here, we don't expect the client to correctly</span></span><br><span class="line">            <span class="comment">// clean up this connection, we'll just remove it.</span></span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            cpr.connections.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.conProviders.remove(conn)) &#123;</span><br><span class="line">                stopAssociationLocked(capp.uid, capp.processName, cpr.uid,</span><br><span class="line">                        cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inLaunching &amp;&amp; always) &#123;</span><br><span class="line">        mLaunchingProviders.remove(cpr);</span><br><span class="line">        cpr.mRestartCount = <span class="number">0</span>;</span><br><span class="line">        inLaunching = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inLaunching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法中遍历了<code>ContentProvider</code>下的所有连接，当发现有其他进程与自己建立了<code>stable</code>连接（<code>conn.stableCount &gt; 0</code>），且调用方进程不是<code>persistent</code>进程（常驻进程，只有拥有系统签名的App设置这个属性才生效），也不是运行在<code>system_server</code>进程，调用<code>ProcessRecord.kill</code>方法直接杀死进程，对于没有建立<code>stable</code>连接的调用方进程，调用<code>IApplicationThread.unstableProviderDied</code>方法通知调用方进程移除相应的<code>ContentProvider</code></p>
<p>所以，使用<code>ContentProvider</code>是有一定风险的，大家要注意规避</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个<code>Framework</code>层关于<code>ContentProvider</code>的内容应该都分析完了，希望大家看完后能获得一些收获，接下来的文章应该会去分析<code>Service</code>相关源码，敬请期待~</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/ContentProvider/">ContentProvider</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/07/31/android/view/%E8%B0%88%E8%B0%88Android%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9C%86%E8%A7%92/"><i class="fa fa-chevron-left">  </i><span>谈谈Android如何实现不同大小的圆角</span></a></div><div class="next-post pull-right"><a href="/2023/06/06/AI/AI%E4%BA%BA%E5%A3%B0/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/"><span>有手就行！Sovits AI人声模型训练</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>