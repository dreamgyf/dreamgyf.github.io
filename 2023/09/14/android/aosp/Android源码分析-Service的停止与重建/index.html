<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Service的停止与重建"><meta name="keywords" content="Android源码,ActivityManagerService,Service"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Service的停止与重建 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程图"><span class="toc-number">2.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#主动停止"><span class="toc-number">3.</span> <span class="toc-text">主动停止</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-stopSelf-或-Service-stopSelfResult"><span class="toc-number">3.1.</span> <span class="toc-text">Service.stopSelf 或 Service.stopSelfResult</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#startId机制"><span class="toc-number">3.1.1.</span> <span class="toc-text">startId机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stopService"><span class="toc-number">3.2.</span> <span class="toc-text">stopService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unbindService"><span class="toc-number">3.3.</span> <span class="toc-text">unbindService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rebind流程"><span class="toc-number">4.</span> <span class="toc-text">rebind流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#混合启动的Service该如何停止"><span class="toc-number">5.</span> <span class="toc-text">混合启动的Service该如何停止</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#小测验"><span class="toc-number">6.</span> <span class="toc-text">小测验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#被动停止"><span class="toc-number">7.</span> <span class="toc-text">被动停止</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用户手动从最近任务移除Task"><span class="toc-number">7.1.</span> <span class="toc-text">用户手动从最近任务移除Task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存不足"><span class="toc-number">7.2.</span> <span class="toc-text">内存不足</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重建"><span class="toc-number">8.</span> <span class="toc-text">重建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Service的停止与重建</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Service/">Service</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在上一篇文章 <a href="https://juejin.cn/post/7276363520554795064" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中，我们分析了一个<code>Service</code>是怎么启动的，这次我们再来看看一个<code>Service</code>是如何被停止的，什么情况下<code>Service</code>会被重建以及它的重建过程</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>由于<code>Service</code>的停止与重建在实际情况下会收到各种条件影响产生不同的情况，所以这里的流程图我也只画最简路径，以供大家参考</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E4%B8%BB%E5%8A%A8%E5%81%9C%E6%AD%A2%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service主动停止流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E4%B8%BB%E5%8A%A8%E8%A7%A3%E7%BB%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service主动解绑流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_Task%E7%A7%BB%E9%99%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Task移除流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E9%87%8D%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service重建流程图"></p>
<h1 id="主动停止"><a href="#主动停止" class="headerlink" title="主动停止"></a>主动停止</h1><p>首先，我们来看主动停止的情况，主动停止也分三种：</p>
<ul>
<li><p><code>Service</code>自己调用<code>stopSelf</code>或<code>stopSelfResult</code>方法停止</p>
</li>
<li><p>使用<code>startService</code>启动的<code>Service</code>，使用<code>stopService</code>方法停止</p>
</li>
<li><p>使用<code>bindService</code>启动的<code>Service</code>，使用<code>unbindService</code>方法解除绑定，当没有任何<code>Client</code>和<code>Service</code>绑定时，<code>Service</code>就会自行停止</p>
</li>
</ul>
<h2 id="Service-stopSelf-或-Service-stopSelfResult"><a href="#Service-stopSelf-或-Service-stopSelfResult" class="headerlink" title="Service.stopSelf 或 Service.stopSelfResult"></a>Service.stopSelf 或 Service.stopSelfResult</h2><p><code>stopSelf</code>和<code>stopSelfResult</code>方法唯一的区别是一个没返回值，一个会返回是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Service.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopSelf(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">stopSelfResult</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也是直接调用了<code>AMS.stopServiceToken</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopServiceToken</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceTokenLocked(className, token, startId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>AMS</code>转手调用了<code>ActiveServices.stopServiceTokenLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stopServiceTokenLocked</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过className查找相应的ServiceRecord</span></span><br><span class="line">    <span class="comment">//在Service启动过程中调用的retrieveServiceLocked方法会查找Service，创建ServiceRecord</span></span><br><span class="line">    <span class="comment">//并将其添加到Map中，findServiceLocked方法只需要从这个Map中去获取即可</span></span><br><span class="line">    ServiceRecord r = findServiceLocked(className, token, UserHandle.getCallingUserId());</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Asked to only stop if done with all work.  Note that</span></span><br><span class="line">            <span class="comment">// to avoid leaks, we will take this as dropping all</span></span><br><span class="line">            <span class="comment">// start items up to and including this one.</span></span><br><span class="line">            <span class="comment">//查找startId所对应的已分发的启动项</span></span><br><span class="line">            ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//从已分发启动请求列表中移除</span></span><br><span class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r.deliveredStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ServiceRecord.StartItem cur = r.deliveredStarts.remove(<span class="number">0</span>);</span><br><span class="line">                    cur.removeUriPermissionsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (cur == si) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果传入的启动ID不是Service最后一次启动的ID，则不能停止服务</span></span><br><span class="line">            <span class="comment">//ps：每次启动Service，startId都会递增，初始值为1</span></span><br><span class="line">            <span class="keyword">if</span> (r.getLastStartId() != startId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//重置启动状态（重要，后文中会分析）</span></span><br><span class="line">        r.startRequested = <span class="keyword">false</span>;</span><br><span class="line">        r.callStart = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//接着停止Service</span></span><br><span class="line">        bringDownServiceIfNeededLocked(r, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startId机制"><a href="#startId机制" class="headerlink" title="startId机制"></a>startId机制</h3><p>这里要说一下<code>Service</code>的<code>startId</code>机制，每次启动<code>Service</code>时，<code>ActiveServices.startServiceLocked</code>方法会向<code>ServiceRecord.pendingStarts</code>列表中添加一个启动项<code>ServiceRecord.StartItem</code>，构建这个启动项需要提供一个<code>startId</code>，而这个<code>startId</code>是由<code>ServiceRecord.makeNextStartId</code>生成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeNextStartId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastStartId++;</span><br><span class="line">    <span class="keyword">if</span> (lastStartId &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        lastStartId = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastStartId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>lastStartId</code>的初始值为 0 ，所以第一次调用这个方法，得到的<code>startId</code>就是 1 ，即<code>startId</code>是从 1 开始递增的，由于当<code>Service</code>被停止后，<code>ServiceRecord</code>会从之前的缓存Map中移除，所以下一次再启动<code>Service</code>时会重新创建<code>ServiceRecord</code>，<code>startId</code>会被重置</p>
<p>当我们调用<code>stopSelf</code>停止服务时，如果传入了大于等于 0 的<code>startId</code>，此时便会判断这个<code>startId</code>是不是最后一次启动所对应的<code>startId</code>，如果不是的话，则不能停止这个<code>Service</code></p>
<p>这个<code>startId</code>设计的意义是什么呢？我们从<code>IntentService</code>的设计中可以管中窥豹：</p>
<p><code>IntentService</code>是一个运行在另一个线程的，每次处理完任务都会自动停止的<code>Service</code>，但如果你调用多次<code>startService</code>会发现，<code>IntentService.onDestroy</code>方法只会调用一次，这是为什么呢？因为<code>IntentService</code>每次停止，调用<code>stopSelf</code>方法都是带上这次启动的<code>startId</code>的，这样如果一次性有多个启动请求，前面的任务执行完，停止时发现，此次启动请求的<code>startId</code>不是最后一个<code>startId</code>，这样就不会停止掉自身，直到最后一个任务处理完成，避免了<code>Service</code>的多次停止启动消耗系统资源</p>
<hr>
<p>接着，在这个方法的最后，调用<code>bringDownServiceIfNeededLocked</code>方法继续停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查此服务是否还被需要</span></span><br><span class="line">    <span class="comment">//在用stopSelf停止服务的这种情况下</span></span><br><span class="line">    <span class="comment">//检查的就是是否有auto-create的连接（flag为BIND_AUTO_CREATE）</span></span><br><span class="line">    <span class="comment">//如有则不能停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Are we in the process of launching?</span></span><br><span class="line">    <span class="comment">//不要停止正在启动中的Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续停止服务</span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就做了一些能否停止服务的检查，主要的停止操作都在下一个<code>bringDownServiceLocked</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//处理Client与Serivce的连接，进行断开连接以及解除绑定操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if the service had been started as foreground, but being</span></span><br><span class="line">    <span class="comment">// brought down before actually showing a notification.  That is not allowed.</span></span><br><span class="line">    <span class="comment">//如果此Service是以前台服务的形式启动，并且当前还尚未成为前台服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        r.fgRequired = <span class="keyword">false</span>;</span><br><span class="line">        r.fgWaiting = <span class="keyword">false</span>;</span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//将前台服务的超时回调取消</span></span><br><span class="line">        mAm.mHandler.removeMessages(</span><br><span class="line">                ActivityManagerService.SERVICE_FOREGROUND_TIMEOUT_MSG, r);</span><br><span class="line">        <span class="comment">//这种情况直接令App崩溃，杀死应用</span></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_FOREGROUND_CRASH_MSG);</span><br><span class="line">            msg.obj = r.app;</span><br><span class="line">            msg.getData().putCharSequence(</span><br><span class="line">                ActivityManagerService.SERVICE_RECORD_KEY, r.toString());</span><br><span class="line">            mAm.mHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录销毁时间</span></span><br><span class="line">    r.destroyTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存中移除ServiceRecord</span></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    ServiceRecord found = smap.mServicesByInstanceName.remove(r.instanceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note when this method is called by bringUpServiceLocked(), the service is not found</span></span><br><span class="line">    <span class="comment">// in mServicesByInstanceName and found will be null.</span></span><br><span class="line">    <span class="keyword">if</span> (found != <span class="keyword">null</span> &amp;&amp; found != r) &#123;</span><br><span class="line">        <span class="comment">// This is not actually the service we think is running...  this should not happen,</span></span><br><span class="line">        <span class="comment">// but if it does, fail hard.</span></span><br><span class="line">        <span class="comment">//如果找到的服务不是我们目前停止的服务，应该是一个不可能的情况</span></span><br><span class="line">        <span class="comment">//碰到这种情况，将ServiceRecord重新放回去并抛出异常</span></span><br><span class="line">        smap.mServicesByInstanceName.put(r.instanceName, found);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bringing down "</span> + r + <span class="string">" but actually running "</span></span><br><span class="line">                + found);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除ServiceRecord</span></span><br><span class="line">    smap.mServicesByIntent.remove(r.intent);</span><br><span class="line">    r.totalRestartCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">    unscheduleServiceRestartLocked(r, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also make sure it is not on the pending list.</span></span><br><span class="line">    <span class="comment">//从待启动Service列表中移除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingServices.get(i) == r) &#123;</span><br><span class="line">            mPendingServices.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭前台服务通知</span></span><br><span class="line">    cancelForegroundNotificationLocked(r);</span><br><span class="line">    <span class="comment">//对于已经成为前台服务的Service</span></span><br><span class="line">    <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">        <span class="comment">//修改应用的活动前台计数，如果计数小于等于0，将其从mActiveForegroundApps列表中移除</span></span><br><span class="line">        decActiveForegroundAppLocked(smap, r);</span><br><span class="line">        ... <span class="comment">//更新统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种清理操作</span></span><br><span class="line">    r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">    r.foregroundId = <span class="number">0</span>;</span><br><span class="line">    r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line">    r.mAllowWhileInUsePermissionInFgs = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear start entries.</span></span><br><span class="line">    r.clearDeliveredStartsLocked();</span><br><span class="line">    r.pendingStarts.clear();</span><br><span class="line">    smap.mDelayedStartList.remove(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从ProcessRecord中移除Service记录</span></span><br><span class="line">        r.app.stopService(r);</span><br><span class="line">        <span class="comment">//更新服务进程绑定的应用uids</span></span><br><span class="line">        r.app.updateBoundClientUids();</span><br><span class="line">        <span class="comment">//允许绑定Service的应用程序管理白名单</span></span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//更新进程前台服务信息</span></span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">                <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">                <span class="comment">//添加到销毁中Service列表中</span></span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                <span class="comment">//标记正在销毁中</span></span><br><span class="line">                r.destroying = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                <span class="comment">//回到App进程，调度执行Service的stop操作</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除连接</span></span><br><span class="line">    <span class="keyword">if</span> (r.bindings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于主动停止的Service，不需要重启</span></span><br><span class="line">    <span class="keyword">if</span> (r.restarter <span class="keyword">instanceof</span> ServiceRestarter) &#123;</span><br><span class="line">        ((ServiceRestarter)r.restarter).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">    <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">    smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几件事：</p>
<ol>
<li>处理<code>Client</code>与<code>Serivce</code>的连接，进行断开连接以及解除绑定操作（具体等到后面分析<code>unbindService</code>时再说）</li>
<li>对于以前台服务形式启动，并且当前还尚未成为前台服务的<code>Service</code>，直接杀死App</li>
<li>各种重置，清理操作</li>
<li>关闭前台服务通知</li>
<li>将<code>Service</code>添加到销毁中服务列表，并调度执行停止操作，最终回调<code>Service.onDestroy</code></li>
<li>将<code>ServiceRestarter</code>内的<code>ServiceRecord</code>变量设为<code>null</code>，避免其后续重启</li>
</ol>
<p>我们重点看第5步，在这个方法中调用了<code>ActivityThread$ApplicationThread.scheduleStopService</code>去调度执行停止服务操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    sendMessage(H.STOP_SERVICE, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也是通过<code>Handler</code>发送<code>Message</code>处理服务停止，这里最终调用的是<code>ActivityThread.handleStopService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从Service列表中取出并移除此服务</span></span><br><span class="line">    Service s = mServices.remove(token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用Service.onDestroy</span></span><br><span class="line">            s.onDestroy();</span><br><span class="line">            <span class="comment">//解绑以及清理（解除对ServiceRecord的Binder远程对象的引用）</span></span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            <span class="comment">//执行清理操作，具体来说就是断开其他客户端与Service的连接以及解除绑定</span></span><br><span class="line">            Context context = s.getBaseContext();</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                <span class="keyword">final</span> String who = s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">"Service"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步中会把之前的超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to stop service "</span> + s</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里首先从<code>mServices</code>列表中取出并移除此服务，然后触发<code>Service.onDestroy</code>回调，之后还需要调用<code>ContextImpl.scheduleFinalCleanup</code>方法执行一些清理工作，这一部分的分析我们留到后面<code>unbindService</code>章节里再讲，这样，整个<code>Service</code>的停止流程就到此结束了</p>
<h2 id="stopService"><a href="#stopService" class="headerlink" title="stopService"></a>stopService</h2><p>接下来我们来看一下调用方调用<code>stopService</code>停止服务的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> stopServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//验证Intent有效性</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="comment">//跨进程处理</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//调用AMS.stopService</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().stopService(</span><br><span class="line">            mMainThread.getApplicationThread(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to stop service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里基本上是直接调用<code>AMS.stopService</code>进入系统进程处理服务停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stopService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"stopService"</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//转交给ActiveServices处理</span></span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stopServiceLocked</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span> &amp;&amp; callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when stopping service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this service is active, make sure it is stopped.</span></span><br><span class="line">    <span class="comment">//查找相应的Service，其中入参createIfNeeded为false，所以如果从缓存中找不到ServiceRecord的话则会直接返回null</span></span><br><span class="line">    ServiceLookupResult r = retrieveServiceLocked(service, <span class="keyword">null</span>, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.record != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//接着处理停止服务</span></span><br><span class="line">                stopServiceLocked(r.record);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServiceLocked</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service.delayed) &#123;</span><br><span class="line">        <span class="comment">// If service isn't actually running, but is being held in the</span></span><br><span class="line">        <span class="comment">// delayed list, then we need to keep it started but note that it</span></span><br><span class="line">        <span class="comment">// should be stopped once no longer delayed.</span></span><br><span class="line">        service.delayedStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//统计信息记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置启动状态（重要，后文中会分析）</span></span><br><span class="line">    service.startRequested = <span class="keyword">false</span>;</span><br><span class="line">    service.callStart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和上文一样，停止Service</span></span><br><span class="line">    bringDownServiceIfNeededLocked(service, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里和上文中分析的以<code>stopSelf</code>方式停止服务一样，先重置启动状态，然后调用<code>bringDownServiceIfNeededLocked</code>停止服务</p>
<h2 id="unbindService"><a href="#unbindService" class="headerlink" title="unbindService"></a>unbindService</h2><p>接下来的是通过<code>bindService</code>方法，并且<code>flag</code>为<code>BIND_AUTO_CREATE</code>启动的<code>Service</code>，我们需要通过<code>unbindService</code>方法解除绑定，当最终没有任何<code>flag</code>为<code>BIND_AUTO_CREATE</code>的客户端与<code>Service</code>绑定，这个<code>Service</code>就会被停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将ServiceDispatcher的状态设置为forgotten，之后便不再会回调ServiceConnection任何方法</span></span><br><span class="line">        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用AMS.unbindService方法</span></span><br><span class="line">            ActivityManager.getService().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中首先调用了<code>LoadedApk.forgetServiceDispatcher</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">forgetServiceDispatcher</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceConnection c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map</span><br><span class="line">                = mServices.get(context);</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//移除ServiceDispatcher</span></span><br><span class="line">                map.remove(c);</span><br><span class="line">                <span class="comment">//清理连接并标记遗忘</span></span><br><span class="line">                sd.doForget();</span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    mServices.remove(context);</span><br><span class="line">                &#125;</span><br><span class="line">                ... <span class="comment">//debug</span></span><br><span class="line">                <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//debug</span></span><br><span class="line">        ... <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>ServiceDispatcher</code>从缓存中移除并调用<code>LoadedApk$ServiceDispatcher.doForget</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doForget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActiveConnections.size(); i++) &#123;</span><br><span class="line">            ServiceDispatcher.ConnectionInfo ci = mActiveConnections.valueAt(i);</span><br><span class="line">            ci.binder.unlinkToDeath(ci.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mActiveConnections.clear();</span><br><span class="line">        mForgotten = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将所有连接的<code>binder</code>死亡回调移除，然后清除所有连接，再将<code>mForgotten</code>标记设为<code>true</code></p>
<p>接着我们会走到<code>AMS.unbindService</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unbindService</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，将工作转交给<code>ActiveServices</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    IBinder binder = connection.asBinder();</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="comment">//找不到连接记录，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历连接</span></span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ConnectionRecord r = clist.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            removeConnectionLocked(r, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//removeConnectionLocked方法会将此ConnectionRecord从连接列表中移除</span></span><br><span class="line">            <span class="comment">//如果此ConnectionRecord仍然存在的话，是一个严重的错误，这里再移除一次</span></span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                <span class="comment">// In case it didn't get removed above, do it now.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Connection "</span> + r + <span class="string">" not removed for binder "</span> + binder);</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                    r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                            r.binding.service.app.hasClientActivities()</span><br><span class="line">                            || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新顶层应用进程优先级</span></span><br><span class="line">        mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没看到什么特别重要的逻辑，看来重点应该在<code>removeConnectionLocked</code>这个方法中了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConnectionLocked</span><span class="params">(ConnectionRecord c, ProcessRecord skipApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityServiceConnectionsHolder skipAct)</span> </span>&#123;</span><br><span class="line">    IBinder binder = c.conn.asBinder();</span><br><span class="line">    AppBindRecord b = c.binding;</span><br><span class="line">    ServiceRecord s = b.service;</span><br><span class="line">    <span class="comment">//这里的clist是ServiceRecord中的列表，和上一个方法中的clist不是一个对象</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.getConnections().get(binder);</span><br><span class="line">    <span class="comment">//移除各种连接</span></span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.removeConnection(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    c.stopAssociation();</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="keyword">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        c.activity.removeConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line">        ... <span class="comment">//各种flag的处理</span></span><br><span class="line">        <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将连接从mServiceConnections列表中移除</span></span><br><span class="line">    <span class="comment">//这个clist才是和上一个方法是同一个对象</span></span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid,</span><br><span class="line">            s.appInfo.longVersionCode, s.instanceName, s.processName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果调用方App没有其他连接和Service绑定</span></span><br><span class="line">    <span class="comment">//则将整个AppBindRecord移除</span></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="comment">//如果服务端进程存活并且没有其他连接绑定了，同时服务还处在绑定关系中（尚未回调过Service.onUnbind）</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">                    <span class="comment">// If this service's process is not already in the cached list,</span></span><br><span class="line">                    <span class="comment">// then update it in the LRU list here because this may be causing</span></span><br><span class="line">                    <span class="comment">// it to go down there and we want it to start out near the top.</span></span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(s.app, <span class="keyword">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                <span class="comment">//标记为未绑定</span></span><br><span class="line">                b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn't want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回到App进程，调度执行Service的unbind操作</span></span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If unbound while waiting to start and there is no connection left in this service,</span></span><br><span class="line">        <span class="comment">// remove the pending service</span></span><br><span class="line">        <span class="keyword">if</span> (s.getConnections().isEmpty()) &#123;</span><br><span class="line">            mPendingServices.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//是否有其他含有BIND_AUTO_CREATE标记的连接</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();</span><br><span class="line">            ... <span class="comment">//记录</span></span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="keyword">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几件事：</p>
<ol>
<li><p>执行各种移除操作</p>
</li>
<li><p>如果目标服务在此次解绑后不再有任何其他连接与其绑定，则调度执行<code>Service</code>的<code>unbind</code>操作</p>
</li>
<li><p>如果此次断开的连接的<code>flag</code>中包含<code>BIND_AUTO_CREATE</code>，则调用<code>bringDownServiceIfNeededLocked</code>尝试停止服务</p>
</li>
</ol>
<p>2、3两点都很重要，我们首先看第2点，什么情况下会在这里调度执行<code>Service</code>的<code>unbind</code>操作，前面描述的其实不是很准确，准确的来说应该是目标服务在同一个<code>IntentBindRecord</code>下，此次解绑后不再有任何其他连接与其绑定。那么什么叫同一个<code>IntentBindRecord</code>呢？这和我们启动服务传入的<code>Intent</code>有关，<code>IntentBindRecord</code>的第一次创建是在我们调用<code>bindService</code>后，走到<code>ActiveServices.bindServiceLocked</code>方法中，其中有一段代码调用了<code>ServiceRecord.retrieveAppBindingLocked</code>方法产生的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppBindRecord <span class="title">retrieveAppBindingLocked</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">    IntentBindRecord i = bindings.get(filter);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = <span class="keyword">new</span> IntentBindRecord(<span class="keyword">this</span>, filter);</span><br><span class="line">        bindings.put(filter, i);</span><br><span class="line">    &#125;</span><br><span class="line">    AppBindRecord a = i.apps.get(app);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="keyword">new</span> AppBindRecord(<span class="keyword">this</span>, i, app);</span><br><span class="line">    i.apps.put(app, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，它将我们传入的<code>Intent</code>包装成了<code>Intent.FilterComparison</code>对象，然后尝试用它作为<code>key</code>从<code>ArrayMap``bindings</code>中取获取<code>IntentBindRecord</code>，如果获取不到则会创建一个新的，那么是否是同一个<code>IntentBindRecord</code>的判断标准就是包装后的<code>Intent.FilterComparison</code>对象的<code>HashCode</code>是否相等，我们来看一下它的<code>HashCode</code>是怎样计算的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/content/Intent.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterComparison</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Intent mIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mHashCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterComparison</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mIntent = intent;</span><br><span class="line">        mHashCode = intent.filterHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHashCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAction != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mAction.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mData.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mType.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mIdentifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mIdentifier.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mPackage.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mComponent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mComponent.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCategories != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mCategories.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，只有以上参数全部相等，才会被视为同一个<code>Intent</code>，而我们通常使用<code>Intent</code>只会设置它的<code>mComponent</code>，所以在一般情况下<code>Service</code>的<code>onBind</code>和<code>onUnbind</code>也只会触发一次（在<code>Service</code>没有被销毁的情况下）</p>
<p>接着我们来看第3点，如果此次断开的连接的<code>flag</code>中包含<code>BIND_AUTO_CREATE</code>，首先会去查询是否有其他含有<code>BIND_AUTO_CREATE</code>标记的连接，然后以此作为参数调用<code>bringDownServiceIfNeededLocked</code>尝试停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查此服务是否还被需要</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Are we in the process of launching?</span></span><br><span class="line">    <span class="comment">//不要停止正在启动中的Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续停止服务</span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isServiceNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Are we still explicitly being asked to run?</span></span><br><span class="line">    <span class="comment">//Service之前是否通过startService启动过并且未stop</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is someone still bound to us keeping us running?</span></span><br><span class="line">    <span class="comment">//这里我们传入的是true</span></span><br><span class="line">    <span class="comment">//因为我们之前已经做了检查，知道了是否还有其他auto-create的连接</span></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有其他auto-create的连接</span></span><br><span class="line">    <span class="comment">//则此服务还被需要</span></span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，经过上述检查，如果发现此<code>Service</code>确实可以被停止了，则会调用<code>bringDownServiceLocked</code>方法停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断开所有连接</span></span><br><span class="line">    ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> conni = connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size(); i++) &#123;</span><br><span class="line">            ConnectionRecord cr = c.get(i);</span><br><span class="line">            <span class="comment">// There is still a connection to the service that is</span></span><br><span class="line">            <span class="comment">// being brought down.  Mark it as dead.</span></span><br><span class="line">            <span class="comment">//将服务标记为死亡</span></span><br><span class="line">            cr.serviceDead = <span class="keyword">true</span>;</span><br><span class="line">            cr.stopAssociation();</span><br><span class="line">            <span class="comment">//回调ServiceConnection各种方法</span></span><br><span class="line">            <span class="comment">//通知client服务断开连接以及死亡</span></span><br><span class="line">            cr.conn.connected(r.name, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the service that it has been unbound.</span></span><br><span class="line">    <span class="comment">//通知Service解除绑定</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needOomAdj = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历所有连接，解除绑定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">            <span class="comment">//如果还处在绑定关系中（尚未回调过Service.onUnbind）</span></span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">                    <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">                    bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line">                    needOomAdj = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//标记为未绑定</span></span><br><span class="line">                    ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                    ibr.requested = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//回到App进程，调度执行Service的unbind操作</span></span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    needOomAdj = <span class="keyword">false</span>;</span><br><span class="line">                    serviceProcessGoneLocked(r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新服务端进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (needOomAdj) &#123;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>,</span><br><span class="line">                    OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//和上文相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我们在前面分析<code>stopSelf</code>的时候说过了，这次我们只看和绑定服务有关的部分</p>
<p>首先断开所有连接，回调<code>ServiceConnection</code>各种方法，通知客户端服务断开连接以及死亡，这里需要注意的是，我们本次执行<code>unbindService</code>操作的连接已经在上一步中从<code>ServiceRecord.connections</code>列表中移除，所以并不会回调它的<code>ServiceConnection</code>的任何方法，这也是很多人对<code>unbindService</code>方法的误解（包括我自己），<code>bindService</code>方法在成功绑定服务后会回调<code>ServiceConnection.onServiceConnected</code>方法，但<code>unbindService</code>方法在成功解绑服务后并不会回调<code>ServiceConnection.onServiceDisconnected</code>以及任何其它方法，这些方法只会在<code>Service</code>被以其他方式停止（比如后面会分析的混合启动的服务如何停止）或者<code>Service</code>意外停止（比如服务端应用崩溃或被杀死）的情况才会被调用</p>
<p>所以这里处理的是断开其他的连接，我们假设一个场景，使用同一个<code>Intent</code>和两个不同的<code>ServiceConnection</code>，一个使用<code>BIND_AUTO_CREATE</code>标记，一个使用其他标记，先绑定<code>BIND_AUTO_CREATE</code>标记的<code>Service</code>，然后再绑定其他标记的<code>Service</code>，接着我们对<code>BIND_AUTO_CREATE</code>标记的<code>Serivce</code>调用<code>unbindService</code>解绑，此时就会走到这个方法中，<code>ServiceRecord.connections</code>列表中会存在那个使用其他标记的连接，然后其内部成员变量<code>conn</code>的<code>connected</code>方法，这个<code>conn</code>是一个<code>IServiceConnection</code>类型，实际上的实现类为<code>LoadedApk$ServiceDispatcher$InnerConnection</code>，最终会调用到<code>LoadedApk$ServiceDispatcher.doConnected</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//被标记为遗忘则不处理任何事情</span></span><br><span class="line">        <span class="comment">//调用unbindService就会将这个标志设为true</span></span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="comment">//如果旧的连接信息中的IBinder对象和本次调用传入的IBinder对象是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            <span class="comment">//建立一个新的连接信息</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注册Binder死亡通知</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//保存本次连接信息</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                <span class="comment">//服务已死亡，移除连接信息</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除Binder死亡通知</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="comment">//回调ServiceConnection.onServiceDisconnected</span></span><br><span class="line">    <span class="comment">//通知client之前的连接已被断开</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Service死亡需要回调ServiceConnection.onBindingDied通知client服务死亡</span></span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new viable service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        <span class="comment">//告知client已建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        <span class="comment">//当Service.onBind方法返回null，或者Service停止时</span></span><br><span class="line">        <span class="comment">//回调ServiceConnection.onNullBinding方法</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法其实我们在上一篇文章中已经说过了，不过在上一篇文章中我们关注的是<code>Service</code>绑定的部分，而这次我们关注的是解绑的部分</p>
<p>首先映入眼帘的就是对<code>mForgotten</code>变量的判断，它在客户端调用<code>unbindService</code>就会被设为<code>true</code>，然后便会直接返回，不再处理后续事项。当然，实际上执行完<code>unbindService</code>方法后，客户端与<code>Service</code>的连接会被移除，理论上应该也不会再走到这个方法里才对（这里我也感觉有点疑惑）</p>
<p>根据这段代码，我们能看出来<code>Service</code>停止后，对客户端的回调是什么：</p>
<ul>
<li><p>当<code>Service.onBind</code>方法的返回不为<code>null</code>时，此时会依次回调<code>ServiceConnection.onServiceDisconnected</code>、<code>ServiceConnection.onBindingDied</code>和<code>ServiceConnection.onNullBinding</code>方法</p>
</li>
<li><p>当<code>Service.onBind</code>方法的返回为<code>null</code>时，此时会依次回调<code>ServiceConnection.onBindingDied</code>和<code>ServiceConnection.onNullBinding</code>方法</p>
</li>
</ul>
<p>大家也可以自己写写<code>Demo</code>来检验一下我说的是否正确</p>
<p>这一步处理完后，接下来要做的便是处理<code>Service</code>那边的解绑，遍历<code>IntentBindRecord</code>列表，调用<code>ActivityThread$ApplicationThread.scheduleUnbindService</code>去调度执行服务解绑操作，这里通过<code>Handler</code>最终调用的是<code>ActivityThread.handleUnbindService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUnbindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="comment">//回调Service.onUnbind方法，如果返回值为true</span></span><br><span class="line">            <span class="comment">//当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">            <span class="keyword">boolean</span> doRebind = s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    ActivityManager.getService().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to unbind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里回调了<code>Service.onUnbind</code>方法，它的返回值表示当<code>Service</code>后面再与其他客户端建立连接时，是否需要回调<code>Service.onRebind</code>方法，但是这有一个前提，那就是<code>Service</code>中途没有被停止，具体原因以及<code>rebind</code>流程我们稍后再分析</p>
<p>到了这一步，解绑就完成了，接下来和之前在<code>stopSelf</code>章节里分析的后续流程就一样了，最终调用<code>ActivityThread.handleStopService</code>方法停止服务，还记得我们之前分析在这个方法中触发完<code>Service.onDestroy</code>回调，之后还需要调用<code>ContextImpl.scheduleFinalCleanup</code>方法吗？现在我们就来看看这个方法又做了什么事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleFinalCleanup</span><span class="params">(String who, String what)</span> </span>&#123;</span><br><span class="line">    mMainThread.scheduleContextCleanup(<span class="keyword">this</span>, who, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>mMainThread</code>就是应用的<code>ActivityThread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleContextCleanup</span><span class="params">(ContextImpl context, String who,</span></span></span><br><span class="line"><span class="function"><span class="params">        String what)</span> </span>&#123;</span><br><span class="line">    ContextCleanupInfo cci = <span class="keyword">new</span> ContextCleanupInfo();</span><br><span class="line">    cci.context = context;</span><br><span class="line">    cci.who = who;</span><br><span class="line">    cci.what = what;</span><br><span class="line">    sendMessage(H.CLEAN_UP_CONTEXT, cci);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是老样子通过<code>Handler</code>发消息，最终调用的是<code>ContextImpl.performFinalCleanup</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performFinalCleanup</span><span class="params">(String who, String what)</span> </span>&#123;</span><br><span class="line">    mPackageInfo.removeContextRegistrations(getOuterContext(), who, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>LoadedApk.removeContextRegistrations</code>方法执行清理操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContextRegistrations</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        String who, String what)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//清理广播接收器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; smap =</span><br><span class="line">                mServices.remove(context);</span><br><span class="line">        <span class="keyword">if</span> (smap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smap.size(); i++) &#123;</span><br><span class="line">                LoadedApk.ServiceDispatcher sd = smap.valueAt(i);</span><br><span class="line">                ... <span class="comment">//报告ServiceConnection泄露</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ActivityManager.getService().unbindService(</span><br><span class="line">                            sd.getIServiceConnection());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">                sd.doForget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mUnboundServices.remove(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能看到这里，有很多小伙伴会有疑问，为什么之前已经清理过了，这里还要再进行清理、这里为什么会有<code>ServiceConnection</code>泄露、这里为什么还要再次<code>unbindService</code>？那我们需要注意了，这里被调用的对象到底是谁？其实是<code>Service</code>的<code>Context</code>，假设我们在<code>Serivce</code>里调用<code>bindService</code>又绑定了一个其他<code>Service</code>，那这个<code>Service</code>被销毁后，它和另一个<code>Service</code>的连接怎么办？是不是就产生了泄露？为了防止这种情况，所以我们需要在<code>Service</code>销毁时调用一下这个方法解除它与其他<code>Service</code>的绑定</p>
<p>而且这个方法不仅会在这里被调用到哦，在我们之前分析过的 <a href="https://juejin.cn/post/7216142711614799930" target="_blank" rel="noopener">Android源码分析 - Activity销毁流程</a> 中，也存在它的身影，当<code>Activity</code>被销毁，走到<code>handleDestroyActivity</code>方法时，会调用到我们<code>ContextImpl.scheduleFinalCleanup</code>方法，进行广播接收器的清理以及服务的解绑</p>
<p>至此，<code>Service</code>的主动停止流程我们都分析完了，还有一些细枝末节的事情可以说一说</p>
<h1 id="rebind流程"><a href="#rebind流程" class="headerlink" title="rebind流程"></a>rebind流程</h1><p>之前我们说过，<code>rebind</code>的前提是<code>Service</code>中途没有被停止，为什么呢？带着疑问，我们来看之前没有分析的，当<code>Service.onUnbind</code>方法返回值为<code>true</code>时，会调用的<code>AMS.unbindFinished</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindFinished</span><span class="params">(IBinder token, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是转交给<code>ActiveServices</code>去实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unbindFinishedLocked</span><span class="params">(ServiceRecord r, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//服务unbind的前提就是IntentBindRecord.apps.size == 0</span></span><br><span class="line">                <span class="keyword">if</span> (b.apps.size() &gt; <span class="number">0</span> &amp;&amp; !inDestroying) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Note to tell the service the next time there is</span></span><br><span class="line">                    <span class="comment">// a new client.</span></span><br><span class="line">                    <span class="comment">//将doRebind标记置为true，下一次再次建立连接时</span></span><br><span class="line">                    <span class="comment">//服务会回调Service.onRebind方法</span></span><br><span class="line">                    b.doRebind = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们之前的分析，我们知道，回调<code>Service.onUnbind</code>的前提就是这个<code>Service</code>没有任何连接与其绑定了，即<code>IntentBindRecord.apps.size == 0</code>，在这个case下，这个方法会将<code>IntentBindRecord</code>的<code>doRebind</code>变量置为<code>true</code></p>
<p>此时让我们再回顾一下上一篇文章 <a href="https://juejin.cn/post/7276363520554795064#heading-10" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中分析的<code>bindService</code>流程，在<code>ActiveServices.bindServiceLocked</code>方法中有这么一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">        <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">        <span class="comment">// publish the connection.</span></span><br><span class="line">        <span class="comment">//如果服务之前就已经在运行，即Service.onBind方法已经被执行，返回的IBinder对象也已经被保存</span></span><br><span class="line">        <span class="comment">//调用LoadedApk$ServiceDispatcher$InnerConnection.connected方法</span></span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        c.conn.connected(s.name, b.intent.binder, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">        <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">        <span class="comment">// rebound, then do so.</span></span><br><span class="line">        <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">        <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">        <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">        <span class="comment">//如果服务是因这次绑定而创建的</span></span><br><span class="line">        <span class="comment">//请求执行Service.onBind方法，获取返回的IBinder对象</span></span><br><span class="line">        <span class="comment">//发布Service，回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>Service</code>被停止了，那么它相应的<code>ServiceRecord</code>会从缓存<code>mServicesByInstanceName</code>和<code>mServicesByIntent</code>中移除，那么等到重新启动<code>Service</code>时会新建出一个<code>ServiceRecord</code>，此时里面的变量全部被初始化，<code>b.intent.received == false</code>，<code>b.intent.requested == false</code>，<code>b.intent.doRebind == false</code>，在这种情况下，调用<code>requestServiceBindingLocked</code>方法的最后一个入参<code>rebind</code>为<code>false</code>，就会直接回调<code>Service.onBind</code>方法，而不会回调<code>Service.onRebind</code>方法</p>
<p>如果<code>Service</code>没有被停止，且之前有被绑定过，那么<code>b.intent.received == true</code>，代表<code>IBinder</code>对象已获取到，此时如果之前的<code>Service.onUnbind</code>回调返回值为<code>true</code>，那么这里的<code>b.intent.doRebind</code>也为<code>true</code>，再加上如果这是<code>Service</code>断开所有连接后建立的第一次连接，即<code>b.intent.apps.size() == 1</code>，那么此时调用的<code>requestServiceBindingLocked</code>方法的最后一个入参<code>rebind</code>为<code>true</code>，就会直接回调<code>Service.onRebind</code>方法，而不会回调<code>Service.onBind</code>方法</p>
<h1 id="混合启动的Service该如何停止"><a href="#混合启动的Service该如何停止" class="headerlink" title="混合启动的Service该如何停止"></a>混合启动的Service该如何停止</h1><p>单一启动方式的<code>Service</code>的停止很简单，那么混合启动的<code>Service</code>该如何停止呢？</p>
<p>何为混合启动？指的是通过<code>startService</code>方式启动<code>Service</code>并且以<code>BIND_AUTO_CREATE</code>标志调用<code>bindService</code>方法绑定<code>Service</code>，两者不分先后</p>
<p>在上面的分析中，我们注意到，不管用哪种方式停止服务，最后都会走到<code>bringDownServiceIfNeededLocked</code>方法中，在这个方法里又会调用<code>isServiceNeededLocked</code>判断是否<code>Service</code>是否被需要，那被需要的条件是什么呢？<code>Service.startRequested</code>为<code>true</code>，并且没有标志为<code>BIND_AUTO_CREATE</code>的连接绑定，那么，只要不符合这两个条件，服务自然就可以被停止了</p>
<p>没有标志为<code>BIND_AUTO_CREATE</code>的连接绑定这个简单，只需要把标记为<code>BIND_AUTO_CREATE</code>的连接全部解绑了就好，那么怎么让<code>Service.startRequested</code>为<code>false</code>呢？我们回顾一下之前对<code>stopSelf</code>和<code>stopService</code>的分析，在他们调用<code>bringDownServiceIfNeededLocked</code>方法之前，都会先将<code>Service.startRequested</code>设置为<code>false</code>，所以答案就很明显了：只要<code>unbindService</code>掉所有<code>BIND_AUTO_CREATE</code>的标志的连接，然后<code>stopService</code>就能停止掉混合启动的服务，当然你也可以先<code>stopService</code>，再<code>unbindService</code>掉所有<code>BIND_AUTO_CREATE</code>的标志的连接</p>
<h1 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h1><p>经过以上一系列的分析，我给大家出几个小问题：</p>
<ol>
<li><p>先通过<code>startService</code>启动服务，然后再用<code>BIND_AUTO_CREATE</code>标志<code>bindService</code>（连接1），此时，<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>在上一题的基础上，再使用一个非<code>BIND_AUTO_CREATE</code>标志<code>bindService</code>（连接2），此时，<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>此时，使用<code>unbindService</code>解绑连接1，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>此时，使用<code>unbindService</code>解绑连接2，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>接着，再使用连接1<code>bindService</code>，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>然后，调用<code>stopService</code>停止服务，服务真的会被停止吗？<code>Service</code>的生命周期是怎样的？连接1的<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>紧接着，再使用连接2<code>bindService</code>，会发生什么？连接2的<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>最后，调用<code>unbindService</code>解绑连接1，会发生什么？<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
</ol>
<p>请大家思考片刻，可以去回顾之前的<code>Service</code>启动分析以及停止流程分析，如果以上问题能全部回答正确，证明你对<code>Service</code>已经有了一个很深刻的理解，接下来揭晓答案：</p>
<ol>
<li><p>生命周期：<code>onCreate</code> -&gt; <code>onStartCommand</code> -&gt; <code>onBind</code>，如果<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>生命周期不会发生变化，如果<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>生命周期不会发生变化，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>生命周期：<code>onUnbind</code>，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>如果之前<code>onUnbind</code>的返回值为<code>true</code>，则生命周期为：<code>onRebind</code>，否则生命周期不会发生变化，如果之前<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>不会真的被停止，生命周期不会发生变化，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>生命周期不会发生变化，如果之前<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>服务会被停止，生命周期：<code>onUnbind</code> -&gt; <code>onDestroy</code>，连接1的<code>ServiceConnection</code>不会回调任何方法，如果之前<code>onBind</code>的返回值不为<code>null</code>，连接2的<code>ServiceConnection</code>会回调<code>onServiceDisconnected</code>、<code>onBindingDied</code>以及<code>onNullBinding</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，连接2的<code>ServiceConnection</code>会回调<code>onBindingDied</code>以及<code>onNullBinding</code>方法</p>
</li>
</ol>
<h1 id="被动停止"><a href="#被动停止" class="headerlink" title="被动停止"></a>被动停止</h1><p><code>Service</code>除了主动停止，还会因为各种情况导致被动停止</p>
<h2 id="用户手动从最近任务移除Task"><a href="#用户手动从最近任务移除Task" class="headerlink" title="用户手动从最近任务移除Task"></a>用户手动从最近任务移除Task</h2><p>注：由于各家系统对进程或任务调度策略不同，所以这里的<code>Task</code>移除逻辑和<code>Service</code>停止逻辑可能会有些许不同，我们还是以原生<code>Android</code>为准分析</p>
<p>不管用户是从最近任务划走了一个<code>Task</code>，还是点击了全部清除，最终都会走到<code>ActivityStackSupervisor.removeTaskById</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeTaskById</span><span class="params">(<span class="keyword">int</span> taskId, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过id查询Task</span></span><br><span class="line">    <span class="keyword">final</span> Task task =</span><br><span class="line">            mRootWindowContainer.anyTaskForId(taskId, MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        removeTask(task, killProcess, removeFromRecents, reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的入参，<code>killProcess</code>为<code>true</code>，如果是移除单一<code>Task</code>，那么<code>removeFromRecents</code>为<code>true</code>，如果是清除全部<code>Task</code>，那么<code>removeFromRecents</code>为<code>false</code></p>
<p>先通过<code>id</code>，使用<code>RootWindowContainer</code>查询相应的<code>Task</code>，然后再调用<code>removeTask</code>方法继续移除<code>Task</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTask</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果Task正在清理中则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (task.mInRemoveTask) &#123;</span><br><span class="line">        <span class="comment">// Prevent recursion.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记Task正在清理中</span></span><br><span class="line">    task.mInRemoveTask = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//销毁此Task下所有Activity</span></span><br><span class="line">        task.performClearTask(reason);</span><br><span class="line">        <span class="comment">//清理Task</span></span><br><span class="line">        cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents);</span><br><span class="line">        <span class="comment">//关闭屏幕固定</span></span><br><span class="line">        mService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">        <span class="comment">//通知任务栈发生变化</span></span><br><span class="line">        mService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        <span class="comment">//启动任务持久化程序，将任何挂起的任务写入磁盘</span></span><br><span class="line">        <span class="keyword">if</span> (task.isPersistable) &#123;</span><br><span class="line">            mService.notifyTaskPersisterLocked(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//取消标记</span></span><br><span class="line">        task.mInRemoveTask = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法最重要的有两个部分，一个是销毁此<code>Task</code>下所有<code>Activity</code>，对于我们本次而言不需要关注，另一个是调用<code>cleanUpRemovedTaskLocked</code>继续清理<code>Task</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanUpRemovedTaskLocked</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从最近任务列表中移除</span></span><br><span class="line">    <span class="comment">//对于清除全部Task而言，之前在RecentTasks中已经进行过移除操作了</span></span><br><span class="line">    <span class="comment">//所以传入的removeFromRecents为false</span></span><br><span class="line">    <span class="keyword">if</span> (removeFromRecents) &#123;</span><br><span class="line">        mRecentTasks.remove(task);</span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = task.getBaseIntent().getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find any running services associated with this app and stop if needed.</span></span><br><span class="line">    <span class="comment">//清理和此Task有关联的服务</span></span><br><span class="line">    <span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(ActivityManagerInternal::cleanUpServices,</span><br><span class="line">            mService.mAmInternal, task.mUserId, component, <span class="keyword">new</span> Intent(task.getBaseIntent()));</span><br><span class="line">    mService.mH.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不需要杀死进程，到这里就为止了</span></span><br><span class="line">    <span class="keyword">if</span> (!killProcess) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine if the process(es) for this task should be killed.</span></span><br><span class="line">    <span class="keyword">final</span> String pkg = component.getPackageName();</span><br><span class="line">    ArrayList&lt;Object&gt; procsToKill = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayMap&lt;String, SparseArray&lt;WindowProcessController&gt;&gt; pmap = </span><br><span class="line">            mService.mProcessNames.getMap();</span><br><span class="line">    <span class="comment">//遍历App进程，确定要杀死的进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pmap.size(); i++) &#123;</span><br><span class="line">        SparseArray&lt;WindowProcessController&gt; uids = pmap.valueAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; uids.size(); j++) &#123;</span><br><span class="line">            WindowProcessController proc = uids.valueAt(j);</span><br><span class="line">            <span class="comment">//不要杀死其他用户下的进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc.mUserId != task.mUserId) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process for a different user.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不要杀死首页进程</span></span><br><span class="line">            <span class="comment">//HomeProcess指的是含有分类为android.intent.category.HOME的进程</span></span><br><span class="line">            <span class="comment">//也就是能成为首页Launcher的进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc == mService.mHomeProcess) &#123;</span><br><span class="line">                <span class="comment">// Don't kill the home process along with tasks from the same package.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不要杀死和这个Task无关的进程</span></span><br><span class="line">            <span class="keyword">if</span> (!proc.mPkgList.contains(pkg)) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process that is not associated with this task.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果这个进程有Activity在不同的Task里，并且这个Task也在最近任务里</span></span><br><span class="line">            <span class="comment">//或者有Activity还没有被停止，则不要杀死进程</span></span><br><span class="line">            <span class="keyword">if</span> (!proc.shouldKillProcessForRemovedTask(task)) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process(es) that has an activity in a different task that is also</span></span><br><span class="line">                <span class="comment">// in recents, or has an activity not stopped.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有前台服务的话不要杀死进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc.hasForegroundServices()) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process(es) with foreground service.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add process to kill list.</span></span><br><span class="line">            procsToKill.add(proc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the running processes. Post on handle since we don't want to hold the service lock</span></span><br><span class="line">    <span class="comment">// while calling into AM.</span></span><br><span class="line">    <span class="comment">//杀死进程</span></span><br><span class="line">    <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(</span><br><span class="line">            ActivityManagerInternal::killProcessesForRemovedTask, mService.mAmInternal,</span><br><span class="line">            procsToKill);</span><br><span class="line">    mService.mH.sendMessage(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做两件事，一是清理和此<code>Task</code>有关联的服务，二是杀死应该杀死的进程</p>
<p>清理服务这一步用到了池化技术，这里大家不用管，就当做调用了<code>mService.mAmInternal.cleanUpServices</code>即可，这里的<code>mService.mAmInternal</code>是<code>AMS</code>里的一个内部类<code>LocalService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpServices</span><span class="params">(<span class="keyword">int</span> userId, ComponentName component, Intent baseIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        mServices.cleanUpServices(userId, component, baseIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，关于<code>Service</code>的工作都转交给<code>ActiveServices</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanUpServices</span><span class="params">(<span class="keyword">int</span> userId, ComponentName component, Intent baseIntent)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ServiceRecord&gt; services = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获得此用户下所有的活动Service</span></span><br><span class="line">    ArrayMap&lt;ComponentName, ServiceRecord&gt; alls = getServicesLocked(userId);</span><br><span class="line">    <span class="comment">//筛选出此Task下的所有活动Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = alls.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = alls.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.packageName.equals(component.getPackageName())) &#123;</span><br><span class="line">            services.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of any running services associated with the app.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = services.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = services.get(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果在manifest里设置了stopWithTask，那么会直接停止Service</span></span><br><span class="line">                stopServiceLocked(sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有设置stopWithTask的话，则会回调Service.onTaskRemoved方法</span></span><br><span class="line">                sr.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(sr, <span class="keyword">true</span>,</span><br><span class="line">                        sr.getLastStartId(), baseIntent, <span class="keyword">null</span>, <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span> (sr.app != <span class="keyword">null</span> &amp;&amp; sr.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We always run in the foreground, since this is called as</span></span><br><span class="line">                    <span class="comment">// part of the "remove task" UI operation.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sendServiceArgsLocked(sr, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        <span class="comment">// Ignore, keep going.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要获取到所有需要清理的<code>Service</code>记录，然后再对它们进行处理</p>
<p>对于在<code>manifest</code>文件里设置了<code>stopWithTask</code>标识的<code>Service</code>，直接调用<code>stopServiceLocked</code>方法停止服务，而对于没有这个标识的<code>Service</code>，则是增加一个启动项，接着调用<code>sendServiceArgsLocked</code>处理这个启动项</p>
<p>我们观察这个启动项的构建，第二个参数为<code>true</code>，我们可以去这个类的构造方法那里看到，第二个参数的名字为<code>_taskRemoved</code>，意思很明显了，然后根据我们在上一篇文章 <a href="https://juejin.cn/post/7276363520554795064#heading-9" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中分析的<code>sendServiceArgsLocked</code>方法可以知道，它最终会走到<code>ActivityThread.handleServiceArgs</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">        <span class="comment">//正常情况调用</span></span><br><span class="line">        res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">        s.onTaskRemoved(data.args);</span><br><span class="line">        res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，当<code>taskRemoved</code>变量为<code>true</code>时，会回调<code>Service.onTaskRemoved</code>方法</p>
<p>我们接着回到<code>cleanUpRemovedTaskLocked</code>方法中，当它清理完服务后，便会尝试杀死进程，这里面其他的判断条件我们都不用管，我们只需要关心其中的一段，有前台服务的话不要杀死进程</p>
<p>以上是我根据<code>AOSP</code>源码分析得出的结果，在模拟器上也验证通过，但在我的小米MIX4上表现却完全不是这样，大家开发时还是要以实际为准</p>
<h2 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h2><p>当内存不足时，系统会通过<code>OOM Killer</code>或<code>Low Memory Killer</code>等手段杀死各种进程，如果被杀死的进程里有<code>Service</code>正在运行，那自然也会被停止</p>
<h1 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h1><p>当<code>Service</code>所在进程被杀死后，根据<code>Service.onStartCommand</code>的返回值，系统会决定是否重建，怎么重建。我们先把其可能的返回值以及产生的结果先列出来：</p>
<ul>
<li><code>START_STICKY_COMPATIBILITY</code>：<code>targetSdkVersion</code> &lt; 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，但<code>onStartCommand</code>方法不会被执行</li>
<li><code>START_STICKY</code>：<code>targetSdkVersion</code> &gt;= 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，但此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>null</code></li>
<li><code>START_NOT_STICKY</code>：<code>Service</code>被杀后不会被重建</li>
<li><code>START_REDELIVER_INTENT</code>：<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>Service</code>被杀死前最后一次调用<code>onStartCommand</code>方法时传递的<code>Intent</code></li>
</ul>
<p>对于其返回值我们需要先了解一下是怎么处理的，这需要回顾一下上一篇文章分析的<code>handleServiceArgs</code>方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                <span class="comment">//正常情况调用</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步会根据onStartCommand的返回值，调整Service死亡重建策略</span></span><br><span class="line">                <span class="comment">//同时会把之前的启动超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里从<code>Service.onStartCommand</code>得到返回值后以其作为参数调用了<code>AMS.serviceDoneExecuting</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转交给了<code>ActiveServices.serviceDoneExecutingLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            <span class="comment">// This is a call from a service start...  take care of</span></span><br><span class="line">            <span class="comment">// book-keeping.</span></span><br><span class="line">            r.callStart = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY: &#123;</span><br><span class="line">                    <span class="comment">// We are done with the associated start arguments.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                    r.stopIfKilled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_NOT_STICKY: &#123;</span><br><span class="line">                    <span class="comment">// We are done with the associated start arguments.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (r.getLastStartId() == startId) &#123;</span><br><span class="line">                        <span class="comment">// There is no more work, and this service</span></span><br><span class="line">                        <span class="comment">// doesn't want to hang around if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line">                    <span class="comment">// We'll keep this item until they explicitly</span></span><br><span class="line">                    <span class="comment">// call stop for it, but keep track of the fact</span></span><br><span class="line">                    <span class="comment">// that it was delivered.</span></span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        si.deliveryCount = <span class="number">0</span>;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line">                        <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line">                    <span class="comment">// Special processing for onTaskRemoved().  Don't</span></span><br><span class="line">                    <span class="comment">// impact normal onStartCommand() processing.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Unknown service start result: "</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就只看对<code>Service.onStartCommand</code>的返回值进行处理的部分</p>
<p>首先，不管返回值是什么，都会调用<code>ServiceRecord.findDeliveredStart</code>方法，只不过入参不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StartItem <span class="title">findDeliveredStart</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">boolean</span> remove)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = deliveredStarts.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        StartItem si = deliveredStarts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (si.id == id &amp;&amp; si.taskRemoved == taskRemoved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remove) deliveredStarts.remove(i);</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两个参数，不管返回值是什么，传进来的都是一样的，而第三个参数<code>remove</code>就不同了，当返回值为<code>START_REDELIVER_INTENT</code>的时候，它为<code>false</code>，其他情况都为<code>true</code>，意味着要删除这个已分发的启动项，<code>START_REDELIVER_INTENT</code>由于需要保留最后一次调用<code>onStartCommand</code>时的<code>Intent</code>，所以它不应该被删除</p>
<p>接着我们回到<code>serviceDoneExecutingLocked</code>方法，可以发现，<code>START_STICKY</code>和<code>START_STICKY_COMPATIBILITY</code>情况下的<code>ServiceRecord.stopIfKilled</code>被置为了<code>false</code>，其他则被置为了<code>true</code>，这和我们之前对结果的描述不同啊？不是说好了返回<code>START_REDELIVER_INTENT</code>也会重启吗？这是因为<code>START_REDELIVER_INTENT</code>比较特殊，它的重启不需要看<code>stopIfKilled</code>这个标志位，这个等到我们后面分析到怎么判断是否应该停止服务时就知道了</p>
<p>以上的内容我们先记下来，会在后面的重启流程中发挥作用</p>
<p>然后我们来看进程死亡后会发生什么，我们曾在之前的文章 <a href="https://juejin.cn/post/7172464885492613128#heading-7" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中提到过，当App启动时，<code>AMS</code>会为其注册一个App进程死亡回调<code>AppDeathRecipient</code>，当App进程死亡后便会回调其<code>binderDied</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</span><br><span class="line"></span><br><span class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</span><br><span class="line">            IApplicationThread thread) &#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mPid = pid;</span><br><span class="line">        mAppThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便会调用<code>appDiedLocked</code>方法处理进程死亡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appDiedLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> pid, IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fromBinderDied, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check if this ProcessRecord is actually active for the pid.</span></span><br><span class="line">    <span class="comment">//检查pid所属ProcessRecord是否与传入ProcessRecord相符</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">        ProcessRecord curProc = mPidsSelfLocked.get(pid);</span><br><span class="line">        <span class="keyword">if</span> (curProc != app) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录电池统计信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果App进程尚未死亡的话，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (!app.killed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromBinderDied) &#123;</span><br><span class="line">            killProcessQuiet(pid);</span><br><span class="line">            mProcessList.noteAppKill(app, ApplicationExitInfo.REASON_OTHER,</span><br><span class="line">                    ApplicationExitInfo.SUBREASON_UNKNOWN, reason);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessList.killProcessGroup(app.uid, pid);</span><br><span class="line">        app.killed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up already done if the process has been re-started.</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid == pid &amp;&amp; app.thread != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            app.thread.asBinder() == thread.asBinder()) &#123;</span><br><span class="line">        <span class="comment">//一般情况下非自动化测试，先置为true</span></span><br><span class="line">        <span class="keyword">boolean</span> doLowMem = app.getActiveInstrumentation() == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> doOomAdj = doLowMem;</span><br><span class="line">        <span class="keyword">if</span> (!app.killedByAm) &#123; <span class="comment">//不通过AMS杀死的进程，一般就是被 Low Memory Killer (LMK) 杀死的</span></span><br><span class="line">            ... <span class="comment">//报告信息</span></span><br><span class="line">            <span class="comment">//被LMK杀死，说明系统内存不足</span></span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//通过AMS杀死的进程</span></span><br><span class="line">            <span class="comment">// Note that we always want to do oom adj to update our state with the</span></span><br><span class="line">            <span class="comment">// new number of procs.</span></span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//正常情况下非内存不足</span></span><br><span class="line">            doLowMem = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//事件记录</span></span><br><span class="line">        <span class="comment">//继续处理App进程死亡</span></span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (doOomAdj) &#123;</span><br><span class="line">            updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_PROCESS_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当因为内存不足而杀死App进程时</span></span><br><span class="line">        <span class="comment">//调用App层各处的的onLowMemory方法，释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (doLowMem) &#123;</span><br><span class="line">            doLowMemReportIfNeededLocked(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) &#123; <span class="comment">//新进程已启动</span></span><br><span class="line">        <span class="comment">// A new process has already been started.</span></span><br><span class="line">        ... <span class="comment">//报告记录信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的其他代码我们都不用关心，直接看<code>handleAppDiedLocked</code>方法继续处理App进程死亡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleAppDiedLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//清理进程的主要方法</span></span><br><span class="line">    <span class="keyword">boolean</span> kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mServices.killServicesLocked(app, allowRestart);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>ActiveServices.killServicesLocked</code>方法停止还在运行中的服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">killServicesLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clean up any connections this application has to other services.</span></span><br><span class="line">    <span class="comment">//清理所有连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ConnectionRecord r = app.connections.valueAt(i);</span><br><span class="line">        removeConnectionLocked(r, app, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    updateServiceConnectionActivitiesLocked(app);</span><br><span class="line">    app.connections.clear();</span><br><span class="line"></span><br><span class="line">    app.whitelistManager = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear app state from services.</span></span><br><span class="line">    <span class="comment">//遍历所有正在运行中的服务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.numberOfRunningServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.getRunningServiceAt(i);</span><br><span class="line">        <span class="keyword">synchronized</span> (sr.stats.getBatteryStats()) &#123;</span><br><span class="line">            sr.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sr.app != app &amp;&amp; sr.app != <span class="keyword">null</span> &amp;&amp; !sr.app.isPersistent()) &#123;</span><br><span class="line">            <span class="comment">//记录服务已停止</span></span><br><span class="line">            sr.app.stopService(sr);</span><br><span class="line">            <span class="comment">//更新绑定的客户端uids</span></span><br><span class="line">            sr.app.updateBoundClientUids();</span><br><span class="line">        &#125;</span><br><span class="line">        sr.setProcess(<span class="keyword">null</span>);</span><br><span class="line">        sr.isolatedProc = <span class="keyword">null</span>;</span><br><span class="line">        sr.executeNesting = <span class="number">0</span>;</span><br><span class="line">        sr.forceClearTracker();</span><br><span class="line">        <span class="keyword">if</span> (mDestroyingServices.remove(sr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"killServices remove destroying "</span> + sr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numClients = sr.bindings.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bindingi=numClients-<span class="number">1</span>; bindingi&gt;=<span class="number">0</span>; bindingi--) &#123;</span><br><span class="line">            IntentBindRecord b = sr.bindings.valueAt(bindingi);</span><br><span class="line">            <span class="comment">//释放对服务Binder的引用</span></span><br><span class="line">            b.binder = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//重置</span></span><br><span class="line">            b.requested = b.received = b.hasBound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// If this binding is coming from a cached process and is asking to keep</span></span><br><span class="line">            <span class="comment">// the service created, then we'll kill the cached process as well -- we</span></span><br><span class="line">            <span class="comment">// don't want to be thrashing around restarting processes that are only</span></span><br><span class="line">            <span class="comment">// there to be cached.</span></span><br><span class="line">            ... <span class="comment">//遍历客户端进程（实际上没做任何事）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceMap smap = getServiceMapLocked(app.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now do remaining service cleanup.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.numberOfRunningServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.getRunningServiceAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unless the process is persistent, this process record is going away,</span></span><br><span class="line">        <span class="comment">// so make sure the service is cleaned out of it.</span></span><br><span class="line">        <span class="comment">//非持久化进程</span></span><br><span class="line">        <span class="keyword">if</span> (!app.isPersistent()) &#123;</span><br><span class="line">            <span class="comment">//记录服务已停止</span></span><br><span class="line">            app.stopService(sr);</span><br><span class="line">            <span class="comment">//更新绑定的客户端uids</span></span><br><span class="line">            app.updateBoundClientUids();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sanity check: if the service listed for the app is not one</span></span><br><span class="line">        <span class="comment">// we actually are maintaining, just let it drop.</span></span><br><span class="line">        <span class="comment">//一致性检查</span></span><br><span class="line">        <span class="keyword">final</span> ServiceRecord curRec = smap.mServicesByInstanceName.get(sr.instanceName);</span><br><span class="line">        <span class="keyword">if</span> (curRec != sr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curRec != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Service "</span> + sr + <span class="string">" in process "</span> + app</span><br><span class="line">                        + <span class="string">" not same as in map: "</span> + curRec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Any services running in the application may need to be placed</span></span><br><span class="line">        <span class="comment">// back in the pending list.</span></span><br><span class="line">        <span class="comment">//允许重启，但Service崩溃的次数超出重试上限（默认为16），并且它不是系统应用</span></span><br><span class="line">        <span class="keyword">if</span> (allowRestart &amp;&amp; sr.crashCount &gt;= mAm.mConstants.BOUND_SERVICE_MAX_CRASH_RETRY</span><br><span class="line">                &amp;&amp; (sr.serviceInfo.applicationInfo.flags</span><br><span class="line">                    &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123;</span><br><span class="line">            ... <span class="comment">//记录</span></span><br><span class="line">            <span class="comment">//停止服务</span></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowRestart</span><br><span class="line">                || !mAm.mUserController.isUserRunning(sr.userId, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//不允许重启或者服务进程所在用户不在运行，停止服务</span></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尝试调度重启服务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> scheduled = scheduleServiceRestartLocked(sr, <span class="keyword">true</span> <span class="comment">/* allowCancel */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Should the service remain running?  Note that in the</span></span><br><span class="line">            <span class="comment">// extreme case of so many attempts to deliver a command</span></span><br><span class="line">            <span class="comment">// that it failed we also will stop it here.</span></span><br><span class="line">            <span class="keyword">if</span> (!scheduled) &#123; <span class="comment">//未调度重启</span></span><br><span class="line">                <span class="comment">//停止服务</span></span><br><span class="line">                bringDownServiceLocked(sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sr.canStopIfKilled(<span class="keyword">false</span> <span class="comment">/* isStartCanceled */</span>)) &#123;</span><br><span class="line">                <span class="comment">// Update to stopped state because the explicit start is gone. The service is</span></span><br><span class="line">                <span class="comment">// scheduled to restart for other reason (e.g. connections) so we don't bring</span></span><br><span class="line">                <span class="comment">// down it.</span></span><br><span class="line">                <span class="comment">//将服务的启动状态更新为停止</span></span><br><span class="line">                sr.startRequested = <span class="keyword">false</span>;</span><br><span class="line">                ... <span class="comment">//记录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不允许重启的话</span></span><br><span class="line">    <span class="keyword">if</span> (!allowRestart) &#123;</span><br><span class="line">        <span class="comment">//停止所有服务</span></span><br><span class="line">        app.stopAllServices();</span><br><span class="line">        <span class="comment">//清理绑定的客户端uids</span></span><br><span class="line">        app.clearBoundClientUids();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure there are no more restarting services for this process.</span></span><br><span class="line">        <span class="comment">//确保这个进程不再会重启服务，清理所有待重启待启动的服务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord r = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line">                mRestartingServices.remove(i);</span><br><span class="line">                clearRestartingIfNeededLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord r = mPendingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we have no more records on the stopping list.</span></span><br><span class="line">    <span class="comment">//清理所有停止中的服务</span></span><br><span class="line">    <span class="keyword">int</span> i = mDestroyingServices.size();</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        ServiceRecord sr = mDestroyingServices.get(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.app == app) &#123;</span><br><span class="line">            sr.forceClearTracker();</span><br><span class="line">            mDestroyingServices.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理所有执行中的服务</span></span><br><span class="line">    <span class="comment">//这里的执行中指的是有事务正在运行，比如说正在停止过程中，不是指运行中</span></span><br><span class="line">    app.executingServices.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了各种清理工作，客户端进程的清理呀，服务端进程的清理，然后就是<code>Service</code>重启的核心，<code>scheduleServiceRestartLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">scheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> allowCancel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//系统正在关机，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.mAtmInternal.isShuttingDown()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一致性检查</span></span><br><span class="line">    ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="keyword">if</span> (smap.mServicesByInstanceName.get(r.instanceName) != r) &#123;</span><br><span class="line">        ServiceRecord cur = smap.mServicesByInstanceName.get(r.instanceName);</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Attempting to schedule restart of "</span> + r</span><br><span class="line">                + <span class="string">" when found in map: "</span> + cur);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String reason;</span><br><span class="line">    <span class="keyword">if</span> ((r.serviceInfo.applicationInfo.flags</span><br><span class="line">            &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123; <span class="comment">//对于非系统应用</span></span><br><span class="line">        <span class="comment">//服务至少要过多长时间才能重启，默认1000ms</span></span><br><span class="line">        <span class="keyword">long</span> minDuration = mAm.mConstants.SERVICE_RESTART_DURATION;</span><br><span class="line">        <span class="comment">//服务被杀死重启后需要运行多长时间，默认60s</span></span><br><span class="line">        <span class="keyword">long</span> resetTime = mAm.mConstants.SERVICE_RESET_RUN_DURATION;</span><br><span class="line">        <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Any delivered but not yet finished starts should be put back</span></span><br><span class="line">        <span class="comment">// on the pending list.</span></span><br><span class="line">        <span class="comment">//对应着返回值为START_REDELIVER_INTENT的情况</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = r.deliveredStarts.size();</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ServiceRecord.StartItem si = r.deliveredStarts.get(i);</span><br><span class="line">                si.removeUriPermissionsLocked();</span><br><span class="line">                <span class="keyword">if</span> (si.intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We'll generate this again if needed.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowCancel || (si.deliveryCount &lt; ServiceRecord.MAX_DELIVERY_COUNT</span><br><span class="line">                        &amp;&amp; si.doneExecutingCount &lt; ServiceRecord.MAX_DONE_EXECUTING_COUNT)) &#123;</span><br><span class="line">                    <span class="comment">//如果该启动项的失败次数小于最大容忍次数</span></span><br><span class="line">                    <span class="comment">//MAX_DELIVERY_COUNT默认为3</span></span><br><span class="line">                    <span class="comment">//MAX_DONE_EXECUTING_COUNT默认为6</span></span><br><span class="line">                    r.pendingStarts.add(<span class="number">0</span>, si);</span><br><span class="line">                    <span class="comment">//这种情况下延时是现在距离启动时间的两倍</span></span><br><span class="line">                    <span class="keyword">long</span> dur = SystemClock.uptimeMillis() - si.deliveredTime;</span><br><span class="line">                    dur *= <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (minDuration &lt; dur) minDuration = dur;</span><br><span class="line">                    <span class="keyword">if</span> (resetTime &lt; dur) resetTime = dur;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果该启动项的失败次数大于等于最大容忍次数</span></span><br><span class="line">                    canceled = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.deliveredStarts.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowCancel) &#123;</span><br><span class="line">            <span class="comment">//判断是否应该停止（只考虑非绑定启动的情况）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> shouldStop = r.canStopIfKilled(canceled);</span><br><span class="line">            <span class="keyword">if</span> (shouldStop &amp;&amp; !r.hasAutoCreateConnections()) &#123;</span><br><span class="line">                <span class="comment">// Nothing to restart.</span></span><br><span class="line">                <span class="comment">//如果应该停止，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reason = (r.startRequested &amp;&amp; !shouldStop) ? <span class="string">"start-requested"</span> : <span class="string">"connection"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reason = <span class="string">"always"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.totalRestartCount++;</span><br><span class="line">        <span class="keyword">if</span> (r.restartDelay == <span class="number">0</span>) &#123; <span class="comment">//第一次重启的情况</span></span><br><span class="line">            r.restartCount++;</span><br><span class="line">            r.restartDelay = minDuration;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.crashCount &gt; <span class="number">1</span>) &#123; <span class="comment">//Service所在进程在Service运行过程中发生崩溃导致重启的话</span></span><br><span class="line">            <span class="comment">//重启延时为 30min * (崩溃次数 - 1)</span></span><br><span class="line">            r.restartDelay = mAm.mConstants.BOUND_SERVICE_CRASH_RESTART_DURATION</span><br><span class="line">                    * (r.crashCount - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//非第一次重启的情况</span></span><br><span class="line">            <span class="comment">// If it has been a "reasonably long time" since the service</span></span><br><span class="line">            <span class="comment">// was started, then reset our restart duration back to</span></span><br><span class="line">            <span class="comment">// the beginning, so we don't infinitely increase the duration</span></span><br><span class="line">            <span class="comment">// on a service that just occasionally gets killed (which is</span></span><br><span class="line">            <span class="comment">// a normal case, due to process being killed to reclaim memory).</span></span><br><span class="line">            <span class="keyword">if</span> (now &gt; (r.restartTime+resetTime)) &#123;</span><br><span class="line">                <span class="comment">//如果服务重启后运行达到了一定时间，则重启延时为</span></span><br><span class="line">                r.restartCount = <span class="number">1</span>;</span><br><span class="line">                r.restartDelay = minDuration;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果服务重启后运行没有达到一定时间（短时间内又要重启）</span></span><br><span class="line">                <span class="comment">//则增长重启延时，默认因子为4</span></span><br><span class="line">                r.restartDelay *= mAm.mConstants.SERVICE_RESTART_DURATION_FACTOR;</span><br><span class="line">                <span class="keyword">if</span> (r.restartDelay &lt; minDuration) &#123;</span><br><span class="line">                    r.restartDelay = minDuration;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定重启时间</span></span><br><span class="line">        r.nextRestartTime = now + r.restartDelay;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that we don't end up restarting a bunch of services</span></span><br><span class="line">        <span class="comment">// all at the same time.</span></span><br><span class="line">        <span class="comment">//确保不会在同一时间启动大量服务</span></span><br><span class="line">        <span class="keyword">boolean</span> repeat;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            repeat = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> restartTimeBetween = mAm.mConstants.SERVICE_MIN_RESTART_TIME_BETWEEN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ServiceRecord r2 = mRestartingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (r2 != r &amp;&amp; r.nextRestartTime &gt;= (r2.nextRestartTime-restartTimeBetween)</span><br><span class="line">                        &amp;&amp; r.nextRestartTime &lt; (r2.nextRestartTime+restartTimeBetween)) &#123;</span><br><span class="line">                    r.nextRestartTime = r2.nextRestartTime + restartTimeBetween;</span><br><span class="line">                    r.restartDelay = r.nextRestartTime - now;</span><br><span class="line">                    repeat = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (repeat);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//对于系统进程，立马重启</span></span><br><span class="line">        <span class="comment">// Persistent processes are immediately restarted, so there is no</span></span><br><span class="line">        <span class="comment">// reason to hold of on restarting their services.</span></span><br><span class="line">        r.totalRestartCount++;</span><br><span class="line">        r.restartCount = <span class="number">0</span>;</span><br><span class="line">        r.restartDelay = <span class="number">0</span>;</span><br><span class="line">        r.nextRestartTime = now;</span><br><span class="line">        reason = <span class="string">"persistent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加到重启列表中</span></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        r.createdFromFg = <span class="keyword">false</span>;</span><br><span class="line">        mRestartingServices.add(r);</span><br><span class="line">        r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消前台服务通知</span></span><br><span class="line">    cancelForegroundNotificationLocked(r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Handler调度重启</span></span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line">    mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime);</span><br><span class="line">    r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay;</span><br><span class="line">    ... <span class="comment">//事件记录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了几件事情，一是判断服务需不需要重启，二是计算服务的下次重启时间，最后通过<code>Handler</code>执行延时重启</p>
<p>还记得我们前面说的当返回值为<code>START_REDELIVER_INTENT</code>时，不会从<code>ServiceRecord.deliveredStarts</code>中删除启动项吗？这里就体现出了这一点，遍历整个<code>deliveredStarts</code>列表，从中找出符合重启条件的启动项，将其加入到<code>pendingStarts</code>列表中，需要注意的是，在这种情况下，重启延时为现在距离启动时间的两倍，所以一般情况下<code>START_REDELIVER_INTENT</code>比<code>START_STICKY</code>重启的要更慢</p>
<p>接下来便要判断服务需不需要重启，这里调用了<code>ServiceRecord.canStopIfKilled</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canStopIfKilled</span><span class="params">(<span class="keyword">boolean</span> isStartCanceled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startRequested &amp;&amp; (stopIfKilled || isStartCanceled) &amp;&amp; pendingStarts.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说过，如果返回值为<code>START_STICKY</code>或<code>START_STICKY_COMPATIBILITY</code>，那这里的<code>stopIfKilled</code>就为<code>false</code>，所以整体会返回<code>false</code>，而对于返回值<code>START_REDELIVER_INTENT</code>而言，之前已经进行过操作，将启动项添加到<code>pendingStarts</code>列表中了，所以只要这里为<code>false</code>，整体就为<code>false</code>，<code>stopIfKilled</code>的值就不重要了</p>
<p>最后就是通过<code>Handler</code>执行延时重启了，这里<code>Handler</code>传入的<code>Runnable</code>是<code>ServiceRecord.restarter</code>，它是在服务启动，调用<code>retrieveServiceLocked</code>方法时被创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setService</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在一定的延时后，会调用到<code>performServiceRestartLocked</code>方法重启服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performServiceRestartLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isServiceNeededLocked(r, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Paranoia: is this service actually needed?  In theory a service that is not</span></span><br><span class="line">        <span class="comment">// needed should never remain on the restart list.  In practice...  well, there</span></span><br><span class="line">        <span class="comment">// have been bugs where this happens, and bad things happen because the process</span></span><br><span class="line">        <span class="comment">// ends up just being cached, so quickly killed, then restarted again and again.</span></span><br><span class="line">        <span class="comment">// Let's not let that happen.</span></span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Restarting service that is not needed: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//参考上一篇文章，Service启动流程</span></span><br><span class="line">        bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore, it's been logged and nothing upstack cares.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了<code>bringUpServiceLocked</code>方法启动服务，这一部分可以看上一篇文章 <a href="https://juejin.cn/post/7276363520554795064" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中的分析，还记得上一篇文章中分析的<code>realStartServiceLocked</code>方法中，有一个逻辑是：如果<code>Service</code>已经启动，并且没有启动项，则构建一个假的启动参数供<code>onStartCommand</code>使用 吗？之前看到这个逻辑的时候我还有些疑惑为什么需要这样，现在就豁然开朗了，原来这是为<code>Service</code>重启做的逻辑，而对于返回值<code>START_REDELIVER_INTENT</code>而言，<code>pendingStarts</code>列表本身就不为空，直接正常执行启动任务就可以了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个<code>Service</code>篇章就到此结束了，通过这次的写作，我自身也是受益匪浅，了解到了很多我以前不知道的知识，也纠正了一些我以前错误的认知，如果也能帮到正在看文章的你们，那就再好不过了</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><a class="post-meta__tags" href="/tags/Service/">Service</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/10/25/interview/2023%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85/"><i class="fa fa-chevron-left">  </i><span>2023小红书Android面试之旅</span></a></div><div class="next-post pull-right"><a href="/2023/08/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"><span>Android源码分析 - Service启动流程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>