<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Service启动流程"><meta name="keywords" content="Android源码,ActivityManagerService,Service"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Service启动流程 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程图"><span class="toc-number">2.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#入口"><span class="toc-number">3.</span> <span class="toc-text">入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-startService"><span class="toc-number">3.1.</span> <span class="toc-text">Context.startService</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程未启动"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程未启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveServices-attachApplicationLocked"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">ActiveServices.attachApplicationLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程已启动"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程已启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ActiveServices-realStartServiceLocked"><span class="toc-number">3.1.3.</span> <span class="toc-text">ActiveServices.realStartServiceLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建Service"><span class="toc-number">3.1.4.</span> <span class="toc-text">创建Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动Service"><span class="toc-number">3.1.5.</span> <span class="toc-text">启动Service</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context-bindService"><span class="toc-number">3.2.</span> <span class="toc-text">Context.bindService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Service启动流程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Service/">Service</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在之前的文章中，我们已经分析过了四大组件中<code>Activity</code>和<code>ContentProvider</code>的启动流程，这次我们就来讲讲四大组件之一的<code>Service</code>是如何启动和绑定的</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>在查阅资料的过程中，我发现有些博主会将梳理好的流程图贴在开头，我觉得这样有助于从宏观上去理解源码的整个流程和设计理念，所以以后的文章我都会尽量将源码梳理成流程图，以便大家理解</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_startService%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="startService流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_bindService%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="bindService流程图"></p>
<h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>启动<code>Service</code>有两种方式，一是<code>startService</code>，一是<code>bindService</code>，它们最终的实现都在<code>ContextImpl</code>中</p>
<h2 id="Context-startService"><a href="#Context-startService" class="headerlink" title="Context.startService"></a>Context.startService</h2><p>当<code>Service</code>通过这种方式启动后，会一直运行下去，直到外部调用了<code>stopService</code>或内部调用<code>stopSelf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="keyword">false</span>, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//确保Intent有效</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="comment">//跨进程准备</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//调用AMS.startService</span></span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()), requireForeground,</span><br><span class="line">                getOpPackageName(), getAttributionTag(), user.getIdentifier());</span><br><span class="line">        <span class="comment">//通过AMS层返回的ComponentName.packageName来判断是否出错以及错误类型</span></span><br><span class="line">        <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service</span><br><span class="line">                        + <span class="string">" without permission "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + service</span><br><span class="line">                        + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"?"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，这里就是做了一下简单的校验，然后便调用了<code>AMS.startService</code>启动<code>Service</code>，最终通过返回的<code>ComponentName</code>中的<code>packageName</code>来判断是否出错以及错误类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">boolean</span> requireForeground, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方包名不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用ActiveServices.startServiceLocked方法</span></span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, callingFeatureId, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里做了一些简单的检查，然后调用<code>ActiveServices.startServiceLocked</code>方法，<code>ActiveServices</code>是一个辅助<code>AMS</code>进行<code>Service</code>管理的类，包括<code>Service</code>的启动、绑定和停止等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired,</span><br><span class="line">            callingPackage, callingFeatureId, userId, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, <span class="keyword">final</span> <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowBackgroundActivityStarts)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//判断调用方是否为前台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">") when starting service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找待启动Service</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, <span class="keyword">null</span>, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//如果找不到待启动Service，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果待启动的Service所在package和uid无法与调用方package和uid建立关联，则无法启动Service</span></span><br><span class="line">    <span class="comment">//返回异常ComponentName，由上层抛出SecurityException异常</span></span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!"</span>, res.permission != <span class="keyword">null</span></span><br><span class="line">                ? res.permission : <span class="string">"private to package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//试图用一个不存在的用户启动Service</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Trying to start service with non-existent user! "</span> + r.userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're starting indirectly (e.g. from PendingIntent), figure out whether</span></span><br><span class="line">    <span class="comment">// we're launching into an app in a background state.  This keys off of the same</span></span><br><span class="line">    <span class="comment">// idleness state tracking as e.g. O+ background service start policy.</span></span><br><span class="line">    <span class="comment">//Service所在应用未启动或处在后台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> bgLaunch = !mAm.isUidActiveLocked(r.appInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the app has strict background restrictions, we treat any bg service</span></span><br><span class="line">    <span class="comment">// start analogously to the legacy-app forced-restrictions case, regardless</span></span><br><span class="line">    <span class="comment">// of its target SDK version.</span></span><br><span class="line">    <span class="comment">//检查Service所在应用后台启动限制</span></span><br><span class="line">    <span class="keyword">boolean</span> forcedStandby = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (bgLaunch &amp;&amp; appRestrictedAnyInBackground(r.appInfo.uid, r.packageName)) &#123;</span><br><span class="line">        forcedStandby = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a direct-to-foreground start, make sure it is allowed as per the app op.</span></span><br><span class="line">    <span class="keyword">boolean</span> forceSilentAbort = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (fgRequired) &#123; <span class="comment">//作为前台服务启动</span></span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mAm.getAppOpsManager().checkOpNoThrow(</span><br><span class="line">                AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="comment">//默认和允许都可以作为前台服务启动</span></span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_ALLOWED:</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_DEFAULT:</span><br><span class="line">                <span class="comment">// All okay.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//不允许的话，回退到作为普通后台服务启动</span></span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_IGNORED:</span><br><span class="line">                <span class="comment">// Not allowed, fall back to normal start service, failing siliently</span></span><br><span class="line">                <span class="comment">// if background check restricts that.</span></span><br><span class="line">                Slog.w(TAG, <span class="string">"startForegroundService not allowed due to app op: service "</span></span><br><span class="line">                        + service + <span class="string">" to "</span> + r.shortInstanceName</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid + <span class="string">" uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" pkg="</span> + callingPackage);</span><br><span class="line">                fgRequired = <span class="keyword">false</span>;</span><br><span class="line">                forceSilentAbort = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//错误的话直接返回，由上层抛出SecurityException异常</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, <span class="string">"foreground not allowed as per app op"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this isn't a direct-to-foreground start, check our ability to kick off an</span></span><br><span class="line">    <span class="comment">// arbitrary service</span></span><br><span class="line">    <span class="comment">//如果不是从前台启动</span></span><br><span class="line">    <span class="comment">//startRequested表示Service是否由startService方式所启动，fgRequired表示作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123;</span><br><span class="line">        <span class="comment">// Before going further -- if this app is not allowed to start services in the</span></span><br><span class="line">        <span class="comment">// background, then at this point we aren't going to let it period.</span></span><br><span class="line">        <span class="comment">//服务是否允许在后台启动</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> allowed = mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName,</span><br><span class="line">                r.appInfo.targetSdkVersion, callingPid, <span class="keyword">false</span>, <span class="keyword">false</span>, forcedStandby);</span><br><span class="line">        <span class="comment">//如果不允许，则无法启动服务</span></span><br><span class="line">        <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">//静默的停止启动</span></span><br><span class="line">            <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123;</span><br><span class="line">                <span class="comment">// In this case we are silently disabling the app, to disrupt as</span></span><br><span class="line">                <span class="comment">// little as possible existing apps.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (forcedStandby) &#123;</span><br><span class="line">                <span class="comment">// This is an O+ app, but we might be here because the user has placed</span></span><br><span class="line">                <span class="comment">// it under strict background restrictions.  Don't punish the app if it's</span></span><br><span class="line">                <span class="comment">// trying to do the right thing but we're denying it for that reason.</span></span><br><span class="line">                <span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This app knows it is in the new model where this operation is not</span></span><br><span class="line">            <span class="comment">// allowed, so tell it what has happened.</span></span><br><span class="line">            <span class="comment">//明确的告知不允许启动，上层抛出异常</span></span><br><span class="line">            UidRecord uidRec = mAm.mProcessList.getUidRecordLocked(r.appInfo.uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"?"</span>, <span class="string">"app is in background uid "</span> + uidRec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we've applied allowed-to-start policy based on whether this was</span></span><br><span class="line">    <span class="comment">// an ordinary startService() or a startForegroundService().  Now, only require that</span></span><br><span class="line">    <span class="comment">// the app follow through on the startForegroundService() -&gt; startForeground()</span></span><br><span class="line">    <span class="comment">// contract if it actually targets O+.</span></span><br><span class="line">    <span class="comment">//对于targetSdk 26以下（Android 8.0以下）的应用来说，不需要作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (r.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O &amp;&amp; fgRequired) &#123;</span><br><span class="line">        fgRequired = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查通过Intent被临时授权的Uris</span></span><br><span class="line">    NeededUriGrants neededGrants = mAm.mUgmInternal.checkGrantUriPermissionFromIntent(</span><br><span class="line">            service, callingUid, r.packageName, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line">    <span class="comment">// we do not start the service and launch a review activity if the calling app</span></span><br><span class="line">    <span class="comment">// is in the foreground passing it a pending intent to start the service when</span></span><br><span class="line">    <span class="comment">// review is completed.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX This is not dealing with fgRequired!</span></span><br><span class="line">    <span class="comment">//如果待启动的Service需要相应权限，则需要用户手动确认权限后，再进行启动</span></span><br><span class="line">    <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage, callingFeatureId,</span><br><span class="line">            callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">    <span class="keyword">if</span> (unscheduleServiceRestartLocked(r, callingUid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"START SERVICE WHILE RESTART PENDING: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//表示Service是否由startService方式所启动的</span></span><br><span class="line">    r.startRequested = <span class="keyword">true</span>;</span><br><span class="line">    r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否作为前台服务启动</span></span><br><span class="line">    r.fgRequired = fgRequired;</span><br><span class="line">    <span class="comment">//构造启动参数</span></span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants, callingUid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">        <span class="comment">// We are now effectively running a foreground service.</span></span><br><span class="line">        ... <span class="comment">//使用ServiceState记录</span></span><br><span class="line">        ... <span class="comment">//通过AppOpsService监控</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="keyword">boolean</span> addToStarting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//对于后台启动的非前台服务，需要判断其是否需要延迟启动</span></span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; !fgRequired &amp;&amp; r.app == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="comment">//获取Service所处进程信息</span></span><br><span class="line">        ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//没有对应进程或进程状态级别低于 [进程在后台运行Receiver]</span></span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span> || proc.getCurProcState() &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            <span class="comment">// If this is not coming from a foreground caller, then we may want</span></span><br><span class="line">            <span class="comment">// to delay the start if there are already other background services</span></span><br><span class="line">            <span class="comment">// that are starting.  This is to avoid process start spam when lots</span></span><br><span class="line">            <span class="comment">// of applications are all handling things like connectivity broadcasts.</span></span><br><span class="line">            <span class="comment">// We only do this for cached processes, because otherwise an application</span></span><br><span class="line">            <span class="comment">// can have assumptions about calling startService() for a service to run</span></span><br><span class="line">            <span class="comment">// in its own process, and for that process to not be killed before the</span></span><br><span class="line">            <span class="comment">// service is started.  This is especially the case for receivers, which</span></span><br><span class="line">            <span class="comment">// may start a service in onReceive() to do some additional work and have</span></span><br><span class="line">            <span class="comment">// initialized some global state as part of that.</span></span><br><span class="line">            <span class="comment">//对于之前已经设置为延迟启动的服务，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">                <span class="comment">// This service is already scheduled for a delayed start; just leave</span></span><br><span class="line">                <span class="comment">// it still waiting.</span></span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前正在后台启动的Service数大于等于允许同时在后台启动的最大服务数</span></span><br><span class="line">            <span class="comment">//将这个Service设置为延迟启动</span></span><br><span class="line">            <span class="keyword">if</span> (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                <span class="comment">// Something else is starting, delay!</span></span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                r.delayed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加到正在启动服务列表中</span></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.getCurProcState() &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            <span class="comment">//进程状态为 [正在运行Service的后台进程] 或 [正在运行Receiver的后台进程] 时</span></span><br><span class="line">            <span class="comment">// We slightly loosen when we will enqueue this new service as a background</span></span><br><span class="line">            <span class="comment">// starting service we are waiting for, to also include processes that are</span></span><br><span class="line">            <span class="comment">// currently running other services or receivers.</span></span><br><span class="line">            <span class="comment">//添加到正在启动服务列表中</span></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果允许Service后台启动Activity，则将其加入到白名单中</span></span><br><span class="line">    <span class="keyword">if</span> (allowBackgroundActivityStarts) &#123;</span><br><span class="line">        r.whitelistBgActivityStartsOnServiceStart();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续启动Service</span></span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否允许前台服务使用while-in-use权限</span></span><br><span class="line">    <span class="keyword">if</span> (!r.mAllowWhileInUsePermissionInFgs) &#123;</span><br><span class="line">        r.mAllowWhileInUsePermissionInFgs =</span><br><span class="line">                shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, callingPid,</span><br><span class="line">                        callingUid, service, r, allowBackgroundActivityStarts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法涉及到很多前后台判断，我想这里的前后台其实分为三个概念，一是调用方App是否在前台，二是<code>Service</code>方App是否在前台，三是<code>Service</code>是否作为前台服务启动，当然，大部分情况启动的都是App内的<code>Service</code>，即一二中的前后台状态是一致的，但也不排除启动其他App的<code>Service</code>这种情况，所以这里还是需要好好区分开来</p>
<p>这个方法看起来很长，但总之都是一些<code>Service</code>启动前的预处理工作，主要做了以下几点工作：</p>
<ol>
<li>判断调用方进程是否在前台（<code>callerFg</code>）：对于调用方在后台启动的<code>Service</code>，需要判断其是否需要延迟启动</li>
<li>调用<code>retrieveServiceLocked</code>查找待启动<code>Service</code>信息（<code>ServiceRecord</code>）</li>
<li>各种检查，一旦发现不满足启动条件就终止启动<code>Service</code></li>
<li>检查<code>Service</code>所在应用的前后台状态以及后台启动限制，不符合条件则终止启动<code>Service</code></li>
<li>判断是否可以作为前台服务启动</li>
<li>如果待启动的<code>Service</code>需要相应权限，则需要用户手动确认权限后，再进行启动</li>
<li>取消之前的<code>Service</code>重启任务（如果有）</li>
<li>设置<code>ServiceRecord</code>状态，包括上次活动时间，是否由startService方式所启动的，是否作为前台服务启动等</li>
<li>如果作为前台服务启动，则需要进行记录和监控</li>
<li>对于后台启动的非前台服务，需要判断其是否需要延迟启动</li>
<li>调用<code>startServiceInnerLocked</code>继续启动<code>Service</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line">    <span class="comment">//启动前初始化</span></span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line">    <span class="comment">//拉起服务，如果服务未启动，则会启动服务并调用其onCreate和onStartCommand方法</span></span><br><span class="line">    <span class="comment">//如果服务已启动，由于之前构造了启动参数，则会直接调用其onStartCommand方法</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123; <span class="comment">//对于后台启动服务的情况</span></span><br><span class="line">        <span class="comment">//是否为第一个后台启动的服务</span></span><br><span class="line">        <span class="keyword">boolean</span> first = smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//添加到正在后台启动服务列表中</span></span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        <span class="comment">//设置后台启动服务超时时间（默认15秒）</span></span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        <span class="comment">//如果为第一个后台启动的服务，则代表后面暂时没有正在后台启动的服务了</span></span><br><span class="line">        <span class="comment">//此时将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123; <span class="comment">//对于调用方进程为前台或作为前台服务启动的情况</span></span><br><span class="line">        <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">        <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先会调用<code>bringUpServiceLocked</code>方法拉起服务，然后根据服务是否为前台启动，分别调用<code>ServiceMap.rescheduleDelayedStartsLocked</code>和<code>ServiceMap.ensureNotStartingBackgroundLocked</code>方法从后台延迟启动服务列表<code>mDelayedStartList</code>中不断地调度启动服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//如果Service所在的进程存在，并且其IApplicationThread也存在</span></span><br><span class="line">    <span class="comment">//说明服务已启动（因为在启动服务时，会给ServiceRecord.app赋值，并且app.thread不为null说明进程没有被杀死）</span></span><br><span class="line">    <span class="comment">//此时直接拉起Service.onStartCommand方法</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果服务正在重启中，则什么都不做，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="comment">// If waiting for a restart, then do nothing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are now bringing the service up, so no longer in the</span></span><br><span class="line">    <span class="comment">// restarting state.</span></span><br><span class="line">    <span class="comment">//Service马上启动，将其从重启中服务列表中移除，并清除其重启中状态</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this service is no longer considered delayed, we are starting it now.</span></span><br><span class="line">    <span class="comment">//走到这里，需要确保此服务不再被视为延迟启动，同时将其从延迟启动服务列表中移除</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this service is started.  If not,</span></span><br><span class="line">    <span class="comment">// we don't want to allow it to run.</span></span><br><span class="line">    <span class="comment">//确保Service所在的用户已启动</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="comment">//停止服务</span></span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Service is now being launched, its package can't be stopped.</span></span><br><span class="line">    <span class="comment">//Service即将启动，Service所属的App不该为stopped状态</span></span><br><span class="line">    <span class="comment">//将App状态置为unstopped，设置休眠状态为false</span></span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务所在进程是否为隔离进程，指服务是否在其自己的独立进程中运行</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    HostingRecord hostingRecord = <span class="keyword">new</span> HostingRecord(<span class="string">"service"</span>, r.instanceName);</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123; <span class="comment">//非隔离进程</span></span><br><span class="line">        <span class="comment">//获取进程的ProcessRecord对象</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">            app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">            <span class="comment">//接着启动Service</span></span><br><span class="line">            realStartServiceLocked(r, app, execInFg);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//隔离进程</span></span><br><span class="line">        <span class="comment">// If this service runs in an isolated process, then each time</span></span><br><span class="line">        <span class="comment">// we call startProcessLocked() we will get a new isolated</span></span><br><span class="line">        <span class="comment">// process, starting another process if we are currently waiting</span></span><br><span class="line">        <span class="comment">// for a previous process to come up.  To deal with this, we store</span></span><br><span class="line">        <span class="comment">// in the service any current isolated process it is running in or</span></span><br><span class="line">        <span class="comment">// waiting to have come up.</span></span><br><span class="line">        <span class="comment">//获取服务之前所在的进程</span></span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">        <span class="comment">//辅助zygote进程，用于创建isolated_app进程来渲染不可信的web内容，具有最为严格的安全限制</span></span><br><span class="line">        <span class="keyword">if</span> (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byWebviewZygote(r.instanceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用zygote进程，与常规zygote创建的应用相比受到更多限制</span></span><br><span class="line">        <span class="keyword">if</span> ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != <span class="number">0</span>) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName,</span><br><span class="line">                    r.definingUid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="comment">//如果Service所在进程尚未启动</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="comment">// TODO (chriswailes): Change the Zygote policy flags based on if the launch-for-service</span></span><br><span class="line">        <span class="comment">//  was initiated from a notification tap or not.</span></span><br><span class="line">        <span class="comment">//启动App进程</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                hostingRecord, ZYGOTE_POLICY_FLAG_EMPTY, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果启动进程失败，停止服务</span></span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            <span class="comment">//如果是隔离进程，将这次启动的进程记录保存下来</span></span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于要启动的前台服务，加入到临时白名单，暂时绕过省电模式</span></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                SERVICE_START_FOREGROUND_TIMEOUT, <span class="string">"fg-service-launch"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将启动的服务添加到mPendingServices列表中</span></span><br><span class="line">    <span class="comment">//如果服务进程尚未启动，进程在启动的过程中会检查此列表并启动需要启动的Service</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Service被要求stop，停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法看起来长，其实做的事情并不多：</p>
<ol>
<li>如果<code>Service</code>已经启动，则调用<code>sendServiceArgsLocked</code>方法直接拉起<code>Service.onStartCommand</code>方法</li>
<li>各种检查准备操作（待重启、用户是否启动等，具体见注释）</li>
<li>如果<code>Service</code>所在进程已启动，调用<code>realStartServiceLocked</code>方法接着启动<code>Service</code></li>
<li>如果<code>Service</code>所在进程未启动，调用<code>AMS.startProcessLocked</code>方法启动进程</li>
<li>将要启动的<code>Service</code>添加到<code>mPendingServices</code>列表中，对于<code>Service</code>所在进程未启动的这种情况，在进程的启动过程中会检查此列表并启动需要启动的<code>Service</code>（即此<code>Service</code>）</li>
</ol>
<p>从这里可以看出来，<code>Service</code>的启动分为两个分支，一个是进程已启动，一个是进程未启动</p>
<h3 id="进程未启动"><a href="#进程未启动" class="headerlink" title="进程未启动"></a>进程未启动</h3><p>在进程未启动的情况下，这里会调用<code>AMS.startProcessLocked</code>方法启动进程，接着等待进程启动完成后，会调用到<code>AMS.attachApplicationLocked</code>方法，在这个方法中有一段关于<code>Service</code>启动的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Services等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这里调用了<code>ActiveServices.attachApplicationLocked</code>方法去启动待启动的<code>Service</code></p>
<p>关于<code>App</code>进程启动的流程详见我之前的文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> ，这里就不赘述了</p>
<h4 id="ActiveServices-attachApplicationLocked"><a href="#ActiveServices-attachApplicationLocked" class="headerlink" title="ActiveServices.attachApplicationLocked"></a>ActiveServices.attachApplicationLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the app background restriction of the caller</span></span><br><span class="line">    <span class="comment">//更新Service所在App后台限制</span></span><br><span class="line">    proc.mState.setBackgroundRestricted(appRestrictedAnyInBackground(</span><br><span class="line">            proc.uid, proc.info.packageName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="comment">//启动mPendingServices列表内，该进程下的所有Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolationHostProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> IApplicationThread thread = proc.getThread();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pid = proc.getPid();</span><br><span class="line">                <span class="keyword">final</span> UidRecord uidRecord = proc.getUidRecord();</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                <span class="comment">//启动Service</span></span><br><span class="line">                realStartServiceLocked(sr, proc, thread, pid, uidRecord, sr.createdFromFg,</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//如果此Service不再需要了，则停止它</span></span><br><span class="line">                <span class="comment">//e.g. 通过bindService启动的服务，但此时调用bindService的Activity已死亡</span></span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeededLocked(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// We were waiting for this service to start, but it is actually no</span></span><br><span class="line">                    <span class="comment">// longer needed.  This could happen because bringDownServiceIfNeeded</span></span><br><span class="line">                    <span class="comment">// won't bring down a service that is pending...  so now the pending</span></span><br><span class="line">                    <span class="comment">// is done, so let's drop it.</span></span><br><span class="line">                    bringDownServiceLocked(sr, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Will be a no-op if nothing pending */</span></span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                mAm.updateOomAdjPendingTargetsLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Also, if there are any services that are waiting to restart and</span></span><br><span class="line">    <span class="comment">// would run in this process, now is a good time to start them.  It would</span></span><br><span class="line">    <span class="comment">// be weird to bring up the process but arbitrarily not let the services</span></span><br><span class="line">    <span class="comment">// run at this point just because their restart time hasn't come up.</span></span><br><span class="line">    <span class="comment">//App被杀重启机制，后续文章再详细说明</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会从<code>mPendingServices</code>列表内寻找该进程下的所有待启动<code>Service</code>，然后调用<code>ActiveServices.realStartServiceLocked</code>方法启动它</p>
<h3 id="进程已启动"><a href="#进程已启动" class="headerlink" title="进程已启动"></a>进程已启动</h3><p>对于进程已启动的情况，我们通过<code>ActiveServices.bringUpServiceLocked</code>方法也可以得知，调用了<code>ActiveServices.realStartServiceLocked</code>方法，所以不管进程是否启动，最终都会殊途同归走到<code>ActiveServices.realStartServiceLocked</code>方法启动<code>Service</code></p>
<h3 id="ActiveServices-realStartServiceLocked"><a href="#ActiveServices-realStartServiceLocked" class="headerlink" title="ActiveServices.realStartServiceLocked"></a>ActiveServices.realStartServiceLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note the name of this method should not be confused with the started services concept.</span></span><br><span class="line"><span class="comment"> * The "start" here means bring up the instance in the client, and this method is called</span></span><br><span class="line"><span class="comment"> * from bindService() as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//IApplicationThread不存在则抛移除</span></span><br><span class="line">    <span class="comment">//即确保ActivityThread存在</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为ServiceRecord设置所属进程</span></span><br><span class="line">    r.setProcess(app);</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此进程中将Service记录为运行中</span></span><br><span class="line">    <span class="comment">//返回值为此Service是否之前未启动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.startService(r);</span><br><span class="line">    <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">    <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line">    <span class="comment">//更新进程优先级</span></span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="keyword">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//记录信息</span></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        <span class="comment">//设置进程状态</span></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">//回到App进程，调度创建Service</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        <span class="comment">//显示前台服务通知</span></span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        <span class="comment">//杀死进程</span></span><br><span class="line">        mAm.appDiedLocked(app, <span class="string">"Died when creating service"</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果没能成功创建Service</span></span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="comment">//保证executeNesting计数的准确</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cleanup.</span></span><br><span class="line">            <span class="comment">//停止服务，清除信息</span></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.stopService(r);</span><br><span class="line">                r.setProcess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Retry.</span></span><br><span class="line">            <span class="comment">//重试</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许管理白名单，如省电模式白名单</span></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行Service.onBind方法（通过bindService启动的情况下）</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加绑定到Service所在进程的UID</span></span><br><span class="line">    <span class="keyword">if</span> (newService &amp;&amp; created) &#123;</span><br><span class="line">        app.addBoundClientUidsOfNewService(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line">    <span class="comment">// be called.</span></span><br><span class="line">    <span class="comment">//如果Service已经启动，并且没有启动项，则构建一个假的启动参数供onStartCommand使用</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拉起Service.onStartCommand方法</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里，需要确保此服务不再被视为延迟启动，同时将其从延迟启动服务列表中移除</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Service被要求stop，停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>到了这一步，进程理应启动和初始化完成了，接下来就该实际的去创建<code>Service</code>并启动它了，首先创建<code>Service</code>这一块我们看<code>app.thread.scheduleCreateService</code>方法，这里的<code>app</code>是<code>ProcessRecord</code>，里面的<code>thread</code>是<code>IApplicationThread</code>，<code>ActivityThread</code>中的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新进程状态</span></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//将创建Service的必要信息包装</span></span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line">    <span class="comment">//通过Handler发送Message</span></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将创建<code>Service</code>的必要信息包装成<code>CreateServiceData</code>对象后，通过<code>Handler</code>发送<code>Message</code>处理服务创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ActivityThread</code>的<code>Handler</code>在接收到<code>CREATE_SERVICE</code>消息后调用了<code>handleCreateService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    <span class="comment">//此时不要进行GC</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建Context</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        <span class="comment">//创建或获取Application（到了这里进程的初始化应该都完成了，所以是直接获取Application）</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        <span class="comment">//通过AppComponentFactory反射创建Service实例</span></span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">        <span class="comment">// Service resources must be initialized with the same loaders as the application</span></span><br><span class="line">        <span class="comment">// context.</span></span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        context.getResources().addLoaders(</span><br><span class="line">                app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        <span class="comment">//执行onCreate回调</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        <span class="comment">//保存运行中的Service</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">            <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Service</code>的创建和之前文章中所分析的<code>Activity</code>的创建流程基本一致，都是创建<code>Context</code>，通过<code>AppComponentFactory</code>反射实例化对象，然后加载资源，<code>attach</code>做绑定，最后执行<code>onCreate</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/AppComponentFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Service <span class="title">instantiateService</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className, @Nullable Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Service) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有特别在<code>AndroidManifest.xml</code>中设置<code>android:appComponentFactory</code>的话，默认的实现就是这样，通过传进来的<code>ClassLoader</code>和<code>className</code>反射实例化<code>Service</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Service.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定BaseContext</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mThread = thread;           <span class="comment">// <span class="doctag">NOTE:</span>  unused - remove?</span></span><br><span class="line">    mClassName = className;</span><br><span class="line">    <span class="comment">//保存ServiceRecord</span></span><br><span class="line">    mToken = token;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">    <span class="comment">//启动兼容性设置</span></span><br><span class="line">    mStartCompatibility = getApplicationInfo().targetSdkVersion</span><br><span class="line">            &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">    <span class="comment">//设置内容捕获功能</span></span><br><span class="line">    setContentCaptureOptions(application.getContentCaptureOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attach</code>方法也很简单，做了一些绑定<code>Context</code>等基本操作</p>
<p>最后调用<code>onCreate</code>方法，这个方法默认是个空实现，让继承<code>Service</code>的类去实现这个方法</p>
<h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p><code>Service</code>创建完成后就该启动它了，这里对应着<code>ActiveServices.realStartServiceLocked</code>方法中调用的<code>sendServiceArgsLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//如果待启动项列表中没有内容则直接返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ServiceStartArgs&gt; args = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历待启动项</span></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord.StartItem si = r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果在多个启动项中有假启动项，则跳过假启动项</span></span><br><span class="line">        <span class="comment">//但如果这个假启动项是唯一的启动项则不要跳过它，这是为了支持onStartCommand(null)的情况</span></span><br><span class="line">        <span class="keyword">if</span> (si.intent == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// If somehow we got a dummy null intent in the middle,</span></span><br><span class="line">            <span class="comment">// then skip it.  DO NOT skip a null intent when it is</span></span><br><span class="line">            <span class="comment">// the only one in the list -- this is to support the</span></span><br><span class="line">            <span class="comment">// onStartCommand(null) case.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">        r.deliveredStarts.add(si);</span><br><span class="line">        si.deliveryCount++;</span><br><span class="line">        <span class="comment">//处理Uri权限</span></span><br><span class="line">        <span class="keyword">if</span> (si.neededGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAm.mUgmInternal.grantUriPermissionUncheckedFromIntent(si.neededGrants,</span><br><span class="line">                    si.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//授权访问权限</span></span><br><span class="line">        mAm.grantImplicitAccess(r.userId, si.intent, si.callingId,</span><br><span class="line">                UserHandle.getAppId(r.appInfo.uid)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">        <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">            oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是以前台服务的方式启动的Service（startForegroundService），并且之前没有设置启动前台服务超时回调</span></span><br><span class="line">        <span class="keyword">if</span> (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">            <span class="comment">//如果当前服务还没成为前台服务，设置启动前台服务超时回调</span></span><br><span class="line">            <span class="comment">//在10s内需要调用Service.startForeground成为前台服务，否则停止服务</span></span><br><span class="line">            <span class="comment">//注：Android 11这个超时时间是10s，在后面的Android版本中这个时间有变化</span></span><br><span class="line">            <span class="keyword">if</span> (!r.isForeground) &#123;</span><br><span class="line">                scheduleServiceForegroundTransitionTimeoutLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.fgRequired = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加启动项</span></span><br><span class="line">        args.add(<span class="keyword">new</span> ServiceStartArgs(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建出一个支持Binder跨进程传输大量数据的列表来传输启动参数数据</span></span><br><span class="line">    ParceledListSlice&lt;ServiceStartArgs&gt; slice = <span class="keyword">new</span> ParceledListSlice&lt;&gt;(args);</span><br><span class="line">    slice.setInlineCountLimit(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//回到App进程，调度启动Service</span></span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中有几个比较重要的点需要注意：</p>
<ol>
<li><code>pendingStarts</code>中至少要有一个启动项才会执行<code>onStartCommand</code>，所以在前面的<code>ActiveServices.realStartServiceLocked</code>方法中才会有这样一段代码：如果<code>Service</code>已经启动，并且没有启动项，则构建一个假的启动参数供<code>onStartCommand</code>使用</li>
<li>如果在多个启动项中有假启动项，则跳过假启动项，但如果这个假启动项是唯一的启动项则不要跳过它，这是为了支持<code>onStartCommand</code>方法的第一个参数<code>Intent</code>未<code>null</code>的情况</li>
<li>如果服务是以前台服务的方式启动的（<code>startForegroundService</code>），如果当前服务还没成为前台服务，则需要设置一个启动前台服务的超时回调，如果在限制的时间范围内还没有成为前台服务（调用<code>Service.startForeground</code>方法），则会触发超时逻辑，停止服务，这个时间在<code>Android 11</code>上是10s，在后面的<code>Android</code>版本中有变化</li>
<li>最后将所有的启动项放到一个支持<code>Binder</code>跨进程传输大量数据的列表中，然后调用<code>App</code>进程中的<code>ActivityThread$ApplicationThread.scheduleServiceArgs</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, ParceledListSlice args)</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceStartArgs&gt; list = args.getList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ServiceStartArgs ssa = list.get(i);</span><br><span class="line">        ServiceArgsData s = <span class="keyword">new</span> ServiceArgsData();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.taskRemoved = ssa.taskRemoved;</span><br><span class="line">        s.startId = ssa.startId;</span><br><span class="line">        s.flags = ssa.flags;</span><br><span class="line">        s.args = ssa.args;</span><br><span class="line"></span><br><span class="line">        sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面一样，这里也是将启动<code>Service</code>的必要信息包装成一个个<code>ServiceStartArgs</code>对象后，通过<code>Handler</code>依次发送<code>Message</code>处理服务启动，这里最终调用的是<code>ActivityThread.handleServiceArgs</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Intent跨进程处理</span></span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                <span class="comment">//正常情况调用</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步会根据onStartCommand的返回值，调整Service死亡重建策略</span></span><br><span class="line">                <span class="comment">//同时会把之前的启动超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断<code>taskRemoved</code>标志，这个标志为<code>true</code>则代表用户之前从最近任务界面里划掉了这个任务栈或者在最近任务界面里点击了清理，此时会调用<code>Service.onTaskRemoved</code>方法（从最近任务界面关闭应用，进程不一定会被杀死，而且<code>Service</code>具有死亡重建机制），在正常情况下则是调用<code>Service.onStartCommand</code>处理服务启动</p>
<p>当任务执行完成后，会调用<code>AMS.serviceDoneExecuting</code>方法告知，在这个方法中会根据<code>onStartCommand</code>的返回值（或执行完<code>onTaskRemoved</code>被赋值为<code>START_TASK_REMOVED_COMPLETE</code>），调整<code>Service</code>的死亡重建策略，并且会把之前的启动超时定时器取消</p>
<p><code>onStartCommand</code>可以有以下几种返回值：</p>
<ul>
<li><code>START_STICKY_COMPATIBILITY</code>：<code>targetSdkVersion</code> &lt; 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，但<code>onStartCommand</code>方法不会被执行</li>
<li><code>START_STICKY</code>：<code>targetSdkVersion</code> &gt;= 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，但此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>null</code></li>
<li><code>START_NOT_STICKY</code>：<code>Service</code>被杀后不会被重建</li>
<li><code>START_REDELIVER_INTENT</code>：<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>Service</code>被杀死前最后一次调用<code>onStartCommand</code>方法时传递的<code>Intent</code></li>
</ul>
<p>在这里我们只摆出结论，暂时不分析原理，如果感兴趣的话我会在后面的文章中再去详细分析</p>
<h2 id="Context-bindService"><a href="#Context-bindService" class="headerlink" title="Context.bindService"></a>Context.bindService</h2><p>到这里，<code>Service</code>通过<code>startService</code>路径的启动流程我们就基本分析完了，接着我们看另一条路径，<code>bindService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="keyword">null</span>, mMainThread.getHandler(), <span class="keyword">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    <span class="comment">//获取LoadedApk$ServiceDispatcher$IServiceConnection</span></span><br><span class="line">    <span class="comment">//这个类是用来后续连接建立完成后发布连接，回调ServiceConnection各种方法的</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Handler and Executor both supplied"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保Intent有效</span></span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取ActivityRecord的远程Binder对象</span></span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="comment">//targetSdkVersion &lt; 14 (Android 4.0)的情况下，如果没有设置BIND_AUTO_CREATE</span></span><br><span class="line">        <span class="comment">//则该Service的优先级将会被视为等同于后台任务</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跨进程准备</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//跨进程使用AMS绑定Service</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就做了两件事：</p>
<ol>
<li>创建或获取<code>IServiceConnection</code>：这里实际获取到的是<code>LoadedApk</code>中的内部类<code>ServiceDispatcher</code>中的内部类<code>InnerConnection</code>，这个类主要是用来后面建立或断开连接后，回调<code>ServiceConnection</code>接口的各个方法的</li>
<li>跨进程调用<code>AMS.bindIsolatedService</code>方法绑定<code>Service</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindIsolatedService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String instanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验调用方包名</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that instanceName, which is caller provided, does not contain</span></span><br><span class="line">    <span class="comment">// unusual characters.</span></span><br><span class="line">    <span class="keyword">if</span> (instanceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instanceName.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = instanceName.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">                        || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'_'</span> || c == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal instanceName"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, instanceName, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅仅做了一些简单的校验，然后将绑定服务的任务转交给了<code>ActiveServices.bindServiceLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//获取调用方进程记录</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt; activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//token不为空表示是从Activity发起的，token实际为ActivityRecord的远程Binder对象</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取Activity与Service的连接记录</span></span><br><span class="line">        activity = mAm.mAtmInternal.getServiceConnectionsHolder(token);</span><br><span class="line">        <span class="comment">//ServiceConnectionsHolder为null说明调用方Activity不在栈中，直接异常返回</span></span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clientLabel = <span class="number">0</span>;</span><br><span class="line">    PendingIntent clientIntent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果调用方为系统级应用</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        <span class="comment">// Hacky kind of thing -- allow system stuff to tell us</span></span><br><span class="line">        <span class="comment">// what they are, so we can report this elsewhere for</span></span><br><span class="line">        <span class="comment">// others to know why certain services are running.</span></span><br><span class="line">        service.setDefusable(<span class="keyword">true</span>);</span><br><span class="line">        clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);</span><br><span class="line">        <span class="keyword">if</span> (clientIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (clientLabel != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// There are no useful extras in the intent, trash them.</span></span><br><span class="line">                <span class="comment">// System code calling with this stuff just needs to know</span></span><br><span class="line">                <span class="comment">// this will happen.</span></span><br><span class="line">                service = service.cloneFilter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像对待Activity一样对待该Service</span></span><br><span class="line">    <span class="comment">//需要校验调用方应用是否具有MANAGE_ACTIVITY_STACKS权限</span></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,</span><br><span class="line">                <span class="string">"BIND_TREAT_LIKE_ACTIVITY"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此标志仅用于系统调整IMEs（以及与顶层App密切合作的其他跨进程的用户可见组件）的调度策略，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_SCHEDULE_LIKE_TOP_APP) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Non-system caller (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") set BIND_SCHEDULE_LIKE_TOP_APP when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许绑定Service的应用程序管理白名单，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Non-system caller "</span> + caller + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许绑定到免安装应用提供的服务，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_INSTANT) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Non-system caller "</span> + caller + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") set BIND_ALLOW_INSTANT when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许Service后台启动Activity</span></span><br><span class="line">    <span class="comment">//需要校验调用方应用是否具有START_ACTIVITIES_FROM_BACKGROUND权限</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAm.enforceCallingPermission(</span><br><span class="line">                android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">"BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断调用方是否为前台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allowInstant = (flags &amp; Context.BIND_ALLOW_INSTANT) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找相应的Service</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>,</span><br><span class="line">                callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line">    <span class="keyword">boolean</span> permissionsReviewRequired = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line">    <span class="comment">// we schedule binding to the service but do not start its process, then</span></span><br><span class="line">    <span class="comment">// we launch a review activity to which is passed a callback to invoke</span></span><br><span class="line">    <span class="comment">// when done to start the bound service's process to completing the binding.</span></span><br><span class="line">    <span class="comment">//如果需要用户手动确认授权</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">            s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">        permissionsReviewRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a permission review UI only for binding from a foreground app</span></span><br><span class="line">        <span class="comment">//只有调用方进程在前台才可以显示授权弹窗</span></span><br><span class="line">        <span class="keyword">if</span> (!callerFg) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServiceRecord serviceRecord = s;</span><br><span class="line">        <span class="keyword">final</span> Intent serviceIntent = service;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户手动确认授权后执行的回调</span></span><br><span class="line">        RemoteCallback callback = <span class="keyword">new</span> RemoteCallback(</span><br><span class="line">                <span class="keyword">new</span> RemoteCallback.OnResultListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Bundle result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If there is still a pending record, then the service</span></span><br><span class="line">                        <span class="comment">// binding request is still valid, so hook them up. We</span></span><br><span class="line">                        <span class="comment">// proceed only if the caller cleared the review requirement</span></span><br><span class="line">                        <span class="comment">// otherwise we unbind because the user didn't approve.</span></span><br><span class="line">                        <span class="comment">//二次检查权限</span></span><br><span class="line">                        <span class="keyword">if</span> (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                .isPermissionsReviewRequired(</span><br><span class="line">                                        serviceRecord.packageName,</span><br><span class="line">                                        serviceRecord.userId)) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//拉起服务，如果服务未创建，则会创建服务并调用其onCreate方法</span></span><br><span class="line">                                <span class="comment">//如果服务已创建则什么都不会做</span></span><br><span class="line">                                bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                        serviceIntent.getFlags(),</span><br><span class="line">                                        callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                <span class="comment">/* ignore - local call */</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//无相应权限则解绑Service</span></span><br><span class="line">                            unbindServiceLocked(connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        Binder.restoreCallingIdentity(identity);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出授权弹窗</span></span><br><span class="line">        mAm.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mAm.mContext.startActivityAsUser(intent, <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> (unscheduleServiceRestartLocked(s, callerApp.info.uid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"BIND SERVICE WHILE RESTART PENDING: "</span></span><br><span class="line">                    + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//如果是第一次绑定的话，设置跟踪器</span></span><br><span class="line">            <span class="keyword">if</span> (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line">                <span class="comment">// This is the first binding, let the tracker know.</span></span><br><span class="line">                ServiceState stracker = s.getTracker();</span><br><span class="line">                <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stracker.setBound(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            s.lastActivity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定的服务代表受保护的系统组件，因此必须对其应用关联做限制</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Context.BIND_RESTRICT_ASSOCIATIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            mAm.requireAllowedAssociationsLocked(s.appInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立调用方与服务方之间的关联</span></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,</span><br><span class="line">                callerApp.getCurProcState(), s.appInfo.uid, s.appInfo.longVersionCode,</span><br><span class="line">                s.instanceName, s.processName);</span><br><span class="line">        <span class="comment">// Once the apps have become associated, if one of them is caller is ephemeral</span></span><br><span class="line">        <span class="comment">// the target app should now be able to see the calling app</span></span><br><span class="line">        mAm.grantImplicitAccess(callerApp.userId, service,</span><br><span class="line">                callerApp.uid, UserHandle.getAppId(s.appInfo.uid));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询App绑定信息</span></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="comment">//创建连接信息</span></span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line"></span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        <span class="comment">//添加连接</span></span><br><span class="line">        s.addConnection(binder, c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.addConnection(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        c.startAssociationIfNeeded();</span><br><span class="line">        <span class="comment">//表示此服务比发起绑定的应用重要性更高</span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.hasAboveClient = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//允许绑定Service的应用程序管理白名单</span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//允许Service后台启动Activity</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.setHasBindingWhitelistingBgActivityStarts(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新连接列表</span></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            mServiceConnections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定存在就会自动创建服务</span></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//拉起服务，如果服务未创建，则会创建服务并调用其onCreate方法</span></span><br><span class="line">            <span class="comment">//如果服务已创建则什么都不会做</span></span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否允许前台服务使用while-in-use权限</span></span><br><span class="line">        <span class="keyword">if</span> (!s.mAllowWhileInUsePermissionInFgs) &#123;</span><br><span class="line">            s.mAllowWhileInUsePermissionInFgs =</span><br><span class="line">                    shouldAllowWhileInUsePermissionInFgsLocked(callingPackage,</span><br><span class="line">                            Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">                            service, s, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新flag以及进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">                s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This could have made the service more important.</span></span><br><span class="line">            mAm.updateLruProcessLocked(s.app,</span><br><span class="line">                    (callerApp.hasActivitiesOrRecentTasks() &amp;&amp; s.app.hasClientActivities())</span><br><span class="line">                            || (callerApp.getCurProcState() &lt;= ActivityManager.PROCESS_STATE_TOP</span><br><span class="line">                                    &amp;&amp; (flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>),</span><br><span class="line">                    b.client);</span><br><span class="line">            mAm.updateOomAdjLocked(s.app, OomAdjuster.OOM_ADJ_REASON_BIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">            <span class="comment">// publish the connection.</span></span><br><span class="line">            <span class="comment">//如果服务之前就已经在运行，即Service.onBind方法已经被执行，返回的IBinder对象也已经被保存</span></span><br><span class="line">            <span class="comment">//调用LoadedApk$ServiceDispatcher$InnerConnection.connected方法</span></span><br><span class="line">            <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">            c.conn.connected(s.name, b.intent.binder, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">            <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">            <span class="comment">//如果服务是因这次绑定而创建的</span></span><br><span class="line">            <span class="comment">//请求执行Service.onBind方法，获取返回的IBinder对象</span></span><br><span class="line">            <span class="comment">//发布Service，回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maybeLogBindCrossProfileService(userId, callingPackage, callerApp.info.uid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">        <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值大于0则视为成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做的事就比较多了，我们挑重点来说：</p>
<ul>
<li><p>获取或创建各种连接记录（<code>ActivityServiceConnectionsHolder</code>、<code>AppBindRecord</code>、<code>ConnectionRecord</code>等）</p>
</li>
<li><p>校验各种<code>flags</code></p>
</li>
<li><p>查找相应的<code>Service</code></p>
</li>
<li><p>检查是否需要用户手动确认权限并弹出权限确认弹窗</p>
</li>
<li><p>向各个连接记录类中添加<code>ConnectionRecord</code>连接信息</p>
</li>
<li><p>如果<code>flags</code>设置了<code>BIND_AUTO_CREATE</code>便会调用<code>bringUpServiceLocked</code>方法尝试拉起服务，如果服务未创建，则会创建服务并调用其<code>onCreate</code>方法，如果服务已创建，则什么都不会做：这里和<code>startService</code>路径一样都调用到了<code>bringUpServiceLocked</code>方法，但最终调用的结果却不太一样，这是因为<code>startService</code>路径中，<code>ServiceRecord.startRequested</code>为<code>true</code>并且向<code>ServiceRecord.pendingStarts</code>中添加了启动项，而<code>bindService</code>路径不会向<code>ServiceRecord.pendingStarts</code>中添加启动项，并且由于<code>ServiceRecord.startRequested</code>为<code>false</code>，因此也不会去添加假的启动项，所以和<code>startService</code>不同，最终不会回调<code>Service.onStartCommand</code>方法</p>
</li>
<li><p>如果服务之前就已经在运行，则表示<code>Service.onBind</code>方法已经被执行，返回的<code>IBinder</code>对象也已经被保存，此时直接调用<code>LoadedApk$ServiceDispatcher$InnerConnection.connected</code>方法，在这个方法中会回调<code>ServiceConnection.onServiceConnected</code>方法</p>
</li>
<li><p>如果服务是因这次绑定而创建的，则调用<code>requestServiceBindingLocked</code>方法请求执行<code>Service.onBind</code>方法，获取返回的<code>IBinder</code>对象，然后发布<code>Service</code>，回调<code>ServiceConnection.onServiceConnected</code>方法</p>
</li>
<li><p>最后调用<code>ActiveServices$ServiceMap.ensureNotStartingBackgroundLocked</code>方法继续调度后台<code>Service</code>的启动</p>
</li>
</ul>
<p><code>bringUpServiceLocked</code>方法我们之前已经分析过了，我们接下来看服务创建后所要调用的<code>requestServiceBindingLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If service is not currently running, can't yet bind.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">            <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            <span class="comment">//设置进程状态</span></span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">//回到App进程，调度执行Service的bind操作</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.getReportedProcState());</span><br><span class="line">            <span class="comment">//请求绑定完成</span></span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">            i.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前一样，这里也是调用<code>App</code>进程中的<code>ActivityThread$ApplicationThread.scheduleBindService</code>方法进行绑定操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新进程信息</span></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将绑定<code>Service</code>的必要信息包装成<code>BindServiceData</code>对象后，通过<code>Handler</code>依次发送<code>Message</code>处理服务启动，这里最终调用的是<code>ActivityThread.handleBindService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">//正常情况下回调Service.onBind方法，获得控制Service的IBinder对象</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">//发布Service</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">                    <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                    <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面调用了<code>Service.onBind</code>方法，获得到了控制<code>Service</code>的<code>IBinder</code>对象，然后再调用<code>AMS.publishService</code>发布服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转交给ActiveServices处理</span></span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            <span class="comment">//获取Intent绑定记录</span></span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                <span class="comment">//保存控制Service的IBinder对象</span></span><br><span class="line">                b.binder = service;</span><br><span class="line">                <span class="comment">//请求绑定完成</span></span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//IBinder对象获取完成</span></span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//遍历所有与此服务绑定的客户端连接</span></span><br><span class="line">                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni = connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//调用LoadedApk$ServiceDispatcher$IServiceConnection.connected方法</span></span><br><span class="line">                        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">                        c.conn.connected(r.name, service, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">            <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先将通过<code>Service.onBind</code>获得到的控制<code>Service</code>的<code>IBinder</code>对象保存在<code>IntentBindRecord</code>中，这样之后再有其他<code>client</code>绑定服务，就只需要用它作为参数回调<code>ServiceConnection.onServiceConnected</code>方法就可以了</p>
<p>接下来遍历所有与此服务绑定的客户端连接，对符合条件的连接执行<code>LoadedApk$ServiceDispatcher$IServiceConnection.connected</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//mDispatcher是对ServiceDispatcher的弱引用</span></span><br><span class="line">    LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用ServiceDispatcher.connected方法</span></span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RunConnection里也是调用了doConnected方法</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="comment">//如果旧的连接信息中的IBinder对象和本次调用传入的IBinder对象是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            <span class="comment">//建立一个新的连接信息</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注册Binder死亡通知</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//保存本次连接信息</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                <span class="comment">//服务已死亡，移除连接信息</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除Binder死亡通知</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="comment">//回调ServiceConnection.onServiceDisconnected</span></span><br><span class="line">    <span class="comment">//通知client之前的连接已被断开</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Service死亡需要回调ServiceConnection.onBindingDied通知client服务死亡</span></span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new viable service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        <span class="comment">//告知client已建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        <span class="comment">//当Service.onBind方法返回null时，回调ServiceConnection.onNullBinding方法</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法里最终执行了<code>ServiceConnection.onServiceConnected</code>回调，通知客户端已与<code>Service</code>建立连接</p>
<p>至此，整个<code>bindService</code>的流程就结束了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Service</code>的整个启动流程到这里基本上都分析完了，至于<code>Service</code>的停止，重建等流程，我将会在后面的文章中再慢慢分析</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><a class="post-meta__tags" href="/tags/Service/">Service</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/09/14/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Service的停止与重建</span></a></div><div class="next-post pull-right"><a href="/2023/07/31/android/view/%E8%B0%88%E8%B0%88Android%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9C%86%E8%A7%92/"><span>谈谈Android如何实现不同大小的圆角</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>