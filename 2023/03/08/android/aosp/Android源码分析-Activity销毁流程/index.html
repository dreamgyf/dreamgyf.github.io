<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Activity销毁流程"><meta name="keywords" content="Android源码,ActivityThread,ActivityManagerService,ActivityTaskManagerService"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Activity销毁流程 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#触发销毁"><span class="toc-number">2.</span> <span class="toc-text">触发销毁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#handlePauseActivity"><span class="toc-number">3.</span> <span class="toc-text">handlePauseActivity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scheduleTransaction"><span class="toc-number">4.</span> <span class="toc-text">scheduleTransaction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#handleStopActivity"><span class="toc-number">5.</span> <span class="toc-text">handleStopActivity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#handleDestroyActivity"><span class="toc-number">6.</span> <span class="toc-text">handleDestroyActivity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tips"><span class="toc-number">7.</span> <span class="toc-text">Tips</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结尾"><span class="toc-number">8.</span> <span class="toc-text">结尾</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Activity销毁流程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityTaskManagerService/">ActivityTaskManagerService</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>我们在之前的几篇<code>Activity</code>启动流程分析中已经了解了<code>Activity</code>一半的生命周期，接下来这篇文章我们就来分析一下<code>Activity</code>销毁相关的生命周期</p>
<p>前几期文章回顾：</p>
<p><a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a></p>
<p><a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a></p>
<p><a href="https://juejin.cn/post/7195458962328649788" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a></p>
<h1 id="触发销毁"><a href="#触发销毁" class="headerlink" title="触发销毁"></a>触发销毁</h1><p>既然要分析<code>Activity</code>销毁流程，那我们就从最常见的入口<code>Activity.finish</code>入手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finish(DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的<code>finish</code>方法调用了另一个同名重载方法，接受一个int类型的参数表明是否需要在销毁<code>Activity</code>的同时销毁<code>Task</code>，该参数有以下三种：</p>
<ul>
<li><p><code>DONT_FINISH_TASK_WITH_ACTIVITY</code>：默认参数，表示在销毁<code>Activity</code>的时候不要销毁<code>Task</code></p>
</li>
<li><p><code>FINISH_TASK_WITH_ROOT_ACTIVITY</code>：当<code>Activity</code>为跟<code>Activity</code>的时候，销毁的同时销毁<code>Task</code>，同时这个任务也会从最近任务中移除</p>
</li>
<li><p><code>FINISH_TASK_WITH_ACTIVITY</code>：销毁<code>Activity</code>的时候同时销毁<code>Task</code>，但不会从最近任务中移除</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当finish后才可能会触发onActivityResult回调</span></span><br><span class="line">        <span class="comment">//这里准备将result返回给之前调用startActivityForResult的Activity</span></span><br><span class="line">        <span class="keyword">int</span> resultCode;</span><br><span class="line">        Intent resultData;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            resultCode = mResultCode;</span><br><span class="line">            resultData = mResultData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//两个Activity可能处于不同进程中，做进程间通信的准备</span></span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用ATMS销毁Activity</span></span><br><span class="line">            <span class="keyword">if</span> (ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParent.finishFromChild(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity was launched when user tapped a link in the Autofill Save UI - Save UI must</span></span><br><span class="line">    <span class="comment">// be restored now.</span></span><br><span class="line">    <span class="keyword">if</span> (mIntent != <span class="keyword">null</span> &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123;</span><br><span class="line">        restoreAutofillSaveUi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onActivityResult</code>回调是在对应<code>Activity</code> <code>resume</code>时才可能触发，具体过程后面会分析，将<code>ActivityRecord.Token</code>和<code>Result</code>作为参数调用<code>ATMS.finishActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">finishActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//回传的ResultIntent中不允许包含fd，防止泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (resultData != <span class="keyword">null</span> &amp;&amp; resultData.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//获取ActivityRecord并保证其在栈中</span></span><br><span class="line">        r = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="comment">//为null说明已被移出ActivityStack，视作已被finish</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carefully collect grants without holding lock</span></span><br><span class="line">    <span class="comment">//检查调用方（即待finish的Activity）是否能授予result所对应Activity package访问uri的权限</span></span><br><span class="line">    <span class="keyword">final</span> NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// Sanity check in case activity was removed before entering global lock.</span></span><br><span class="line">        <span class="keyword">if</span> (!r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of the root activity of the task before we finish it</span></span><br><span class="line">        <span class="keyword">final</span> Task tr = r.getTask();</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord rootR = tr.getRootActivity();</span><br><span class="line">        <span class="comment">// Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can</span></span><br><span class="line">        <span class="comment">// finish.</span></span><br><span class="line">        <span class="comment">//LockTask模式下，如果此为最后一个Task，则不允许被销毁</span></span><br><span class="line">        <span class="comment">//详见：https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode</span></span><br><span class="line">        <span class="keyword">if</span> (getLockTaskController().activityBlockedFromFinish(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> There is a dup. of this block of code in ActivityStack.navigateUpToLocked</span></span><br><span class="line">        <span class="comment">// We should consolidate.</span></span><br><span class="line">        <span class="comment">//IActivityController分发Activity状态变化</span></span><br><span class="line">        <span class="keyword">if</span> (mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">            <span class="comment">//寻找该Activity销毁后的下一个顶层Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord next =</span><br><span class="line">                    r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ask watcher if this is allowed</span></span><br><span class="line">                <span class="keyword">boolean</span> resumeOK = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resumeOK = mController.activityResuming(next.packageName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    mController = <span class="keyword">null</span>;</span><br><span class="line">                    Watchdog.getInstance().setActivityController(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!resumeOK) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note down that the process has finished an activity and is in background activity</span></span><br><span class="line">        <span class="comment">// starts grace period</span></span><br><span class="line">        <span class="comment">//设置Activity销毁的最新时间</span></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> res;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> finishWithRootActivity =</span><br><span class="line">                    finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;</span><br><span class="line">            <span class="keyword">if</span> (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY</span><br><span class="line">                    || (finishWithRootActivity &amp;&amp; r == rootR)) &#123; <span class="comment">//需要同时销毁Task</span></span><br><span class="line">                <span class="comment">// If requested, remove the task that is associated to this activity only if it</span></span><br><span class="line">                <span class="comment">// was the root activity in the task. The result code and data is ignored</span></span><br><span class="line">                <span class="comment">// because we don't support returning them across task boundaries. Also, to</span></span><br><span class="line">                <span class="comment">// keep backwards compatibility we remove the task from recents when finishing</span></span><br><span class="line">                <span class="comment">// task with root activity.</span></span><br><span class="line">                <span class="comment">//移除Task</span></span><br><span class="line">                mStackSupervisor.removeTask(tr, <span class="keyword">false</span> <span class="comment">/*killProcess*/</span>,</span><br><span class="line">                        finishWithRootActivity, <span class="string">"finish-activity"</span>);</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// Explicitly dismissing the activity so reset its relaunch flag.</span></span><br><span class="line">                r.mRelaunchReason = RELAUNCH_REASON_NONE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不需要同时销毁Task</span></span><br><span class="line">                r.finishIfPossible(resultCode, resultData, resultGrants,</span><br><span class="line">                        <span class="string">"app-request"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">                res = r.finishing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里分了两个case，当需要同时销毁<code>Task</code>的时候，直接调用<code>ActivityStackSupervisor.removeTask</code>，当不需要同时销毁<code>Task</code>的时候，调用<code>ActivityRecord.finishIfPossible</code></p>
<p>我们先看需要同时销毁<code>Task</code>的case</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTask</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task.mInRemoveTask) &#123;</span><br><span class="line">        <span class="comment">// Prevent recursion.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.mInRemoveTask = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行Task移除操作</span></span><br><span class="line">        task.performClearTask(reason);</span><br><span class="line">        <span class="comment">//对Task执行杀进程，从最近任务列表移除等操作</span></span><br><span class="line">        cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents);</span><br><span class="line">        <span class="comment">//关闭LockTask模式</span></span><br><span class="line">        mService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">        <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">        mService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        <span class="comment">//将最近任务持久化保存</span></span><br><span class="line">        <span class="keyword">if</span> (task.isPersistable) &#123;</span><br><span class="line">            mService.notifyTaskPersisterLocked(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task.mInRemoveTask = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇文章我们主要关注的是<code>Activity</code>销毁流程，至于进程的关闭，最近任务列表的更新我们在这里就不关心了，而这里<code>Activity</code>销毁的重点在于<code>Task.performClearTask</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Completely remove all activities associated with an existing task. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performClearTask</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken down into to cases to avoid object create due to capturing mStack.</span></span><br><span class="line">    <span class="keyword">if</span> (getStack() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// Task was restored from persistent storage.</span></span><br><span class="line">            r.takeFromHistory();</span><br><span class="line">            removeChild(r);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> figure-out how to avoid object creation due to capture of reason variable.</span></span><br><span class="line">            r.finishIfPossible(Activity.RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* resultData */</span>, <span class="keyword">null</span> <span class="comment">/* resultGrants */</span>, reason, <span class="keyword">false</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看后半部分代码可以发现，这个方法对<code>Task</code>中所有未销毁的<code>Activity</code>都执行了<code>ActivityRecord.finishIfPossible</code>方法，这样路径就和上面<code>ATMS.finishActivity</code>方法中第二个case统一了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish activity if possible. If activity was resumed - we must first pause it to make the</span></span><br><span class="line"><span class="comment"> * activity below resumed. Otherwise we will try to complete the request immediately by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #completeFinishing(String)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> One of &#123;<span class="doctag">@link</span> FinishRequest&#125; values:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REMOVED&#125; if this activity has been removed from the history list.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REQUESTED&#125; if removal process was started, but it is still in the list</span></span><br><span class="line"><span class="comment"> * and will be removed from history later.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_CANCELLED&#125; if activity is already finishing or in invalid state and the</span></span><br><span class="line"><span class="comment"> * request to finish it was not ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FinishRequest</span> <span class="function"><span class="keyword">int</span> <span class="title">finishIfPossible</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants, String reason, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止重复销毁</span></span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此Activity不在任务栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!isInStackLocked()) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="comment">//应该调整顶部Activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mayAdjustTop = (isState(RESUMED) || stack.mResumedActivity == <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; stack.isFocusedStackOnDisplay();</span><br><span class="line">    <span class="comment">//应该调整全局焦点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldAdjustGlobalFocus = mayAdjustTop</span><br><span class="line">            <span class="comment">// It must be checked before &#123;@link #makeFinishingLocked&#125; is called, because a stack</span></span><br><span class="line">            <span class="comment">// is not visible if it only contains finishing activities.</span></span><br><span class="line">            &amp;&amp; mRootWindowContainer.isTopDisplayFocusedStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停布局工作</span></span><br><span class="line">    mAtmService.deferWindowLayout();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置当前Activity状态为finishing</span></span><br><span class="line">        makeFinishingLocked();</span><br><span class="line">        <span class="comment">// Make a local reference to its task since this.task could be set to null once this</span></span><br><span class="line">        <span class="comment">// activity is destroyed and detached from task.</span></span><br><span class="line">        <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">        <span class="comment">//获取上一个ActivityRecord</span></span><br><span class="line">        ActivityRecord next = task.getActivityAbove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//传递FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET：重置该Task时清除此Activity</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If the caller asked that this activity (and all above it)</span></span><br><span class="line">                <span class="comment">// be cleared when the task is reset, don't lose that information,</span></span><br><span class="line">                <span class="comment">// but propagate it up to the next activity.</span></span><br><span class="line">                next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停输入事件分发</span></span><br><span class="line">        pauseKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are finishing the top focused activity and its task has nothing to be focused so</span></span><br><span class="line">        <span class="comment">// the next focusable task should be focused.</span></span><br><span class="line">        <span class="comment">//应该调整顶部Activity，但此Task没有Activity可以被运行在顶部，将焦点转移至下一个可聚焦的Task</span></span><br><span class="line">        <span class="keyword">if</span> (mayAdjustTop &amp;&amp; ((ActivityStack) task).topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>)</span><br><span class="line">                == <span class="keyword">null</span>) &#123;</span><br><span class="line">            task.adjustFocusToNextFocusableTask(<span class="string">"finish-top"</span>, <span class="keyword">false</span> <span class="comment">/* allowFocusSelf */</span>,</span><br><span class="line">                        shouldAdjustGlobalFocus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Result信息写入到对应ActivityRecord中，待后面resume的时候触发onActivityResult回调</span></span><br><span class="line">        finishActivityResults(resultCode, resultData, resultGrants);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止Task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> endTask = task.getActivityBelow(<span class="keyword">this</span>) == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !task.isClearingToReuseTask();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;</span><br><span class="line">        <span class="keyword">if</span> (isState(RESUMED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//通知Task移除已开始</span></span><br><span class="line">                mAtmService.getTaskChangeNotificationController().notifyTaskRemovalStarted(</span><br><span class="line">                        task.getTaskInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Prepare app close transition, but don't execute just yet. It is possible that</span></span><br><span class="line">            <span class="comment">// an activity that will be made resumed in place of this one will immediately</span></span><br><span class="line">            <span class="comment">// launch another new activity. In this case current closing transition will be</span></span><br><span class="line">            <span class="comment">// combined with open transition for the new activity.</span></span><br><span class="line">            <span class="comment">//准备Activity转场动画</span></span><br><span class="line">            mDisplayContent.prepareAppTransition(transit, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When finishing the activity preemptively take the snapshot before the app window</span></span><br><span class="line">            <span class="comment">// is marked as hidden and any configuration changes take place</span></span><br><span class="line">            <span class="comment">//更新Task快照</span></span><br><span class="line">            <span class="keyword">if</span> (mAtmService.mWindowManager.mTaskSnapshotController != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ArraySet&lt;Task&gt; tasks = Sets.newArraySet(task);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController.snapshotTasks(tasks);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController</span><br><span class="line">                        .addSkipClosingAppSnapshotTasks(tasks);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></span><br><span class="line">            <span class="comment">//设置可见性</span></span><br><span class="line">            setVisibility(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//开始暂停此Activity</span></span><br><span class="line">                stack.startPausingLocked(<span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* resuming */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//屏幕固定功能</span></span><br><span class="line">                mAtmService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">                <span class="comment">// This activity was in the top focused stack and this is the last activity in</span></span><br><span class="line">                <span class="comment">// that task, give this activity a higher layer so it can stay on top before the</span></span><br><span class="line">                <span class="comment">// closing task transition be executed.</span></span><br><span class="line">                <span class="comment">//更新窗口层级</span></span><br><span class="line">                <span class="keyword">if</span> (mayAdjustTop) &#123;</span><br><span class="line">                    mNeedsZBoost = <span class="keyword">true</span>;</span><br><span class="line">                    mDisplayContent.assignWindowLayers(<span class="keyword">false</span> <span class="comment">/* setLayoutNeeded */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isState(PAUSING)) &#123;</span><br><span class="line">            ... <span class="comment">//正常不会进入此case</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_REQUESTED;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mAtmService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，我们需要关注一下对于<code>Result</code>信息的处理，这里调用了<code>finishActivityResults</code>方法，将<code>Result</code>信息写入到对应<code>ActivityRecord</code>中，待后面<code>resume</code>的时候触发<code>onActivityResult</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the result for activity that started this one, clears the references to activities</span></span><br><span class="line"><span class="comment"> * started for result from this one, and clears new intents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishActivityResults</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Send the result if needed</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultTo.mUserId != mUserId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveUser(mUserId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (info.applicationInfo.uid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAtmService.mUgmInternal.grantUriPermissionUncheckedFromIntent(resultGrants,</span><br><span class="line">                    resultTo.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        resultTo.addResultLocked(<span class="keyword">this</span>, resultWho, requestCode, resultCode, resultData);</span><br><span class="line">        resultTo = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this HistoryRecord is not holding on to other resources,</span></span><br><span class="line">    <span class="comment">// because clients have remote IPC references to this object so we</span></span><br><span class="line">    <span class="comment">// can't assume that will go away and want to avoid circular IPC refs.</span></span><br><span class="line">    results = <span class="keyword">null</span>;</span><br><span class="line">    pendingResults = <span class="keyword">null</span>;</span><br><span class="line">    newIntents = <span class="keyword">null</span>;</span><br><span class="line">    setSavedState(<span class="keyword">null</span> <span class="comment">/* savedState */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Result结果添加到results列表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResultLocked</span><span class="params">(ActivityRecord from, String resultWho,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent resultData)</span> </span>&#123;</span><br><span class="line">    ActivityResult r = <span class="keyword">new</span> ActivityResult(from, resultWho,</span><br><span class="line">            requestCode, resultCode, resultData);</span><br><span class="line">    <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">        results = <span class="keyword">new</span> ArrayList&lt;ResultInfo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    results.add(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，就是将<code>Result</code>信息添加到<code>ActivityRecord.results</code>列表中</p>
<p>然后我们继续沿着<code>finish</code>主线链路走，后面有一个<code>isState</code>的判断，正常来说，<code>ActivityRecord</code>的<code>state</code>应该为<code>RESUMED</code>，具体为什么我们可以回顾一下之前分析的<code>Activity</code>启动流程，在<code>ActivityStackSupervisor.realStartActivityLocked</code>方法最后，会调用<code>ActivityStack.minimalResumeActivityLocked</code>，在这个方法中，会将<code>ActivityRecord</code>的<code>state</code>设置为<code>RESUMED</code>，由于<code>ClientTransaction</code>的执行是通过<code>Handler.sendMessage</code>进行的，所以早在<code>Activity</code> <code>onCreate</code>之前，<code>ActivityRecord</code>的状态就已经被设为了<code>RESUMED</code></p>
<p>根据以上分析，我们会走进<code>isState(RESUMED)</code>这个case中，接着调用<code>ActivityStack.startPausingLocked</code>方法暂停<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start pausing the currently resumed activity.  It is an error to call this if there</span></span><br><span class="line"><span class="comment"> * is already an activity being paused or there is no resumed activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userLeaving True if this should result in an onUserLeaving to the current activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uiSleeping True if this is happening with the user interface going to sleep (the</span></span><br><span class="line"><span class="comment"> * screen turning off).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resuming The activity we are currently trying to resume or null if this is not being</span></span><br><span class="line"><span class="comment"> *                 called as part of resuming the top activity, so we shouldn't try to instigate</span></span><br><span class="line"><span class="comment"> *                 a resume here if not null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if an activity now is in the PAUSING state, and we are waiting for</span></span><br><span class="line"><span class="comment"> * it to tell us when it is done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已有Activity正在暂停中</span></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">            <span class="comment">// Avoid recursion among check for sleep and complete pause during sleeping.</span></span><br><span class="line">            <span class="comment">// Because activity will be paused immediately after resume, just let pause</span></span><br><span class="line">            <span class="comment">// be completed by the order of activity paused from clients.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上一个已resume的Activity</span></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既没有已resume的Activity，也没有正在resume的Activity</span></span><br><span class="line">    <span class="comment">//从栈顶找一个Activity恢复</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能暂停一个正在resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (prev == resuming) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置各种状态</span></span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = prev.isNoHistory() ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">"startPausingLocked"</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新统计信息</span></span><br><span class="line">    mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pauseImmediately = <span class="keyword">false</span>;</span><br><span class="line">    ... <span class="comment">//当前流程下pauseImmediately始终为false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev.attachedToProcess()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度Pause生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),</span><br><span class="line">                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are not going to sleep, we want to ensure the device is</span></span><br><span class="line">    <span class="comment">// awake until the next activity is started.</span></span><br><span class="line">    <span class="comment">//获取Wakelock，确保设备awake状态直到下一个Activity启动</span></span><br><span class="line">    <span class="keyword">if</span> (!uiSleeping &amp;&amp; !mAtmService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">        mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Have the window manager pause its key dispatching until the new</span></span><br><span class="line">        <span class="comment">// activity has started.  If we're pausing the activity just because</span></span><br><span class="line">        <span class="comment">// the screen is being turned off and the UI is sleeping, don't interrupt</span></span><br><span class="line">        <span class="comment">// key dispatch; the same activity will pick it up again on wakeup.</span></span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            <span class="comment">//暂停输入事件分发</span></span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123; <span class="comment">//不会进入此case</span></span><br><span class="line">            <span class="comment">// If the caller said they don't want to wait for the pause, then complete</span></span><br><span class="line">            <span class="comment">// the pause now.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置超时监听（500ms内没有完成便视为超时）</span></span><br><span class="line">            prev.schedulePauseTimeout();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity failed to schedule the</span></span><br><span class="line">        <span class="comment">// pause, so just treat it as being paused now.</span></span><br><span class="line">        <span class="comment">//未能成功暂停此Activity，从栈顶找一个Activity恢复</span></span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和<code>Activity</code>启动流程类似，该方法里面调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法来调度<code>Activity</code>暂停的生命周期，具体是怎样调度的可以看我之前的文章 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a>，里面分析了<code>ClientTransaction</code>事务是怎么被调度执行的</p>
<p>了解完后我们就可以知道，生命周期事务的执行也就相当于分别调用<code>ActivityLifecycleItem</code>的<code>preExecute</code>、<code>execute</code>、<code>postExecute</code>方法，而<code>PauseActivityItem</code>没有重写<code>preExecute</code>方法，所以我们就依次分析其<code>execute</code>、<code>postExecute</code>方法就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClientTransactionHandler</code>这个我们之前说过，这是一个抽象类，被<code>ActivityThread</code>继承实现，所以这里实际上就是调用<code>ActivityThread.handlePauseActivity</code>方法</p>
<h1 id="handlePauseActivity"><a href="#handlePauseActivity" class="headerlink" title="handlePauseActivity"></a>handlePauseActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新标记</span></span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pause the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Saved instance state for pre-Honeycomb apps if it was saved, &#123;<span class="doctag">@code</span> null&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//异常状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-Honeycomb apps always save their state before pausing</span></span><br><span class="line">    <span class="comment">//是否需要保存状态信息（Android 3.0前无论是否finish都会触发保存）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState) &#123;</span><br><span class="line">        <span class="comment">//回调Activity的onSaveInstanceState方法</span></span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//回调OnActivityPausedListener，目前看来只有NFC部分有注册这个回调</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Android 3.0之前的特殊处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回保存状态的Bundle</span></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已暂停，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reporting top resumed position loss when pausing an activity. If necessary, it</span></span><br><span class="line">    <span class="comment">// will be restored in performResumeActivity().</span></span><br><span class="line">    <span class="comment">//报告resume状态变更</span></span><br><span class="line">    reportTopResumedActivityChanged(r, <span class="keyword">false</span> <span class="comment">/* onTop */</span>, <span class="string">"pausing"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//回调Activity的onPause方法</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onPause方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ...</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一条调用链路看下来还是很简单的，和之前我们分析过的其他生命周期调用是一个套路，这里显示调用了<code>callActivityOnSaveInstanceState</code>方法保存状态信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    r.state = <span class="keyword">new</span> Bundle();</span><br><span class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPreSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//回调onSaveInstanceState</span></span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//保存受管理的Dialog的状态</span></span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    <span class="comment">//保存权限请求状态</span></span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    <span class="comment">//分发PostSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPostSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终回调<code>Activity.onSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存窗口信息</span></span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    <span class="comment">//保存Fragment状态</span></span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发SaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivitySaveInstanceState回调</span></span><br><span class="line">    dispatchActivitySaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存状态的流程就基本完成了，我们再回过头来看<code>onPause</code>的触发</p>
<p>在上面<code>performPauseActivityIfNeeded</code>方法中有一行代码调用了<code>Instrumentation.callActivityOnPause</code>方法，<br>通过<code>Instrumentation</code>调用了<code>Activity.performPause</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PrePaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPrePaused回调</span></span><br><span class="line">    dispatchActivityPrePaused();</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//FragmentManager分发pause状态</span></span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//回调onPause</span></span><br><span class="line">    onPause();</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Target Sdk 9以上（Android 2.3）需要保证在onPause中调用super.onPause方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostPaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostPaused回调</span></span><br><span class="line">    dispatchActivityPostPaused();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>onPause</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发Paused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPaused回调</span></span><br><span class="line">    dispatchActivityPaused();</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAutoFillIgnoreFirstResumePause) &#123;</span><br><span class="line">            View focus = getCurrentFocus();</span><br><span class="line">            <span class="keyword">if</span> (focus != <span class="keyword">null</span> &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;</span><br><span class="line">                getAutofillManager().notifyViewExited(focus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// reset after first pause()</span></span><br><span class="line">            mAutoFillIgnoreFirstResumePause = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE);</span><br><span class="line">    <span class="comment">//super.onPause标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，<code>Activity</code>的<code>onPause</code>生命周期已经基本走完了，此时我们再回到<code>PauseActivityItem.postExecute</code>方法中做一些善后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mDontReport为我们之前obtain方法中传入的pauseImmediately参数，始终为false</span></span><br><span class="line">    <span class="keyword">if</span> (mDontReport) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        <span class="comment">//调用ATMS.activityPaused方法</span></span><br><span class="line">        ActivityTaskManager.getService().activityPaused(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>ATMS.activityPaused</code>方法回到<code>system_server</code>进程处理<code>Activity</code>暂停后的事项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//通过ActivityRecord.Token获取ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.activityPaused(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>ActivityRecord.activityPaused</code>方法继续处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(<span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//移除超时监听</span></span><br><span class="line">        removePauseTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//暂停布局工作</span></span><br><span class="line">            mAtmService.deferWindowLayout();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stack.completePauseLocked(<span class="keyword">true</span> <span class="comment">/* resumeNext */</span>, <span class="keyword">null</span> <span class="comment">/* resumingActivity */</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//恢复布局工作</span></span><br><span class="line">                mAtmService.continueWindowLayout();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//暂停Activity失败</span></span><br><span class="line">            <span class="keyword">if</span> (isState(PAUSING)) &#123;</span><br><span class="line">                setState(PAUSED, <span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    completeFinishing(<span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下会进入到<code>ActivityStack.completePauseLocked</code>方法中，但在暂停<code>Activity</code>失败的情况下，如果当前状态为<code>PAUSING</code>，则直接将其状态置为<code>PAUSED</code>已暂停，如果被标记为<code>finishing</code>，则会调用<code>ActivityRecord.completeFinishing</code>继续<code>finish</code>流程，这其实和正常情况下的调用链路差不多，具体我们往下就能看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completePauseLocked</span><span class="params">(<span class="keyword">boolean</span> resumeNext, ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.setWillCloseOrEnterPip(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//之前的状态是否为正在停止</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasStopping = prev.isState(STOPPING);</span><br><span class="line">        <span class="comment">//设置状态为已暂停</span></span><br><span class="line">        prev.setState(PAUSED, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            <span class="comment">//继续finish流程</span></span><br><span class="line">            prev = prev.completeFinishing(<span class="string">"completePausedLocked"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev.hasProcess()) &#123;</span><br><span class="line">            <span class="comment">//Configuration发生变化时可能会设置这个flag</span></span><br><span class="line">            <span class="keyword">if</span> (prev.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                <span class="comment">// Complete the deferred relaunch that was waiting for pause to complete.</span></span><br><span class="line">                <span class="comment">//等待暂停完成后relaunch Activity</span></span><br><span class="line">                prev.relaunchActivityLocked(prev.preserveWindowOnDeferredRelaunch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wasStopping) &#123;</span><br><span class="line">                <span class="comment">// We are also stopping, the stop request must have gone soon after the pause.</span></span><br><span class="line">                <span class="comment">// We can't clobber it, because the stop confirmation will not be handled.</span></span><br><span class="line">                <span class="comment">// We don't need to schedule another stop, we only need to let it happen.</span></span><br><span class="line">                <span class="comment">//之前的状态为正在停止，将状态置回即可</span></span><br><span class="line">                prev.setState(STOPPING, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev.mVisibleRequested || shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                <span class="comment">// Clear out any deferred client hide we might currently have.</span></span><br><span class="line">                prev.setDeferHidingClient(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// If we were visible then resumeTopActivities will release resources before</span></span><br><span class="line">                <span class="comment">// stopping.</span></span><br><span class="line">                <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">                prev.addToStopping(<span class="keyword">true</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                        <span class="string">"completePauseLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//App在pause过程中死亡</span></span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It is possible the activity was freezing the screen before it was paused.</span></span><br><span class="line">        <span class="comment">// In that case go ahead and remove the freeze this activity has on the screen</span></span><br><span class="line">        <span class="comment">// since it is no longer visible.</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//停止屏幕冻结</span></span><br><span class="line">            prev.stopFreezingScreenLocked(<span class="keyword">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Activity暂停完毕</span></span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复前一个顶层Activity</span></span><br><span class="line">    <span class="keyword">if</span> (resumeNext) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (topStack != <span class="keyword">null</span> &amp;&amp; !topStack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(topStack, prev, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = topStack != <span class="keyword">null</span> ? topStack.topRunningActivity() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="keyword">null</span> || (prev != <span class="keyword">null</span> &amp;&amp; top != prev)) &#123;</span><br><span class="line">                <span class="comment">// If there are no more activities available to run, do resume anyway to start</span></span><br><span class="line">                <span class="comment">// something. Also if the top activity on the stack is not the just paused</span></span><br><span class="line">                <span class="comment">// activity, we need to go ahead and resume it to ensure we complete an</span></span><br><span class="line">                <span class="comment">// in-flight app switch.</span></span><br><span class="line">                mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//恢复按键分发</span></span><br><span class="line">        prev.resumeKeyDispatchingLocked();</span><br><span class="line">        ... <span class="comment">//更新统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(resuming, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify when the task stack has changed, but only if visibilities changed (not just</span></span><br><span class="line">    <span class="comment">// focus). Also if there is an active pinned stack - we always want to notify it about</span></span><br><span class="line">    <span class="comment">// task stack changes, because its positioning may depend on it.</span></span><br><span class="line">    <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause</span><br><span class="line">            || (getDisplayArea() != <span class="keyword">null</span> &amp;&amp; getDisplayArea().hasPinnedTask())) &#123;</span><br><span class="line">        mAtmService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论暂停成功与否，最后都会走到<code>ActivityRecord.completeFinishing</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete activity finish request that was initiated earlier. If the activity is still</span></span><br><span class="line"><span class="comment"> * pausing we will wait for it to complete its transition. If the activity that should appear in</span></span><br><span class="line"><span class="comment"> * place of this one is not visible yet - we'll wait for it first. Otherwise - activity can be</span></span><br><span class="line"><span class="comment"> * destroyed right away.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for finishing the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Flag indicating whether the activity was removed from history.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ActivityRecord <span class="title">completeFinishing</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//状态检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCurrentVisible = mVisibleRequested || isState(PAUSED);</span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible) &#123;</span><br><span class="line">        ... <span class="comment">//更新Activity可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this activity is currently visible, and the resumed activity is not yet visible, then</span></span><br><span class="line">    <span class="comment">// hold off on finishing until the resumed one becomes visible.</span></span><br><span class="line">    <span class="comment">// The activity that we are finishing may be over the lock screen. In this case, we do not</span></span><br><span class="line">    <span class="comment">// want to consider activities that cannot be shown on the lock screen as running and should</span></span><br><span class="line">    <span class="comment">// proceed with finishing the activity if there is no valid next top running activity.</span></span><br><span class="line">    <span class="comment">// Note that if this finishing activity is floating task, we don't need to wait the</span></span><br><span class="line">    <span class="comment">// next activity resume and can destroy it directly.</span></span><br><span class="line">    <span class="comment">// TODO(b/137329632): find the next activity directly underneath this one, not just anywhere</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = getDisplayArea().topRunningActivity(</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* considerKeyguardState */</span>);</span><br><span class="line">    <span class="comment">// isNextNotYetVisible is to check if the next activity is invisible, or it has been</span></span><br><span class="line">    <span class="comment">// requested to be invisible but its windows haven't reported as invisible.  If so, it</span></span><br><span class="line">    <span class="comment">// implied that the current finishing activity should be added into stopping list rather</span></span><br><span class="line">    <span class="comment">// than destroy immediately.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isNextNotYetVisible = next != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (!next.nowVisible || !next.mVisibleRequested);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此Activity当前可见，而要恢复的Activity还不可见，则推迟finish，直到要恢复的Activity可见为止</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible &amp;&amp; isNextNotYetVisible) &#123;</span><br><span class="line">        <span class="comment">// Add this activity to the list of stopping activities. It will be processed and</span></span><br><span class="line">        <span class="comment">// destroyed when the next activity reports idle.</span></span><br><span class="line">        <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">        addToStopping(<span class="keyword">false</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                <span class="string">"completeFinishing"</span>);</span><br><span class="line">        <span class="comment">//设置状态为stop中</span></span><br><span class="line">        setState(STOPPING, <span class="string">"completeFinishing"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addToFinishingAndWaitForIdle()) &#123;</span><br><span class="line">        <span class="comment">// We added this activity to the finishing list and something else is becoming resumed.</span></span><br><span class="line">        <span class="comment">// The activity will complete finishing when the next activity reports idle. No need to</span></span><br><span class="line">        <span class="comment">// do anything else here.</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not waiting for the next one to become visible, and nothing else will be resumed in</span></span><br><span class="line">        <span class="comment">// place of this activity - requesting destruction right away.</span></span><br><span class="line">        <span class="comment">//立刻销毁此Activity</span></span><br><span class="line">        activityRemoved = destroyIfPossible(reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved ? <span class="keyword">null</span> : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非锁屏状态且当前要销毁的<code>Activity</code>在前台的情况下，该<code>Activity</code>可见而待恢复的<code>Activity</code>尚不可见，此时优先完成待恢复<code>Activity</code>的<code>resume</code>生命周期，等到之后空闲再去处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>所以在面试中常问的<code>Activity</code>从<code>B</code>返回到<code>A</code>的生命周期顺序我们从这里就可以看出来，理解后我们就不用去死记硬背了：</p>
<p><code>B.onPause</code> -&gt; <code>A.onRestart</code> -&gt; <code>A.onResume</code> -&gt; <code>B.onStop</code> -&gt; <code>B.onDestory</code></p>
<p>对于锁屏状态或者要销毁的<code>Activity</code>不在前台的情况下，由于不需要立刻恢复<code>Activity</code>，所以可能会直接处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>我们以第一种当前要销毁的<code>Activity</code>在前台的情况分析，此时会将这个<code>Activity</code>添加到<code>stop</code>列表中，并将状态设置为<code>STOPPING</code>，之后返回到<code>ActivityStack.completePauseLocked</code>方法中，继续执行<code>resumeNext</code>工作</p>
<p>在<code>resumeNext</code>中会调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复栈顶<code>Activity</code>，由于这个方法之前已经在<br><a href="https://juejin.cn/post/7130182223231188999#heading-6" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中分析过了，这里就不再赘述了，我们还是将目光放在销毁流程上</p>
<p>通过之前的文章，我们知道恢复<code>Activity</code>会调用到<code>ActivityThread.handleResumeActivity</code>方法，而当<code>Activity</code>恢复完毕后，此方法最后一行会向<code>MessageQueue</code>添加一个<code>IdleHandler</code>，关于<code>IdleHandler</code>这里就不再介绍了，这是每位<code>Android</code>开发都应该了解的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Idler</code>是<code>ActivityThread</code>的一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="comment">//遍历整条ActivityClientRecord.nextIdle链，依次调用ATMS.activityIdle</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历整个进程内所有的<code>ActivityClientRecord</code>，并依次调用<code>ATMS.activityIdle</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStackSupervisor.activityIdleInternal(r, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>ActivityRecord.Token</code>获取到<code>ActivityRecord</code>，接着调用<code>ActivityStackSupervisor.activityIdleInternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityIdleInternal</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    processStoppingAndFinishingActivities(r, processPausingActivities, <span class="string">"idle"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需要重点关注<code>processStoppingAndFinishingActivities</code>这一个方法，从方法名我们也能看出来，它是用来处理<code>Activity</code> <code>stop</code>或<code>destroy</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processes the activities to be stopped or destroyed. This should be called when the resumed</span></span><br><span class="line"><span class="comment"> * activities are idle or drawn.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStoppingAndFinishingActivities</span><span class="params">(ActivityRecord launchedActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been waiting for the transition</span></span><br><span class="line">    <span class="comment">// animation to finish.</span></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; readyToStopActivities = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mStoppingActivities.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord s = mStoppingActivities.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> animating = s.isAnimating(TRANSITION | PARENTS,</span><br><span class="line">                ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS);</span><br><span class="line">        <span class="comment">//不在动画中或者ATMS服务正在关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!animating || mService.mShuttingDown) &#123;</span><br><span class="line">            <span class="comment">//跳过正在pause的Activitiy</span></span><br><span class="line">            <span class="keyword">if</span> (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123;</span><br><span class="line">                <span class="comment">// Defer processing pausing activities in this iteration and reschedule</span></span><br><span class="line">                <span class="comment">// a delayed idle to reprocess it again</span></span><br><span class="line">                removeIdleTimeoutForActivity(launchedActivity);</span><br><span class="line">                scheduleIdleTimeout(launchedActivity);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readyToStopActivities == <span class="keyword">null</span>) &#123;</span><br><span class="line">                readyToStopActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将准备好stop的Activitiy加入列表中</span></span><br><span class="line">            readyToStopActivities.add(s);</span><br><span class="line"></span><br><span class="line">            mStoppingActivities.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numReadyStops = readyToStopActivities == <span class="keyword">null</span> ? <span class="number">0</span> : readyToStopActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        <span class="comment">//Activity是否在任务栈中</span></span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                <span class="comment">// TODO(b/137329632): Wait for idle of the right activity, not just any.</span></span><br><span class="line">                <span class="comment">//被标记为finishing，尝试销毁Activity</span></span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则仅仅只是stop Activity</span></span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numFinishingActivities = mFinishingActivities.size();</span><br><span class="line">    <span class="keyword">if</span> (numFinishingActivities == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish any activities that are scheduled to do so but have been waiting for the next one</span></span><br><span class="line">    <span class="comment">// to start.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; finishingActivities = <span class="keyword">new</span> ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">    mFinishingActivities.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFinishingActivities; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = finishingActivities.get(i);</span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">            r.destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>, <span class="string">"finish-"</span> + reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于被标记为<code>finishing</code>的<code>Activity</code>，调用<code>destroyIfPossible</code>方法销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy and cleanup the activity both on client and server if possible. If activity is the</span></span><br><span class="line"><span class="comment"> * last one left on display with home stack and there is no other running activity - delay</span></span><br><span class="line"><span class="comment"> * destroying it until the next one starts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyIfPossible</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    setState(FINISHING, <span class="string">"destroyIfPossible"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the record is cleaned out of other places.</span></span><br><span class="line">    <span class="comment">//确保此Activity已从待stop列表中移除</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = taskDisplayArea.topRunningActivity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLastStackOverEmptyHome =</span><br><span class="line">            next == <span class="keyword">null</span> &amp;&amp; stack.isFocusedStackOnDisplay()</span><br><span class="line">                    &amp;&amp; taskDisplayArea.getOrCreateRootHomeTask() != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLastStackOverEmptyHome) &#123;</span><br><span class="line">        <span class="comment">// Don't destroy activity immediately if this is the last activity on the display and</span></span><br><span class="line">        <span class="comment">// the display contains home stack. Although there is no next activity at the moment,</span></span><br><span class="line">        <span class="comment">// another home activity should be started later. Keep this activity alive until next</span></span><br><span class="line">        <span class="comment">// home activity is resumed. This way the user won't see a temporary black screen.</span></span><br><span class="line">        <span class="comment">//如果Home栈存在且这是当前焦点栈中最后一个Activity，则不要立即销毁它</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">        addToFinishingAndWaitForIdle();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置finishing标记（之前设过了，这里是重复设置）</span></span><br><span class="line">    makeFinishingLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> activityRemoved = destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>,</span><br><span class="line">            <span class="string">"finish-imm:"</span> + reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the display does not have running activity, the configuration may need to be</span></span><br><span class="line">    <span class="comment">// updated for restoring original orientation of the display.</span></span><br><span class="line">    <span class="comment">//更新可见性和屏幕显示方向</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(),</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新恢复栈顶Activity</span></span><br><span class="line">    <span class="keyword">if</span> (activityRemoved) &#123;</span><br><span class="line">        mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了最后的一些判断，然后调用<code>destroyImmediately</code>方法，立刻执行Activity的销毁流程（这里和上一个方法<code>processStoppingAndFinishingActivities</code>中，待<code>finish</code>列表的处理是一样的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy the current CLIENT SIDE instance of an activity. This may be called both when</span></span><br><span class="line"><span class="comment"> * actually finishing an activity, or when performing a configuration switch where we destroy</span></span><br><span class="line"><span class="comment"> * the current client-side object but then create a new client-side object for this same</span></span><br><span class="line"><span class="comment"> * HistoryRecord.</span></span><br><span class="line"><span class="comment"> * Normally the server-side record will be removed when the client reports back after</span></span><br><span class="line"><span class="comment"> * destruction. If, however, at this point there is no client process attached, the record will</span></span><br><span class="line"><span class="comment"> * be removed immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if activity was immediately removed from history, &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyImmediately</span><span class="params">(<span class="keyword">boolean</span> removeFromApp, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经被销毁或正在被销毁，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isState(DESTROYING, DESTROYED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> removedFromHistory = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理工作</span></span><br><span class="line">    cleanUp(<span class="keyword">false</span> <span class="comment">/* cleanServices */</span>, <span class="keyword">false</span> <span class="comment">/* setState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasProcess()) &#123;</span><br><span class="line">        <span class="comment">//清理更新工作</span></span><br><span class="line">        <span class="keyword">if</span> (removeFromApp) &#123;</span><br><span class="line">            app.removeActivity(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!app.hasActivities()) &#123;</span><br><span class="line">                mAtmService.clearHeavyWeightProcessIfEquals(app);</span><br><span class="line">                <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">                <span class="comment">// their client may have activities.</span></span><br><span class="line">                <span class="comment">// No longer have activities, so update LRU list and oom adj.</span></span><br><span class="line">                <span class="comment">//更新进程信息</span></span><br><span class="line">                app.updateProcessInfo(<span class="keyword">true</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> skipDestroy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度销毁生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken,</span><br><span class="line">                    DestroyActivityItem.obtain(finishing, configChangeFlags));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// We can just ignore exceptions here...  if the process has crashed, our death</span></span><br><span class="line">            <span class="comment">// notification will clean things up.</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//从历史任务中移除</span></span><br><span class="line">                removeFromHistory(reason + <span class="string">" exceptionInScheduleDestroy"</span>);</span><br><span class="line">                removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">                skipDestroy = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nowVisible = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the activity is finishing, we need to wait on removing it from the list to give it</span></span><br><span class="line">        <span class="comment">// a chance to do its cleanup.  During that time it may make calls back with its token</span></span><br><span class="line">        <span class="comment">// so we need to be able to find it on the list and so we don't want to remove it from</span></span><br><span class="line">        <span class="comment">// the list yet.  Otherwise, we can just immediately put it in the destroyed state since</span></span><br><span class="line">        <span class="comment">// we are not removing it from the list.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing &amp;&amp; !skipDestroy) &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYING,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. finishing and not skipping destroy"</span>);</span><br><span class="line">            <span class="comment">//设置销毁超时回调</span></span><br><span class="line">            mAtmService.mH.postDelayed(mDestroyTimeoutRunnable, DESTROY_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYED,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. not finishing or skipping destroy"</span>);</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove this record from the history.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程，从历史任务中移除</span></span><br><span class="line">            removeFromHistory(reason + <span class="string">" hadNoApp"</span>);</span><br><span class="line">            removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程且不在finishing中，直接设置状态为已被销毁</span></span><br><span class="line">            setState(DESTROYED, <span class="string">"destroyActivityLocked. not finishing and had no app"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configChangeFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removedFromHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h1><p>这个方法做了一些清理工作，重头戏在于调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法调度销毁生命周期事务，接下来我们就重点分析这个事务的执行路径</p>
<p><code>scheduleTransaction</code>的调用链路我们在 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a> 中已经分析过了，这里我就简单的标注一下流程：</p>
<p><code>ClientLifecycleManager.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.schedule</code> -&gt;<br><code>ActivityThread.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.preExecute</code> -&gt;<br><code>ActivityLifecycleItem.preExecute</code>-&gt;<br><code>ActivityThread.sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction)</code> -&gt;<br><code>TransactionExecutor.execute</code> -&gt;<br><code>TransactionExecutor.executeCallbacks</code> -&gt;<br><code>TransactionExecutor.executeLifecycleState</code> -&gt;<br><code>TransactionExecutor.cycleToPath</code> -&gt;<br><code>ActivityLifecycleItem.execute</code> -&gt;<br><code>ActivityLifecycleItem.postExecute</code></p>
<p>这里的链路基本上和<code>Activity</code>启动事务链路相差无几，甚至更短了（<code>Activity</code>销毁事务没有添加<code>callback</code>），所以没看过我上篇文章的强烈推荐去看一下，这里我就不再做分析了</p>
<p>我们从<code>TransactionExecutor.cycleToPath</code>开始，之前我们分析过，我们在事务中设置的<code>ActivityLifecycleItem</code>代表了<code>Activity</code>最终需要到达执行的生命周期，而中间的那些过渡生命周期就由<code>cycleToPath</code>方法推进执行，我们目前的生命周期状态为<code>ON_PAUSE</code>，而我们的目标生命周期为<code>ON_DESTROY</code>，中间还夹着一个<code>ON_STOP</code>，所以这个方法会帮我们执行<code>ClientTransactionHandler.handleStopActivity</code>方法，也就是<code>ActivityThread.handleStopActivity</code>方法</p>
<h1 id="handleStopActivity"><a href="#handleStopActivity" class="headerlink" title="handleStopActivity"></a>handleStopActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">    <span class="comment">//执行onStop生命周期</span></span><br><span class="line">    performStopActivityInner(r, stopInfo, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">            reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新可见性</span></span><br><span class="line">    updateVisibility(r, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录Stop信息（不过在后续销毁链路中似乎并没有被用到）</span></span><br><span class="line">    stopInfo.setActivity(r);</span><br><span class="line">    stopInfo.setState(r.state);</span><br><span class="line">    stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">    pendingActions.setStopInfo(stopInfo);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的路径就和其他生命周期差不多了，大部分内容我都用注释标注了，大家顺着往下看就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Core implementation of stopping an activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r Target activity client record.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info Action that will report activity stop to server.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> saveState Flag indicating whether the activity state should be saved.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalStateRequest Flag indicating if this call is handling final lifecycle state</span></span><br><span class="line"><span class="comment"> *                          request for a transaction.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for performing this operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r, StopInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> saveState, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//异常状态处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//设置描述（Activity.onCreateDescription）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调Activity的onStop方法</span></span><br><span class="line">        callActivityOnStop(r, saveState, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls &#123;<span class="doctag">@link</span> Activity#onStop()&#125; and &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125;, and updates</span></span><br><span class="line"><span class="comment"> * the client record's state.</span></span><br><span class="line"><span class="comment"> * All calls to stop an activity must be done through this method to make sure that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125; is also executed in the same call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnStop</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Before P onSaveInstanceState was called before onStop, starting with P it's</span></span><br><span class="line">    <span class="comment">// called after. Before Honeycomb state was always saved before onPause.</span></span><br><span class="line">    <span class="comment">//这里shouldSaveState为true，因为activity.mFinished早在performPauseActivity的时候就被设为了true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; !r.isPreHoneycomb();</span><br><span class="line">    <span class="comment">//targetSdkVersion为Android P (Android 9)之前</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPreP = r.isPreP();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行stop生命周期</span></span><br><span class="line">        r.activity.performStop(r.mPreserveWindow, reason);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置生命周期状态</span></span><br><span class="line">    r.setState(ON_STOP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStop</span><span class="params">(<span class="keyword">boolean</span> preserveWindow, String reason)</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Loader相关，详见https://developer.android.com/guide/components/loaders</span></span><br><span class="line">    mFragments.doLoaderStop(mChangingConfigurations <span class="comment">/*retain*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow entering picture-in-picture after the activity has been stopped</span></span><br><span class="line">    <span class="comment">//stop后禁用画中画</span></span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="comment">//分发PreStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreStopped回调</span></span><br><span class="line">        dispatchActivityPreStopped();</span><br><span class="line">        <span class="comment">//关闭所有子窗口</span></span><br><span class="line">        <span class="keyword">if</span> (mWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mWindow.closeAllPanels();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we're preserving the window, don't setStoppedState to true, since we</span></span><br><span class="line">        <span class="comment">// need the window started immediately again. Stopping the window will</span></span><br><span class="line">        <span class="comment">// destroys hardware resources and causes flicker.</span></span><br><span class="line">        <span class="keyword">if</span> (!preserveWindow &amp;&amp; mToken != <span class="keyword">null</span> &amp;&amp; mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置停止状态，释放硬件资源，销毁Surface</span></span><br><span class="line">            WindowManagerGlobal.getInstance().setStoppedState(mToken, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//FragmentManager分发stop状态</span></span><br><span class="line">        mFragments.dispatchStop();</span><br><span class="line"></span><br><span class="line">        mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//执行onStop回调</span></span><br><span class="line">        mInstrumentation.callActivityOnStop(<span class="keyword">this</span>);</span><br><span class="line">        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);</span><br><span class="line">        <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onStop方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onStop()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放Cursors</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mManagedCursors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                ManagedCursor mc = mManagedCursors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!mc.mReleased) &#123;</span><br><span class="line">                    mc.mCursor.deactivate();</span><br><span class="line">                    mc.mReleased = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">        dispatchActivityPostStopped();</span><br><span class="line">    &#125;</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>执行<code>onStop</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ActionBar动画</span></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) mActionBar.setShowHideAnimationEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//共享元素动画</span></span><br><span class="line">    mActivityTransitionState.onStop();</span><br><span class="line">    <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">    dispatchActivityStopped();</span><br><span class="line">    mTranslucentCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//super.onStop标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    mEnterAnimationComplete = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一整个<code>onStop</code>生命周期就执行完成了，最后还剩下个<code>onDestroy</code>，根据之前写的事务调度链路，现在应该走到了<code>DestroyActivityItem.execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleDestroyActivity(token, mFinished, mConfigChanges,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>, <span class="string">"DestroyActivityItem"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上就直接调用了<code>ActivityThread.handleDestroyActivity</code>方法</p>
<h1 id="handleDestroyActivity"><a href="#handleDestroyActivity" class="headerlink" title="handleDestroyActivity"></a>handleDestroyActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行onDestroy生命周期</span></span><br><span class="line">    ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//清理之前设置的延时移除的window</span></span><br><span class="line">        cleanUpPendingRemoveWindows(r, finishing);</span><br><span class="line">        WindowManager wm = r.activity.getWindowManager();</span><br><span class="line">        View v = r.activity.mDecor;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                mNumVisibleActivities--;</span><br><span class="line">            &#125;</span><br><span class="line">            IBinder wtoken = v.getWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    <span class="comment">// Hold off on removing this until the new activity's</span></span><br><span class="line">                    <span class="comment">// window is being added.</span></span><br><span class="line">                    r.mPendingRemoveWindow = r.window;</span><br><span class="line">                    r.mPendingRemoveWindowManager = wm;</span><br><span class="line">                    <span class="comment">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class="line">                    <span class="comment">// everything else must be removed, because it might not be able to</span></span><br><span class="line">                    <span class="comment">// behave properly when activity is relaunching.</span></span><br><span class="line">                    <span class="comment">//从DecorView中移除ContentView</span></span><br><span class="line">                    r.window.clearContentView();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//立刻执行View的移除操作，释放硬件资源，销毁Surface，回调View.onDetachedFromWindow</span></span><br><span class="line">                    wm.removeViewImmediate(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (wtoken != <span class="keyword">null</span> &amp;&amp; r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//移除指定Window下的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAll(wtoken,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We're preserving only one window, others should be closed so app views</span></span><br><span class="line">                <span class="comment">// will be detached before the final tear down. It should be done now because</span></span><br><span class="line">                <span class="comment">// some components (e.g. WebView) rely on detach callbacks to perform receiver</span></span><br><span class="line">                <span class="comment">// unregister and other cleanup.</span></span><br><span class="line">                <span class="comment">//移除指定Window下除了当前DecorView以外的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAllExceptView(token, v,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.mDecor = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are delaying the removal of the activity window, then</span></span><br><span class="line">            <span class="comment">// we can't clean up all windows here.  Note that we can't do</span></span><br><span class="line">            <span class="comment">// so later either, which means any windows that aren't closed</span></span><br><span class="line">            <span class="comment">// by the app will leak.  Well we try to warning them a lot</span></span><br><span class="line">            <span class="comment">// about leaking windows, because that is a bug, so if they are</span></span><br><span class="line">            <span class="comment">// using this recreate facility then they get to live with leaks.</span></span><br><span class="line">            WindowManagerGlobal.getInstance().closeAll(token,</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mocked out contexts won't be participating in the normal</span></span><br><span class="line">        <span class="comment">// process lifecycle, but if we're running with a proper</span></span><br><span class="line">        <span class="comment">// ApplicationContext we need to have it tear down things</span></span><br><span class="line">        <span class="comment">// cleanly.</span></span><br><span class="line">        <span class="comment">//清理Context</span></span><br><span class="line">        Context c = r.activity.getBaseContext();</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">            ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理一些销毁后的事项，移除超时回调等</span></span><br><span class="line">            ActivityTaskManager.getService().activityDestroyed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Window</code>这块的处理我目前也不太了解，等以后我学习了<code>WMS</code>那块再补吧</p>
<p>其他的和之前的套路一样，调用<code>performDestroyActivity</code>方法执行销毁<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Core implementation of activity destroy call. */</span></span><br><span class="line"><span class="function">ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activityClass = r.activity.getClass();</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被停职则先执行stop生命周期</span></span><br><span class="line">        <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">            callActivityOnStop(r, <span class="keyword">false</span> <span class="comment">/* saveState */</span>, <span class="string">"destroy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">            ... <span class="comment">//getNonConfigInstance为false，这里不执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//执行onDestroy回调</span></span><br><span class="line">            mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">            <span class="comment">//必须要调用super.onDestroy方法</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                    <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭所有子窗口</span></span><br><span class="line">            <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.window.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置生命周期状态</span></span><br><span class="line">        r.setState(ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲时清理资源</span></span><br><span class="line">    schedulePurgeIdler();</span><br><span class="line">    <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">    <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">    <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        mActivities.remove(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格模式更新Activity计数器，与实际Activity数量对比，判断是否产生内存泄漏</span></span><br><span class="line">    StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performDestroy</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreDestroyed回调</span></span><br><span class="line">    dispatchActivityPreDestroyed();</span><br><span class="line">    mDestroyed = <span class="keyword">true</span>;</span><br><span class="line">    mWindow.destroy();</span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">    onDestroy();</span><br><span class="line">    EventLogTags.writeWmOnDestroyCalled(mIdent, getComponentName().getClassName(),</span><br><span class="line">            <span class="string">"performDestroy"</span>);</span><br><span class="line">    mFragments.doLoaderDestroy();</span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.detachActivity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostDestroyed回调</span></span><br><span class="line">    dispatchActivityPostDestroyed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onDestroy标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dismiss any dialogs we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Dialog</span></span><br><span class="line">    <span class="keyword">if</span> (mManagedDialogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDialogs = mManagedDialogs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDialogs; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (md.mDialog.isShowing()) &#123;</span><br><span class="line">                md.mDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedDialogs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close any cursors we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Cursor</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCursors = mManagedCursors.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCursors; i++) &#123;</span><br><span class="line">            ManagedCursor c = mManagedCursors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.mCursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedCursors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close any open search dialog</span></span><br><span class="line">    <span class="comment">//关闭系统搜索服务的弹窗</span></span><br><span class="line">    <span class="keyword">if</span> (mSearchManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSearchManager.stopSearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActionBar.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分发Destroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityDestroyed回调</span></span><br><span class="line">    dispatchActivityDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DestroyActivityItem</code>没有重写<code>postExecute</code>方法，所以到此为止，<code>Activity</code>整个销毁流程就结束了</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>我们通过本篇文章的分析，可以发现，触发<code>Activity</code>销毁后，<code>onStop</code>和<code>onDestroy</code>这两个生命周期回调的触发时机是不确定的，如果有需求需要在确定<code>Activity</code>要被销毁后立刻执行，我们可以在<code>onPause</code>回调中调用<code>Activity.isFinishing</code>方法判断<code>mFinished</code>标志是否被置<code>true</code>，如果为<code>true</code>则可以判定这个<code>Activity</code>将被销毁</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，<code>Activity</code>的启动流程和销毁流程我们都分析完了，后面应该暂时不会再写<code>Activity</code>相关的源码分析了</p>
<p>之后的一段时间，我可能会将我的精力投入到<code>AIGC</code>的技术调研中，<code>Android源码分析</code>这一系列的后续更新可能会放慢，希望大家多多谅解</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><a class="post-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><a class="post-meta__tags" href="/tags/ActivityTaskManagerService/">ActivityTaskManagerService</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/04/23/android/common/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/"><i class="fa fa-chevron-left">  </i><span>Android动态权限申请从未如此简单</span></a></div><div class="next-post pull-right"><a href="/2023/02/06/android/aosp/WSL%E7%BC%96%E8%AF%91AOSP%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/"><span>WSL编译AOSP必要的几个前置工作</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>