<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - init进程"><meta name="keywords" content="Android源码,init进程"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - init进程 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BootLoader"><span class="toc-number">2.</span> <span class="toc-text">BootLoader</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进程"><span class="toc-number">3.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#idle"><span class="toc-number">3.1.</span> <span class="toc-text">idle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number">3.2.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kthreadd"><span class="toc-number">3.3.</span> <span class="toc-text">kthreadd</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#init进程"><span class="toc-number">4.</span> <span class="toc-text">init进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FirstStageMain"><span class="toc-number">4.1.</span> <span class="toc-text">FirstStageMain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#umask"><span class="toc-number">4.1.1.</span> <span class="toc-text">umask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建目录、设备节点，挂载"><span class="toc-number">4.1.2.</span> <span class="toc-text">创建目录、设备节点，挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化日志"><span class="toc-number">4.1.3.</span> <span class="toc-text">初始化日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SetStdioToDevNull"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">SetStdioToDevNull</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InitKernelLogging"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">InitKernelLogging</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建设备，挂载分区"><span class="toc-number">4.1.4.</span> <span class="toc-text">创建设备，挂载分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结束"><span class="toc-number">4.1.5.</span> <span class="toc-text">结束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exec系列函数"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">exec系列函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SetupSelinux"><span class="toc-number">4.2.</span> <span class="toc-text">SetupSelinux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SecondStageMain"><span class="toc-number">4.3.</span> <span class="toc-text">SecondStageMain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-OOM-Killer机制"><span class="toc-number">4.3.1.</span> <span class="toc-text">Linux OOM Killer机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析init-rc脚本"><span class="toc-number">4.3.2.</span> <span class="toc-text">解析init.rc脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-Init-Language"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">Android Init Language</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Actions"><span class="toc-number">4.3.2.1.1.</span> <span class="toc-text">Actions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Triggers（触发器）"><span class="toc-number">4.3.2.1.2.</span> <span class="toc-text">Triggers（触发器）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Commands"><span class="toc-number">4.3.2.1.3.</span> <span class="toc-text">Commands</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Services"><span class="toc-number">4.3.2.1.4.</span> <span class="toc-text">Services</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Options"><span class="toc-number">4.3.2.1.5.</span> <span class="toc-text">Options</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Imports"><span class="toc-number">4.3.2.1.6.</span> <span class="toc-text">Imports</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解析"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行任务"><span class="toc-number">4.3.3.</span> <span class="toc-text">执行任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动服务"><span class="toc-number">4.3.4.</span> <span class="toc-text">启动服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护服务"><span class="toc-number">4.3.5.</span> <span class="toc-text">守护服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction函数"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">sigaction函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号集函数"><span class="toc-number">4.3.5.2.</span> <span class="toc-text">信号集函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sigemptyset"><span class="toc-number">4.3.5.2.1.</span> <span class="toc-text">sigemptyset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigaddset"><span class="toc-number">4.3.5.2.2.</span> <span class="toc-text">sigaddset</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sigpromask"><span class="toc-number">4.3.5.2.3.</span> <span class="toc-text">sigpromask</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pthread-atfork"><span class="toc-number">4.3.5.3.</span> <span class="toc-text">pthread_atfork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signalfd函数"><span class="toc-number">4.3.5.4.</span> <span class="toc-text">signalfd函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#waitid函数"><span class="toc-number">4.3.5.4.1.</span> <span class="toc-text">waitid函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - init进程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>PC启动会通过BIOS引导，从0x7c00处找到以0xaa55为结尾的引导程序启动。而Android通常使用在移动设备上，没有PC的BIOS，取而代之的是BootLoader。</p>
<h1 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h1><p>在CPU上电复位完成后，会从一个固定的地址加载一段程序，即BootLoader，不同的CPU可能这个地址不同。BootLoader是一段引导程序，其中最为常见的为U-boot，它一般会先检测用户是否按下某些特别按键，这些特别按键是uboot在编译时预先被约定好的，用于进入调试模式。如果用户没有按这些特别的按键，则uboot会从NAND Flash中装载Linux内核，装载的地址是在编译uboot时预先约定好的。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h2><p>Linux内核启动后，便会创建第一个进程idle。idle进程是Linux中的第一个进程，pid为0，是唯一一个没有通过fork产生的进程，它的优先级非常低，用于CPU没有任务的时候进行空转。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>init进程由idle进程创建，是Linux系统的第一个用户进程，pid为1，是系统所有用户进程的直接或间接父进程，本篇重点讲的就是它。</p>
<h2 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h2><p>kthreadd进程同样由idle进程创建，pid为2，它始终运行在内核空间，负责所有内核线程的调度与管理。</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><p>Android的init进程代码在<code>system/core/init/main.cpp</code>中，以main方法作为入口，分为几个阶段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"selinux_setup"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"second_stage"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ueventd和subcontext，都是在各自守护进程中执行的，不在init进程中执行，这里就不多介绍了</p>
<h2 id="FirstStageMain"><a href="#FirstStageMain" class="headerlink" title="FirstStageMain"></a>FirstStageMain</h2><p>默认不加任何参数启动init的话，便会开始init第一阶段，进入到FirstStageMain函数中，代码在<code>system/core/init/first_stage_init.cpp</code>中</p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>文档：<a href="https://man7.org/linux/man-pages/man2/umask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/umask.2.html</a></p>
<p>原型：<code>mode_t umask(mode_t mask);</code></p>
<p>这个方法是用来设置创建目录或文件时所应该赋予权限的掩码</p>
<p>Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755</p>
<p>在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高</p>
<h3 id="创建目录、设备节点，挂载"><a href="#创建目录、设备节点，挂载" class="headerlink" title="创建目录、设备节点，挂载"></a>创建目录、设备节点，挂载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKCALL(x) \</span></span><br><span class="line">    <span class="keyword">if</span> ((x) != <span class="number">0</span>) errors.emplace_back(#x <span class="string">" failed"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the umask.</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(<span class="string">"PATH"</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    CHECKCALL(chmod(<span class="string">"/proc/cmdline"</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmdline;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">"/proc/cmdline"</span>, &amp;cmdline);</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"selinuxfs"</span>, <span class="string">"/sys/fs/selinux"</span>, <span class="string">"selinuxfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/kmsg"</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class="line">        CHECKCALL(mknod(<span class="string">"/dev/kmsg_debug"</span>, S_IFCHR | <span class="number">0622</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/random"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">8</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/urandom"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">9</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/ptmx"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">5</span>, <span class="number">2</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/null"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">3</span>)));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/mnt"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=1000"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/vendor"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/product"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/debug_ramdisk"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=0"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CHECKCALL</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><h4 id="SetStdioToDevNull"><a href="#SetStdioToDevNull" class="headerlink" title="SetStdioToDevNull"></a>SetStdioToDevNull</h4><p>由于Linux内核打开了/dev/console作为标准输入输出流（stdin/stdout/stderr）的文件描述符，而init进程在用户空间，无权访问/dev/console，后续如果执行printf的话可能会导致错误，所以先调用<code>SetStdioToDevNull</code>函数来将标准输入输出流（stdin/stdout/stderr）用/dev/null文件描述符替换</p>
<p>/dev/null被称为空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，读取它会立即得到一个EOF</p>
<h4 id="InitKernelLogging"><a href="#InitKernelLogging" class="headerlink" title="InitKernelLogging"></a>InitKernelLogging</h4><p>接着调用<code>InitKernelLogging</code>函数，初始化了一个简单的kernel日志系统</p>
<h3 id="创建设备，挂载分区"><a href="#创建设备，挂载分区" class="headerlink" title="创建设备，挂载分区"></a>创建设备，挂载分区</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> want_console = ALLOW_FIRST_STAGE_CONSOLE ? FirstStageConsole(cmdline) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline), want_console)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (want_console != FirstStageConsoleParam::DISABLED) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to load kernel modules, starting console"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Failed to load kernel modules"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;</span><br><span class="line">        StartConsole();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ForceNormalBoot(cmdline)) &#123;</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/first_stage_ramdisk"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// SwitchRoot() must be called with a mount point as the target, so we bind mount the</span></span><br><span class="line">        <span class="comment">// target directory to itself here.</span></span><br><span class="line">        <span class="keyword">if</span> (mount(<span class="string">"/first_stage_ramdisk"</span>, <span class="string">"/first_stage_ramdisk"</span>, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Could not bind mount /first_stage_ramdisk to itself"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SwitchRoot(<span class="string">"/first_stage_ramdisk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>至此，第一阶段的init结束，通过execv函数带参执行init文件，进入<code>SetupSelinux</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"selinux_setup"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/kmsg"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line"><span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line"><span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>用exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。</p>
<p>这里在末尾直接打log是因为，exec系列函数如果执行正常是不会返回的，所以只要执行到下面就代表exec执行出错了</p>
<h2 id="SetupSelinux"><a href="#SetupSelinux" class="headerlink" title="SetupSelinux"></a>SetupSelinux</h2><p>启动Selinux安全机制，初始化selinux，加载SELinux规则，配置SELinux相关log输出，并启动第二阶段：<code>SecondStageMain</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    MountMissingSystemPartitions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up SELinux, loading the SELinux policy.</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelinuxInitialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class="line">    <span class="comment">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class="line">    <span class="comment">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class="line">    <span class="comment">// recovery image for A/B devices.</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">"/system/bin/init"</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"restorecon failed of /system/bin/init failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, <span class="built_in">std</span>::to_string(start_time.time_since_epoch().count()).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"second_stage"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondStageMain"><a href="#SecondStageMain" class="headerlink" title="SecondStageMain"></a>SecondStageMain</h2><p>使用<code>second_stage</code>参数启动init的话，便会开始init第二阶段，进入到<code>SecondStageMain</code>函数中，代码在<code>system/core/init/init.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//和第一阶段一样，初始化日志</span></span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set init and its forked children's oom_adj.</span></span><br><span class="line">    <span class="comment">//设置init进程和以后fork出来的进程的OOM等级，这里的值为-1000，保证进程不会因为OOM被杀死</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                WriteFile(<span class="string">"/proc/1/oom_score_adj"</span>, StringPrintf(<span class="string">"%d"</span>, DEFAULT_OOM_SCORE_ADJUST));</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Unable to write "</span> &lt;&lt; DEFAULT_OOM_SCORE_ADJUST</span><br><span class="line">                   &lt;&lt; <span class="string">" to /proc/1/oom_score_adj: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    <span class="comment">//设置一个标记，代表正在启动过程中</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">open</span>(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化系统属性</span></span><br><span class="line">    PropertyInit();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Mount extra filesystems required during second stage init</span></span><br><span class="line">    <span class="comment">//挂载额外的文件系统</span></span><br><span class="line">    MountExtraFilesystems();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    <span class="comment">//设置SELinux</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelabelInitialize();</span><br><span class="line">    SelinuxRestoreContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用epoll，注册信号处理函数，守护进程服务</span></span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">    <span class="comment">//启动系统属性服务</span></span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//解析init.rc脚本</span></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构建了一些Action，Trigger等事件对象加入事件队列中</span></span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, <span class="string">"SetupCgroups"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class="string">"SetKptrRestrict"</span>);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, <span class="string">"TestPerfEventSelinux"</span>);</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class="string">"SetMmapRndBits"</span>);</span><br><span class="line">    Keychords keychords;</span><br><span class="line">    am.QueueBuiltinAction(</span><br><span class="line">            [&amp;epoll, &amp;keychords](<span class="keyword">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class="line">                    keychords.Register(svc-&gt;keycodes());</span><br><span class="line">                &#125;</span><br><span class="line">                keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"KeychordInit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环，等待事件处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Linux-OOM-Killer机制"><a href="#Linux-OOM-Killer机制" class="headerlink" title="Linux OOM Killer机制"></a>Linux OOM Killer机制</h3><p>Linux下有一种 OOM KILLER 的机制，它会在系统内存耗尽的情况下，启用自己算法有选择性的杀掉一些进程，这个算法和三个值有关：</p>
<ul>
<li>/proc/PID/oom_score ,OOM 最终得分，值越大越有可能被杀掉</li>
<li>/proc/PID/oom_score_adj ，取值范围为-1000到1000，计算oom_score时会加上该参数</li>
<li>/proc/PID/oom_adj ，取值是-17到+15，该参数主要是为兼容旧版内核</li>
</ul>
<p>在init过程中，代码设置了init进程和以后fork出来的进程的OOM等级，这里的值为-1000，设置为这个值就可以保证进程永远不会因为OOM被杀死</p>
<h3 id="解析init-rc脚本"><a href="#解析init-rc脚本" class="headerlink" title="解析init.rc脚本"></a>解析init.rc脚本</h3><h4 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h4><p>rc文件，是用<code>Android Init Language</code>编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀</p>
<p>它的语法说明可以在aosp源码<code>system/core/init/README.md</code>中找到，这里就简单说明一下语法规则</p>
<h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h5><p><code>Actions</code>是一系列命令的开始，一个<code>Action</code>会有一个触发器，用于确定<code>Action</code>何时执行。当一个与<code>Action</code>的触发器匹配的事件发生时，该动作被添加到待执行队列的尾部</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Triggers（触发器）"><a href="#Triggers（触发器）" class="headerlink" title="Triggers（触发器）"></a>Triggers（触发器）</h5><p>触发器作用于<code>Actions</code>，可用于匹配某些类型的事件，并用于导致操作发生</p>
<h5 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h5><p><code>Commands</code>就是一个个命令的集合了</p>
<p><code>Action</code>, <code>Triggers</code>, <code>Commands</code>共同组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted </span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot. </span><br><span class="line">    exec_start update_verifier_nonencrypted </span><br><span class="line">    start statsd </span><br><span class="line">    start netd </span><br><span class="line">    start zygote </span><br><span class="line">    start zygote_secondary</span><br></pre></td></tr></table></figure>

<h5 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h5><p><code>Services</code>是对一些程序的定义，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>name：定义的服务名</li>
<li>pathname：这个程序的路径</li>
<li>argument：程序运行的参数</li>
<li>option：服务选项，后文将介绍</li>
</ul>
<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p><code>Options</code>是对<code>Services</code>的修饰，它们影响着服务运行的方式和时间</p>
<p><code>Services</code>, <code>Options</code>组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server --socket-name&#x3D;zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    task_profiles ProcessCapacityHigh MaxPerformance</span><br></pre></td></tr></table></figure>

<h5 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h5><p>导入其他的rc文件或目录解析，如果path是一个目录，目录中的每个文件都被解析为一个rc文件。它不是递归的，嵌套的目录将不会被解析。</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;path&gt;</span><br></pre></td></tr></table></figure>

<p><code>Imports</code>的内容会放到最后解析</p>
<p>上文所述的<code>Commands</code>，<code>Options</code>等具体命令，可以网上搜索一下，或者自己看<code>system/core/init/README.md</code></p>
<p><code>Commands</code>的定义可以在<code>system/core/init/builtins.cpp</code>中找到</p>
<p><code>Options</code>的定义可以在<code>system/core/init/service_parser.cpp</code>中找到</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">"ro.boot.init_rc"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        parser.ParseConfig(<span class="string">"/system/etc/init/hw/init.rc"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/system/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/system/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// late_import is available only in Q and earlier release. As we don't</span></span><br><span class="line">        <span class="comment">// have system_ext in those versions, skip late_import for system_ext.</span></span><br><span class="line">        parser.ParseConfig(<span class="string">"/system_ext/etc/init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/product/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/product/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/odm/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/odm/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/vendor/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/vendor/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会从这些地方寻找rc文件解析，<code>/system/etc/init/hw/init.rc</code>是主rc文件，剩下的目录，如果system分区尚未挂载的话，就把它们加入到<code>late_import_paths</code>中，等到后面<code>mount_all</code>时再加载</p>
<p>主rc文件在编译前的位置为<code>system/core/rootdir/init.rc</code></p>
<p>简单分析一下：</p>
<p>首先，以<code>ActionManager</code>和<code>ServiceList</code>作为参数创建了一个Parser解析器，解析后的结果会存放在<code>ActionManager</code>和<code>ServiceList</code>中，这里的两个传进来的参数都是单例模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), <span class="built_in">std</span>::nullopt));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建了一个<code>Parser</code>对象，然后往里面添加了<code>ServiceParser</code>、<code>ActionParser</code>以及<code>ImportParser</code>，这三个类都是继承自<code>ServiceParser</code>，这里的<code>std::make_unique</code>是new了一个对象，并用其原始指针构造出了一个智能指针</p>
<p>接着走到<code>Parser::ParseConfig</code>方法中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否是目录，如果是目录，就把目录中的所有文件加入容器中排序后依次解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigDir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing directory "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir);</span><br><span class="line">    <span class="keyword">if</span> (!config_dir) &#123;</span><br><span class="line">        PLOG(INFO) &lt;&lt; <span class="string">"Could not import directory '"</span> &lt;&lt; path &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* current_file;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files;</span><br><span class="line">    <span class="keyword">while</span> ((current_file = readdir(config_dir.<span class="built_in">get</span>()))) &#123;</span><br><span class="line">        <span class="comment">// Ignore directories and only process regular files.</span></span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> current_path =</span><br><span class="line">                android::base::StringPrintf(<span class="string">"%s/%s"</span>, path.c_str(), current_file-&gt;d_name);</span><br><span class="line">            files.emplace_back(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sort first so we load files in a consistent order (bug 31996208)</span></span><br><span class="line">    <span class="built_in">std</span>::sort(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ParseConfigFile(file)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"could not import file '"</span> &lt;&lt; file &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终都调用了<code>Parser::ParseConfigFile</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing file "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="keyword">auto</span> config_contents = ReadFile(path);</span><br><span class="line">    <span class="keyword">if</span> (!config_contents.ok()) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Unable to read config file '"</span> &lt;&lt; path &lt;&lt; <span class="string">"': "</span> &lt;&lt; config_contents.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; <span class="string">"(Parsing "</span> &lt;&lt; path &lt;&lt; <span class="string">" took "</span> &lt;&lt; t &lt;&lt; <span class="string">".)"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从文件中读取出字符串，并继续调用<code>Parser::ParseData</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="built_in">std</span>::<span class="built_in">string</span>* data)</span> </span>&#123;</span><br><span class="line">    data-&gt;push_back(<span class="string">'\n'</span>);  <span class="comment">// <span class="doctag">TODO:</span> fix tokenizer</span></span><br><span class="line">    data-&gt;push_back(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.<span class="built_in">line</span> = <span class="number">0</span>;</span><br><span class="line">    state.ptr = data-&gt;data();</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> section_start_line = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we encounter a bad section start, there is no valid parser object to parse the subsequent</span></span><br><span class="line">    <span class="comment">// sections, so we must suppress errors until the next valid section is found.</span></span><br><span class="line">    <span class="keyword">bool</span> bad_section_found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_section = [&amp;] &#123;</span><br><span class="line">        bad_section_found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (section_parser == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;EndSection(); !result.ok()) &#123;</span><br><span class="line">            parse_error_count_++;</span><br><span class="line">            LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; section_start_line &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">        section_start_line = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_EOF:</span><br><span class="line">                end_section();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [section_name, section_parser] : section_parsers_) &#123;</span><br><span class="line">                    section_parser-&gt;EndFile();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> T_NEWLINE: &#123;</span><br><span class="line">                state.<span class="built_in">line</span>++;</span><br><span class="line">                <span class="keyword">if</span> (args.empty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// If we have a line matching a prefix we recognize, call its callback and unset any</span></span><br><span class="line">                <span class="comment">// current section parsers.  This is meant for /sys/ and /dev/ line entries for</span></span><br><span class="line">                <span class="comment">// uevent.</span></span><br><span class="line">                <span class="keyword">auto</span> line_callback = <span class="built_in">std</span>::find_if(</span><br><span class="line">                    line_callbacks_.<span class="built_in">begin</span>(), line_callbacks_.<span class="built_in">end</span>(),</span><br><span class="line">                    [&amp;args](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c) &#123; <span class="keyword">return</span> android::base::StartsWith(args[<span class="number">0</span>], c.first); &#125;);</span><br><span class="line">                <span class="keyword">if</span> (line_callback != line_callbacks_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = line_callback-&gt;second(<span class="built_in">std</span>::<span class="built_in">move</span>(args)); !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    section_parser = section_parsers_[args[<span class="number">0</span>]].<span class="built_in">get</span>();</span><br><span class="line">                    section_start_line = state.<span class="built_in">line</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                                section_parser-&gt;ParseSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), filename, state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                        bad_section_found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;ParseLineSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bad_section_found) &#123;</span><br><span class="line">                    parse_error_count_++;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span></span><br><span class="line">                               &lt;&lt; <span class="string">": Invalid section keyword found"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                args.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> T_TEXT:</span><br><span class="line">                args.emplace_back(state.<span class="built_in">text</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里新建了一个<code>parse_state</code>结构体，用来以行为单位，分割整个文件字符串，根据分割出来的结果返回相应的TYPE，<code>Parser::ParseData</code>方法再通过TYPE来做逐行解析</p>
<p>这个结构体以及TPYE和分割分割方法的定义在<code>system/core/init/tokenizer.h</code>中，在<code>system/core/init/tokenizer.cpp</code>中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_token</span><span class="params">(struct parse_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *x = state-&gt;ptr;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;nexttoken) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = state-&gt;nexttoken;</span><br><span class="line">        state-&gt;nexttoken = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_EOF;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">while</span> (*x &amp;&amp; (*x != <span class="string">'\n'</span>)) x++;</span><br><span class="line">            <span class="keyword">if</span> (*x == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                state-&gt;ptr = x+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state-&gt;ptr = x;</span><br><span class="line">                <span class="keyword">return</span> T_EOF;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">text</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">textdone:</span><br><span class="line">    state-&gt;ptr = x;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T_TEXT;</span><br><span class="line"><span class="built_in">text</span>:</span><br><span class="line">    state-&gt;<span class="built_in">text</span> = s = x;</span><br><span class="line">textresume:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            state-&gt;nexttoken = T_NEWLINE;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="comment">/* unterminated quoted thing */</span></span><br><span class="line">                    state-&gt;ptr = x;</span><br><span class="line">                    <span class="keyword">return</span> T_EOF;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">goto</span> textresume;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    *s++ = *x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">goto</span> textdone;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                *s++ = <span class="string">'\n'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                *s++ = <span class="string">'\r'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                *s++ = <span class="string">'\t'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                *s++ = <span class="string">'\\'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                <span class="keyword">if</span> (x[<span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                FALLTHROUGH_INTENDED;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                state-&gt;<span class="built_in">line</span>++;</span><br><span class="line">                x++;</span><br><span class="line">                    <span class="comment">/* eat any extra whitespace */</span></span><br><span class="line">                <span class="keyword">while</span>((*x == <span class="string">' '</span>) || (*x == <span class="string">'\t'</span>)) x++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* unknown escape -- just copy */</span></span><br><span class="line">                *s++ = *x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *s++ = *x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先看看有没有遇到结束符（换行 \n 或者EOF \0）或者注释（#）如果遇到了就返回<code>T_NEWLINE</code>或者<code>T_EOF</code>代表这上一行结束了或者整个文件读取完了，没有遇到的话说明读取的是可解析的正文，跳到text段，将文本内容写到<code>state.text</code>中，直到碰到换行符或空格等分割标志（以空格或换行等作为分隔符，一小段一小段的进行分割），将读取到的最后一个正文的位置+1处的字符置为\0，<code>state.text</code>里的内容便称为了完整一段的内容，接着返回<code>T_TEXT</code>表示已读入一段文本</p>
<p>接着回到<code>Parser::ParseData</code>方法中，如果读到的TYPE是<code>T_TEXT</code>，就将这一段内容先添加到容器中，当读到<code>T_NEWLINE</code>时，解析之前读入的一整行内容，先用args[0]（一行的开头）去寻找我们之前添加的<code>SectionParser</code>，如果能找到，说明这一行是service、on或者import，将<code>section_parser</code>赋值为相应<code>SectionParser</code>子类的指针，调用其<code>ParseSection</code>方法解析，如果读入的一行里，不是以service、on或者import开头，并且之前定义的<code>section_parser</code>不为空指针，说明是service或者on参数的子参数，调用<code>ParseLineSection</code>方法解析子参数，并加入到父参数中。</p>
<p>最后，每次读取完都会执行<code>args.clear()</code>清楚这一行的数据，当读取到新的service、on或者import时，需要先执行<code>EndSection</code>方法，将之前解析好的结构添加到列表中</p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>回到<code>SecondStageMain</code>中，可以看到，最后有一个死循环，用来等待事件处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>am.ExecuteOneCommand()</code>方法便是执行从rc文件中解析出来的指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> lock = <span class="built_in">std</span>::lock_guard&#123;event_queue_lock_&#125;;</span><br><span class="line">        <span class="comment">// Loop through the event queue until we have an action to execute</span></span><br><span class="line">        <span class="comment">//当前正在执行的action队列为空，但等待执行的事件队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> (current_executing_actions_.empty() &amp;&amp; !event_queue_.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">                <span class="comment">//从等待执行的事件队列头取出一个元素event， </span></span><br><span class="line">                <span class="comment">//然后调用action的CheckEvent检查此event是否匹配当前action </span></span><br><span class="line">                <span class="comment">//如果匹配，将这个action加入到正在执行的actions队列的队尾</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">std</span>::visit([&amp;action](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) &#123; <span class="keyword">return</span> action-&gt;CheckEvent(event); &#125;,</span><br><span class="line">                               event_queue_.front())) &#123;</span><br><span class="line">                    current_executing_actions_.emplace(action.<span class="built_in">get</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            event_queue_.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从队列头取一个action（front不会使元素出队）</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是第一次执行这个action</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = action-&gt;BuildTriggersString();</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"processing action ("</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">") from ("</span> &lt;&lt; action-&gt;filename()</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; action-&gt;<span class="built_in">line</span>() &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个current_command_是个成员变量，标志着执行到了哪一行</span></span><br><span class="line">    action-&gt;ExecuteOneCommand(current_command_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this was the last command in the current action, then remove</span></span><br><span class="line">    <span class="comment">// the action from the executing list.</span></span><br><span class="line">    <span class="comment">// If this action was oneshot, then also remove it from actions_.</span></span><br><span class="line">    ++current_command_;</span><br><span class="line">    <span class="comment">//current_command_等于action的commands数量，说明这个action以及全部执行完了</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == action-&gt;NumCommands()) &#123;</span><br><span class="line">        <span class="comment">//此action出队</span></span><br><span class="line">        current_executing_actions_.pop();</span><br><span class="line">        <span class="comment">//重置计数器</span></span><br><span class="line">        current_command_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (action-&gt;oneshot()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> eraser = [&amp;action](<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123; <span class="keyword">return</span> a.<span class="built_in">get</span>() == action; &#125;;</span><br><span class="line">            actions_.erase(<span class="built_in">std</span>::remove_if(actions_.<span class="built_in">begin</span>(), actions_.<span class="built_in">end</span>(), eraser),</span><br><span class="line">                           actions_.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面会执行<code>Action::ExecuteOneCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteOneCommand</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We need a copy here since some Command execution may result in</span></span><br><span class="line">    <span class="comment">// changing commands_ vector by importing .rc files through parser</span></span><br><span class="line">    Command cmd = commands_[command];</span><br><span class="line">    ExecuteCommand(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用到了<code>Action::ExecuteCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="comment">//这一行是具体的执行</span></span><br><span class="line">    <span class="keyword">auto</span> result = command.InvokeFunc(subcontext_);</span><br><span class="line">    <span class="keyword">auto</span> duration = t.duration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any action longer than 50ms will be warned to user as slow operation</span></span><br><span class="line">    <span class="comment">//失败、超时或者debug版本都需要打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (!result.has_value() || duration &gt; <span class="number">50</span>ms ||</span><br><span class="line">        android::base::GetMinimumLogSeverity() &lt;= android::base::DEBUG) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = BuildTriggersString();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> cmd_str = command.BuildCommandString();</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Command '"</span> &lt;&lt; cmd_str &lt;&lt; <span class="string">"' action="</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">" ("</span> &lt;&lt; filename_</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; command.<span class="built_in">line</span>() &lt;&lt; <span class="string">") took "</span> &lt;&lt; duration.count() &lt;&lt; <span class="string">"ms and "</span></span><br><span class="line">                  &lt;&lt; (result.ok() ? <span class="string">"succeeded"</span> : <span class="string">"failed: "</span> + result.error().message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会调用<code>Command::InvokeFunc</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Command::InvokeFunc</span><span class="params">(Subcontext* subcontext)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从 /vendor 或 /oem 解析出来的rc文件都会走这里 </span></span><br><span class="line">    <span class="comment">//涉及到selinux权限问题，Google为了保证安全 </span></span><br><span class="line">    <span class="comment">//队对厂商定制的rc文件中的命令执行，以及由此启动的服务的权限都会有一定限制</span></span><br><span class="line">    <span class="keyword">if</span> (subcontext) &#123;</span><br><span class="line">        <span class="keyword">if</span> (execute_in_subcontext_) &#123;</span><br><span class="line">            <span class="keyword">return</span> subcontext-&gt;Execute(args_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> expanded_args = subcontext-&gt;ExpandArgs(args_);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_args.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_args.error();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RunBuiltinFunction(func_, *expanded_args, subcontext-&gt;context());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//系统原生的rc文件命令都会走这里</span></span><br><span class="line">    <span class="keyword">return</span> RunBuiltinFunction(func_, args_, kInitContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统原生的rc文件命令都会走到<code>RunBuiltinFunction</code>方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">RunBuiltinFunction</span><span class="params">(<span class="keyword">const</span> BuiltinFunction&amp; function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> builtin_arguments = BuiltinArguments(context);</span><br><span class="line"></span><br><span class="line">    builtin_arguments.args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    builtin_arguments.args[<span class="number">0</span>] = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        builtin_arguments.args[i] = <span class="built_in">std</span>::<span class="built_in">move</span>(*expanded_arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function(builtin_arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>function</code>是一个以<code>BuiltinArguments</code>为参数的<code>std::function</code>函数包装器模板，可以包装函数、函数指针、类成员函数指针或任意类型的函数对象，在Command对象new出来的时候构造函数就指定了这个func_，我们可以看一下<code>Action::AddCommand</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Action::AddCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args, <span class="keyword">int</span> <span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_map_) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"no function map available"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从function_map_中进行键值对查找</span></span><br><span class="line">    <span class="keyword">auto</span> map_result = function_map_-&gt;Find(args);</span><br><span class="line">    <span class="keyword">if</span> (!map_result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; map_result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commands_.emplace_back(map_result-&gt;function, map_result-&gt;run_in_subcontext, <span class="built_in">std</span>::<span class="built_in">move</span>(args),</span><br><span class="line">                           <span class="built_in">line</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，是通过rc文件中的字符串去一个<code>function_map_</code>常量中查找得到的，而这个<code>function_map_</code>是在哪赋值的呢，答案是在<code>SecondStageMain</code>函数中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个在前文代码中有提及，map的定义在<code>system/core/init/builtins.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BuiltinFunctionMap&amp; <span class="title">GetBuiltinFunctionMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> BuiltinFunctionMap builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">"bootchart"</span>,               &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_bootchart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chmod"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_chmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chown"</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    &#123;<span class="literal">true</span>,   do_chown&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_restart"</span>,           &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_stop"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"copy"</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_copy&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"domainname"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_domainname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enable"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_enable&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec"</span>,                    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_background"</span>,         &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec_background&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_start"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_exec_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"export"</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_export&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"hostname"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_hostname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ifup"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_ifup&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"init_user0"</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_init_user0&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"insmod"</span>,                  &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_insmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"installkey"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_installkey&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_restart"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_start"</span>,         &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_stop"</span>,          &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_persist_props"</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_persist_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_system_props"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_system_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"loglevel"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_loglevel&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mark_post_data"</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_mark_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mkdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">6</span>,    &#123;<span class="literal">true</span>,   do_mkdir&#125;&#125;&#125;,</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do mount operations in vendor_init.</span></span><br><span class="line">        <span class="comment">// mount_all is currently too complex to run in vendor_init as it queues action triggers,</span></span><br><span class="line">        <span class="comment">// imports rc scripts, etc.  It should be simplified and run in vendor_init context.</span></span><br><span class="line">        <span class="comment">// mount and umount are run in the same context as mount_all for symmetry.</span></span><br><span class="line">        &#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">0</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount"</span>,                   &#123;<span class="number">3</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"perform_apex_config"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_perform_apex_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"update_linker_config"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_update_linker_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"readahead"</span>,               &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_readahead&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"remount_userdata"</span>,        &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_remount_userdata&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restart"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon"</span>,              &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon_recursive"</span>,    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon_recursive&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rm"</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rm&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rmdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rmdir&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setprop"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_setprop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setrlimit"</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    &#123;<span class="literal">false</span>,  do_setrlimit&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"start"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"stop"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"swapon_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_swapon_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enter_default_mount_ns"</span>,  &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_enter_default_mount_ns&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"symlink"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_symlink&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"sysclktz"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_sysclktz&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"trigger"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_trigger&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_update_state"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_verity_update_state&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait"</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_wait&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait_for_prop"</span>,           &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_wait_for_prop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"write"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_write&#125;&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>以下面一段rc脚本为例，我们看一下一个服务是怎么启动的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start </span><br><span class="line">    start zygote</span><br></pre></td></tr></table></figure>

<p>首先这是一个action，当init进程在死循环中执行到<code>ActionManager::ExecuteOneCommand</code>方法时，检查到这个action刚好符合<code>event_queue_</code>队首的<code>EventTrigger</code>，便会执行这个<code>action</code>下面的<code>commands</code>。<code>commands</code>怎么执行在上面已经分析过了，我们去<code>system/core/init/builtins.cpp</code>里的map中找key-value对应关系，发现start对应着<code>do_start</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Result&lt;<span class="keyword">void</span>&gt; <span class="title">do_start</span><span class="params">(<span class="keyword">const</span> BuiltinArguments&amp; args)</span> </span>&#123;</span><br><span class="line">    Service* svc = ServiceList::GetInstance().FindService(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!svc) <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"service "</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">" not found"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = svc-&gt;Start(); !result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorIgnoreEnoent() &lt;&lt; <span class="string">"Could not start service: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceList</code>通过<code>args[1]</code>即定义的服务名去寻找之前解析好的service，并执行<code>Service::Start</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//上面基本上是一些检查和准备工作，这里先忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//通过namespaces_.flags判断使用哪种方式创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (namespaces_.flags) &#123;</span><br><span class="line">        pid = clone(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespaces_.flags | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置权限掩码</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//内部调用execv函数启动文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ExpandArgsAndExecv(args_, sigstop_)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"cannot execv('"</span> &lt;&lt; args_[<span class="number">0</span>]</span><br><span class="line">                        &lt;&lt; <span class="string">"'). See the 'Debugging init' section of init's README.md for tips"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pid_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ErrnoError() &lt;&lt; <span class="string">"Failed to fork"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ExpandArgsAndExecv</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">bool</span> sigstop)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; expanded_args;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; c_strings;</span><br><span class="line"></span><br><span class="line">    expanded_args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//将要执行的文件路径先加入容器</span></span><br><span class="line">    c_strings.push_back(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(args[<span class="number">0</span>].data()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; args[<span class="number">0</span>] &lt;&lt; <span class="string">": cannot expand arguments': "</span> &lt;&lt; expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        expanded_args[i] = *expanded_arg;</span><br><span class="line">        c_strings.push_back(expanded_args[i].data());</span><br><span class="line">    &#125;</span><br><span class="line">    c_strings.push_back(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigstop) &#123;</span><br><span class="line">        kill(getpid(), SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用execv函数，带参执行文件</span></span><br><span class="line">    <span class="keyword">return</span> execv(c_strings[<span class="number">0</span>], c_strings.data()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先<code>fork</code>（或<code>clone</code>）出了一个子进程，再在这个子进程中调用<code>execv</code>函数执行文件</p>
<p>到此为止，一个服务便被启动起来了</p>
<h3 id="守护服务"><a href="#守护服务" class="headerlink" title="守护服务"></a>守护服务</h3><p>当服务启动起来后，<code>init</code>进程也要负责服务的守护，为什么呢？</p>
<p>假设<code>zygote</code>进程挂了，那<code>zygote</code>进程下的所有子进程都可能会被杀，整个<code>Android</code>系统会出现大问题，那怎么办呢？得把<code>zygote</code>进程重启起来呀。<code>init</code>进程守护服务做的就是这些事，当接收到子进程退出信号，就会触发对应的函数进行处理，去根据这个进程所对应的服务，处理后事（重启等）</p>
<p>代码在这个位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建出来一个epoll句柄，再用它去<code>InstallSignalFdHandler</code>装载信号handler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InstallSignalFdHandler</span><span class="params">(Epoll* epoll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Applying SA_NOCLDSTOP to a defaulted SIGCHLD handler prevents the signalfd from receiving</span></span><br><span class="line">    <span class="comment">// SIGCHLD when a child process stops or continues (b/77867680#comment9).</span></span><br><span class="line">    <span class="comment">//设置SIGCHLD信号的处理方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在init进程中屏蔽SIGCHLD、SIGTERM信号</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsRebootCapable()) &#123;</span><br><span class="line">        <span class="comment">// If init does not have the CAP_SYS_BOOT capability, it is running in a container.</span></span><br><span class="line">        <span class="comment">// In that case, receiving SIGTERM will cause the system to shut down.</span></span><br><span class="line">        sigaddset(&amp;mask, SIGTERM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to block signals"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a handler to unblock signals in the child processes.</span></span><br><span class="line">    <span class="comment">//在子进程中取消SIGCHLD、SIGTERM信号屏蔽</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> result = pthread_atfork(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;UnblockSignals);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to register a fork handler: "</span> &lt;&lt; strerror(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建用于接受信号的文件描述符</span></span><br><span class="line">    signal_fd = signalfd(<span class="number">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (signal_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to create signalfd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册信号处理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p>先介绍一下<code>sigaction</code>函数，它是用来检查和设置一个信号的处理方式的</p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>第一个参数<code>signum</code>，定义在<code>signal.h</code>中，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>是一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_handler</code>表示信号的处理方式，<code>sa_flags</code>用来设置信号处理的其他相关操作</p>
<p>第三个参数<code>oldact</code>，如果不为<code>null</code>，会将此信号原来的处理方式保存进去</p>
<p>对应一下<code>InstallSignalFdHandler</code>里的调用，<code>.sa_handler = SIG_DFL</code>表示使用默认的信号处理，<code>.sa_flags = SA_NOCLDSTOP</code>当参数<code>signum</code>为<code>SIGCHLD</code>的时候生效，表示当子进程暂停时不会通知父进程</p>
<h4 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h4><p>接下来<code>InstallSignalFdHandler</code>函数调用了一些信号集函数</p>
<h5 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h5><p>原型：<code>int sigemptyset(sigset_t *set);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigemptyset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</a></p>
<p>该函数的作用是将信号集初始化为空</p>
<h5 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a>sigaddset</h5><p>原型：<code>int sigaddset(sigset_t *set, int signo);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigaddset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigaddset.3p.html</a></p>
<p>该函数的作用是把信号signo添加到信号集set中</p>
<h5 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h5><p>原型：<code>int sigpromask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>该函数可以根据参数指定的方法修改进程的信号屏蔽字</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<p>为什么init进程要屏蔽这些信号呢？因为它后面会特殊处理这些信号</p>
<h4 id="pthread-atfork"><a href="#pthread-atfork" class="headerlink" title="pthread_atfork"></a>pthread_atfork</h4><p>这也是一个Linux函数，用来注册fork的handlers</p>
<p>原型：<code>int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</code></p>
<p>调用这个函数后，当进程再调用fork时，内部创建子进程钱会先在父进程中调用<code>prepare</code>函数，创建子进程成功后，会在父进程中调用<code>parent</code>函数，子进程中调用<code>child</code>函数</p>
<p>对应到<code>InstallSignalFdHandler</code>里来，即当init进程fork出子进程后调用<code>UnblockSignals</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnblockSignals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGTERM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to unblock signals for PID "</span> &lt;&lt; getpid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是，先在init进程中屏蔽了<code>SIGCHLD</code>、<code>SIGTERM</code>信号，再在子进程中解除了这两个信号的屏蔽</p>
<h4 id="signalfd函数"><a href="#signalfd函数" class="headerlink" title="signalfd函数"></a>signalfd函数</h4><p>同样也是Linux函数，用来创建用于接受信号的文件描述符</p>
<p>原型：<code>int signalfd(int fd, const sigset_t *mask, int flags);</code></p>
<p>参数fd如果为-1，则该函数会创建一个新的文件描述符与mask信号集相关联，如果不为-1，则该函数会用mask替换之前与这个fd相关联的信号集</p>
<p>flags：</p>
<ul>
<li>SFD_NONBLOCK：给新打开的文件描述符设置<code>O_NONBLOCK</code>标志，非阻塞I/O模式</li>
<li>SFD_CLOEXEC：给新打开的文件描述符设置<code>O_CLOEXEC</code>标志，当exec函数执行成功后，会自动关闭这个文件描述符</li>
</ul>
<p>对应到<code>InstallSignalFdHandler</code>中，它创建了一个用于接受<code>SIGCHLD</code>、<code>SIGTERM</code>信号的文件描述符。回忆一下之前对启动服务的分析，是先调用fork创建进程，在exec执行文件，将flags设置为<code>SFD_CLOEXEC</code>，这样就可以保证在子进程中关闭由fork得到的接收信号的文件描述符</p>
<p>注册信号处理器</p>
<p>最后调用<code>Epoll::RegisterHandler</code>方法注册处理器，内部调用了<code>epoll_ctl</code>函数，感兴趣可以自己看一下，文档：<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></p>
<p>这样，当init进程接收到<code>SIGCHLD</code>、<code>SIGTERM</code>信号时便会调用<code>HandleSignalFd</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleSignalFd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signalfd_siginfo siginfo;</span><br><span class="line">    <span class="comment">//从信号集文件描述符中读取信息</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(<span class="built_in">read</span>(signal_fd, &amp;siginfo, <span class="keyword">sizeof</span>(siginfo)));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read != <span class="keyword">sizeof</span>(siginfo)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to read siginfo from signal_fd"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            HandleSigtermSignal(siginfo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"signal_fd: received unexpected signal "</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里主要看<code>SIGCHLD</code>，当子进程退出，init进程便会捕获到<code>SIGCHLD</code>，执行<code>ReapAnyOutstandingChildren</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapAnyOutstandingChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ReapOneProcess() != <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ReapOneProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// This returns a zombie pid or informs us that there are no zombies left to be reaped.</span></span><br><span class="line">    <span class="comment">// It does NOT reap the pid; that is done below.</span></span><br><span class="line">    <span class="comment">//获取一个已经退出的子进程，但暂时先不销毁</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class="number">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"waitid failed"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pid = siginfo.si_pid;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we know we have a zombie pid, so we use this scopeguard to reap the pid</span></span><br><span class="line">    <span class="comment">// whenever the function returns from this point forward.</span></span><br><span class="line">    <span class="comment">// We do NOT want to reap the zombie earlier as in Service::Reap(), we kill(-pid, ...) and we</span></span><br><span class="line">    <span class="comment">// want the pid to remain valid throughout that (and potentially future) usages.</span></span><br><span class="line">    <span class="comment">//最后，销毁这个子进程</span></span><br><span class="line">    <span class="keyword">auto</span> reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, <span class="literal">nullptr</span>, WNOHANG)); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wait_string;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class="line">        name = <span class="string">"Subcontext"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过pid获得service</span></span><br><span class="line">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!service) <span class="keyword">return</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理service后事</span></span><br><span class="line">    service-&gt;Reap(siginfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service-&gt;flags() &amp; SVC_TEMPORARY) &#123;</span><br><span class="line">        ServiceList::GetInstance().RemoveService(*service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="waitid函数"><a href="#waitid函数" class="headerlink" title="waitid函数"></a>waitid函数</h5><p>Linux函数，用于等待一个子进程状态的改变</p>
<p>原型：<code>int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/waitid.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/waitid.3p.html</a></p>
<p>第一个参数<code>idtype</code>：</p>
<ul>
<li>P_PID：等待的子进程的pid必须和参数id匹配</li>
<li>P_GID：等待的子进程的组id必须和参数id匹配</li>
<li>P_ADD：等待所有子进程，此时，参数id被忽略</li>
</ul>
<p>这个函数会将执行的结果保存在第三个参数infop中</p>
<p><code>options</code>：</p>
<ul>
<li>WCONTINUED：等待那些由SIGCONT重新启动的子进程</li>
<li>WEXITED：等待那些已经退出的子进程</li>
<li>WSTOPPED：等待那些被信号暂停的子进程</li>
<li>WNOHANG：非阻塞等待</li>
<li>WNOWAIT：保持返回的子进程处于可等待状态（后续可以再对这个子进程进行wait）</li>
</ul>
<p>回到<code>ReapOneProcess</code>函数中来，它先调用<code>waitid</code>函数，获得一个状态发生改变的子进程（options设置了<code>WEXITED</code>，即已退出的子进程），使用了<code>WNOWAIT</code>参数，也就是暂时先不销毁子进程，使用非阻塞的方式获取</p>
<p>ScopeGuard</p>
<p><code>ScopeGuard</code>的意思是，出作用域后，自动执行某段代码</p>
<p>函数中那段<code>make_scope_guard</code>的意思是，当这个函数执行完后，使用<code>waitpid</code>函数销毁子进程</p>
<p>之后会从<code>ServiceList</code>中通过pid去查找service，查到后调用<code>Service::Reap</code>处理后事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Service::Reap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当service的参数没有oneshot或者restart时，kill整个进程组</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        KillProcessGroup(SIGKILL, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Legacy behavior from ~2007 until Android R: this else branch did not exist and we did not</span></span><br><span class="line">        <span class="comment">// kill the process group in this case.</span></span><br><span class="line">        <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &gt;= __ANDROID_API_R__) &#123;</span><br><span class="line">            <span class="comment">// The new behavior in Android R is to kill these process groups in all cases.  The</span></span><br><span class="line">            <span class="comment">// 'true' parameter instructions KillProcessGroup() to report a warning message where it</span></span><br><span class="line">            <span class="comment">// detects a difference in behavior has occurred.</span></span><br><span class="line">            KillProcessGroup(SIGKILL, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any socket resources we may have created.</span></span><br><span class="line">    <span class="comment">//移除已创建的sockets</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; socket : sockets_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> path = ANDROID_SOCKET_DIR <span class="string">"/"</span> + socket.name;</span><br><span class="line">        unlink(path.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : reap_callbacks_) &#123;</span><br><span class="line">        f(siginfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果进程接收信号异常或被终止的状态异常，并且包含reboot_on_failure标志，重启系统</span></span><br><span class="line">    <span class="keyword">if</span> ((siginfo.si_code != CLD_EXITED || siginfo.si_status != <span class="number">0</span>) &amp;&amp; on_failure_reboot_target_) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Service with 'reboot_on_failure' option failed, shutting down system."</span>;</span><br><span class="line">        trigger_shutdown(*on_failure_reboot_target_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当service参数为exec时，释放相应服务资源</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_EXEC) UnSetExec();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_TEMPORARY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pid_ = <span class="number">0</span>;</span><br><span class="line">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line">    start_order_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Oneshot processes go into the disabled state on exit,</span></span><br><span class="line">    <span class="comment">// except when manually restarted.</span></span><br><span class="line">    <span class="comment">//当service参数有oneshot，没有restart和reset时，将service状态置为disable</span></span><br><span class="line">    <span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line">    <span class="comment">//禁用和重置的服务，都不能自动重启</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将标志置为重启中</span></span><br><span class="line">    flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">    flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line">    <span class="comment">//执行该service下的所有onrestart命令</span></span><br><span class="line">    onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">    NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service相关的参数可以去<code>system/core/init/README.md</code>中自行查看</p>
<p>这个函数检查了一堆service的标志和状态，判断如何处理这个service，如果需要重启，则调用<code>onrestart_.ExecuteAllCommands()</code>执行该service下的所有<code>onrestart</code>命令，具体的执行过程之前在启动服务那边已经分析过了，这里就不再往下看了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个init进程的启动过程最重要的部分基本都已分析完成，我也是一边从网上搜集资料一边对照着源码磕磕绊绊看过来的，有什么错误或者遗漏的部分欢迎指正，谢谢～</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/init%E8%BF%9B%E7%A8%8B/">init进程</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/10/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Zygote%E8%BF%9B%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Zygote进程</span></a></div><div class="next-post pull-right"><a href="/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/"><span>各厂商Android系统碰到的奇奇怪怪问题的记录</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>