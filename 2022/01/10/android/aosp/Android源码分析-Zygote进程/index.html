<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Zygote进程"><meta name="keywords" content="Android源码,Zygote"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Zygote进程 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍"><span class="toc-number">2.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#启动服务"><span class="toc-number">3.</span> <span class="toc-text">启动服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AndroidRuntime-start"><span class="toc-number">4.</span> <span class="toc-text">AndroidRuntime::start</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#启动JVM"><span class="toc-number">5.</span> <span class="toc-text">启动JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JniInvocation"><span class="toc-number">5.1.</span> <span class="toc-text">JniInvocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载libart-so库"><span class="toc-number">5.1.1.</span> <span class="toc-text">加载libart.so库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dlopen"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">dlopen</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从libart-so库中寻找函数地址"><span class="toc-number">5.1.2.</span> <span class="toc-text">从libart.so库中寻找函数地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dlsym"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">dlsym</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AndroidRuntime-startVm"><span class="toc-number">5.2.</span> <span class="toc-text">AndroidRuntime::startVm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注册JNI函数"><span class="toc-number">6.</span> <span class="toc-text">注册JNI函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#进入JAVA世界"><span class="toc-number">7.</span> <span class="toc-text">进入JAVA世界</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ZygoteInit"><span class="toc-number">8.</span> <span class="toc-text">ZygoteInit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#android-system-Os"><span class="toc-number">8.1.</span> <span class="toc-text">android.system.Os</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预加载"><span class="toc-number">8.2.</span> <span class="toc-text">预加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#preloadClasses"><span class="toc-number">8.2.1.</span> <span class="toc-text">preloadClasses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要预加载"><span class="toc-number">8.2.2.</span> <span class="toc-text">为什么需要预加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动binder线程池"><span class="toc-number">8.3.</span> <span class="toc-text">启动binder线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动SystemServer"><span class="toc-number">8.4.</span> <span class="toc-text">启动SystemServer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ZygoteServer"><span class="toc-number">9.</span> <span class="toc-text">ZygoteServer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-number">9.1.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runSelectLoop"><span class="toc-number">9.2.</span> <span class="toc-text">runSelectLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll"><span class="toc-number">9.2.1.</span> <span class="toc-text">poll</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StructPollfd-amp-pollfd"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">StructPollfd &amp; pollfd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调用"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建立连接"><span class="toc-number">9.2.2.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行client-socket命令"><span class="toc-number">9.2.3.</span> <span class="toc-text">执行client socket命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#启动APP进程"><span class="toc-number">10.</span> <span class="toc-text">启动APP进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">11.</span> <span class="toc-text">结束</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Zygote进程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7049277873877680142" target="_blank" rel="noopener">Android源码分析 - init进程</a>，我们分析了Android第一个用户进程init进程的启动过程和之后的守护服务</p>
<p>init进程启动了很多服务，例如Zygote，ServiceManager，MediaServer，SurfaceFlinger等，我们平常写Android应用都是使用Java语言，这次我们就先从Java世界的半边天：Zygote进程 开始分析</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Zygote意为受精卵，它有两大作用，一是启动SystemServer，二是孵化启动App</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>我们已经知道了init进程会从<code>init.rc</code>文件中解析并启动服务，那zygote是在哪定义的呢，<code>init.rc</code>的头几行就有一个import：<code>import /system/etc/init/hw/init.${ro.zygote}.rc</code></p>
<p>我们在init.rc同目录下就能找到几个对应的文件：<code>init.zygote32_64.rc</code> <code>init.zygote32.rc</code> <code>init.zygote64_32.rc</code> <code>init.zygote64.rc</code>，具体import哪个文件与具体设备硬件有关，现在64位手机这么普及了，我们就以<code>init.zygote64.rc</code>为目标分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p>下面的子项我们暂时不用关心，先记住<code>app_process64</code>的启动参数<code>-Xzygote /system/bin --zygote --start-system-server</code>即可</p>
<p>Zygote启动的源文件为<code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建了一个AppRuntime，继承自AndroidRuntime，重写了一些回调方法</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    <span class="comment">//在启动服务时，传进来的参数是包含文件路径的</span></span><br><span class="line">    <span class="comment">//我们不需要这个参数，就减一下个数，移一下指针</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理参数，这里只添加了一个-Xzygote参数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过参数/system/bin，这个参数目前没有被使用</span></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有--zygote参数</span></span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//ZYGOTE_NICE_NAME在64位下为zygote64，32位下为zygote</span></span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有-start-system-server参数</span></span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//这个分支不会进入Zygote模式</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        <span class="comment">//新建Dalvik缓存目录</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加启动参数</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="comment">//Zygote模式下没有其他参数了</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//设置程序名以及进程名</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//执行AndroidRuntime::start方法</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体结构还是比较简单的，就是处理一下参数，进入zygote对应的分支，执行AndroidRuntime::start方法，第一个参数传的是ZygoteInit在Java中的类名，第二个参数传了一些选项（start-system-server和abi-list），第三个参数传了true，代表启动虚拟机的时候需要额外添加一些JVM参数</p>
<h1 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime::start"></a>AndroidRuntime::start</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Whether this is the primary zygote, meaning the zygote which will fork system server.</span></span><br><span class="line">    <span class="comment">//64_32位兼容设备上会启动两个Zygote，一个叫zygote，一个叫zygote_secondary</span></span><br><span class="line">    <span class="keyword">bool</span> primary_zygote = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有start-system-server选项则代表是主Zygote</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查和配置一些环境变量</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    <span class="comment">//加载libart.so</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//启动JVM</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调AppRuntime中重写的方法</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//注册Android JNI函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断选项中是否携带参数start-system-server，如有，则将它视为主Zygote，接着就开始启动JVM了</p>
<h1 id="启动JVM"><a href="#启动JVM" class="headerlink" title="启动JVM"></a>启动JVM</h1><h2 id="JniInvocation"><a href="#JniInvocation" class="headerlink" title="JniInvocation"></a>JniInvocation</h2><p>使用JniInvocation初始化Android ART虚拟机环境，它的路径是<code>libnativehelper/include_platform/nativehelper/JniInvocation.h</code>，我们来看一下它是怎么做的</p>
<p>我们首先看一下它的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libnativehelper/include_platform/nativehelper/JniInvocation.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JniInvocation</span> <span class="title">final</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    JniInvocation() &#123;</span><br><span class="line">        impl_ = JniInvocationCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~JniInvocation() &#123;</span><br><span class="line">        JniInvocationDestroy(impl_);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>JniInvocationCreate</code>方法创建了一个JniInvocationImpl实例对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JniInvocationImpl* <span class="title">JniInvocationCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JniInvocationImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>JniInvocation::Init</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JniInvocationInit(impl_, library) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JniInvocationInit</span><span class="params">(JniInvocationImpl* instance, <span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;Init(library) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JniInvocation</code>实际上是个代理类，内部实现是交给<code>JniInvocationImpl</code>的，路径为<code>libnativehelper/JniInvocation.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//非debug一律为libart.so</span></span><br><span class="line">  library = GetLibrary(library, <span class="built_in">buffer</span>);</span><br><span class="line">  <span class="comment">//加载libart.so库</span></span><br><span class="line">  handle_ = OpenLibrary(library);</span><br><span class="line">  <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是加载libart.so库失败，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(library, kLibraryFallback) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Nothing else to try.</span></span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果是加载其他库失败，尝试回退加载libart.so库</span></span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    handle_ = OpenLibrary(library);</span><br><span class="line">    <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从libart.so库获得三个JVM相关的函数地址</span></span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_),</span><br><span class="line">                  <span class="string">"JNI_GetDefaultJavaVMInitArgs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_CreateJavaVM_),</span><br><span class="line">                  <span class="string">"JNI_CreateJavaVM"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetCreatedJavaVMs_),</span><br><span class="line">                  <span class="string">"JNI_GetCreatedJavaVMs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载libart-so库"><a href="#加载libart-so库" class="headerlink" title="加载libart.so库"></a>加载libart.so库</h3><p>我们先看<code>GetLibrary</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* kLibraryFallback = <span class="string">"libart.so"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">JniInvocationImpl::GetLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">char</span>* <span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">bool</span> (*is_debuggable)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> (*get_library_system_property)(<span class="keyword">char</span>* <span class="built_in">buffer</span>))</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ANDROID__</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_debuggable()) &#123;</span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    default_library = kLibraryFallback;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library = kLibraryFallback;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (library == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    library = default_library;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> library;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在debug模式或<code>library</code>参数为<code>NULL</code>的情况下都是直接返回的<code>libart.so</code></p>
<p>而<code>OpenLibrary</code>方法是使用了<code>dlopen</code>函数，加载<code>libart.so</code>库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">OpenLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> kDlopenFlags = RTLD_NOW | RTLD_NODELETE;</span><br><span class="line">  <span class="keyword">return</span> dlopen(filename, kDlopenFlags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen"></a>dlopen</h4><p>原型：<code>void *dlopen(const char *filename, int flags);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlopen.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlopen.3.html</a></p>
<p>这是一个Linux函数，用来加载一个动态链接库，当加载成功时，会返回一个句柄</p>
<p>上面的这两个参数，<code>RTLD_NOW</code>代表立即计算库的依赖性，<code>RTLD_NODELETE</code>代表不要再<code>dlclose</code>期间卸载库，这样当再次加载库的时候不会重新初始化对象的静态全局变量，使用这个flag是为了确保<code>libart.so</code>在关闭时不会被取消映射。因为即使在 <code>JNI_DeleteJavaVM</code> 调用之后，某些线程仍可能尚未完成退出，如果卸载该库，则可能导致段错误</p>
<h3 id="从libart-so库中寻找函数地址"><a href="#从libart-so库中寻找函数地址" class="headerlink" title="从libart.so库中寻找函数地址"></a>从libart.so库中寻找函数地址</h3><p>接着调用<code>FindSymbol</code>函数查找函数地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_POINTER void*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::FindSymbol</span><span class="params">(FUNC_POINTER* pointer, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得函数地址</span></span><br><span class="line">  *pointer = GetSymbol(handle_, symbol);</span><br><span class="line">  <span class="comment">//获取失败，卸载libart.so库</span></span><br><span class="line">  <span class="keyword">if</span> (*pointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Failed to find symbol %s: %s\n"</span>, symbol, GetError().c_str());</span><br><span class="line">    CloseLibrary(handle_);</span><br><span class="line">    handle_ = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FUNC_POINTER <span class="title">GetSymbol</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> dlsym(handle, symbol);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym"></a>dlsym</h4><p>原型：<code>void *dlsym(void *restrict handle , const char *restrict symbol);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlsym.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlsym.3.html</a></p>
<p>也是一个Linux函数，用来从已加载的动态链接库中获取一个函数的地址</p>
<p>传入的第一个参数为之前加载库时返回的句柄，第二个参数为函数名</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下全局，<code>JniInvocationImpl::Init</code>的作用是，加载<code>libart.so</code>库，并从中获取三个函数指针：</p>
<ul>
<li>JNI_GetDefaultJavaVMInitArgs：获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM：创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs：获取创建的虚拟机实例</li>
</ul>
<p>这几个函数被定义在<code>jni.h</code>中，后面我们创建JVM的时候会用到这些函数</p>
<h2 id="AndroidRuntime-startVm"><a href="#AndroidRuntime-startVm" class="headerlink" title="AndroidRuntime::startVm"></a>AndroidRuntime::startVm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote, <span class="keyword">bool</span> primary_zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaVMInitArgs initArgs;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//配置了一大堆JVM选项</span></span><br><span class="line">    </span><br><span class="line">    initArgs.version = JNI_VERSION_1_4;</span><br><span class="line">    initArgs.options = mOptions.editArray();</span><br><span class="line">    initArgs.nOptions = mOptions.<span class="built_in">size</span>();</span><br><span class="line">    initArgs.ignoreUnrecognized = JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并初始化JVM</span></span><br><span class="line">    <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JNI_CreateJavaVM failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JNI_CreateJavaVM</code>方法就是我们之前从<code>libart.so</code>里获得的方法，被编译进<code>libart.so</code>前，源码的路径为<code>art/runtime/jni/java_vm_ext.cc</code>，接下来属于ART虚拟机的工作，我们就不再往下深究了</p>
<p>后面有一个<code>onVmCreated</code>回调，但在zygote模式下没做任何事</p>
<h1 id="注册JNI函数"><a href="#注册JNI函数" class="headerlink" title="注册JNI函数"></a>注册JNI函数</h1><p>接着调用<code>startReg</code>函数注册Android JNI函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register android native functions with the VM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置Native创建线程的函数，通过javaCreateThreadEtc这个函数创建的线程</span></span><br><span class="line">    <span class="comment">//会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建局部引用栈帧</span></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册jni函数</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前栈帧出栈，释放其中所有局部引用</span></span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先hook了Native创建线程的函数，之后创建线程便会调用我们设置的<code>javaCreateThreadEtc</code>函数，<br>会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码。这个等之后看到Android线程创建的时候再分析</p>
<p><code>PushLocalFrame</code>和<code>PopLocalFrame</code>是一对函数，它们是用来管理JNI的局部引用的</p>
<p>首先，<code>PushLocalFrame</code>会创建出一个局部引用栈帧，之后JNI创建出来的局部引用都会放在这个栈帧里，等使用结束后调用PopLocalFrame函数，会将当前栈帧出栈，并且释放其中所有的局部引用</p>
<p>接下来我们看<code>register_jni_procs</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是循环执行<code>gRegJNI</code>数组中所有的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">        REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">        REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),</span><br><span class="line">        REG_JNI(register_android_os_SystemClock),</span><br><span class="line">        REG_JNI(register_android_util_EventLog),</span><br><span class="line">        REG_JNI(register_android_util_Log),</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>gRegJNI</code>数组中存放着很多Java类注册JNI函数的函数，后面大家如果阅读源码看到了Android中的native方法可以来这边找它所对应的c++实现</p>
<p>这边注册的类非常多，我们就取第一个<code>register_com_android_internal_os_RuntimeInit</code>为例分析一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="keyword">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">            &#123;<span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeFinishInit&#125;,</span><br><span class="line">            &#123;<span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">"com/android/internal/os/RuntimeInit"</span>,</span><br><span class="line">        methods, NELEM(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个JNINativeMethod结构体，第一个成员是Java中的方法名，第二个成员是Java中对应方法的签名，第三个成员是Java方法对应native函数的函数指针，然后调用<code>jniRegisterNativeMethods</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(C_JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Registering %s's %d native methods..."</span>, className, numMethods);</span><br><span class="line"></span><br><span class="line">    <span class="function">scoped_local_ref&lt;jclass&gt; <span class="title">c</span><span class="params">(env, findClass(env, className))</span></span>;</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(c.<span class="built_in">get</span>() == <span class="literal">NULL</span>,</span><br><span class="line">                         <span class="string">"Native registration unable to find class '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = e-&gt;RegisterNatives(c.<span class="built_in">get</span>(), gMethods, numMethods);</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"RegisterNatives failed for '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数先通过Java类名获得一个jclass对象，接着调用<code>JNIEnv::RegisterNatives</code>函数，这个函数定义在<code>jni.h</code>中，实现在<code>libart.so</code>库中，我们在平时开发jni的时候，动态注册native方法的时候就会使用到它，这里就不再往下分析了</p>
<h1 id="进入JAVA世界"><a href="#进入JAVA世界" class="headerlink" title="进入JAVA世界"></a>进入JAVA世界</h1><p>JVM启动好了，JNI函数也注册完毕了，接下来就该进入到JAVA世界了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看不懂的自己先补一下JNI知识，总之就是调用了<code>com.android.internal.os.ZygoteInit</code>类的静态方法<code>main</code>，以<code>com.android.internal.os.ZygoteInit</code>，<code>start-system-server</code>和<code>abi-list</code>作为参数</p>
<h1 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h1><p><code>ZygoteInit</code>类的源码路径为<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<p>我们这就开始分析它的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="comment">//标记着zygote开始启动，不允许创建线程（Zygote必须保证单线程）</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    <span class="comment">//设置进程组id</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//配置参数</span></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String zygoteSocketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public static final String PRIMARY_SOCKET_NAME = "zygote";</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//预加载</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Java层的垃圾回收</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//回调AppRRuntime中的onZygoteInit函数</span></span><br><span class="line">        Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除创建线程限制（马上就要执行fork了，子进程要有能力创建线程）</span></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动SystemServer</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        <span class="comment">//执行死循环监听socket，负责接收事件，启动App</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="comment">//接收到AMS的启动App请求后，fork出子进程，处理App启动</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ZygoteHooks.startZygoteNoThreadCreation()</code>禁止创建线程，Zygote必须保证单线程，这和<code>fork</code>机制有关，<code>fork</code>函数只会将当前线程复制到子进程，同时，<code>fork</code>会将锁也复制到子进程中，如果在<code>fork</code>之前，有一个线程持有了锁，但是<code>fork</code>的时候没把这个线程复制到子进程中，这把锁就被永久持有了，会造成死锁</p>
<h2 id="android-system-Os"><a href="#android-system-Os" class="headerlink" title="android.system.Os"></a>android.system.Os</h2><p>我们看一下<code>Os</code>是什么，根据import我们知道它的全限定类名为<code>android.system.Os</code>，它的源码路径为<code>libcore/luni/src/main/java/android/system/Os.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> libcore.io.Libcore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Os</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; Libcore.os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面全是这种形式的静态代理方法，实际调用<code>Libcore.os</code>执行，我们就以<code>setpgid</code>方法去追踪一下</p>
<p><code>Libcore</code>位于<code>libcore/luni/src/main/java/libcore/io/Libcore.java</code>，<code>os</code>是其中的一个静态变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Direct access to syscalls. Code should strongly prefer using &#123;<span class="doctag">@link</span> #os&#125;</span></span><br><span class="line"><span class="comment">     * unless it has a strong reason to bypass the helpful checks/guards that it</span></span><br><span class="line"><span class="comment">     * provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Access to syscalls with helpful checks/guards.</span></span><br><span class="line"><span class="comment">     * For read access only; the only supported way to update this field is via</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #compareAndSetOs&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Os <span class="title">getOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os</code>的类型为<code>BlockGuardOs</code>，以<code>Linux</code>类型的常量<code>rawOs</code>作为构造方法参数实例化，它继承自<code>ForwardingOs</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingOs</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Os os;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="meta">@libcore</span>.api.CorePlatformApi</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForwardingOs</span><span class="params">(Os os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.os = Objects.requireNonNull(os);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这其实又是一个代理类，实际上是直接调用了<code>Linux</code>类的方法，至于<code>BlockGuardOs</code>，它在部分方法上做了一些回调监听，除此之外也是直接调用了<code>Linux</code>类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    Linux() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">int</span> pid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面基本上都是JNI调用native方法，对应的c++源码路径为<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>，下面是注册JNI函数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE_METHOD(className, functionName, signature)                \</span></span><br><span class="line">  MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_JNI_NATIVE_METHOD(name, signature, function)                      \</span></span><br><span class="line">  _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \</span></span><br><span class="line">  MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \</span></span><br><span class="line">  ([]() &#123;                                                                \</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> nativehelper::detail;  <span class="comment">/* NOLINT(google-build-using-namespace) */</span> \</span><br><span class="line">    <span class="keyword">static_assert</span>(                                                       \</span><br><span class="line">        MatchJniDescriptorWithFunctionType&lt;native_kind,                  \</span><br><span class="line">                                           <span class="keyword">decltype</span>(fn),                 \</span><br><span class="line">                                           fn,                           \</span><br><span class="line">                                           <span class="keyword">sizeof</span>(signature_)&gt;(signature_),\</span><br><span class="line">        <span class="string">"JNI signature doesn't match C++ function type."</span>);               \</span><br><span class="line">    <span class="comment">/* Suppress implicit cast warnings by explicitly casting. */</span>         \</span><br><span class="line">    <span class="keyword">return</span> JNINativeMethod &#123;                                             \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::name)&gt;(name_),              \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::signature)&gt;(signature_),    \</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;(fn))&#125;;                                 \</span><br><span class="line">  &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    NATIVE_METHOD(Linux, setpgid, <span class="string">"(II)V"</span>),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_libcore_io_Linux</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jniRegisterNativeMethods(env, <span class="string">"libcore/io/Linux"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Java层方法对应native方法的格式为<code>Linux_方法名</code>，我们通过这种规则找到<code>setpgid</code>方法对应的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Linux_setpgid</span><span class="params">(JNIEnv* env, jobject, jint pid, <span class="keyword">int</span> pgid)</span> </span>&#123;</span><br><span class="line">    throwIfMinusOne(env, <span class="string">"setpgid"</span>, TEMP_FAILURE_RETRY(setpgid(pid, pgid)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是直接调用了Linux系统层函数</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>综上所述，<code>android.system.Os</code>类存在的意义是可以使Java层能够方便的调用Linux系统方法</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>接下来就是一些参数配置工作，然后调用<code>preload</code>预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载Java类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//加载三个jar文件</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.base-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.manager-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.test.base.jar */</span></span><br><span class="line">    cacheNonBootClasspathClassLoaders();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载系统资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载硬件抽象层？</span></span><br><span class="line">    nativePreloadAppProcessHALs();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载opengl</span></span><br><span class="line">    maybePreloadGraphicsDriver();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载动态库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    <span class="comment">//TextView预加载Font</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line">    <span class="comment">//预加载webviewchromium</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preloadClasses"><a href="#preloadClasses" class="headerlink" title="preloadClasses"></a>preloadClasses</h3><p>我们看看Java类的预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRELOADED_CLASSES = <span class="string">"/system/etc/preloaded-classes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(PRELOADED_CLASSES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Couldn't find "</span> + PRELOADED_CLASSES + <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">            line = line.trim();</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//Java类加载器加载类</span></span><br><span class="line">            Class.forName(line, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            count++;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"...preloaded "</span> + count + <span class="string">" classes in "</span></span><br><span class="line">                + (SystemClock.uptimeMillis() - startTime) + <span class="string">"ms."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error reading "</span> + PRELOADED_CLASSES + <span class="string">"."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的代码就是从<code>/system/etc/preloaded-classes</code>这个文件中读取出需要预加载的类，再通过<code>Class.forName</code>使用类加载器加载一遍，编译前的路径为<code>frameworks/base/config/preloaded-classes</code></p>
<h3 id="为什么需要预加载"><a href="#为什么需要预加载" class="headerlink" title="为什么需要预加载"></a>为什么需要预加载</h3><p>Zygote进程的一大作用就是孵化App，那是怎么孵化的呢？这过程中肯定要使用到<code>fork</code>，我们知道，<code>fork</code>后，父子进程是可以共享资源的，既然我们每启动一个App，都需要使用虚拟机、加载一些View等必要的类等等，那为何不在父进程中加载好这些，fork后子进程不就可以直接使用它们了吗？这就是Zygote进程预加载的原因</p>
<h2 id="启动binder线程池"><a href="#启动binder线程池" class="headerlink" title="启动binder线程池"></a>启动binder线程池</h2><p>预加载结束后，会先清理一下Java层的垃圾，然后调用<code>Zygote.initNativeState(isPrimaryZygote)</code>方法，这个方法调用了native方法<code>nativeInitNativeState</code>，这个方法是在<code>AndroidRuntime</code>中注册的，同时也实现在<code>AndroidRuntime</code>中，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前分析过，执行的是<code>AndroidRuntime</code>的子类<code>AppRuntime</code>的<code>onZygoteInit</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数启动Binder线程池，至于Binder的细节，我们留到以后再分析</p>
<h2 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h2><p><code>Zygote</code>进程孵化的第一个进程便是<code>SystemServer</code>，具体怎么孵化的，孵化后SystemServer又做了什么，留在下一节我们再分析</p>
<h1 id="ZygoteServer"><a href="#ZygoteServer" class="headerlink" title="ZygoteServer"></a>ZygoteServer</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们知道，我们App都是从<code>Zygote</code>孵化而来的，App启动是从<code>ActivityManagerService</code>的<code>startActivity</code>方法开始的，那么AMS是怎么和Zygote通信的呢，答案是通过socket</p>
<p>我们先从ZygoteServer的构造方法开始看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZygoteServer(<span class="keyword">boolean</span> isPrimaryZygote) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一些东西是和USAP机制有关的，但在AOSP中默认是关闭的，关于USAP机制我们以后再分析，现在只需要关注<code>mZygoteSocket</code>就可以了，它是通过调用<code>Zygote.createManagedSocketFromInitSocket</code>赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalServerSocket <span class="title">createManagedSocketFromInitSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fileDesc;</span><br><span class="line">    <span class="comment">//ANDROID_SOCKET_zygote</span></span><br><span class="line">    <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得文件描述符</span></span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Socket unset or invalid: "</span> + fullSocketName, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.setInt$(fileDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Error building socket from file descriptor: "</span> + fileDesc, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是从系统属性中获取一个fd，然后实例化<code>LocalServerSocket</code>，路径为<code>frameworks/base/core/java/android/net/LocalServerSocket.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LocalServerSocket</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    impl = <span class="keyword">new</span> LocalSocketImpl(fd);</span><br><span class="line">    impl.listen(LISTEN_BACKLOG);</span><br><span class="line">    localAddress = impl.getSockAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部创建了一个<code>LocalSocketImpl</code>，然后调用了<code>listen</code>方法声明开始监听这个fd，内部调用了Linux的<code>listen</code>函数</p>
<h2 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h2><p>然后我们来看在<code>ZygoteInit</code>中调用的<code>runSelectLoop</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; socketFDs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将server socket fd加到列表头（后面需要判断是否为server socket）</span></span><br><span class="line">    socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        StructPollfd[] pollFDs;</span><br><span class="line">        ...</span><br><span class="line">        pollFDs = <span class="keyword">new</span> StructPollfd[socketFDs.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pollIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class="line">            pollFDs[pollIndex] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFDs[pollIndex].fd = socketFD;</span><br><span class="line">            pollFDs[pollIndex].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            ++pollIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//上面一大段都与USAP机制有关，这里先不关注</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pollReturnValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待文件描述符上的事件</span></span><br><span class="line">            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollReturnValue == <span class="number">0</span>) &#123; <span class="comment">//没有接收到事件（超时），从循环开头重新开始等待事件</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有要读取的数据，跳过</span></span><br><span class="line">                <span class="keyword">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pollIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//pollIndex == 0说明这个fd是ZygoteServer socket的fd</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//接受并建立一个socket连接</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    <span class="comment">//将client socket fd加入列表</span></span><br><span class="line">                    socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class="line">                    <span class="comment">//不使用USAP机制的话，pollIndex &lt; usapPoolEventFDIndex条件一定成立</span></span><br><span class="line">                    <span class="comment">//进入这边说明是client socket</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//内部执行fork，返回一个待执行Runnable用于处理子进程后续任务</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(pollIndex);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//fork后，在子进程中会将这个变量设为true</span></span><br><span class="line">                        <span class="keyword">if</span> (mIsForkChild) &#123; <span class="comment">//子进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//return出去，由ZygoteInit执行这个Runnable</span></span><br><span class="line">                            <span class="keyword">return</span> command;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//读取完了，关闭这个socket，清理列表</span></span><br><span class="line">                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                                connection.closeSocket();</span><br><span class="line">                                peers.remove(pollIndex);</span><br><span class="line">                                socketFDs.remove(pollIndex);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ... <span class="comment">//不开启USAP机制不会走到这个分支</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个列表，<code>socketFDs</code>和<code>peers</code>的下标是一一对应的，首先将server socket fd添加到列表头，方便后续判断事件是来自client或是server socker，<code>peers</code>列表也要添加一个<code>null</code>作为<code>socketFDs</code>的对应</p>
<p>接着就开始执行死循环，<code>Zygote</code>进程永远不会退出这个循环，只有<code>fork</code>出子进程后，子进程会主动return</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>为了理解后面的内容，我们先要学习一下poll函数</p>
<p>poll是Linux中的字符设备驱动中的一个函数，它的作用是等待文件描述符上的某个事件</p>
<p>原型：<code>int poll(struct pollfd * fds , nfds_t nfds , int timeout );</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/poll.2.html</a></p>
<p>第一个参数是一个<code>pollfd</code>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fd不用多说，就是文件描述符</li>
<li>event代表关注哪些事件，<code>POLLIN</code>代表可读，<code>POLLOUT</code>代表可写等等</li>
<li>revents是由内核通知的，函数返回的时候，会设置对应的fd实际发生的事件，比如fd有可读的事件，设置<code>POLLIN</code></li>
</ul>
<p>第二个参数<code>nfds</code>表示fd的个数，即<code>pollfd</code>数组的size</p>
<p>第三个参数表示超时时间</p>
<p>返回值：</p>
<ul>
<li>大于0：表示有fd事件产生，值为有产生事件的fd的个数</li>
<li>等于0：表示超时</li>
<li>小于0：表示有错误产生</li>
</ul>
<h4 id="StructPollfd-amp-pollfd"><a href="#StructPollfd-amp-pollfd" class="headerlink" title="StructPollfd &amp; pollfd"></a>StructPollfd &amp; pollfd</h4><p>弄懂poll是干嘛的后，我们再来接着看<code>runSelectLoop</code>方法</p>
<p>死循环中首先创建了一个<code>StructPollfd</code>数组，它根据<code>socketFDs</code>依次创建出一个个<code>StructPollfd</code>对象，并将他们的事件都设为<code>POLLIN</code>可读</p>
<p><code>StructPollfd</code>和c中的结构体<code>pollfd</code>是对应的，目的是为了方便Java层调用Linux的<code>poll</code>函数</p>
<p><code>StructPollfd</code>的路径为<code>libcore/luni/src/main/java/android/system/StructPollfd.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StructPollfd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> FileDescriptor fd;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> events;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> revents;</span><br><span class="line">    <span class="keyword">public</span> Object userData;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>然后调用<code>Os.poll</code>方法</p>
<p>关于<code>Os</code>我们上面刚分析过，知道他调用了JNI函数，native函数命名格式为<code>Linux_函数名</code>，我们去<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>中找一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Linux_poll</span><span class="params">(JNIEnv* env, jobject, jobjectArray javaStructs, jint timeoutMs)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//把Java对象StructPollfd数组转换成c中的struct pollfd数组</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        rc = poll(fds.get(), count, timeoutMs);</span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= <span class="number">0</span> || errno != EINTR) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">        throwErrnoException(env, <span class="string">"poll"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//设置Java对象StructPollfd的revents值</span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看一下，就是把传进去的<code>StructPollfd</code>数组转换成了<code>struct pollfd</code>数组，然后调用Linux <code>poll</code>函数，再把<code>revents</code>写进<code>StructPollfd</code>对象中，最后返回</p>
<p>再看回<code>runSelectLoop</code>方法，如果poll执行返回值为-1，会直接引发一个Java异常，其他情况先判断一下<code>poll</code>的返回值，如果为0，则没有事件产生，否则会从后向前依次判断<code>pollFDs</code>的<code>revents</code>，如果为<code>POLLIN</code>可读，则处理，不可读则跳过</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>我们先看第一次<code>poll</code>到事件的情况，这时候，<code>pollFDs</code>中只有一个zygote socket fd，收到可读事件，说明有客户端socket向zygote socket请求发起连接，这时候我们调用<code>acceptCommandPeer</code>方法建立新连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createNewConnection(mZygoteSocket.accept(), abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>mZygoteSocket.accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalSocket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LocalSocketImpl acceptedImpl = <span class="keyword">new</span> LocalSocketImpl();</span><br><span class="line"></span><br><span class="line">    impl.accept(acceptedImpl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LocalSocket.createLocalSocketForAccept(acceptedImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个<code>LocalSocketImpl</code>(client socket) 实例，然后调用<code>LocalSocketImpl</code>(zygote socket) 的<code>accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(LocalSocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"socket not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s.fd = Os.accept(fd, <span class="keyword">null</span> <span class="comment">/* address */</span>);</span><br><span class="line">        s.mFdCreatedInternally = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsIOException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了Linux的accept函数，接受建立连接，并返回了一个新的client socket fd，将<code>LocalSocketImpl</code>中的fd变量设置为这个fd，接着调用<code>LocalSocket.createLocalSocketForAccept</code>将<code>LocalSocketImpl</code>包装成<code>LocalSocket</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalSocket <span class="title">createLocalSocketForAccept</span><span class="params">(LocalSocketImpl impl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createConnectedLocalSocket(impl, SOCKET_UNKNOWN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LocalSocket <span class="title">createConnectedLocalSocket</span><span class="params">(LocalSocketImpl impl, <span class="keyword">int</span> sockType)</span> </span>&#123;</span><br><span class="line">    LocalSocket socket = <span class="keyword">new</span> LocalSocket(impl, sockType);</span><br><span class="line">    socket.isConnected = <span class="keyword">true</span>;</span><br><span class="line">    socket.isBound = <span class="keyword">true</span>;</span><br><span class="line">    socket.implCreated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用这个<code>LocalSocket</code>创建了一个<code>ZygoteConnection</code>包装socket连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ZygoteConnection <span class="title">createNewConnection</span><span class="params">(LocalSocket socket, String abiList)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(socket, abiList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下构造方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZygoteConnection(LocalSocket socket, String abiList) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    mSocket = socket;</span><br><span class="line">    <span class="keyword">this</span>.abiList = abiList;</span><br><span class="line"></span><br><span class="line">    mSocketOutStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">    mSocketReader =</span><br><span class="line">            <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream()), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line">    ...</span><br><span class="line">    isEof = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开了client socket的输入输出流，准备读写数据了</p>
<p>然后将这个连接和fd分别添加进<code>peers</code>和<code>socketFDs</code></p>
<h3 id="执行client-socket命令"><a href="#执行client-socket命令" class="headerlink" title="执行client socket命令"></a>执行client socket命令</h3><p>在第二次循环中<code>pollFDs</code>数组中便包括了新建立连接的client socket了，这时调用<code>Os.poll</code>，可以获得到这个client socket的可读事件，此时调用<code>connection.processOneCommand</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取从client socket传来的参数</span></span><br><span class="line">        args = Zygote.readArgumentList(mSocketReader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"IOException on command socket"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    ZygoteArguments parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//一系列参数校验工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,</span><br><span class="line">            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,</span><br><span class="line">            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,</span><br><span class="line">            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp,</span><br><span class="line">            parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList,</span><br><span class="line">            parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程中</span></span><br><span class="line">            <span class="comment">//设置mIsForkChild = true</span></span><br><span class="line">            zygoteServer.setForkChild();</span><br><span class="line">            <span class="comment">//子进程中关闭fork复制来的zygote socket</span></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleParentProc(pid, serverPipeFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动APP进程"><a href="#启动APP进程" class="headerlink" title="启动APP进程"></a>启动APP进程</h1><p>首先读取从client socket传来的参数，然后校验这些参数，完毕后调用<code>Zygote.forkAndSpecialize</code>方法fork出子进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] fdsToIgnore, <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isTopApp, String[] pkgDataInfoList, String[] whitelistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> bindMountAppDataDirs, <span class="keyword">boolean</span> bindMountAppStorageDirs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止其他线程</span></span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fork进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, whitelistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//恢复其他线程</span></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程启动了4个线程：</p>
<ul>
<li>HeapTaskDaemon</li>
<li>ReferenceQueueDaemon</li>
<li>FinalizerDaemon</li>
<li>FinalizerWatchdogDaemon</li>
</ul>
<p>之前上面也分析过了多线程对fork会产生影响，所以这里先把其他线程停了，等fork完了再重新启动</p>
<p>然后执行native函数<code>nativeForkAndSpecialize</code>，路径为<code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint mount_external, jstring se_info, jstring nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring instruction_set, jstring app_data_dir, jboolean is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean mount_data_dirs, jboolean mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">false</span>, fds_to_close, fds_to_ignore, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       capabilities, capabilities,</span><br><span class="line">                       mount_external, se_info, nice_name, <span class="literal">false</span>,</span><br><span class="line">                       is_child_zygote == JNI_TRUE, instruction_set, app_data_dir,</span><br><span class="line">                       is_top_app == JNI_TRUE, pkg_data_info_list,</span><br><span class="line">                       whitelisted_data_info_list,</span><br><span class="line">                       mount_data_dirs == JNI_TRUE,</span><br><span class="line">                       mount_storage_dirs == JNI_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ForkCommon</code>，再在子进程调用<code>SpecializeCommon</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkCommon</span><span class="params">(JNIEnv* env, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_close,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_ignore,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> is_priority_fork)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程信号处理函数</span></span><br><span class="line">  SetSignalHandlers();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//fork前先阻塞SIGCHLD信号</span></span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//执行fork</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//恢复SIGCHLD信号</span></span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong permitted_capabilities, jlong effective_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint mount_external, jstring managed_se_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_nice_name, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> is_child_zygote, jstring managed_instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_app_data_dir, <span class="keyword">bool</span> is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> mount_data_dirs, <span class="keyword">bool</span> mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建进程组</span></span><br><span class="line">  <span class="keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">      ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, <span class="comment">/* pid= */</span> <span class="number">0</span>, strerror(-rc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置GroupId</span></span><br><span class="line">  SetGids(env, gids, is_child_zygote, fail_fn);</span><br><span class="line">  <span class="comment">//设置资源Limit</span></span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置调度策略</span></span><br><span class="line">  SetSchedulerPolicy(fail_fn, is_top_app);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置线程名</span></span><br><span class="line">  <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">    SetThreadName(<span class="string">"system_server"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子进程中不再处理SIGCHLD信号</span></span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_child_zygote) &#123;</span><br><span class="line">      initUnsolSocketToSystemServer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用Zygote.callPostForkChildHooks方法</span></span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认进程优先级</span></span><br><span class="line">  setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程创建完成后，<code>ZygoteConnection</code>在子进程中会返回<code>handleChildProc</code>，在父进程中会返回<code>null</code></p>
<p>在<code>ZygoteServer</code>中做了判断，如果为子进程且command不为null，返回common到<code>ZygoteInit</code>，如果是父进程，继续socket poll循环</p>
<p>在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>（对应<code>ZygoteServer</code>中的<code>command</code>）不为<code>null</code>，则执行这个<code>Runnable</code></p>
<p>我们看一下<code>handleChildProc</code>做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(ZygoteArguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在子进程中关闭发起启动App请求的client socket</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    Zygote.setAppProcessName(parsedArgs, TAG);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//和进程内存泄露或溢出有关？</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.mRemainingArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should not get here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"WrapperInit.execApplication unexpectedly returned"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">            <span class="comment">//根据参数，执行这个方法</span></span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>ZygoteInit.zygoteInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//重定向Log</span></span><br><span class="line">    RuntimeInit.redirectLogStreams();</span><br><span class="line">    <span class="comment">//通用初始化</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    <span class="comment">//之前有提到，开启binder线程池</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">            classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RuntimeInit</code>的路径为<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>，先执行通用初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置默认线程异常处理器</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="string">"persist.sys.timezone"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置Log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置网络UA信息</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    ...</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>RuntimeInit.applicationInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置虚拟机参数</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查找startClass中的main方法</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的startClass为<code>android.app.ActivityThread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Java中的反射，找到了<code>ActivityThread</code>中对应的<code>main</code>方法，并用其创建了一个<code>Runnable</code>对象<code>MethodAndArgsCaller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行ActivityThread.main方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说了，在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>不为<code>null</code>，则执行这个<code>Runnable</code>，即执行<code>MethodAndArgsCaller</code>的<code>run</code>方法，反射调用<code>ActivityThread.main</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，Zygote进程部分的分析就到此为止了，后面fork出App进程那段讲的很粗糙，后面写到App启动那块的时候，我会重新梳理一遍这里的逻辑，补充上去</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/Zygote/">Zygote</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/01/14/linux/LinuxCapabilities%E6%9C%BA%E5%88%B6/"><i class="fa fa-chevron-left">  </i><span>Linux Capabilities机制</span></a></div><div class="next-post pull-right"><a href="/2022/01/04/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-init%E8%BF%9B%E7%A8%8B/"><span>Android源码分析 - init进程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>