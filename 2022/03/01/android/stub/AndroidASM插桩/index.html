<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android ASM插桩"><meta name="keywords" content="插桩"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android ASM插桩 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工具"><span class="toc-number">2.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字节码"><span class="toc-number">3.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android打包过程"><span class="toc-number">4.</span> <span class="toc-text">Android打包过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android插桩过程"><span class="toc-number">5.</span> <span class="toc-text">Android插桩过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#实战"><span class="toc-number">6.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#新建插件工程"><span class="toc-number">6.1.</span> <span class="toc-text">新建插件工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为插件提供可配置的功能"><span class="toc-number">6.2.</span> <span class="toc-text">为插件提供可配置的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Transform-Api"><span class="toc-number">6.3.</span> <span class="toc-text">使用Transform Api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义ClassVisitor"><span class="toc-number">6.4.</span> <span class="toc-text">自定义ClassVisitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取配置"><span class="toc-number">6.4.1.</span> <span class="toc-text">读取配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问类"><span class="toc-number">6.4.2.</span> <span class="toc-text">访问类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问类内方法"><span class="toc-number">6.4.3.</span> <span class="toc-text">访问类内方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入成员变量"><span class="toc-number">6.4.4.</span> <span class="toc-text">插入成员变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义MethodVisitor"><span class="toc-number">6.5.</span> <span class="toc-text">自定义MethodVisitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在方法执行之前插入代码"><span class="toc-number">6.5.1.</span> <span class="toc-text">在方法执行之前插入代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在方法return之前插入代码"><span class="toc-number">6.5.2.</span> <span class="toc-text">在方法return之前插入代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行"><span class="toc-number">6.6.</span> <span class="toc-text">运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number">7.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android ASM插桩</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%8F%92%E6%A1%A9/">插桩</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ASM插桩在网上其实已经有很多资料了，我之所以再写这篇文章呢，一是因为好久前学习的ASM，现在已经忘的差不多了，需要再回顾一下，二来是记录一下学习过程，以后如果再有细节记不清楚可以很方便的就能查到，三来再学习的过程中也踩了一些坑，收获了一些心得，这些也需要一个地方记录一下。</p>
<p>好了，废话就说到这里，接下来开始正文。</p>
<p>插桩技术指在保证原有程序逻辑完整性的基础上，在程序中插入探针，通过探针采集代码中的信息（方法本身、方法参数值、返回值等）在特定的位置插入代码段，从而收集程序运行时的动态上下文信息。</p>
<p>插桩技术大体可以分为两类：</p>
<ul>
<li><p><code>APT</code>（Annotation Process Tools），在编译的时候，动态生成 <code>Java</code> 文件，之后编译器将生成的 <code>Java</code> 文件编译成 <code>class</code> 文件，像 <code>ButterKnife</code>、<code>Dagger</code> 就是通过 <code>APT</code> 的方式生成代码的。</p>
<ul>
<li>代表工具：<code>ButterKnife</code></li>
</ul>
</li>
<li><p><code>AOP</code>（Aspect Oriented Programming），生成 <code>class</code> 文件后，修改 <code>class</code> 文件的字节码，达到修改代码的目的。</p>
<ul>
<li>代表工具：听云</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>我们这次选用<code>AOP</code>技术，我们看看有哪些工具可以帮助我们完成插桩工作：</p>
<ul>
<li><p><code>AspectJ</code>，成熟稳定，使用者不需要对字节码文件有深入的理解，使用简单。但是其切入点相对固定，对于字节码文件的操作自由度以及开发的掌控度就大打折扣。并且，他会额外生成一些包装代码，对性能以及包大小有一定影响。</p>
</li>
<li><p><code>ASM</code>，可以修改现有的字节码文件，也可以动态生成字节码文件，完全从字节码去操作字节码的框架，更加灵活，功能更加强大，可以根据需求自定义修改、插入、删除，性能也十分出色，但是要对字节码文件有比较深入的了解，上手也更难。</p>
</li>
</ul>
<p>我们使用<code>ASM</code>来完成插桩，在介绍<code>Android</code>字节码插桩之前，需要先了解一下<code>Java</code>字节码的概念和<code>Android</code>程序打包过程。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>我们知道，<code>Java</code>程序是运行在<code>JVM</code>（<code>Java</code>虚拟机）上的，<code>Java</code>源代码首先会由编译器（<code>Java Compiler</code>）编译成包含了<code>Bytecode</code>（字节码）的<code>.class</code>文件，程序执行时，由类加载器(<code>class loader</code>)将该类的字节码加载到<code>JVM</code>中，<code>JVM</code>会解释执行相应的<code>Bytecode</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="Java编译执行过程"></p>
<p>为什么不直接彻底编译成机器码，而需要字节码这个中间产物呢？<code>Java</code>是一门跨平台的语言，为了实现一份源码，处处运行的效果，每个平台都有对应不同的<code>JVM</code>，它会将源码对应的指令翻译成对应平台能够理解的机器指令。那为什么不从源码直接解释执行呢，我个人认为这是因为直接从源码开始的编译，速度非常慢，出于性能的考虑，先将源码做一些预处理，处理为字节码，来减轻运行前的编译的性能开销。</p>
<p>在做插桩之前，我们先要记住一点：<code>Java</code> 字节码指令是基于堆栈操作的，因为大部分的<code>Java</code>虚拟机对字节码的执行是基于堆栈的（<code>Android</code>的<code>Dalvik</code>虚拟机是基于寄存器的，不过不影响我们的插桩，因为在我们对<code>java</code>字节码插完桩后，才会执行从<code>java</code>字节码转换到<code>dex</code>文件的过程）</p>
<h1 id="Android打包过程"><a href="#Android打包过程" class="headerlink" title="Android打包过程"></a>Android打包过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B.png" alt="Android打包过程"></p>
<h1 id="Android插桩过程"><a href="#Android插桩过程" class="headerlink" title="Android插桩过程"></a>Android插桩过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B.png" alt="Android插桩点"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B2.png" alt="Android插桩点"></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>这次，我们模仿听云，做一个<code>Activity</code>生命周期执行时间检测的插件。</p>
<p>我们先梳理一下功能点：</p>
<ol>
<li>针对<code>Activity</code>类</li>
<li>针对生命周期方法</li>
<li>支持插件自定义配置</li>
</ol>
<p>我们用<code>Java</code>代码把我们想要插入的逻辑写一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里取这个名字是为了防止和代码本身的成员变量产生冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> _$_timeRecorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向实际代码前插入代码</span></span><br><span class="line">	_$_timeRecorder = -System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">	... <span class="comment">//这里是实际代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向实际代码后插入代码</span></span><br><span class="line">	_$_timeRecorder += System.currentTimeMillis();</span><br><span class="line">	System.err.println(<span class="string">"Time spent: "</span> + _$_timeRecorder + <span class="string">"ms, when "</span> + className + <span class="string">".onCreate"</span>);</span><br><span class="line">	StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">	<span class="keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;</span><br><span class="line">		System.err.println(element.getClassName() + <span class="string">"."</span> + element.getMethodName() + <span class="string">":"</span> + element.getLineNumber());</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来正式开始编写插件</p>
<h2 id="新建插件工程"><a href="#新建插件工程" class="headerlink" title="新建插件工程"></a>新建插件工程</h2><p>由于<code>Android Studio</code>没有新建<code>gradle</code>脚本的选项，我们先新建一个<code>Empty Activity Project</code>，在此基础上进行改造。</p>
<ol>
<li>新建<code>module</code></li>
<li>更改<code>module</code>的<code>build.gradle</code>文件</li>
<li>新建<code>groovy</code>源代码目录</li>
<li>新建<code>groovy</code>类实现<code>Plugin&lt;Project&gt;</code>接口</li>
<li>新建<code>resource/META_INF/xxx.properites</code>文件（xxx为插件的id名）</li>
<li>在<code>properites</code>文件中声明插件的实现类</li>
</ol>
<h2 id="为插件提供可配置的功能"><a href="#为插件提供可配置的功能" class="headerlink" title="为插件提供可配置的功能"></a>为插件提供可配置的功能</h2><ol>
<li>新建一个实体类用来保存配置信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsmConfigModel</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以此参数为开头的类（全限定类名）才插桩</span></span><br><span class="line"><span class="comment">	 * 如果不配此参数则代表所有类都可插桩</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; startWithPatterns;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; excludes;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 * 以文件形式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> File excludesByFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在插件<code>apply</code>的时候创建这个配置类，以提供给使用者配置</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    mConfig = project.extensions.create(<span class="string">"asmConfig"</span>, AsmConfigModel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在使用该插件的<code>module</code>下的<code>build.gradle</code>文件中配置</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmConfig &#123;</span><br><span class="line">    startWithPatterns = [<span class="string">'com.shanbay'</span>]</span><br><span class="line">    excludesByFile = <span class="keyword">new</span> <span class="keyword">File</span>(projectDir, <span class="string">"asm-excludes.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新建asm-excludes.txt文件，配置exclude信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;xxx&#x2F;xxx&#x2F;BaseActivity</span><br></pre></td></tr></table></figure>

<p>这里是举个例子，在工程中很有可能有的<code>Activity</code>继承自一些基类<code>Activity</code>，对这些类插桩就重复了</p>
<h2 id="使用Transform-Api"><a href="#使用Transform-Api" class="headerlink" title="使用Transform Api"></a>使用Transform Api</h2><p>根据<a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">官网</a>介绍，<code>Transform Api</code>允许第三方 <code>Plugin</code> 在打包 <code>dex</code> 文件之前的编译过程中操作<code>.class</code> 文件，下图是<code>Transform Api</code>的工作流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E8%BF%87%E7%A8%8B.png" alt="Transform Api工作流程"></p>
<p>可以看到，一次<code>App</code>的编译打包可能会经历多次<code>Transform</code>，<code>Transform</code>将输入进行处理，然后写入到指定的目录下作为下一个 <code>Transform</code> 的输入源。</p>
<p>使用插桩工具，我们需要借助于<code>Transform Api</code>实现</p>
<ol>
<li>首先，我们需要让我们的插件继承自<code>Transform</code></li>
<li>然后，我们要在插件<code>apply</code>时注册<code>Transform</code></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    <span class="keyword">def</span> android = project.extensions.getByType(AppExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">android</span>.<span class="title">registerTransform</span>(<span class="title">this</span>)</span></span><br><span class="line"><span class="class">    <span class="title">mConfig</span> = <span class="title">project</span>.<span class="title">extensions</span>.<span class="title">create</span>("<span class="title">asmConfig</span>", <span class="title">AsmConfigModel</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最后，需要实现<code>Transform</code>类中的抽象方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E7%B1%BB.png" alt="Transform抽象方法"></p>
<ul>
<li><code>getName</code> 这个方法是指定这个<code>Transform</code>的名称</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">String getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'AsmPlugin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getInputTypes</code> 这个方法是指定输入类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes.png" alt="Transform输入类型"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes2.png" alt="Transform输入类型"></p>
<p>这里，我们选用<code>TransformManager.CONTENT_CLASS</code>就可以了</p>
<ul>
<li><code>getScopes</code> 这个方法是指定插桩的作用域</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes.png" alt="Transform作用域"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes2.png" alt="Transform作用域"></p>
<p>这里我们选择<code>TransformManager.SCOPE_FULL_PROJECT</code>，代表插桩范围包括此工程和它依赖的所有包</p>
<ul>
<li><code>isIncremental</code> 这个方法代表是否开启增量编译</li>
</ul>
<p>如果开启的话可以减少编译时间，但需要增加额外的判断条件，所以这里就先不开启了</p>
<ul>
<li><code>transform</code> 这个方法是核心方法，我们要对输入内容进行处理然后输出</li>
</ul>
<p><code>transform()</code>方法的参数 <code>TransformInvocation</code> 是一个接口，提供了一些关于输入输出的一些基本信息。下图是<code>transform</code>中我们需要走的流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_transform%E6%B5%81%E7%A8%8B.png" alt="Transform流程"></p>
<p>这里以<code>directoryInputs</code>举例，<code>directoryInputs</code>就是本地源码编译后产生的<code>class</code>文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> handleDirectory(DirectoryInput input, TransformOutputProvider outputProvider) &#123;</span><br><span class="line">    File file = input.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">//递归遍历该文件夹下面所有的子文件夹以及子文件</span></span><br><span class="line">        file.eachFileRecurse &#123; subFile -&gt;</span><br><span class="line">            <span class="keyword">def</span> fileName = subFile.name</span><br><span class="line">            <span class="comment">//初步判断这个文件（或文件夹）是否可插桩</span></span><br><span class="line">            <span class="keyword">if</span> (fileName.endsWith(<span class="string">".class"</span>) &amp;&amp; !fileName.startsWith(<span class="string">"R$"</span>)</span><br><span class="line">                    &amp;&amp; <span class="string">"R.class"</span> != fileName &amp;&amp; <span class="string">"BuildConfig.class"</span> != fileName) &#123;</span><br><span class="line">                <span class="comment">//ClassReader: 字节码的读取与分析引擎</span></span><br><span class="line">                ClassReader classReader = <span class="keyword">new</span> ClassReader(subFile.bytes)</span><br><span class="line">                <span class="comment">//ClassWriter: 它实现了ClassVisitor接口，用于拼接字节码</span></span><br><span class="line">                <span class="comment">//COMPUTE_MAXS: 自动计算栈的最大值以及本地变量的最大数量</span></span><br><span class="line">                <span class="comment">//COMPUTE_FRAMES: 包含COMPUTE_MAXS，且会自动计算方法的栈桢</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="comment">//ClassVisitor: 定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等</span></span><br><span class="line">                ClassVisitor cv = <span class="keyword">new</span> AsmClassVisitor(api, classWriter, mConfig)</span><br><span class="line">                <span class="comment">//使给定的ClassVisitor访问传递给此构造函数的jvm类文件结构</span></span><br><span class="line">                <span class="comment">//EXPAND_FRAMES: 展开栈帧的标志位</span></span><br><span class="line">                classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        subFile.parentFile.absolutePath + File.separator + fileName)</span><br><span class="line">                fos.write(classWriter.toByteArray())</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = outputProvider.getContentLocation(</span><br><span class="line">            input.name,</span><br><span class="line">            input.contentTypes,</span><br><span class="line">            input.scopes,</span><br><span class="line">            Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectoryToDirectory(file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用以下流程图大概描述一下一个<code>class</code>文件的修改过程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_class%E4%BF%AE%E6%94%B9%E8%BF%87%E7%A8%8B.png" alt="class文件修改流程"></p>
<h2 id="自定义ClassVisitor"><a href="#自定义ClassVisitor" class="headerlink" title="自定义ClassVisitor"></a>自定义ClassVisitor</h2><p>我们开始继承<code>ClassVisitor</code>来实现我们对类的修改</p>
<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE.png" alt="读取配置"></p>
<h3 id="访问类"><a href="#访问类" class="headerlink" title="访问类"></a>访问类</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB.png" alt="访问类方法"></p>
<p>通过这个方法我们可以获得这个类的访问控制，全限定类名，父类名，实现的接口名等信息</p>
<p>这里，我们通过全限定类名和读取出的配置做比对，进一步验证是否需要对此类进行插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB.png" alt="验证类是否可插桩"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB2.png" alt="验证类是否可插桩"></p>
<h3 id="访问类内方法"><a href="#访问类内方法" class="headerlink" title="访问类内方法"></a>访问类内方法</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%86%85%E6%96%B9%E6%B3%95.png" alt="访问类内方法"></p>
<p>通过这个方法我们可以获得这个类的所有方法的名称和描述符，我们通过它们来判断该方法是否需要插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E6%96%B9%E6%B3%95.png" alt="判断方法是否需要插桩"></p>
<p>如果有需要插桩的方法，就将<code>mNeedStubClass</code>标志位置为true，这个标识是为了我们后续判断是否要在该类中插入成员变量，然后使用我们自定义的<code>MethodVisitor</code>替换原始的<code>MethodVisitor</code>。</p>
<h3 id="插入成员变量"><a href="#插入成员变量" class="headerlink" title="插入成员变量"></a>插入成员变量</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E5%85%A5%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="插入成员变量"></p>
<p>在最后，如果有需要插桩的方法，我们需要将<code>private long _$_timeRecorder</code>这个成员变量插入到类中去</p>
<h2 id="自定义MethodVisitor"><a href="#自定义MethodVisitor" class="headerlink" title="自定义MethodVisitor"></a>自定义MethodVisitor</h2><p>之前说了，<code>Java</code> 字节码指令是基于栈操作的，基本上任何操作都会改变栈状态</p>
<h3 id="在方法执行之前插入代码"><a href="#在方法执行之前插入代码" class="headerlink" title="在方法执行之前插入代码"></a>在方法执行之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* 此时，this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设此时栈为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">    mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//invokestatic: 调用静态方法System.currentTimeMillis()，返回值为基础类型long</span></span><br><span class="line">    <span class="comment">//第二个参数代表类的全限定名，第三个参数代表方法名，第四个参数代表函数签名，()J的意思是不接受参数，返回值为J (J在字节码里代表基础类型long)</span></span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lneg: 将栈顶的long类型取负并将结果压入栈顶</span></span><br><span class="line">    mv.visitInsn(Opcodes.LNEG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值取负, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//putfield: 为该类的此实例变量赋值</span></span><br><span class="line">    <span class="comment">//以(栈顶 - 1)为执行对象，为其赋值为栈顶值 (this._$_timeRecorder = -System.currentTimeMillis())</span></span><br><span class="line">    mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在方法return之前插入代码"><a href="#在方法return之前插入代码" class="headerlink" title="在方法return之前插入代码"></a>在方法return之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">        Label labelEnd = <span class="keyword">new</span> Label();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//dup: 将栈顶的值复制一份压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行System.currentTimeMillis()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis()执行后的结果值, this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶两long值相加，并将结果压入栈顶</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitInsn(Opcodes.LADD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis() + this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶的值存入(栈顶 - 1)._$_timeRecorder中</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder = this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//L: 对象类型，以分号结尾，如Ljava/lang/Object;</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建字符串</span></span><br><span class="line">        <span class="comment">//创建一个StringBuilder对象，此时还并没有执行构造方法</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        <span class="comment">//因为执行构造函数会将栈顶的StringBuilder对象弹出，为了后续能继续使用这个对象，所以这里需要先复制一份</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的StringBuilder调用构造方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"Time spent: "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            ["Time spent: ", StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(J)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"ms, when "</span> + mFormatClassName + <span class="string">"."</span> + mMethodName + <span class="string">":"</span> + mMethodDescriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [字符串常量, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行StringBuilder.toString()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行PrintStream.println()方法</span></span><br><span class="line">        <span class="comment">//相当于System.out.println(String)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Thread.currentThread()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/Thread"</span>, <span class="string">"currentThread"</span>, <span class="string">"()Ljava/lang/Thread;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [Thread.currentThread()执行的结果]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行getStackTrace()方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//相当于Thread.currentThread().getStackTrace()</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/Thread"</span>, <span class="string">"getStackTrace"</span>, <span class="string">"()[Ljava/lang/StackTraceElement;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//astore: 将一个引用类型对象保存到局部变量表index为2的位置（index1: this, index2: onCreate方法的参数）</span></span><br><span class="line">        <span class="comment">//使用一个临时变量保存StackTraceElement数组</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//将局部变量表index2处的引用对象压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StackTraceElement数组备份</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">3</span>);</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得栈顶位置数组的长度</span></span><br><span class="line">        mv.visitInsn(Opcodes.ARRAYLENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组length保存至局部变量表index4的位置</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4   ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将int常量0压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">        <span class="comment">//将栈顶的0取出保存（用作循环下标index）</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环开始处</span></span><br><span class="line">        <span class="comment">//插入一个label用来做后续循环跳转的标志</span></span><br><span class="line">        Label labelLoop = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(labelLoop);</span><br><span class="line">        <span class="comment">//将循环标志位的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数组长度值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环标志位, 数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//if_icmpge: 比较栈顶两int型数值大小, 当结果大于等于0时跳转</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.IF_ICMPGE, labelEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将循环index的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环index, StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将引用类型数组指定索引的值推送至栈顶（var3[var5]）</span></span><br><span class="line">        mv.visitInsn(Opcodes.AALOAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该索引下的值保存</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将System.out入栈</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new StringBuilder()</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出StackTraceElement数组中的某个值(以循环index作为下标)</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标), StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用栈顶对象，执行getClassName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getClassName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [ClassName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以ClassName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//即StringBuilder.append(ClassName)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"."</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getMethodName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getMethodName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [MethodName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以MethodName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getLineNumber方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getLineNumber"</span>, <span class="string">"()I"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [LineNumber, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以LineNumber作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(I)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用栈顶对象的toString方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以String作为参数，执行(栈顶 - 1)对象System.out的println方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iinc: 将指定int型变量增加指定值(index++)</span></span><br><span class="line">        mv.visitIincInsn(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//跳转到labelLoop插入的位置</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.GOTO, labelLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入结束Label，作为循环终止的跳转标志</span></span><br><span class="line">        mv.visitLabel(labelEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的方法插桩工作就完成了，接下来我们运行一下看看</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先<code>clean build</code>，再<code>build</code>，查看控制台信息，<code>build</code>完成后查看<code>class</code>文件</p>
<p>运行<code>App</code>，查看<code>Logcat</code>信息，可以看到打印出来了我们想要的信息。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这样我们就通过插桩的方式，实现了一个简单的无任何代码侵入的性能检测工具</p>
<p>通过这一次实践，我对<code>java</code>的编译运行字节码，<code>Android</code>的打包流程有了更深的理解</p>
<p>完整项目地址：<a href="https://github.com/dreamgyf/AsmPluginDemo" target="_blank" rel="noopener">https://github.com/dreamgyf/AsmPluginDemo</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8F%92%E6%A1%A9/">插桩</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/11/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Binder驱动（下）</span></a></div><div class="next-post pull-right"><a href="/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/"><span>Android源码分析 - Binder驱动（中）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>