<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux信号机制及其原理分析"><meta name="keywords" content="信号"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Linux信号机制及其原理分析 | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">2.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号的产生"><span class="toc-number">3.</span> <span class="toc-text">信号的产生</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号种类"><span class="toc-number">4.</span> <span class="toc-text">信号种类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何使用"><span class="toc-number">5.</span> <span class="toc-text">如何使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#发送信号"><span class="toc-number">5.1.</span> <span class="toc-text">发送信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kill"><span class="toc-number">5.1.1.</span> <span class="toc-text">kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raise"><span class="toc-number">5.1.2.</span> <span class="toc-text">raise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigqueue"><span class="toc-number">5.1.3.</span> <span class="toc-text">sigqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abort"><span class="toc-number">5.1.4.</span> <span class="toc-text">abort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alarm"><span class="toc-number">5.1.5.</span> <span class="toc-text">alarm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理信号"><span class="toc-number">5.2.</span> <span class="toc-text">处理信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sigaction"><span class="toc-number">5.2.1.</span> <span class="toc-text">sigaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction结构体"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">sigaction结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signal"><span class="toc-number">5.2.2.</span> <span class="toc-text">signal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞信号"><span class="toc-number">5.3.</span> <span class="toc-text">阻塞信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#信号集函数"><span class="toc-number">5.3.1.</span> <span class="toc-text">信号集函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#信号集设置函数"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">信号集设置函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigpromask"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">sigpromask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigpending"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">sigpending</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#信号原理"><span class="toc-number">6.</span> <span class="toc-text">信号原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#信号的发送"><span class="toc-number">6.1.</span> <span class="toc-text">信号的发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置信号处理"><span class="toc-number">6.2.</span> <span class="toc-text">设置信号处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信号的响应"><span class="toc-number">6.3.</span> <span class="toc-text">信号的响应</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#likely-amp-unlikely"><span class="toc-number">6.3.1.</span> <span class="toc-text">likely &amp; unlikely</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用户态与内核态的切换"><span class="toc-number">6.3.2.</span> <span class="toc-text">用户态与内核态的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pt-regs结构体"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">pt_regs结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信号处理函数的跳转方式"><span class="toc-number">6.3.3.</span> <span class="toc-text">信号处理函数的跳转方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#附录"><span class="toc-number">8.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#信号表"><span class="toc-number">8.1.</span> <span class="toc-text">信号表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献"><span class="toc-number">9.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux信号机制及其原理分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-31</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最近在工作中，使用到了信号的相关知识，之前我们在分析<code>Android</code>系统<code>init</code>进程的时候也提到了信号，但并没有对信号这个机制做出深入的理解，借此机会，我们深入分析一下<code>Linux</code>信号机制是怎样实现的</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>信号（<code>signal</code>），是<code>Unix</code>系统中的一种古老的进程间通信机制，而<code>Linux</code>作为类<code>Unix</code>系统，早期也是模仿了<code>Unix</code>系统，自然也保留下了这个机制。信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟</p>
<p><strong>注：本篇文章基于glibc版本2.35，Linux内核版本5.17，x86_64架构</strong></p>
<h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>信号可以由内核产生，也可以由用户产生，这边举几个例子：</p>
<ul>
<li><p>用户在终端输入<code>ctrl + c</code>时，会产生一个<code>SIGINT</code>信号</p>
</li>
<li><p>在程序中对一个数除0，会产生一个异常，最终由内核产生一个<code>SIGFPE</code>信号</p>
</li>
<li><p>在程序中非法访问一段内存，会由内核产生一个<code>SIGBUS</code>信号</p>
</li>
<li><p>在终端或程序中手动发送一个信号</p>
<ul>
<li><p>终端：比如说<code>kill -9 [pid]</code></p>
</li>
<li><p>程序：调用<code>kill</code>函数，<code>raise</code>函数等</p>
</li>
</ul>
</li>
</ul>
<h1 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h1><p>在<code>Linux</code>中，信号被分为不可靠信号和可靠信号，一共64种，可以通过<code>kill -l</code>命令来查看</p>
<ul>
<li><p>不可靠信号：也称为非实时信号，不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，信号值取值区间为1~31</p>
</li>
<li><p>可靠信号：也称为实时信号，支持排队，信号不会丢失，发多少次，就可以收到多少次，信号值取值区间为32~64</p>
</li>
</ul>
<p>在早期的<code>Linux</code>中，只定义了前面的不可靠信号，随着时间的发展，发现有必要对信号机制加以改进和扩充，又由于原先定义的信号已有应用，出于兼容性考虑，不能再做改动，于是又新增了一部分信号，这些信号被定义为可靠信号。</p>
<p>在<code>arch/x86/include/uapi/asm/signal.h</code>中，我们可以发现这些信号的定义，在文末的附录中，我们也详细介绍了每个信号的含义和默认动作</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>我一向认为，如果想要理解一个技术原理，首先我们必须要会使用这个技术</p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>之前提过，用户是可以手动向一个进程发送信号的，我们可以使用以下一些函数：</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/kill.2.html</a></p>
<p>这个函数的作用是向指定进程（或进程组）发送一个信号，成功返回0，失败返回-1</p>
<p>其中的<code>pid</code>参数：</p>
<ul>
<li><p>当<code>pid &gt; 0</code>时，发送信号给pid对应的进程</p>
</li>
<li><p>当<code>pid = 0</code>时，发送信号给本进程组中的所有进程</p>
</li>
<li><p>当<code>pid = -1</code>时，发送信号给所有调用进程有权给其发送信号的进程，除了init进程</p>
</li>
<li><p>当<code>pid &lt; -1</code>时，发送信号给进程组id为<code>-pid</code>的所有进程</p>
</li>
</ul>
<p>当<code>sig</code>参数为0时，不会发送任何信号，但仍然会进行参数检测，我们可以用这种方法检查<code>pid</code>对应进程是否存在或允许发送信号</p>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/raise.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/raise.3.html</a></p>
<p>这个函数的作用是向本进程或线程发送信号，成功返回0，失败返回-1</p>
<p>这个函数对于主线程来说，相当于<code>kill(getpid(), sig)</code>，对于子线程来说，相当于<code>pthread_kill(pthread_self(), sig)</code></p>
<h3 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a>sigqueue</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigqueue.3.html</a></p>
<p>这个函数的作用是向一个进程发送信号，同时可以传递一些额外数据，成功返回0，失败返回-1</p>
<p>这个函数和<code>kill</code>不同的地方是，它只能向一个进程发送信号，不能发送给信号组，当<code>sig</code>为0时，行为和<code>kill</code>一致</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">noreturn <span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/abort.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/abort.3.html</a></p>
<p>这个函数的作用是向本进程发送<code>SIGABRT</code>信号</p>
<p>需要注意的有两点：</p>
<ul>
<li><p><code>abort</code>函数会首先解除进程对<code>SIGABRT</code>信号的阻塞</p>
</li>
<li><p>无论<code>SIGABRT</code>信号是否注册了自定义处理器，最后都会终止进程，因为<code>abort</code>函数会在<code>SIGABRT</code>信号处理完后恢复默认信号处理方式，然后重发这个信号</p>
</li>
</ul>
<h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/alarm.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/alarm.2.html</a></p>
<p>这个函数的作用是在<code>seconds</code>秒后向本进程发送<code>SIGALRM</code>信号</p>
<p>参数<code>seconds</code>为时间，单位为秒</p>
<p>返回值，如果以前没有设置过<code>alarm</code>或超时，则返回0，如果以前没有设置过<code>alarm</code>，则返回剩余的时间</p>
<h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>我们是可以自定义一些信号的处理方式，需要注意的是，<code>SIGKILL</code>和<code>SIGSTOP</code>是两个特殊的信号，它们不允许被忽略、处理和阻塞</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct sigaction *<span class="keyword">restrict</span> oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>这是较新的一个信号处理函数，它的作用是，对一个信号注册一个新的信号处理方式，并获取以前的信号处理方式，成功返回0，失败返回-1</p>
<p>第一个参数<code>signum</code>，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>用来指定注册的新的信号处理方式</p>
<p>第三个参数<code>oldact</code>不为<code>null</code>时，可以用来获取该信号原来的处理方式</p>
<p>当参数<code>act</code>为<code>null</code>，<code>oldact</code>不为<code>null</code>时，这个函数可以用来只获取信号当前的处理方式</p>
<h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a>sigaction结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	  <span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line">	  <span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>, struct siginfo *, <span class="keyword">void</span> *);</span><br><span class="line">	&#125; _u;</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">__signalfn_t</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__signalfn_t</span> __user *<span class="keyword">__sighandler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler	_u._sa_handler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_sigaction	_u._sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>可以看到，其中有一个联合，它是用来兼容旧版本函数的，当参数<code>sa_mask</code>中含有<code>SA_SIGINFO</code>的时候，回调的是<code>_sa_sigaction</code>函数，当没有这个参数时，回调的是<code>_sa_handler</code>这个旧版本函数</p>
<p><code>_sa_sigaction</code>函数相对于<code>_sa_handler</code>函数而言，多携带了一些信号信息，譬如说发送信号的进程<code>pid</code></p>
<p><code>_sa_handler</code>可以被赋值成<code>SIG_DFL</code>或<code>SIG_IGN</code>，它们分别对应着默认处理和忽略信号，需要注意的时，它们只是一个<code>int</code>值，是不能被直接调用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL	((__force __sighandler_t)0)	<span class="comment">/* default signal handling */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN	((__force __sighandler_t)1)	<span class="comment">/* ignore signal */</span></span></span><br></pre></td></tr></table></figure>

<p>这个结构体中的<code>sa_mask</code>域为一个信号集，表示当正在执行信号处理函数的时候，阻塞一些信号，只有这个信号处理完了，这些信号才会被处理</p>
<p>这个结构体中的<code>sa_flags</code>域，有如下一些标志：</p>
<ul>
<li><p><code>SA_NOCLDSTOP</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程暂停或恢复时，父进程不会收到<code>SIGCHLD</code>信号</p>
</li>
<li><p><code>SA_NOCLDWAIT</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程退出时，父进程不会收到<code>SIGCHLD</code>信号，子进程也不会成为僵尸进程</p>
</li>
<li><p><code>SA_NODEFER</code>：一般情况下，当信号处理函数运行时，内核将阻塞对应的信号。但是如果设置了<code>SA_NODEFER</code>标记，那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p><code>SA_ONSTACK</code>：表示使用一个备用栈，当发生栈溢出时，内核会发出<code>SIGILL</code>信号，如果此时在原来的栈上调用信号处理函数，也会发生栈溢出，导致死循环，此时就需要准备一个备用栈，在备用栈上处理信号</p>
</li>
<li><p><code>SA_RESETHAND</code>：表示设置的信号处理行为只生效一次，当触发我们设置的信号处理函数后，内核会将信号处理行为重置（<code>SA_ONESHOT</code>作用相同，但它是一个过时的，非标准的<code>flag</code>）</p>
</li>
<li><p><code>SA_RESTART</code>：当执行系统调用时，如果收到一个信号，系统默认将中断这个系统调用，转而执行信号处理函数，结束后让这个被中断的系统调用失败，设置了<code>SA_RESTART</code>标志后，当信号处理函数执行完后，会自动恢复执行这个被中断的系统调用</p>
</li>
<li><p><code>SA_SIGINFO</code>：设置这个标志后，会回调<code>_sa_sigaction</code>作为信号处理函数，会携带更多的信号信息</p>
</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/signal.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/signal.2.html</a></p>
<p>这个函数的作用是，设置下一次的信号处理函数（只生效一次），成功返回上一次设置的信号处理函数，失败返回<code>SIG_ERR</code></p>
<p>这个函数在新版本中实际上是通过<code>sigaction</code>函数实现的，推荐使用更加强大的<code>sigaction</code>函数</p>
<h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><p>信号有几种状态，首先是信号的<code>产生 (Genertion)</code>，而实际执行信号处理动作时，状态为<code>递达 (Delivery)</code>，信号在<code>产生</code>到<code>递达</code>中的状态被称为<code>未决 (Pending)</code></p>
<p>进程可以选择<code>阻塞 (Blocking)</code>某些信号，被<code>阻塞</code>的信号在产生后将保持在<code>未决</code>状态，直到进程解除对该信号的<code>阻塞</code>，才执行<code>递达</code>的动作</p>
<h3 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h3><p>我们可以用信号集函数改变当前进程的<code>信号屏蔽字（Signal Mask）</code>，控制信号的阻塞与否</p>
<h4 id="信号集设置函数"><a href="#信号集设置函数" class="headerlink" title="信号集设置函数"></a>信号集设置函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号集数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">sigset_t</span>;</span><br><span class="line"><span class="comment">//清空一个信号集（将这个sigset_t置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//填充满一个信号集（将这个sigset_t的每一位都置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigfillset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号添加到信号集中（将这个sigset_t的对应信号位置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigaddset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号从信号集中移除（将这个sigset_t的对应信号位置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigdelset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//判断一个信号是否在这个信号集中（判断这个sigset_t的对应信号位是否为1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigismember.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>这个函数通过指定的方法和信号集修改进程的信号屏蔽字，成功返回0，失败返回-1</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是获得当前进程的信号屏蔽字，将结果保存到传入的<code>set</code>中，成功返回0，失败返回-1</p>
<h1 id="信号原理"><a href="#信号原理" class="headerlink" title="信号原理"></a>信号原理</h1><p>我们已经了解了信号的产生和处理，现在我们可以具体的看看一个信号从产生到响应处理，它经历了什么，它的原理是什么</p>
<p>我们在简介中说过：信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟，该怎么理解这句话呢？</p>
<p>当我们对一个进程发送信号后，会将这个信号暂时存放到这个进程所对应的<code>task_struct</code>的<code>pending</code>队列中，此时，进程并不知道有新的信号过来了，这也就是异步的意思。那么进程什么时候才能得知并处理这个信号呢？有两个时机，一个是进程从内核态返回到用户态时，一个是进程从睡眠状态被唤醒。让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的，所以信号能很快的得到执行</p>
<p>下图为信号相关的一些结构</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84.png" alt="task_struct中的信号结构"></p>
<h2 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h2><p>我们以<code>kill</code>函数为例，看看信号是如何发送的，它被定义在<code>tools/include/nolibc/nolibc.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = sys_kill(pid, signal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		SET_ERRNO(-ret);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_syscall2(__NR_kill, pid, signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了系统调用，在<code>Linux</code>内核中，每个<code>syscall</code>都对应着唯一的系统调用号，<code>kill</code>函数的系统调用号为<code>__NR_kill</code>，它被定义在<code>tools/include/uapi/asm-generic/unistd.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/signal.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 129</span></span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>架构的机器上，<code>my_syscall2</code>是这样被定义的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_syscall2(num, arg1, arg2)                                          \</span></span><br><span class="line">(&#123;                                                                            \</span><br><span class="line">	<span class="keyword">long</span> _ret;                                                            \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _num  <span class="keyword">asm</span>(<span class="string">"rax"</span>) = (num);                               \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg1 <span class="keyword">asm</span>(<span class="string">"rdi"</span>) = (<span class="keyword">long</span>)(arg1);                        \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg2 <span class="keyword">asm</span>(<span class="string">"rsi"</span>) = (<span class="keyword">long</span>)(arg2);                        \</span><br><span class="line">									      \</span><br><span class="line">	<span class="keyword">asm</span> <span class="keyword">volatile</span> (                                                        \</span><br><span class="line">		<span class="string">"syscall\n"</span>                                                   \</span><br><span class="line">		: <span class="string">"=a"</span>(_ret)                                                  \</span><br><span class="line">		: <span class="string">"r"</span>(_arg1), <span class="string">"r"</span>(_arg2),                                     \</span><br><span class="line">		  <span class="string">"0"</span>(_num)                                                   \</span><br><span class="line">		: <span class="string">"rcx"</span>, <span class="string">"r11"</span>, <span class="string">"memory"</span>, <span class="string">"cc"</span>                                \</span><br><span class="line">	);                                                                    \</span><br><span class="line">	_ret;                                                                 \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里涉及到了扩展内联汇编，<code>syscall</code>指令需要一个系统调用号和一些参数，在<code>x86_64</code>架构中，系统调用号需要存放在<code>rax</code>寄存器中，参数依次存放在<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code>, <code>r9</code>寄存器中，执行<code>syscall</code>指令后，内核会通过系统调用号去从系统调用表找到对应函数的入口</p>
<p>我们之前在找系统调用号<code>__NR_kill</code>的时候可以发现，上面标了注释，表明这个函数的实现在<code>kernel/signal.c</code>中，但我们在这个文件中并没有找到<code>sys_kill</code>这个函数，实际上这里隐藏了一个宏定义</p>
<p>在<code>include/linux/syscalls.h</code>中，我们可以找到这样一些宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SYSCALL_DEFINE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE0(sname)					\</span></span><br><span class="line">	SYSCALL_METADATA(_##sname, <span class="number">0</span>);				\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void);			\</span></span><br><span class="line">	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);		\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SYSCALL_DEFINE0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE_MAXARGS	6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span><br><span class="line">	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The asmlinkage stub is aliased to a function named __se_sys_*() which</span></span><br><span class="line"><span class="comment"> * sign-extends 32-bit ints to longs whenever needed. The actual work is</span></span><br><span class="line"><span class="comment"> * done within __do_sys_*().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL_DEFINEx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line">	__diag_push();							\</span><br><span class="line">	__diag_ignore(GCC, <span class="number">8</span>, <span class="string">"-Wattribute-alias"</span>,			\</span><br><span class="line">		      <span class="string">"Type aliasing is used to sanitize syscall arguments"</span>);\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line">		__attribute__((alias(__stringify(__se_sys##name))));	\</span><br><span class="line">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line">	&#123;								\</span><br><span class="line">		<span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span><br><span class="line">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span><br><span class="line">		<span class="keyword">return</span> ret;						\</span><br><span class="line">	&#125;								\</span><br><span class="line">	__diag_pop();							\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SYSCALL_DEFINEx */</span></span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINEx</code>中的<code>x</code>表示接受<code>x</code>个参数，这个宏定义根据传入的<code>name</code>参数，以<code>sys_name</code>为名定义了一个函数，也就是说<code>SYSCALL_DEFINE2(kill, ...)</code>这个宏展开后基本相当于<code>sys_kill</code>函数，在<code>kernel/signal.c</code>中我们可以找到这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    prepare_kill_siginfo(sig, &amp;info);</span><br><span class="line">    <span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是<code>kill</code>函数的真正实现，我们这里主要关注信号的发送，就屏蔽一些细节，只看发送部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//这里我们就只看对一个进程发送信号</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> kill_proc_info(sig, info, pid);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_proc_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill_pid_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取pid对应进程的task_struct</span></span><br><span class="line">        p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            <span class="comment">//PIDTYPE_TGID表示类型是线程组id，对于同一进程中的所有线程，tgid都是一致的，为该进程的进程id</span></span><br><span class="line">            group_send_sig_info(sig, info, p, PIDTYPE_TGID);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">        ret = do_send_sig_info(sig, info, p, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    send_signal(sig, info, p, type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">send_signal</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> __send_signal(sig, info, t, type, force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span><br><span class="line">            <span class="keyword">enum</span> pid_type type, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> override_rlimit;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_IGNORED;</span><br><span class="line">    <span class="comment">//判断是否可以忽略信号</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_signal(sig, t, force))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择信号pending队列</span></span><br><span class="line">    <span class="comment">//线程组共享队列(t-&gt;signal-&gt;shared_pending) 或 进程私有队列(t-&gt;pending)</span></span><br><span class="line">    pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">    </span><br><span class="line">    result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line">    <span class="comment">//如果该信号是不可靠信号，且已经在padding队列中，则忽略这个信号</span></span><br><span class="line">    <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对SIGKILL信号和内核进程跳过信号的pending</span></span><br><span class="line">    <span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">        <span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实时信号可以突破队列大小限制，否则丢弃信号</span></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新分配一个sigqueue，并将其加入pending队尾</span></span><br><span class="line">    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_USER;</span><br><span class="line">            q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">                            task_active_pid_ns(t));</span><br><span class="line">            rcu_read_lock();</span><br><span class="line">            q-&gt;info.si_uid =</span><br><span class="line">                from_kuid_munged(task_cred_xxx(t, user_ns),</span><br><span class="line">                         current_uid());</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">            q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info) &amp;&amp;</span><br><span class="line">           sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">    signalfd_notify(t, sig);</span><br><span class="line">    sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//唤醒进程</span></span><br><span class="line">    complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里我们可以看出来，和我们之前说的原理是一样的，新分配了一个<code>sigqueue</code>，并将其加入到对应进程<code>task_struct</code>的<code>pending</code>队列队尾</p>
<h2 id="设置信号处理"><a href="#设置信号处理" class="headerlink" title="设置信号处理"></a>设置信号处理</h2><p>之前我们介绍了怎么自定义信号处理行为，如何设置信号屏蔽字，实际上都能在进程的<code>task_struct</code>中体现出来，信号处理行为保存在其中的<code>sighand</code>域中，而信号屏蔽字保存在其中的<code>blocked</code>域中</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E5%9F%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="task_struct"></p>
<h2 id="信号的响应"><a href="#信号的响应" class="headerlink" title="信号的响应"></a>信号的响应</h2><p><code>x86_64</code>架构系统调用会经历<code>do_syscall_64</code>这么一个函数，它被实现在<code>arch/x86/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__visible noinstr <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(struct pt_regs *regs, <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_random_kstack_offset();</span><br><span class="line">    nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">    instrumentation_begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Invalid system call, but still a system call. */</span></span><br><span class="line">        regs-&gt;ax = __x64_sys_ni_syscall(regs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instrumentation_end();</span><br><span class="line">    syscall_exit_to_user_mode(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码我们可以看出来，当进程从内核空间返回用户空间时，会调用<code>syscall_exit_to_user_mode</code>函数</p>
<p>最终经历一系列调用，会走到<code>exit_to_user_mode_loop</code>函数中，它们被定义在<code>kernel/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">exit_to_user_mode_loop</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">long</span> ti_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ti_work &amp; EXIT_TO_USER_MODE_WORK) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))</span><br><span class="line">            handle_signal_work(regs, ti_work);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ti_work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果当前线程包含<code>_TIF_SIGPENDING</code>或<code>_TIF_NOTIFY_SIGNAL</code>，表明该线程可能有信号需要处理，会调用到<code>handle_signal_work</code>函数处理，接着调用到<code>arch_do_signal_or_restart</code>函数中，它被实现在<code>arch/x86/kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//has_signal的值为 (ti_work &amp; _TIF_SIGPENDING)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_do_signal_or_restart</span><span class="params">(struct pt_regs *regs, <span class="keyword">bool</span> has_signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_signal &amp;&amp; get_signal(&amp;ksig)) &#123;</span><br><span class="line">        handle_signal(&amp;ksig, regs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果该进程没有对这个信号设置处理程序，这里会自动重启这个系统调用</span></span><br><span class="line">    <span class="comment">/* Did we come from a system call? */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall_get_nr(current, regs) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Restart the system call - no handlers present */</span></span><br><span class="line">        <span class="keyword">switch</span> (syscall_get_error(current, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">            regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">            regs-&gt;ax = get_nr_restart_syscall(regs);</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    restore_saved_sigmask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中的<code>if</code>语句体，看上去是如果有信号，则处理这个信号，其实不完全是这样的。如果该进程没有对这个信号设置处理程序，则会执行默认的信号处理，这里的处理过程是在<code>get_signal</code>中完成的，我当时在看这块源码的时候还在疑惑为什么找不到信号默认处理的地方，结果是这个函数的名字误导了我。如果该进程没有对这个信号设置处理程序，则会自动重启这个系统调用，这里就不展开说了，我们首先看一下<code>get_signal</code>函数是怎么实现的，它被实现在<code>kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line">    <span class="keyword">int</span> signr;</span><br><span class="line">    ...</span><br><span class="line">relock:</span><br><span class="line">    spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果子进程的状态发生变化，发送SIGCHLD信号给父进程</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line">        <span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">            why = CLD_CONTINUED;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">        signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">        read_lock(&amp;tasklist_lock);</span><br><span class="line">        do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">            do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line">                        <span class="literal">true</span>, why);</span><br><span class="line">        read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> relock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line">        <span class="keyword">enum</span> pid_type type;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从进程task_struct的pending队列中取出一个信号</span></span><br><span class="line">        type = PIDTYPE_PID;</span><br><span class="line">        signr = dequeue_synchronous_signal(&amp;ksig-&gt;info);</span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            signr = dequeue_signal(current, &amp;current-&gt;blocked,</span><br><span class="line">                           &amp;ksig-&gt;info, &amp;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从信号处理数组中，取出对应信号的处理动作</span></span><br><span class="line">        ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">            <span class="comment">/* Run the handler.  */</span></span><br><span class="line">            ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果设置了SA_RESETHAND或者SA_ONESHOT标志（这俩标志的值是一样的），将其信号处理函数重设为默认</span></span><br><span class="line">            <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">                ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面为默认信号处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//部分信号的默认动作为忽略（具体可以查看SIG_KERNEL_IGNORE_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//部分信号的默认动作为停止进程（具体可以查看SIG_KERNEL_STOP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">                spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前为孤儿进程组</span></span><br><span class="line">                <span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line">                    <span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">                spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认动作为停止当前线程组里的所有线程</span></span><br><span class="line">            <span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> relock;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fatal:</span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">        ...</span><br><span class="line">        current-&gt;flags |= PF_SIGNALED;</span><br><span class="line">        <span class="comment">//部分信号的默认动作为dump core，然后终止进程（具体可以查看SIG_KERNEL_COREDUMP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">                print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">            proc_coredump_connector(current);</span><br><span class="line">            do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_IO_WORKER)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩下来的信号的默认操作为终止进程</span></span><br><span class="line">        do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">out:</span><br><span class="line">    ksig-&gt;sig = signr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_EXPOSE_TAGBITS))</span><br><span class="line">        hide_si_addr_tag_bits(ksig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当当前进程对此信号设置了自定义信号处理动作后，返回true</span></span><br><span class="line">    <span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="likely-amp-unlikely"><a href="#likely-amp-unlikely" class="headerlink" title="likely &amp; unlikely"></a>likely &amp; unlikely</h3><p>这里的<code>likely</code>和<code>unlikely</code>为两个宏，指向<code>__builtin_expect</code>函数，是<code>gcc</code>编译器提供给程序员优化的一种方式，<code>likely</code>表示表达式为真的可能性更大，<code>unlikely</code>表示表达式为假的可能性更大，这样<code>gcc</code>编译器可以在编译过程中，将可能性更大的代码紧跟前面的代码，减少指令跳转带来的性能开销</p>
<hr>
<p>我们接着看，当用户自定义了信号处理函数后，内核是怎么处理的。从上面的代码看来，当用户自定义了信号处理函数，<code>get_signal</code>函数会返回<code>true</code>，紧接着就会进入到<code>handle_signal</code>函数中，这里的处理比较特殊，我们要先了解信号处理的一些过程</p>
<p>用户自定义信号处理函数实际上是在用户空间执行的，目的是为了防止用户利用内核空间的<code>ring 0</code>特权等级做一些意想不到的事，处理过程如下两图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="信号处理过程"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B2.png" alt="信号处理过程"></p>
<p>整个过程如图中所见，进程由于系统调用或中断进入内核空间，在内核空间完成工作后返回用户空间的前夕，检查信号队列，如果检查有信号并且有自定义的信号处理函数，返回到用户空间执行信号处理函数，处理完后再返回内核空间，最后再回到用户空间之前代码执行到的地方继续运行</p>
<p>可以看到，这一套流程经历了4次用户态与内核态的切换，比较复杂，那么内核是如何做到的呢？为什么信号处理函数执行完后还要返回内核空间呢？</p>
<h3 id="用户态与内核态的切换"><a href="#用户态与内核态的切换" class="headerlink" title="用户态与内核态的切换"></a>用户态与内核态的切换</h3><p>在<code>Linux</code>中，在用户态和内核态运行的进程使用的是不同的栈，分别为用户栈和内核栈，当一个进程陷入内核态时，需要将用户栈的信息保存到内核栈中，具体的，会将<code>ss</code>, <code>sp</code>, <code>flags</code>, <code>cs</code>, <code>ip</code>等值依次压入栈中，保存为<code>pt_regs</code>结构，然后设置CPU堆栈寄存器的地址为内核栈顶，这样，后续使用的栈便变成了内核栈，当系统调用结束，需要从内核态切换到用户态时，再将之前压入栈中的寄存器值弹出，将<code>pt_regs</code>中保存的值恢复到相应的寄存器中，这里改变了<code>sp</code>寄存器的值，即完成了换栈，<code>cs:ip</code>这两个寄存器分别指向用户态代码段以及用户态指令指针，后续CPU便会执行之前用户态的代码了</p>
<h4 id="pt-regs结构体"><a href="#pt-regs结构体" class="headerlink" title="pt_regs结构体"></a>pt_regs结构体</h4><p><code>pt_regs</code>结构体位于<code>arch/x86/include/asm/ptrace.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从理论角度上大概理解了内核是怎么在用户态与内核态之间切换的，接下来我们去源码里验证一下是不是我们所想的这样，<code>syscall</code>的入口函数为<code>entry_SYSCALL_64</code>，位于<code>arch/x86/entry/entry_64.S</code>中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line">    </span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至内核态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* tss<span class="number">.</span>sp2为用户栈 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">    /* 切换至内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">    /* 保存用户栈寄存器值至pt_regs结构中 */</span><br><span class="line">    pushq	$__USER_DS				/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">    pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将rflags的值保存在<span class="built_in">r11</span>寄存器中 */</span><br><span class="line">    pushq	%r11					/* pt_regs-&gt;flags */</span><br><span class="line">    pushq	$__USER_CS				/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将<span class="keyword">syscall</span>指令的下一条指令的地址传给<span class="built_in">rcx</span>寄存器 */</span><br><span class="line">    pushq	%rcx					/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">    pushq	%rax					/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">    /* 保存并清除寄存器 */</span><br><span class="line">    PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line">    /* 此时，<span class="built_in">rsp</span>指向的栈顶地址即为pt_regs的地址 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 设置系统调用号 */</span><br><span class="line">    movslq	%eax, %rsi</span><br><span class="line">    /* 以<span class="built_in">rdi</span>, <span class="built_in">rsi</span>作为参数，调用do_syscall_64函数 */</span><br><span class="line">    <span class="keyword">call</span>	do_syscall_64		/* returns with IRQs disabled */</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cmpq	%rcx, %r11</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_CS, <span class="built_in">CS</span>(%rsp)		/* <span class="built_in">CS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	<span class="built_in">R11</span>(%rsp), %r11</span><br><span class="line">    cmpq	%r11, EFLAGS(%rsp)		/* <span class="built_in">R11</span> == RFLAGS */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">    <span class="keyword">jnz</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_DS, <span class="built_in">SS</span>(%rsp)		/* <span class="built_in">SS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这个标签实际上只是为了便于理解，并没有地方跳转它</span><br><span class="line">     * 实际工作是在swapgs_restore_regs_and_return_to_usermode中完成的</span><br><span class="line">     */</span><br><span class="line"><span class="symbol">syscall_return_via_sysret:</span></span><br><span class="line">    /* 恢复寄存器 */</span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 保存内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">    pushq	<span class="built_in">RSP</span>-<span class="built_in">RDI</span>(%rdi)	/* <span class="built_in">RSP</span> */</span><br><span class="line">    pushq	(%rdi)		/* <span class="built_in">RDI</span> */</span><br><span class="line"></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    popq	%rdi</span><br><span class="line">    popq	%rsp</span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至用户态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* 恢复<span class="built_in">rip</span>, rflags等寄存器，使<span class="meta">cpu</span>接下来要执行指令指向<span class="keyword">syscall</span>的下一条指令 */</span><br><span class="line">    sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<h3 id="信号处理函数的跳转方式"><a href="#信号处理函数的跳转方式" class="headerlink" title="信号处理函数的跳转方式"></a>信号处理函数的跳转方式</h3><p>但是在系统调用完后，回到的将是syscall后的下一条指令，那么如何才能让程序去执行信号处理函数呢？信号处理函数执行完后，又如何回到之前所执行到的代码呢？我们很容易就能想到，先将<code>pt_regs</code>中的值备份一下，然后改变<code>pt_regs</code>中一些寄存器值，比如说将<code>cs:ip</code>修改成信号处理函数对应地址，这样从内核态返回后，就会自动跳转到信号处理函数了，等到信号处理函数执行完，再进入内核态，恢复<code>pt_regs</code>中的值后回到用户态，这样<code>cpu</code>又会从用户调用<code>syscall</code>后的指令开始正常执行了</p>
<p>我们具体的看一下内核代码是怎么做的，这里的逻辑在<code>arch/x86/kernel/signal.c</code>中的<code>handle_signal</code>函数里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    failed = (setup_rt_frame(ksig, regs) &lt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    signal_setup_done(failed, ksig, stepping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line">    <span class="keyword">sigset_t</span> *<span class="built_in">set</span> = sigmask_to_save();</span><br><span class="line">    <span class="keyword">compat_sigset_t</span> *cset = (<span class="keyword">compat_sigset_t</span> *) <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform fixup for the pre-signal frame. */</span></span><br><span class="line">    rseq_signal_deliver(ksig, regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置栈帧</span></span><br><span class="line">    <span class="keyword">if</span> (is_ia32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)</span><br><span class="line">            <span class="keyword">return</span> ia32_setup_rt_frame(usig, ksig, cset, regs);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ia32_setup_frame(usig, ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_x32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> x32_setup_rt_frame(ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> __setup_rt_frame(ksig-&gt;sig, ksig, <span class="built_in">set</span>, regs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x86_64执行的应该是这个函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __setup_rt_frame(<span class="keyword">int</span> sig, struct ksignal *ksig,</span><br><span class="line">                <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* x86-64 should always use SA_RESTORER. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个栈帧</span></span><br><span class="line">    frame = get_sigframe(&amp;ksig-&gt;ka, regs, <span class="keyword">sizeof</span>(struct rt_sigframe), &amp;fp);</span><br><span class="line">    uc_flags = frame_uc_flags(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user_access_begin(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the ucontext.  */</span></span><br><span class="line">    unsafe_put_user(uc_flags, &amp;frame-&gt;uc.uc_flags, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;frame-&gt;uc.uc_link, Efault);</span><br><span class="line">    unsafe_save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up to return from userspace.  If provided, use a stub</span></span><br><span class="line"><span class="comment">       already in userspace.  */</span></span><br><span class="line">    <span class="comment">//设置执行完信号处理函数后，要跳回的地址，即sa_restorer</span></span><br><span class="line">    unsafe_put_user(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode, Efault);</span><br><span class="line">    <span class="comment">//将原本的pt_regs备份保存至frame.uc.uc_mcontext中</span></span><br><span class="line">    unsafe_put_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, <span class="built_in">set</span>, Efault);</span><br><span class="line">    unsafe_put_sigmask(<span class="built_in">set</span>, frame, Efault);</span><br><span class="line">    user_access_end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号处理函数的第1个参数</span></span><br><span class="line">    regs-&gt;di = sig;</span><br><span class="line">    <span class="comment">/* In case the signal handler was declared without prototypes */</span></span><br><span class="line">    regs-&gt;ax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置了SA_SIGINFO标志位，需要带一些额外的信号信息 */</span></span><br><span class="line">    <span class="comment">//信号处理函数的第2个参数</span></span><br><span class="line">    regs-&gt;si = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;info;</span><br><span class="line">    <span class="comment">//信号处理函数的第3个参数</span></span><br><span class="line">    regs-&gt;dx = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;uc;</span><br><span class="line">    <span class="comment">//设置指令指针指向信号处理函数</span></span><br><span class="line">    <span class="comment">//sigaction结构体中的第一个域是一个联合，所以这里</span></span><br><span class="line">    <span class="comment">//sa_handler和sa_sigaction的地址是相同的</span></span><br><span class="line">    regs-&gt;ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ksig-&gt;ka.sa.sa_handler;</span><br><span class="line">    <span class="comment">//设置栈顶地址</span></span><br><span class="line">    regs-&gt;sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)frame;</span><br><span class="line">    <span class="comment">//设置用户代码段</span></span><br><span class="line">    regs-&gt;cs = __USER_CS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(regs-&gt;ss != __USER_DS))</span><br><span class="line">        force_valid_ss(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Efault:</span><br><span class="line">    user_access_end();</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsafe_put_sigcontext(sc, fp, regs, set, label)			\</span></span><br><span class="line"><span class="keyword">do</span> &#123;									\</span><br><span class="line">    <span class="keyword">if</span> (__unsafe_setup_sigcontext(sc, fp, regs, <span class="built_in">set</span>-&gt;sig[<span class="number">0</span>]))	\</span><br><span class="line">        <span class="keyword">goto</span> label;						\</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span><br><span class="line">__unsafe_setup_sigcontext(struct sigcontext __user *sc, <span class="keyword">void</span> __user *fpstate,</span><br><span class="line">             struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> mask)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(regs-&gt;di, &amp;sc-&gt;di, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;si, &amp;sc-&gt;si, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bp, &amp;sc-&gt;bp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;sp, &amp;sc-&gt;sp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bx, &amp;sc-&gt;bx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;dx, &amp;sc-&gt;dx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cx, &amp;sc-&gt;cx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ax, &amp;sc-&gt;ax, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;r8, &amp;sc-&gt;r8, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r9, &amp;sc-&gt;r9, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r10, &amp;sc-&gt;r10, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r11, &amp;sc-&gt;r11, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r12, &amp;sc-&gt;r12, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r13, &amp;sc-&gt;r13, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r14, &amp;sc-&gt;r14, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r15, &amp;sc-&gt;r15, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(current-&gt;thread.trap_nr, &amp;sc-&gt;trapno, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.error_code, &amp;sc-&gt;err, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ip, &amp;sc-&gt;ip, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;flags, &amp;sc-&gt;flags, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cs, &amp;sc-&gt;cs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;gs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;fs, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ss, &amp;sc-&gt;ss, Efault);</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(fpstate, (<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *)&amp;sc-&gt;fpstate, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-iBCS2 extensions.. */</span></span><br><span class="line">    unsafe_put_user(mask, &amp;sc-&gt;oldmask, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2, Efault);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Efault:</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际上是这么做的，首先，内核默认在用户栈上分配了一个栈帧（如果设置了备用栈的话，则会在备用栈上分配），将<code>pt_regs</code>备份到这个栈帧上，用于后续恢复，然后设置<code>pt_regs</code>，改变其<code>sp</code>, <code>cs</code>, <code>ip</code>等值，使程序从内核态返回时，可以跳转到信号处理函数对应的栈和代码指令地址，当信号处理函数返回时会执行<code>sigreturn</code>系统调用再进入内核态，将之前备份到栈帧中的寄存器值重新恢复到<code>pt_regs</code>中，然后再从内核态回到用户态就可以正常继续执行<code>syscall</code>后面的代码了</p>
<p>其中<code>sa_restorer</code>是在<code>glibc</code>里的<code>__libc_sigaction</code>函数中被设置的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_sigaction (<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_sigaction</span> <span class="title">kact</span>, <span class="title">koact</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (act)</span><br><span class="line">    &#123;</span><br><span class="line">        kact.k_sa_handler = act-&gt;sa_handler;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;kact.sa_mask, &amp;act-&gt;sa_mask, <span class="keyword">sizeof</span> (<span class="keyword">sigset_t</span>));</span><br><span class="line">        kact.sa_flags = act-&gt;sa_flags;</span><br><span class="line">        <span class="comment">//设置sa_restorer</span></span><br><span class="line">        SET_SA_RESTORER (&amp;kact, act);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">restore_rt</span> <span class="params">(<span class="keyword">void</span>)</span> <span class="title">asm</span> <span class="params">(<span class="string">"__restore_rt"</span>)</span> attribute_hidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SA_RESTORER(kact, act)			\</span></span><br><span class="line">    (kact)-&gt;sa_flags = (act)-&gt;sa_flags | SA_RESTORER;	\</span><br><span class="line">    (kact)-&gt;sa_restorer = &amp;restore_rt</span><br><span class="line">    </span><br><span class="line">RESTORE (restore_rt, __NR_rt_sigreturn)</span><br><span class="line"></span><br><span class="line">#define RESTORE(name, syscall) RESTORE2 (name, syscall)</span><br><span class="line">#define RESTORE2(name, syscall) \</span><br><span class="line"><span class="keyword">asm</span>									\</span><br><span class="line">  (									\</span><br><span class="line">   <span class="comment">/* `nop' for debuggers assuming `call' should not disalign the code.  */</span> \</span><br><span class="line">   <span class="string">"	nop\n"</span>								\</span><br><span class="line">   <span class="string">".align 16\n"</span>							\</span><br><span class="line">   <span class="string">".LSTART_"</span> #name <span class="string">":\n"</span>						\</span><br><span class="line">   <span class="string">"	.type __"</span> #name <span class="string">",@function\n"</span>					\</span><br><span class="line">   <span class="string">"__"</span> #name <span class="string">":\n"</span>							\</span><br><span class="line">   <span class="string">"	movq $"</span> #syscall <span class="string">", %rax\n"</span>					\</span><br><span class="line">   <span class="string">"	syscall\n"</span>							\</span><br><span class="line">   ...</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>可以看到，这里也是一个系统调用，和上面所说的规则一样，它最终会调用<code>sys_rt_sigreturn</code>函数，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(rt_sigreturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> = <span class="title">current_pt_regs</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    frame = (struct rt_sigframe __user *)(regs-&gt;sp - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(*(__u64 *)&amp;<span class="built_in">set</span>, (__u64 __user *)&amp;frame-&gt;uc.uc_sigmask))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    set_current_blocked(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame.uc.uc_mcontext中恢复pt_regs</span></span><br><span class="line">    <span class="keyword">if</span> (!restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (restore_altstack(&amp;frame-&gt;uc.uc_stack))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ax;</span><br><span class="line"></span><br><span class="line">badframe:</span><br><span class="line">    signal_fault(regs, frame, <span class="string">"rt_sigreturn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">restore_sigcontext</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct sigcontext __user *usc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">sc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always make any pending restarted system calls return -EINTR */</span></span><br><span class="line">    current-&gt;restart_block.fn = do_no_restart_syscall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;sc, usc, CONTEXT_COPY_SIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;bx = sc.bx;</span><br><span class="line">    regs-&gt;cx = sc.cx;</span><br><span class="line">    regs-&gt;dx = sc.dx;</span><br><span class="line">    regs-&gt;si = sc.si;</span><br><span class="line">    regs-&gt;di = sc.di;</span><br><span class="line">    regs-&gt;bp = sc.bp;</span><br><span class="line">    regs-&gt;ax = sc.ax;</span><br><span class="line">    regs-&gt;sp = sc.sp;</span><br><span class="line">    regs-&gt;ip = sc.ip;</span><br><span class="line"></span><br><span class="line">    regs-&gt;r8 = sc.r8;</span><br><span class="line">    regs-&gt;r9 = sc.r9;</span><br><span class="line">    regs-&gt;r10 = sc.r10;</span><br><span class="line">    regs-&gt;r11 = sc.r11;</span><br><span class="line">    regs-&gt;r12 = sc.r12;</span><br><span class="line">    regs-&gt;r13 = sc.r13;</span><br><span class="line">    regs-&gt;r14 = sc.r14;</span><br><span class="line">    regs-&gt;r15 = sc.r15;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get CS/SS and force CPL3 */</span></span><br><span class="line">    regs-&gt;cs = sc.cs | <span class="number">0x03</span>;</span><br><span class="line">    regs-&gt;ss = sc.ss | <span class="number">0x03</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (sc.flags &amp; FIX_EFLAGS);</span><br><span class="line">    <span class="comment">/* disable syscall checks */</span></span><br><span class="line">    regs-&gt;orig_ax = <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fpu__restore_sig((<span class="keyword">void</span> __user *)sc.fpstate,</span><br><span class="line">                   IS_ENABLED(CONFIG_X86_32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码还是可以比较清楚的看出来，和我们之前描述的原理基本一致，到这一步时，恢复<code>pt_regs</code>中的值，这样后续返回用户态后便可以正常继续运行后面的用户代码了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Linux</code>信号的原理分析到这基本上也就结束了，其实整个信号原理分析对现阶段的我来说，还是一件相当具有挑战性的事情，不过在此过程中，还是收获了很多知识，也发现了一些之前文章里错漏的地方，由于我对<code>Linux</code>内核以及汇编并不熟悉，所以难免会有一些分析错误或者不到位的地方，欢迎大家指正</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h2><p>取值 | 名称        | 解释               | 默认动作        |<br>| – | ——— | —————- | ———– |<br>| 1  | SIGHUP    | 挂起               | 终止进程    |<br>| 2  | SIGINT    | 中断               | 终止进程    |<br>| 4  | SIGILL    | 非法指令             | coredump后终止进程 |<br>| 5  | SIGTRAP   | 断点或陷阱指令          | coredump后终止进程 |<br>| 6  | SIGABRT/SIGIOT   | abort发出的信号  | coredump后终止进程 |<br>| 7  | SIGBUS    | 非法内存访问           | coredump后终止进程 |<br>| 8  | SIGFPE    | 浮点异常             | coredump后终止进程 |<br>| 9  | SIGKILL   | kill信号           | 不能被忽略、处理和阻塞 |<br>| 10 | SIGUSR1   | 用户自定义信号1            | 终止进程 |<br>| 11 | SIGSEGV   | 无效内存访问           | coredump后终止进程 |<br>| 12 | SIGUSR2   | 用户自定义信号2            | 终止进程 |<br>| 13 | SIGPIPE   | 管道破损，没有读端的管道写数据  | 终止进程 |<br>| 14 | SIGALRM   | alarm发出的信号       | 终止进程 |<br>| 15 | SIGTERM   | 终止信号             | 终止进程 |<br>| 16 | SIGSTKFLT | 栈溢出              | 终止进程 |<br>| 17 | SIGCHLD   | 子进程退出            | 忽略信号 |<br>| 18 | SIGCONT   | 进程继续             | 忽略信号 |<br>| 19 | SIGSTOP   | 进程停止             | 不能被忽略、处理和阻塞 |<br>| 20 | SIGTSTP   | 进程停止             | 停止进程 |<br>| 21 | SIGTTIN   | 进程停止，后台进程从终端读数据时 | 停止进程 |<br>| 22 | SIGTTOU   | 进程停止，后台进程想终端写数据时 | 停止进程 |<br>| 23 | SIGURG    | I/O有紧急数据到达当前进程   | 忽略信号 |<br>| 24 | SIGXCPU   | 进程的CPU时间片到期      | coredump后终止进程 |<br>| 25 | SIGXFSZ   | 文件大小的超出上限        | coredump后终止进程 |<br>| 26 | SIGVTALRM | 虚拟时钟超时           | 终止进程 |<br>| 27 | SIGPROF   | profile时钟超时      | 终止进程 |<br>| 28 | SIGWINCH  | 窗口大小改变           | 忽略信号 |<br>| 29 | SIGPOLL/SIGIO     | I/O相关            | 终止进程 |<br>| 30 | SIGPWR    | 关机               | 默认忽略        |<br>| 31 | SIGSYS/SIGUNUSED    | 系统调用异常 | coredump后终止进程 |</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://tianyu-code.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E4%BF%A1%E5%8F%B7/" target="_blank" rel="noopener">Linux信号</a></li>
<li><a href="https://docs.huihoo.com/c/linux-c-programming/ch33s03.html" target="_blank" rel="noopener">阻塞信号</a></li>
<li><a href="https://kernel.meizu.com/linux-signal.html" target="_blank" rel="noopener">Linux Signal</a></li>
<li><a href="http://gityuan.com/2015/12/20/signal/" target="_blank" rel="noopener">Linux信号(signal)机制</a></li>
<li><a href="https://oilbeater.com/linux/2012/05/09/linux-signal.html" target="_blank" rel="noopener">linux 信号处理机制简介</a></li>
<li><a href="https://wenfh2020.com/2021/09/05/kernel-syscall/" target="_blank" rel="noopener">[内核源码] Linux 系统调用（x86_64）</a></li>
<li><a href="https://ty-chen.github.io/linux-kernel-signal/" target="_blank" rel="noopener">Linux操作系统学习笔记（十六）进程间通信之信号</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117794217" target="_blank" rel="noopener">X86_64处理器系统调用机制在linux上的实现</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117929007" target="_blank" rel="noopener">linux kernel signal机制（X86_64）</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BF%A1%E5%8F%B7/">信号</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/"><i class="fa fa-chevron-left">  </i><span>Jetpack Compose入门</span></a></div><div class="next-post pull-right"><a href="/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/"><span>B站Android面试小记</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>