<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Binder驱动（上）"><meta name="keywords" content="Android源码,Binder"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Binder驱动（上） | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#提示"><span class="toc-number">1.1.</span> <span class="toc-text">提示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#初始化"><span class="toc-number">2.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-initcall机制"><span class="toc-number">2.1.</span> <span class="toc-text">Linux initcall机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-init"><span class="toc-number">2.2.</span> <span class="toc-text">binder_init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init-binder-device"><span class="toc-number">2.3.</span> <span class="toc-text">init_binder_device</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注册misc设备"><span class="toc-number">2.3.1.</span> <span class="toc-text">注册misc设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册binder设备"><span class="toc-number">2.3.2.</span> <span class="toc-text">注册binder设备</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-proc"><span class="toc-number">3.</span> <span class="toc-text">binder_proc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-open"><span class="toc-number">4.</span> <span class="toc-text">binder_open</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spinlock"><span class="toc-number">4.1.</span> <span class="toc-text">spinlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#current"><span class="toc-number">4.2.</span> <span class="toc-text">current</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#container-of"><span class="toc-number">4.3.</span> <span class="toc-text">container_of</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fd-amp-filp"><span class="toc-number">4.4.</span> <span class="toc-text">fd&amp;filp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-mmap"><span class="toc-number">5.</span> <span class="toc-text">binder_mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vm-area-struct"><span class="toc-number">5.1.</span> <span class="toc-text">vm_area_struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-alloc-mmap-handler"><span class="toc-number">5.2.</span> <span class="toc-text">binder_alloc_mmap_handler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献"><span class="toc-number">7.</span> <span class="toc-text">参考文献</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Binder驱动（上）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Binder/">Binder</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="Android源码分析 - Binder概述">Android源码分析 - Binder概述</a>我们大概了解了一下<code>Android</code>选用<code>Binder</code>的原因，以及<code>Binder</code>的基本结构和通信过程。今天，我们便开始从<code>Binder</code>驱动层代码开始分析<code>Binder</code>的机制</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><code>Binder</code>驱动部分代码不在<code>AOSP</code>项目中，所以我们需要单独<code>clone</code>一份驱动代码</p>
<p>由于我的开发设备是pixel2，查了<code>Linux</code>内核版本号为<code>4.4.223</code>，对应的分支为<code>android-msm-wahoo-4.4-android11</code>，所以今天的分析我们也是基于此分支</p>
<p>我是从清华大学镜像站<code>clone</code>的代码，高通的设备，所以地址为：<a href="https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git" target="_blank" rel="noopener">https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git</a></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p><code>binder</code>驱动的源码位于<code>drivers/android</code>目录下，我们从<code>binder.c</code>文件看起</p>
<h2 id="Linux-initcall机制"><a href="#Linux-initcall机制" class="headerlink" title="Linux initcall机制"></a>Linux initcall机制</h2><p>在<code>binder.c</code>的最底下，我们可以看到这一行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>

<p>在<code>Linux</code>内核中，驱动程序通常是用<code>xxx_initcall(fn)</code>启动的，这实际上是一个宏定义，被定义在平台对应的<code>init.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_initcall(fn) __define_initcall(fn, early)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn) __define_initcall(fn, 0) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn) __define_initcall(fn, 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn) __define_initcall(fn, 1s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn) __define_initcall(fn, 2) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn) __define_initcall(fn, 2s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn) __define_initcall(fn, 3) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn) __define_initcall(fn, 3s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn) __define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn) __define_initcall(fn, 4s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn) __define_initcall(fn, 5) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn) __define_initcall(fn, 5s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn) __define_initcall(fn, rootfs) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn) __define_initcall(fn, 6) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn) __define_initcall(fn, 6s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn) __define_initcall(fn, 7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn) __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，实际上调用的是<code>__define_initcall()</code>函数，这个函数的第二个参数表示优先级，数字越小，优先级越高，带s的优先级低于不带s的优先级</p>
<p>在Linux内核启动过程中，需要调用各种函数，在底层实现是通过在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可，而<code>__define_initcall()</code>函数，就是将自定义的init函数添加到上述段中</p>
<h2 id="binder-init"><a href="#binder-init" class="headerlink" title="binder_init"></a>binder_init</h2><p>了解了以上函数定义后，我们再回头看<code>device_initcall(binder_init)</code>就可以知道，在<code>Linux</code>内核启动时，会调用<code>binder_init</code>这么一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *device_name, *device_names, *device_tmp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder内存回收</span></span><br><span class="line">    ret = binder_alloc_shrinker_init();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个单线程工作队列，用于处理异步任务</span></span><br><span class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建binder/proc目录</span></span><br><span class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>,</span><br><span class="line">                         binder_debugfs_dir_entry_root);</span><br><span class="line">    <span class="comment">//在binder目录下创建5个文件</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">        debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_state_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"stats"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_stats_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transactions"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_transactions_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log_failed,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//"binder,hwbinder,vndbinder"</span></span><br><span class="line">    device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">    device_tmp = device_names;</span><br><span class="line">    <span class="comment">//用binder,hwbinder,vndbinder分别调用init_binder_device函数</span></span><br><span class="line">    <span class="keyword">while</span> ((device_name = strsep(&amp;device_tmp, <span class="string">","</span>))) &#123;</span><br><span class="line">        ret = init_binder_device(device_name);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err_init_binder_device_failed:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">err_alloc_device_names_failed:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将重点放在<code>init_binder_device</code>函数上</p>
<h2 id="init-binder-device"><a href="#init-binder-device" class="headerlink" title="init_binder_device"></a>init_binder_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!binder_device)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder注册虚拟字符设备所对应的file_operations</span></span><br><span class="line">    binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">    <span class="comment">//动态分配次设备号</span></span><br><span class="line">    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">    binder_device-&gt;context.name = name;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//注册misc设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(binder_device);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将binder设备加入链表（头插法）</span></span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造了一个结构体用来存放<code>binder</code>参数，然后通过<code>misc_register</code>函数，以<code>misc</code>设备进行注册<code>binder</code>，作为虚拟字符设备</p>
<h3 id="注册misc设备"><a href="#注册misc设备" class="headerlink" title="注册misc设备"></a>注册misc设备</h3><p>我们先学习一下在<code>Linux</code>中如何注册一个<code>misc</code>设备</p>
<p>在Linux驱动中把无法归类的五花八门的设备定义为<code>misc</code>设备，<code>Linux</code>内核所提供的<code>misc</code>设备有很强的包容性，各种无法归结为标准字符设备的类型都可以定义为<code>misc</code>设备，譬如NVRAM，看门狗，实时时钟，字符LCD等</p>
<p>在<code>Linux</code>内核里把所有的<code>misc</code>设备组织在一起，构成了一个子系统(<code>subsys</code>)，统一进行管理。在这个子系统里的所有<code>miscdevice</code>类型的设备共享一个主设备号<code>MISC_MAJOR</code>(10)，但次设备号不同</p>
<p>在内核中用<code>miscdevice</code>结构体表示<code>misc</code>设备，具体的定义在<code>include/linux/miscdevice.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nodename;</span><br><span class="line">    <span class="keyword">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们自己注册<code>misc</code>设备时只需要填入前3项即可：</p>
<ul>
<li><code>minor</code>：次设备号，如果填充<code>MISC_DYNAMIC_MINOR</code>，则由内核动态分配次设备号</li>
<li><code>name</code>：设备名</li>
<li><code>fops</code>：<code>file_operations</code>结构体，用于定义自己<code>misc</code>设备的文件操作函数，如果不填此项则会使用默认的<code>misc_fops</code></li>
</ul>
<p><code>file_operations</code>结构体被定义在<code>include/linux/fs.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">flush</span>) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>file_operation</code>是把系统调用和驱动程序关联起来的关键结构，这个结构的每一个成员都对应着一个系统调用，<code>Linux</code>系统调用通过读取<code>file_operation</code>中相应的函数指针，接着把控制权转交给函数，从而完成<code>Linux</code>设备驱动程序的工作</p>
<p>最后调用<code>misc_register</code>函数注册<code>misc</code>设备，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">misc_register</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br><span class="line"><span class="comment">//卸载misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">misc_deregister</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="注册binder设备"><a href="#注册binder设备" class="headerlink" title="注册binder设备"></a>注册binder设备</h3><p>了解了<code>misc</code>设备的注册，我们就可以看一下<code>binder</code>的注册过程了，代码中先构建了一个<code>binder_device</code>结构体，我们先观察一下这个结构体长什么样子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>hlist_node</code>是链表中的一个节点，<code>miscdevice</code>就是上文所描述的注册<code>misc</code>所必要的结构体参数，<code>binder_context</code>用于保存<code>binder</code>上下文管理者的信息</p>
<p>回到代码中，首先给<code>miscdevice</code>赋了值，指定了<code>file_operation</code>，设置了<code>minor</code>动态分配次设备号，<code>binder_context</code>则是简单初始化了一下，然后便调用<code>misc_register</code>函数注册<code>misc</code>设备，最后将这个<code>binder</code>设备使用头插法加入到一个全局链表中</p>
<p>我们看一下它指定的<code>file_operation</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .<span class="built_in">open</span> = binder_open,</span><br><span class="line">    .<span class="built_in">flush</span> = binder_flush,</span><br><span class="line">    .<span class="built_in">release</span> = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>binder</code>驱动支持以上7种系统调用，接下来，我们就逐一分析这些系统调用</p>
<h1 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a>binder_proc</h1><p>在分析这些系统调用前，我们有必要先了解一下在<code>binder</code>中非常重要的结构体<code>binder_proc</code>，它是用来描述进程上下文信息以及管理IPC的一个结构体，被定义在<code>drivers/android/binder.c</code>中，是一个私有的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="comment">//hash链表中的一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="comment">//处理用户请求的线程组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="comment">//binder实体组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以句柄来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以它对应的binder实体的地址来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_threads</span>;</span></span><br><span class="line">    <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//进程描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="comment">//进程打开的所有文件数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">files_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> deferred_work;</span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//待处理事件队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;</span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">default_priority</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">    <span class="comment">//用来记录mmap分配的用户虚拟地址空间和内核虚拟地址空间等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_alloc</span> <span class="title">alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> inner_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> outer_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h1><p>我们先从打开<code>binder</code>驱动设备开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//管理IPC和保存进程信息的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//初始化内核同步自旋锁</span></span><br><span class="line">    spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">    <span class="comment">//原子操作赋值</span></span><br><span class="line">    atomic_set(&amp;proc-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使执行当前系统调用进程的task_struct.usage加1</span></span><br><span class="line">    get_task_struct(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">//使binder_proc中的tsk指向执行当前系统调用的进程</span></span><br><span class="line">    proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">//初始化文件锁</span></span><br><span class="line">    mutex_init(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//初始化todo列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">        proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">        proc-&gt;default_priority.prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到binder_device结构体的首地址</span></span><br><span class="line">    binder_dev = container_of(filp-&gt;private_data, struct binder_device,</span><br><span class="line">                  miscdev);</span><br><span class="line">    <span class="comment">//使binder_proc的上下文指向binder_device的上下文</span></span><br><span class="line">    proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">    <span class="comment">//初始化binder缓冲区</span></span><br><span class="line">    binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">//全局binder_stats结构体中，BINDER_STAT_PROC类型的对象创建数量加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">//设置当前进程id</span></span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    <span class="comment">//初始化已分发的死亡通知列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    <span class="comment">//初始化等待线程列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line">    <span class="comment">//保存binder_proc数据</span></span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为binder支持多线程，所以需要加锁</span></span><br><span class="line">    mutex_lock(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">//将binder_proc添加到binder_procs全局链表中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在binder/proc目录下创建文件，以执行当前系统调用的进程id为名</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</span><br><span class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">            binder_debugfs_dir_entry_proc,</span><br><span class="line">            (<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)proc-&gt;pid,</span><br><span class="line">            &amp;binder_proc_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>binder_open</code>函数创建了<code>binder_proc</code>结构体，并把初始化并将当前进程等信息保存到<code>binder_proc</code>结构体中，然后将<code>binder_proc</code>结构体保存到文件指针<code>filp</code>的<code>private_data</code>中，再将<code>binder_proc</code>加入到全局链表<code>binder_procs</code>中</p>
<p>这里面有一些关于<code>Linux</code>的知识需要解释一下</p>
<h2 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h2><p><code>spinlock</code>是内核中提供的一种自旋锁机制。在<code>Linux</code>内核实现中，常常会碰到共享数据被中断上下文和进程上下文访问的场景，如果只有进程上下文的话，我们可以使用互斥锁或者信号量解决，将未获得锁的进程置为睡眠状态等待，但由于中断上下文不是一个进程，它不存在<code>task_struct</code>，所以不可被调度，当然也就不可睡眠，这时候就可以通过<code>spinlock</code>自旋锁的忙等待机制来达成睡眠同样的效果</p>
<h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><p>在<code>Linux</code>内核中，定义了一个叫<code>current</code>的宏，它被定义在<code>asm/current.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(current_thread_info()-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	current	get_current()</span></span><br></pre></td></tr></table></figure>

<p>它返回一个<code>task_struct</code>指针，指向执行当前这段内核代码的进程</p>
<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p><code>container_of</code>也是<code>Linux</code>中定义的一个宏，它的作用是根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER)	((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;              \         </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \         </span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="fd-amp-filp"><a href="#fd-amp-filp" class="headerlink" title="fd&amp;filp"></a>fd&amp;filp</h2><p><code>filp-&gt;private_data</code>保存了<code>binder_proc</code>结构体，当进程调用<code>open</code>系统函数时，内核会返回一个文件描述符<code>fd</code>，这个<code>fd</code>指向文件指针<code>filp</code>，在后续调用<code>mmap</code>，<code>ioctl</code>等函数与<code>binder</code>驱动交互时，会传入这个<code>fd</code>，内核就会以这个<code>fd</code>指向文件指针<code>filp</code>作为参数调用<code>binder_mmap</code>，<code>binder_ioctl</code>等函数，这样这些函数就可以通过<code>filp-&gt;private_data</code>取出<code>binder_proc</code>结构体</p>
<h1 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h1><h2 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h2><p>在分析<code>mmap</code>前，我们需要先了解一下<code>vm_area_struct</code>这个结构体，它被定义在<code>include/linux/mm_types.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//当前vma的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;</span><br><span class="line">    <span class="comment">//当前vma的末地址后第一个字节的地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="comment">//红黑树中对应节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma前面还有多少空闲空间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma所属的内存地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="comment">//vma标识集，定义在 include/linux/mm.h 中</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">        &#125; shared;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *anon_name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma操作函数集指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma起始地址在vm_file中的文件偏移，单位为物理页面PAGE_SIZE</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;</span><br><span class="line">    <span class="comment">//被映射的文件（如果使用文件映射）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vm_area_struct</code>结构体描述了一段虚拟内存空间，通常，进程所使用到的虚拟内存空间不连续，且各部分虚存空间的访问属性也可能不同，所以一个进程的虚拟内存空间需要多个<code>vm_area_struct</code>结构来描述（后面简称<code>vma</code>）</p>
<p>每个进程都有一个对应的<code>task_struct</code>结构描述，这个<code>task_struct</code>结构中有一个<code>mm_struct</code>结构用于描述进程的内存空间，<code>mm_struct</code>结构中有两个域成员变量分别指向了<code>vma</code>链表头和红黑树根</p>
<p><code>vma</code>所描述的虚拟内存空间范围由<code>vm_start</code>和<code>vm_end</code>表示，<code>vm_start</code>代表当前<code>vma</code>的首地址，<code>vm_end</code>代表当前<code>vma</code>的末地址后第一个字节的地址，即虚拟内存空间范围为<code>[vm_start, vm_end)</code></p>
<p><code>vm_operations_struct</code>和上文中的<code>file_operations</code>类似，用来定义虚拟内存的操作函数</p>
<hr>
<p>介绍完<code>vma</code>，接下来我们便看一下<code>binder_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验进程信息</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将虚拟内存地址大小限制在4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检查用户空间是否可写（FORBIDDEN_MMAP_FLAGS == VM_WRITE）</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//VM_DONTCOPY表示此vma不可被fork所复制</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP;</span><br><span class="line">    <span class="comment">//用户空间不可设置该vma的VM_WRITE标志</span></span><br><span class="line">    vma-&gt;vm_flags &amp;= ~VM_MAYWRITE;</span><br><span class="line">    <span class="comment">//设置此vma操作函数集</span></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    <span class="comment">//指向binder_proc</span></span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理进程虚拟内存空间与内核虚拟地址空间的映射关系</span></span><br><span class="line">    ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    mutex_lock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//获取进程的打开文件信息结构体files_struct，并将引用计数加1</span></span><br><span class="line">    proc-&gt;files = get_files_struct(current);</span><br><span class="line">    mutex_unlock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">    pr_err(<span class="string">"%s: %d %lx-%lx %s failed %d\n"</span>, __func__,</span><br><span class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先从<code>filp</code>中获取对应的<code>binder_proc</code>信息</li>
<li>将它的进程<code>task_struct</code>和执行当前这段内核代码的进程<code>task_struct</code>对比校验</li>
<li>限制了用户空间虚拟内存的大小在4M以内</li>
<li>检查用户空间是否可写（<code>binder</code>驱动为进程分配的缓冲区在用户空间中只可以读，不可以写）</li>
<li>设置<code>vm_flags</code>，令<code>vma</code>不可写，不可复制</li>
<li>设置<code>vma</code>的操作函数集</li>
<li>将<code>vm_area_struct</code>中的成员变量<code>vm_private_data</code>指向<code>binder_proc</code>，使得<code>vma</code>设置的操作函数中可以拿到<code>binder_proc</code></li>
<li>处理进程虚拟内存空间与内核虚拟地址空间的映射关系</li>
<li>获取进程的打开文件信息结构体<code>files_struct</code>，令<code>binder_proc</code>的<code>files</code>指向它，并将引用计数加1</li>
</ol>
<h2 id="binder-alloc-mmap-handler"><a href="#binder-alloc-mmap-handler" class="headerlink" title="binder_alloc_mmap_handler"></a>binder_alloc_mmap_handler</h2><p><code>binder_alloc_mmap_handler</code>将进程虚拟内存空间与内核虚拟地址空间做映射，它被实现在<code>drivers/android/binder_alloc.c</code>中</p>
<p>这里先介绍一下<code>vm_struct</code>，之前我们已经了解了<code>vm_area_struct</code>表示用户进程中的虚拟地址空间，而相对应的，<code>vm_struct</code>则表示内核中的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_alloc_mmap_handler</span><span class="params">(struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        <span class="comment">//检查是否已经分配过内核缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//获得一个内核虚拟空间</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC);</span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//alloc-&gt;buffer指向内核虚拟内存空间地址</span></span><br><span class="line">	alloc-&gt;<span class="built_in">buffer</span> = area-&gt;addr;</span><br><span class="line">        <span class="comment">//计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量</span></span><br><span class="line">	alloc-&gt;user_buffer_offset =</span><br><span class="line">		vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">	alloc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]) *</span><br><span class="line">				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//buffer大小等于vma大小</span></span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">buffer</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc buffer struct"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//指向内核虚拟空间地址</span></span><br><span class="line">	<span class="built_in">buffer</span>-&gt;data = alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">        <span class="comment">//将buffer添加到链表中</span></span><br><span class="line">	list_add(&amp;<span class="built_in">buffer</span>-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将此内核缓冲区加入到binder_alloc的空闲缓冲红黑树中</span></span><br><span class="line">	binder_insert_free_buffer(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="comment">//设置进程最大可用异步事务缓冲区大小（防止异步事务消耗过多内核缓冲区，影响同步事务）</span></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//内存屏障，保证指令顺序执行</span></span><br><span class="line">	barrier();</span><br><span class="line">        <span class="comment">//设置binder_alloc</span></span><br><span class="line">	alloc-&gt;vma = vma;</span><br><span class="line">	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">	<span class="comment">//引用计数+1</span></span><br><span class="line">	atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>检查是否已经分配过内核缓冲区</li>
<li>从内核中寻找一块可用的虚拟内存地址</li>
<li>将此内核虚拟内存空间地址保存至<code>binder_alloc</code></li>
<li>计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量（这样就可以非常方便的在用户虚拟内存空间与内核虚拟内存空间间切换）</li>
<li>为<code>alloc-&gt;pages</code>数组申请内存，申请的大小等于<code>vma</code>能分配多少个页框</li>
<li>设置<code>buffer</code>大小等于<code>vma</code>大小</li>
<li>为<code>binder_buffer</code>申请内存，填充参数，使其指向内核虚拟空间地址，并将其添加到链表和红黑树中</li>
<li>设置<code>binder_alloc</code>其他参数</li>
</ol>
<p>这里要注意，虽然我们计算出了用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量，但并没有建立映射关系。在旧版内核中，这里会调用<code>binder_update_page_range</code>函数分别将内核虚拟内存和进程虚拟内存与物理内存做映射，这样内核虚拟内存和进程虚拟内存也相当于间接建立了映射关系，而在<code>4.4.223</code>中，这件事将会延迟到<code>binder_ioctl</code>后</p>
<p>当完成物理内存的映射后，以32位系统，缓冲区大小4M为例，效果应该如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89_mmap.png" alt="binder_mmap"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，了解了一些重要的结构体，明白了<code>mmap</code>是如何映射用户空间和内核空间的，由于篇幅原因，下一章我们会分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://unicornx.github.io/2016/02/14/20160214-lk-drv-miscdevice/" target="_blank" rel="noopener">linux中的misc设备</a></li>
<li><a href="https://blog.csdn.net/u012142460/article/details/90344951" target="_blank" rel="noopener">内存映射与VMA</a></li>
<li><a href="https://www.jianshu.com/p/4399aedb4d42" target="_blank" rel="noopener">Android 重学系列 Binder驱动的初始化 映射原理(二)</a></li>
<li><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></li>
<li><a href="https://segmentfault.com/a/1190000014643994" target="_blank" rel="noopener">Linux 4.16 Binder驱动学习笔记——–接口简析</a></li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/Binder/">Binder</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Binder驱动（中）</span></a></div><div class="next-post pull-right"><a href="/2022/02/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E6%A6%82%E8%BF%B0/"><span>Android源码分析 - Binder概述</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>