<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Binder驱动（中）"><meta name="keywords" content="Android源码,Binder"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Binder驱动（中） | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ioctl"><span class="toc-number">2.</span> <span class="toc-text">ioctl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#命令码"><span class="toc-number">2.1.</span> <span class="toc-text">命令码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder驱动命令码"><span class="toc-number">3.</span> <span class="toc-text">binder驱动命令码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#binder-ioctl"><span class="toc-number">4.</span> <span class="toc-text">binder_ioctl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#user"><span class="toc-number">4.1.</span> <span class="toc-text">__user</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-event-interruptible"><span class="toc-number">4.2.</span> <span class="toc-text">wait_event_interruptible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-thread结构体"><span class="toc-number">4.3.</span> <span class="toc-text">binder_thread结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-get-thread"><span class="toc-number">4.4.</span> <span class="toc-text">binder_get_thread</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BINDER-WRITE-READ"><span class="toc-number">5.</span> <span class="toc-text">BINDER_WRITE_READ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-write-read结构体"><span class="toc-number">5.1.</span> <span class="toc-text">binder_write_read结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder-thread-write"><span class="toc-number">5.2.</span> <span class="toc-text">binder_thread_write</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#binder请求码"><span class="toc-number">5.2.1.</span> <span class="toc-text">binder请求码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binder-transaction"><span class="toc-number">5.2.2.</span> <span class="toc-text">binder_transaction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#binder-transaction-data结构体"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">binder_transaction_data结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transaction-flags"><span class="toc-number">5.2.2.1.1.</span> <span class="toc-text">transaction_flags</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binder-transaction结构体"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">binder_transaction结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binder-work结构体"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">binder_work结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一部分：获得目标进程-线程信息"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">第一部分：获得目标进程&#x2F;线程信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BC-TRANSACTION"><span class="toc-number">5.2.2.4.1.</span> <span class="toc-text">BC_TRANSACTION</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#binder-get-ref-olocked"><span class="toc-number">5.2.2.4.1.1.</span> <span class="toc-text">binder_get_ref_olocked</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#binder-get-node-refs-for-txn"><span class="toc-number">5.2.2.4.1.2.</span> <span class="toc-text">binder_get_node_refs_for_txn</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BC-REPLY"><span class="toc-number">5.2.2.4.2.</span> <span class="toc-text">BC_REPLY</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第二部分：数据拷贝，建立映射"><span class="toc-number">5.2.2.5.</span> <span class="toc-text">第二部分：数据拷贝，建立映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分配缓存，建立映射"><span class="toc-number">5.2.2.5.1.</span> <span class="toc-text">分配缓存，建立映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数据拷贝"><span class="toc-number">5.2.2.5.2.</span> <span class="toc-text">数据拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#binder类型转换"><span class="toc-number">5.2.2.5.3.</span> <span class="toc-text">binder类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#flat-binder-object结构体"><span class="toc-number">5.2.2.5.3.1.</span> <span class="toc-text">flat_binder_object结构体</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#binder-translate-binder"><span class="toc-number">5.2.2.5.3.2.</span> <span class="toc-text">binder_translate_binder</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#binder-translate-handle"><span class="toc-number">5.2.2.5.3.3.</span> <span class="toc-text">binder_translate_handle</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三部分：加入todo队列，唤醒目标线程"><span class="toc-number">5.2.2.6.</span> <span class="toc-text">第三部分：加入todo队列，唤醒目标线程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Binder驱动（中）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Binder/">Binder</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="https://juejin.cn/post/7059601252367204365">Android源码分析 - Binder驱动（上）</a>，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，接下来我们继续分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>我们先简单介绍一下<code>ioctl</code>函数，这个函数是用来控制设备的，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd , <span class="keyword">unsigned</span> <span class="keyword">long</span> cmd , ...<span class="comment">/* args */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>fd</code>为设备的文件描述符</p>
<p>第二个参数<code>cmd</code>为命令码，它由驱动方自定义，用户通过命令码告诉设备驱动想要它做什么</p>
<p>后面为可选参数，具体内容和<code>cmd</code>有关，是传入驱动层的参数</p>
<h2 id="命令码"><a href="#命令码" class="headerlink" title="命令码"></a>命令码</h2><p><code>Linux</code>内核是这么定义一个命令码的</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>序列号</th>
<th>方向</th>
<th>数据尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>8 bit</td>
<td>8 bit</td>
<td>2 bit</td>
<td>8~14 bit</td>
</tr>
</tbody></table>
<p>这样，一个命令就变成了一个整数形式的命令码了，为了使用起来方便，<code>Linux</code>定义了一些生成命令码的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO(type,nr)        <span class="comment">//没有参数的命令</span></span><br><span class="line">_IOR(type,nr,<span class="built_in">size</span>)  <span class="comment">//从驱动中读数据</span></span><br><span class="line">_IOW(type,nr,<span class="built_in">size</span>)  <span class="comment">//写数据到驱动中</span></span><br><span class="line">_IOWR(type,nr,<span class="built_in">size</span>) <span class="comment">//双向读写</span></span><br></pre></td></tr></table></figure>

<h1 id="binder驱动命令码"><a href="#binder驱动命令码" class="headerlink" title="binder驱动命令码"></a>binder驱动命令码</h1><p>了解了<code>ioctl</code>和它的命令码后，我们来看看<code>binder</code>驱动定义了哪些命令码，以及它们分别有什么作用</p>
<p><code>binder</code>驱动命令码被定义在<code>include/uapi/linux/android/binder.h</code>中，其中有几个貌似未使用，我就不列出来了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ		_IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS		_IOW(<span class="meta-string">'b'</span>, 5, __u32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR		_IOW(<span class="meta-string">'b'</span>, 7, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT		_IOW(<span class="meta-string">'b'</span>, 8, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION			_IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_DEBUG_INFO	_IOWR(<span class="meta-string">'b'</span>, 11, struct binder_node_debug_info)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_INFO_FOR_REF	_IOWR(<span class="meta-string">'b'</span>, 12, struct binder_node_info_for_ref)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR_EXT	_IOW(<span class="meta-string">'b'</span>, 13, struct flat_binder_object)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>BINDER_WRITE_READ</code>：读写命令，用于数据传输，<code>binder IPC</code>通信中的核心</li>
<li><code>BINDER_SET_MAX_THREADS</code>：设置最大线程数</li>
<li><code>BINDER_SET_CONTEXT_MGR</code>：设置成为<code>binder</code>上下文管理者</li>
<li><code>BINDER_THREAD_EXIT</code>：<code>binder</code>线程退出命令，释放相关资源</li>
<li><code>BINDER_VERSION</code>：获取<code>binder</code>驱动版本号</li>
<li><code>BINDER_GET_NODE_DEBUG_INFO</code>：获得<code>binder</code>节点的<code>debug</code>信息</li>
<li><code>BINDER_GET_NODE_INFO_FOR_REF</code>：从<code>binder</code>引用获得<code>binder</code>节点信息</li>
<li><code>BINDER_SET_CONTEXT_MGR_EXT</code>：和<code>BINDER_SET_CONTEXT_MGR</code>作用相同，携带额外参数</li>
</ul>
<p>了解了这些<code>binder</code>驱动命令码，我们就可以开始正式分析<code>binder_ioctl</code></p>
<h1 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h1><p>这个函数位于<code>drivers/android/binder.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="comment">//从命令参数中解析出用户数据大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//进入休眠状态，等待被唤醒</span></span><br><span class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_unlocked;</span><br><span class="line">    <span class="comment">//根据请求系统调用的线程的pid，查找对应的binder_thread，没有则新建一个</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_DEBUG_INFO: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体上来看还是比较清晰的，我们对一些点做一下详解</p>
<h2 id="user"><a href="#user" class="headerlink" title="__user"></a>__user</h2><p><code>__user</code>是一个宏，它告诉编译器不应该解除这个指针的引用（因为在当前地址空间中它是没有意义的），<code>(void __user *)arg</code>表示<code>arg</code>是一个用户空间的地址，不能直接进行拷贝等，要使用<code>copy_from_user</code>，<code>copy_to_user</code>等函数。</p>
<h2 id="wait-event-interruptible"><a href="#wait-event-interruptible" class="headerlink" title="wait_event_interruptible"></a>wait_event_interruptible</h2><p><code>wait_event_interruptible(wq, condition)</code>是一个宏，它是用来挂起进程直到满足判断条件的</p>
<p><code>binder_stop_on_user_error</code>是一个全局变量，它的初始值为0，<code>binder_user_error_wait</code>是一个等待队列</p>
<p>在正常情况下，<code>binder_stop_on_user_error &lt; 2</code>这个条件是成立的，所以不会进入挂起状态，而当<code>binder</code>因为错误而停止后，调用<code>binder_ioctl</code>，则会挂起进程，直到其他进程通过<code>wake_up_interruptible</code>来唤醒<code>binder_user_error_wait</code>队列，并且满足<code>binder_stop_on_user_error &lt; 2</code>这个条件，<code>binder_ioctl</code>才会继续往后运行</p>
<h2 id="binder-thread结构体"><a href="#binder-thread结构体" class="headerlink" title="binder_thread结构体"></a>binder_thread结构体</h2><p>我们需要关注一个重要的结构体<code>binder_thread</code>，它在后续的代码中会频繁的出现，这个结构体描述了进程中的工作线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="comment">//binder线程所属的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_thread_node</span>;</span></span><br><span class="line">    <span class="comment">//进程pid</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//描述了线程当前的状态</span></span><br><span class="line">    <span class="keyword">int</span> looper;              <span class="comment">/* only modified by this thread */</span></span><br><span class="line">    <span class="keyword">bool</span> looper_need_return; <span class="comment">/* can be written by other thread */</span></span><br><span class="line">    <span class="comment">//binder事务栈（链表形式，内部存在前后节点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">    <span class="comment">//todo队列，为需要处理的工作的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="comment">//binder_thread_write后是否立即执行完成binder_thread_read</span></span><br><span class="line">    <span class="comment">//false的情况下会在binder_thread_read中休眠，延迟执行BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    <span class="keyword">bool</span> process_todo;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">return_error</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">reply_error</span>;</span></span><br><span class="line">    <span class="comment">//等待队列，当处理binder事务需要依赖别的binder事务的时候，则会以此等待队列睡眠</span></span><br><span class="line">    <span class="comment">//直到它所依赖的binder事务完成后唤醒</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="comment">//统计信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="comment">//临时引用计数</span></span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="comment">//是否死亡</span></span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//线程信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="binder-get-thread"><a href="#binder-get-thread" class="headerlink" title="binder_get_thread"></a>binder_get_thread</h2><p>接下来我们看一下<code>binder_ioctl</code>是怎么获得<code>binder_thread</code>的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">new_thread</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">if</span> (!thread) &#123;</span><br><span class="line">        new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (thread != new_thread)</span><br><span class="line">            kfree(new_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到里面有锁操作，使用的就是上一章<a href="https://juejin.cn/post/7062654742329032740#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中所介绍过的<code>spinlock</code>，使用的是<code>binder_proc</code>结构体中的<code>inner_lock</code></p>
<p>简单浏览一下代码我们就可以知道，<code>binder_get_thread</code>首先试着从<code>binder_proc</code>获得<code>binder_thread</code>，如果没能获得，就新建一个，这两种情况都调用了<code>binder_get_thread_ilocked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread_ilocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc *proc, struct binder_thread *new_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!new_thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    thread = new_thread;</span><br><span class="line">    <span class="comment">//binder_thread对象创建计数加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">    thread-&gt;proc = proc;</span><br><span class="line">    thread-&gt;pid = current-&gt;pid;</span><br><span class="line">    <span class="comment">//引用计数加1</span></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    thread-&gt;task = current;</span><br><span class="line">    atomic_set(&amp;thread-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">    <span class="comment">//初始化todo队列</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">//插入红黑树</span></span><br><span class="line">    rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">    thread-&gt;looper_need_return = <span class="literal">true</span>;</span><br><span class="line">    thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">    thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">    INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数分为前后两个部分，前半部分通过<code>binder_proc-&gt;threads</code>这个红黑树查找当前系统调用进程<code>pid</code>所对应的<code>binder_thread</code>，后半部分初始化了传入的<code>new_thread</code>，并将其插入到红黑树中（<code>binder_proc-&gt;threads</code>）</p>
<hr>
<p>接下来就是判断命令码<code>cmd</code>，来执行相应的工作了，我们只分析比较重要的几个命令码</p>
<h1 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h1><p><code>binder</code>驱动中最重要的命令码肯定非<code>BINDER_WRITE_READ</code>莫属了，这个命令用来进行<code>binder</code>读写交互</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch case命令码后，直接调用了<code>binder_ioctl_write_read</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验用户传入arg数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户空间ubuf拷贝至内核空间bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//当写缓存中有数据，执行binder写操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        trace_binder_write_done(ret);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有错误发生，将已读数据大小设为0</span></span><br><span class="line">            bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当读缓存中有数据，执行binder读操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="comment">//如果todo队列中有未处理的任务，唤醒等待状态下的线程</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">            binder_wakeup_proc_ilocked(proc);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将内核空间修改后的bwr拷贝至用户空间ubuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="binder-write-read结构体"><a href="#binder-write-read结构体" class="headerlink" title="binder_write_read结构体"></a>binder_write_read结构体</h2><p><code>BINDER_WRITE_READ</code>命令码所接受的参数为一个<code>binder_write_read</code>结构体，我们先来了解一下它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_size;        <span class="comment">/* bytes to write */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_consumed;    <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     write_buffer;</span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_size;         <span class="comment">/* bytes to read */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_consumed;     <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>write_size</code>：写数据的总大小</li>
<li><code>write_consumed</code>：已写数据大小</li>
<li><code>write_buffer</code>：写数据的虚拟内存地址</li>
<li><code>read_size</code>：读数据的总大小</li>
<li><code>read_consumed</code>：已读数据大小</li>
<li><code>read_buffer</code>：读数据的虚拟内存地址</li>
</ul>
<hr>
<p>整个<code>binder_ioctl_write_read</code>函数结构是比较简单的，首先校验了一下用户空间所传的参数<code>arg</code>为<code>binder_write_read</code>结构体，接着将其从用户空间拷贝至内核空间<code>bwr</code>，接下来便是分别检查写缓存读缓存中是否有数据，有的话则执行相应的写读操作。这里需要注意的是，读写操作所传入的<code>write_consumed</code>和<code>read_consumed</code>是以地址的形式，即会对这两个值进行修改，不管读写操作是否执行，成功或者失败，最后都会调用<code>copy_to_user</code>将<code>bwr</code>从内核空间复制到用户空间<code>ubuf</code></p>
<p>看到这里，可能有些同学会觉得有些奇怪，说好<code>binder</code>只进行一次复制的呢？其实是这样的没错，这里的<code>copy_from_user</code>或者<code>copy_to_user</code>只是复制了<code>binder_write_read</code>结构体，得到了需要IPC数据的虚拟内存地址而已，真正的复制操作是在<code>binder</code>读写操作中进行的</p>
<h2 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write"></a>binder_thread_write</h2><p>先看<code>binder</code>写操作，这个函数首先从传入的参数中，计算出待写的起始地址和结束地址，因为可能数据中含有多个命令和对应数据要处理，所以这里开了一个循环，在循环中，首先调用<code>get_user</code>，从用户空间读取一个值到内核空间中来，这个值就是<code>binder</code>请求码，然后将指针向后移动32位，使其指向对应请求码的数据头，接着根据<code>binder</code>请求码去完成不同的工作，处理完后修改已写数据大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//可能含有多个命令和对应数据要处理</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; <span class="built_in">end</span> &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得binder请求码</span></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">//使指针指向数据头</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        <span class="comment">//记录binder数据信息</span></span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据binder请求码，执行不同工作</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BC_DECREFS: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS_DONE:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_ATTEMPT_ACQUIRE:</span><br><span class="line">            pr_err(<span class="string">"BC_ATTEMPT_ACQUIRE not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_RESULT:</span><br><span class="line">            pr_err(<span class="string">"BC_ACQUIRE_RESULT not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION_SG:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY_SG: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_DEAD_BINDER_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">"%d:%d unknown command %d\n"</span>,</span><br><span class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置已写数据大小</span></span><br><span class="line">        *consumed = ptr - <span class="built_in">buffer</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="binder请求码"><a href="#binder请求码" class="headerlink" title="binder请求码"></a>binder请求码</h3><p><code>binder</code>请求码用于用户空间程序向<code>binder</code>驱动发送请求消息，以<code>BC</code>开头，被定义在<code>enum</code> <code>binder_driver_command_protocol</code>中（<code>include/uapi/linux/android/binder.h</code>）</p>
<p>命令                            | 说明                           | 参数类型                    |<br>| —————————– | —————————- | ——————– |<br>| BC_TRANSACTION                | Binder事务，即：Client对于Server的请求 | binder_transaction_data |<br>| BC_REPLY                      | 事务的应答，即：Server对于Client的回复    | binder_transaction_data |<br>| BC_FREE_BUFFER                | 通知驱动释放Buffer                 | binder_uintptr_t |<br>| BC_ACQUIRE                    | 强引用计数+1                      | __u32             |<br>| BC_RELEASE                    | 强引用计数-1                      | __u32             |<br>| BC_INCREFS                    | 弱引用计数+1                      | __u32             |<br>| BC_DECREFS                    | 弱引用计数-1                      | __u32             |<br>| BC_ACQUIRE_DONE               | BR_ACQUIRE的回复                | binder_ptr_cookie  |<br>| BC_INCREFS_DONE               | BR_INCREFS的回复                | binder_ptr_cookie  |<br>| BC_ENTER_LOOPER               | 通知驱动主线程ready                 | void            |<br>| BC_REGISTER_LOOPER            | 通知驱动子线程ready                 | void            |<br>| BC_EXIT_LOOPER                | 通知驱动线程已经退出                   | void          |<br>| BC_REQUEST_DEATH_NOTIFICATION | 请求接收死亡通知             | binder_handle_cookie    |<br>| BC_CLEAR_DEATH_NOTIFICATION   | 去除接收死亡通知             | binder_handle_cookie    |<br>| BC_DEAD_BINDER_DONE           | 已经处理完死亡通知            | binder_uintptr_t       |<br>| BC_ATTEMPT_ACQUIRE            | 暂不支持                         | -                 |<br>| BC_ACQUIRE_RESULT             | 暂不支持                         | -                 |</p>
<p>其中，最重要且最频繁的操作为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>，我们就只分析一下这两个请求码做了什么事</p>
<h3 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">                       cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个请求码，首先从用户空间中复制了一份<code>binder_transaction_data</code>到内核空间，接着就调用<code>binder_transaction</code>函数继续处理</p>
<h4 id="binder-transaction-data结构体"><a href="#binder-transaction-data结构体" class="headerlink" title="binder_transaction_data结构体"></a>binder_transaction_data结构体</h4><p>在分析<code>binder_transaction</code>函数前，我们需要先了解一些结构体</p>
<p><code>binder_transaction_data</code>结构体就是<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>所对应的参数类型，它被定义在<code>include/uapi/linux/android/binder.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象非本地binder实体时，用handle表示对目标binder的引用</span></span><br><span class="line">        __u32	handle;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象是本地binder实体时，用此域成员变量表示这个对象在本进程中的内存地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span> ptr;</span><br><span class="line">    &#125; target;</span><br><span class="line">    <span class="comment">//目标binder实体所带的附加数据</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">    <span class="comment">//表示要对目标对象请求的命令代码</span></span><br><span class="line">    __u32		code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务标志，详见enum transaction_flags</span></span><br><span class="line">    __u32	        flags;</span><br><span class="line">    <span class="comment">//发起请求的进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span>		sender_pid;</span><br><span class="line">    <span class="comment">//发起请求的进程uid</span></span><br><span class="line">    <span class="keyword">uid_t</span>		sender_euid;</span><br><span class="line">    <span class="comment">//真正要传输的数据的大小</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	data_size;</span><br><span class="line">    <span class="comment">//偏移数组大小，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">//数据区的首地址</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	<span class="built_in">buffer</span>;</span><br><span class="line">            <span class="comment">//偏移数组的首地址，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">            <span class="comment">//数组的每一项为一个binder_size_t，这个值对应着每一个binder对象相对buffer首地址的偏移</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	offsets;</span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">//数据较小的时候可以直接装在这个数组里</span></span><br><span class="line">        __u8	buf[<span class="number">8</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，真正需要拷贝的数据的地址是保存在<code>data</code>域中的，可能文字描述的<code>data</code>结构不是特别清晰，可以结合下图理解：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data.png" alt="data结构"></p>
<p>这里我用一个例子来解释一下<code>binder_transaction_data</code>传输的数据是什么样子的</p>
<p>小伙伴们应该都了解<code>Parcel</code>吧，它是一个存放读取数据的容器，我们<code>binder_transaction_data</code>中实际传输的数据就是通过它组合而成的，它可以传输基本数据类型，<code>Parcelable</code>类型和<code>binder</code>类型</p>
<p>其中基本数据类型就不用说了，每种基本类型所占用的大小是固定的，<code>Parcelable</code>类型实际上也是传输基本数据类型，它是通过实现<code>Parcelable</code>接口将一个复杂对象中的成员序列化成了一个个基本数据类型传输，而<code>binder</code>类型的传输有点特别，它会将这个<code>binder</code>对象 “压扁” 成一个<code>flat_binder_object</code>结构体传输</p>
<p>假设我们有一个客户端<code>client</code>，一个服务端<code>server</code>，<code>client</code>想要向<code>binder</code>驱动发起一个事物，调用<code>server</code>的某个方法，我们该怎么构建<code>binder_transaction_data</code>的数据区呢？</p>
<p>一般来说，我们需要先写一个<code>token</code>，这个<code>token</code>是为了进行校验的，两端需要保持一致。接着我们需要按顺序依次写入参数，假设我们想要调用<code>server</code>的<code>callMe(int, Parcelable, IBinder)</code>函数，那我们就需要先写入一个<code>int</code>，再写入一个<code>Parcelable</code>，最后再将<code>IBinder</code> “压扁” 成一个<code>flat_binder_object</code>写入。</p>
<p>此时数据布局如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data2.png" alt="data结构"></p>
<p>从图中我们可以看出来，<code>offsets</code>指示出了<code>buffer</code>中传输的<code>binder</code>对象的位置，有几个<code>binder</code>对象，就会有几个<code>offset</code>与之对应</p>
<h5 id="transaction-flags"><a href="#transaction-flags" class="headerlink" title="transaction_flags"></a>transaction_flags</h5><p>我们再看一下有哪些事务标志，他们分别代表什么意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> transaction_flags &#123;</span><br><span class="line">    <span class="comment">//单向调用，异步操作，无返回</span></span><br><span class="line">    TF_ONE_WAY	        = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个组件的根对象，对应类型为本地binder</span></span><br><span class="line">    TF_ROOT_OBJECT	= <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个32位的状态码，对应类型为远程binder引用的句柄</span></span><br><span class="line">    TF_STATUS_CODE	= <span class="number">0x08</span>,</span><br><span class="line">    <span class="comment">//可以接收一个文件描述符，对应的类型为文件（BINDER_TYPE_FD），即handle中存储的为文件描述符</span></span><br><span class="line">    TF_ACCEPT_FDS	= <span class="number">0x10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-transaction结构体"><a href="#binder-transaction结构体" class="headerlink" title="binder_transaction结构体"></a>binder_transaction结构体</h4><p><code>binder_transaction</code>结构体用来描述进程间通信过程（事务），它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="comment">//用来描述需要处理的工作事项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="comment">//发起事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line">    <span class="comment">//事务所依赖的另一个事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="comment">//目标线程下一个需要处理的事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="comment">//1: 表示同步事务，需要等待对方回复</span></span><br><span class="line">    <span class="comment">//0: 表示异步事务</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向为该事务分配的内核缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	flags;</span><br><span class="line">    <span class="comment">//发起事务线程的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">priority</span>;</span></span><br><span class="line">    <span class="comment">//线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求</span></span><br><span class="line">    <span class="comment">//在修改之前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">saved_priority</span>;</span></span><br><span class="line">    <span class="keyword">bool</span>    set_priority_called;</span><br><span class="line">    <span class="keyword">kuid_t</span>	sender_euid;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> security_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-work结构体"><a href="#binder-work结构体" class="headerlink" title="binder_work结构体"></a>binder_work结构体</h4><p><code>binder_work</code>结构体用来描述需要处理的工作事项，它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> &#123;</span></span><br><span class="line">    <span class="comment">//双向链表中的一个节点，这个链表储存了所有的binder_work</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作项类型</span></span><br><span class="line">    <span class="keyword">enum</span> binder_work_type &#123;</span><br><span class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</span><br><span class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</span><br><span class="line">        BINDER_WORK_RETURN_ERROR,</span><br><span class="line">        BINDER_WORK_NODE,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</span><br><span class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</span><br><span class="line">    &#125; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>简单看完了一些必要的结构体后，我们把目光转回<code>binder_transaction</code>函数上</p>
<p><code>binder_transaction</code>函数的代码很长，我们精简一下，然后再分段来看，从整体上，我们可以将它分为几个部分：</p>
<ol>
<li>获得目标进程/线程信息</li>
<li>将数据拷贝到目标进程所映射的内存中（此时会建立实际的映射关系）</li>
<li>将待处理的任务加入<code>todo</code>队列，唤醒目标线程</li>
</ol>
<h4 id="第一部分：获得目标进程-线程信息"><a href="#第一部分：获得目标进程-线程信息" class="headerlink" title="第一部分：获得目标进程/线程信息"></a>第一部分：获得目标进程/线程信息</h4><p>这里根据是否为<code>reply</code>，分成了两种情况</p>
<h5 id="BC-TRANSACTION"><a href="#BC-TRANSACTION" class="headerlink" title="BC_TRANSACTION"></a>BC_TRANSACTION</h5><p>我们先看<code>BC_TRANSACTION</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line"></span><br><span class="line">            binder_proc_lock(proc);</span><br><span class="line">            <span class="comment">//查找binder引用</span></span><br><span class="line">            ref = binder_get_ref_olocked(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">            target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                    ref-&gt;node, &amp;target_proc,</span><br><span class="line">                    &amp;return_error);</span><br><span class="line">            binder_proc_unlock(proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//handle为0代表目标target是ServiceManager</span></span><br><span class="line">            mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="comment">//ServiceManager为binder驱动的context，所以可以直接从context中获取binder实体</span></span><br><span class="line">            target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">            <span class="keyword">if</span> (target_node)</span><br><span class="line">                <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">                target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                        target_node, &amp;target_proc,</span><br><span class="line">                        &amp;return_error);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                return_error = BR_DEAD_REPLY;</span><br><span class="line">            mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="keyword">if</span> (target_node &amp;&amp; target_proc == proc) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//使用LSM进行安全检查</span></span><br><span class="line">        <span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk,</span><br><span class="line">                        target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//flags不带TF_ONE_WAY（即需要reply）并且当前线程存在binder事务栈</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找一个合适的目标binder线程</span></span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">                spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">                from = tmp-&gt;from;</span><br><span class="line">                <span class="keyword">if</span> (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">                    atomic_inc(&amp;from-&gt;tmp_ref);</span><br><span class="line">                    target_thread = from;</span><br><span class="line">                    spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然整个函数很长很复杂，但经过我们的拆分精简，逻辑就清晰很多了</p>
<p><code>binder_transaction_data.target.handle</code>用一个<code>int</code>值表示目标<code>binder</code>引用，当它不为0时，调用<code>binder_get_ref_olocked</code>函数查找<code>binder_ref</code></p>
<h6 id="binder-get-ref-olocked"><a href="#binder-get-ref-olocked" class="headerlink" title="binder_get_ref_olocked"></a>binder_get_ref_olocked</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_ref *<span class="title">binder_get_ref_olocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                         u32 desc, <span class="keyword">bool</span> need_strong_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">proc</span>-&gt;<span class="title">refs_by_desc</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"tried to use weak ref as strong ref\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个函数就是从<code>binder_proc.refs_by_desc</code>这个红黑树中，通过<code>desc</code>句柄查找到对应的<code>binder</code>引用<code>binder_ref</code>，这样就可以通过<code>binder_ref.node</code>获得到<code>binder</code>实体<code>binder_node</code></p>
<p>接着再调用<code>binder_get_node_refs_for_txn</code>函数通过目标<code>binder</code>实体获取目标进程信息</p>
<h6 id="binder-get-node-refs-for-txn"><a href="#binder-get-node-refs-for-txn" class="headerlink" title="binder_get_node_refs_for_txn"></a>binder_get_node_refs_for_txn</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_get_node_refs_for_txn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc **procp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_node_inner_lock(node);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc) &#123;</span><br><span class="line">        target_node = node;</span><br><span class="line">        <span class="comment">//binder_node强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//binder_node临时引用计数加1</span></span><br><span class="line">        binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">        <span class="comment">//binder_proc临时引用计数加1</span></span><br><span class="line">        atomic_inc(&amp;node-&gt;proc-&gt;tmp_ref);</span><br><span class="line">        <span class="comment">//使外部传入的proc指针指向binder_proc地址</span></span><br><span class="line">        *procp = node-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *error = BR_DEAD_REPLY;</span><br><span class="line">    binder_node_inner_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数第二个参数接受一个<code>binder_proc **</code>类型，即指向指针的指针，调用方对<code>proc</code>取地址，即指向<code>proc</code>指针分配在栈上的地址，这样函数中对<code>procp</code>解引用就得到了<code>proc</code>指针本身的地址，即可使<code>proc</code>指针指向<code>binder_proc</code>的地址</p>
<p>当<code>binder_transaction_data.target.handle</code>为0时，表示目标是<code>ServiceManager</code>，而<code>ServiceManager</code>是<code>binder</code>驱动的<code>context</code>，所以可以直接从<code>context</code>中获取<code>binder</code>实体，关于<code>ServiceManager</code>是怎么成为<code>binder</code>驱动的<code>context</code>的，我们会在后面的章节进行分析</p>
<p>接下来做一下安全检查，当<code>flags</code>不带<code>TF_ONE_WAY</code>（即需要<code>reply</code>）并且当前线程存在<code>binder</code>事务栈时，寻找一个合适的目标<code>binder</code>工作线程用来处理此事务（线程复用）</p>
<p>这里<code>client</code>端可能是第一次请求服务，此时<code>binder_thread</code>里是不存在<code>binder</code>事务栈，所以是没法找到目标<code>binder</code>线程的</p>
<h5 id="BC-REPLY"><a href="#BC-REPLY" class="headerlink" title="BC_REPLY"></a>BC_REPLY</h5><p>接着，我们再看<code>BC_REPLY</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//这个事务是发起事务，也就是说我们需要对这个事务做应答</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改指向下一个需要处理的事务，即将这个事务移出链表</span></span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//目标线程即为需要回应的事务的发起线程</span></span><br><span class="line">        target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过binder_thread获得binder_proc</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">        atomic_inc(&amp;target_proc-&gt;tmp_ref);</span><br><span class="line">        binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_txn_from_and_acq_inner</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_transaction *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于 from = t-&gt;from; 内部加了锁和引用计数操作</span></span><br><span class="line">    from = binder_get_txn_from(t);</span><br><span class="line">    <span class="keyword">if</span> (!from)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_inner_proc_lock(from-&gt;proc);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">        BUG_ON(from != t-&gt;from);</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_inner_proc_unlock(from-&gt;proc);</span><br><span class="line">    binder_thread_dec_tmpref(from);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BC_REPLY</code>获取目标进程/线程信息就更简单了，<code>BC_TRANSACTION</code>中我们还需要根据<code>binder</code>句柄来获取各种信息，<code>BC_REPLY</code>我们只需要找到需要回应的那个事务，那个事务所在的线程和进程即为<code>reply</code>事务的目标线程和目标进程</p>
<h4 id="第二部分：数据拷贝，建立映射"><a href="#第二部分：数据拷贝，建立映射" class="headerlink" title="第二部分：数据拷贝，建立映射"></a>第二部分：数据拷贝，建立映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> *offp, *off_end, *off_start;</span><br><span class="line">    <span class="keyword">binder_size_t</span> off_min;</span><br><span class="line">    u8 *sg_bufp, *sg_buf_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span></span></span><br><span class="line"><span class="class">    <span class="title">u32</span> <span class="title">secctx_sz</span> = 0;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标进程binder事务分配空间（后续会加到目标进程/线程的todo队列中，由目标进程/线程处理这个事务）</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = t_debug_id;</span><br><span class="line">    <span class="comment">//设置事务发起线程</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">    <span class="comment">//设置事务处理进程</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">//设置事务处理线程</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">        binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        <span class="comment">/* Inherit supported policies for synchronous transactions */</span></span><br><span class="line">        t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">        t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Otherwise, fall back to the default priority */</span></span><br><span class="line">        t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全相关</span></span><br><span class="line">    <span class="keyword">if</span> (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配缓存，建立映射</span></span><br><span class="line">    t-&gt;<span class="built_in">buffer</span> = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">        !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;transaction = t;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;target_node = target_node;</span><br><span class="line">    </span><br><span class="line">    off_start = (<span class="keyword">binder_size_t</span> *)(t-&gt;<span class="built_in">buffer</span>-&gt;data +</span><br><span class="line">                      ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    offp = off_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是真正的一次复制</span></span><br><span class="line">    copy_from_user(t-&gt;<span class="built_in">buffer</span>-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.<span class="built_in">buffer</span>, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据对齐</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(extra_buffers_size, <span class="keyword">sizeof</span>(u64))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">    sg_bufp = (u8 *)(PTR_ALIGN(off_end, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    sg_buf_end = sg_bufp + extra_buffers_size -</span><br><span class="line">        ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    off_min = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环遍历每一个binder对象</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> object_size = binder_validate_object(t-&gt;<span class="built_in">buffer</span>, *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object_size == <span class="number">0</span> || *offp &lt; off_min) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hdr = (struct binder_object_header *)(t-&gt;<span class="built_in">buffer</span>-&gt;data + *offp);</span><br><span class="line">        off_min = *offp + object_size;</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">        <span class="comment">//需要对binder类型进行转换</span></span><br><span class="line">        <span class="comment">//因为在A进程中为本地binder对象，对于B进程则为远程binder对象，反之亦然</span></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_PTR: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置工作类型</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">//设置目标进程的事务类型</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这一部分再细分成几个部分：</p>
<ol>
<li>分配缓存，建立映射</li>
<li>数据拷贝</li>
<li><code>binder</code>类型转换</li>
</ol>
<h5 id="分配缓存，建立映射"><a href="#分配缓存，建立映射" class="headerlink" title="分配缓存，建立映射"></a>分配缓存，建立映射</h5><p>我们首先看分配缓存，建立映射是怎么做的，它调用了<code>binder_alloc_new_buf</code>函数，这个函数定义在<code>drivers/android/binder_alloc.c</code>中，内部加了锁后调用了<code>binder_alloc_new_buf_locked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_buffer *<span class="title">binder_alloc_new_buf_locked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> data_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> offsets_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> extra_buffers_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> is_async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">alloc</span>-&gt;<span class="title">free_buffers</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">best_fit</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *has_page_addr;</span><br><span class="line">    <span class="keyword">void</span> *end_page_addr;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, data_offsets_size;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc-&gt;vma == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要的缓冲区大小</span></span><br><span class="line">    <span class="comment">//这里需要将size对齐void *（32位下占用4字节，64位下占用8字节）</span></span><br><span class="line">    data_offsets_size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</span><br><span class="line">        ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = data_offsets_size + ALIGN(extra_buffers_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">max</span>(<span class="built_in">size</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder_alloc的空闲缓冲红黑树中找到一个大小最合适的binder_buffer</span></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="comment">//当找到一个需求大小和缓存区大小刚好相同的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer就正好指向这个空闲缓存区</span></span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">        BUG_ON(!<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span>);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当只找到一个比需求大小稍大一点的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer指向的是这个空闲缓存区所在节点的父节点</span></span><br><span class="line">        <span class="comment">//然后n指向NULL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; buffer_size) &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &gt; buffer_size)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (best_fit == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时buffer指向的是所需求的空闲缓存区所在红黑树节点的父节点</span></span><br><span class="line">    <span class="comment">//需要让其指向真正需求的那个空闲缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出buffer的终点，向下对齐（不能超过可用的buffer_size）</span></span><br><span class="line">    has_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)(((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">    WARN_ON(n &amp;&amp; buffer_size != <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//计算出实际上我们接收数据需要的空间的终点，向上映射</span></span><br><span class="line">    end_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//如果超出了可用的buffer_size，恢复到正常可用的结束地址</span></span><br><span class="line">    <span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</span><br><span class="line">        end_page_addr = has_page_addr;</span><br><span class="line">    <span class="comment">//分配物理页，建立映射</span></span><br><span class="line">    ret = binder_update_page_range(alloc, <span class="number">1</span>,</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data), end_page_addr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有空余空间的话，分隔这个buffer，剩余的buffer加入到空闲缓存区红黑树中（合理利用空间）</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_size != <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span>;</span></span><br><span class="line"></span><br><span class="line">        new_buffer = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">        new_buffer-&gt;data = (u8 *)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>;</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;<span class="built_in">buffer</span>-&gt;entry);</span><br><span class="line">        new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        binder_insert_free_buffer(alloc, new_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们已经使用了这个buffer，要将其从空闲缓存区红黑树中移除</span></span><br><span class="line">    rb_erase(best_fit, &amp;alloc-&gt;free_buffers);</span><br><span class="line">    <span class="comment">//标记为非空闲</span></span><br><span class="line">    <span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//插入到已分配缓存区红黑树中</span></span><br><span class="line">    binder_insert_allocated_buffer_locked(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;data_size = data_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;offsets_size = offsets_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;async_transaction = is_async;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;extra_buffers_size = extra_buffers_size;</span><br><span class="line">    <span class="comment">//如果是异步事件, 那么更新binder_alloc的异步事件空闲buffer</span></span><br><span class="line">    <span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">        alloc-&gt;free_async_space -= <span class="built_in">size</span> + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的整体逻辑分为三个部分：</p>
<ol>
<li>找到可用的空闲内核缓存区，计算我们需要分配的大小</li>
<li>分配物理页，建立映射</li>
<li>初始化新分配的<code>buffer</code></li>
</ol>
<p>其中1、3部分已经用注释标出来了，应该还是比较好理解的，我们终点看一下第2部分：怎么分配物理页，建立映射</p>
<p>我们在上一章<a href="https://juejin.cn/post/7062654742329032740#heading-16" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中说到，<code>binder_mmap</code>并没有立即将内核虚拟内存和进程虚拟内存与物理内存做映射，实际上这个映射操作是在<code>binder_update_page_range</code>这里做的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_alloc *alloc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_lru_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> need_mm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= start)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_range;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否有页框需要分配</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE];</span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            need_mm = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向目标用户进程的内存空间描述体</span></span><br><span class="line">    <span class="keyword">if</span> (need_mm &amp;&amp; atomic_inc_not_zero(&amp;alloc-&gt;vma_vm_mm-&gt;mm_users))</span><br><span class="line">        mm = alloc-&gt;vma_vm_mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//获取mm_struct的读信号量</span></span><br><span class="line">        down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="comment">//检查mm是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!mmget_still_valid(mm)) &#123;</span><br><span class="line">            <span class="comment">//释放</span></span><br><span class="line">            <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> free_range;</span><br><span class="line">            <span class="comment">//错误</span></span><br><span class="line">            <span class="keyword">goto</span> err_no_vma;</span><br><span class="line">        &#125;</span><br><span class="line">        vma = alloc-&gt;vma;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma &amp;&amp; need_mm) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">bool</span> on_lru;</span><br><span class="line">        <span class="keyword">size_t</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向对应页框地址，为后面赋值做准备</span></span><br><span class="line">        index = (page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE;</span><br><span class="line">        page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//page-&gt;page_ptr不为NULL说明之前已经分配并映射过了</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;page_ptr) &#123;</span><br><span class="line">            on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配一个页的物理内存</span></span><br><span class="line">        page-&gt;page_ptr = alloc_page(GFP_KERNEL |</span><br><span class="line">                        __GFP_HIGHMEM |</span><br><span class="line">                        __GFP_ZERO);</span><br><span class="line">        <span class="comment">//未分配成功</span></span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        page-&gt;alloc = alloc;</span><br><span class="line">        INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将物理内存空间映射到内核虚拟内存空间</span></span><br><span class="line">        ret = map_kernel_range_noflush((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                           PAGE_SIZE, PAGE_KERNEL,</span><br><span class="line">                           &amp;page-&gt;page_ptr);</span><br><span class="line">        flush_cache_vmap((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr + PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据之前计算的user_buffer_offset可以直接得到目标用户空间进程虚拟内存地址</span></span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + alloc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">//将物理内存空间映射到目标用户进程虚拟内存空间</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>].page_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &gt; alloc-&gt;pages_high)</span><br><span class="line">            alloc-&gt;pages_high = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//释放mm_struct的读信号量</span></span><br><span class="line">        up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释写的应该比较清楚了，总之就是先分配<code>物理内存</code>，再将这块<code>物理内存</code>分别映射到<code>内核虚拟空间</code>和<code>用户进程虚拟空间</code>，这样<code>内核虚拟空间</code>与<code>用户进程虚拟空间</code>相当于也间接的建立了映射关系</p>
<p>关于物理内存的分配以及映射，就是<code>Linux</code>内核层的事情了，感兴趣的同学可以再深入往里看看，这里就不再多说了</p>
<h5 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h5><p>关于数据拷贝这部分就不用多说了，物理内存已经分配好了，映射也建立了，接下来直接调用<code>copy_from_user</code>将数据从用户空间拷贝至映射的那块内存就可以了</p>
<h5 id="binder类型转换"><a href="#binder类型转换" class="headerlink" title="binder类型转换"></a>binder类型转换</h5><p>最后循环遍历每一个<code>binder</code>对象，对其中每一个<code>binder</code>对象类型做转换，因为在一个进程中为本地<code>binder</code>对象，对于另一个进程则为远程<code>binder</code>对象，反之亦然</p>
<h6 id="flat-binder-object结构体"><a href="#flat-binder-object结构体" class="headerlink" title="flat_binder_object结构体"></a>flat_binder_object结构体</h6><p>这里就是我们之前提到的，<code>binder</code>对象在传输过程中会被 “压扁” 的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    <span class="comment">//描述了binder对象的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span>	<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="comment">//和binder_transaction_data中flags含义相同</span></span><br><span class="line">    __u32				flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_BINDER时，表示是一个binder实体对象，指向binder实体在用户空间的地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span>	binder;	<span class="comment">/* local object */</span></span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_HANDLE，表示是一个binder引用句柄</span></span><br><span class="line">        __u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////当hdr.type == BINDER_TYPE_BINDER时才有值，表示携带的额外数据</span></span><br><span class="line">    <span class="comment">/* extra data associated with local object */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-binder"><a href="#binder-translate-binder" class="headerlink" title="binder_translate_binder"></a>binder_translate_binder</h6><p><code>BINDER_TYPE_BINDER</code>表示是一个<code>binder</code>实体对象，需要将它转换成<code>binder</code>引用句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过proc-&gt;nodes.rb_node红黑树查找binder_node</span></span><br><span class="line">    node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">    <span class="comment">//如果没有找到，新建一个binder_node并将其插入红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = binder_new_node(proc, fp);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找binder_ref并将其引用计数加1，如果没有查找到则创建一个，并将其插入红黑树</span></span><br><span class="line">    ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">            &amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换binder类型</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//binder引用句柄赋值</span></span><br><span class="line">    fp-&gt;handle = rdata.desc;</span><br><span class="line">    fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-handle"><a href="#binder-translate-handle" class="headerlink" title="binder_translate_handle"></a>binder_translate_handle</h6><p><code>BINDER_TYPE_HANDLE</code>表示是一个<code>binder</code>引用句柄，，需要将它转换成<code>binder</code>实体对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_handle</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">src_rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从proc-&gt;refs_by_desc.rb_node红黑树中查找binder_node，并将其临时引用计数加1</span></span><br><span class="line">    node = binder_get_node_from_ref(proc, fp-&gt;handle,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    <span class="comment">//如果binder实体所在的进程为事务处理进程</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc == target_proc) &#123;</span><br><span class="line">        <span class="comment">//binder类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_HANDLE)</span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">        fp-&gt;binder = node-&gt;ptr;</span><br><span class="line">        fp-&gt;cookie = node-&gt;cookie;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_lock(node-&gt;proc);</span><br><span class="line">        <span class="comment">//binder强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node,</span><br><span class="line">                     fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">                     <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_unlock(node-&gt;proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//重新查找binder_ref</span></span><br><span class="line">        struct binder_ref_data dest_rdata;</span><br><span class="line"></span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">                fp-&gt;hdr.type == BINDER_TYPE_HANDLE,</span><br><span class="line">                <span class="literal">NULL</span>, &amp;dest_rdata);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">        fp-&gt;handle = dest_rdata.desc;</span><br><span class="line">        fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三部分：加入todo队列，唤醒目标线程"><a href="#第三部分：加入todo队列，唤醒目标线程" class="headerlink" title="第三部分：加入todo队列，唤醒目标线程"></a>第三部分：加入todo队列，唤醒目标线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;    <span class="comment">//如果请求码为BC_REPLY</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        binder_inner_proc_lock(target_proc);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">            binder_inner_proc_unlock(target_proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将发起事务从目标binder线程的事务链表中移除</span></span><br><span class="line">        binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">        binder_inner_proc_unlock(target_proc);</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">        <span class="comment">//恢复发起事务的优先级</span></span><br><span class="line">        binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">        <span class="comment">//释放发起事务</span></span><br><span class="line">        binder_free_transaction(in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且不为异步操作，需要返回</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中（这里会延迟执行BINDER_WORK_TRANSACTION_COMPLETE）</span></span><br><span class="line">        binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">        <span class="comment">//设置为需要回应</span></span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//插入事务链表中</span></span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标线程的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">            binder_inner_proc_lock(proc);</span><br><span class="line">            <span class="comment">//出错后，移除该事务</span></span><br><span class="line">            binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且为异步操作，不需要返回</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标进程的某个线程（或目标进程）的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减临时引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread)</span><br><span class="line">        binder_thread_dec_tmpref(target_thread);</span><br><span class="line">    binder_proc_dec_tmpref(target_proc);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_dec_node_tmpref(target_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一块的代码基本上格式都是一样的，都是将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，<code>t-&gt;work</code>插入到目标<code>binder</code>线程的<code>todo</code>队列中，最后唤醒目标进程</p>
<p>这里需要注意的是，在<code>BC_TRANSACTION</code>的情况下，需要区分事务的<code>flags</code>中是否包含<code>TF_ONE_WAY</code>，这意味着这个事务是否需要回应</p>
<p>在没有<code>TF_ONE_WAY</code>的情况下，会使用<code>binder_enqueue_deferred_thread_work_ilocked</code>函数将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，这个函数区别于<code>binder_enqueue_thread_work_ilocked</code>函数，它没有将<code>thread-&gt;process_todo</code>设为<code>true</code>，这个标记在之前介绍<code>binder_thread</code>结构体的时候提到了，当其为<code>false</code>的情况下会在<code>binder_thread_read</code>中休眠，延迟执行<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，具体是怎么操作的，我们会在后续的<code>binder_thread_read</code>函数中进行分析</p>
<p>在<code>TF_ONE_WAY</code>的情况下，我们是没有去寻找合适的目标处理<code>binder</code>线程的，关于这一点，我们需要看一下<code>binder_proc_transaction</code>函数是怎么处理没有传入<code>binder_thread</code>的情况的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_proc_transaction</span><span class="params">(struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    <span class="keyword">bool</span> pending_async = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    node_prio.prio = node-&gt;min_priority;</span><br><span class="line">    node_prio.sched_policy = node-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了TF_ONE_WAY标志</span></span><br><span class="line">    <span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;has_async_transaction) &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象正在处理一个异步事务，做一个标记</span></span><br><span class="line">            pending_async = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象没有正在处理一个异步事务，将has_async_transaction置为true，表示接下来要处理一个异步任务</span></span><br><span class="line">            node-&gt;has_async_transaction = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标进程死亡或者目标线程不为NULL且死亡</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有传入目标线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!thread &amp;&amp; !pending_async)</span><br><span class="line">        <span class="comment">//从proc-&gt;waiting_threads链表中取出第一个节点元素（没有的话则为NULL）</span></span><br><span class="line">        thread = binder_select_thread_ilocked(proc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;    <span class="comment">//当找到了合适的binder线程</span></span><br><span class="line">        <span class="comment">//设置事务优先级</span></span><br><span class="line">        binder_transaction_priority(thread-&gt;task, t, node_prio,</span><br><span class="line">                        node-&gt;inherit_rt);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_async) &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder进程的todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder实体的async_todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!pending_async)</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        binder_wakeup_thread_ilocked(proc, thread, !oneway <span class="comment">/* sync */</span>);</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    binder_node_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有传入目标<code>binder</code>线程时，从目标进程的等待线程链表中取出第一个<code>binder_thread</code>作为处理线程处理该事务，如果没找到合适的空闲线程，分为两种情况：</p>
<ol>
<li>目标<code>binder</code>实体对象正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>实体的<code>async_todo</code>队列中</li>
<li>目标<code>binder</code>实体对象没有正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>进程的<code>todo</code>队列中</li>
</ol>
<p>关于<code>binder</code>驱动是怎么从这些<code>todo</code>队列取出<code>binder_work</code>并处理的，我们马上在后面<code>binder_thread_read</code>里分析，这里我们最后再看一下如何唤醒目标<code>binder</code>线程的等待队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_thread_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert_spin_locked(&amp;proc-&gt;inner_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sync)</span><br><span class="line">            wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有找到一个可用的等待线程，可能在两种情况下发生：</span></span><br><span class="line">    <span class="comment">//1. 所有线程都忙于处理事务</span></span><br><span class="line">    <span class="comment">//在这种情况下，这些线程中的一个应该很快回调到内核驱动程序并执行这项工作</span></span><br><span class="line">    <span class="comment">//2. 线程正在使用epoll轮询，在这种情况下，它们可能在没有被添加到waiting_threads的情况下被阻塞在等待队列上</span></span><br><span class="line">    <span class="comment">//对于这种情况，我们只循环获取所有不处理事务工作的线程，并将它们全部唤醒</span></span><br><span class="line">    binder_wakeup_poll_threads_ilocked(proc, sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数也有可能<code>binder_thread</code>参数传入NULL，在这种情况下，我们需要循环获取目标进程下的所有<code>binder</code>线程，对所有不处理事务工作的线程全部执行唤醒操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_poll_threads_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;threads); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        thread = rb_entry(n, struct binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_POLL &amp;&amp;</span><br><span class="line">            binder_available_for_proc_work_ilocked(thread)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sync)</span><br><span class="line">                wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经分析了<code>binder_ioctl</code>函数的一半<code>binder_thread_write</code>，了解了一些相关的数据结构，并且补充了<code>binder_mmap</code>篇未完成的内存映射的分析，大家应该对<code>binder</code>请求的发起与调度有了一个初步的认识了</p>
<p>本来这一篇是打算把整个<code>binder_ioctl</code>分析完的，但没想到写到后面内容这么多，只好再分一篇，下一篇我们将分析<code>binder_thread_read</code>，将<code>binder</code>驱动篇完结</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/Binder/">Binder</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/01/android/stub/AndroidASM%E6%8F%92%E6%A1%A9/"><i class="fa fa-chevron-left">  </i><span>Android ASM插桩</span></a></div><div class="next-post pull-right"><a href="/2022/02/09/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/"><span>Android源码分析 - Binder驱动（上）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>