<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Framework层的Binder（客户端篇）"><meta name="keywords" content="Android源码,Binder"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Framework层的Binder（客户端篇） | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ServiceManager"><span class="toc-number">2.</span> <span class="toc-text">ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#getIServiceManager"><span class="toc-number">2.1.</span> <span class="toc-text">getIServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BinderInternal-getContextObject"><span class="toc-number">2.1.1.</span> <span class="toc-text">BinderInternal.getContextObject</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ProcessState"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">ProcessState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#javaObjectForIBinder"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">javaObjectForIBinder</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServiceManagerNative-asInterface"><span class="toc-number">2.1.2.</span> <span class="toc-text">ServiceManagerNative.asInterface</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServiceManagerProxy"><span class="toc-number">2.2.</span> <span class="toc-text">ServiceManagerProxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IServiceManager"><span class="toc-number">2.3.</span> <span class="toc-text">IServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Parcel"><span class="toc-number">2.3.1.</span> <span class="toc-text">Parcel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BinderProxy-transact"><span class="toc-number">2.4.</span> <span class="toc-text">BinderProxy.transact</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BpBinder-transact"><span class="toc-number">2.5.</span> <span class="toc-text">BpBinder.transact</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPCThreadState"><span class="toc-number">2.6.</span> <span class="toc-text">IPCThreadState</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transact"><span class="toc-number">2.6.1.</span> <span class="toc-text">transact</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#writeTransactionData"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">writeTransactionData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitForResponse"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">waitForResponse</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#talkWithDriver"><span class="toc-number">2.6.1.2.1.</span> <span class="toc-text">talkWithDriver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#处理Reply"><span class="toc-number">2.6.1.2.2.</span> <span class="toc-text">处理Reply</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#freeBuffer"><span class="toc-number">2.6.1.2.3.</span> <span class="toc-text">freeBuffer</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">3.</span> <span class="toc-text">结束</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Framework层的Binder（客户端篇）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Binder/">Binder</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以<code>aosp</code>分支<code>android-11.0.0_r25</code>作为基础解析</strong></p>
<p>我们在之前的文章中，从驱动层面分析了<code>Binder</code>是怎样工作的，但<code>Binder</code>驱动只涉及传输部分，待传输对象是怎么产生的呢，这就是<code>framework</code>层的工作了。我们要彻底了解<code>Binder</code>的工作原理，不仅要去看驱动层，还得去看<code>framework</code>层以及应用层（<code>AIDL</code>）</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p>我们还是以第一次见到<code>Binder</code>的地方<code>ServiceManager</code>开始分析，我们选取<code>getService</code>方法来分析（这个方法既有入参也有返回），抛除掉它缓存和<code>log</code>的部分，最核心的代码就一句<code>getIServiceManager().getService(name)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BinderInternal-getContextObject"><a href="#BinderInternal-getContextObject" class="headerlink" title="BinderInternal.getContextObject"></a>BinderInternal.getContextObject</h3><p>我们从<code>BinderInternal.getContextObject()</code>开始看起，这个函数是一个<code>native</code>函数，他被实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h4><p>我们在这里可以发现一个比较关键的类<code>ProcessState</code>，它是一个负责打开<code>binder</code>驱动并进行<code>mmap</code>映射的单例对象，这从它的<code>self</code>函数就可以看出来，每个进程只存在一个<code>ProcessState</code>实例</p>
<p>位置：<code>frameworks/native/libs/binder/ProcessState.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看它的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    <span class="comment">//打开binder驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">nullptr</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">nullptr</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>:</code>后是<code>c++</code>构造函数初始化赋值的一种语法，可以看到其中调用了<code>open_driver</code>函数打开<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开binder驱动</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//验证binder版本</span></span><br><span class="line">    <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置binder最大线程数</span></span><br><span class="line">    <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">    result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了三件事，打开<code>binder</code>驱动、验证<code>binder</code>版本、设置<code>binder</code>最大线程数，接着构造函数调用<code>mmap</code>建立<code>binder</code>映射，这里面的实现我们已经在<a href="https://juejin.cn/post/7062654742329032740" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>、<a href="https://juejin.cn/post/7069675794028560391" target="_blank" rel="noopener">（中）</a>、<a href="https://juejin.cn/post/7073783503791325214" target="_blank" rel="noopener">（下）</a>中分析过了，感兴趣的同学可以回过头去看一看</p>
<p><code>ProcessState::self</code>函数执行完后，当前进程的<code>binder</code>初始化工作已经执行完毕，接下来我们回过头来看它的<code>getContextObject</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; context = getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       ALOGW(<span class="string">"Not able to get context object on %s."</span>, mDriverName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The root object is special since we get it directly from the driver, it is never</span></span><br><span class="line">    <span class="comment">// written by Parcell::writeStrongBinder.</span></span><br><span class="line">    internal::Stability::tryMarkCompilationUnit(context.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>binder</code>驱动篇就提到了，<code>handle</code>句柄<code>0</code>代表的就是<code>ServiceManager</code>，所以这里调用<code>getStrongProxyForHandle</code>函数的参数为<code>0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找或建立handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当handle为ServiceManager的特殊情况</span></span><br><span class="line">                <span class="comment">//需要确保在创建Binder引用之前，context manager已经被binder注册</span></span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建BpBinder并保存下来以便后面再次查找</span></span><br><span class="line">            b = BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N=mHandleToObject.size();</span><br><span class="line">    <span class="comment">//新建一个handle_entry并插入到vector中</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路下来还是比较清晰的，最终获得了一个<code>BpBinder</code>对象，这是<code>native</code>中的类型，需要将它转换成<code>java</code>中的类型，这里调用了<code>javaObjectForIBinder</code>函数，位于<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the argument is a JavaBBinder, return the Java object that was used to create it.</span></span><br><span class="line"><span class="comment">// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the</span></span><br><span class="line"><span class="comment">// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.</span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="comment">// In the exception case, getInstance still took ownership of nativeData.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看一看这个<code>gBinderProxyOffsets</code>是什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binderproxy_offsets_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    <span class="comment">//指向BinderProxyNativeData的指针</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderProxyPathName);</span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, <span class="string">"getInstance"</span>,</span><br><span class="line">            <span class="string">"(JJ)Landroid/os/BinderProxy;"</span>);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice =</span><br><span class="line">            GetStaticMethodIDOrDie(env, clazz, <span class="string">"sendDeathNotice"</span>,</span><br><span class="line">                                   <span class="string">"(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V"</span>);</span><br><span class="line">    gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, <span class="string">"mNativeData"</span>, <span class="string">"J"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>gBinderProxyOffsets</code>实际上是一个用来记录一些<code>java</code>中对应类、方法以及字段的结构体，用于从<code>native</code>层调用<code>java</code>层代码</p>
<p>接下来我们看<code>javaObjectForIBinder</code>函数的具体内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个<code>IBinder</code>类型检查的判断，我看了一圈发现目前只有当<code>IBinder</code>的实际类型为<code>JavaBBinder</code>的时候会返回<code>true</code>，其他子类均返回<code>false</code>。<code>JavaBBinder</code>类继承自<code>BBinder</code>，里面保存了对<code>java</code>层<code>Binder</code>对象的引用，所以在这种情况下，直接返回里面的<code>object</code>就好了。</p>
<p>从这里可以看出，<code>native</code>层的<code>javaBBinder</code>与<code>java</code>层的<code>Binder</code>是对应关系</p>
<p>我们这里传进来的是<code>BpBinder</code>，会接着往下走</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实例化一个<code>BinderProxyNativeData</code>，将<code>Binder</code>死亡回调<code>DeathRecipientList</code>和<code>Binder</code>对象（这里为<code>BpBinder</code>）赋值给它，然后调用<code>java</code>层方法。<code>gBinderProxyOffsets</code>之前说过了，类为<code>android.os.BinderProxy</code>，方法为<code>getInstance</code>，所以这里调用的即为<code>android.os.BinderProxy.getInstance(nativeData, iBinder)</code>，<code>BinderProxy</code>的路径为<code>frameworks/base/core/java/android/os/BinderProxy.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> nativeData, <span class="keyword">long</span> iBinder)</span> </span>&#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">new</span> BinderProxy(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We're throwing an exception (probably OOME); don't drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑比较简单，以<code>iBinder</code>为 <strong>key</strong> 尝试从<code>sProxyMap</code>取出<code>BinderProxy</code>，如果取到值了就直接将它返回出去，如果没取到，用之前传进来的<code>BinderProxyNativeData</code>指针为参数实例化一个<code>BinderProxy</code>，并将其设置到<code>sProxyMap</code>中</p>
<p>从这里可以看出每一个服务的<code>BinderProxy</code>都是以单例形式存在的，并且<code>native</code>层的<code>BinderProxyNativeData</code>与<code>java</code>层的<code>BinderProxy</code>是对应关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来判断我们通过<code>BinderProxy.getInstance</code>方法获得的<code>BinderProxy</code>是不是刚刚创建出来的，如果是新建的则需要处理一下proxy计数，这里是通过对比<code>BinderProxy</code>中的<code>mNativeData</code>和我们新建出来的<code>nativeData</code>地址判断的</p>
<h3 id="ServiceManagerNative-asInterface"><a href="#ServiceManagerNative-asInterface" class="headerlink" title="ServiceManagerNative.asInterface"></a>ServiceManagerNative.asInterface</h3><p>我们将目光放回<code>getIServiceManager</code>方法，现在我们知道<code>BinderInternal.getContextObject()</code>方法返回了<code>ServiceManager</code>对应的<code>BinderProxy</code>，接着会调用<code>Binder.allowBlocking</code>方法，这个方法只是改变了<code>BinderProxy</code>中的一个参数，使其允许阻塞调用，这样的话<code>getIServiceManager</code>就可以被简化成如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(<span class="comment">/* BinderProxy */</span>);</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>asInterface</code>方法实际上是直接实例化了一个<code>ServiceManagerProxy</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceManager is never local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServiceManagerProxy"><a href="#ServiceManagerProxy" class="headerlink" title="ServiceManagerProxy"></a>ServiceManagerProxy</h2><p>从名字就能听出来，<code>ServiceManagerProxy</code>其实是一个代理类，它其实是<code>IServiceManager.Stub.Proxy</code>的代理，实际上是没有什么必要的，可以发现作者也在注释中标注了<code>This class should be deleted and replaced with IServiceManager.Stub whenever mRemote is no longer used</code>，我们看一下它的构造方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    mServiceManager = IServiceManager.Stub.asInterface(remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code>实现了<code>IServiceManager</code>接口，但这个方法的实现都是直接调用<code>mServiceManager</code>，以<code>addService</code>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与直接使用<code>IServiceManager.Stub.asInterface(remote)</code>得到<code>IServiceManager</code>并没有什么区别</p>
<h2 id="IServiceManager"><a href="#IServiceManager" class="headerlink" title="IServiceManager"></a>IServiceManager</h2><p>我们将重点转到<code>IServiceManager</code>上，我们在源码中搜索不到<code>IServiceManager.java</code>文件，因为实际上这个文件是通过<code>aidl</code>生成的</p>
<p>关于<code>aidl</code>我们到后面再详细分析，现在我们只需要知道它其实是辅助我们进行<code>binder</code>通信的一种工具，<code>aidl</code>文件会在编译过程中生成出与之对应的<code>java</code>文件</p>
<p><code>IServiceManager</code>的<code>aidl</code>文件路径为<code>frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl</code></p>
<p>我们来看一下它生成出的<code>IServiceManager.Stub.asInterface</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.os.<span class="function">IServiceManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.os.IServiceManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.os.IServiceManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.os.IServiceManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们传入的<code>IBinder</code>是<code>BinderProxy</code>，它的<code>queryLocalInterface</code>永远返回<code>null</code>，所以这里返回的是<code>IServiceManager.Stub.Proxy</code>对象，我们接着看之前调用的<code>getService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p><code>Parcel</code>是一个存放读取数据的容器，它的基本功能和使用相信进阶<code>Android</code>开发应该都懂，我们在这里只介绍一些关键性函数的含义，其他就不多赘述了，有机会的话以后单独开一章分析它</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>obtain</td>
<td>获取一个新的Parcel对象</td>
</tr>
<tr>
<td>ipcData、data</td>
<td>数据区首地址</td>
</tr>
<tr>
<td>ipcDataSize、dataSize</td>
<td>数据大小</td>
</tr>
<tr>
<td>ipcObjects</td>
<td>偏移数组首地址</td>
</tr>
<tr>
<td>ipcObjectsCount</td>
<td>IPC对象数量</td>
</tr>
<tr>
<td>dataPosition</td>
<td>数据指针当前的位置</td>
</tr>
<tr>
<td>dataCapacity</td>
<td>数据区的总容量（始终 &gt;= dataSize）</td>
</tr>
</tbody></table>
<p>这里获取了两个<code>Parcel</code>，一个<code>_data</code>用来传递参数数据，一个<code>_reply</code>用来接收回应。接着，<code>_data</code>首先调用<code>writeInterfaceToken</code>方法，这里的<code>token</code>是客户端与服务端的一个协定，服务端会校验我们写入的这个<code>token</code>，然后按照顺序将参数依次写入到<code>_data</code>中（序列化），然后通过<code>binder</code>调用远程服务真正的方法，然后检查异常。</p>
<p>对于无返回值的方法来说，到这一步已经结束了，但我们这个方法是有返回值的，所以我们需要一个<code>_result</code>，从<code>_reply</code>中读取出数据（反序列化），赋给<code>_result</code>，然后返回出去</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>我们重点看<code>transact</code>这一部分，通过我们之前的分析，我们知道<code>mRemote</code>是一个<code>BinderProxy</code>类型的对象，我们来看他的<code>transact</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//检查Parcel大小</span></span><br><span class="line">    Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//trace</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Binder事务处理回调</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AppOpsManager信息记录</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result = transactNative(code, data, reply, flags);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span> &amp;&amp; !warnOnBlocking) &#123;</span><br><span class="line">            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里简化了一下代码，可以看到，首先就是对<code>Parcel</code>大小的检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkParcel</span><span class="params">(IBinder obj, <span class="keyword">int</span> code, Parcel parcel, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= <span class="number">800</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">// Trying to send &gt; 800k, this is way too much.</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(msg);</span><br><span class="line">        sb.append(<span class="string">": on "</span>);</span><br><span class="line">        sb.append(obj);</span><br><span class="line">        sb.append(<span class="string">" calling "</span>);</span><br><span class="line">        sb.append(code);</span><br><span class="line">        sb.append(<span class="string">" size "</span>);</span><br><span class="line">        sb.append(parcel.dataSize());</span><br><span class="line">        sb.append(<span class="string">" (data: "</span>);</span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">")"</span>);</span><br><span class="line">        Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android</code>默认设置了<code>Parcel</code>数据传输不能超过<strong>800k</strong>，当然，各个厂商是可以随意改动这里的代码的，如果超过了的话，便会调用<code>Slog.wtfStack</code>打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash</p>
<p>省去中间的一些<code>log</code>、回调，接下来便是调用<code>transactNative</code>方法，这是一个<code>native</code>方法，实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>, data-&gt;dataSize());</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是获得<code>native</code>层对应的<code>Parcel</code>并执行判断，<code>Parcel</code>实际上功能是在<code>native</code>中实现的，<code>java</code>中的<code>Parcel</code>类使用<code>mNativePtr</code>成员变量保存了其对应<code>native</code>中的<code>Parcel</code>的指针</p>
<p>然后调用<code>getBPNativeData</code>函数获得<code>BinderProxy</code>在<code>native</code>中对应的<code>BinderProxyNativeData</code>，再通过里面的<code>mObject</code>域成员变量得到其对应的<code>BpBinder</code>，这个函数在之前分析<code>javaObjectForIBinder</code>的时候已经出现过了</p>
<h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder.transact"></a>BpBinder.transact</h2><p>之后便是调用<code>BpBinder</code>的<code>transact</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>Alive</code>判断，可以避免对一个已经死亡的<code>binder</code>服务再发起事务，浪费资源，除此之外便是调用<code>IPCThreadState</code>的<code>transact</code>函数了</p>
<h2 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h2><p>路径：<code>frameworks/native/libs/binder/IPCThreadState.cpp</code></p>
<p>还记得我们之前提到的<code>ProcessState</code>吗？<code>IPCThreadState</code>和它很像，<code>ProcessState</code>负责打开<code>binder</code>驱动并进行<code>mmap</code>映射，而<code>IPCThreadState</code>则是负责与<code>binder</code>驱动进行具体的交互</p>
<p><code>IPCThreadState</code>也有一个<code>self</code>函数，与<code>ProcessState</code>的<code>self</code>不同的是，<code>ProcessState</code>是进程单例，而<code>IPCThreadState</code>是线程单例，我们来看看它是怎么实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不是初次调用的情况</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="comment">//初次调用，生成线程私有变量key后</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">//先从线程本地储存空间中尝试获取值</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">//没有的话就实例化一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPCThreadState shutdown后不能再获取</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首次获取时gHaveTLS为false，会先走这里</span></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">//创建一个key，作为存放线程本地变量的key</span></span><br><span class="line">        <span class="keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(<span class="string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建完毕，gHaveTLS置为true</span></span><br><span class="line">        gHaveTLS.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">//回到gHaveTLS为true的case</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gHaveTLS</code>是一个原子类型的<code>bool</code>值，它在存取过程中需要指定内存序<code>std::memory_order_xxx</code>，在这里我们直接忽略掉，把它当成一个纯粹的<code>bool</code>值就好了</p>
<p>在这里，<code>TLS</code>的全称为<code>Thread Local Storage</code>，表示线程本地储存空间，和<code>java</code>中的<code>ThreadLocal</code>其实是一个作用</p>
<p>当一个线程初次获取<code>IPCThreadState</code>的时候，会先走到<code>gHaveTLS</code>为<code>false</code>的case，此时程序会创建一个<code>key</code>，作为存放线程本地变量的<code>key</code>，创建成功后将<code>gHaveTLS</code>置为<code>true</code>，然后<code>goto</code>到<code>gHaveTLS</code>为<code>true</code>的case，此时线程本地储存空间中暂时还是没有数据的，所以会<code>new</code>一个<code>IPCThreadState</code>出来，在<code>IPCThreadState</code>的构造函数中，会将自己保存到线程本地储存空间中，这样，当线程第二次再获取<code>IPCThreadState</code>的时候，便会直接走到<code>pthread_getspecific</code>这里获取并返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">      : mProcess(ProcessState::self()),</span><br><span class="line">        mServingStackPointer(<span class="literal">nullptr</span>),</span><br><span class="line">        mServingStackPointerGuard(<span class="literal">nullptr</span>),</span><br><span class="line">        mWorkSource(kUnsetWorkSource),</span><br><span class="line">        mPropagateWorkSource(<span class="literal">false</span>),</span><br><span class="line">        mIsLooper(<span class="literal">false</span>),</span><br><span class="line">        mIsFlushing(<span class="literal">false</span>),</span><br><span class="line">        mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">        mLastTransactionBinderFlags(<span class="number">0</span>),</span><br><span class="line">        mCallRestriction(mProcess-&gt;mCallRestriction) &#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过构造函数可以发现，它调用了<code>pthread_setspecific</code>函数将自身保存在了线程本地储存空间中</p>
<p><code>IPCThreadState</code>中，成员变量<code>mIn</code>用于接收来自<code>binder</code>设备的数据，<code>mOut</code>用于储存发往<code>binder</code>设备的数据，他们的默认容量都为<code>256字节</code></p>
<h3 id="transact"><a href="#transact" class="headerlink" title="transact"></a>transact</h3><p>我们接着看它的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(data.isForRpc(), <span class="string">"Parcel constructed for RPC, but being used with binder."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;    <span class="comment">//binder事务不为TF_ONE_WAY</span></span><br><span class="line">        <span class="comment">//当线程限制binder事务不为TF_ONE_WAY时</span></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123;</span><br><span class="line">                <span class="comment">//这个限制只是log记录</span></span><br><span class="line">                ALOGE(<span class="string">"Process making non-oneway call (code: %u) but is restricted."</span>, code);</span><br><span class="line">                CallStack::logStack(<span class="string">"non-oneway call"</span>, CallStack::getCurrent(<span class="number">10</span>).get(),</span><br><span class="line">                    ANDROID_LOG_ERROR);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* FATAL_IF_NOT_ONEWAY */</span> &#123;</span><br><span class="line">                <span class="comment">//这个限制会终止线程</span></span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Process may not make non-oneway calls (code: %u)."</span>, code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在于<code>writeTransactionData</code>和<code>waitForResponse</code>，我们依次分析</p>
<h4 id="writeTransactionData"><a href="#writeTransactionData" class="headerlink" title="writeTransactionData"></a>writeTransactionData</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    <span class="comment">//目标binder句柄值，ServiceManager为0</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//数据大小</span></span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        <span class="comment">//数据区起始地址</span></span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        <span class="comment">//传递的偏移数组大小</span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//偏移数组的起始地址</span></span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里为BC_TRANSACTION</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析这个函数之前，我们需要先回忆一下在前面<code>binder</code>驱动章节我们所学习的<code>binder</code>结构和通信过程：<a href="https://juejin.cn/post/7069675794028560391#heading-13" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a></p>
<p><code>binder_tansaction</code>首先会读取一个请求码<code>cmd</code>，当<code>binder</code>请求码为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>的时候，<code>binder</code>驱动所接收的参数为<code>binder_transaction_data</code>结构体，所以在这个函数中，我们将<code>binder</code>请求码（这里为<code>BC_TRANSACTION</code>）和<code>binder_transaction_data</code>结构体依次写入到<code>mOut</code>中，为之后<code>binder_tansaction</code>做准备</p>
<h4 id="waitForResponse"><a href="#waitForResponse" class="headerlink" title="waitForResponse"></a>waitForResponse</h4><p>数据准备好后，接着便来到了<code>waitForResponse</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_ONEWAY_SPAM_SUSPECT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FROZEN_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//这里是binder服务端部分的处理，现在不需要关注</span></span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个循环，正如函数名所描述，会一直等待到一整条<code>binder</code>事务链结束返回后才会退出这个循环，在这个循环的开头，便是<code>talkWithDriver</code>方法</p>
<h5 id="talkWithDriver"><a href="#talkWithDriver" class="headerlink" title="talkWithDriver"></a>talkWithDriver</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查打开的binder设备的fd</span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">//dataPosition &gt;= dataSize说明上一次读取到的数据已经消费完</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">//需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">//将read_size设置为读缓存可用容量</span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        <span class="comment">//设置读缓存起始地址</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="comment">//没有要读写的数据就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//调用binder驱动的ioctl</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//写数据被消费了</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//写数据没有被消费完</span></span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Driver did not consume write buffer. "</span></span><br><span class="line">                                 <span class="string">"err: %s consumed: %zu of %zu"</span>,</span><br><span class="line">                                 statusToString(err).c_str(),</span><br><span class="line">                                 (<span class="keyword">size_t</span>)bwr.write_consumed,</span><br><span class="line">                                 mOut.dataSize());</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到了数据</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了</span></span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>binder_write_read</code>也是一个我们熟悉的结构，我们在之前的文章<a href="https://juejin.cn/post/7069675794028560391#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>中了解过，关于<code>binder</code>通信的代码，我们需要结合着<code>binder</code>驱动一起看才能理解</p>
<p>在<code>binder</code>驱动层中，<code>binder_ioctl_write_read</code>函数会从用户空间读取一个<code>binder_write_read</code>结构，这个结构体主要描述了数据传输的大小和位置以及消费情况（已读/写数据大小），这么看来，<code>talkWithDriver</code>函数的结构就很清晰了：</p>
<ol>
<li><p>创建出<code>binder_write_read</code>结构，根据之前的读取情况，决定是否读写数据，设置写数据内容和大小，设置读数据的空间和容量</p>
</li>
<li><p>调用<code>binder</code>驱动的<code>ioctl</code></p>
</li>
<li><p>重置写缓存，根据<code>ioctl</code>的结果设置读缓存</p>
</li>
</ol>
<p>这之后，<code>waitForResponse</code>函数就可以从读缓存<code>mIn</code>中读到数据了，我们回到这个函数中，发现它首先从读缓存中读取了一个<code>binder</code>响应码，然后根据这个响应码再处理接下来的工作</p>
<h5 id="处理Reply"><a href="#处理Reply" class="headerlink" title="处理Reply"></a>处理Reply</h5><p>在此之前，我们先回顾一下一次<code>binder_tansaction</code>的整个过程，根据事务类型，分为两种情况：</p>
<ul>
<li><code>TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_oneway.png" alt="binder_oneway"></p>
<ul>
<li><code>非 TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="binder_non_oneway"></p>
<p>我们先对照着看<code>TF_ONE_WAY</code>的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>TF_ONE_WAY</code>模式来说，客户端在收到<code>BR_TRANSACTION_COMPLETE</code>响应码后则返回，不会再等待<code>BR_REPLY</code></p>
<p>而对于非<code>TF_ONE_WAY</code>模式来说，客户端不仅会收到<code>BR_TRANSACTION_COMPLETE</code>响应码，之后还会阻塞等待<code>binder</code>驱动给它发来<code>BR_REPLY</code>响应码，这之后一次<code>binder_transaction</code>才算完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，非<code>TF_ONE_WAY</code>模式肯定是需要一个<code>reply</code>来接收的，即<code>reply != null</code>，此时我们来看看接收正常<code>reply</code>的过程（接收32位状态码没什么好说的，直接从读缓冲区中强制类型转换出一个32位的code就完事了）</p>
<p>这里我们就需要看一下<code>Parcel</code>的<code>ipcSetDataReference</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize, <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">size_t</span> objectsCount, release_func relFunc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this code uses 'mOwner == nullptr' to understand whether it owns memory</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(relFunc == <span class="literal">nullptr</span>, <span class="string">"must provide cleanup function"</span>);</span><br><span class="line">    <span class="comment">//先清理重置一下数据和状态</span></span><br><span class="line">    freeData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* kernelFields = maybeKernelFields();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(kernelFields == <span class="literal">nullptr</span>); <span class="comment">// guaranteed by freeData.</span></span><br><span class="line"></span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    kernelFields-&gt;mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects);</span><br><span class="line">    kernelFields-&gt;mObjectsSize = kernelFields-&gt;mObjectsCapacity = objectsCount;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kernelFields-&gt;mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = kernelFields-&gt;mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span> PRIu64 <span class="string">" &lt; %"</span> PRIu64 <span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* flat</span><br><span class="line">            = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData + offset);</span><br><span class="line">        <span class="keyword">uint32_t</span> type = flat-&gt;hdr.type;</span><br><span class="line">        <span class="comment">//binder类型出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||</span><br><span class="line">              type == BINDER_TYPE_FD)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个函数也不复杂，我们知道<code>binder_mmap</code>做到了一次拷贝，将数据拷贝到了内核物理内存中，然后将其与用户空间虚拟内存做了映射，所以这个函数此时只需要将数据的地址，大小等等无脑赋值进去，客户端后续便可以用<code>Parcel</code>提供的函数方便的从中读取数据了</p>
<h5 id="freeBuffer"><a href="#freeBuffer" class="headerlink" title="freeBuffer"></a>freeBuffer</h5><p>最后我们再来看一下<code>freeBuffer</code>这个释放缓冲区的方法，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::freeBuffer</span><span class="params">(Parcel* parcel, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*dataSize*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* <span class="comment">/*objects*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*objectsSize*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">nullptr</span>) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state = self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((<span class="keyword">uintptr_t</span>)data);</span><br><span class="line">    state-&gt;flushIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里向<code>binder</code>驱动发送了一个<code>BC_FREE_BUFFER</code>请求，然后<code>binder</code>驱动会负责回收这块缓冲区内存</p>
<p>我们在<code>Parcel::ipcSetDataReference</code>函数中可以发现，它将<code>freeBuffer</code>函数指针赋值给了<code>mOwner</code>，等到什么时候不需要这个<code>Parcel</code>了，便会调用这个函数进行缓冲区内存回收</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里，我们客户端与<code>binder</code>驱动沟通交互的分析就结束了，相比<code>binder</code>驱动而言，<code>framework</code>层的<code>binder</code>就好理解多了，下一章我们会从服务端的角度来看，它是怎么从<code>binder</code>驱动接收并处理客户端的请求的</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/Binder/">Binder</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Framework层的Binder（服务端篇）</span></a></div><div class="next-post pull-right"><a href="/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/"><span>Jetpack Compose入门</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>