<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Framework层的Binder（服务端篇）"><meta name="keywords" content="Android源码,Binder"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Framework层的Binder（服务端篇） | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ServiceManager"><span class="toc-number">2.</span> <span class="toc-text">ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程启动"><span class="toc-number">2.1.</span> <span class="toc-text">进程启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化Binder"><span class="toc-number">2.1.1.</span> <span class="toc-text">初始化Binder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#access"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">access</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册成为Binder驱动的context-manager"><span class="toc-number">2.1.2.</span> <span class="toc-text">注册成为Binder驱动的context manager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Looper循环处理Binder事务"><span class="toc-number">2.1.3.</span> <span class="toc-text">Looper循环处理Binder事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder事务处理"><span class="toc-number">2.2.</span> <span class="toc-text">Binder事务处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读取并处理响应"><span class="toc-number">2.2.1.</span> <span class="toc-text">读取并处理响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理响应"><span class="toc-number">2.2.2.</span> <span class="toc-text">处理响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onTransact"><span class="toc-number">2.2.3.</span> <span class="toc-text">onTransact</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实际功能实现"><span class="toc-number">2.2.4.</span> <span class="toc-text">实际功能实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reply"><span class="toc-number">2.2.5.</span> <span class="toc-text">Reply</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">3.</span> <span class="toc-text">结束</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Framework层的Binder（服务端篇）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-07-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Binder/">Binder</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>我们在上一片文章<a href="https://juejin.cn/post/7113760814409973790" target="_blank" rel="noopener">Android源码分析 - Framework层的Binder（客户端篇）</a>中，分析了客户端是怎么向服务端通过<code>binder</code>驱动发起请求，然后再接收服务端的返回的。本篇文章，我们将会以服务端的视角，分析服务端是怎么通过<code>binder</code>驱动接收客户端的请求，处理，然后再返回给客户端的。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>上篇文章我们是以<code>ServiceManager</code>作为服务端分析的，本篇文章我们还是围绕着它来做分析，它也是一个比较特殊的服务端，我们正好可以顺便分析一下它是怎么成为<code>binder</code>驱动的<code>context_manager</code>的</p>
<h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><p><code>ServiceManager</code>是在独立的进程中运行的，它是由<code>init</code>进程从<code>rc</code>文件中解析并启动的，路径为<code>frameworks/native/cmds/servicemanager/servicemanager.rc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart restart thermalservice</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>这个服务的入口函数位于<code>frameworks/native/cmds/servicemanager/main.cpp</code>的<code>main</code>函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据上面的rc文件，argc == 1, argv[0] == "/system/bin/servicemanager"</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" [binder driver]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时，要使用的binder驱动为/dev/binder</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/dev/binder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder驱动</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver);</span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>);</span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ServiceManager</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = <span class="keyword">new</span> ServiceManager(<span class="built_in">std</span>::make_unique&lt;Access&gt;());</span><br><span class="line">    <span class="comment">//将自身作为服务添加</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">"manager"</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not self register servicemanager"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置服务端Bbinder对象</span></span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(manager);</span><br><span class="line">    <span class="comment">//设置成为binder驱动的context manager</span></span><br><span class="line">    ps-&gt;becomeContextManager(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Looper epoll机制处理binder事务</span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::prepare(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line"></span><br><span class="line">    BinderCallback::setupTo(looper);</span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常走不到这里</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化Binder"><a href="#初始化Binder" class="headerlink" title="初始化Binder"></a>初始化Binder</h3><p>首先读取参数，按照之前的rc文件来看，这里的<code>driver</code>为<code>/dev/binder</code>，然后根据此<code>driver</code>初始化此进程的<code>ProcessState</code>单例，根据我们上一章的分析我们知道此时会执行<code>binder_open</code>和<code>binder_mmap</code>，接着对这个单例做一些配置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::initWithDriver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow for initWithDriver to be called repeatedly with the same</span></span><br><span class="line">        <span class="comment">// driver.</span></span><br><span class="line">        <span class="comment">//如果已经被初始化过了，并且传入的driver参数和已初始化的驱动名一样，直接返回之前初始化的单例</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(gProcess-&gt;getDriverName().c_str(), driver)) &#123;</span><br><span class="line">            <span class="keyword">return</span> gProcess;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则异常退出</span></span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"ProcessState was already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断指定的driver是否存在并可读</span></span><br><span class="line">    <span class="keyword">if</span> (access(driver, R_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder driver %s is unavailable. Using /dev/binder instead."</span>, driver);</span><br><span class="line">        <span class="comment">//回滚默认binder驱动</span></span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(driver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>文档：<a href="https://man7.org/linux/man-pages/man2/access.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/access.2.html</a></p>
<p>原型：<code>int access(const char *pathname, int mode);</code></p>
<p>这个函数是用来检查调用进程是否可以对指定文件执行某种操作的，成功返回0，失败返回-1并设置error</p>
<p><code>mode</code>参数可以为以下几个值：</p>
<ul>
<li><p><code>F_OK</code>：文件存在</p>
</li>
<li><p><code>R_OK</code>：文件可读</p>
</li>
<li><p><code>W_OK</code>：文件可写</p>
</li>
<li><p><code>X_OK</code>：文件可执行</p>
</li>
</ul>
<h3 id="注册成为Binder驱动的context-manager"><a href="#注册成为Binder驱动的context-manager" class="headerlink" title="注册成为Binder驱动的context manager"></a>注册成为Binder驱动的context manager</h3><p>接着调用了<code>ProcessState</code>的<code>becomeContextManager</code>函数注册成为<code>Binder</code>驱动的<code>context manager</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProcessState::becomeContextManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    flat_binder_object obj &#123;</span><br><span class="line">        .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback to original method</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"121035042"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> unused = <span class="number">0</span>;</span><br><span class="line">        result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to become context manager failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>binder_ioctl</code>，以<code>BINDER_SET_CONTEXT_MGR_EXT</code>为命令码请求<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">fbo</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;fbo, ubuf, <span class="keyword">sizeof</span>(fbo))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct flat_binder_object *fbo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span>;</span></span><br><span class="line">    <span class="keyword">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//binder的context manager只能设置一次</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">        pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断调用进程是否有权限设置context manager</span></span><br><span class="line">    ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//context-&gt;binder_context_mgr_uid != -1</span></span><br><span class="line">    <span class="keyword">if</span> (uid_valid(context-&gt;binder_context_mgr_uid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">            pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR bad uid %d != %d\n"</span>,</span><br><span class="line">                   from_kuid(&amp;init_user_ns, curr_euid),</span><br><span class="line">                   from_kuid(&amp;init_user_ns,</span><br><span class="line">                     context-&gt;binder_context_mgr_uid));</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置Binder驱动context manager所在进程的用户ID</span></span><br><span class="line">        context-&gt;binder_context_mgr_uid = curr_euid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建binder节点</span></span><br><span class="line">    new_node = binder_new_node(proc, fbo);</span><br><span class="line">    <span class="keyword">if</span> (!new_node) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_node_lock(new_node);</span><br><span class="line">    new_node-&gt;local_weak_refs++;</span><br><span class="line">    new_node-&gt;local_strong_refs++;</span><br><span class="line">    new_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    new_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置binder驱动context manager节点</span></span><br><span class="line">    context-&gt;binder_context_mgr_node = new_node;</span><br><span class="line">    binder_node_unlock(new_node);</span><br><span class="line">    binder_put_node(new_node);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的过程也很简单，首先检查之前是否设置过<code>context manager</code>，然后做权限校验，通过后通过<code>binder_new_node</code>创建出一个新的<code>binder</code>节点，并将它作为<code>context manager</code>节点</p>
<h3 id="Looper循环处理Binder事务"><a href="#Looper循环处理Binder事务" class="headerlink" title="Looper循环处理Binder事务"></a>Looper循环处理Binder事务</h3><p>这里的<code>Looper</code>和我们平常应用开发所说的<code>Looper</code>是一个东西，本篇就不做过多详解了，只需要知道，可以通过<code>Looper::addFd</code>函数监听文件描述符，通过<code>Looper::pollAll</code>或<code>Looper::pollOnce</code>函数接收消息，消息抵达后会回调<code>LooperCallback::handleEvent</code>函数</p>
<p>了解了这些后我们来看一下<code>BinderCallback</code>这个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;</span><br><span class="line">        sp&lt;BinderCallback&gt; cb = <span class="keyword">new</span> BinderCallback;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符</span></span><br><span class="line">        IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(binder_fd &lt; <span class="number">0</span>, <span class="string">"Failed to setupPolling: %d"</span>, binder_fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">        <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听binder文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> ret = looper-&gt;addFd(binder_fd,</span><br><span class="line">                                Looper::POLL_CALLBACK,</span><br><span class="line">                                Looper::EVENT_INPUT,</span><br><span class="line">                                cb,</span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(ret != <span class="number">1</span>, <span class="string">"Failed to add binder FD to Looper"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从binder驱动接收到消息并处理</span></span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>servicemanager</code>进程启动的过程中调用了<code>BinderCallback::setupTo</code>函数，这个函数首先想<code>binder</code>驱动发起了一个<code>BC_ENTER_LOOPER</code>事务请求，获得<code>binder</code>设备的文件描述符，然后调用<code>Looper::addFd</code>函数监听<code>binder</code>设备文件描述符，这样当<code>binder</code>驱动发来消息后，就可以通过<code>Looper::handleEvent</code>函数接收并处理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::setupPolling</span><span class="params">(<span class="keyword">int</span>* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置binder请求码</span></span><br><span class="line">    mOut.writeInt32(BC_ENTER_LOOPER);</span><br><span class="line">    <span class="comment">//检查写缓存是否有可写数据，有的话发送给binder驱动</span></span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="comment">//赋值binder驱动的文件描述符</span></span><br><span class="line">    *fd = mProcess-&gt;mDriverFD;</span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    mProcess-&gt;mCurrentThreads++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder事务处理"><a href="#Binder事务处理" class="headerlink" title="Binder事务处理"></a>Binder事务处理</h2><p><code>BinderCallback</code>类重写了<code>handleEvent</code>函数，里面调用了<code>IPCThreadState::handlePolledCommands</code>函数来接收处理<code>binder</code>事务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当读缓存中数据未消费完时，持续循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE</span></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取并处理响应"><a href="#读取并处理响应" class="headerlink" title="读取并处理响应"></a>读取并处理响应</h3><p>这个函数的重点在<code>getAndExecuteCommand</code>，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从<code>binder</code>驱动那里读写数据，只会处理剩余读缓存）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据）</span></span><br><span class="line">    result = talkWithDriver(<span class="comment">/* true */</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//读取BR响应码</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        ...</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><p>这里有很多线程等其他操作，我们不需要关心，我在这里把他们简化掉了，剩余的代码很清晰，首先从binder驱动中读取数据，然后从数据中读取出<code>BR</code>响应码，接着调用<code>executeCommand</code>函数继续往下处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX:</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data_secctx tr_secctx;</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="keyword">int</span>) BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                result = mIn.read(&amp;tr_secctx, <span class="keyword">sizeof</span>(tr_secctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据到缓冲区</span></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            <span class="comment">//对于ServiceManager的binder节点来说，是没有ptr的</span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="comment">//对于其他binder服务端来说，tr.cookie为本地BBinder对象指针</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对于ServiceManager来说，使用the_context_object这个BBinder对象</span></span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                <span class="comment">//非TF_ONE_WAY模式下需要Reply</span></span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ... <span class="comment">//TF_ONE_WAY模式下不需要Reply，这里只打了些日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点分析这个函数在<code>BR_TRANSACTION</code>下的case，其余的都删减掉</p>
<p>首先，这个函数从读缓存中读取了<code>binder_transaction_data</code>，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个<code>Parcel</code>对象作为缓冲区，从<code>binder_transaction_data</code>中将实际数据读取出来</p>
<p>接着找到本地<code>BBinder</code>对象，对于<code>ServiceManager</code>来说就是之前在<code>main</code>函数中<code>setTheContextObject</code>的<code>ServiceManager</code>对象，而对于其他<code>binder</code>服务端来说，则是通过<code>tr.cookie</code>获取，然后调用<code>BBinder</code>的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保从头开始读取数据</span></span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123;</span><br><span class="line">        <span class="comment">//标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全）</span></span><br><span class="line">        reply-&gt;markSensitive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="comment">//这里的code是由binder客户端请求传递过来的</span></span><br><span class="line">    <span class="comment">//是客户端与服务端的一个约定</span></span><br><span class="line">    <span class="comment">//它标识了客户端像服务端发起的是哪种请求</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case this is being transacted on in the same process.</span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//设置数据指针偏移为0，这样后续读取数据便会从头开始</span></span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Large reply transaction of %zu bytes, interface descriptor %s, code %d"</span>,</span><br><span class="line">                  reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onTransact"><a href="#onTransact" class="headerlink" title="onTransact"></a>onTransact</h3><p>这个函数主要调用了<code>onTransact</code>函数，它是一个虚函数，可以被子类重写。我们观察<code>ServiceManager</code>这个类，它继承了<code>BnServiceManager</code>，在<code>BnServiceManager</code>中重写了这个<code>onTransact</code>函数，它们的继承关系如下：</p>
<p><code>ServiceManager</code> -&gt; <code>BnServiceManager</code> -&gt; <code>BnInterface&lt;IServiceManager&gt;</code> -&gt; <code>IServiceManager</code> &amp; <code>BBinder</code></p>
<p>这里的<code>BnServiceManager</code>是通过<code>AIDL</code>工具生成出来的（<code>AIDL</code>既可以生成<code>Java</code>代码，也可以生成<code>C++</code>代码），我们找到一份生成后的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">BnServiceManager::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> _aidl_code, <span class="keyword">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="keyword">uint32_t</span> _aidl_flags)</span> </span>&#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _aidl_ret_status = ::android::OK;</span><br><span class="line">    <span class="keyword">switch</span> (_aidl_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> BnServiceManager::TRANSACTION_getService: &#123;</span><br><span class="line">            <span class="comment">//参数name</span></span><br><span class="line">            ::<span class="built_in">std</span>::<span class="built_in">string</span> in_name;</span><br><span class="line">            ::android::sp&lt;::android::IBinder&gt; _aidl_return;</span><br><span class="line">            <span class="comment">//类型检查</span></span><br><span class="line">            <span class="keyword">if</span> (!(_aidl_data.checkInterface(<span class="keyword">this</span>))) &#123;</span><br><span class="line">                _aidl_ret_status = ::android::BAD_TYPE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取参数name</span></span><br><span class="line">            _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确认数据已读完</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> st = _aidl_data.enforceNoDataAvail();</span><br><span class="line">            !st.isOk()) &#123;</span><br><span class="line">                _aidl_ret_status = st.writeToParcel(_aidl_reply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行真正的getService函数</span></span><br><span class="line">            ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return));</span><br><span class="line">            <span class="comment">//将状态值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_aidl_status.isOk()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将返回值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_reply-&gt;writeStrongBinder(_aidl_return);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123;</span><br><span class="line">        _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeOverParcel(_aidl_reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _aidl_ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成出的代码格式比较丑，不易阅读，我把它格式化了一下，提取出我们需要的部分。这个函数主要流程就是先从<code>data</code>中读取所需要的参数，然后根据参数执行相对应的函数，然后将状态值写入<code>reply</code>，最后再将返回值写入<code>reply</code>。这里我们将上一章节<code>AIDL</code>生成出的<code>java</code>文件那部分拿过来做对比，我们可以发现，这里<code>Parcel</code>的写入和那里<code>Parcel</code>的读取顺序是严格一一对应的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//先读取状态值</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">//再读取返回值</span></span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际功能实现"><a href="#实际功能实现" class="headerlink" title="实际功能实现"></a>实际功能实现</h3><p>然后我们来看真正功能实现的地方：<code>getService</code>函数，根据之前所说的继承关系，<code>ServiceManager</code>继承自<code>IServiceManager</code>，实现了其中的纯虚函数，其中就包括了<code>getService</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;</span><br><span class="line">    *outBinder = tryGetService(name, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// returns ok regardless of result for legacy reasons</span></span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ServiceManager::tryGetService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">bool</span> startIfNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    sp&lt;IBinder&gt; out;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//从map中寻找相应的服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = mNameToService.find(name); it != mNameToService.end()) &#123;</span><br><span class="line">        service = &amp;(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!service-&gt;allowIsolated) &#123;</span><br><span class="line">            <span class="keyword">uid_t</span> appid = multiuser_get_app_id(ctx.uid);</span><br><span class="line">            <span class="keyword">bool</span> isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isIsolated) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值指向对应service的binder对象</span></span><br><span class="line">        out = service-&gt;binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAccess-&gt;canFind(ctx, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out &amp;&amp; startIfNotFound) &#123;</span><br><span class="line">        tryStartService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out) &#123;</span><br><span class="line">        <span class="comment">// Setting this guarantee each time we hand out a binder ensures that the client-checking</span></span><br><span class="line">        <span class="comment">// loop knows about the event even if the client immediately drops the service</span></span><br><span class="line">        service-&gt;guaranteeClient = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的实现我们就没必要细看了，只需要注意它返回了相应<code>service</code>的<code>binder</code>对象，根据上面的代码来看，会将其写入到<code>reply</code>中</p>
<h3 id="Reply"><a href="#Reply" class="headerlink" title="Reply"></a>Reply</h3><p>实际的功能处理完成后，我们回到<code>IPCThreadState::executeCommand</code>中来。对于非<code>TF_ONE_WAY</code>模式，我们要将<code>reply</code>发送给请求方客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="keyword">const</span> Parcel&amp; reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">status_t</span> statusBuffer;</span><br><span class="line">    <span class="comment">//将binder reply请求打包好写入写缓冲区</span></span><br><span class="line">    err = writeTransactionData(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeTransactionData</code>在上一章中已经分析过了，这里就不多做描述了，<code>waitForResponse</code>我们上一章也分析过了，根据我们在上一章所描述的非<code>TF_ONE_WAY</code>的通信过程，在向<code>binder</code>驱动发送<code>BC_REPLY</code>请求后我们会收到<code>BR_TRANSACTION_COMPLETE</code>响应，根据我们传入<code>waitForResponse</code>的两个参数值，会直接跳出函数中的循环，结束此次<code>binder</code>通信</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="non_oneway"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//参数为两个nullptr，直接跳转到finish结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>binder</code>服务端的一次消息处理到这就结束了，<code>Looper</code>会持续监听着<code>binder</code>驱动<code>fd</code>，等待下一条<code>binder</code>消息的到来</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>经过这么多篇文章的分析，整个<code>Binder</code>架构的大致通信原理、过程，我们应该都了解的差不多了，至于一些边边角角的细节，以后有机会的话我会慢慢再补充</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/Binder/">Binder</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>Android源码分析 - Activity启动流程（上）</span></a></div><div class="next-post pull-right"><a href="/2022/06/27/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89/"><span>Android源码分析 - Framework层的Binder（客户端篇）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>