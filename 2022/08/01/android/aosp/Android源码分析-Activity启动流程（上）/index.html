<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android源码分析 - Activity启动流程（上）"><meta name="keywords" content="Android源码,ActivityThread,ActivityManagerService"><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>Android源码分析 - Activity启动流程（上） | 始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开篇"><span class="toc-number">1.</span> <span class="toc-text">开篇</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android窗口结构关系"><span class="toc-number">2.</span> <span class="toc-text">Android窗口结构关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#startActivity"><span class="toc-number">3.</span> <span class="toc-text">startActivity</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Instrumentation"><span class="toc-number">4.</span> <span class="toc-text">Instrumentation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ActivityTaskManagerSerivce"><span class="toc-number">5.</span> <span class="toc-text">ActivityTaskManagerSerivce</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ActivityStarter"><span class="toc-number">6.</span> <span class="toc-text">ActivityStarter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RootWindowContainer"><span class="toc-number">7.</span> <span class="toc-text">RootWindowContainer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ActivityStack"><span class="toc-number">8.</span> <span class="toc-text">ActivityStack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#结束"><span class="toc-number">9.</span> <span class="toc-text">结束</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Android源码分析 - Activity启动流程（上）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>作为一名<code>Android</code>开发，我们最熟悉并且最常打交道的当然非四大组件中的<code>Activity</code>莫属，这次我们就来讲讲一个<code>Activity</code>是怎样启动起来的</p>
<p>本来本篇想要讲<code>ActivityManagerService</code>的，但<code>AMS</code>中的内容过多过于繁杂，不如用这种以线及面的方式，通过<code>Activity</code>的启动流程这一条线，去了解<code>ActivityThread</code>，<code>AMS</code>等是怎么工作的</p>
<h1 id="Android窗口结构关系"><a href="#Android窗口结构关系" class="headerlink" title="Android窗口结构关系"></a>Android窗口结构关系</h1><p>在开始正式深入代码之前，我们需要先理一下<code>Android</code>的窗口结构关系，以免后面看到源码里各种<code>parent</code>、<code>child</code>头晕，我画了一张树状关系图来描述它</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-Android%E7%AA%97%E5%8F%A3%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="Android窗口结构关系"></p>
<p>上图中的所有类都是<code>WindowContainer</code>的子类，<code>WindowContainer</code>是一个窗口容器，它的<code>child</code>也是<code>WindowContainer</code>，它是用来管理窗口子容器的</p>
<p>可以先不用纠结理解这张图中的关系，顺着源码往下看，碰到不理解的地方回头看一下就可以了</p>
<h1 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h1><p>作为<code>Android</code>开发，<code>startActivity</code>这个方法一定非常熟悉，我们以这个函数作为入口来分析<code>Activity</code>的启动流程</p>
<p><code>Activity</code>和<code>ContextImpl</code>的<code>startActivity</code>方法实现不太一样，但最终都调用了<code>Instrumentation.execStartActivity</code>方法</p>
<h1 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>路径：<code>frameworks/base/core/java/android/app/Instrumentation.java</code></p>
<p>以下是Google官方对这个类功能的注释</p>
<p><em>Base class for implementing application instrumentation code.  When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application.  An Instrumentation implementation is described to the system through an AndroidManifest.xml’s &lt;instrumentation&gt; tag.</em></p>
<p>简单翻译一下，就是这个类是用于监控系统与应用的交互的（<code>onCreate</code>等生命周期会经历<code>Instrumentation</code>这么一环），它会在任何<code>App</code>代码执行前被初始化。</p>
<p>本人猜测，这个类主要存在的意义是为了给自动化测试提供一个切入点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">//记录调用者</span></span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动化测试相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//迁移额外的URI数据流到剪贴板（处理Intent使用ACTION_SEND或ACTION_SEND_MULTIPLE共享数据的情况）</span></span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        <span class="comment">//处理离开当前App进程的情况</span></span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">//请求ATMS启动Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查异常情况，抛出对应异常</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了<code>ActivityTaskManager.getService.startActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityTaskManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>getService</code>出来的很明显的是一个远程<code>binder</code>对象，我们之前已经分析过那么多<code>binder</code>知识了，以后就不再过多啰嗦了，这里实际上调用的是<code>ActivityTaskManagerSerivce</code>（以下简称<code>ATMS</code>）的<code>startActivity</code>方法</p>
<h1 id="ActivityTaskManagerSerivce"><a href="#ActivityTaskManagerSerivce" class="headerlink" title="ActivityTaskManagerSerivce"></a>ActivityTaskManagerSerivce</h1><p><code>ATMS</code>是<code>Android 10</code>以后新加的一个服务，用来专门处理<code>Activity</code>相关工作，分担<code>AMS</code>的工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*validateIncomingUser*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断言发起startActivity请求方的UID和callingPackage指向的是同一个App</span></span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    <span class="comment">//确认请求方没有被隔离</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并获取当前用户ID（多用户模式）</span></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ActivityStarter启动Activity</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller) <span class="comment">//调用方ApplicationThread</span></span><br><span class="line">            .setCallingPackage(callingPackage) <span class="comment">//调用方包名</span></span><br><span class="line">            .setCallingFeatureId(callingFeatureId) <span class="comment">// Context.getAttributionTag()</span></span><br><span class="line">            .setResolvedType(resolvedType) <span class="comment">//设置Intent解析类型</span></span><br><span class="line">            .setResultTo(resultTo) <span class="comment">//设置目标Activity Token（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setResultWho(resultWho) <span class="comment">//设置目标Activity（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setRequestCode(requestCode) <span class="comment">//设置requestCode</span></span><br><span class="line">            .setStartFlags(startFlags) <span class="comment">// startFlags == 0</span></span><br><span class="line">            .setProfilerInfo(profilerInfo) <span class="comment">// null</span></span><br><span class="line">            .setActivityOptions(bOptions) <span class="comment">//设置Activity Options Bundle</span></span><br><span class="line">            .setUserId(userId) <span class="comment">//设置用户ID</span></span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分内容都是检查，最重要的是最后一段使用<code>ActivityStarter</code>启动<code>Activity</code>，首先通过<code>ActivityStartController</code>的<code>obtainStarter</code>方法获取一个<code>ActivityStarter</code>实例，然后调用各种set方法设置参数，最后执行<code>execute</code>方法执行</p>
<h1 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h1><p>这个类从名字就能看出来，就是一个专门处理<code>Activity</code>启动的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">        <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.intent != <span class="keyword">null</span> &amp;&amp; mRequest.intent.hasFileDescriptors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LaunchingState launchingState;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">//通过Token获取调用方ActivityRecord</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo);</span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(</span><br><span class="line">                    mRequest.intent, caller);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the caller hasn't already resolved the activity, we're willing</span></span><br><span class="line">        <span class="comment">// to do so here. If the caller is already holding the WM lock here,</span></span><br><span class="line">        <span class="comment">// and we need to check dynamic Uri permissions, then we're forced</span></span><br><span class="line">        <span class="comment">// to assume those permissions are denied to avoid deadlocking.</span></span><br><span class="line">        <span class="comment">//通过Intent解析Activity信息</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.activityInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRequest.resolveActivity(mSupervisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            ... <span class="comment">//处理Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//清除Binder调用方UID和PID，用当前进程的UID和PID替代，并返回之前的UID和PID（UID：前32位，PID：后32位）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析成为重量级进程（如果设置了相关flag的话）</span></span><br><span class="line">            <span class="comment">//这里的重量级进程指的是不能保存状态的应用进程</span></span><br><span class="line">            res = resolveToHeavyWeightSwitcherIfNeeded();</span><br><span class="line">            <span class="keyword">if</span> (res != START_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行请求</span></span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复之前的Binder调用方UID和PID</span></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//更新Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify ActivityMetricsLogger that the activity has launched.</span></span><br><span class="line">            <span class="comment">// ActivityMetricsLogger will then wait for the windows to be drawn and populate</span></span><br><span class="line">            <span class="comment">// WaitResult.</span></span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res,</span><br><span class="line">                    mLastStartActivityRecord);</span><br><span class="line">            <span class="comment">//返回启动结果</span></span><br><span class="line">            <span class="keyword">return</span> getExternalResult(mRequest.waitResult == <span class="keyword">null</span> ? res</span><br><span class="line">                    : waitForResult(res, mLastStartActivityRecord));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//清理回收工作</span></span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数每一步做了什么我都用注释标出来了，大家看看就好，重点在于其中的<code>executeRequest(mRequest)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Executing activity start request and starts the journey of starting an activity. Here</span></span><br><span class="line"><span class="comment">    * begins with performing several preliminary checks. The normally activity launch flow will</span></span><br><span class="line"><span class="comment">    * go through &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125; to &#123;<span class="doctag">@link</span> #startActivityInner&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(request.reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = request.reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IApplicationThread caller = request.caller;</span><br><span class="line">    Intent intent = request.intent;</span><br><span class="line">    NeededUriGrants intentGrants = request.intentGrants;</span><br><span class="line">    String resolvedType = request.resolvedType;</span><br><span class="line">    ActivityInfo aInfo = request.activityInfo;</span><br><span class="line">    ResolveInfo rInfo = request.resolveInfo;</span><br><span class="line">    <span class="keyword">final</span> IVoiceInteractionSession voiceSession = request.voiceSession;</span><br><span class="line">    <span class="keyword">final</span> IBinder resultTo = request.resultTo;</span><br><span class="line">    String resultWho = request.resultWho;</span><br><span class="line">    <span class="keyword">int</span> requestCode = request.requestCode;</span><br><span class="line">    <span class="keyword">int</span> callingPid = request.callingPid;</span><br><span class="line">    <span class="keyword">int</span> callingUid = request.callingUid;</span><br><span class="line">    String callingPackage = request.callingPackage;</span><br><span class="line">    String callingFeatureId = request.callingFeatureId;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = request.realCallingPid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = request.realCallingUid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startFlags = request.startFlags;</span><br><span class="line">    <span class="keyword">final</span> SafeActivityOptions options = request.activityOptions;</span><br><span class="line">    Task inTask = request.inTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle =</span><br><span class="line">            options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    WindowProcessController callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方应用进程对应的WindowProcessController</span></span><br><span class="line">        <span class="comment">//这个类是用于和ProcessRecord进行通讯的</span></span><br><span class="line">        callerApp = mService.getProcessController(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//异常情况，startActivity的调用方进程不存在或未启动</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">") when starting: "</span> + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前用户ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = aInfo != <span class="keyword">null</span> &amp;&amp; aInfo.applicationInfo != <span class="keyword">null</span></span><br><span class="line">            ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</span><br><span class="line">                + <span class="string">"&#125; from uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//调用方Activity Token != null</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方ActivityRecord（要求存在任意一个Window栈中，即是RootWindow的子嗣）</span></span><br><span class="line">        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) &#123;</span><br><span class="line">            Slog.v(TAG_RESULTS, <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用方需要response</span></span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line">    <span class="comment">//多Activity传值场景</span></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到可以处理此Intent的组件</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find a class that can handle the given Intent.</span></span><br><span class="line">        <span class="comment">// That's the end of that!</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Intent中解析不出相应的Activity信息</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">null</span> : resultRecord.getRootTask();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查启动Activity的权限</span></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, callingFeatureId,</span><br><span class="line">            request.ignoreTargetSecurity, inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPackage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> restrictedBgActivity = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,</span><br><span class="line">                    <span class="string">"shouldAbortBackgroundActivityStart"</span>);</span><br><span class="line">            <span class="comment">//检查是否要限制后台启动Activity</span></span><br><span class="line">            restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,</span><br><span class="line">                    callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,</span><br><span class="line">                    request.originatingPendingIntent, request.allowBackgroundActivityStart,</span><br><span class="line">                    intent);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two options bundles, while realCallerOptions takes precedence.</span></span><br><span class="line">    <span class="comment">//过渡动画相关</span></span><br><span class="line">    ActivityOptions checkedOptions = options != <span class="keyword">null</span></span><br><span class="line">            ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        checkedOptions = mService.getActivityStartController()</span><br><span class="line">                .getPendingRemoteAnimationRegistry()</span><br><span class="line">                .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// The Intent we give to the watcher has the extra data stripped off, since it</span></span><br><span class="line">            <span class="comment">// can contain private information.</span></span><br><span class="line">            Intent watchIntent = intent.cloneFilter();</span><br><span class="line">            <span class="comment">//这个方法似乎只打印了一些日志，恒返回true，即abort |= false</span></span><br><span class="line">            abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                    aInfo.applicationInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            mService.mController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化ActivityStartInterceptor</span></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage,</span><br><span class="line">            callingFeatureId);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity start was intercepted, e.g. because the target user is currently in quiet</span></span><br><span class="line">        <span class="comment">// mode (turn off work) or the target application is suspended</span></span><br><span class="line">        <span class="comment">//拦截并转化成其他的启动模式</span></span><br><span class="line">        intent = mInterceptor.mIntent;</span><br><span class="line">        rInfo = mInterceptor.mRInfo;</span><br><span class="line">        aInfo = mInterceptor.mAInfo;</span><br><span class="line">        resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">        inTask = mInterceptor.mInTask;</span><br><span class="line">        callingPid = mInterceptor.mCallingPid;</span><br><span class="line">        callingUid = mInterceptor.mCallingUid;</span><br><span class="line">        checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The interception target shouldn't get any permission grants</span></span><br><span class="line">        <span class="comment">// intended for the original destination</span></span><br><span class="line">        intentGrants = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We pretend to the caller that it was really started, but they will just get a</span></span><br><span class="line">        <span class="comment">// cancel result.</span></span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run, we</span></span><br><span class="line">    <span class="comment">// launch the review activity and pass a pending intent to start the activity</span></span><br><span class="line">    <span class="comment">// we are to launching now after the review is completed.</span></span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果启动的Activity没有相应权限，则需要用户手动确认允许权限后，再进行启动工作</span></span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            <span class="comment">//将原来的Intent包装在新的Intent中，用这个确认权限的新Intent继续后面的启动工作</span></span><br><span class="line">            <span class="keyword">final</span> IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingFeatureId,</span><br><span class="line">                    callingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Intent newIntent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flags = intent.getFlags();</span><br><span class="line">            flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Prevent reuse of review activity: Each app needs their own review activity. By</span></span><br><span class="line"><span class="comment">                * default activities launched with NEW_TASK or NEW_DOCUMENT try to reuse activities</span></span><br><span class="line"><span class="comment">                * with the same launch parameters (extras are ignored). Hence to avoid possible</span></span><br><span class="line"><span class="comment">                * reuse force a new activity via the MULTIPLE_TASK flag.</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * Activities that are not launched with NEW_TASK or NEW_DOCUMENT are not re-used,</span></span><br><span class="line"><span class="comment">                * hence no need to add the flag in this case.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">            newIntent.setFlags(flags);</span><br><span class="line"></span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The permissions review target shouldn't get any permission</span></span><br><span class="line">            <span class="comment">// grants intended for the original destination</span></span><br><span class="line">            intentGrants = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, request.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have an ephemeral app, abort the process of launching the resolved intent.</span></span><br><span class="line">    <span class="comment">// Instead, launch the ephemeral installer. Once the installer is finished, it</span></span><br><span class="line">    <span class="comment">// starts either the intent we resolved here [on install error] or the ephemeral</span></span><br><span class="line">    <span class="comment">// app [on install success].</span></span><br><span class="line">    <span class="keyword">if</span> (rInfo != <span class="keyword">null</span> &amp;&amp; rInfo.auxiliaryInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//Instant App相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建启动Activity的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">    mLastStartActivityRecord = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.appTimeTracker == <span class="keyword">null</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller didn't specify an explicit time tracker, we want to continue</span></span><br><span class="line">        <span class="comment">// tracking under any it has.</span></span><br><span class="line">        r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶层焦点的Acticity栈</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are starting an activity that is not from the same uid as the currently resumed</span></span><br><span class="line">    <span class="comment">// one, check whether app switches are allowed.</span></span><br><span class="line">    <span class="comment">//当此时栈顶Activity UID != 调用方 UID的时候（比如悬浮窗）</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">        <span class="comment">//检查是否可以直接切换应用</span></span><br><span class="line">        <span class="comment">// 1. 设置的 mAppSwitchesAllowedTime &lt; 当前系统时间（stopAppSwitches）</span></span><br><span class="line">        <span class="comment">// 2. 调用方在最近任务中</span></span><br><span class="line">        <span class="comment">// 3. 调用方具有 STOP_APP_SWITCHES 权限</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">            <span class="comment">//加入到延时启动列表中</span></span><br><span class="line">            <span class="keyword">if</span> (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">                mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                        sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调处理延迟应用切换</span></span><br><span class="line">    mService.onStartActivitySetDidAppSwitch();</span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心：进入Activity启动的下一阶段</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.outActivity[<span class="number">0</span>] = mLastStartActivityRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分都是检查工作，这些可以看我标的注释，基本上介绍的比较详细了，然后进入到Activity启动的下一步，<code>startActivityUnchecked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity while most of preliminary checks has been done and caller has been</span></span><br><span class="line"><span class="comment">    * confirmed that holds necessary permissions to do so.</span></span><br><span class="line"><span class="comment">    * Here also ensures that the starting activity is removed if the start wasn't successful.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack startedActivityStack;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//暂停布局工作，避免重复刷新</span></span><br><span class="line">        mService.deferWindowLayout();</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="string">"startActivityInner"</span>);</span><br><span class="line">        <span class="comment">//接着把启动Activity工作交给这个方法</span></span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        <span class="comment">//进行一些更新Configuration，清理栈等收尾工作</span></span><br><span class="line">        startedActivityStack = handleStartResult(r, result);</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, startedActivityStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也不是主要逻辑所在，我们往下接着看<code>startActivityInner</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity and determine if the activity should be adding to the top of an existing</span></span><br><span class="line"><span class="comment">    * task or delivered new intent to an existing activity. Also manipulating the activity task</span></span><br><span class="line"><span class="comment">    * onto requested or valid stack/display.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Note: This method should only be called from &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(b/152429287): Make it easier to exercise code paths through startActivityInner</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置初始化参数</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    <span class="comment">//计算处理Activity启动模式</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//计算调用方Activity任务栈</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将flags设置为调整后的LaunchFlags</span></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找是否有可复用的Task</span></span><br><span class="line">    <span class="keyword">final</span> Task reusedTask = getReusableTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If requested, freeze the task list</span></span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="keyword">null</span> &amp;&amp; mOptions.freezeRecentTasksReordering()</span><br><span class="line">            &amp;&amp; mSupervisor.mRecentTasks.isCallerRecents(r.launchedFromUid)</span><br><span class="line">            &amp;&amp; !mSupervisor.mRecentTasks.isFreezeTaskListReorderingSet()) &#123;</span><br><span class="line">        mFrozeTaskList = <span class="keyword">true</span>;</span><br><span class="line">        mSupervisor.mRecentTasks.setFreezeTaskListReordering();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute if there is an existing task that should be used for.</span></span><br><span class="line">    <span class="comment">//计算是否存在可使用的现有Task</span></span><br><span class="line">    <span class="keyword">final</span> Task targetTask = reusedTask != <span class="keyword">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newTask = targetTask == <span class="keyword">null</span>;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算启动参数</span></span><br><span class="line">    computeLaunchParams(r, sourceRecord, targetTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if starting activity on given task or on a new task is allowed.</span></span><br><span class="line">    <span class="comment">//检查是否允许在targetTask上或者新建Task启动</span></span><br><span class="line">    <span class="keyword">int</span> startResult = isAllowedToStart(r, newTask, targetTask);</span><br><span class="line">    <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得栈顶未finish的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord targetTaskTop = newTask</span><br><span class="line">            ? <span class="keyword">null</span> : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    <span class="keyword">if</span> (targetTaskTop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Recycle the target task for this launch.</span></span><br><span class="line">        <span class="comment">//回收，准备复用这个Task</span></span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAddingToTask = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="comment">//处理singleTop启动模式</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (topStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startResult = deliverToCurrentTopIfNeeded(topStack, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复用或创建Activity栈</span></span><br><span class="line">    <span class="keyword">if</span> (mTargetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123; <span class="comment">//开启新Task</span></span><br><span class="line">        <span class="keyword">final</span> Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">                ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//复用或新建一个Task，并建立Task与ActivityRecord之间的关联</span></span><br><span class="line">        setNewTask(taskToAffiliate);</span><br><span class="line">        <span class="keyword">if</span> (mService.getLockTaskController().isLockTaskModeViolation(</span><br><span class="line">                mStartActivity.getTask())) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation mStartActivity="</span> + mStartActivity);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAddingToTask) &#123; <span class="comment">//复用Task</span></span><br><span class="line">        <span class="comment">//将启动Activity添加到targetTask容器顶部或将其父容器替换成targetTask（也会将启动Activity添加到targetTask容器顶部）</span></span><br><span class="line">        addOrReparentStartingActivity(targetTask, <span class="string">"adding to task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123;</span><br><span class="line">        mTargetStack.getStack().moveToFront(<span class="string">"reuseOrNewTask"</span>, targetTask);</span><br><span class="line">        <span class="keyword">if</span> (mOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOptions.getTaskAlwaysOnTop()) &#123;</span><br><span class="line">                mTargetStack.setAlwaysOnTop(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123;</span><br><span class="line">            <span class="comment">// Launching underneath dream activity (fullscreen, always-on-top). Run the launch-</span></span><br><span class="line">            <span class="comment">// -behind transition so the Activity gets created and starts in visible state.</span></span><br><span class="line">            mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">            r.mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mTargetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded(</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* forceSend */</span>, mStartActivity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Task移到ActivityStack容器顶部</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(),</span><br><span class="line">            newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="comment">//启动的Activity不可获得焦点，无法恢复它</span></span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// If the activity is not focusable, we can't resume it, but still would like to</span></span><br><span class="line">            <span class="comment">// make sure it becomes visible as it starts (this will also trigger entry</span></span><br><span class="line">            <span class="comment">// animation). An example of this are PIP activities.</span></span><br><span class="line">            <span class="comment">// Also, we don't want to resume activities in a task that currently has an overlay</span></span><br><span class="line">            <span class="comment">// as the starting activity just needs to be in the visible paused state until the</span></span><br><span class="line">            <span class="comment">// over is removed.</span></span><br><span class="line">            <span class="comment">// Passing &#123;@code null&#125; as the start parameter ensures all activities are made</span></span><br><span class="line">            <span class="comment">// visible.</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisible(<span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                    <span class="number">0</span> <span class="comment">/* configChanges */</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// Go ahead and tell window manager to execute app transition for this activity</span></span><br><span class="line">            <span class="comment">// since the app transition will not be triggered through the resume channel.</span></span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">            <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">            <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">            <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">            <span class="comment">// accordingly.</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityInner"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重点：恢复栈顶Activities</span></span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the recent tasks list immediately when the activity starts</span></span><br><span class="line">    <span class="comment">//当Activity启动后立刻更新最近任务列表</span></span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了一些<code>Task</code>和栈的操作，是否可以复用栈，是否需要新栈，处理栈顶复用等相关操作。我们需要注意一下这里关于<code>Task</code>的操作，不管是新建<code>Task</code>（<code>newTask</code>）还是复用<code>Task</code>（<code>mAddingToTask</code>），都会调用到<code>addOrReparentStartingActivity</code>方法将启动<code>ActivityRecord</code>添加到<code>targetTask</code>容器顶部（<code>newTask</code>的情况下会调用<code>setNewTask</code>方法先复用或创建<code>Task</code>，然后再用这个<code>Task</code>调用<code>addOrReparentStartingActivity</code>方法），之后调用<code>mTargetStack.startActivityLocked</code>方法将<code>Task</code>移到<code>mTargetStack</code>容器顶部，此时调用<code>mTargetStack.topRunningActivity</code>便会得到我们将要启动的这个<code>ActivityRecord</code></p>
<p>最后判断目标<code>Activity</code>是否可获得焦点，当可获得焦点的时候，调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复<code>Activity</code></p>
<p>要注意，从这个方法开始的以后的方法不再只是针对<code>Activity</code>启动的方法，它们有可能被多方调用，所以其中的一些步骤case我们是不会经历的，可以忽略掉这部分</p>
<h1 id="RootWindowContainer"><a href="#RootWindowContainer" class="headerlink" title="RootWindowContainer"></a>RootWindowContainer</h1><p><code>RootWindowContainer</code>是显示窗口的根窗口容器，它主要是用来管理显示屏幕的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStacksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//目标栈在栈顶显示区域</span></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        <span class="comment">//使用目标栈进行恢复</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能存在多显示设备（投屏等）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> resumedOnDisplay = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tdaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; tdaNdx &gt;= <span class="number">0</span>; --tdaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; sNdx &gt;= <span class="number">0</span>; --sNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack stack = taskDisplayArea.getStackAt(sNdx);</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord topRunningActivity = stack.topRunningActivity();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isFocusableAndVisible() || topRunningActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack == targetStack) &#123;</span><br><span class="line">                    <span class="comment">//如果进入到这里，代表着targetStack在上面已经恢复过了，此时只需要记录结果即可</span></span><br><span class="line">                    resumedOnDisplay |= result;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123;</span><br><span class="line">                    <span class="comment">//执行切换效果</span></span><br><span class="line">                    stack.executeAppTransition(targetOptions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使顶部显示的Activity执行Resume、Pause或Start生命周期</span></span><br><span class="line">                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!resumedOnDisplay) &#123;</span><br><span class="line">            <span class="comment">// In cases when there are no valid activities (e.g. device just booted or launcher</span></span><br><span class="line">            <span class="comment">// crashed) it's possible that nothing was resumed on a display. Requesting resume</span></span><br><span class="line">            <span class="comment">// of top activity in focused stack explicitly will make sure that at least home</span></span><br><span class="line">            <span class="comment">// activity is started and resumed, and no recursion occurs.</span></span><br><span class="line">            <span class="comment">//当没有任何有效的Activity的时候（设备刚启动或Launcher崩溃），可能没有任何东西可被恢复</span></span><br><span class="line">            <span class="comment">//这时候使用DisplayContent中的焦点栈进行恢复</span></span><br><span class="line">            <span class="comment">//如果连存在焦点的栈都没有，则恢复Launcher的Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">"no-focusable-task"</span>,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了几件事：</p>
<ul>
<li><p>如果目标栈在栈顶显示区域，执行Resume</p>
</li>
<li><p>遍历显示设备，从中遍历所有有焦点并且可见的栈，对其栈顶<code>Activity</code>执行相应的切换效果及生命周期</p>
</li>
<li><p>对每个显示设备，如果存在焦点栈，则使用其执行Resume，否则启动<code>Launcher</code></p>
</li>
</ul>
<p>在正常情况下，我们会走进<code>ActivityStack.resumeTopActivityUncheckedLocked</code>这个方法</p>
<h1 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h1><p><code>Activity</code>栈，用于管理栈中的<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        mInResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">        <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">        <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">        <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">        <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">        <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">        <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            <span class="comment">//准备休眠</span></span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了一个防止递归调用的措施，接下来调用了<code>resumeTopActivityInnerLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="comment">//ATMS服务尚未准备好</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="comment">//在之前我们已经把要启动的ActivityRecord加到了栈顶</span></span><br><span class="line">    ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let's look somewhere else.</span></span><br><span class="line">        <span class="keyword">return</span> resumeNextFocusableActivityWhenStackIsEmpty(prev, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">    <span class="comment">//如果需要Resume的已在顶部且状态为Resume，不需要做任何事</span></span><br><span class="line">    <span class="comment">//启动Activity不会碰到这种case</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!next.canResumeByCompat()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">    <span class="comment">//如果有正在Pause的Activity，在它Pause完成前不要做任何事</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete();</span><br><span class="line">    <span class="keyword">if</span> (!allPausedComplete) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line">    <span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line">    <span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line">    <span class="comment">//确保拥有此Activity的用户已启动</span></span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">    <span class="comment">// appropriate for it.</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">    next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里似乎重复检查了，我去查看了一下master分支的代码，已经没有这一段了</span></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置启动Activity UID，获取WakeLock，保证在显示Activity的过程中，系统不会进行休眠状态</span></span><br><span class="line">    mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    ActivityRecord lastResumed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//上一个具有焦点的ActivityStack（目前仍是屏幕上正在显示的那个Activity的栈）</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (lastFocusedStack != <span class="keyword">null</span> &amp;&amp; lastFocusedStack != <span class="keyword">this</span>) &#123;</span><br><span class="line">        lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pause掉其他ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">boolean</span> pausing = taskDisplayArea.pauseBackStacks(userLeaving, next);</span><br><span class="line">    <span class="comment">//Pause掉当前ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing) &#123; <span class="comment">//有Activity执行了Pause</span></span><br><span class="line">        <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">        <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">        <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">        <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">        <span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line">            <span class="comment">//将启动的Activity进程信息移至lru列表的头部</span></span><br><span class="line">            <span class="comment">//因为很快就会使用它启动Activity</span></span><br><span class="line">            next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                    <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">false</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">            <span class="comment">// Since the start-process is asynchronous, if we already know the process of next</span></span><br><span class="line">            <span class="comment">// activity isn't running, we can start the process earlier to save the time to wait</span></span><br><span class="line">            <span class="comment">// for the current activity to be paused.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = <span class="keyword">this</span> == taskDisplayArea.getFocusedStack();</span><br><span class="line">            <span class="comment">//启动App进程</span></span><br><span class="line">            mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">                    isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//这里会先结束掉启动Activity的流程，等待onPause生命周期走完后</span></span><br><span class="line">        <span class="comment">//再重新调用这个方法执行下一步操作，避免Activity生命周期紊乱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">        <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">        <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        <span class="comment">//不需要等待其他的Activity onPause完成</span></span><br><span class="line">        <span class="comment">//执行完切换效果后就没有什么其他需要做的了</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动Activity流程不会进入这个case</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev != next &amp;&amp; next.nowVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改启动Activity的package的状态</span></span><br><span class="line">    mAtmService.getPackageManager().setPackageStoppedState(</span><br><span class="line">                next.packageName, <span class="keyword">false</span>, next.mUserId);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Activity转场动画准备</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next.attachedToProcess()) &#123; <span class="comment">//对于将要启动的ActivityRecord来说，此时尚未完成和Process的绑定，返回false</span></span><br><span class="line">        ...</span><br><span class="line">        ActivityRecord lastResumedActivity =</span><br><span class="line">                lastFocusedStack == <span class="keyword">null</span> ? <span class="keyword">null</span> : lastFocusedStack.mResumedActivity;</span><br><span class="line">        <span class="comment">//保存状态以做后面恢复使用</span></span><br><span class="line">        <span class="keyword">final</span> ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">        mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新ActivityRecord状态</span></span><br><span class="line">        next.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新启动Activity的进程信息并将其移至lru列表的头部</span></span><br><span class="line">        next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//更新Activity显示、方向和Configuration</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction =</span><br><span class="line">                    ClientTransaction.obtain(next.app.getThread(), next.appToken);</span><br><span class="line">            <span class="comment">// Deliver all pending results.</span></span><br><span class="line">            ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                            <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                    transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transaction.addCallback(</span><br><span class="line">                        NewIntentItem.obtain(next.newIntents, <span class="keyword">true</span> <span class="comment">/* resume */</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">            <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">            next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">            EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next),</span><br><span class="line">                    next.getTask().mTaskId, next.shortComponentName);</span><br><span class="line"></span><br><span class="line">            next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line">            mAtmService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">            next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState);</span><br><span class="line">            next.clearOptionsLocked();</span><br><span class="line">            <span class="comment">//设置onResume生命周期请求</span></span><br><span class="line">            transaction.setLifecycleStateRequest(</span><br><span class="line">                    ResumeActivityItem.obtain(next.app.getReportedProcState(),</span><br><span class="line">                            dc.isNextTransitionForward()));</span><br><span class="line">            <span class="comment">//调度执行Activity onResume生命周期</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span></span><br><span class="line">                    + next);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//resume失败需要尝试restart</span></span><br><span class="line">            <span class="comment">//恢复初始状态</span></span><br><span class="line">            next.setState(lastState, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastResumedActivity.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//重新启动Activity</span></span><br><span class="line">            mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// From this point on, if something goes wrong there is no way</span></span><br><span class="line">        <span class="comment">// to recover the activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//更新信息</span></span><br><span class="line">            next.completeResumeLocked();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If any exception gets thrown, toss away this</span></span><br><span class="line">            <span class="comment">// activity and try the next one.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</span><br><span class="line">            next.finishIfPossible(<span class="string">"resume-exception"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//尚未绑定Process</span></span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动Activity</span></span><br><span class="line">        mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码很长，其实我们只需要关注三个点：</p>
<ol>
<li><p><code>Pause</code>掉其他<code>Activity</code></p>
</li>
<li><p>如果对应<code>App</code>尚未启动，启动<code>App</code>进程</p>
</li>
<li><p>启动<code>Activity</code></p>
</li>
</ol>
<p>第一步，在启动<code>Activity</code>前，我们需要先<code>Pause</code>掉其他<code>Activity</code>，这一点很好理解，我们可以对照着看<code>Activity</code>生命周期也是这样的，这里会通过<code>ATMS</code>跨进程调用相应<code>Activity</code>的<code>onPause</code>生命周期，等待<code>onPause</code>执行完成后，再跨进程调用回<code>ATMS</code>，经过一系列方法调用，又重新调用<code>resumeTopActivityInnerLocked</code>方法，继续执行下一步操作</p>
<p>第二步，如果<code>App</code>尚未启动，则先去启动<code>App</code>进程，这主要体现在这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">    <span class="comment">//启动App进程</span></span><br><span class="line">    mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">            isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动完<code>App</code>进程后，会调用<code>ATMS</code>的<code>attachApplication</code>方法，最终调用到<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code>，这个方法后面会讲</p>
<p>第三步，如果<code>App</code>进程已经启动，这时候会调用<code>ActivityStackSupervisor.startSpecificActivity</code>方法，最终殊途同归调用<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这里篇幅有点过长了，所以我觉得还是分篇比较好，这一章其实重要内容不是很多，最主要的内容，像<code>Activity</code>的生命周期控制，<code>App</code>进程的启动，<code>Activity</code>具体的启动及其后续生命周期执行都会放在下一章来讲</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><a class="post-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><a class="post-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/09/14/android/compile/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV+FFmpeg+x264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/"><i class="fa fa-chevron-left">  </i><span>Android交叉编译OpenCV+FFmpeg+x264的艰难历程</span></a></div><div class="next-post pull-right"><a href="/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/"><span>Android源码分析 - Framework层的Binder（服务端篇）</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>