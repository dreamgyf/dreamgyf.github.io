<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/06/AI/AI%E4%BA%BA%E5%A3%B0/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">有手就行！Sovits AI人声模型训练</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI/">AI</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI/AI%E4%BA%BA%E5%A3%B0/">AI人声</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AIGC/">AIGC</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI%E4%BA%BA%E5%A3%B0/">AI人声</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Sovits/">Sovits</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着AI孙燕姿的爆火出圈，各大视频平台的AI人声投稿量激增，B站首页频频给我推送相关视频，正好我对AIGC方面也挺感兴趣，心动不如行动，于是我用自己的声音训练了一个模型，发现整个过程异常的简单，并且最终出来的效果也不错，真的是有手就行，所以这次将我自己训练推理的过程经验分享给大家</p>
<h1 id="Sovits"><a href="#Sovits" class="headerlink" title="Sovits"></a>Sovits</h1><p>首先介绍一下今天要讲的Sovits，So-vits-svc（也称Sovits）是由是中国民间歌声合成爱好者Rcell基于VITS、soft-vc、VISinger2等一系列项目开发的一款开源免费AI语音转换软件，通过SoftVC内容编码器提取源音频语音特征，与F0同时输入VITS替换原本的文本输入达到歌声转换的效果。</p>
<p>由于某些原因，原作者Rcell删除了原代码仓库，现由svc-develop-team接手进行后续维护，现仓库地址：<a href="https://github.com/svc-develop-team/so-vits-svc" target="_blank" rel="noopener">https://github.com/svc-develop-team/so-vits-svc</a></p>
<h1 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h1><ul>
<li>一张支持 CUDA 的，拥有至少 6G 以上显存的 NVIDIA 显卡</li>
<li>推荐使用<code>Windows</code>系统，教程后续的素材处理、训练、推理均在<code>Windows</code>平台上完成，同时使用整合包GUI也可以帮助新手将注意力集中在训练/推理本身上，避免了繁杂的环境配置等工作</li>
</ul>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>本次的环境使用的是 <a href="https://space.bilibili.com/3493141443250876" target="_blank" rel="noopener">bilibili@羽毛布団</a> 大佬提供的整合包：<a href="https://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r" target="_blank" rel="noopener">https://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r</a> ，在这里能找到下载地址和一些说明</p>
<p>下载完后，你会得到一个Sovits的压缩包和一些工具软件，将其中的so-vits-svc解压缩后，打开里面的<code>启动webui.bat</code>文件，它会自动准备环境，然后弹出一个网页</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_sovits%E7%9B%AE%E5%BD%95.jpg" alt="sovits目录"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%90%AF%E5%8A%A8webui.png" alt="启动webui"></p>
<p>在网页中将Tab页切换至训练页，可以看到我们的显卡信息</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%98%BE%E5%8D%A1%E4%BF%A1%E6%81%AF.jpg" alt="显卡信息"></p>
<p>确认无误后我们就可以开始训练了</p>
<h1 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h1><p>数据集的质量及多少决定了训练模型质量的上下限，质量差的数据集无论你训练多久，训练了多少万个step，都不可能达到一个理想的效果</p>
<h2 id="准备干声"><a href="#准备干声" class="headerlink" title="准备干声"></a>准备干声</h2><p>Sovits的训练我们需要找一些想训练的声线所对应的干声素材，不可混杂多种声线，时长最好在2个小时以上，最低不要少于30分钟，否则无法保证训练出来的模型的质量，可以是说话、读书或唱歌的声音（有的人说加入一些哭闹、大笑等各种各样的声音有奇效，我没尝试过，大家可以试试看），如果想让你的模型唱歌的话，唱歌的素材需要覆盖低中高音多个频率</p>
<p>干声素材中不能有伴奏、混响、和声（避免转换后的声音自带BGM），不要有换气声、颤音、转音等，尽量将背景噪音去除干净</p>
<h2 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h2><p>如果你本来的素材就是不带伴奏混响的干声文件，但是有一些嘈杂的背景噪音，可以使用<code>Adobe Audition</code>（以下简称AU）进行降噪处理</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html</a></p>
<h2 id="去伴奏混响"><a href="#去伴奏混响" class="headerlink" title="去伴奏混响"></a>去伴奏混响</h2><p>如果你的素材是之前录好的歌曲，那么需要对它进行去伴奏去混响处理，这里推荐使用 <a href="https://ultimatevocalremover.com/" target="_blank" rel="noopener">Ultimate Vocal Remover v5</a>（简称UVR5）</p>
<p>下载完UVR5，在处理音频前建议先去<code>Advanced VR Options</code>中将<code>Post-Process</code>选项打开，这样去混响的效果可能更好（玄学）</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_Settings.jpg" alt="UVR5 Settings"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_AdvancedVROptions.jpg" alt="UVR5 Advanced VR Options"></p>
<p>接着开始去伴奏，推荐采用以下配置：</p>
<ol>
<li>Process Method: Demucs</li>
<li>Stems: Vocals</li>
<li>Demucs Model: v3 | UVR_Model_1 <strong>注：找不到对应模型的可以在下拉框中选择Download在软件内下载相应模型</strong></li>
<li>勾选GPU Conversion</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_%E5%8E%BB%E4%BC%B4%E5%A5%8F.jpg" alt="UVR5去伴奏"></p>
<p>然后对处理完后的人声文件再做一次去混响处理，推荐采用以下配置：</p>
<ol>
<li>Process Method: VR Architecture</li>
<li>Window Size: 320</li>
<li>Aggression Setting: 10</li>
<li>VR Model: 5_HP-Karaoke_UVR</li>
<li>勾选GPU Conversion</li>
<li>勾选Voacls Only</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_%E5%8E%BB%E6%B7%B7%E5%93%8D.jpg" alt="UVR5去混响"></p>
<p>这样简单的几步，我们就将干声从歌曲文件中提取出来了，如果你觉得提取出来的效果差强人意，也可以使用 <a href="https://hitnmix.com/audio-manipulation/" target="_blank" rel="noopener">RipX DeepAudio</a> 做一些精修</p>
<p>将文件导入RipX中，会产生如下图一样的一段曲线</p>
<p>点击其中的某段黄色曲线可以播放这段音频，我们可以一段段听过去，遇到杂音部分可以将其手动删除</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_ripx.jpg" alt="RipX"></p>
<h2 id="匹配响度"><a href="#匹配响度" class="headerlink" title="匹配响度"></a>匹配响度</h2><p>如果你的干声素材的来源不同，很可能会有素材响度大小不一的情况，这种情况下需要使用AU对所有音频去做匹配响度，使所有素材的分贝值在一个统一的范围内</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/match-loudness.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/match-loudness.html</a></p>
<h2 id="压限"><a href="#压限" class="headerlink" title="压限"></a>压限</h2><p>干声的响度不宜超过-6db，建议使用<code>Adobe Audition</code>中的压限器将声音的分贝限制在-6db以内</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html</a></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>干声素材都处理完后，下一步就是将这些素材切成一个个2-15s的小片段（片段太长容易爆显存，最好不要超过20s），这里推荐使用 <a href="https://github.com/flutydeer/audio-slicer" target="_blank" rel="noopener">Audio Slicer</a> ，可以根据响度阈值和间隔时间等自动将音频切片</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_AudioSlicer.jpg" alt="Audio Slicer"></p>
<p>将干声文件拖进去后可以先使用默认参数切一遍，然后去输出目录，将文件按文件大小由大到小排列，查看是否还有大于15s的音频切片，如有的话，将这些音频重新拖入软件中，按照以下参数重新切片一次：</p>
<ol>
<li>Threshold（db）: -20</li>
<li>Minimum Interval: 100</li>
<li>Maximum Silence Length（ms）: 500</li>
</ol>
<p>一般这样就不会有大于15s的音频了，如果还有的话，我将这些参数的含义列在下面，大家可以自己调整参数尝试，大家也可以使用其他的一些音频处理工具（如：AU）手动切片</p>
<ul>
<li>Threshold（阈值）</li>
</ul>
<p>以 dB 表示的 RMS 阈值。所有 RMS 值都低于此阈值的区域将被视为静音。如果音频有噪音，请增加此值。默认值为 -40。</p>
<ul>
<li>Minimum Length（最小长度）</li>
</ul>
<p>每个切片音频剪辑所需的最小长度，以毫秒为单位。默认值为 5000。</p>
<ul>
<li>Minimum Interval（最小间距）</li>
</ul>
<p>要切片的静音部分的最小长度，以毫秒为单位。如果音频仅包含短暂的中断，请将此值设置得更小。此值越小，此应用程序可能生成的切片音频剪辑就越多。请注意，此值必须小于 min length 且大于 hop size。默认值为 300。</p>
<ul>
<li>Hop Size（跳跃步长）</li>
</ul>
<p>每个 RMS 帧的长度，以毫秒为单位。增加此值将提高切片的精度，但会降低处理速度。默认值为 10。</p>
<ul>
<li>Maximum Silence Length（最大静音长度）</li>
</ul>
<p>在切片音频周围保持的最大静音长度，以毫秒为单位。根据需要调整此值。请注意，设置此值并不意味着切片音频中的静音部分具有完全给定的长度。如上所述，该算法将搜索要切片的最佳位置。默认值为 1000。</p>
<p>最后，记得把过短的音频切片删除掉</p>
<h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>数据集的格式必须是<code>wav</code>原始波形格式，大家检查一下，如果如果有非<code>wav</code>格式的文件，需要做一下格式转换，推荐使用<code>Foobar2000</code>，或者直接使用<code>FFmepg</code>进行转换</p>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>数据集中不能出现中文等非英文字符，特殊字符推荐只使用下划线，<code>Windows</code>下直接将文件全选后重命名，文件名会变成以下这种格式：</p>
<ul>
<li>xxx (1).wav</li>
<li>xxx (2).wav</li>
<li>…</li>
</ul>
<p>本人亲测这样命名虽然会报Warning，但不影响训练，是可行的</p>
<h1 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h1><p>接着我们就开始准备训练了</p>
<h2 id="放置数据集"><a href="#放置数据集" class="headerlink" title="放置数据集"></a>放置数据集</h2><p>首先将处理好的干声全部放到一个文件夹下，然后再将这个文件夹放到<code>so-vits-svc</code>目录下的<code>dataset_raw</code>文件夹下</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%94%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E9%9B%86.jpg" alt="放置数据集"></p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>打开webui界面，切换到训练选项卡，首先点击<code>识别数据集</code>，上面的文本框中便会显示出我们准备好的数据集名，然后选择训练使用的<code>编码器</code>和<code>f0预测器</code>，这里选择我图中标出的两个选项，是目前效果比较好的选项，接着点击数据预处理，在预处理输出信息那一栏会打印进度，耐心等待它跑完</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.jpg" alt="数据预处理"></p>
<h2 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h2><p>等待数据预处理完成后，我们要将训练的设置和参数写入到配置文件中</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E8%AE%AD%E7%BB%83%E9%85%8D%E7%BD%AE.jpg" alt="训练配置"></p>
<p>介绍一下这里参数的含义和推荐设置：</p>
<ol>
<li>每隔多少步(steps)生成一次评估日志：每隔一定步数输出一下当前步数下的学习率，loss值等信息，根据个人偏好自己填写即可</li>
<li>每隔多少步(steps)验证并保存一次模型：字面意思，根据个人偏好自己填写即可</li>
<li>仅保留最新的X个模型：我训练到11万步时一个模型接近600MB，大家根据自己的硬盘大小和个人偏好填写即可</li>
<li>批量大小：大的batch size可以减少训练时间，提高稳定性，但同时也会导致模型泛化能力下降，所以，就算你的显存很大也不建议将本参数设置的过大，推荐使用4</li>
<li>学习率：初始学习率过大会导致模型无法收敛，过小则会导致模型收敛特别慢或无法学习，建议使用默认值0.0001</li>
<li>使用fp16混合精度训练：混合精度训练是在尽可能减少精度损失的情况下利用半精度浮点数加速训练，它使用FP16即半精度浮点数存储权重和梯度，在减少占用内存的同时起到了加速训练的效果，理论上来说使用混合精度几乎不会造成精度损失，但目前没对模型质量的影响尚未查证，在显卡性能足够的情况下建议还是先不要勾选</li>
<li>加载数据集到内存中：在内存足够的情况下建议勾选，可以加快训练速度</li>
</ol>
<p>所有训练参数设置好后，点击下面的写入配置文件按钮，在下面的输出信息那里会显示<code>配置文件写入完成</code>，接下来就可以开始正式训练了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="写入配置文件"></p>
<h1 id="正式训练"><a href="#正式训练" class="headerlink" title="正式训练"></a>正式训练</h1><p>点击下面的<code>从头开始训练</code>，会弹出一个新的终端窗口，在这个终端窗口中，会不断的输出当前训练的日志</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83.jpg" alt="开始训练"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E8%AE%AD%E7%BB%83%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3.jpg" alt="训练终端窗口"></p>
<p>我的训练参数设置的是每隔200步生成一次评估日志，每隔1000步保存一次模型，日志中输出的<code>reference_loss</code>值代表了模型的输出与真实值之间的差距，理论来说，这个值越低越好，越低，模型输出的声音就和真人的声音越像，但从经验来说未必如此，过低的loss值也可能代表了模型过拟合，我们只能将这个参数作为一个参考，实际效果要使用测试了这个模型后才能得知，我们可以参考这个值初步选择模型进行推理测试</p>
<p>训练是不会自动终止的，当我们感觉训练的差不多了，想试一下模型的实际效果时，可以在训练终端窗口中键盘键入<code>Ctrl + C</code>停止训练，如果对本次训练出来的模型还不满意，想要继续训练，则可以点击<code>继续上一次的训练进度</code>，程序会从上一个自动保存的模型的进度开始继续训练</p>
<h1 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h1><h2 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h2><p>模型训练完后我们就可以将选项卡切换到<code>推理</code>来测试模型的实际效果了</p>
<p>我们先点击<code>刷新选项</code>，此时在<code>模型选择</code>和<code>配置文件</code>的下拉菜单中就出现了我们之前训练好的模型，参考之前的<code>reference_loss</code>值我们选取一个模型（G开头），并且选择训练所使用的配置文件，点击加载模型，等待下面的<code>Output Message</code>文本框出现<code>模型加载成功</code>字样，就可以正式开始我们的推理了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B.jpg" alt="加载模型"></p>
<h2 id="开始推理"><a href="#开始推理" class="headerlink" title="开始推理"></a>开始推理</h2><p>Sovits是一个声音转换工具，我们首先需要找一段想要转换的原声音频，和准备数据集那一章的要求一样，我们需要一段干声，不能有伴奏、混响、和声。如果想让模型唱歌的话，我们可以采用前面准备数据集所用的方法，直接将原曲去伴奏混响，处理好后将其拖入音频上传区域中</p>
<p>默认的 <code>pm</code> f0预测器推理出来的音质效果最好，所以建议先使用默认参数推理一遍，出现问题再针对性的对参数进行调整</p>
<p>我们点击下面的<code>音频转换</code>按钮，稍等一会儿，在<code>Output Audio</code>那里便会生成一段推理后的音频</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%8E%A8%E7%90%86.png" alt="推理"></p>
<p>我们试听后根据具体的问题设置转换参数：</p>
<ul>
<li>出现哑音</li>
</ul>
<p>哑音是因为原声音频中的和声部分没有去处干净，导致f0预测器对音高的预测出现了错误，预测成了一个极高的音高，模型唱不上去导致的</p>
<p>有两种办法解决这个问题，一种就是从源头解决问题，想办法将原声音频的和声混响去除，获得更纯净的干声重新推理，另一种方法可以将f0预测器换成<code>crepe</code>，适度调节<code>F0过滤阈值</code>（一般使用默认值就行，改大改小没什么区别），然后重新进行推理基本就可以解决这个问题，但是音质不如f0预测器<code>pm</code>，电流音等杂音会变多，两种方法大家可以自行判断选取</p>
<ul>
<li>音域差距过大</li>
</ul>
<p>如果训练的模型是男声，但推理使用的原声是女声，或者反过来，碰到这种音域差距过大的情况会导致推理出来的音频不堪入耳</p>
<p>我们可以打开f0自动预测选项来解决这个问题，但正如选项里描述的那样，此选择仅限于转换语音时才可用，转换歌声时打开此选项会导致灾难性的跑调</p>
<p>如果是歌声并且实在是想要唱这首歌的话，建议去找一个和自己音域比较契合的翻唱音频，用这个音频处理后作为原声进行推理</p>
<ul>
<li>部分音调唱不上（下）去</li>
</ul>
<p>训练时喂的数据集没有覆盖到部分音域</p>
<p>这里的变调选项似乎是先推理再变调？所以对这种情况不起作用，建议使用AU先将原声音频升降调到合适的音域，再进行推理</p>
<ul>
<li>爆显存</li>
</ul>
<p>在推理的过程中有可能会出现爆显存的情况，因为推理也是将原音频按照响度阈值切成一段段小切片分别进行推理，最后再合成，如果其中有一段切片时常过长就可能会导致爆显存</p>
<p>我们可以将切片阈值调高，使得原声音频可以切的更加细碎，甚至你也可以直接调整音频自动切片的值开启强制切片，比如输入10，音频就会被切成每10s一段，确保音频时常不会爆显存</p>
<h1 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h1><p>如果转换的是歌声，最后可以将转换出来的干声和伴奏合并成一个音频文件，可以使用AU等软件，在合成之前还可以对干声进行一些EQ、混响的调整等，关于音乐方面的知识这里就不多说了</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>最后贴一下我自己练的模型所推理出来的歌声，使用了30分钟质量较好的干声素材和30分钟质量较差的素材（噪音和混响比较多），训练了11万步，使用<code>crepe</code>f0预测器推理得出</p>
<p>链接：<a href="https://www.bilibili.com/audio/au3907000" target="_blank" rel="noopener">https://www.bilibili.com/audio/au3907000</a></p>
<p>这是我第一次尝试训练Sovits模型，如果有什么疏漏或错误欢迎大家指出</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/01/android/animation/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E7%9B%91%E5%90%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%EF%BC%9FAnimationDrawable%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">如何完美监听帧动画？AnimationDrawable深度解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%8A%A8%E7%94%BB/">动画</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8A%A8%E7%94%BB/">动画</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AnimationDrawable/">AnimationDrawable</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作为苦逼的程序员，产品和设计提出来的需求咱也没法拒绝，这不，前两天设计就给提了个需求，要求在帧动画结束后，把原位置的动画替换成一段文字。我们知道，在<code>Android</code>中，帧动画的实现类为<code>AnimationDrawable</code>，而这玩意儿又不像<code>Animator</code>一样可以通过<code>addListener</code>之类的方法监听动画的开始、结束等事件，那我们该怎么监听<code>AnimationDrawable</code>的结束事件呢？</p>
<p>目前网上大多数的做法都是获取帧动画的总时长，然后用<code>Handler</code>做一个<code>postDelayed</code>执行结束后的事情。这种方法怎么说呢？能用，但是不够精准也不够优雅，本文我们将从源码层面解析<code>AnimationDrawable</code>是如何将一帧帧的图片组合起来展示成连续的动画的，再从中寻求动画监听的切入点。</p>
<p><strong>注：只想看实现的朋友们可以直接跳到 包装Drawable.Callback 这一节看最终实现</strong></p>
<h1 id="ImageView如何展示Drawable"><a href="#ImageView如何展示Drawable" class="headerlink" title="ImageView如何展示Drawable"></a>ImageView如何展示Drawable</h1><p><code>AnimationDrawable</code>说到底它也就是个<code>Drawable</code>，而我们一般都是使用<code>ImageView</code>作为<code>Drawable</code>展示的布局，那我们就以此作为入口开始分析<code>Drawable</code>在<code>ImageView</code>中是如何被展示的。</p>
<p>回想一下，我们想要给一个<code>ImageView</code>设置图片一般可以用下面几种方法：</p>
<ul>
<li><code>setImageBitmap</code></li>
<li><code>setImageResource</code></li>
<li><code>setImageURI</code></li>
<li><code>setImageDrawable</code></li>
</ul>
<p><code>setImageBitmap</code>会将<code>Bitmap</code>包装成一个<code>BitmapDrawable</code>，然后再调用<code>setImageDrawable</code>方法。</p>
<p><code>setImageResource</code>和<code>setImageURI</code>方法会通过<code>resolveUri</code>方法从<code>Resource</code>或<code>Uri</code>中解析出<code>Drawable</code>，然后调用<code>updateDrawable</code>方法</p>
<p><code>setImageDrawable</code>方法则会直接调用<code>updateDrawable</code>方法</p>
<p>最终殊途同归走到<code>updateDrawable</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDrawable</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sameDrawable = mDrawable == d;</span><br><span class="line">        mDrawable.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleDrawable(mDrawable);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawable = d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">        d.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将我们设置的图片资源赋值到<code>mDrawable</code>上。注意，这里有一个<code>Drawable</code>动起来的关键点，同时也是我们动画监听的最终切入点：<code>Drawable.setCallback(this)</code>，我们后面分析帧切换的时候会详细去聊它。</p>
<p>我们知道，一个控件想要绘制内容得在<code>onDraw</code>方法中操作<code>Canvas</code>，所以让我们再来看看<code>onDraw</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// couldn't resolve the URI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawableWidth == <span class="number">0</span> || mDrawableHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// nothing to draw (empty bounds)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    mDrawable.draw(canvas);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>Drawable.draw</code>方法将<code>Drawable</code>自身绘制到<code>ImageView</code>的<code>Canvas</code>上</p>
<h1 id="DrawableContainer"><a href="#DrawableContainer" class="headerlink" title="DrawableContainer"></a>DrawableContainer</h1><p>查看<code>AnimationDrawable</code>的继承关系我们可以得知它继承自<code>DrawableContainer</code>，从命名中我们就能看出来，它是<code>Drawable</code>的容器，我们来看一下它所实现的<code>draw</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurrDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurrDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLastDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLastDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mLastDrawable</code>是为了完成动画的切换效果（出入场动画）所准备的，我们可以不用关心它。</p>
<p>我们可以发现，它的内部有一个名为<code>mCurrDrawable</code>的成员变量，我们可以合理猜测它是通过切换<code>mCurrDrawable</code>指向的目标<code>Drawable</code>来完成展示不同图片的功能，那么事实是这样吗？</p>
<p>没错，<code>DrawableContainer</code>给我们提供了一个<code>selectDrawable</code>方法，用来切换不同的图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">selectDrawable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == mCurIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; mDrawableContainerState.mNumChildren) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable d = mDrawableContainerState.getChild(index);</span><br><span class="line">        mCurrDrawable = d;</span><br><span class="line">        mCurIndex = index;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCurrDrawable = <span class="keyword">null</span>;</span><br><span class="line">        mCurIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    invalidateSelf();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和我们猜想的一样，在<code>DrawableContainer</code>的内部有一个子类<code>DrawableContainerState</code>用于保存所有的<code>Drawable</code>，它继承自<code>Drawable.ConstantState</code>，是用来储存<code>Drawable</code>间的常量状态和数据的。在<code>DrawableContainerState</code>中有一个<code>mDrawables</code>数组用于保存所有的<code>Drawable</code>，通过<code>addChild</code>方法将<code>Drawable</code>加入到这个数组中</p>
<p>而在<code>selectDrawable</code>方法中，它通过<code>getChild</code>方法去获取当前应该显示的<code>Drawable</code>，并将其和<code>index</code>分别赋值给它的两个成员变量<code>mCurrDrawable</code>和<code>mCurIndex</code>，然后调用<code>invalidateSelf</code>方法执行重绘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.invalidateDrawable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalidateSelf</code>被定义实现在<code>Drawable</code>类中，还记得我之前让大家注意的<code>Callback</code>吗？在设置图片这一步时，它就被赋值了，实际上这个接口被<code>View</code>所实现，所以在前面我们可以看到调用<code>setCallback</code>时，我们传入的参数为<code>this</code></p>
<p>不过<code>ImageView</code>在继承<code>View</code>的同时也重写了这个<code>invalidateDrawable</code>方法，最终调用了<code>invalidate</code>方法执行重绘，此时，一张新的图片就被展示到我们的屏幕上了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ImageView.invalidateDrawable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateDrawable</span><span class="params">(@NonNull Drawable dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dr == mDrawable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// update cached drawable dimensions if they've changed</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> w = dr.getIntrinsicWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> h = dr.getIntrinsicHeight();</span><br><span class="line">            <span class="keyword">if</span> (w != mDrawableWidth || h != mDrawableHeight) &#123;</span><br><span class="line">                mDrawableWidth = w;</span><br><span class="line">                mDrawableHeight = h;</span><br><span class="line">                <span class="comment">// updates the matrix, which is dependent on the bounds</span></span><br><span class="line">                configureBounds();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* we invalidate the whole view in this case because it's very</span></span><br><span class="line"><span class="comment">            * hard to know where the drawable actually is. This is made</span></span><br><span class="line"><span class="comment">            * complicated because of the offsets and transformations that</span></span><br><span class="line"><span class="comment">            * can be applied. In theory we could get the drawable's bounds</span></span><br><span class="line"><span class="comment">            * and run them through the transformation and offsets, but this</span></span><br><span class="line"><span class="comment">            * is probably not worth the effort.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        invalidate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.invalidateDrawable(dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AnimationDrawable"><a href="#AnimationDrawable" class="headerlink" title="AnimationDrawable"></a>AnimationDrawable</h1><p><code>DrawableContainer</code>分析完后，我们可以很自然的想到，<code>AnimationDrawable</code>就是通过<code>DrawableContainer</code>这种可以切换图片的机制，每隔一定时间执行一下<code>selectDrawable</code>便可以达成帧动画的效果了。</p>
<p>我们先回想一下，在代码中怎么构造出一个多帧的<code>AnimationDrawable</code>？没错，用默认构造方法实例化出来后，调用它的<code>addFrame</code>方法往里一帧帧的添加图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrame</span><span class="params">(@NonNull Drawable frame, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mAnimationState.addFrame(frame, duration);</span><br><span class="line">    <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">        setFrame(<span class="number">0</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>AnimationDrawable</code>也有一个内部类<code>AnimationState</code>，继承自<code>DrawableContainerState</code>，它的<code>addFrame</code>方法就是调用<code>DrawableContainerState.addChild</code>方法添加图片，同时将这张图片的持续时间保存在<code>mDurations</code>数组中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrame</span><span class="params">(Drawable dr, <span class="keyword">int</span> dur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">super</span>.addChild(dr);</span><br><span class="line">    mDurations[pos] = dur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想让<code>AnimationDrawable</code>动起来的话，我们得要调用它的<code>start</code>方法，那我们就从这个方法开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning()) &#123;</span><br><span class="line">        <span class="comment">// Start from 0th frame.</span></span><br><span class="line">        setFrame(<span class="number">0</span>, <span class="keyword">false</span>, mAnimationState.getChildCount() &gt; <span class="number">1</span></span><br><span class="line">                || !mAnimationState.mOneShot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将<code>mAnimating</code>状态置为<code>true</code>，然后调用<code>setFrame</code>方法从第0帧开始展示图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> frame, <span class="keyword">boolean</span> unschedule, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame &gt;= mAnimationState.getChildCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimating = animate;</span><br><span class="line">    mCurFrame = frame;</span><br><span class="line">    selectDrawable(frame);</span><br><span class="line">    <span class="keyword">if</span> (unschedule || animate) &#123;</span><br><span class="line">        unscheduleSelf(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">        <span class="comment">// Unscheduling may have clobbered these values; restore them</span></span><br><span class="line">        mCurFrame = frame;</span><br><span class="line">        mRunning = <span class="keyword">true</span>;</span><br><span class="line">        scheduleSelf(<span class="keyword">this</span>, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，和我们所想的一样，调用了<code>DrawableContainer.selectDrawable</code>切换当前展示图片，由于我们之前将<code>mAnimating</code>赋值为了<code>true</code>，所以会调用<code>scheduleSelf</code>方法调度展示下一张图片，时间为当前帧持续时间后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleSelf</span><span class="params">(@NonNull Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.scheduleDrawable(<span class="keyword">this</span>, what, when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>scheduleSelf</code>方法调用了<code>Drawable.Callback.scheduleDrawable</code>方法，我们去<code>View</code>里面看实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleDrawable</span><span class="params">(@NonNull Drawable who, @NonNull Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verifyDrawable(who) &amp;&amp; what != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = when - SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(</span><br><span class="line">                    Choreographer.CALLBACK_ANIMATION, what, who,</span><br><span class="line">                    Choreographer.subtractFrameDelay(delay));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Postpone the runnable until we know</span></span><br><span class="line">            <span class="comment">// on which thread it needs to run.</span></span><br><span class="line">            getRunQueue().postDelayed(what, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上两个分支最终都是通过<code>Handler</code>实现延时调用，而调用的<code>Runnable</code>对象就是之前<code>scheduleSelf</code>传入的<code>this</code>。没错，<code>AnimationDrawable</code>实现了<code>Runnable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nextFrame(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextFrame</span><span class="params">(<span class="keyword">boolean</span> unschedule)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextFrame = mCurFrame + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numFrames = mAnimationState.getChildCount();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop if necessary. One-shot animations should never hit this case.</span></span><br><span class="line">    <span class="keyword">if</span> (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) &#123;</span><br><span class="line">        nextFrame = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setFrame(nextFrame, unschedule, !isLastFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在一帧持续时间结束后，便会调用<code>nextFrame</code>方法，计算下一帧的<code>index</code>，然后调用<code>setFrame</code>方法切换下一帧，形成一个循环，这样一帧帧的图片便动了起来，形成了帧动画</p>
<h1 id="包装Drawable-Callback"><a href="#包装Drawable-Callback" class="headerlink" title="包装Drawable.Callback"></a>包装Drawable.Callback</h1><p>我们从源码层面分析了帧动画是如何运作的，那么怎么监听动画事件相信各位应该都能得出结论了吧？没错，就是重设<code>Drawable</code>的<code>Callback</code></p>
<p>当<code>Drawable</code>被设置到控件中后，控件会将自身作为<code>Drawable.Callback</code>设置给<code>Drawable</code>，那么我们只需要重新给<code>Drawable</code>设置一个<code>Drawable.Callback</code>，在其中调用<code>View</code>回调方法的同时，加入自己的监听逻辑即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animDrawable = imageView.drawable <span class="keyword">as</span> AnimationDrawable</span><br><span class="line"><span class="keyword">val</span> callback = <span class="keyword">object</span> : Drawable.Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invalidateDrawable</span><span class="params">(who: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">        imageView.invalidateDrawable(who)</span><br><span class="line">        <span class="keyword">if</span> (animDrawable.getFrame(animDrawable.numberOfFrames - <span class="number">1</span>) == current </span><br><span class="line">                &amp;&amp; animDrawable.isOneShot </span><br><span class="line">                &amp;&amp; animDrawable.isRunning </span><br><span class="line">                &amp;&amp; animDrawable.isVisible</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">val</span> lastFrameDuration = getDuration(animDrawable.numberOfFrames - <span class="number">1</span>)</span><br><span class="line">            postDelayed(&#123; ...<span class="comment">//结束后需要做的事 &#125;, lastFrameDuration.toLong())</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>, `<span class="keyword">when</span>`: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        imageView.scheduleDrawable(who, what, `<span class="keyword">when</span>`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">unscheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        imageView.unscheduleDrawable(who, what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意一定需要用一个成员变量或其他方式持有这个Callback</span></span><br><span class="line"><span class="comment">//因为Drawable.Callback是以弱引用的形式被保存在Drawable内的，很容易被回收</span></span><br><span class="line">mCallbackHolder = callback</span><br><span class="line">animDrawable.callback = callback</span><br><span class="line">animDrawable.start()</span><br></pre></td></tr></table></figure>

<p>以上的代码便是示例，当满足动画运行到最后一帧，且满足结束状态时，在最后一帧的持续时间后处理结束后需要做的事</p>
<p>当<code>AnimationDrawable</code>切换<code>Visible</code>状态为<code>false</code>时，动画会被暂停，如果在动画结束后触发<code>setVisible(false)</code>事件，也会触发<code>invalidateDrawable</code>回调，所以这里需要额外判断一下<code>isVisible</code></p>
<p>自己包装的<code>Drawable.Callback</code>一定需要找个东西将它强引用起来，因为<code>Drawable.Callback</code>是以弱引用的形式被保存在<code>Drawable</code>内的，很容易被回收，一旦被回收，整个<code>AnimationDrawable</code>动画就动不起来了</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>为了这么简单一个小功能，还得跑到源码里看怎么实现，对此我的感受是：一入安卓深似海，从此头发是路人</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/23/android/common/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/">Android动态权限申请从未如此简单</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%9D%83%E9%99%90/">权限</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android/">Android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%9D%83%E9%99%90/">权限</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>注：只想看实现的朋友们可以直接跳到最后面的最终实现</strong></p>
<p>大家是否还在为动态权限申请感到苦恼呢？传统的动态权限申请需要在<code>Activity</code>中重写<code>onRequestPermissionsResult</code>方法来接收用户权限授予的结果。试想一下，你需要在一个子模块中申请权限，那得从这个模块所在的<code>Activity</code>的<code>onRequestPermissionsResult</code>中将结果一层层再传回到这个模块中，相当的麻烦，代码也相当冗余和不干净，逼死强迫症。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>为了解决这个痛点，我封装出了两个方法，用于随时随地快速的动态申请权限，我们先来看看我们的封装方法是如何调用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">activity.requestPermission(Manifest.permission.CAMERA, onPermit = &#123;</span><br><span class="line">    <span class="comment">//申请权限成功 Do something</span></span><br><span class="line">&#125;, onDeny = &#123; shouldShowCustomRequest -&gt;</span><br><span class="line">    <span class="comment">//申请权限失败 Do something</span></span><br><span class="line">    <span class="keyword">if</span> (shouldShowCustomRequest) &#123;</span><br><span class="line">        <span class="comment">//用户选择了拒绝并且不在询问，此时应该使用自定义弹窗提醒用户授权（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样是不是非常的简单便捷？申请和结果回调都在一个方法内处理，并且支持随用随调。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>那么，这么方便好用的方法是怎么实现的呢？不知道小伙伴们在平时开发中有没有注意到过，当你调用<code>startActivityForResult</code>时，AS会提示你该方法已被弃用，点进去看会告诉你应该使用<code>registerForActivityResult</code>方法替代。没错，这就是<code>androidx</code>给我们提供的<code>ActivityResult</code>功能，并且这个功能不仅支持<code>ActivityResult</code>回调，还支持打开文档，拍摄照片，选择文件等各种各样的回调，同样也包括我们今天要说的权限申请</p>
<p>其实Android在官方文档 <a href="https://developer.android.com/training/permissions/requesting?hl=zh-cn" target="_blank" rel="noopener">请求运行时权限</a> 中就已经将其作为动态权限申请的推荐方法了，如下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> requestPermissionLauncher =</span><br><span class="line">    registerForActivityResult(RequestPermission()</span><br><span class="line">    ) &#123; isGranted: <span class="built_in">Boolean</span> -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isGranted) &#123;</span><br><span class="line">            <span class="comment">// Permission is granted. Continue the action or workflow in your</span></span><br><span class="line">            <span class="comment">// app.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explain to the user that the feature is unavailable because the</span></span><br><span class="line">            <span class="comment">// feature requires a permission that the user has denied. At the</span></span><br><span class="line">            <span class="comment">// same time, respect the user's decision. Don't link to system</span></span><br><span class="line">            <span class="comment">// settings in an effort to convince the user to change their</span></span><br><span class="line">            <span class="comment">// decision.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    ContextCompat.checkSelfPermission(</span><br><span class="line">            CONTEXT,</span><br><span class="line">            Manifest.permission.REQUESTED_PERMISSION</span><br><span class="line">            ) == PackageManager.PERMISSION_GRANTED -&gt; &#123;</span><br><span class="line">        <span class="comment">// You can use the API that requires the permission.</span></span><br><span class="line">    &#125;</span><br><span class="line">    shouldShowRequestPermissionRationale(...) -&gt; &#123;</span><br><span class="line">        <span class="comment">// In an educational UI, explain to the user why your app requires this</span></span><br><span class="line">        <span class="comment">// permission for a specific feature to behave as expected, and what</span></span><br><span class="line">        <span class="comment">// features are disabled if it's declined. In this UI, include a</span></span><br><span class="line">        <span class="comment">// "cancel" or "no thanks" button that lets the user continue</span></span><br><span class="line">        <span class="comment">// using your app without granting the permission.</span></span><br><span class="line">        showInContextUI(...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">        <span class="comment">// The registered ActivityResultCallback gets the result of this request.</span></span><br><span class="line">        requestPermissionLauncher.launch(</span><br><span class="line">                Manifest.permission.REQUESTED_PERMISSION)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里，可能有小伙伴要质疑我了：“官方文档里都写明了的东西，你还特地写一遍，还起了这么个标题，是不是在水文章？！”</p>
<p>莫急，如果你遵照以上方法这么写的话，在实际调用的时候会直接发生崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">LifecycleOwner Activity is attempting to register while current state is RESUMED. </span><br><span class="line">LifecycleOwners must call register before they are STARTED.</span><br></pre></td></tr></table></figure>

<p>这段报错很明显的告诉我们，我们的注册工作必须要在<code>Activity</code>声明周期<code>STARTED</code>之前进行（也就是<code>onCreate</code>时和<code>onStart</code>完成前），但这样我们就必须要事先注册好所有可能会用到的权限，没办法做到随时随地有需要时再申请权限了，有办法解决这个问题吗？答案是肯定的。</p>
<h1 id="绕过生命周期检测"><a href="#绕过生命周期检测" class="headerlink" title="绕过生命周期检测"></a>绕过生命周期检测</h1><p>想解决这个问题，我们必须要知道问题的成因，让我们带着问题进到源码中一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">registerForActivityResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerForActivityResult(contract, mActivityResultRegistry, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">registerForActivityResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registry.register(</span><br><span class="line">            <span class="string">"activity_rq#"</span> + mNextLocalRequestCode.getAndIncrement(), <span class="keyword">this</span>, contract, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> String key,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> LifecycleOwner lifecycleOwner,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Lifecycle lifecycle = lifecycleOwner.getLifecycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"LifecycleOwner "</span> + lifecycleOwner + <span class="string">" is "</span></span><br><span class="line">                + <span class="string">"attempting to register while current state is "</span></span><br><span class="line">                + lifecycle.getCurrentState() + <span class="string">". LifecycleOwners must call register before "</span></span><br><span class="line">                + <span class="string">"they are STARTED."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerKey(key);</span><br><span class="line">    LifecycleContainer lifecycleContainer = mKeyToLifecycleContainers.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lifecycleContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lifecycleContainer = <span class="keyword">new</span> LifecycleContainer(lifecycle);</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleEventObserver observer = <span class="keyword">new</span> LifecycleEventObserver() &#123; ... &#125;;</span><br><span class="line">    lifecycleContainer.addObserver(observer);</span><br><span class="line">    mKeyToLifecycleContainers.put(key, lifecycleContainer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，<code>registerForActivityResult</code>实际上就是调用了<code>ComponentActivity</code>内部成员变量的<code>mActivityResultRegistry.register</code>方法，而在这个方法的一开头就检查了当前<code>Activity</code>的生命周期，如果生命周期位于<code>STARTED</code>后则直接抛出异常，那我们该如何绕过这个限制呢？</p>
<p>其实在<code>register</code>方法的下面就有一个同名重载方法，这个方法并没有做生命周期的检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> String key,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    registerKey(key);</span><br><span class="line">    mKeyToCallback.put(key, <span class="keyword">new</span> CallbackAndContract&lt;&gt;(callback, contract));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParsedPendingResults.containsKey(key)) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> O parsedPendingResult = (O) mParsedPendingResults.get(key);</span><br><span class="line">        mParsedPendingResults.remove(key);</span><br><span class="line">        callback.onActivityResult(parsedPendingResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ActivityResult pendingResult = mPendingResults.getParcelable(key);</span><br><span class="line">    <span class="keyword">if</span> (pendingResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingResults.remove(key);</span><br><span class="line">        callback.onActivityResult(contract.parseResult(</span><br><span class="line">                pendingResult.getResultCode(),</span><br><span class="line">                pendingResult.getData()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到这个方法就简单了，我们将<code>registerForActivityResult</code>方法调用替换成<code>activityResultRegistry.register</code>调用就可以了</p>
<p>当然，我们还需要注意一些小细节，检查生命周期的<code>register</code>方法同时也会注册生命周期回调，当<code>Activity</code>被销毁时会将我们注册的<code>ActivityResult</code>回调移除，我们也需要给我们封装的方法加上这个逻辑，最终实现就如下所示。</p>
<h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> nextLocalRequestCode = AtomicInteger()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> nextKey: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">"activity_rq#<span class="subst">$&#123;nextLocalRequestCode.getAndIncrement()&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">requestPermission</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    permission: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onPermit: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onDeny: (<span class="type">shouldShowCustomRequest</span>: <span class="type">Boolean</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, permission) == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        onPermit()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> launcher <span class="keyword">by</span> Delegates.notNull&lt;ActivityResultLauncher&lt;String&gt;&gt;()</span><br><span class="line">    launcher = activityResultRegistry.register(</span><br><span class="line">        nextKey,</span><br><span class="line">        ActivityResultContracts.RequestPermission()</span><br><span class="line">    ) &#123; result -&gt;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            onPermit()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onDeny(!ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, permission))</span><br><span class="line">        &#125;</span><br><span class="line">        launcher.unregister()</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                launcher.unregister()</span><br><span class="line">                lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    launcher.launch(permission)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">requestPermissions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    onPermit: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onDeny: (<span class="type">shouldShowCustomRequest</span>: <span class="type">Boolean</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hasPermissions = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (permission <span class="keyword">in</span> permissions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                permission</span><br><span class="line">            ) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            hasPermissions = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasPermissions) &#123;</span><br><span class="line">        onPermit()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> launcher <span class="keyword">by</span> Delegates.notNull&lt;ActivityResultLauncher&lt;Array&lt;String&gt;&gt;&gt;()</span><br><span class="line">    launcher = activityResultRegistry.register(</span><br><span class="line">        nextKey,</span><br><span class="line">        ActivityResultContracts.RequestMultiplePermissions()</span><br><span class="line">    ) &#123; result -&gt;</span><br><span class="line">        <span class="keyword">var</span> allAllow = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (allow <span class="keyword">in</span> result.values) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!allow) &#123;</span><br><span class="line">                allAllow = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allAllow) &#123;</span><br><span class="line">            onPermit()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> shouldShowCustomRequest = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (permission <span class="keyword">in</span> permissions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, permission)) &#123;</span><br><span class="line">                    shouldShowCustomRequest = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            onDeny(shouldShowCustomRequest)</span><br><span class="line">        &#125;</span><br><span class="line">        launcher.unregister()</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                launcher.unregister()</span><br><span class="line">                lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    launcher.launch(permissions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多实用技巧本质上都是很简单的，但没有接触过就很难想到，我将我的开发经验分享给大家，希望能帮助到大家。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/08/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/">Android源码分析 - Activity销毁流程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityTaskManagerService/">ActivityTaskManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityTaskManagerService/">ActivityTaskManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>我们在之前的几篇<code>Activity</code>启动流程分析中已经了解了<code>Activity</code>一半的生命周期，接下来这篇文章我们就来分析一下<code>Activity</code>销毁相关的生命周期</p>
<p>前几期文章回顾：</p>
<p><a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a></p>
<p><a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a></p>
<p><a href="https://juejin.cn/post/7195458962328649788" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a></p>
<h1 id="触发销毁"><a href="#触发销毁" class="headerlink" title="触发销毁"></a>触发销毁</h1><p>既然要分析<code>Activity</code>销毁流程，那我们就从最常见的入口<code>Activity.finish</code>入手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finish(DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的<code>finish</code>方法调用了另一个同名重载方法，接受一个int类型的参数表明是否需要在销毁<code>Activity</code>的同时销毁<code>Task</code>，该参数有以下三种：</p>
<ul>
<li><p><code>DONT_FINISH_TASK_WITH_ACTIVITY</code>：默认参数，表示在销毁<code>Activity</code>的时候不要销毁<code>Task</code></p>
</li>
<li><p><code>FINISH_TASK_WITH_ROOT_ACTIVITY</code>：当<code>Activity</code>为跟<code>Activity</code>的时候，销毁的同时销毁<code>Task</code>，同时这个任务也会从最近任务中移除</p>
</li>
<li><p><code>FINISH_TASK_WITH_ACTIVITY</code>：销毁<code>Activity</code>的时候同时销毁<code>Task</code>，但不会从最近任务中移除</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当finish后才可能会触发onActivityResult回调</span></span><br><span class="line">        <span class="comment">//这里准备将result返回给之前调用startActivityForResult的Activity</span></span><br><span class="line">        <span class="keyword">int</span> resultCode;</span><br><span class="line">        Intent resultData;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            resultCode = mResultCode;</span><br><span class="line">            resultData = mResultData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//两个Activity可能处于不同进程中，做进程间通信的准备</span></span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用ATMS销毁Activity</span></span><br><span class="line">            <span class="keyword">if</span> (ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParent.finishFromChild(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity was launched when user tapped a link in the Autofill Save UI - Save UI must</span></span><br><span class="line">    <span class="comment">// be restored now.</span></span><br><span class="line">    <span class="keyword">if</span> (mIntent != <span class="keyword">null</span> &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123;</span><br><span class="line">        restoreAutofillSaveUi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onActivityResult</code>回调是在对应<code>Activity</code> <code>resume</code>时才可能触发，具体过程后面会分析，将<code>ActivityRecord.Token</code>和<code>Result</code>作为参数调用<code>ATMS.finishActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">finishActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//回传的ResultIntent中不允许包含fd，防止泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (resultData != <span class="keyword">null</span> &amp;&amp; resultData.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//获取ActivityRecord并保证其在栈中</span></span><br><span class="line">        r = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="comment">//为null说明已被移出ActivityStack，视作已被finish</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carefully collect grants without holding lock</span></span><br><span class="line">    <span class="comment">//检查调用方（即待finish的Activity）是否能授予result所对应Activity package访问uri的权限</span></span><br><span class="line">    <span class="keyword">final</span> NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// Sanity check in case activity was removed before entering global lock.</span></span><br><span class="line">        <span class="keyword">if</span> (!r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of the root activity of the task before we finish it</span></span><br><span class="line">        <span class="keyword">final</span> Task tr = r.getTask();</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord rootR = tr.getRootActivity();</span><br><span class="line">        <span class="comment">// Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can</span></span><br><span class="line">        <span class="comment">// finish.</span></span><br><span class="line">        <span class="comment">//LockTask模式下，如果此为最后一个Task，则不允许被销毁</span></span><br><span class="line">        <span class="comment">//详见：https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode</span></span><br><span class="line">        <span class="keyword">if</span> (getLockTaskController().activityBlockedFromFinish(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> There is a dup. of this block of code in ActivityStack.navigateUpToLocked</span></span><br><span class="line">        <span class="comment">// We should consolidate.</span></span><br><span class="line">        <span class="comment">//IActivityController分发Activity状态变化</span></span><br><span class="line">        <span class="keyword">if</span> (mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">            <span class="comment">//寻找该Activity销毁后的下一个顶层Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord next =</span><br><span class="line">                    r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ask watcher if this is allowed</span></span><br><span class="line">                <span class="keyword">boolean</span> resumeOK = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resumeOK = mController.activityResuming(next.packageName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    mController = <span class="keyword">null</span>;</span><br><span class="line">                    Watchdog.getInstance().setActivityController(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!resumeOK) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note down that the process has finished an activity and is in background activity</span></span><br><span class="line">        <span class="comment">// starts grace period</span></span><br><span class="line">        <span class="comment">//设置Activity销毁的最新时间</span></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> res;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> finishWithRootActivity =</span><br><span class="line">                    finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;</span><br><span class="line">            <span class="keyword">if</span> (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY</span><br><span class="line">                    || (finishWithRootActivity &amp;&amp; r == rootR)) &#123; <span class="comment">//需要同时销毁Task</span></span><br><span class="line">                <span class="comment">// If requested, remove the task that is associated to this activity only if it</span></span><br><span class="line">                <span class="comment">// was the root activity in the task. The result code and data is ignored</span></span><br><span class="line">                <span class="comment">// because we don't support returning them across task boundaries. Also, to</span></span><br><span class="line">                <span class="comment">// keep backwards compatibility we remove the task from recents when finishing</span></span><br><span class="line">                <span class="comment">// task with root activity.</span></span><br><span class="line">                <span class="comment">//移除Task</span></span><br><span class="line">                mStackSupervisor.removeTask(tr, <span class="keyword">false</span> <span class="comment">/*killProcess*/</span>,</span><br><span class="line">                        finishWithRootActivity, <span class="string">"finish-activity"</span>);</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// Explicitly dismissing the activity so reset its relaunch flag.</span></span><br><span class="line">                r.mRelaunchReason = RELAUNCH_REASON_NONE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不需要同时销毁Task</span></span><br><span class="line">                r.finishIfPossible(resultCode, resultData, resultGrants,</span><br><span class="line">                        <span class="string">"app-request"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">                res = r.finishing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里分了两个case，当需要同时销毁<code>Task</code>的时候，直接调用<code>ActivityStackSupervisor.removeTask</code>，当不需要同时销毁<code>Task</code>的时候，调用<code>ActivityRecord.finishIfPossible</code></p>
<p>我们先看需要同时销毁<code>Task</code>的case</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTask</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task.mInRemoveTask) &#123;</span><br><span class="line">        <span class="comment">// Prevent recursion.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.mInRemoveTask = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行Task移除操作</span></span><br><span class="line">        task.performClearTask(reason);</span><br><span class="line">        <span class="comment">//对Task执行杀进程，从最近任务列表移除等操作</span></span><br><span class="line">        cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents);</span><br><span class="line">        <span class="comment">//关闭LockTask模式</span></span><br><span class="line">        mService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">        <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">        mService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        <span class="comment">//将最近任务持久化保存</span></span><br><span class="line">        <span class="keyword">if</span> (task.isPersistable) &#123;</span><br><span class="line">            mService.notifyTaskPersisterLocked(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task.mInRemoveTask = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇文章我们主要关注的是<code>Activity</code>销毁流程，至于进程的关闭，最近任务列表的更新我们在这里就不关心了，而这里<code>Activity</code>销毁的重点在于<code>Task.performClearTask</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Completely remove all activities associated with an existing task. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performClearTask</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken down into to cases to avoid object create due to capturing mStack.</span></span><br><span class="line">    <span class="keyword">if</span> (getStack() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// Task was restored from persistent storage.</span></span><br><span class="line">            r.takeFromHistory();</span><br><span class="line">            removeChild(r);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> figure-out how to avoid object creation due to capture of reason variable.</span></span><br><span class="line">            r.finishIfPossible(Activity.RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* resultData */</span>, <span class="keyword">null</span> <span class="comment">/* resultGrants */</span>, reason, <span class="keyword">false</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看后半部分代码可以发现，这个方法对<code>Task</code>中所有未销毁的<code>Activity</code>都执行了<code>ActivityRecord.finishIfPossible</code>方法，这样路径就和上面<code>ATMS.finishActivity</code>方法中第二个case统一了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish activity if possible. If activity was resumed - we must first pause it to make the</span></span><br><span class="line"><span class="comment"> * activity below resumed. Otherwise we will try to complete the request immediately by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #completeFinishing(String)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> One of &#123;<span class="doctag">@link</span> FinishRequest&#125; values:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REMOVED&#125; if this activity has been removed from the history list.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REQUESTED&#125; if removal process was started, but it is still in the list</span></span><br><span class="line"><span class="comment"> * and will be removed from history later.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_CANCELLED&#125; if activity is already finishing or in invalid state and the</span></span><br><span class="line"><span class="comment"> * request to finish it was not ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FinishRequest</span> <span class="function"><span class="keyword">int</span> <span class="title">finishIfPossible</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants, String reason, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止重复销毁</span></span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此Activity不在任务栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!isInStackLocked()) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="comment">//应该调整顶部Activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mayAdjustTop = (isState(RESUMED) || stack.mResumedActivity == <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; stack.isFocusedStackOnDisplay();</span><br><span class="line">    <span class="comment">//应该调整全局焦点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldAdjustGlobalFocus = mayAdjustTop</span><br><span class="line">            <span class="comment">// It must be checked before &#123;@link #makeFinishingLocked&#125; is called, because a stack</span></span><br><span class="line">            <span class="comment">// is not visible if it only contains finishing activities.</span></span><br><span class="line">            &amp;&amp; mRootWindowContainer.isTopDisplayFocusedStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停布局工作</span></span><br><span class="line">    mAtmService.deferWindowLayout();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置当前Activity状态为finishing</span></span><br><span class="line">        makeFinishingLocked();</span><br><span class="line">        <span class="comment">// Make a local reference to its task since this.task could be set to null once this</span></span><br><span class="line">        <span class="comment">// activity is destroyed and detached from task.</span></span><br><span class="line">        <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">        <span class="comment">//获取上一个ActivityRecord</span></span><br><span class="line">        ActivityRecord next = task.getActivityAbove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//传递FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET：重置该Task时清除此Activity</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If the caller asked that this activity (and all above it)</span></span><br><span class="line">                <span class="comment">// be cleared when the task is reset, don't lose that information,</span></span><br><span class="line">                <span class="comment">// but propagate it up to the next activity.</span></span><br><span class="line">                next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停输入事件分发</span></span><br><span class="line">        pauseKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are finishing the top focused activity and its task has nothing to be focused so</span></span><br><span class="line">        <span class="comment">// the next focusable task should be focused.</span></span><br><span class="line">        <span class="comment">//应该调整顶部Activity，但此Task没有Activity可以被运行在顶部，将焦点转移至下一个可聚焦的Task</span></span><br><span class="line">        <span class="keyword">if</span> (mayAdjustTop &amp;&amp; ((ActivityStack) task).topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>)</span><br><span class="line">                == <span class="keyword">null</span>) &#123;</span><br><span class="line">            task.adjustFocusToNextFocusableTask(<span class="string">"finish-top"</span>, <span class="keyword">false</span> <span class="comment">/* allowFocusSelf */</span>,</span><br><span class="line">                        shouldAdjustGlobalFocus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Result信息写入到对应ActivityRecord中，待后面resume的时候触发onActivityResult回调</span></span><br><span class="line">        finishActivityResults(resultCode, resultData, resultGrants);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止Task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> endTask = task.getActivityBelow(<span class="keyword">this</span>) == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !task.isClearingToReuseTask();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;</span><br><span class="line">        <span class="keyword">if</span> (isState(RESUMED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//通知Task移除已开始</span></span><br><span class="line">                mAtmService.getTaskChangeNotificationController().notifyTaskRemovalStarted(</span><br><span class="line">                        task.getTaskInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Prepare app close transition, but don't execute just yet. It is possible that</span></span><br><span class="line">            <span class="comment">// an activity that will be made resumed in place of this one will immediately</span></span><br><span class="line">            <span class="comment">// launch another new activity. In this case current closing transition will be</span></span><br><span class="line">            <span class="comment">// combined with open transition for the new activity.</span></span><br><span class="line">            <span class="comment">//准备Activity转场动画</span></span><br><span class="line">            mDisplayContent.prepareAppTransition(transit, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When finishing the activity preemptively take the snapshot before the app window</span></span><br><span class="line">            <span class="comment">// is marked as hidden and any configuration changes take place</span></span><br><span class="line">            <span class="comment">//更新Task快照</span></span><br><span class="line">            <span class="keyword">if</span> (mAtmService.mWindowManager.mTaskSnapshotController != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ArraySet&lt;Task&gt; tasks = Sets.newArraySet(task);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController.snapshotTasks(tasks);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController</span><br><span class="line">                        .addSkipClosingAppSnapshotTasks(tasks);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></span><br><span class="line">            <span class="comment">//设置可见性</span></span><br><span class="line">            setVisibility(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//开始暂停此Activity</span></span><br><span class="line">                stack.startPausingLocked(<span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* resuming */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//屏幕固定功能</span></span><br><span class="line">                mAtmService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">                <span class="comment">// This activity was in the top focused stack and this is the last activity in</span></span><br><span class="line">                <span class="comment">// that task, give this activity a higher layer so it can stay on top before the</span></span><br><span class="line">                <span class="comment">// closing task transition be executed.</span></span><br><span class="line">                <span class="comment">//更新窗口层级</span></span><br><span class="line">                <span class="keyword">if</span> (mayAdjustTop) &#123;</span><br><span class="line">                    mNeedsZBoost = <span class="keyword">true</span>;</span><br><span class="line">                    mDisplayContent.assignWindowLayers(<span class="keyword">false</span> <span class="comment">/* setLayoutNeeded */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isState(PAUSING)) &#123;</span><br><span class="line">            ... <span class="comment">//正常不会进入此case</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_REQUESTED;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mAtmService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，我们需要关注一下对于<code>Result</code>信息的处理，这里调用了<code>finishActivityResults</code>方法，将<code>Result</code>信息写入到对应<code>ActivityRecord</code>中，待后面<code>resume</code>的时候触发<code>onActivityResult</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the result for activity that started this one, clears the references to activities</span></span><br><span class="line"><span class="comment"> * started for result from this one, and clears new intents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishActivityResults</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Send the result if needed</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultTo.mUserId != mUserId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveUser(mUserId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (info.applicationInfo.uid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAtmService.mUgmInternal.grantUriPermissionUncheckedFromIntent(resultGrants,</span><br><span class="line">                    resultTo.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        resultTo.addResultLocked(<span class="keyword">this</span>, resultWho, requestCode, resultCode, resultData);</span><br><span class="line">        resultTo = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this HistoryRecord is not holding on to other resources,</span></span><br><span class="line">    <span class="comment">// because clients have remote IPC references to this object so we</span></span><br><span class="line">    <span class="comment">// can't assume that will go away and want to avoid circular IPC refs.</span></span><br><span class="line">    results = <span class="keyword">null</span>;</span><br><span class="line">    pendingResults = <span class="keyword">null</span>;</span><br><span class="line">    newIntents = <span class="keyword">null</span>;</span><br><span class="line">    setSavedState(<span class="keyword">null</span> <span class="comment">/* savedState */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Result结果添加到results列表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResultLocked</span><span class="params">(ActivityRecord from, String resultWho,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent resultData)</span> </span>&#123;</span><br><span class="line">    ActivityResult r = <span class="keyword">new</span> ActivityResult(from, resultWho,</span><br><span class="line">            requestCode, resultCode, resultData);</span><br><span class="line">    <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">        results = <span class="keyword">new</span> ArrayList&lt;ResultInfo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    results.add(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，就是将<code>Result</code>信息添加到<code>ActivityRecord.results</code>列表中</p>
<p>然后我们继续沿着<code>finish</code>主线链路走，后面有一个<code>isState</code>的判断，正常来说，<code>ActivityRecord</code>的<code>state</code>应该为<code>RESUMED</code>，具体为什么我们可以回顾一下之前分析的<code>Activity</code>启动流程，在<code>ActivityStackSupervisor.realStartActivityLocked</code>方法最后，会调用<code>ActivityStack.minimalResumeActivityLocked</code>，在这个方法中，会将<code>ActivityRecord</code>的<code>state</code>设置为<code>RESUMED</code>，由于<code>ClientTransaction</code>的执行是通过<code>Handler.sendMessage</code>进行的，所以早在<code>Activity</code> <code>onCreate</code>之前，<code>ActivityRecord</code>的状态就已经被设为了<code>RESUMED</code></p>
<p>根据以上分析，我们会走进<code>isState(RESUMED)</code>这个case中，接着调用<code>ActivityStack.startPausingLocked</code>方法暂停<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start pausing the currently resumed activity.  It is an error to call this if there</span></span><br><span class="line"><span class="comment"> * is already an activity being paused or there is no resumed activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userLeaving True if this should result in an onUserLeaving to the current activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uiSleeping True if this is happening with the user interface going to sleep (the</span></span><br><span class="line"><span class="comment"> * screen turning off).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resuming The activity we are currently trying to resume or null if this is not being</span></span><br><span class="line"><span class="comment"> *                 called as part of resuming the top activity, so we shouldn't try to instigate</span></span><br><span class="line"><span class="comment"> *                 a resume here if not null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if an activity now is in the PAUSING state, and we are waiting for</span></span><br><span class="line"><span class="comment"> * it to tell us when it is done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已有Activity正在暂停中</span></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">            <span class="comment">// Avoid recursion among check for sleep and complete pause during sleeping.</span></span><br><span class="line">            <span class="comment">// Because activity will be paused immediately after resume, just let pause</span></span><br><span class="line">            <span class="comment">// be completed by the order of activity paused from clients.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上一个已resume的Activity</span></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既没有已resume的Activity，也没有正在resume的Activity</span></span><br><span class="line">    <span class="comment">//从栈顶找一个Activity恢复</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能暂停一个正在resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (prev == resuming) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置各种状态</span></span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = prev.isNoHistory() ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">"startPausingLocked"</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新统计信息</span></span><br><span class="line">    mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pauseImmediately = <span class="keyword">false</span>;</span><br><span class="line">    ... <span class="comment">//当前流程下pauseImmediately始终为false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev.attachedToProcess()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度Pause生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),</span><br><span class="line">                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are not going to sleep, we want to ensure the device is</span></span><br><span class="line">    <span class="comment">// awake until the next activity is started.</span></span><br><span class="line">    <span class="comment">//获取Wakelock，确保设备awake状态直到下一个Activity启动</span></span><br><span class="line">    <span class="keyword">if</span> (!uiSleeping &amp;&amp; !mAtmService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">        mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Have the window manager pause its key dispatching until the new</span></span><br><span class="line">        <span class="comment">// activity has started.  If we're pausing the activity just because</span></span><br><span class="line">        <span class="comment">// the screen is being turned off and the UI is sleeping, don't interrupt</span></span><br><span class="line">        <span class="comment">// key dispatch; the same activity will pick it up again on wakeup.</span></span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            <span class="comment">//暂停输入事件分发</span></span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123; <span class="comment">//不会进入此case</span></span><br><span class="line">            <span class="comment">// If the caller said they don't want to wait for the pause, then complete</span></span><br><span class="line">            <span class="comment">// the pause now.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置超时监听（500ms内没有完成便视为超时）</span></span><br><span class="line">            prev.schedulePauseTimeout();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity failed to schedule the</span></span><br><span class="line">        <span class="comment">// pause, so just treat it as being paused now.</span></span><br><span class="line">        <span class="comment">//未能成功暂停此Activity，从栈顶找一个Activity恢复</span></span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和<code>Activity</code>启动流程类似，该方法里面调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法来调度<code>Activity</code>暂停的生命周期，具体是怎样调度的可以看我之前的文章 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a>，里面分析了<code>ClientTransaction</code>事务是怎么被调度执行的</p>
<p>了解完后我们就可以知道，生命周期事务的执行也就相当于分别调用<code>ActivityLifecycleItem</code>的<code>preExecute</code>、<code>execute</code>、<code>postExecute</code>方法，而<code>PauseActivityItem</code>没有重写<code>preExecute</code>方法，所以我们就依次分析其<code>execute</code>、<code>postExecute</code>方法就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClientTransactionHandler</code>这个我们之前说过，这是一个抽象类，被<code>ActivityThread</code>继承实现，所以这里实际上就是调用<code>ActivityThread.handlePauseActivity</code>方法</p>
<h1 id="handlePauseActivity"><a href="#handlePauseActivity" class="headerlink" title="handlePauseActivity"></a>handlePauseActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新标记</span></span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pause the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Saved instance state for pre-Honeycomb apps if it was saved, &#123;<span class="doctag">@code</span> null&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//异常状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-Honeycomb apps always save their state before pausing</span></span><br><span class="line">    <span class="comment">//是否需要保存状态信息（Android 3.0前无论是否finish都会触发保存）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState) &#123;</span><br><span class="line">        <span class="comment">//回调Activity的onSaveInstanceState方法</span></span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//回调OnActivityPausedListener，目前看来只有NFC部分有注册这个回调</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Android 3.0之前的特殊处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回保存状态的Bundle</span></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已暂停，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reporting top resumed position loss when pausing an activity. If necessary, it</span></span><br><span class="line">    <span class="comment">// will be restored in performResumeActivity().</span></span><br><span class="line">    <span class="comment">//报告resume状态变更</span></span><br><span class="line">    reportTopResumedActivityChanged(r, <span class="keyword">false</span> <span class="comment">/* onTop */</span>, <span class="string">"pausing"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//回调Activity的onPause方法</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onPause方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ...</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一条调用链路看下来还是很简单的，和之前我们分析过的其他生命周期调用是一个套路，这里显示调用了<code>callActivityOnSaveInstanceState</code>方法保存状态信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    r.state = <span class="keyword">new</span> Bundle();</span><br><span class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPreSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//回调onSaveInstanceState</span></span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//保存受管理的Dialog的状态</span></span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    <span class="comment">//保存权限请求状态</span></span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    <span class="comment">//分发PostSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPostSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终回调<code>Activity.onSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存窗口信息</span></span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    <span class="comment">//保存Fragment状态</span></span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发SaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivitySaveInstanceState回调</span></span><br><span class="line">    dispatchActivitySaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存状态的流程就基本完成了，我们再回过头来看<code>onPause</code>的触发</p>
<p>在上面<code>performPauseActivityIfNeeded</code>方法中有一行代码调用了<code>Instrumentation.callActivityOnPause</code>方法，<br>通过<code>Instrumentation</code>调用了<code>Activity.performPause</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PrePaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPrePaused回调</span></span><br><span class="line">    dispatchActivityPrePaused();</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//FragmentManager分发pause状态</span></span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//回调onPause</span></span><br><span class="line">    onPause();</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Target Sdk 9以上（Android 2.3）需要保证在onPause中调用super.onPause方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostPaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostPaused回调</span></span><br><span class="line">    dispatchActivityPostPaused();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>onPause</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发Paused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPaused回调</span></span><br><span class="line">    dispatchActivityPaused();</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAutoFillIgnoreFirstResumePause) &#123;</span><br><span class="line">            View focus = getCurrentFocus();</span><br><span class="line">            <span class="keyword">if</span> (focus != <span class="keyword">null</span> &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;</span><br><span class="line">                getAutofillManager().notifyViewExited(focus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// reset after first pause()</span></span><br><span class="line">            mAutoFillIgnoreFirstResumePause = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE);</span><br><span class="line">    <span class="comment">//super.onPause标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，<code>Activity</code>的<code>onPause</code>生命周期已经基本走完了，此时我们再回到<code>PauseActivityItem.postExecute</code>方法中做一些善后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mDontReport为我们之前obtain方法中传入的pauseImmediately参数，始终为false</span></span><br><span class="line">    <span class="keyword">if</span> (mDontReport) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        <span class="comment">//调用ATMS.activityPaused方法</span></span><br><span class="line">        ActivityTaskManager.getService().activityPaused(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>ATMS.activityPaused</code>方法回到<code>system_server</code>进程处理<code>Activity</code>暂停后的事项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//通过ActivityRecord.Token获取ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.activityPaused(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>ActivityRecord.activityPaused</code>方法继续处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(<span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//移除超时监听</span></span><br><span class="line">        removePauseTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//暂停布局工作</span></span><br><span class="line">            mAtmService.deferWindowLayout();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stack.completePauseLocked(<span class="keyword">true</span> <span class="comment">/* resumeNext */</span>, <span class="keyword">null</span> <span class="comment">/* resumingActivity */</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//恢复布局工作</span></span><br><span class="line">                mAtmService.continueWindowLayout();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//暂停Activity失败</span></span><br><span class="line">            <span class="keyword">if</span> (isState(PAUSING)) &#123;</span><br><span class="line">                setState(PAUSED, <span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    completeFinishing(<span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下会进入到<code>ActivityStack.completePauseLocked</code>方法中，但在暂停<code>Activity</code>失败的情况下，如果当前状态为<code>PAUSING</code>，则直接将其状态置为<code>PAUSED</code>已暂停，如果被标记为<code>finishing</code>，则会调用<code>ActivityRecord.completeFinishing</code>继续<code>finish</code>流程，这其实和正常情况下的调用链路差不多，具体我们往下就能看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completePauseLocked</span><span class="params">(<span class="keyword">boolean</span> resumeNext, ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.setWillCloseOrEnterPip(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//之前的状态是否为正在停止</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasStopping = prev.isState(STOPPING);</span><br><span class="line">        <span class="comment">//设置状态为已暂停</span></span><br><span class="line">        prev.setState(PAUSED, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            <span class="comment">//继续finish流程</span></span><br><span class="line">            prev = prev.completeFinishing(<span class="string">"completePausedLocked"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev.hasProcess()) &#123;</span><br><span class="line">            <span class="comment">//Configuration发生变化时可能会设置这个flag</span></span><br><span class="line">            <span class="keyword">if</span> (prev.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                <span class="comment">// Complete the deferred relaunch that was waiting for pause to complete.</span></span><br><span class="line">                <span class="comment">//等待暂停完成后relaunch Activity</span></span><br><span class="line">                prev.relaunchActivityLocked(prev.preserveWindowOnDeferredRelaunch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wasStopping) &#123;</span><br><span class="line">                <span class="comment">// We are also stopping, the stop request must have gone soon after the pause.</span></span><br><span class="line">                <span class="comment">// We can't clobber it, because the stop confirmation will not be handled.</span></span><br><span class="line">                <span class="comment">// We don't need to schedule another stop, we only need to let it happen.</span></span><br><span class="line">                <span class="comment">//之前的状态为正在停止，将状态置回即可</span></span><br><span class="line">                prev.setState(STOPPING, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev.mVisibleRequested || shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                <span class="comment">// Clear out any deferred client hide we might currently have.</span></span><br><span class="line">                prev.setDeferHidingClient(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// If we were visible then resumeTopActivities will release resources before</span></span><br><span class="line">                <span class="comment">// stopping.</span></span><br><span class="line">                <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">                prev.addToStopping(<span class="keyword">true</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                        <span class="string">"completePauseLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//App在pause过程中死亡</span></span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It is possible the activity was freezing the screen before it was paused.</span></span><br><span class="line">        <span class="comment">// In that case go ahead and remove the freeze this activity has on the screen</span></span><br><span class="line">        <span class="comment">// since it is no longer visible.</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//停止屏幕冻结</span></span><br><span class="line">            prev.stopFreezingScreenLocked(<span class="keyword">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Activity暂停完毕</span></span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复前一个顶层Activity</span></span><br><span class="line">    <span class="keyword">if</span> (resumeNext) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (topStack != <span class="keyword">null</span> &amp;&amp; !topStack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(topStack, prev, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = topStack != <span class="keyword">null</span> ? topStack.topRunningActivity() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="keyword">null</span> || (prev != <span class="keyword">null</span> &amp;&amp; top != prev)) &#123;</span><br><span class="line">                <span class="comment">// If there are no more activities available to run, do resume anyway to start</span></span><br><span class="line">                <span class="comment">// something. Also if the top activity on the stack is not the just paused</span></span><br><span class="line">                <span class="comment">// activity, we need to go ahead and resume it to ensure we complete an</span></span><br><span class="line">                <span class="comment">// in-flight app switch.</span></span><br><span class="line">                mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//恢复按键分发</span></span><br><span class="line">        prev.resumeKeyDispatchingLocked();</span><br><span class="line">        ... <span class="comment">//更新统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(resuming, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify when the task stack has changed, but only if visibilities changed (not just</span></span><br><span class="line">    <span class="comment">// focus). Also if there is an active pinned stack - we always want to notify it about</span></span><br><span class="line">    <span class="comment">// task stack changes, because its positioning may depend on it.</span></span><br><span class="line">    <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause</span><br><span class="line">            || (getDisplayArea() != <span class="keyword">null</span> &amp;&amp; getDisplayArea().hasPinnedTask())) &#123;</span><br><span class="line">        mAtmService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论暂停成功与否，最后都会走到<code>ActivityRecord.completeFinishing</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete activity finish request that was initiated earlier. If the activity is still</span></span><br><span class="line"><span class="comment"> * pausing we will wait for it to complete its transition. If the activity that should appear in</span></span><br><span class="line"><span class="comment"> * place of this one is not visible yet - we'll wait for it first. Otherwise - activity can be</span></span><br><span class="line"><span class="comment"> * destroyed right away.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for finishing the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Flag indicating whether the activity was removed from history.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ActivityRecord <span class="title">completeFinishing</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//状态检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCurrentVisible = mVisibleRequested || isState(PAUSED);</span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible) &#123;</span><br><span class="line">        ... <span class="comment">//更新Activity可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this activity is currently visible, and the resumed activity is not yet visible, then</span></span><br><span class="line">    <span class="comment">// hold off on finishing until the resumed one becomes visible.</span></span><br><span class="line">    <span class="comment">// The activity that we are finishing may be over the lock screen. In this case, we do not</span></span><br><span class="line">    <span class="comment">// want to consider activities that cannot be shown on the lock screen as running and should</span></span><br><span class="line">    <span class="comment">// proceed with finishing the activity if there is no valid next top running activity.</span></span><br><span class="line">    <span class="comment">// Note that if this finishing activity is floating task, we don't need to wait the</span></span><br><span class="line">    <span class="comment">// next activity resume and can destroy it directly.</span></span><br><span class="line">    <span class="comment">// TODO(b/137329632): find the next activity directly underneath this one, not just anywhere</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = getDisplayArea().topRunningActivity(</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* considerKeyguardState */</span>);</span><br><span class="line">    <span class="comment">// isNextNotYetVisible is to check if the next activity is invisible, or it has been</span></span><br><span class="line">    <span class="comment">// requested to be invisible but its windows haven't reported as invisible.  If so, it</span></span><br><span class="line">    <span class="comment">// implied that the current finishing activity should be added into stopping list rather</span></span><br><span class="line">    <span class="comment">// than destroy immediately.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isNextNotYetVisible = next != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (!next.nowVisible || !next.mVisibleRequested);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此Activity当前可见，而要恢复的Activity还不可见，则推迟finish，直到要恢复的Activity可见为止</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible &amp;&amp; isNextNotYetVisible) &#123;</span><br><span class="line">        <span class="comment">// Add this activity to the list of stopping activities. It will be processed and</span></span><br><span class="line">        <span class="comment">// destroyed when the next activity reports idle.</span></span><br><span class="line">        <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">        addToStopping(<span class="keyword">false</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                <span class="string">"completeFinishing"</span>);</span><br><span class="line">        <span class="comment">//设置状态为stop中</span></span><br><span class="line">        setState(STOPPING, <span class="string">"completeFinishing"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addToFinishingAndWaitForIdle()) &#123;</span><br><span class="line">        <span class="comment">// We added this activity to the finishing list and something else is becoming resumed.</span></span><br><span class="line">        <span class="comment">// The activity will complete finishing when the next activity reports idle. No need to</span></span><br><span class="line">        <span class="comment">// do anything else here.</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not waiting for the next one to become visible, and nothing else will be resumed in</span></span><br><span class="line">        <span class="comment">// place of this activity - requesting destruction right away.</span></span><br><span class="line">        <span class="comment">//立刻销毁此Activity</span></span><br><span class="line">        activityRemoved = destroyIfPossible(reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved ? <span class="keyword">null</span> : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非锁屏状态且当前要销毁的<code>Activity</code>在前台的情况下，该<code>Activity</code>可见而待恢复的<code>Activity</code>尚不可见，此时优先完成待恢复<code>Activity</code>的<code>resume</code>生命周期，等到之后空闲再去处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>所以在面试中常问的<code>Activity</code>从<code>B</code>返回到<code>A</code>的生命周期顺序我们从这里就可以看出来，理解后我们就不用去死记硬背了：</p>
<p><code>B.onPause</code> -&gt; <code>A.onRestart</code> -&gt; <code>A.onResume</code> -&gt; <code>B.onStop</code> -&gt; <code>B.onDestory</code></p>
<p>对于锁屏状态或者要销毁的<code>Activity</code>不在前台的情况下，由于不需要立刻恢复<code>Activity</code>，所以可能会直接处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>我们以第一种当前要销毁的<code>Activity</code>在前台的情况分析，此时会将这个<code>Activity</code>添加到<code>stop</code>列表中，并将状态设置为<code>STOPPING</code>，之后返回到<code>ActivityStack.completePauseLocked</code>方法中，继续执行<code>resumeNext</code>工作</p>
<p>在<code>resumeNext</code>中会调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复栈顶<code>Activity</code>，由于这个方法之前已经在<br><a href="https://juejin.cn/post/7130182223231188999#heading-6" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中分析过了，这里就不再赘述了，我们还是将目光放在销毁流程上</p>
<p>通过之前的文章，我们知道恢复<code>Activity</code>会调用到<code>ActivityThread.handleResumeActivity</code>方法，而当<code>Activity</code>恢复完毕后，此方法最后一行会向<code>MessageQueue</code>添加一个<code>IdleHandler</code>，关于<code>IdleHandler</code>这里就不再介绍了，这是每位<code>Android</code>开发都应该了解的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Idler</code>是<code>ActivityThread</code>的一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="comment">//遍历整条ActivityClientRecord.nextIdle链，依次调用ATMS.activityIdle</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历整个进程内所有的<code>ActivityClientRecord</code>，并依次调用<code>ATMS.activityIdle</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStackSupervisor.activityIdleInternal(r, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>ActivityRecord.Token</code>获取到<code>ActivityRecord</code>，接着调用<code>ActivityStackSupervisor.activityIdleInternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityIdleInternal</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    processStoppingAndFinishingActivities(r, processPausingActivities, <span class="string">"idle"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需要重点关注<code>processStoppingAndFinishingActivities</code>这一个方法，从方法名我们也能看出来，它是用来处理<code>Activity</code> <code>stop</code>或<code>destroy</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processes the activities to be stopped or destroyed. This should be called when the resumed</span></span><br><span class="line"><span class="comment"> * activities are idle or drawn.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStoppingAndFinishingActivities</span><span class="params">(ActivityRecord launchedActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been waiting for the transition</span></span><br><span class="line">    <span class="comment">// animation to finish.</span></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; readyToStopActivities = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mStoppingActivities.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord s = mStoppingActivities.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> animating = s.isAnimating(TRANSITION | PARENTS,</span><br><span class="line">                ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS);</span><br><span class="line">        <span class="comment">//不在动画中或者ATMS服务正在关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!animating || mService.mShuttingDown) &#123;</span><br><span class="line">            <span class="comment">//跳过正在pause的Activitiy</span></span><br><span class="line">            <span class="keyword">if</span> (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123;</span><br><span class="line">                <span class="comment">// Defer processing pausing activities in this iteration and reschedule</span></span><br><span class="line">                <span class="comment">// a delayed idle to reprocess it again</span></span><br><span class="line">                removeIdleTimeoutForActivity(launchedActivity);</span><br><span class="line">                scheduleIdleTimeout(launchedActivity);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readyToStopActivities == <span class="keyword">null</span>) &#123;</span><br><span class="line">                readyToStopActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将准备好stop的Activitiy加入列表中</span></span><br><span class="line">            readyToStopActivities.add(s);</span><br><span class="line"></span><br><span class="line">            mStoppingActivities.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numReadyStops = readyToStopActivities == <span class="keyword">null</span> ? <span class="number">0</span> : readyToStopActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        <span class="comment">//Activity是否在任务栈中</span></span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                <span class="comment">// TODO(b/137329632): Wait for idle of the right activity, not just any.</span></span><br><span class="line">                <span class="comment">//被标记为finishing，尝试销毁Activity</span></span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则仅仅只是stop Activity</span></span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numFinishingActivities = mFinishingActivities.size();</span><br><span class="line">    <span class="keyword">if</span> (numFinishingActivities == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish any activities that are scheduled to do so but have been waiting for the next one</span></span><br><span class="line">    <span class="comment">// to start.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; finishingActivities = <span class="keyword">new</span> ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">    mFinishingActivities.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFinishingActivities; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = finishingActivities.get(i);</span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">            r.destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>, <span class="string">"finish-"</span> + reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于被标记为<code>finishing</code>的<code>Activity</code>，调用<code>destroyIfPossible</code>方法销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy and cleanup the activity both on client and server if possible. If activity is the</span></span><br><span class="line"><span class="comment"> * last one left on display with home stack and there is no other running activity - delay</span></span><br><span class="line"><span class="comment"> * destroying it until the next one starts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyIfPossible</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    setState(FINISHING, <span class="string">"destroyIfPossible"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the record is cleaned out of other places.</span></span><br><span class="line">    <span class="comment">//确保此Activity已从待stop列表中移除</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = taskDisplayArea.topRunningActivity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLastStackOverEmptyHome =</span><br><span class="line">            next == <span class="keyword">null</span> &amp;&amp; stack.isFocusedStackOnDisplay()</span><br><span class="line">                    &amp;&amp; taskDisplayArea.getOrCreateRootHomeTask() != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLastStackOverEmptyHome) &#123;</span><br><span class="line">        <span class="comment">// Don't destroy activity immediately if this is the last activity on the display and</span></span><br><span class="line">        <span class="comment">// the display contains home stack. Although there is no next activity at the moment,</span></span><br><span class="line">        <span class="comment">// another home activity should be started later. Keep this activity alive until next</span></span><br><span class="line">        <span class="comment">// home activity is resumed. This way the user won't see a temporary black screen.</span></span><br><span class="line">        <span class="comment">//如果Home栈存在且这是当前焦点栈中最后一个Activity，则不要立即销毁它</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">        addToFinishingAndWaitForIdle();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置finishing标记（之前设过了，这里是重复设置）</span></span><br><span class="line">    makeFinishingLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> activityRemoved = destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>,</span><br><span class="line">            <span class="string">"finish-imm:"</span> + reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the display does not have running activity, the configuration may need to be</span></span><br><span class="line">    <span class="comment">// updated for restoring original orientation of the display.</span></span><br><span class="line">    <span class="comment">//更新可见性和屏幕显示方向</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(),</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新恢复栈顶Activity</span></span><br><span class="line">    <span class="keyword">if</span> (activityRemoved) &#123;</span><br><span class="line">        mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了最后的一些判断，然后调用<code>destroyImmediately</code>方法，立刻执行Activity的销毁流程（这里和上一个方法<code>processStoppingAndFinishingActivities</code>中，待<code>finish</code>列表的处理是一样的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy the current CLIENT SIDE instance of an activity. This may be called both when</span></span><br><span class="line"><span class="comment"> * actually finishing an activity, or when performing a configuration switch where we destroy</span></span><br><span class="line"><span class="comment"> * the current client-side object but then create a new client-side object for this same</span></span><br><span class="line"><span class="comment"> * HistoryRecord.</span></span><br><span class="line"><span class="comment"> * Normally the server-side record will be removed when the client reports back after</span></span><br><span class="line"><span class="comment"> * destruction. If, however, at this point there is no client process attached, the record will</span></span><br><span class="line"><span class="comment"> * be removed immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if activity was immediately removed from history, &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyImmediately</span><span class="params">(<span class="keyword">boolean</span> removeFromApp, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经被销毁或正在被销毁，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isState(DESTROYING, DESTROYED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> removedFromHistory = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理工作</span></span><br><span class="line">    cleanUp(<span class="keyword">false</span> <span class="comment">/* cleanServices */</span>, <span class="keyword">false</span> <span class="comment">/* setState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasProcess()) &#123;</span><br><span class="line">        <span class="comment">//清理更新工作</span></span><br><span class="line">        <span class="keyword">if</span> (removeFromApp) &#123;</span><br><span class="line">            app.removeActivity(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!app.hasActivities()) &#123;</span><br><span class="line">                mAtmService.clearHeavyWeightProcessIfEquals(app);</span><br><span class="line">                <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">                <span class="comment">// their client may have activities.</span></span><br><span class="line">                <span class="comment">// No longer have activities, so update LRU list and oom adj.</span></span><br><span class="line">                <span class="comment">//更新进程信息</span></span><br><span class="line">                app.updateProcessInfo(<span class="keyword">true</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> skipDestroy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度销毁生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken,</span><br><span class="line">                    DestroyActivityItem.obtain(finishing, configChangeFlags));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// We can just ignore exceptions here...  if the process has crashed, our death</span></span><br><span class="line">            <span class="comment">// notification will clean things up.</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//从历史任务中移除</span></span><br><span class="line">                removeFromHistory(reason + <span class="string">" exceptionInScheduleDestroy"</span>);</span><br><span class="line">                removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">                skipDestroy = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nowVisible = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the activity is finishing, we need to wait on removing it from the list to give it</span></span><br><span class="line">        <span class="comment">// a chance to do its cleanup.  During that time it may make calls back with its token</span></span><br><span class="line">        <span class="comment">// so we need to be able to find it on the list and so we don't want to remove it from</span></span><br><span class="line">        <span class="comment">// the list yet.  Otherwise, we can just immediately put it in the destroyed state since</span></span><br><span class="line">        <span class="comment">// we are not removing it from the list.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing &amp;&amp; !skipDestroy) &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYING,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. finishing and not skipping destroy"</span>);</span><br><span class="line">            <span class="comment">//设置销毁超时回调</span></span><br><span class="line">            mAtmService.mH.postDelayed(mDestroyTimeoutRunnable, DESTROY_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYED,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. not finishing or skipping destroy"</span>);</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove this record from the history.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程，从历史任务中移除</span></span><br><span class="line">            removeFromHistory(reason + <span class="string">" hadNoApp"</span>);</span><br><span class="line">            removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程且不在finishing中，直接设置状态为已被销毁</span></span><br><span class="line">            setState(DESTROYED, <span class="string">"destroyActivityLocked. not finishing and had no app"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configChangeFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removedFromHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h1><p>这个方法做了一些清理工作，重头戏在于调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法调度销毁生命周期事务，接下来我们就重点分析这个事务的执行路径</p>
<p><code>scheduleTransaction</code>的调用链路我们在 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a> 中已经分析过了，这里我就简单的标注一下流程：</p>
<p><code>ClientLifecycleManager.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.schedule</code> -&gt;<br><code>ActivityThread.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.preExecute</code> -&gt;<br><code>ActivityLifecycleItem.preExecute</code>-&gt;<br><code>ActivityThread.sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction)</code> -&gt;<br><code>TransactionExecutor.execute</code> -&gt;<br><code>TransactionExecutor.executeCallbacks</code> -&gt;<br><code>TransactionExecutor.executeLifecycleState</code> -&gt;<br><code>TransactionExecutor.cycleToPath</code> -&gt;<br><code>ActivityLifecycleItem.execute</code> -&gt;<br><code>ActivityLifecycleItem.postExecute</code></p>
<p>这里的链路基本上和<code>Activity</code>启动事务链路相差无几，甚至更短了（<code>Activity</code>销毁事务没有添加<code>callback</code>），所以没看过我上篇文章的强烈推荐去看一下，这里我就不再做分析了</p>
<p>我们从<code>TransactionExecutor.cycleToPath</code>开始，之前我们分析过，我们在事务中设置的<code>ActivityLifecycleItem</code>代表了<code>Activity</code>最终需要到达执行的生命周期，而中间的那些过渡生命周期就由<code>cycleToPath</code>方法推进执行，我们目前的生命周期状态为<code>ON_PAUSE</code>，而我们的目标生命周期为<code>ON_DESTROY</code>，中间还夹着一个<code>ON_STOP</code>，所以这个方法会帮我们执行<code>ClientTransactionHandler.handleStopActivity</code>方法，也就是<code>ActivityThread.handleStopActivity</code>方法</p>
<h1 id="handleStopActivity"><a href="#handleStopActivity" class="headerlink" title="handleStopActivity"></a>handleStopActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">    <span class="comment">//执行onStop生命周期</span></span><br><span class="line">    performStopActivityInner(r, stopInfo, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">            reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新可见性</span></span><br><span class="line">    updateVisibility(r, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录Stop信息（不过在后续销毁链路中似乎并没有被用到）</span></span><br><span class="line">    stopInfo.setActivity(r);</span><br><span class="line">    stopInfo.setState(r.state);</span><br><span class="line">    stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">    pendingActions.setStopInfo(stopInfo);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的路径就和其他生命周期差不多了，大部分内容我都用注释标注了，大家顺着往下看就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Core implementation of stopping an activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r Target activity client record.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info Action that will report activity stop to server.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> saveState Flag indicating whether the activity state should be saved.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalStateRequest Flag indicating if this call is handling final lifecycle state</span></span><br><span class="line"><span class="comment"> *                          request for a transaction.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for performing this operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r, StopInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> saveState, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//异常状态处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//设置描述（Activity.onCreateDescription）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调Activity的onStop方法</span></span><br><span class="line">        callActivityOnStop(r, saveState, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls &#123;<span class="doctag">@link</span> Activity#onStop()&#125; and &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125;, and updates</span></span><br><span class="line"><span class="comment"> * the client record's state.</span></span><br><span class="line"><span class="comment"> * All calls to stop an activity must be done through this method to make sure that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125; is also executed in the same call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnStop</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Before P onSaveInstanceState was called before onStop, starting with P it's</span></span><br><span class="line">    <span class="comment">// called after. Before Honeycomb state was always saved before onPause.</span></span><br><span class="line">    <span class="comment">//这里shouldSaveState为true，因为activity.mFinished早在performPauseActivity的时候就被设为了true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; !r.isPreHoneycomb();</span><br><span class="line">    <span class="comment">//targetSdkVersion为Android P (Android 9)之前</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPreP = r.isPreP();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行stop生命周期</span></span><br><span class="line">        r.activity.performStop(r.mPreserveWindow, reason);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置生命周期状态</span></span><br><span class="line">    r.setState(ON_STOP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStop</span><span class="params">(<span class="keyword">boolean</span> preserveWindow, String reason)</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Loader相关，详见https://developer.android.com/guide/components/loaders</span></span><br><span class="line">    mFragments.doLoaderStop(mChangingConfigurations <span class="comment">/*retain*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow entering picture-in-picture after the activity has been stopped</span></span><br><span class="line">    <span class="comment">//stop后禁用画中画</span></span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="comment">//分发PreStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreStopped回调</span></span><br><span class="line">        dispatchActivityPreStopped();</span><br><span class="line">        <span class="comment">//关闭所有子窗口</span></span><br><span class="line">        <span class="keyword">if</span> (mWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mWindow.closeAllPanels();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we're preserving the window, don't setStoppedState to true, since we</span></span><br><span class="line">        <span class="comment">// need the window started immediately again. Stopping the window will</span></span><br><span class="line">        <span class="comment">// destroys hardware resources and causes flicker.</span></span><br><span class="line">        <span class="keyword">if</span> (!preserveWindow &amp;&amp; mToken != <span class="keyword">null</span> &amp;&amp; mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置停止状态，释放硬件资源，销毁Surface</span></span><br><span class="line">            WindowManagerGlobal.getInstance().setStoppedState(mToken, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//FragmentManager分发stop状态</span></span><br><span class="line">        mFragments.dispatchStop();</span><br><span class="line"></span><br><span class="line">        mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//执行onStop回调</span></span><br><span class="line">        mInstrumentation.callActivityOnStop(<span class="keyword">this</span>);</span><br><span class="line">        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);</span><br><span class="line">        <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onStop方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onStop()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放Cursors</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mManagedCursors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                ManagedCursor mc = mManagedCursors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!mc.mReleased) &#123;</span><br><span class="line">                    mc.mCursor.deactivate();</span><br><span class="line">                    mc.mReleased = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">        dispatchActivityPostStopped();</span><br><span class="line">    &#125;</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>执行<code>onStop</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ActionBar动画</span></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) mActionBar.setShowHideAnimationEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//共享元素动画</span></span><br><span class="line">    mActivityTransitionState.onStop();</span><br><span class="line">    <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">    dispatchActivityStopped();</span><br><span class="line">    mTranslucentCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//super.onStop标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    mEnterAnimationComplete = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一整个<code>onStop</code>生命周期就执行完成了，最后还剩下个<code>onDestroy</code>，根据之前写的事务调度链路，现在应该走到了<code>DestroyActivityItem.execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleDestroyActivity(token, mFinished, mConfigChanges,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>, <span class="string">"DestroyActivityItem"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上就直接调用了<code>ActivityThread.handleDestroyActivity</code>方法</p>
<h1 id="handleDestroyActivity"><a href="#handleDestroyActivity" class="headerlink" title="handleDestroyActivity"></a>handleDestroyActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行onDestroy生命周期</span></span><br><span class="line">    ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//清理之前设置的延时移除的window</span></span><br><span class="line">        cleanUpPendingRemoveWindows(r, finishing);</span><br><span class="line">        WindowManager wm = r.activity.getWindowManager();</span><br><span class="line">        View v = r.activity.mDecor;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                mNumVisibleActivities--;</span><br><span class="line">            &#125;</span><br><span class="line">            IBinder wtoken = v.getWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    <span class="comment">// Hold off on removing this until the new activity's</span></span><br><span class="line">                    <span class="comment">// window is being added.</span></span><br><span class="line">                    r.mPendingRemoveWindow = r.window;</span><br><span class="line">                    r.mPendingRemoveWindowManager = wm;</span><br><span class="line">                    <span class="comment">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class="line">                    <span class="comment">// everything else must be removed, because it might not be able to</span></span><br><span class="line">                    <span class="comment">// behave properly when activity is relaunching.</span></span><br><span class="line">                    <span class="comment">//从DecorView中移除ContentView</span></span><br><span class="line">                    r.window.clearContentView();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//立刻执行View的移除操作，释放硬件资源，销毁Surface，回调View.onDetachedFromWindow</span></span><br><span class="line">                    wm.removeViewImmediate(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (wtoken != <span class="keyword">null</span> &amp;&amp; r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//移除指定Window下的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAll(wtoken,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We're preserving only one window, others should be closed so app views</span></span><br><span class="line">                <span class="comment">// will be detached before the final tear down. It should be done now because</span></span><br><span class="line">                <span class="comment">// some components (e.g. WebView) rely on detach callbacks to perform receiver</span></span><br><span class="line">                <span class="comment">// unregister and other cleanup.</span></span><br><span class="line">                <span class="comment">//移除指定Window下除了当前DecorView以外的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAllExceptView(token, v,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.mDecor = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are delaying the removal of the activity window, then</span></span><br><span class="line">            <span class="comment">// we can't clean up all windows here.  Note that we can't do</span></span><br><span class="line">            <span class="comment">// so later either, which means any windows that aren't closed</span></span><br><span class="line">            <span class="comment">// by the app will leak.  Well we try to warning them a lot</span></span><br><span class="line">            <span class="comment">// about leaking windows, because that is a bug, so if they are</span></span><br><span class="line">            <span class="comment">// using this recreate facility then they get to live with leaks.</span></span><br><span class="line">            WindowManagerGlobal.getInstance().closeAll(token,</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mocked out contexts won't be participating in the normal</span></span><br><span class="line">        <span class="comment">// process lifecycle, but if we're running with a proper</span></span><br><span class="line">        <span class="comment">// ApplicationContext we need to have it tear down things</span></span><br><span class="line">        <span class="comment">// cleanly.</span></span><br><span class="line">        <span class="comment">//清理Context</span></span><br><span class="line">        Context c = r.activity.getBaseContext();</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">            ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理一些销毁后的事项，移除超时回调等</span></span><br><span class="line">            ActivityTaskManager.getService().activityDestroyed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Window</code>这块的处理我目前也不太了解，等以后我学习了<code>WMS</code>那块再补吧</p>
<p>其他的和之前的套路一样，调用<code>performDestroyActivity</code>方法执行销毁<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Core implementation of activity destroy call. */</span></span><br><span class="line"><span class="function">ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activityClass = r.activity.getClass();</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被停职则先执行stop生命周期</span></span><br><span class="line">        <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">            callActivityOnStop(r, <span class="keyword">false</span> <span class="comment">/* saveState */</span>, <span class="string">"destroy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">            ... <span class="comment">//getNonConfigInstance为false，这里不执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//执行onDestroy回调</span></span><br><span class="line">            mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">            <span class="comment">//必须要调用super.onDestroy方法</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                    <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭所有子窗口</span></span><br><span class="line">            <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.window.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置生命周期状态</span></span><br><span class="line">        r.setState(ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲时清理资源</span></span><br><span class="line">    schedulePurgeIdler();</span><br><span class="line">    <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">    <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">    <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        mActivities.remove(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格模式更新Activity计数器，与实际Activity数量对比，判断是否产生内存泄漏</span></span><br><span class="line">    StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performDestroy</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreDestroyed回调</span></span><br><span class="line">    dispatchActivityPreDestroyed();</span><br><span class="line">    mDestroyed = <span class="keyword">true</span>;</span><br><span class="line">    mWindow.destroy();</span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">    onDestroy();</span><br><span class="line">    EventLogTags.writeWmOnDestroyCalled(mIdent, getComponentName().getClassName(),</span><br><span class="line">            <span class="string">"performDestroy"</span>);</span><br><span class="line">    mFragments.doLoaderDestroy();</span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.detachActivity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostDestroyed回调</span></span><br><span class="line">    dispatchActivityPostDestroyed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onDestroy标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dismiss any dialogs we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Dialog</span></span><br><span class="line">    <span class="keyword">if</span> (mManagedDialogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDialogs = mManagedDialogs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDialogs; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (md.mDialog.isShowing()) &#123;</span><br><span class="line">                md.mDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedDialogs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close any cursors we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Cursor</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCursors = mManagedCursors.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCursors; i++) &#123;</span><br><span class="line">            ManagedCursor c = mManagedCursors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.mCursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedCursors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close any open search dialog</span></span><br><span class="line">    <span class="comment">//关闭系统搜索服务的弹窗</span></span><br><span class="line">    <span class="keyword">if</span> (mSearchManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSearchManager.stopSearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActionBar.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分发Destroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityDestroyed回调</span></span><br><span class="line">    dispatchActivityDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DestroyActivityItem</code>没有重写<code>postExecute</code>方法，所以到此为止，<code>Activity</code>整个销毁流程就结束了</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>我们通过本篇文章的分析，可以发现，触发<code>Activity</code>销毁后，<code>onStop</code>和<code>onDestroy</code>这两个生命周期回调的触发时机是不确定的，如果有需求需要在确定<code>Activity</code>要被销毁后立刻执行，我们可以在<code>onPause</code>回调中调用<code>Activity.isFinishing</code>方法判断<code>mFinished</code>标志是否被置<code>true</code>，如果为<code>true</code>则可以判定这个<code>Activity</code>将被销毁</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，<code>Activity</code>的启动流程和销毁流程我们都分析完了，后面应该暂时不会再写<code>Activity</code>相关的源码分析了</p>
<p>之后的一段时间，我可能会将我的精力投入到<code>AIGC</code>的技术调研中，<code>Android源码分析</code>这一系列的后续更新可能会放慢，希望大家多多谅解</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/02/06/android/aosp/WSL%E7%BC%96%E8%AF%91AOSP%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/">WSL编译AOSP必要的几个前置工作</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/AOSP/">AOSP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AOSP/">AOSP</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先，关于<code>AOSP</code>的编译可以查看我的这篇文章：<a href="https://juejin.cn/post/7042921660336308231" target="_blank" rel="noopener">AOSP的编译及刷机</a></p>
<p>我之前都是在<code>MacOS</code>上构建的<code>AOSP</code>的，但是自2021年6月22日起，<code>AOSP</code>不再支持在<code>Windows</code>或<code>MacOS</code>上构建，但我又不想给我的电脑安装<code>Ubuntu</code>双系统，只得另寻他路，在<code>Windows</code>上使用<code>WSL</code>就是一个很好的选择。</p>
<p>其实之前我尝试过用<code>WSL</code>编译<code>AOSP</code>，但几次都失败了，这次过年回家潜心研究了几天，总算是成功了，我会将我之前失败的原因和这次成功的心得总结分享给大家，教大家如何避坑</p>
<h1 id="关于NAS"><a href="#关于NAS" class="headerlink" title="关于NAS"></a>关于NAS</h1><p>我是将我的<code>AOSP</code>源码放在<code>NAS</code>上进行编译的，毕竟磁盘空间够大，而且共享起来也方便，但需要千万注意 <strong>不要使用<code>SMB</code>协议共享<code>AOSP</code>源码编译</strong>，这样做直接就会卡在源码<code>sync</code>完后的<code>lunch</code>那一步，可以使用<code>iSCSI</code>协议将<code>NAS</code>上的一部分磁盘空间映射成一个虚拟磁盘，这样在<code>Windows</code>上就可以将这块磁盘当成普通的硬盘使用，几乎完全没有区别</p>
<h1 id="修改大小写敏感"><a href="#修改大小写敏感" class="headerlink" title="修改大小写敏感"></a>修改大小写敏感</h1><p>在同步<code>AOSP</code>源码前一定要做的工作，不然你就等着把辛苦下载好的源码删了重新下吧</p>
<p>在同步<code>AOSP</code>源码之前，我们会首先创建一个新的目录用来保存它，我们新建完这个目录后，用<strong>管理员身份</strong>打开<code>Windows</code>的<code>Powershell</code>，执行以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsutil.exe file setCaseSensitiveInfo &lt;path&gt; enable</span><br></pre></td></tr></table></figure>

<p>其中的<code>path</code>就是刚新建用来同步<code>AOSP</code>源码的目录，需要注意的是，这个命令只对指定的目录有效，不会改变已存在的子目录的大小写敏感，所以千万要在同步代码之前做这件事</p>
<h1 id="重新挂载磁盘"><a href="#重新挂载磁盘" class="headerlink" title="重新挂载磁盘"></a>重新挂载磁盘</h1><p>如果你的<code>AOSP</code>源码放在了<code>Windows</code>驱动器上，比如说 <code>F:\aosp</code> ，在<code>WSL</code>中的路径应该是 <code>/mnt/f/aosp</code> 这种形式的，此时需要以<code>drvfs</code>文件系统重新挂载盘符，否则编译到中途会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt/f</span><br><span class="line">sudo mount -t drvfs F: /mnt/f -o metadata</span><br></pre></td></tr></table></figure>

<p>注意，每次<code>WSL</code>重启，在编译<code>AOSP</code>之前都需要执行这步操作，当然你也可以将它新建成<code>WSL</code>的一个开机服务，确保每次打开<code>WSL</code>都会执行这两段命令</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>可以发现，用<code>WSL</code>编译出错主要还是文件系统的问题，经过以上几步前置工作，相信你一定可以顺利的编译<code>AOSP</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/07/android/common/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5/">史上最完美的Android沉浸式状态导航栏攻略</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/">沉浸式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/">状态栏</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/">导航栏</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/StatusBar/">StatusBar</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/NavigationBar/">NavigationBar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android/">Android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/">沉浸式</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/">状态栏</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/">导航栏</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/StatusBar/">StatusBar</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NavigationBar/">NavigationBar</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近我在小破站开发一款新App，叫<strong>高能链</strong>。我是一个完美主义者，所以不管对架构还是UI，我都是比较抠细节的，在状态栏和导航栏沉浸式这一块，我还是踩了挺多坑，费了挺多精力的。这次我将我踩坑，适配各机型总结出来的史上最完美的Android沉浸式状态导航栏攻略分享给大家，大家也可以去 <strong><a href="https://www.upowerchain.com/" target="_blank" rel="noopener">高能链官网</a></strong> 下载体验一下我们的App，实际感受一下沉浸式状态导航栏的效果（登录，实名等账号相关页面由于不是我开发的，就没有适配沉浸式导航栏啦，嘻嘻）</p>
<p><strong>注：此攻略只针对 Android 5.0 及以上机型，即 minSdkVersion &gt;= 21</strong></p>
<h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><p>在开始攻略之前，我们先看看完美的沉浸式状态导航栏效果</p>
<h2 id="传统三键式导航栏"><a href="#传统三键式导航栏" class="headerlink" title="传统三键式导航栏"></a>传统三键式导航栏</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E5%88%97%E8%A1%A8%E9%A1%B5_%E4%B8%89%E9%94%AE%E5%BC%8F.jpg" alt="客态列表页_三键式"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E8%AF%A6%E6%83%85%E9%A1%B5_%E4%B8%89%E9%94%AE%E5%BC%8F.jpg" alt="客态详情页_三键式"></p>
<h2 id="全面屏导航条"><a href="#全面屏导航条" class="headerlink" title="全面屏导航条"></a>全面屏导航条</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E5%88%97%E8%A1%A8%E9%A1%B5_%E5%AF%BC%E8%88%AA%E6%9D%A1.jpg" alt="客态列表页_导航条"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E8%AF%A6%E6%83%85%E9%A1%B5_%E5%AF%BC%E8%88%AA%E6%9D%A1.jpg" alt="客态详情页_导航条"></p>
<h1 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h1><p>在上具体实现代码之前，我们先分析一下，实现沉浸式状态导航栏需要几步</p>
<ol>
<li><p>状态栏导航栏底色透明</p>
</li>
<li><p>根据当前页面的背景色，给状态栏字体和导航栏按钮（或导航条）设置亮色或暗色</p>
</li>
<li><p>状态栏导航栏设置透明后，我们页面的布局会延伸到原本状态栏导航栏的位置，这时候需要一些手段将我们需要显示的正文内容回缩到其正确的显示范围内</p>
<p> 这里我给大家提供以下几种思路，大家可以根据实际情况自行选择：</p>
<ul>
<li>设置<code>fitsSystemWindows</code>属性</li>
<li>根据状态栏导航栏的高度，给根布局设置相应的<code>paddingTop</code>和<code>paddingBottom</code></li>
<li>根据状态栏导航栏的高度，给需要移位的控件设置相应的<code>marginTop</code>和<code>marginBottom</code></li>
<li>在顶部和底部增加两个占位的<code>View</code>，高度分别设置成状态栏和导航栏的高度</li>
<li>针对滑动视图，巧用<code>clipChildren</code>和<code>clipToPadding</code>属性（可参照高能链藏品详情页样式）</li>
</ul>
</li>
</ol>
<h1 id="沉浸式状态栏"><a href="#沉浸式状态栏" class="headerlink" title="沉浸式状态栏"></a>沉浸式状态栏</h1><p>思路说完了，我们现在开始进入实战，沉浸式状态栏比较简单，没什么坑</p>
<h2 id="状态栏透明"><a href="#状态栏透明" class="headerlink" title="状态栏透明"></a>状态栏透明</h2><p>首先第一步，我们需要将状态栏的背景设置为透明，这里我直接放代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transparentStatusBar</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)</span><br><span class="line">    <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">    systemUiVisibility =</span><br><span class="line">        systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">    window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    window.statusBarColor = Color.TRANSPARENT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置状态栏文字颜色</span></span><br><span class="line">    setStatusBarTextColor(window, NightMode.isNightMode(window.context))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们需要将<code>FLAG_TRANSLUCENT_STATUS</code>这个<code>windowFlag</code>换成<code>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</code>，否则状态栏不会完全透明，会有一个半透明的灰色蒙层</p>
<p><code>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</code>这个<code>flag</code>表示系统<code>Bar</code>的背景将交给当前<code>window</code>绘制</p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code>这个<code>flag</code>表示<code>Activity</code>全屏显示，但状态栏不会被隐藏，依然可见</p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_STABLE</code>这个<code>flag</code>表示保持整个<code>View</code>稳定，使<code>View</code>不会因为系统UI的变化而重新<code>layout</code></p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code>和<code>SYSTEM_UI_FLAG_LAYOUT_STABLE</code>这两个<code>flag</code>通常是一起使用的，我们设置这两个<code>flag</code>，然后再将<code>statusBarColor</code>设置为透明，就达成了状态栏背景透明的效果</p>
<h2 id="状态栏文字颜色"><a href="#状态栏文字颜色" class="headerlink" title="状态栏文字颜色"></a>状态栏文字颜色</h2><p>接着我们就该设置状态栏文字颜色了，细心的小伙伴们应该已经注意到了，我在<code>transparentStatusBar</code>方法的末尾加了一个<code>setStatusBarTextColor</code>的方法调用，一般情况下，如果是日间模式，页面背景通常都是亮色，所以此时状态栏文字颜色设置为黑色比较合理，而在夜间模式下，页面背景通常都是暗色，此时状态栏文字颜色设置为白色比较合理，对应代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setStatusBarTextColor</span><span class="params">(window: <span class="type">Window</span>, light: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">        systemUiVisibility = <span class="keyword">if</span> (light) &#123; <span class="comment">//白色文字</span></span><br><span class="line">            systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑色文字</span></span><br><span class="line">            systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</span><br><span class="line">        &#125;</span><br><span class="line">        window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android 8.0</code>以上才支持导航栏文字颜色的修改，<code>SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</code>这个<code>flag</code>表示亮色状态栏，即黑色状态栏文字，所以如果希望状态栏文字为黑色，就设置这个<code>flag</code>，如果希望状态栏文字为白色，就将这个<code>flag</code>从<code>systemUiVisibility</code>中剔除</p>
<p>可能有小伙伴不太了解<code>kotlin</code>中的位运算，<code>kotlin</code>中的<code>or</code>、<code>and</code>、<code>inv</code>分别对应着或、与、取反运算</p>
<p>所以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()</span><br></pre></td></tr></table></figure>

<p>翻译成<code>java</code>即为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</span><br></pre></td></tr></table></figure>

<p>在原生系统上，这么设置就可以成功设置状态栏文字颜色，但我发现，在某些系统上，这样设置后的效果是不可预期的，譬如<code>MIUI</code>系统的状态栏文字颜色似乎是根据状态栏背景颜色自适应的，且日间模式和黑夜模式下的自适应策略还略有不同。不过在大多数情况下，它自适应的颜色都是正常的，我们就按照我们希望的结果设置就可以了。</p>
<h2 id="矫正显示区域"><a href="#矫正显示区域" class="headerlink" title="矫正显示区域"></a>矫正显示区域</h2><h3 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>矫正状态栏显示区域最简单的办法就是设置<code>fitsSystemWindows</code>属性，设置了该属性的<code>View</code>的所有<code>padding</code>属性都将失效，并且系统会自动为其添加<code>paddingTop</code>（设置了透明状态栏的情况下）和<code>paddingBottom</code>（设置了透明导航栏的情况下）</p>
<p>我个人是不用这种方式的，首先它会覆盖你设置的<code>padding</code>，其次，如果你同时设置了透明状态栏和透明导航栏，这个属性没有办法分开来处理，很不灵活</p>
<h3 id="获取状态栏高度"><a href="#获取状态栏高度" class="headerlink" title="获取状态栏高度"></a>获取状态栏高度</h3><p>除了<code>fitsSystemWindows</code>这种方法外，其他的方法都得依靠获取状态栏高度了，这里直接上代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStatusBarHeight</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resId = context.resources.getIdentifier(</span><br><span class="line">        <span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>, <span class="string">"android"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> context.resources.getDimensionPixelSize(resId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态栏不像导航栏那样多变，所以直接这样获取高度就可以了，导航栏的高度飘忽不定才是真正的噩梦</p>
<p>这里再给两个设置<code>View</code> <code>margin</code>或<code>padding</code>的工具方法吧，帮助大家快速使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fixStatusBarMargin</span><span class="params">(<span class="keyword">vararg</span> views: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    views.forEach &#123; view -&gt;</span><br><span class="line">        (view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123; lp -&gt;</span><br><span class="line">            lp.topMargin = lp.topMargin + getStatusBarHeight(view.context)</span><br><span class="line">            view.requestLayout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">paddingByStatusBar</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    view.setPadding(</span><br><span class="line">        view.paddingLeft,</span><br><span class="line">        view.paddingTop + getStatusBarHeight(view.context),</span><br><span class="line">        view.paddingRight,</span><br><span class="line">        view.paddingBottom</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="沉浸式导航栏"><a href="#沉浸式导航栏" class="headerlink" title="沉浸式导航栏"></a>沉浸式导航栏</h1><p>沉浸式导航栏相比沉浸式状态栏坑会多很多，具体原因我们后面再说</p>
<h2 id="导航栏透明"><a href="#导航栏透明" class="headerlink" title="导航栏透明"></a>导航栏透明</h2><p>和沉浸式状态栏一样，第一步我们需要将导航栏的背景设置为透明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transparentNavigationBar</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        window.isNavigationBarContrastEnforced = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)</span><br><span class="line">    <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">    systemUiVisibility =</span><br><span class="line">        systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">    window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    window.navigationBarColor = Color.TRANSPARENT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置导航栏按钮或导航条颜色</span></span><br><span class="line">    setNavigationBarBtnColor(window, NightMode.isNightMode(window.context))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Android 10</code>以上，当设置了导航栏栏背景为透明时，<code>isNavigationBarContrastEnforced</code>如果为<code>true</code>，则系统会自动绘制一个半透明背景来提供对比度，所以我们要将这个属性设为<code>false</code></p>
<p>ps：状态栏其实也有对应的属性<code>isStatusBarContrastEnforced</code>，只不过这个属性默认即为<code>false</code>，我们不需要特意去设置</p>
<h2 id="导航栏按钮或导航条颜色"><a href="#导航栏按钮或导航条颜色" class="headerlink" title="导航栏按钮或导航条颜色"></a>导航栏按钮或导航条颜色</h2><p>和设置状态栏文字颜色一样，我这里就不多介绍了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setNavigationBarBtnColor</span><span class="params">(window: <span class="type">Window</span>, light: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">        systemUiVisibility = <span class="keyword">if</span> (light) &#123; <span class="comment">//白色按钮</span></span><br><span class="line">            systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR.inv()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑色按钮</span></span><br><span class="line">            systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR</span><br><span class="line">        &#125;</span><br><span class="line">        window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矫正显示区域-1"><a href="#矫正显示区域-1" class="headerlink" title="矫正显示区域"></a>矫正显示区域</h2><h3 id="fitsSystemWindows-1"><a href="#fitsSystemWindows-1" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>和状态栏使用一样，我就不重复说明了</p>
<h3 id="获取导航栏高度"><a href="#获取导航栏高度" class="headerlink" title="获取导航栏高度"></a>获取导航栏高度</h3><p>自从全面屏手势开始流行，导航栏也从原先的三键式，变成了三键式、导航条、全隐藏这三种情况，这三种情况下的高度也是互不相同的</p>
<p>三键式和导航条这两种情况我们都可以通过<code>android.R.dimen.navigation_bar_height</code>这个资源获取到准确高度，但现在很多系统都支持隐藏导航栏的功能，在这种情况下，虽然实际导航栏的高度应该是0，但是通过资源获取到的高度却为三键式或导航条的高度，这就给我们沉浸式导航栏的适配带来了很大困难</p>
<p>经过我的各种尝试，我发现只有一种方式可以准确的获取到当前导航栏的高度，那就是<code>WindowInsets</code>，至于<code>WindowInsets</code>是什么我就不多介绍了，我们直接看代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅当view attach window后生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealNavigationBarHeight</span><span class="params">(view: <span class="type">View</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> insets = ViewCompat.getRootWindowInsets(view)</span><br><span class="line">        ?.getInsets(WindowInsetsCompat.Type.navigationBars())</span><br><span class="line">    <span class="comment">//WindowInsets为null则默认通过资源获取高度</span></span><br><span class="line">    <span class="keyword">return</span> insets?.bottom ?: getNavigationBarHeight(view.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意到我在方法上写的注释，只有当<code>View</code>和<code>Window</code> attach 后，才能获得到<code>WindowInsets</code>，否则为<code>null</code>，所以我一开始的想法是先检查<code>View</code>是否 attach 了<code>Window</code>，如果有的话则直接调用<code>getRealNavigationBarHeight</code>方法，如果没有的话，调用<code>View.addOnAttachStateChangeListener</code>方法，当出发<code>attach</code>回调后，再调用<code>getRealNavigationBarHeight</code>方法获取高度</p>
<p>这种方式在大部分情况下运行良好，但在我一次无意中切换了系统夜间模式后发现，获取到的导航栏高度变成了0，并且这还是一个偶现的问题，于是我尝试使用<code>View.setOnApplyWindowInsetsListener</code>，监听<code>WindowInsets</code>的变化发现，这个回调有可能会触发多次，在触发多次的情况下，前几次的值都为0，只有最后一次的值为真正的导航栏高度</p>
<p>于是我准备用<code>View.setOnApplyWindowInsetsListener</code>代替<code>View.addOnAttachStateChangeListener</code>，但毕竟一个是setListener，一个是addListener，setListener有可能会把之前设置好的Listener覆盖，或者被别的Listener覆盖掉，再考虑到之后会提到的底部<code>Dialog</code>沉浸式导航栏适配的问题，我折中了一下，决定只对<code>Activity</code>下的<code>rootView</code>设置回调</p>
<p>以下是完整代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigationViewInfo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> hostRef: WeakReference&lt;View&gt;,</span><br><span class="line">    <span class="keyword">val</span> viewRef: WeakReference&lt;View&gt;,</span><br><span class="line">    <span class="keyword">val</span> rawBottom: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> onNavHeightChangeListener: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> navigationViewInfoList = mutableListOf&lt;NavigationViewInfo&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> onApplyWindowInsetsListener = View.OnApplyWindowInsetsListener &#123; v, insets -&gt;</span><br><span class="line">    <span class="keyword">val</span> windowInsetsCompat = WindowInsetsCompat.toWindowInsetsCompat(insets, v)</span><br><span class="line">    <span class="keyword">val</span> navHeight =</span><br><span class="line">        windowInsetsCompat.getInsets(WindowInsetsCompat.Type.navigationBars()).bottom</span><br><span class="line">    <span class="keyword">val</span> it = navigationViewInfoList.iterator()</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> info = it.next()</span><br><span class="line">        <span class="keyword">val</span> host = info.hostRef.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">val</span> view = info.viewRef.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || view == <span class="literal">null</span>) &#123;</span><br><span class="line">            it.remove()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == v) &#123;</span><br><span class="line">            info.onNavHeightChangeListener(view, info.rawBottom, navHeight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> actionMarginNavigation: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> =</span><br><span class="line">    &#123; view, rawBottomMargin, navHeight -&gt;</span><br><span class="line">        (view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123;</span><br><span class="line">            it.bottomMargin = rawBottomMargin + navHeight</span><br><span class="line">            view.requestLayout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> actionPaddingNavigation: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> =</span><br><span class="line">    &#123; view, rawBottomPadding, navHeight -&gt;</span><br><span class="line">        view.setPadding(</span><br><span class="line">            view.paddingLeft,</span><br><span class="line">            view.paddingTop,</span><br><span class="line">            view.paddingRight,</span><br><span class="line">            rawBottomPadding + navHeight</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fixNavBarMargin</span><span class="params">(<span class="keyword">vararg</span> views: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    views.forEach &#123;</span><br><span class="line">        fixSingleNavBarMargin(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fixSingleNavBarMargin</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lp = view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> rawBottomMargin = lp.bottomMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> viewForCalculate = getViewForCalculate(view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewForCalculate.isAttachedToWindow) &#123;</span><br><span class="line">        <span class="keyword">val</span> realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate)</span><br><span class="line">        lp.bottomMargin = rawBottomMargin + realNavigationBarHeight</span><br><span class="line">        view.requestLayout()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听</span></span><br><span class="line">    <span class="keyword">val</span> hostRef = WeakReference(viewForCalculate)</span><br><span class="line">    <span class="keyword">val</span> viewRef = WeakReference(view)</span><br><span class="line">    <span class="keyword">val</span> info = NavigationViewInfo(hostRef, viewRef, rawBottomMargin, actionMarginNavigation)</span><br><span class="line">    navigationViewInfoList.add(info)</span><br><span class="line">    viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">paddingByNavBar</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rawBottomPadding = view.paddingBottom</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> viewForCalculate = getViewForCalculate(view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewForCalculate.isAttachedToWindow) &#123;</span><br><span class="line">        <span class="keyword">val</span> realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate)</span><br><span class="line">        view.setPadding(</span><br><span class="line">            view.paddingLeft,</span><br><span class="line">            view.paddingTop,</span><br><span class="line">            view.paddingRight,</span><br><span class="line">            rawBottomPadding + realNavigationBarHeight</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听</span></span><br><span class="line">    <span class="keyword">val</span> hostRef = WeakReference(viewForCalculate)</span><br><span class="line">    <span class="keyword">val</span> viewRef = WeakReference(view)</span><br><span class="line">    <span class="keyword">val</span> info =</span><br><span class="line">        NavigationViewInfo(hostRef, viewRef, rawBottomPadding, actionPaddingNavigation)</span><br><span class="line">    navigationViewInfoList.add(info)</span><br><span class="line">    viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Dialog下的View在低版本机型中获取到的WindowInsets值有误，</span></span><br><span class="line"><span class="comment">* 所以尝试去获得Activity的contentView，通过Activity的contentView获取WindowInsets</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"ContextCast"</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewForCalculate</span><span class="params">(view: <span class="type">View</span>)</span></span>: View &#123;</span><br><span class="line">    <span class="keyword">return</span> (view.context <span class="keyword">as</span>? ContextWrapper)?.let &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@let</span> (it.baseContext <span class="keyword">as</span>? Activity)?.findViewById&lt;View&gt;(android.R.id.content)?.rootView</span><br><span class="line">    &#125; ?: view.rootView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅当view attach window后生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealNavigationBarHeight</span><span class="params">(view: <span class="type">View</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> insets = ViewCompat.getRootWindowInsets(view)</span><br><span class="line">        ?.getInsets(WindowInsetsCompat.Type.navigationBars())</span><br><span class="line">    <span class="keyword">return</span> insets?.bottom ?: getNavigationBarHeight(view.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我简单解释一下这段代码：为所有需要沉浸的页面的根<code>View</code>设置同一个回调，并将待适配导航栏高度的<code>View</code>添加到列表中，当<code>WindowInsets</code>回调触发后，遍历这个列表，判断触发回调的<code>View</code>的<code>host</code>是否与待适配导航栏高度的<code>View</code>对应，对应的话则处理<code>View</code>适配导航栏高度</p>
<p>这里需要注意，<code>WindowInsets</code>的分发其实是在<code>dispatchAttachedToWindow</code>之后的，所以<code>isAttachedToWindow</code>方法并不能保证此时的<code>WindowInsets</code>是正确的，具体可以去看<code>ViewRootImpl</code>中的源码，关键方法：<code>dispatchApplyInsets</code>，这里判断<code>isAttachedToWindow</code>并设置高度是为了防止出现<code>View</code>已经完全布局完成，之后再也不会触发<code>OnApplyWindowInsets</code>的情况</p>
<p>这里我也测试了内存泄漏情况，确认无内存泄漏，大家可以放心食用</p>
<h1 id="底部Dialog适配沉浸式"><a href="#底部Dialog适配沉浸式" class="headerlink" title="底部Dialog适配沉浸式"></a>底部Dialog适配沉浸式</h1><p>底部<code>Dialog</code>适配沉浸式要比正常的<code>Activity</code>更麻烦一些，主要问题也是集中在沉浸式导航栏上</p>
<h2 id="获取导航栏高度-1"><a href="#获取导航栏高度-1" class="headerlink" title="获取导航栏高度"></a>获取导航栏高度</h2><p>仔细的小伙伴们可以已经注意到了我在沉浸式导航栏获取高度那里代码中的注释，<code>Dialog</code>下的<code>View</code>在低版本机型（经测试，<code>Android 9</code>一下就会有这个问题）中获取到的<code>WindowInsets</code>值有误，所以尝试去获得<code>Activity</code>的<code>contentView</code>，通过<code>Activity</code>的<code>contentView</code>获取<code>WindowInsets</code></p>
<h2 id="LayoutParams导致的异常"><a href="#LayoutParams导致的异常" class="headerlink" title="LayoutParams导致的异常"></a>LayoutParams导致的异常</h2><p>在某些系统上（比如MIUI），当我<code>window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)</code>时，沉浸式会出现问题，状态栏会被蒙层盖住，<code>Dialog</code>底部的内容也会被一个莫名其妙的东西遮挡住</p>
<p>我的解决方案是，<code>window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)</code>，然后布局最外层全部占满，内部留一个底部容器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_pangu_bottom_wrapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@android:color/transparent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pangu_bottom_dialog_container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:clickable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:focusable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在代码中重写<code>setContentView</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> canceledOnTouchOutside = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(layoutResID: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    setContentView(</span><br><span class="line">        LayoutInflater.from(context).inflate(layoutResID, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    setContentView(</span><br><span class="line">        view,</span><br><span class="line">        ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(view: <span class="type">View</span>, params: <span class="type">ViewGroup</span>.<span class="type">LayoutParams</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> root =</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.dialog_pangu_bottom_wrapper, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">    root.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceledOnTouchOutside) &#123;</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> container = root.findViewById&lt;ViewGroup&gt;(R.id.pangu_bottom_dialog_container)</span><br><span class="line">    container.addView(view, params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.setContentView(</span><br><span class="line">        root,</span><br><span class="line">        ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setCanceledOnTouchOutside</span><span class="params">(cancel: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.setCanceledOnTouchOutside(cancel)</span><br><span class="line">    canceledOnTouchOutside = cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话视觉效果就和普通的底部<code>Dialog</code>一样了，为了进一步减小底部<code>Dialog</code>显示隐藏动画之间的差异，我将动画插值器从<code>linear_interpolator</code>换成了<code>decelerate_interpolator</code>和<code>accelerate_interpolator</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_enter_from_bottom_to_top --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYDelta</span>=<span class="string">"100%"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/decelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYDelta</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_exit_from_top_to_bottom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYDelta</span>=<span class="string">"100%"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>自此，目前沉浸式遇到的问题全部都解决了，如果以后发现了什么新的问题，我会在这篇文章中补充说明，如果还有什么不明白的地方可以评论，我考虑要不要拿几个具体的场景实战讲解，各位看官老爷麻烦点个赞收个藏不迷路😄</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/19/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - Activity启动流程（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中，我们分析了<code>App</code>进程的启动过程，包括<code>Application</code>是怎么创建并执行<code>onCreate</code>方法的，本篇文章我们将会继续分析<code>App</code>进程启动、<code>Application</code>创建完成后，<code>Activity</code>是如何启动的</p>
<h1 id="两种路径启动Activity"><a href="#两种路径启动Activity" class="headerlink" title="两种路径启动Activity"></a>两种路径启动Activity</h1><p>我们在 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 的末尾分析过，<code>Activity</code>的启动存在两条路径</p>
<h2 id="启动进程，然后启动Activity"><a href="#启动进程，然后启动Activity" class="headerlink" title="启动进程，然后启动Activity"></a>启动进程，然后启动Activity</h2><p>这条路径就是我们在上一篇文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中分析了前半部分：启动进程</p>
<p>当进程启动后，会执行到<code>AMS.attachApplicationLocked</code>方法，在这个方法的最后，会有一段代码检查是否有<code>Activity</code>等待启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Activity等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>ActivityTaskManagerInternal.attachApplication</code>，<code>ActivityTaskManagerInternal</code>是一个抽象类，被<code>ATMS</code>的内部类<code>LocalService</code>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>RootWindowContainer.attachApplication</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        mTmpRemoteException = <span class="keyword">null</span>;</span><br><span class="line">        mTmpBoolean = <span class="keyword">false</span>; <span class="comment">// Set to true if an activity was started.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> areaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; areaNdx &gt;= <span class="number">0</span>; --areaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx);</span><br><span class="line">                <span class="keyword">if</span> (rootTask.getVisibility(<span class="keyword">null</span> <span class="comment">/*starting*/</span>) == STACK_VISIBILITY_INVISIBLE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历ActivityStack下的所有ActivityRecord，</span></span><br><span class="line">                <span class="comment">//以其为参数调用startActivityForAttachedApplicationIfNeeded方法</span></span><br><span class="line">                <span class="keyword">final</span> PooledFunction c = PooledLambda.obtainFunction(</span><br><span class="line">                        RootWindowContainer::startActivityForAttachedApplicationIfNeeded, <span class="keyword">this</span>,</span><br><span class="line">                        PooledLambda.__(ActivityRecord<span class="class">.<span class="keyword">class</span>), <span class="title">app</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">rootTask</span>.<span class="title">topRunningActivity</span>())</span>;</span><br><span class="line">                rootTask.forAllActivities(c);</span><br><span class="line">                c.recycle();</span><br><span class="line">                <span class="keyword">if</span> (mTmpRemoteException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> mTmpRemoteException;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        didSomething |= mTmpBoolean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">false</span> <span class="comment">/* preserve_windows */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两层<code>for</code>循环，可以看出来，这个方法遍历了所有可见的<code>ActivityStack</code>，然后再对每个可见的<code>ActivityStack</code>进行操作</p>
<p>其中，<code>PooledLambda</code>这个类采用了池化技术，用于构造可回收复用的匿名函数，这里<code>PooledLambda.obtainFunction</code>方法得到的结果是一个<code>Function&lt;ActivityRecord, Boolean&gt;</code>，<code>forAllActivities</code>方法被定义在父类<code>WindowContainer</code>中，就是遍历执行所有<code>child</code>的<code>forAllActivities</code>方法，而<code>ActivityRecord</code>中重写了这个方法，直接用自身执行这个<code>Function</code></p>
<p>简单来说，可以将这部分代码看作以下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootTask.forEachAllActivityRecord((activityRecord) -&gt; &#123;</span><br><span class="line">    startActivityForAttachedApplicationIfNeeded(activityRecord, app, rootTask.topRunningActivity())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接着我们来观察<code>startActivityForAttachedApplicationIfNeeded</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startActivityForAttachedApplicationIfNeeded</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowProcessController app, ActivityRecord top)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Activity是否正在finish，是否应为当前用户显示Activity，忽略锁屏情况，此Activity是否可见</span></span><br><span class="line">    <span class="comment">//对比Activity与发起进程的uid和进程名</span></span><br><span class="line">    <span class="keyword">if</span> (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != <span class="keyword">null</span></span><br><span class="line">            || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动Activity</span></span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(r, app,</span><br><span class="line">                top == r &amp;&amp; r.isFocusable() <span class="comment">/*andResume*/</span>, <span class="keyword">true</span> <span class="comment">/*checkConfig*/</span>)) &#123;</span><br><span class="line">            mTmpBoolean = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一系列的判断检查传入的<code>ActivityRecord</code>所对应的<code>Activity</code>是否需要启动，然后调用<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h2 id="已有进程，直接启动Activity"><a href="#已有进程，直接启动Activity" class="headerlink" title="已有进程，直接启动Activity"></a>已有进程，直接启动Activity</h2><p>这条路径我在 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中的末尾也分析过，如果<code>App</code>进程已经启动，则会调用<code>ActivityStackSupervisor.startSpecificActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivity</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    <span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动Activity</span></span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">        knownToBeDead = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁屏状态下启动Activity防闪烁机制</span></span><br><span class="line">    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出现异常，重启进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="string">"top-activity"</span> : <span class="string">"activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里也调用了<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h1 id="realStartActivityLocked"><a href="#realStartActivityLocked" class="headerlink" title="realStartActivityLocked"></a>realStartActivityLocked</h1><p>最终两条路径都走到了<code>ActivityStackSupervisor.realStartActivityLocked</code>方法中，那我们就来看看这个方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保所有Activity都已暂停</span></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// While there are activities pausing we skipping starting any new activities until</span></span><br><span class="line">        <span class="comment">// pauses are complete. <span class="doctag">NOTE:</span> that we also do this for activities that are starting in</span></span><br><span class="line">        <span class="comment">// the paused state because they will first be resumed then paused on the client side.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Task task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟resume以避免重复resume</span></span><br><span class="line">    <span class="comment">//通过设置标记位mDeferResumeCount，只有当其为0时才能执行resume</span></span><br><span class="line">    beginDeferResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//冻结屏幕（不接收输入、不执行动画，截取屏幕进行显示）</span></span><br><span class="line">        r.startFreezingScreenLocked(proc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        <span class="comment">//收集启动缓慢信息</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        r.setProcess(proc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure activity is allowed to be resumed after process has set.</span></span><br><span class="line">        <span class="comment">//确保Activity允许被resume</span></span><br><span class="line">        <span class="keyword">if</span> (andResume &amp;&amp; !r.canResumeByCompat()) &#123;</span><br><span class="line">            andResume = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁屏状态下启动Activity防闪烁机制</span></span><br><span class="line">        r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of the screen based on the new</span></span><br><span class="line">        <span class="comment">// activity order.  Note that as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that, because the activity is</span></span><br><span class="line">        <span class="comment">// not currently running so we are just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            <span class="comment">// Deferring resume here because we're going to launch new activity shortly.</span></span><br><span class="line">            <span class="comment">// We don't want to perform a redundant launch of the same record while ensuring</span></span><br><span class="line">            <span class="comment">// configurations and trying to resume top activity of focused stack.</span></span><br><span class="line">            <span class="comment">//确保所有Activity的可见性、更新屏幕方向和配置</span></span><br><span class="line">            mRootWindowContainer.ensureVisibilityAndConfig(r, r.getDisplayId(),</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查Activity是否在后台锁屏状态下启动</span></span><br><span class="line">        <span class="keyword">if</span> (r.getRootTask().checkKeyguardVisibility(r, <span class="keyword">true</span> <span class="comment">/* shouldBeVisible */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* isTop */</span>) &amp;&amp; r.allowMoveToFront()) &#123;</span><br><span class="line">            <span class="comment">// We only set the visibility to true if the activity is not being launched in</span></span><br><span class="line">            <span class="comment">// background, and is allowed to be visible based on keyguard state. This avoids</span></span><br><span class="line">            <span class="comment">// setting this into motion in window manager that is later cancelled due to later</span></span><br><span class="line">            <span class="comment">// calls to ensure visible activities that set visibility back to false.</span></span><br><span class="line">            <span class="comment">//只有Activity不是在后台启动，才将其可见性设置为true</span></span><br><span class="line">            r.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//异常情况检查</span></span><br><span class="line"></span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line">        proc.setLastActivityLaunchTime(r.lastLaunchTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//屏幕固定功能</span></span><br><span class="line">        <span class="keyword">final</span> LockTaskController lockTaskController = mService.getLockTaskController();</span><br><span class="line">        <span class="keyword">if</span> (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE</span><br><span class="line">                || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV</span><br><span class="line">                || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED</span><br><span class="line">                        &amp;&amp; lockTaskController.getLockTaskModeState()</span><br><span class="line">                                == LOCK_TASK_MODE_LOCKED)) &#123;</span><br><span class="line">            lockTaskController.startLockTaskMode(task, <span class="keyword">false</span>, <span class="number">0</span> <span class="comment">/* blank UID */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!proc.hasThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;ReferrerIntent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                <span class="comment">// We don't need to deliver new intents and/or set results if activity is going</span></span><br><span class="line">                <span class="comment">// to pause immediately after launch.</span></span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是ACTIVITY_TYPE_HOME类型的应用（Launcher）</span></span><br><span class="line">            <span class="keyword">if</span> (r.isActivityTypeHome()) &#123;</span><br><span class="line">                <span class="comment">// Home process is the root process of the task.</span></span><br><span class="line">                updateHomeProcess(task.getBottomMostActivity().app);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//信息记录</span></span><br><span class="line">            mService.getPackageManagerInternalLocked().notifyPackageUse(</span><br><span class="line">                    r.intent.getComponent().getPackageName(), NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            r.setSleeping(<span class="keyword">false</span>);</span><br><span class="line">            r.forceNewConfig = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果有必要的话，显示一些App警告弹窗（不支持的CompileSdk、不支持的TargetSdk、不支持的显示大小）</span></span><br><span class="line">            mService.getAppWarningsLocked().onStartActivity(r);</span><br><span class="line">            <span class="comment">//兼容性信息</span></span><br><span class="line">            r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Because we could be starting an Activity in the system process this may not go</span></span><br><span class="line">            <span class="comment">// across a Binder interface which would create a new Configuration. Consequently</span></span><br><span class="line">            <span class="comment">// we have to always create a new Configuration here.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">                    proc.getConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">            r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">            <span class="comment">//创建或获取一个client事务</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                    proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">            <span class="comment">//添加一条Activity启动消息</span></span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                    r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                    r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set desired final state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置client执行事务后应处于的生命周期状态</span></span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule transaction.</span></span><br><span class="line">            <span class="comment">//调度执行此事务，启动Activity</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理重量级进程</span></span><br><span class="line">            <span class="keyword">if</span> ((proc.mInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">                <span class="comment">// This may be a heavy-weight process! Note that the package manager will ensure</span></span><br><span class="line">                <span class="comment">// that only activity can run in the main process of the .apk, which is the only</span></span><br><span class="line">                <span class="comment">// thing that will be considered heavy-weight.</span></span><br><span class="line">                <span class="keyword">if</span> (proc.mName.equals(proc.mInfo.packageName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mService.mHeavyWeightProcess != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; mService.mHeavyWeightProcess != proc) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Starting new heavy weight process "</span> + proc</span><br><span class="line">                                + <span class="string">" when already running "</span></span><br><span class="line">                                + mService.mHeavyWeightProcess);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mService.setHeavyWeightProcess(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.launchFailed) &#123;</span><br><span class="line">                <span class="comment">// This is the second time we failed -- finish activity and give up.</span></span><br><span class="line">                <span class="comment">//第二次启动失败，finish掉Activity并放弃重试，直接返回false</span></span><br><span class="line">                Slog.e(TAG, <span class="string">"Second failure launching "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString() + <span class="string">", giving up"</span>, e);</span><br><span class="line">                proc.appDied(<span class="string">"2nd-crash"</span>);</span><br><span class="line">                r.finishIfPossible(<span class="string">"2nd-crash"</span>, <span class="keyword">false</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the first time we failed -- restart process and</span></span><br><span class="line">            <span class="comment">// retry.</span></span><br><span class="line">            <span class="comment">//第一次启动失败，尝试重启进程并重试启动Activity</span></span><br><span class="line">            r.launchFailed = <span class="keyword">true</span>;</span><br><span class="line">            proc.removeActivity(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.launchFailed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(lifecycler): Resume or pause requests are done as part of launch transaction,</span></span><br><span class="line">    <span class="comment">// so updating the state should be done accordingly.</span></span><br><span class="line">    <span class="comment">//更新生命周期状态</span></span><br><span class="line">    <span class="keyword">if</span> (andResume &amp;&amp; readyToResume()) &#123;</span><br><span class="line">        <span class="comment">// As part of the process of launching, ActivityThread also performs</span></span><br><span class="line">        <span class="comment">// a resume.</span></span><br><span class="line">        stack.minimalResumeActivityLocked(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity is not starting in the resumed state... which should look like we asked</span></span><br><span class="line">        <span class="comment">// it to pause+stop (but remain visible), and it has done so and reported back the</span></span><br><span class="line">        <span class="comment">// current icicle and other state.</span></span><br><span class="line">        r.setState(PAUSED, <span class="string">"realStartActivityLocked"</span>);</span><br><span class="line">        mRootWindowContainer.executeAppTransitionForAllDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Perform OOM scoring after the activity state is set, so the process can be updated with</span></span><br><span class="line">    <span class="comment">// the latest state.</span></span><br><span class="line">    <span class="comment">//更新进程oom adj，更新进程状态</span></span><br><span class="line">    proc.onStartActivity(mService.mTopProcessState, r.info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></span><br><span class="line">    <span class="comment">// launching the initial activity (that is, home), so that it can have</span></span><br><span class="line">    <span class="comment">// a chance to initialize itself while in the background, making the</span></span><br><span class="line">    <span class="comment">// switch back to it faster and look better.</span></span><br><span class="line">    <span class="keyword">if</span> (mRootWindowContainer.isTopDisplayFocusedStack(stack)) &#123;</span><br><span class="line">        mService.getActivityStartController().startSetupActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">    <span class="comment">// their client may have activities.</span></span><br><span class="line">    <span class="comment">//更新进程绑定的所有服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.app.updateServiceConnectionActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中最关键的部分在于创建了<code>ClientTransaction</code>事务，并向里添加了一条启动<code>Activity</code>的消息，然后调用<code>ATMS.getLifecycleManager.scheduleTransaction</code>调度执行这个事务，启动<code>Activity</code></p>
<h1 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a>ClientTransaction</h1><p>我们先来看看<code>ClientTransaction</code>这个对象是怎么创建获取的，我们首先调用了<code>ClientTransaction.obtain</code>方法，并传入了一个<code>ActivityThread</code>内部类<code>ApplicationThread</code>的<code>Binder</code>对象<code>IApplicationThread</code>和一个<code>ActivityRecord.Token</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientTransaction <span class="title">obtain</span><span class="params">(IApplicationThread client, IBinder activityToken)</span> </span>&#123;</span><br><span class="line">    ClientTransaction instance = ObjectPool.obtain(ClientTransaction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> ClientTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    instance.mClient = client;</span><br><span class="line">    instance.mActivityToken = activityToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，从池子里拿一个实例，或者新创建一个实例对象，将这个实例对象的两个成员变量赋值后返回</p>
<p>然后我们调用了<code>ClientTransaction.addCallback</code>方法将<code>ClientTransactionItem</code>加入到回调队列中，<code>ClientTransactionItem</code>是一条能够被执行的生命周期回调消息，它是一个抽象类，子类需要实现它的<code>preExecute</code>、<code>execute</code>、<code>postExecute</code>方法</p>
<p>我们这里传入的是<code>LaunchActivityItem</code>，这条消息是用来启动<code>Activity</code>的</p>
<p>然后我们调用<code>ClientTransaction.setLifecycleStateRequest</code>设置当事务执行结束后，<code>Activity</code>应该处在一个怎样的生命周期</p>
<p>最后调用<code>ATMS.getLifecycleManager.scheduleTransaction</code>调度执行这个事务，<code>ATMS.getLifecycleManager</code>获得的是一个<code>ClientLifecycleManager</code>对象，我们沿着这个方法继续往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了回收调用<code>recycle</code>之外，我们又回到了<code>ClientTransaction</code>中，调用其<code>schedule</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又跨进程回到了<code>App</code>进程中，调用<code>ApplicationThread.scheduleTransaction</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用<code>ActivityThread.scheduleTransaction</code>执行事务，<code>ActivityThread</code>继承自<code>ClientTransactionHandler</code>，<code>scheduleTransaction</code>方法是在这里面定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用<code>ClientTransaction.preExecute</code>方法，然后通过<code>Handler</code>发送执行一条<code>EXECUTE_TRANSACTION</code>消息，我们先看一下<code>preExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(android.app.ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mActivityCallbacks.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            mActivityCallbacks.get(i).preExecute(clientTransactionHandler, mActivityToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLifecycleStateRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLifecycleStateRequest.preExecute(clientTransactionHandler, mActivityToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，就是遍历整个<code>callback</code>列表，执行<code>preExecute</code>方法，最后再执行<code>LifecycleStateRequest</code>的<code>preExecute</code>方法，对应到<code>Activity</code>启动流程中，就是先执行<code>LaunchActivityItem.preExecute</code>，再执行<code>ResumeActivityItem.preExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchActivityItem</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(ClientTransactionHandler client, IBinder token)</span> </span>&#123;</span><br><span class="line">    client.countLaunchingActivities(<span class="number">1</span>);</span><br><span class="line">    client.updateProcessState(mProcState, <span class="keyword">false</span>);</span><br><span class="line">    client.updatePendingConfiguration(mCurConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResumeActivityItem</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(ClientTransactionHandler client, IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里mUpdateProcState为false，不执行</span></span><br><span class="line">    <span class="keyword">if</span> (mUpdateProcState) &#123;</span><br><span class="line">        client.updateProcessState(mProcState, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是一些状态更新之类的东西，我们就直接跳过，然后我们看<code>ActivityThread</code>在收到<code>EXECUTE_TRANSACTION</code>消息后做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，调用了<code>TransactionExecutor</code>对象的<code>execute</code>方法，<code>TransactionExecutor</code>对象在<code>ActivityThread</code>创建时便创建了，内部持有一个<code>ClientTransactionHandler</code>引用，即<code>ActivityThread</code>自身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="comment">//处理需要销毁的Activities</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed =</span><br><span class="line">                mTransactionHandler.getActivitiesToBeDestroyed();</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token);</span><br><span class="line">        <span class="keyword">if</span> (destroyItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.getLifecycleStateRequest() == destroyItem) &#123;</span><br><span class="line">                <span class="comment">// It is going to execute the transaction that will destroy activity with the</span></span><br><span class="line">                <span class="comment">// token, so the corresponding to-be-destroyed record can be removed.</span></span><br><span class="line">                activitiesToBeDestroyed.remove(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mTransactionHandler.getActivityClient(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The activity has not been created but has been requested to destroy, so all</span></span><br><span class="line">                <span class="comment">// transactions for the token are just like being cancelled.</span></span><br><span class="line">                <span class="comment">//Activity尚未被创建就被请求destroy，直接取消整个事务</span></span><br><span class="line">                Slog.w(TAG, tId(transaction) + <span class="string">"Skip pre-destroyed transaction:\n"</span></span><br><span class="line">                        + transactionToString(transaction, mTransactionHandler));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理需要销毁的<code>Activities</code>这里我们不关注，就直接跳过，然后就是分别执行各个<code>ClientTransactionItem</code>回调消息，最后让其调度执行我们设置的最终的生命周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No callbacks to execute, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//生命周期转换相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">        ... <span class="comment">//生命周期转换，在Activity启动时不会走进这个case</span></span><br><span class="line"></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Launch activity request will create an activity record.</span></span><br><span class="line">            <span class="comment">//在执行完启动Activity后会新建一个ActivityClientRecord，重新赋值</span></span><br><span class="line">            r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//生命周期转换，在Activity启动时不会走进这个case</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于生命周期转换，由于<code>Activity</code>启动的当前阶段不会进入这些case，所以这里就不提了</p>
<p>经过简化，实际上也就执行了<code>LaunchActivityItem.execute</code>和<code>LaunchActivityItem.postExecute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用之前在<code>AMS</code>中创建<code>LaunchActivityItem</code>所使用到的信息，创建了一个<code>ActivityClientRecord</code>对象，接着回到<code>ActivityThread</code>，调用其<code>handleLaunchActivity</code>方法</p>
<h1 id="handleLaunchActivity"><a href="#handleLaunchActivity" class="headerlink" title="handleLaunchActivity"></a>handleLaunchActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    <span class="comment">//确保Configuration为最新</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    <span class="comment">//初始化硬件加速</span></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">            &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">        HardwareRenderer.preload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保WMS被初始化</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint the GraphicsEnvironment that an activity is launching on the process.</span></span><br><span class="line">    <span class="comment">//通知有Activity启动</span></span><br><span class="line">    GraphicsEnvironment.hintActivityLaunch();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行启动Activity</span></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置Configuration</span></span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="comment">//设置一些延迟执行的动作（作用域到整个ClientTransaction结束）</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            <span class="comment">//当Activity生命周期走到onStart前，会通过这里设置的值</span></span><br><span class="line">            <span class="comment">//判断是否需要执行onRestoreInstanceState、onPostCreate</span></span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="comment">//出现错误，停止启动Activity</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，最重要的莫过于<code>performLaunchActivity</code>了，它是创建<code>Activity</code>的核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="comment">//设置LoadedApk</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果启动的Activity是一个activity-alias，将Component设置为真正的Activity组件</span></span><br><span class="line">    <span class="comment">//详见：https://developer.android.com/guide/topics/manifest/activity-alias-element?hl=zh-cn</span></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为Activity创建BaseContext</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//实例化Activity</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建或获取Application</span></span><br><span class="line">        <span class="comment">//如果该Activity指定在其他的一个新的进程中启动（设置了android:process属性），则会新创建Application</span></span><br><span class="line">        <span class="comment">//正常不涉及多进程，都是直接获取之前创建好的Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Manifest中Activity标签下的label属性</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            <span class="comment">//准备Configuration</span></span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//当relaunch Activity的时候mPreserveWindow才会为true（比如说调用Activity.recreate方法）</span></span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Activity resources must be initialized with the same loaders as the</span></span><br><span class="line">            <span class="comment">// application context.</span></span><br><span class="line">            <span class="comment">//设置Activity Resource的Loaders与Application Resource的Loaders一致</span></span><br><span class="line">            appContext.getResources().addLoaders(</span><br><span class="line">                    app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">//重要：绑定BaseContext、创建PhoneWindow等一系列初始化工作</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//更新网络状态</span></span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//设置主题</span></span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//调用Activity的onCreate方法</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="comment">//在执行完super.onCreate方法后，mCalled会被置为true</span></span><br><span class="line">                <span class="comment">//如果mCalled为false，说明没有执行super.onCreate方法</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            mLastReportedWindowingMode.put(activity.getActivityToken(),</span><br><span class="line">                    config.windowConfiguration.getWindowingMode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置生命周期状态为onCreate</span></span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">        <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">        <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">        <span class="comment">//将新建的ActivityClientRecord添加到mActivities中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几个工作：</p>
<ol>
<li><p>准备创建<code>Activity</code>所必要的信息，譬如类名等</p>
</li>
<li><p>为<code>Activity</code>创建<code>BaseContext</code></p>
</li>
<li><p>通过<code>Instrumentation</code>实例化<code>Activity</code></p>
</li>
<li><p>创建或获取<code>Activity</code>进程所对应的<code>Application</code></p>
</li>
<li><p>初始化<code>Activity</code>，执行各种绑定工作，创建<code>PhoneWindow</code>等</p>
</li>
<li><p>执行<code>Activity</code>的<code>onCreate</code>生命周期方法</p>
</li>
<li><p>将<code>ActivityClientRecord</code>生命周期状态设置为<code>onCreate</code></p>
</li>
</ol>
<p>我们重点看一下最主要的实例化、<code>attach</code>和<code>onCreate</code>这三点</p>
<h2 id="Instrumentation-newActivity"><a href="#Instrumentation-newActivity" class="headerlink" title="Instrumentation.newActivity"></a>Instrumentation.newActivity</h2><p>我们在 <a href="https://juejin.cn/post/7172464885492613128/#heading-14" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中分析了，<code>Application</code>是怎么通过<code>Instrumentation</code>创建的，<code>Activity</code>的创建和它类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    String pkg = intent != <span class="keyword">null</span> &amp;&amp; intent.getComponent() != <span class="keyword">null</span></span><br><span class="line">            ? intent.getComponent().getPackageName() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的使用了<code>AppComponentFactory</code>创建，我们还是去看一下它的默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Activity <span class="title">instantiateActivity</span><span class="params">(@NonNull ClassLoader cl, @NonNull String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也是通过类名反射创建一个<code>Activity</code>的实例</p>
<h2 id="Activity-attach"><a href="#Activity-attach" class="headerlink" title="Activity.attach"></a>Activity.attach</h2><p>紧接着，我们来看<code>Activity.attach</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定BaseContext</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    <span class="comment">//初始化Fragment控制器</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并设置Window用于显示界面</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各成员变量初始化</span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mAssistToken = assistToken;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="keyword">if</span> (voiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mVoiceInteractor = <span class="keyword">new</span> VoiceInteractor(voiceInteractor, <span class="keyword">this</span>, <span class="keyword">this</span>,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置WindowManager、ActivityRecordToken以及是否使用硬件加速</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">    mWindow.setPreferMinimalPostProcessing(</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置自动填充选项</span></span><br><span class="line">    setAutofillOptions(application.getAutofillOptions());</span><br><span class="line">    <span class="comment">//设置内容捕获功能</span></span><br><span class="line">    setContentCaptureOptions(application.getContentCaptureOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>attach</code>方法主要做了以下几件事：</p>
<ol>
<li><p>绑定<code>BaseContext</code></p>
</li>
<li><p>初始化<code>Fragment</code>控制器</p>
</li>
<li><p>创建并设置<code>Window</code></p>
</li>
<li><p>各种成员变量及其他属性初始化</p>
</li>
</ol>
<p>看完这个方法，我们可以发现，原来<code>Activity</code>的<code>Window</code>是在这个时候创建的，并且<code>Window</code>的具体实现类为<code>PhoneWindow</code></p>
<p>再然后便是通过<code>Instrumentation</code>执行<code>Activity</code>的<code>onCreate</code>生命周期方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>prePerformCreate</code>和<code>postPerformCreate</code>似乎只有在单元测试和CTS测试下才会产生实质性的影响，在正常情况下我们就当作它们不存在，我们接着看<code>performCreate</code>方法</p>
<h2 id="Activity-performCreate"><a href="#Activity-performCreate" class="headerlink" title="Activity.performCreate"></a>Activity.performCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreCreated回调</span></span><br><span class="line">    dispatchActivityPreCreated(icicle);</span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// initialize mIsInMultiWindowMode and mIsInPictureInPictureMode before onCreate</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> windowingMode = getResources().getConfiguration().windowConfiguration</span><br><span class="line">            .getWindowingMode();</span><br><span class="line">    <span class="comment">//多窗口模式</span></span><br><span class="line">    mIsInMultiWindowMode = inMultiWindowMode(windowingMode);</span><br><span class="line">    <span class="comment">//画中画模式（小窗播放视频等场景）</span></span><br><span class="line">    mIsInPictureInPictureMode = windowingMode == WINDOWING_MODE_PINNED;</span><br><span class="line">    <span class="comment">//恢复请求权限中的标志位</span></span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="comment">//执行onCreate生命周期方法</span></span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//FragmentManager分发ACTIVITY_CREATED状态</span></span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">    <span class="comment">//分发PostCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostCreated回调</span></span><br><span class="line">    dispatchActivityPostCreated(icicle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的参数<code>icicle</code>就是我们平时重写<code>Activity.onCreate</code>方法时的第一个入参<code>savedInstanceState</code>，如果<code>Activity</code>发生了重建之类的情况，它会保存一些状态数据，第一次启动<code>Activity</code>时为<code>null</code></p>
<p>无论<code>persistentState</code>是否为<code>null</code>，最终都会进入到单个参数的<code>onCreate</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//恢复LoaderManager</span></span><br><span class="line">    <span class="keyword">if</span> (mLastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ActionBar</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityInfo.parentActivityName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mEnableDefaultActionBarUp = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mActionBar.setDefaultDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//自动填充功能</span></span><br><span class="line">        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">false</span>);</span><br><span class="line">        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,</span><br><span class="line">                View.LAST_APP_AUTOFILL_ID);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">            getAutofillManager().onCreate(savedInstanceState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复FragmentManager状态</span></span><br><span class="line">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">        mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">                ? mLastNonConfigurationInstances.fragments : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//FragmentManager分发CREATED状态，执行内部Fragment的生命周期</span></span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    <span class="comment">//分发Created事件，执行所有注册的ActivityLifecycleCallbacks的onActivityCreated回调</span></span><br><span class="line">    dispatchActivityCreated(savedInstanceState);</span><br><span class="line">    <span class="comment">//语音交互功能</span></span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.attachActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRestoredFromBundle = savedInstanceState != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里表示已调用过super.onCreate方法</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，<code>Activity</code>的<code>onCreate</code>生命周期就走完了，我们也可以从这整个流程中得到一些新的收获，比如说，原来注册在<code>Application</code>中的<code>ActivityLifecycleCallbacks</code>回调是在这里触发的，<code>FragmentManager</code>状态分发的顺序是这样的，为什么必须要调用<code>super.onCreate</code>方法等等</p>
<p>接着，我们再回到<code>TransactionExecutor</code>中，它接下来执行的是<code>LaunchActivityItem.postExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.countLaunchingActivities(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就非常简单了，计数器减一</p>
<p><code>postExecute</code>执行完后，整个<code>LaunchActivityItem</code>的工作就完成了，接下来执行的是<code>TransactionExecutor.executeLifecycleState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">    <span class="comment">//excludeLastState为true的情况下，推进生命周期直到最终生命周期的上一个生命周期</span></span><br><span class="line">    <span class="comment">//excludeLastState为false的情况下，推进生命周期直到最终生命周期</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">    <span class="comment">//执行最终的生命周期事务</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们目前处在的生命周期为<code>ON_CREATE</code>最终目标要到达的生命周期为<code>ON_RESUME</code>，<code>cycleToPath</code>方法会帮助我们把生命周期推进到<code>ON_RESUME</code>的上一个生命周期也就是<code>ON_START</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">    performLifecycleSequence(r, path, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TransactionExecutorHelper.getLifecyclePath</code>方法会帮我们计算出一个剩余要经过的生命周期路线的一个有序数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//错误判断</span></span><br><span class="line"></span><br><span class="line">    mLifecycleSequence.clear();</span><br><span class="line">    <span class="keyword">if</span> (finish &gt;= start) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == ON_START &amp;&amp; finish == ON_STOP) &#123;</span><br><span class="line">            <span class="comment">// A case when we from start to stop state soon, we don't need to go</span></span><br><span class="line">            <span class="comment">// through the resumed, paused state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_STOP);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just go there</span></span><br><span class="line">            <span class="comment">//按顺序添加生命周期</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// finish &lt; start, can't just cycle down</span></span><br><span class="line">        <span class="keyword">if</span> (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123;</span><br><span class="line">            <span class="comment">// Special case when we can just directly go to resumed state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESUME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123;</span><br><span class="line">            <span class="comment">// Restart and go to required state.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to stopped state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_STOP; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Restart</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESTART);</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_START; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Relaunch and go to required state</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to destroyed state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_DESTROY; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_CREATE; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class="line">    <span class="keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实从这个方法，我们就能看出<code>Activity</code>生命周期是怎么设计的，代码很简单，我就不解释了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRE_ON_CREATE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_CREATE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_START = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESUME = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_PAUSE = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_STOP = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_DESTROY = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESTART = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>我们结合这上面这个生命周期大小来看，<code>start</code>为<code>ON_CREATE</code>，<code>finish</code>为<code>ON_RESUME</code>，<code>excludeLastState</code>为<code>true</code>移除最后一个生命周期，得出的结果便是<code>[ON_START]</code>，然后调用<code>performLifecycleSequence</code>方法执行生命周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">        state = path.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                mTransactionHandler.handleStartActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* activityOptions */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                mTransactionHandler.handleResumeActivity(r, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        r.isForward, <span class="string">"LIFECYCLER_RESUME_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                mTransactionHandler.handlePauseActivity(r, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* autoEnteringPip */</span>, mPendingActions,</span><br><span class="line">                        <span class="string">"LIFECYCLER_PAUSE_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                mTransactionHandler.handleStopActivity(r, <span class="number">0</span> <span class="comment">/* configChanges */</span>,</span><br><span class="line">                        mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        <span class="string">"LIFECYCLER_STOP_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                mTransactionHandler.handleDestroyActivity(r, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                        <span class="string">"performLifecycleSequence. cycling to:"</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                mTransactionHandler.performRestartActivity(r, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected lifecycle state: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单啊，就是遍历这个数组，依次执行生命周期，结合我们传入的数组<code>[ON_START]</code>，最后便是调用<code>ActivityThread.handleStartActivity</code>方法</p>
<h1 id="handleStartActivity"><a href="#handleStartActivity" class="headerlink" title="handleStartActivity"></a>handleStartActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">final</span> Activity activity = r.activity;</span><br><span class="line">    ... <span class="comment">//检查</span></span><br><span class="line"></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start</span></span><br><span class="line">    <span class="comment">//执行onStart生命周期</span></span><br><span class="line">    activity.performStart(<span class="string">"handleStartActivity"</span>);</span><br><span class="line">    <span class="comment">//设置生命周期状态为onStart</span></span><br><span class="line">    r.setState(ON_START);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No more work to do.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore instance state</span></span><br><span class="line">    <span class="comment">//之前在handleLaunchActivity方法中设置了pendingActions.setRestoreInstanceState(true)</span></span><br><span class="line">    <span class="comment">//这里便会判断是否需要并执行Activity.onRestoreInstanceState</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call postOnCreate()</span></span><br><span class="line">    <span class="comment">//之前在handleLaunchActivity方法中设置了pendingActions.setCallOnPostCreate(true)</span></span><br><span class="line">    <span class="comment">//这里便会执行Activity.onPostCreate，如果不是从onCreate转到onStart，不会进入此case</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//调用Activity.onPostCreate</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">            <span class="comment">//和onCreate一样，onPostCreate也必须要调用super.onPostCreate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新可见性</span></span><br><span class="line">    <span class="comment">//Activity启动时，由于此时mDecor还未赋值，所以不会产生影响</span></span><br><span class="line">    updateVisibility(r, <span class="keyword">true</span> <span class="comment">/* show */</span>);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要注意，我们一般重写<code>Activity</code>的<code>onCreate</code>方法，在其中调用<code>setContentView</code>方法，此时<code>DecorView</code>虽然被创建出来了，但是只在<code>PhoneWindow</code>中持有，尚未给<code>Activity.mDecor</code>赋值，所以此时调用<code>updateVisibility</code>方法并不会将<code>DecorView</code>加入到<code>WindowManager</code>中，也就是目前界面还尚未可见</p>
<p>另外，我们可以注意到，<code>performStart</code>是先于<code>callActivityOnPostCreate</code>，所以<code>Activity</code>中的生命周期回调<code>onPostCreate</code>是在<code>onStart</code>之后触发的，各位在开发App的时候不要弄错了这一点</p>
<p>其他的地方注释都写的都很明白了哈，也没什么必要再看<code>performStart</code>了，无非也就和<code>performCreate</code>一样，执行<code>ActivityLifecycleCallbacks</code>回调，<code>FragmentManager</code>分发<code>STARTED</code>状态，调用<code>onStart</code>方法等</p>
<p>接下来我们再回到<code>TransactionExecutor</code>中，后面便是执行<code>ResumeActivityItem</code>的<code>execute</code>和<code>postExecute</code>方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleResumeActivity(r, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">            <span class="string">"RESUME_ACTIVITY"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，又执行了<code>ActivityThread.handleResumeActivity</code>方法</p>
<h1 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="comment">//执行onResume生命周期</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We didn't actually resume the activity, so skipping any follow-up actions.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Activity将被destroy，那就没必要再执行resume了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mActivitiesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">        <span class="comment">// Although the activity is resumed, it is going to be destroyed. So the following</span></span><br><span class="line">        <span class="comment">// UI operations are unnecessary and also prevents exception because its token may</span></span><br><span class="line">        <span class="comment">// be gone that window manager cannot recognize it. All necessary cleanup actions</span></span><br><span class="line">        <span class="comment">// performed below will be done while handling destruction.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置Window</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">//DecorView暂时不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="comment">//给Activity的mDecor成员变量赋值</span></span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">            <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">            <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">            <span class="comment">// callbacks may have changed.</span></span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果DecorView尚未添加到WindowManager中，将其添加进去，否则更新Window属性</span></span><br><span class="line">        <span class="comment">//Activity启动过程中，第一次resume时，DecorView还尚未添加至WindowManager，所以会走进上面这个case</span></span><br><span class="line">        <span class="comment">//由于我们之前将DecorView的Visibility设置成了INVISIBLE，所以此时界面还是不可见</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class="line">                <span class="comment">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class="line">                <span class="comment">// in this method), so no action will be taken. This call ensures the</span></span><br><span class="line">                <span class="comment">// callback occurs with the decor set.</span></span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">        <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">        <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">    <span class="comment">//清除遗留的东西</span></span><br><span class="line">    cleanUpPendingRemoveWindows(r, <span class="keyword">false</span> <span class="comment">/* force */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="comment">//分发Configuration更新事件</span></span><br><span class="line">        <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">            r.newConfig = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当DecorView add进WindowManager后，ViewRootImpl被创建</span></span><br><span class="line">        ViewRootImpl impl = r.window.getDecorView().getViewRootImpl();</span><br><span class="line">        WindowManager.LayoutParams l = impl != <span class="keyword">null</span></span><br><span class="line">                ? impl.mWindowAttributes : r.window.getAttributes();</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//软键盘相关</span></span><br><span class="line"></span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="comment">//使DecorView可见</span></span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当空闲时，检查处理其他后台Activity状态</span></span><br><span class="line">    <span class="comment">//对处在stopping或finishing的Activity执行onStop或onDestroy生命周期</span></span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有三个重要的地方需要注意：</p>
<ol>
<li><p>执行<code>performResumeActivity</code>，这里和之前分析的两个生命周期类似，我们后面再看</p>
</li>
<li><p>给<code>Activity</code>的<code>mDecor</code>成员变量赋值，将<code>DecorView</code>添加到<code>WindowManager</code>中，使<code>DecorView</code>可见</p>
</li>
<li><p>将上一个活动的<code>ActivityClientRecord</code>以链表的形式串在当前<code>ActivityClientRecord</code>后面，向<code>MessageQueue</code>添加一条闲时处理消息<code>Idler</code>，这条消息会遍历<code>ActivityClientRecord</code>的整条<code>nextIdle</code>链，依次检查是否需要<code>stop</code>或<code>destroy</code> <code>Activity</code>，这一点我会在后面关于<code>Activity</code>其他生命周期的文章中再分析</p>
</li>
</ol>
<p>接下来我们简单过一下<code>performResumeActivity</code>吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//状态检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为最终生命周期状态</span></span><br><span class="line">    <span class="keyword">if</span> (finalStateRequest) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">false</span>;</span><br><span class="line">        r.activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.onStateNotSaved();</span><br><span class="line">        <span class="comment">//标记Fragments状态为未保存</span></span><br><span class="line">        r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">        <span class="comment">//更新网络状态</span></span><br><span class="line">        checkAndBlockForNetworkAccess();</span><br><span class="line">        <span class="keyword">if</span> (r.pendingIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">            r.pendingIntents = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.pendingResults != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverResults(r, r.pendingResults, reason);</span><br><span class="line">            r.pendingResults = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行Activity.onResume生命周期</span></span><br><span class="line">        r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将保存信息的savedInstanceState和persistentState重置为null</span></span><br><span class="line">        r.state = <span class="keyword">null</span>;</span><br><span class="line">        r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//设置生命周期状态</span></span><br><span class="line">        r.setState(ON_RESUME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调Activity.onTopResumedActivityChanged，报告栈顶活动Activity发生变化</span></span><br><span class="line">        reportTopResumedActivityChanged(r, r.isTopResumedActivity, <span class="string">"topWhenResuming"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">(<span class="keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityPreResumed</span></span><br><span class="line">    dispatchActivityPreResumed();</span><br><span class="line">    <span class="comment">//执行onRestart生命周期</span></span><br><span class="line">    <span class="comment">//内部会判断当前Activity是否为stop状态，是的话才会真正执行onRestart生命周期</span></span><br><span class="line">    <span class="comment">//启动Activity第一次resume时不会进入onRestart生命周期</span></span><br><span class="line">    performRestart(<span class="keyword">true</span> <span class="comment">/* start */</span>, reason);</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充功能</span></span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// mResumed is set by the instrumentation</span></span><br><span class="line">    <span class="comment">//执行Activity.onResume回调</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="comment">//必须执行super.onResume方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invisible activities must be finished before onResume() completes</span></span><br><span class="line">    ... <span class="comment">//异常检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now really resume, and install the current status bar and menu.</span></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FragmentManager分发resume状态</span></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行onPostResume回调</span></span><br><span class="line">    onPostResume();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="comment">//必须要执行super.onPostResume</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onPostResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityPostResumed</span></span><br><span class="line">    dispatchActivityPostResumed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityResumed</span></span><br><span class="line">    dispatchActivityResumed();</span><br><span class="line">    <span class="comment">//共享元素动画</span></span><br><span class="line">    mActivityTransitionState.onResume(<span class="keyword">this</span>);</span><br><span class="line">    ... <span class="comment">//自动填充功能</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_RESUME);</span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，基本上和之前的两个生命周期的执行是一个套路，唯一需要注意的是，在执行<code>onResume</code>生命周期之前，会先检查<code>Activity</code>是否处在<code>stop</code>状态，如果是的话，则会先执行<code>onRestart</code>生命周期，其他地方我在注释上标注的应该已经很明白了，这里就不再多讲了</p>
<p>不要忘了，在<code>TransactionExecutor</code>中还有最后一步<code>ResumeActivityItem.postExecute</code>没做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        ActivityTaskManager.getService().activityResumed(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>Binder</code>又回到了系统进程调用了<code>ATMS.activityResumed</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ActivityRecord.activityResumedLocked(token);</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">activityResumedLocked</span><span class="params">(IBinder token, <span class="keyword">boolean</span> handleSplashScreenExit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If an app reports resumed after a long delay, the record on server side might have</span></span><br><span class="line">        <span class="comment">// been removed (e.g. destroy timeout), so the token could be null.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SplashScreen</span></span><br><span class="line">    r.setCustomizeSplashScreenExitAnimation(handleSplashScreenExit);</span><br><span class="line">    <span class="comment">//重置savedState Bundle</span></span><br><span class="line">    r.setSavedState(<span class="keyword">null</span> <span class="comment">/* savedState */</span>);</span><br><span class="line"></span><br><span class="line">    r.mDisplayContent.handleActivitySizeCompatModeIfNeeded(r);</span><br><span class="line">    <span class="comment">//防闪烁功能</span></span><br><span class="line">    r.mDisplayContent.mUnknownAppVisibilityController.notifyAppResumedFinished(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后也就做了一些收尾工作，到这里，整个<code>Activity</code>的启动流程也就圆满结束了</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此为止，我们<code>Activity</code>启动流程三部连续剧终于是圆满完成了，历时整整半年的时间，我心里压着的这块石头也终于是落地了，后面我应该会再做一些关于<code>Activity</code>其他生命周期变换的分析，比如说<code>Activity</code>是怎样销毁的，欢迎感兴趣的小伙伴点赞、收藏、关注我</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/">Android源码分析 - Activity启动流程（中）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中，我们分析了<code>Activity</code>启动流程中的一小部分，基本上可以算是<code>Activity</code>启动的前置准备工作，这篇文章我们将会分析App进程启动的主要流程</p>
<h1 id="启动App进程"><a href="#启动App进程" class="headerlink" title="启动App进程"></a>启动App进程</h1><h2 id="准备ProcessRecord"><a href="#准备ProcessRecord" class="headerlink" title="准备ProcessRecord"></a>准备ProcessRecord</h2><p>上篇文章中我们说过了，如果App尚未启动，则会调用<code>ATMS</code>的<code>startProcessAsync</code>方法去启动App进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startProcessAsync</span><span class="params">(ActivityRecord activity, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line">        <span class="comment">// ATMS lock held.</span></span><br><span class="line">        <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">        mH.sendMessage(m);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法实际上是通过<code>Hander</code>调用了<code>ActivityManagerInternal (AMS.LocalService)</code>的<code>startProcess</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// If the process is known as top app, set a hint so when the process is</span></span><br><span class="line">        <span class="comment">// started, the top priority can be applied immediately to avoid cpu being</span></span><br><span class="line">        <span class="comment">// preempted by other processes before attaching the process of top app.</span></span><br><span class="line">        startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                <span class="keyword">new</span> HostingRecord(hostingType, hostingName, isTop),</span><br><span class="line">                ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, <span class="keyword">false</span> <span class="comment">/* allowWhileBooting */</span>,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* isolated */</span>, <span class="keyword">true</span> <span class="comment">/* keepIfLarge */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将进程启动的一些信息封装到了<code>HostingRecord</code>类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">    ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    HostingRecord hostingRecord, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">        hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>,</span><br><span class="line">        keepIfLarge, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">        <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>, <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AMS</code>将启动进程的任务转交给了<code>ProcessList</code>，这个类的职责是管理进程，包括管理进程优先级(Adj)、进程OOM等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        <span class="comment">//先通过进程名和uid查找相应App的ProcessRecord</span></span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是由后台进程发起的 startProcess</span></span><br><span class="line">        <span class="comment">//判断启动进程是否为 bad process，如果是，直接启动失败返回</span></span><br><span class="line">        <span class="comment">//这里 bad process 的定义为：短时间内连续崩溃两次以上的进程</span></span><br><span class="line">        <span class="keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are in the background, then check to see if this process</span></span><br><span class="line">            <span class="comment">// is bad.  If so, we will just silently fail.</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When the user is explicitly starting a process, then clear its</span></span><br><span class="line">            <span class="comment">// crash count so that we won't make it bad until they see at</span></span><br><span class="line">            <span class="comment">// least one crash dialog again, and make the process good again</span></span><br><span class="line">            <span class="comment">// if it had been bad.</span></span><br><span class="line">            <span class="comment">//如果是用户显式的要求启动进程，则会清空启动进程的崩溃次数，将启动进程从 bad process 列表中移除</span></span><br><span class="line">            mService.mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                        UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                        info.processName);</span><br><span class="line">                mService.mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app.bad = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If this is an isolated process, it can't re-use an existing process.</span></span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't have to do anything more if:</span></span><br><span class="line">    <span class="comment">// (1) There is an existing application record; and</span></span><br><span class="line">    <span class="comment">// (2) The caller doesn't think it is dead, OR there is no thread</span></span><br><span class="line">    <span class="comment">//     object attached to it so we know it couldn't have crashed; and</span></span><br><span class="line">    <span class="comment">// (3) There is a pid assigned to it, so it is either starting or</span></span><br><span class="line">    <span class="comment">//     already running.</span></span><br><span class="line">    ProcessRecord precedence = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果已经存在了对应App的ProcessRecord，并且分配了pid</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果进程没有死亡或者进程还未绑定binder线程，说明进程是正常运行状态或正在启动中</span></span><br><span class="line">        <span class="keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We already have the app running, or are waiting for it to</span></span><br><span class="line">            <span class="comment">// come up (we have a pid but not yet its thread), so keep it.</span></span><br><span class="line">            <span class="comment">// If this is a new package in the process, add the package to the list</span></span><br><span class="line">            <span class="comment">//将要启动的包信息记录在ProcessRecord中（Android多个App可以运行在同一个进程中）</span></span><br><span class="line">            app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);</span><br><span class="line">            <span class="keyword">return</span> app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// An application record is attached to a previous process,</span></span><br><span class="line">        <span class="comment">// clean it up now.</span></span><br><span class="line">        <span class="comment">//App绑定在之前的一个进程上了，杀死并清理这个进程</span></span><br><span class="line">        ProcessList.killProcessGroup(app.uid, app.pid);</span><br><span class="line"></span><br><span class="line">        Slog.wtf(TAG_PROCESSES, app.toString() + <span class="string">" is attached to a previous process"</span>);</span><br><span class="line">        <span class="comment">// We are not going to re-use the ProcessRecord, as we haven't dealt with the cleanup</span></span><br><span class="line">        <span class="comment">// routine of it yet, but we'd set it as the precedence of the new process.</span></span><br><span class="line">        precedence = app;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到对应的ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//新创建一个ProcessRecord对象</span></span><br><span class="line">        app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed making new process record for "</span></span><br><span class="line">                    + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler = crashHandler;</span><br><span class="line">        app.isolatedEntryPoint = entryPoint;</span><br><span class="line">        app.isolatedEntryPointArgs = entryPointArgs;</span><br><span class="line">        <span class="keyword">if</span> (precedence != <span class="keyword">null</span>) &#123;</span><br><span class="line">            app.mPrecedence = precedence;</span><br><span class="line">            precedence.mSuccessor = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//存在对应的ProcessRecord，但进程尚未启动或已被清理</span></span><br><span class="line">        <span class="comment">// If this is a new package in the process, add the package to the list</span></span><br><span class="line">        <span class="comment">//将要启动的包信息记录在ProcessRecord中</span></span><br><span class="line">        app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the system is not ready yet, then hold off on starting this</span></span><br><span class="line">    <span class="comment">// process until it is.</span></span><br><span class="line">    <span class="comment">//如果系统尚未准备好（开机中或system_server进程崩溃重启中），将其先添加到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mProcessesReady</span><br><span class="line">            &amp;&amp; !mService.isAllowedWhileBooting(info)</span><br><span class="line">            &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mService.mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">            mService.mProcessesOnHold.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> success =</span><br><span class="line">            startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride);</span><br><span class="line">    <span class="keyword">return</span> success ? app : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是处理<code>ProcessRecord</code>对象，如果找不到对应的<code>ProcessRecord</code>或对应的<code>ProcessRecord</code>里的信息表明App进程尚未启动，则会调用另一个<code>startProcessLocked</code>重载方法启动进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingRecord, zygotePolicyFlags,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, <span class="keyword">false</span> <span class="comment">/* disableTestApiChecks */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* mountExtStorageFull */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> disableHiddenApiChecks, <span class="keyword">boolean</span> disableTestApiChecks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> mountExtStorageFull, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进程正在启动中</span></span><br><span class="line">    <span class="keyword">if</span> (app.pendingStart) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从刚才方法中的判断来看，应该不会进入这个case</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">        <span class="comment">//将ProcessRecord的pid从PidMap中移除</span></span><br><span class="line">        mService.removePidLocked(app);</span><br><span class="line">        app.bindMountPending = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//将ProcessRecord的pid重置为0</span></span><br><span class="line">        app.setPid(<span class="number">0</span>);</span><br><span class="line">        app.startSeq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将ProcessRecord从启动等待队列中移除</span></span><br><span class="line">    mService.mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检测当前用户是否可以启动这个App</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">        <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//默认不挂载外置存储</span></span><br><span class="line">        <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">        <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line">                <span class="comment">//获取GIDS（App申请的权限）</span></span><br><span class="line">                permGids = pm.getPackageGids(app.info.packageName,</span><br><span class="line">                        MATCH_DIRECT_BOOT_AUTO, app.userId);</span><br><span class="line">                <span class="keyword">if</span> (StorageManager.hasIsolatedStorage() &amp;&amp; mountExtStorageFull) &#123;</span><br><span class="line">                    <span class="comment">//挂载外置存储，允许读写</span></span><br><span class="line">                    mountExternal = Zygote.MOUNT_EXTERNAL_FULL;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                            StorageManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="comment">//获取App对外置存储的读写权限</span></span><br><span class="line">                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                            app.info.packageName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove any gids needed if the process has been denied permissions.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> eventually we should probably have the package manager pre-compute</span></span><br><span class="line">            <span class="comment">// this for us?</span></span><br><span class="line">            <span class="comment">//从刚刚过去的App申请权限中剔除进程所被拒绝的权限</span></span><br><span class="line">            <span class="keyword">if</span> (app.processInfo != <span class="keyword">null</span> &amp;&amp; app.processInfo.deniedPermissions != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = app.processInfo.deniedPermissions.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] denyGids = mService.mPackageManagerInt.getPermissionGids(</span><br><span class="line">                            app.processInfo.deniedPermissions.valueAt(i), app.userId);</span><br><span class="line">                    <span class="keyword">if</span> (denyGids != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> gid : denyGids) &#123;</span><br><span class="line">                            permGids = ArrayUtils.removeInt(permGids, gid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算得出进程所应拥有的所有权限</span></span><br><span class="line">            gids = computeGidsForProcess(mountExternal, uid, permGids);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挂载模式</span></span><br><span class="line">        app.mountMode = mountExternal;</span><br><span class="line">        <span class="comment">//工厂测试进程</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) &#123;</span><br><span class="line">            uid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进程启动参数（传递到Zygoto）</span></span><br><span class="line">        <span class="keyword">int</span> runtimeFlags = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果manifest中设置了android:debuggable</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;</span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;</span><br><span class="line">            <span class="comment">// Also turn on CheckJNI for debuggable apps. It's quite</span></span><br><span class="line">            <span class="comment">// awkward to turn on otherwise.</span></span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if the developer does not want ART verification</span></span><br><span class="line">            <span class="keyword">if</span> (android.provider.Settings.Global.getInt(mService.mContext.getContentResolver(),</span><br><span class="line">                    android.provider.Settings.Global.ART_VERIFIER_VERIFY_DEBUGGABLE, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                runtimeFlags |= Zygote.DISABLE_VERIFIER;</span><br><span class="line">                Slog.w(TAG_PROCESSES, app + <span class="string">": ART verification disabled"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//设置各种高进程启动参数</span></span><br><span class="line"></span><br><span class="line">        String invokeWith = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果manifest中设置了android:debuggable</span></span><br><span class="line">        <span class="comment">//使用logwrapper工具捕获stdout信息</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Debuggable apps may include a wrapper script with their library directory.</span></span><br><span class="line">            String wrapperFileName = app.info.nativeLibraryDir + <span class="string">"/wrap.sh"</span>;</span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(wrapperFileName).exists()) &#123;</span><br><span class="line">                    invokeWith = <span class="string">"/system/bin/logwrapper "</span> + wrapperFileName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定App进程使用的abi（有so库的App会通过so库的架构决定，没有so库的使用系统最优先支持的abi）</span></span><br><span class="line">        String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride : app.info.primaryCpuAbi;</span><br><span class="line">        <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将abi转成InstructionSet</span></span><br><span class="line">        String instructionSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (app.info.primaryCpuAbi != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.gids = gids;</span><br><span class="line">        app.setRequiredAbi(requiredAbi);</span><br><span class="line">        app.instructionSet = instructionSet;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String seInfo = app.info.seInfo</span><br><span class="line">                + (TextUtils.isEmpty(app.info.seInfoUser) ? <span class="string">""</span> : app.info.seInfoUser);</span><br><span class="line">        <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">        <span class="comment">//重要：设置进程启动入口</span></span><br><span class="line">        <span class="keyword">final</span> String entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动进程</span></span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,</span><br><span class="line">                instructionSet, invokeWith, startTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">"start failure"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步位置仍然是在进行准备工作，主要做了以下几件事：</p>
<ol>
<li>权限处理：App安装时会检测<code>manifest</code>里申请的权限，并由此生成出一个<code>GIDS</code>数组</li>
<li>设置挂载模式</li>
<li>设置进程的各种启动参数</li>
<li>设置App进程使用的<code>abi</code></li>
<li>设置进程启动入口</li>
<li>继续调用重载方法启动进程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一些参数</span></span><br><span class="line">    <span class="comment">//标识App进程正在启动</span></span><br><span class="line">    app.pendingStart = <span class="keyword">true</span>;</span><br><span class="line">    app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">    app.removed = <span class="keyword">false</span>;</span><br><span class="line">    app.killed = <span class="keyword">false</span>;</span><br><span class="line">    app.mDisabledCompatChanges = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mPlatformCompat != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.mDisabledCompatChanges = mPlatformCompat.getDisabledChanges(app.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startSeq = app.startSeq = ++mProcStartSeqCounter;</span><br><span class="line">    app.setStartParams(uid, hostingRecord, seInfo, startTime);</span><br><span class="line">    app.setUsingWrapper(invokeWith != <span class="keyword">null</span></span><br><span class="line">            || Zygote.getWrapProperty(app.processName) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//将ProcessRecord添加到待启动列表中</span></span><br><span class="line">    mPendingStarts.put(startSeq, app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;    <span class="comment">//异步启动进程</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,</span><br><span class="line">                <span class="string">"Posting procStart msg for "</span> + app.toShortString());</span><br><span class="line">        mService.mProcStartHandler.post(() -&gt; handleProcessStart(</span><br><span class="line">                app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal,</span><br><span class="line">                requiredAbi, instructionSet, invokeWith, startSeq));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//同步启动进程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">                    entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,</span><br><span class="line">                    requiredAbi, instructionSet, invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">//出错，将pendingStart标志复位并强行停止进程</span></span><br><span class="line">            app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">"start failure"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步模式下，程序会等待<code>ProcessRecord.mPrecedence</code>进程结束才会启动进程（这里对应着最开始的<code>startProcessLocked</code>方法中，已经存在了对应App的<code>ProcessRecord</code>，并且分配了<code>pid</code>，但是进程被标记为死亡这种情况）</p>
<p>最终都会进入到<code>startProcess</code>和<code>handleProcessStartedLocked</code>方法中来</p>
<h2 id="startProcess"><a href="#startProcess" class="headerlink" title="startProcess"></a>startProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        String invokeWith, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isTopApp = hostingRecord.isTopApp();</span><br><span class="line">        <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">            <span class="comment">// Use has-foreground-activities as a temporary hint so the current scheduling</span></span><br><span class="line">            <span class="comment">// group won't be lost when the process is attaching. The actual state will be</span></span><br><span class="line">            <span class="comment">// refreshed when computing oom-adj.</span></span><br><span class="line">            app.setHasForegroundActivities(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理应用目录隔离机制</span></span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap;</span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; whitelistedAppDataInfoMap;</span><br><span class="line">        <span class="keyword">boolean</span> bindMountAppStorageDirs = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> bindMountAppsData = mAppDataIsolationEnabled</span><br><span class="line">                &amp;&amp; (UserHandle.isApp(app.uid) || UserHandle.isIsolated(app.uid))</span><br><span class="line">                &amp;&amp; mPlatformCompat.isChangeEnabled(APP_DATA_DIRECTORY_ISOLATION, app.info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all packages belongs to the same shared uid. sharedPackages is empty array</span></span><br><span class="line">        <span class="comment">// if it doesn't have shared uid.</span></span><br><span class="line">        <span class="keyword">final</span> PackageManagerInternal pmInt = mService.getPackageManagerInternalLocked();</span><br><span class="line">        <span class="keyword">final</span> String[] sharedPackages = pmInt.getSharedUserPackagesForPackage(</span><br><span class="line">                app.info.packageName, app.userId);</span><br><span class="line">        <span class="keyword">final</span> String[] targetPackagesList = sharedPackages.length == <span class="number">0</span></span><br><span class="line">                ? <span class="keyword">new</span> String[]&#123;app.info.packageName&#125; : sharedPackages;</span><br><span class="line"></span><br><span class="line">        pkgDataInfoMap = getPackageAppDataInfoMap(pmInt, targetPackagesList, uid);</span><br><span class="line">        <span class="keyword">if</span> (pkgDataInfoMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/152760674): Handle inode == 0 case properly, now we just give it a</span></span><br><span class="line">            <span class="comment">// tmp free pass.</span></span><br><span class="line">            bindMountAppsData = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove all packages in pkgDataInfoMap from mAppDataIsolationWhitelistedApps, so</span></span><br><span class="line">        <span class="comment">// it won't be mounted twice.</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; whitelistedApps = <span class="keyword">new</span> ArraySet&lt;&gt;(mAppDataIsolationWhitelistedApps);</span><br><span class="line">        <span class="keyword">for</span> (String pkg : targetPackagesList) &#123;</span><br><span class="line">            whitelistedApps.remove(pkg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        whitelistedAppDataInfoMap = getPackageAppDataInfoMap(pmInt,</span><br><span class="line">                whitelistedApps.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]), uid);</span><br><span class="line">        <span class="keyword">if</span> (whitelistedAppDataInfoMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/152760674): Handle inode == 0 case properly, now we just give it a</span></span><br><span class="line">            <span class="comment">// tmp free pass.</span></span><br><span class="line">            bindMountAppsData = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> userId = UserHandle.getUserId(uid);</span><br><span class="line">        StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                StorageManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (needsStorageDataIsolation(storageManagerInternal, app)) &#123;</span><br><span class="line">            bindMountAppStorageDirs = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pkgDataInfoMap == <span class="keyword">null</span> ||</span><br><span class="line">                    !storageManagerInternal.prepareStorageDirs(userId, pkgDataInfoMap.keySet(),</span><br><span class="line">                    app.processName)) &#123;</span><br><span class="line">                <span class="comment">// Cannot prepare Android/app and Android/obb directory or inode == 0,</span></span><br><span class="line">                <span class="comment">// so we won't mount it in zygote, but resume the mount after unlocking device.</span></span><br><span class="line">                app.bindMountPending = <span class="keyword">true</span>;</span><br><span class="line">                bindMountAppStorageDirs = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's an isolated process, it should not even mount its own app data directories,</span></span><br><span class="line">        <span class="comment">// since it has no access to them anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (app.isolated) &#123;</span><br><span class="line">            pkgDataInfoMap = <span class="keyword">null</span>;</span><br><span class="line">            whitelistedAppDataInfoMap = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName, app.mDisabledCompatChanges,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can't isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                    <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                    app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap,</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//没有特别指定hostingZygote时，进入此case</span></span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                    isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap,</span><br><span class="line">                    whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Android 11</code>开始引入了应用目录隔离机制，使得应用仅可以发现和访问自己的储存目录，不可以访问其他应用的储存目录</p>
<p>这里处理完应用目录隔离机制后，调用了<code>Process.start</code>方法启动进程，最终走到<code>ZygoteProcess.startViaZygote</code>方法</p>
<h3 id="向zygoto发送socket请求"><a href="#向zygoto发送socket请求" class="headerlink" title="向zygoto发送socket请求"></a>向zygoto发送socket请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(@NonNull <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @NonNull String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            pkgDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            allowlistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> bindMountAppsData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                    <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">    <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">    argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">    argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">    <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-installer"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-pass-through"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-android-writable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">    <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(gids[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">        argsForZygote.add(invokeWith);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--package-name="</span> + packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.START_AS_TOP_APP_ARG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pkgDataInfoMap != <span class="keyword">null</span> &amp;&amp; pkgDataInfoMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(Zygote.PKG_DATA_INFO_MAP);</span><br><span class="line">        sb.append(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            sb.append(entry.getKey());</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().first);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().second);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowlistedDataInfoList != <span class="keyword">null</span> &amp;&amp; allowlistedDataInfoList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(Zygote.ALLOWLISTED_DATA_INFO_MAP);</span><br><span class="line">        sb.append(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : allowlistedDataInfoList.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            sb.append(entry.getKey());</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().first);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().second);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bindMountAppStorageDirs) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bindMountAppsData) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disabledCompatChanges != <span class="keyword">null</span> &amp;&amp; disabledCompatChanges.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"--disabled-compat-changes="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = disabledCompatChanges.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(disabledCompatChanges[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Collections.addAll(argsForZygote, extraArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">        <span class="comment">// The USAP pool can not be used if the application will not use the systems graphics</span></span><br><span class="line">        <span class="comment">// driver.  If that driver is requested use the Zygote application start path.</span></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                            zygotePolicyFlags,</span><br><span class="line">                                            argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的功能就很简单了，就是将各种参数拼装起来，然后调用<code>zygoteSendArgsAndGetResult</code>方法</p>
<p>我们先看<code>openZygoteSocketIfNeeded</code>这个方法，它返回了一个<code>ZygoteState</code>对象，这个类是对与<code>ZygoteServerSocket</code>建立连接后的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//尝试连接主ZygoteServerSocket</span></span><br><span class="line">        attemptConnectionToPrimaryZygote();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主zygote进程支持此abi</span></span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mZygoteSecondarySocketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">            <span class="comment">//尝试连接辅ZygoteServerSocket</span></span><br><span class="line">            attemptConnectionToSecondaryZygote();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//辅zygote进程支持此abi</span></span><br><span class="line">            <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">                <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to zygote"</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attemptConnectionToxxxZygote</code>方法使用<code>LocalSocket</code>进行连接，并返回一个<code>ZygoteState</code>封装对象</p>
<p>我们之前在 <a href="https://juejin.cn/post/7051507161955827720" target="_blank" rel="noopener">Android源码分析 - Zygote进程</a> 中说过，一般，64位的cpu会启动两个<code>zygoto</code>进程，一个64位（主<code>zygote</code>），一个32位（辅<code>zygote</code>）</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89_zygote.png" alt="zygote"></p>
<p>接下来我们看<code>zygoteSendArgsAndGetResult</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * See com.android.internal.os.ZygoteArguments.parseArgs()</span></span><br><span class="line"><span class="comment">        * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">        * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">        * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">        * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">        * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//构建出符合zygote解析规则的参数（argc + argv）</span></span><br><span class="line">    String msgStr = args.size() + <span class="string">"\n"</span> + String.join(<span class="string">"\n"</span>, args) + <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//USAP机制</span></span><br><span class="line">    <span class="keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// If there was an IOException using the USAP pool we will log the error and</span></span><br><span class="line">            <span class="comment">// attempt to start the process through the Zygote.</span></span><br><span class="line">            Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with USAP pool - "</span></span><br><span class="line">                    + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>USAP</code>机制我们先跳过，这个方法就做了一件事：拼装参数，然后调用<code>attemptZygoteSendArgsAndGetResult</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">        zygoteWriter.write(msgStr);</span><br><span class="line">        zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">        result.pid = zygoteInputStream.readInt();</span><br><span class="line">        result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with Zygote - "</span></span><br><span class="line">                + ex.toString());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很明显就能看出来，这是一次<code>socket</code>通信发送 -&gt; 接收</p>
<p>具体<code>zygote</code>进程接收到<code>socket</code>后做了什么可以回顾我之前写的文章 <a href="https://juejin.cn/post/7051507161955827720#heading-29" target="_blank" rel="noopener">Android源码分析 - Zygote进程</a></p>
<h2 id="handleProcessStartedLocked"><a href="#handleProcessStartedLocked" class="headerlink" title="handleProcessStartedLocked"></a>handleProcessStartedLocked</h2><p>向<code>zygote</code>发送完<code>socket</code>请求后，<code>zygote</code>开始<code>fork</code>App进程，<code>fork</code>完后会将App进程的<code>pid</code>和<code>usingWrapper</code>信息再通过<code>socket</code>传回<code>system_server</code>，此时程序会继续执行<code>handleProcessStartedLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">handleProcessStartedLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> pid, <span class="keyword">boolean</span> usingWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> expectedStartSeq, <span class="keyword">boolean</span> procAttached)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从待启动列表中移除此ProcessRecord</span></span><br><span class="line">    mPendingStarts.remove(expectedStartSeq);</span><br><span class="line">    <span class="keyword">final</span> String reason = isProcStartValidLocked(app, expectedStartSeq);</span><br><span class="line">    <span class="comment">//未通过进程启动验证，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">        killProcessQuiet(pid);</span><br><span class="line">        Process.killProcessGroup(app.uid, app.pid);</span><br><span class="line">        noteAppKill(app, ApplicationExitInfo.REASON_OTHER,</span><br><span class="line">                ApplicationExitInfo.SUBREASON_INVALID_START, reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//记录进程启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知看门狗有进程启动</span></span><br><span class="line">    Watchdog.getInstance().processStarted(app.processName, pid);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录进程启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置ProcessRecord</span></span><br><span class="line">    app.setPid(pid);</span><br><span class="line">    app.setUsingWrapper(usingWrapper);</span><br><span class="line">    app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//从PidMap中获取未清理的ProcessRecord</span></span><br><span class="line">    ProcessRecord oldApp;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">        oldApp = mService.mPidsSelfLocked.get(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is already an app occupying that pid that hasn't been cleaned up</span></span><br><span class="line">    <span class="comment">//清理ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (oldApp != <span class="keyword">null</span> &amp;&amp; !app.isolated) &#123;</span><br><span class="line">        mService.cleanUpApplicationRecordLocked(oldApp, <span class="keyword">false</span>, <span class="keyword">false</span>, -<span class="number">1</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将ProcessRecord添加到PidMap中</span></span><br><span class="line">    mService.addPidLocked(app);</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">        <span class="comment">//attach超时检测</span></span><br><span class="line">        <span class="keyword">if</span> (!procAttached) &#123;</span><br><span class="line">            Message msg = mService.mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = app;</span><br><span class="line">            mService.mHandler.sendMessageDelayed(msg, usingWrapper</span><br><span class="line">                    ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将从<code>zygote</code> <code>fork</code>后得到的信息设置到<code>ProcessRecord</code>中，然后将此<code>ProcessRecord</code>添加到<code>PidMap</code>中（<code>AMS.mPidsSelfLocked</code>），后续当<code>attachApplication</code>时会用到它</p>
<h1 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><p><code>zygote</code>进程将App进程<code>fork</code>出来后，便通过反射调用我们之前设置的<code>entryPoint</code>类的<code>main</code>方法，即<code>android.app.ActivityThread.main(String[] args)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    <span class="comment">//设置拦截器，拦截部分系统调用自行处理</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    <span class="comment">//资源关闭检测器</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化用户环境</span></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="comment">//设置CA证书搜索位置</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    <span class="comment">//初始化主模块各个注册服务</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预设进程名</span></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">    <span class="comment">//查找startSeq参数</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建App进程ActivityThread实例</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置全局Handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Looper循环处理消息</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>方法中主要做了两件事，一是启动<code>Looper</code>，循环处理消息，保证进程不会退出，二是实例化<code>ActivityThread</code>并执行<code>attach</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mConfigurationController = <span class="keyword">new</span> ConfigurationController(<span class="keyword">this</span>);</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;    <span class="comment">//非系统ActivityThread</span></span><br><span class="line">        <span class="comment">//预设进程名</span></span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        <span class="comment">//处理一些错误异常需要使用ActivityThread，将其传入</span></span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">//AMS代理binder对象</span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行AMS.attachApplication方法</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        <span class="comment">//每次GC时检测内存，如果内存不足则会尝试释放部分不可见的Activity</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">"Dalvik max="</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" total="</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" used="</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//系统ActivityThread</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理ConfigChanged相关逻辑（屏幕旋转之类）</span></span><br><span class="line">    ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">            <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">            <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResources(globalConfig,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">                mConfigurationController.updateLocaleListFromAppContext(</span><br><span class="line">                        mInitialApplication.getApplicationContext());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">                <span class="keyword">final</span> Configuration updatedConfig =</span><br><span class="line">                        mConfigurationController.updatePendingConfiguration(globalConfig);</span><br><span class="line">                <span class="keyword">if</span> (updatedConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">                    mPendingConfiguration = updatedConfig;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>attach</code>方法最重要的一步又是调用了<code>AMS</code>的<code>attachApplication</code>方法</p>
<h1 id="AMS-attachApplication"><a href="#AMS-attachApplication" class="headerlink" title="AMS.attachApplication"></a>AMS.attachApplication</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Invalid application interface"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the application record that is being attached...  either via</span></span><br><span class="line">    <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></span><br><span class="line">    <span class="comment">// next app record if we are emulating process with anonymous threads.</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">long</span> bindApplicationTimeMillis;</span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通过pid查找PidMap中存在的ProcessRecord</span></span><br><span class="line">        <span class="comment">//对应着handleProcessStartedLocked方法中执行的中的mService.addPidLocked方法</span></span><br><span class="line">        <span class="comment">//在进程同步启动模式下，这里应该是必能取到的</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此ProcessRecord对不上App的ProcessRecord，则将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; (app.startUid != callingUid || app.startSeq != startSeq)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If there is already an app occupying that pid that hasn't been cleaned up</span></span><br><span class="line">            cleanUpApplicationRecordLocked(app, <span class="keyword">false</span>, <span class="keyword">false</span>, -<span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">            removePidLocked(app);</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's possible that process called attachApplication before we got a chance to</span></span><br><span class="line">    <span class="comment">// update the internal state.</span></span><br><span class="line">    <span class="comment">//在进程异步启动模式下，有可能尚未执行到handleProcessStartedLocked方法</span></span><br><span class="line">    <span class="comment">//所以从PidMap中无法取到相应的ProcessRecord</span></span><br><span class="line">    <span class="comment">//这时候从ProcessList.mPendingStarts这个待启动列表中获取ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; startSeq &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord pending = mProcessList.mPendingStarts.get(startSeq);</span><br><span class="line">        <span class="keyword">if</span> (pending != <span class="keyword">null</span> &amp;&amp; pending.startUid == callingUid &amp;&amp; pending.startSeq == startSeq</span><br><span class="line">                &amp;&amp; mProcessList.handleProcessStartedLocked(pending, pid, pending</span><br><span class="line">                        .isUsingWrapper(),</span><br><span class="line">                        startSeq, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            app = pending;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到相应的ProcessRecord，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span> &amp;&amp; pid != MY_PID) &#123;</span><br><span class="line">            killProcessQuiet(pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.scheduleExit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Ignore exceptions.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this application record is still attached to a previous</span></span><br><span class="line">    <span class="comment">// process, clean it up now.</span></span><br><span class="line">    <span class="comment">//如果ProcessRecord绑定了其他的ApplicationThread，则需要清理这个进程</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册App进程死亡回调</span></span><br><span class="line">        AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">        app.deathRecipient = adr;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//如果出现异常则重启进程</span></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        mProcessList.startProcessLocked(app,</span><br><span class="line">                <span class="keyword">new</span> HostingRecord(<span class="string">"link fail"</span>, processName),</span><br><span class="line">                ZYGOTE_POLICY_FLAG_EMPTY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化ProcessRecord各参数</span></span><br><span class="line">    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    mOomAdjuster.setAttachingSchedGroupLocked(app);</span><br><span class="line">    app.forcingToImportant = <span class="keyword">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="keyword">false</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    app.hasShownUi = <span class="keyword">false</span>;</span><br><span class="line">    app.setDebugging(<span class="keyword">false</span>);</span><br><span class="line">    app.setCached(<span class="keyword">false</span>);</span><br><span class="line">    app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">    app.killed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We carefully use the same state that PackageManager uses for</span></span><br><span class="line">    <span class="comment">// filtering, since we use this flag to decide if we need to install</span></span><br><span class="line">    <span class="comment">// providers when user is unlocked later</span></span><br><span class="line">    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除之前在handleProcessStartedLocked中设置的attach超时检测</span></span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通App启动肯定在system_server准备完成后，所以此处为true</span></span><br><span class="line">    <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//设置ContentProvider启动超时检测</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg,</span><br><span class="line">                ContentResolver.CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BackupRecord backupTarget = mBackupTargets.get(app.userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对应着开发者模式里的 Select debug app 和 Wait for debugger</span></span><br><span class="line">        <span class="keyword">int</span> testMode = ApplicationThreadConstants.DEBUG_OFF;</span><br><span class="line">        <span class="keyword">if</span> (mDebugApp != <span class="keyword">null</span> &amp;&amp; mDebugApp.equals(processName)) &#123;</span><br><span class="line">            testMode = mWaitForDebugger</span><br><span class="line">                ? ApplicationThreadConstants.DEBUG_WAIT</span><br><span class="line">                : ApplicationThreadConstants.DEBUG_ON;</span><br><span class="line">            app.setDebugging(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mDebugTransient) &#123;</span><br><span class="line">                mDebugApp = mOrigDebugApp;</span><br><span class="line">                mWaitForDebugger = mOrigWaitForDebugger;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> enableTrackAllocation = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTrackAllocationApp != <span class="keyword">null</span> &amp;&amp; mTrackAllocationApp.equals(processName)) &#123;</span><br><span class="line">            enableTrackAllocation = <span class="keyword">true</span>;</span><br><span class="line">            mTrackAllocationApp = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the app is being launched for restore or full backup, set it up specially</span></span><br><span class="line">        <span class="keyword">boolean</span> isRestrictedBackupMode = <span class="keyword">false</span>;</span><br><span class="line">        ... <span class="comment">//备份相关</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActiveInstrumentation instr;</span><br><span class="line">        ... <span class="comment">//自动化测试相关</span></span><br><span class="line"></span><br><span class="line">        ApplicationInfo appInfo = instr != <span class="keyword">null</span> ? instr.mTargetInfo : app.info;</span><br><span class="line">        app.compat = compatibilityInfoForPackage(appInfo);</span><br><span class="line"></span><br><span class="line">        ProfilerInfo profilerInfo = <span class="keyword">null</span>;</span><br><span class="line">        String preBindAgent = <span class="keyword">null</span>;</span><br><span class="line">        ... <span class="comment">//性能分析相关</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We deprecated Build.SERIAL and it is not accessible to</span></span><br><span class="line">        <span class="comment">// Instant Apps and target APIs higher than O MR1. Since access to the serial</span></span><br><span class="line">        <span class="comment">// is now behind a permission we push down the value.</span></span><br><span class="line">        <span class="comment">//序列号（Android 8.0后不可再通过Build.SERIAL获取序列号）</span></span><br><span class="line">        <span class="keyword">final</span> String buildSerial = (!appInfo.isInstantApp()</span><br><span class="line">                &amp;&amp; appInfo.targetSdkVersion &lt; Build.VERSION_CODES.P)</span><br><span class="line">                        ? sTheRealBuildSerial : Build.UNKNOWN;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ... <span class="comment">//自动化测试相关</span></span><br><span class="line">        ... <span class="comment">//性能分析相关</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//debug模式</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            thread.attachStartupAgents(app.info.dataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//自动填充功能（账号密码等）</span></span><br><span class="line">        ... <span class="comment">//内容捕获相关（ContentCaptureManager）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动化测试</span></span><br><span class="line">        <span class="keyword">final</span> ActiveInstrumentation instr2 = app.getActiveInstrumentation();</span><br><span class="line">        <span class="keyword">if</span> (mPlatformCompat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPlatformCompat.resetReporting(app.info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ProviderInfoList providerList = ProviderInfoList.fromList(providers);</span><br><span class="line">        <span class="comment">//调用ApplicationThread.bindApplication方法</span></span><br><span class="line">        <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">            <span class="comment">// being bound to an application.</span></span><br><span class="line">            thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providerList,</span><br><span class="line">                    instr2.mClass,</span><br><span class="line">                    profilerInfo, instr2.mArguments,</span><br><span class="line">                    instr2.mWatcher,</span><br><span class="line">                    instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                    app.mDisabledCompatChanges);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providerList, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                    app.mDisabledCompatChanges);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make app active after binding application or client may be running requests (e.g</span></span><br><span class="line">        <span class="comment">// starting activities) before it is ready.</span></span><br><span class="line">        <span class="comment">//ProcessRecord保存ApplicationThread代理对象</span></span><br><span class="line">        app.makeActive(thread, mProcessStats);</span><br><span class="line">        <span class="comment">//更新进程使用情况</span></span><br><span class="line">        mProcessList.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//出现错误，杀死进程</span></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        app.kill(<span class="string">"error during bind"</span>, ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this record from the list of starting applications.</span></span><br><span class="line">    <span class="comment">//从persistent启动列表中移除此ProcessRecord</span></span><br><span class="line">    <span class="comment">//persistent是manifest中application标签下的一个属性</span></span><br><span class="line">    <span class="comment">//设置了此属性代表此App会跟随系统启动而启动</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Activity等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Services等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if a next-broadcast receiver is in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有广播接收器需要启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//备份相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上几步发生异常，杀死App进程</span></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        <span class="comment">//更新进程OOM等级</span></span><br><span class="line">        updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下这个方法主要做了哪些事，首先获取<code>ProcessRecord</code>，然后对其做一些初始化设置，然后调用<code>ApplicaionThread.bindApplication</code>方法，最后分别检查处理<code>Activity</code>、<code>Service</code>和<code>BroadcastReceiver</code>的启动</p>
<h2 id="获取ProcessRecord"><a href="#获取ProcessRecord" class="headerlink" title="获取ProcessRecord"></a>获取ProcessRecord</h2><p>我们看一下这个方法是怎么获取<code>ProcessRecord</code>的，我们先回顾一下之前在<code>startProcessLocked</code>方法的最后，会使用同步或异步的方式启动进程，最终两者都会调用<code>startProcess</code>和<code>handleProcessStartedLocked</code>方法</p>
<h3 id="同步启动进程"><a href="#同步启动进程" class="headerlink" title="同步启动进程"></a>同步启动进程</h3><p>我们回顾一下之前讲到的<code>ActivityManagerInternal.startProcess</code>方法，可以发现它内部使用了<code>synchronized (ActivityManagerService.this)</code>加锁，而<code>AMS.attachApplication</code>方法同样也使用了<code>AMS</code>实例对象加了锁，所以在同步启动进程的情况下，必然会先执行<code>handleProcessStartedLocked</code>方法，再执行<code>attachApplication</code>方法，根据之前所分析的，<code>handleProcessStartedLocked</code>方法会将<code>ProcessRecord</code>存到PidMap中，然后<code>attachApplication</code>方法又会从PidMap中去取，此时取出的<code>ProcessRecord</code>必然不为<code>null</code></p>
<h3 id="异步启动进程"><a href="#异步启动进程" class="headerlink" title="异步启动进程"></a>异步启动进程</h3><p>在异步启动进程的情况下，是通过<code>Handler</code>将启动进程的工作插入到任务队列中，这个任务的执行是不在锁的作用域范围内的，在这个任务内没有对<code>startProcess</code>方法加锁，只对<code>handleProcessStartedLocked</code>方法加了锁，所以这里会有两种情况：</p>
<ul>
<li><p>先执行<code>handleProcessStartedLocked</code>方法，再执行<code>attachApplication</code>方法</p>
<p>  这种情况和同步启动进程的执行顺序是一样的，<code>ProcessRecord</code>获取方式也相同</p>
</li>
<li><p>先执行<code>attachApplication</code>方法，再执行<code>handleProcessStartedLocked</code>方法</p>
<p>  这种情况下，PidMap中取不到相应的<code>ProcessRecord</code>，此时<code>ProcessList.mPendingStarts</code>中还没有将<code>ProcessRecord</code>移除，所以会从<code>mPendingStarts</code>这个启动列表中取出<code>ProcessRecord</code>，然后再调用<code>handleProcessStartedLocked</code>方法，等到<code>attachApplication</code>方法走完，锁释放后，在进入到外部的<code>handleProcessStartedLocked</code>重载方法，这个方法会先判断<code>mPendingStarts</code>中是否还存在对应的<code>ProcessRecord</code>，如果不存在，便会直接返回，保证<code>handleProcessStartedLocked</code>方法只执行一次</p>
</li>
</ul>
<h1 id="ApplicationThread-bindApplication"><a href="#ApplicationThread-bindApplication" class="headerlink" title="ApplicationThread.bindApplication"></a>ApplicationThread.bindApplication</h1><p>接着，我们继续看重点方法<code>ApplicationThread.bindApplication</code></p>
<p><code>ApplicationThread</code>是<code>ActivityThread</code>的一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProviderInfoList providerList, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">        String buildSerial, AutofillOptions autofillOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentCaptureOptions contentCaptureOptions, <span class="keyword">long</span>[] disabledCompatChanges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (services != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Setup the service cache in the ServiceManager</span></span><br><span class="line">        <span class="comment">//初始化通用系统服务缓存</span></span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providerList.getList();</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    data.buildSerial = buildSerial;</span><br><span class="line">    data.autofillOptions = autofillOptions;</span><br><span class="line">    data.contentCaptureOptions = contentCaptureOptions;</span><br><span class="line">    data.disabledCompatChanges = disabledCompatChanges;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，只是将参数包装成一个<code>AppBindData</code>，然后通过<code>Handler</code>发送消息处理，根据消息的类型，最终会调用<code>ActivityThread.handleBindApplication</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Register the UI Thread as a sensitive thread to the runtime.</span></span><br><span class="line">    <span class="comment">//将UI线程注册成JIT敏感线程</span></span><br><span class="line">    VMRuntime.registerSensitiveThread();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    ... <span class="comment">//性能分析相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send up app name; do this *before* waiting for debugger</span></span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName,</span><br><span class="line">                                            data.appInfo.packageName,</span><br><span class="line">                                            UserHandle.myUserId());</span><br><span class="line">    VMRuntime.setProcessPackageName(data.appInfo.packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass data directory path to ART. This is used for caching information and</span></span><br><span class="line">    <span class="comment">// should be set before any application code is loaded.</span></span><br><span class="line">    <span class="comment">//设置进程数据目录</span></span><br><span class="line">    VMRuntime.setProcessDataDirectory(data.appInfo.dataDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性能分析相关</span></span><br><span class="line">    <span class="keyword">if</span> (mProfiler.profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the app is Honeycomb MR1 or earlier, switch its AsyncTask</span></span><br><span class="line">    <span class="comment">// implementation to use the pool executor.  Normally, we use the</span></span><br><span class="line">    <span class="comment">// serialized executor as the default. This has to happen in the</span></span><br><span class="line">    <span class="comment">// main thread so the main looper is set right.</span></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion小于等于 3.1 (12) 时，AsyncTask使用线程池实现</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the util.*Array classes maintain "undefined" for apps targeting Pie or earlier.</span></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion大于等于 10 (29) 时，针对Android SDK提供的容器（SparseArray等）</span></span><br><span class="line">    <span class="comment">//如果index越界，会主动抛ArrayIndexOutOfBoundsException异常</span></span><br><span class="line">    <span class="comment">//（之前数组越界的行为未被定义）</span></span><br><span class="line">    UtilConfig.setThrowExceptionForUpperArrayOutOfBounds(</span><br><span class="line">            data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.Q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion大于等于 5.0 (21) 时，回收正在使用的Message会抛出异常</span></span><br><span class="line">    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prior to P, internal calls to decode Bitmaps used BitmapFactory,</span></span><br><span class="line">    <span class="comment">// which may scale up to account for density. In P, we switched to</span></span><br><span class="line">    <span class="comment">// ImageDecoder, which skips the upscale to save memory. ImageDecoder</span></span><br><span class="line">    <span class="comment">// needs to still scale up in older apps, in case they rely on the</span></span><br><span class="line">    <span class="comment">// size of the Bitmap without considering its density.</span></span><br><span class="line">    ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Before spawning a new process, reset the time zone to be the system time zone.</span></span><br><span class="line"><span class="comment">    * This needs to be done because the system time zone could have changed after the</span></span><br><span class="line"><span class="comment">    * the spawning of this process. Without doing this this process would have the incorrect</span></span><br><span class="line"><span class="comment">    * system time zone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Set the LocaleList. This may change once we create the App Context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Configuration</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Update the system configuration since its preloaded and might not</span></span><br><span class="line"><span class="comment">        * reflect configuration changes. The configuration object passed</span></span><br><span class="line"><span class="comment">        * in AppBindData can be safely assumed to be up to date</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">        mCurDefaultDisplayDpi = data.config.densityDpi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This calls mResourcesManager so keep it within the synchronized block.</span></span><br><span class="line">        applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadedApk</span></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性能分析器代理JVM（JVMTI）</span></span><br><span class="line">    <span class="keyword">if</span> (agent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAttachAgent(agent, data.info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Switch this process to density compatibility mode if needed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//在manifest，supports-screens标签中设置了android:anyDensity</span></span><br><span class="line">    <span class="comment">//详见：https://developer.android.com/guide/topics/manifest/supports-screens-element#any</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES)</span><br><span class="line">            == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//指示App包含用于适应任何屏幕密度的资源</span></span><br><span class="line">        mDensityCompatMode = <span class="keyword">true</span>;</span><br><span class="line">        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置默认密度</span></span><br><span class="line">    updateDefaultDensity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 12/24 小时时间制 */</span></span><br><span class="line">    <span class="keyword">final</span> String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);</span><br><span class="line">    Boolean is24Hr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (use24HourSetting != <span class="keyword">null</span>) &#123;</span><br><span class="line">        is24Hr = <span class="string">"24"</span>.equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// null : use locale default for 12/24 hour formatting,</span></span><br><span class="line">    <span class="comment">// false : use 12 hour format,</span></span><br><span class="line">    <span class="comment">// true : use 24 hour format.</span></span><br><span class="line">    DateFormat.set24HourTimePref(is24Hr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新view debug属性sDebugViewAttributes</span></span><br><span class="line">    <span class="comment">//设置了这个属性，View将会保存它本身的属性</span></span><br><span class="line">    <span class="comment">//和Layout Inspector相关</span></span><br><span class="line">    updateDebugViewAttributeState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化默认线程策略</span></span><br><span class="line">    StrictMode.initThreadDefaults(data.appInfo);</span><br><span class="line">    <span class="comment">//初始化默认VM策略</span></span><br><span class="line">    StrictMode.initVmDefaults(data.appInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug模式</span></span><br><span class="line">    <span class="keyword">if</span> (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) &#123;</span><br><span class="line">        <span class="comment">// XXX should have option to change the port.</span></span><br><span class="line">        Debug.changeDebugPort(<span class="number">8100</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                    + <span class="string">" is waiting for the debugger on port 8100..."</span>);</span><br><span class="line"></span><br><span class="line">            IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Debug.waitForDebugger();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                    + <span class="string">" can be debugged on port 8100..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow binder tracing, and application-generated systrace messages if we're profileable.</span></span><br><span class="line">    <span class="comment">//性能分析模式</span></span><br><span class="line">    <span class="keyword">boolean</span> isAppProfileable = data.appInfo.isProfileableByShell();</span><br><span class="line">    <span class="comment">//允许应用程序跟踪</span></span><br><span class="line">    Trace.setAppTracingAllowed(isAppProfileable);</span><br><span class="line">    <span class="keyword">if</span> ((isAppProfileable || Build.IS_DEBUGGABLE) &amp;&amp; data.enableBinderTracking) &#123;</span><br><span class="line">        Binder.enableTracing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize heap profiling.</span></span><br><span class="line">    <span class="comment">//初始化堆分析</span></span><br><span class="line">    <span class="keyword">if</span> (isAppProfileable || Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">        nInitZygoteChildHeapProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow renderer debugging features if we're debuggable.</span></span><br><span class="line">    <span class="keyword">boolean</span> isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开启硬件加速调试功能</span></span><br><span class="line">    HardwareRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE);</span><br><span class="line">    HardwareRenderer.setPackageName(data.appInfo.packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the default http proxy in this process for the reasons we set the time zone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//设置默认HTTP代理</span></span><br><span class="line">    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// In pre-boot mode (doing initial launch to collect password), not</span></span><br><span class="line">        <span class="comment">// all system is up.  This includes the connectivity service, so don't</span></span><br><span class="line">        <span class="comment">// crash if we can't get it.</span></span><br><span class="line">        <span class="keyword">final</span> IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(<span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instrumentation info affects the class loader, so load it before</span></span><br><span class="line">    <span class="comment">// setting up the app context.</span></span><br><span class="line">    <span class="comment">//准备自动化测试信息</span></span><br><span class="line">    <span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">    <span class="keyword">if</span> (data.instrumentationName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ii = <span class="keyword">new</span> ApplicationPackageManager(</span><br><span class="line">                    <span class="keyword">null</span>, getPackageManager(), getPermissionManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to find instrumentation info for: "</span> + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warn of potential ABI mismatches.</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ii = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Context</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    <span class="comment">//更新区域列表</span></span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldMask = StrictMode.allowThreadDiskWritesMask();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setupGraphicsSupport(appContext);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            StrictMode.setThreadPolicyMask(oldMask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HardwareRenderer.setIsolatedProcess(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the Network Security Config Provider. This must happen before the application</span></span><br><span class="line">    <span class="comment">// code is loaded to prevent issues with instances of TLS objects being created before</span></span><br><span class="line">    <span class="comment">// the provider is installed.</span></span><br><span class="line">    <span class="comment">//网络安全设置</span></span><br><span class="line">    NetworkSecurityConfigProvider.install(appContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue loading instrumentation.</span></span><br><span class="line">    <span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123; <span class="comment">//如果设置了自动化测试，实例化指定的自动化测试类</span></span><br><span class="line">        ApplicationInfo instrApp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instrApp = getPackageManager().getApplicationInfo(ii.packageName, <span class="number">0</span>,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            instrApp = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instrApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instrApp = <span class="keyword">new</span> ApplicationInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">final</span> LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The test context's op package name == the target app's op package name, because</span></span><br><span class="line">        <span class="comment">// the app ops manager checks the op package name against the real calling UID,</span></span><br><span class="line">        <span class="comment">// which is what the target package name is associated with.</span></span><br><span class="line">        <span class="keyword">final</span> ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi,</span><br><span class="line">                appContext.getOpPackageName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate instrumentation "</span></span><br><span class="line">                + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ComponentName component = <span class="keyword">new</span> ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(<span class="keyword">this</span>, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfiler.profileFile != <span class="keyword">null</span> &amp;&amp; !ii.handleProfiling</span><br><span class="line">                &amp;&amp; mProfiler.profileFd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mProfiler.handlingProfiling = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(mProfiler.profileFile);</span><br><span class="line">            file.getParentFile().mkdirs();</span><br><span class="line">            Debug.startMethodTracing(file.toString(), <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//直接实例化Instrumentation</span></span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">        mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整应用可用内存上限</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != <span class="number">0</span>) &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Small heap, clamp to the current growth limit and let the heap release</span></span><br><span class="line">        <span class="comment">// pages after the growth limit to the non growth limit capacity. b/18387825</span></span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow disk access during application and provider setup. This could</span></span><br><span class="line">    <span class="comment">// block processing ordered broadcasts, but later processing would</span></span><br><span class="line">    <span class="comment">// probably end up doing the same disk access.</span></span><br><span class="line">    Application app;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">        <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">        <span class="comment">//设置自动填充功能</span></span><br><span class="line">        app.setAutofillOptions(data.autofillOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate Content Capture options</span></span><br><span class="line">        <span class="comment">//设置内容捕获功能</span></span><br><span class="line">        app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">        <span class="comment">// app's custom Application class</span></span><br><span class="line">        <span class="comment">//在非受限模式下启动ContentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">        <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">        <span class="comment">//执行onCreate方法（默认Instrumentation实现为空方法）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行Application的onCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">        <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">        <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preload fonts resources</span></span><br><span class="line">    <span class="comment">//预加载字体资源</span></span><br><span class="line">    FontsContract.setApplicationContextForResources(appContext);</span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ApplicationInfo info =</span><br><span class="line">                    getPackageManager().getApplicationInfo(</span><br><span class="line">                            data.appInfo.packageName,</span><br><span class="line">                            PackageManager.GET_META_DATA <span class="comment">/*flags*/</span>,</span><br><span class="line">                            UserHandle.myUserId());</span><br><span class="line">            <span class="keyword">if</span> (info.metaData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> preloadedFontsResource = info.metaData.getInt(</span><br><span class="line">                        ApplicationInfo.METADATA_PRELOADED_FONTS, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (preloadedFontsResource != <span class="number">0</span>) &#123;</span><br><span class="line">                    data.info.getResources().preloadFonts(preloadedFontsResource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很重要，我们先过一下几个重点部分，然后再按着主线继续往下研究：</p>
<ul>
<li><p><code>Debug</code>、<code>Profiler</code>、<code>Layout Inspector</code></p>
<p><code>Android</code>应用开发的同学对这三样肯定不陌生，在<code>Android Studio</code>中我们可以对App进行调试，性能分析和布局检查，在这个方法中，我们可以找到与这三样相关的一些代码</p>
</li>
<li><p>获取<code>LoadedApk</code></p>
<p><code>LoadedApk</code>是<code>Apk</code>文件在内存中的表示，包含了<code>Apk</code>文件中的代码、资源、组件、<code>manifest</code>等信息</p>
</li>
<li><p>创建<code>Context</code></p>
<p>这里通过<code>ActivityThread</code>和<code>LoadedApk</code>创建出了一个<code>ContextImpl</code></p>
</li>
<li><p>实例化<code>Instrumentation</code></p>
<p>这里和自动化测试相关，如果设置了自动化测试，实例化指定的自动化测试类，否则实例化默认的<code>Instrumentation</code></p>
</li>
<li><p>创建<code>Application</code></p>
<p>这里根据<code>LoadedApk</code>创建出相应的<code>Application</code>，需要注意，这里创建的<code>Application</code>并不与上面创建出的<code>ContextImpl</code>绑定，而是在创建<code>Application</code>的过程中，以同样的参数重新创建了一个<code>ContextImpl</code>，然后调用<code>attachBaseContext</code>方法绑定它</p>
</li>
<li><p>设置<code>HTTP</code>代理</p>
<p>App在启动过程中设置<code>HTTP</code>代理，所以我们在开发过程中使用代理抓包等时候需要注意，设置了代理后需要重启App才会生效</p>
</li>
<li><p>启动<code>ContentProvider</code></p>
<p><code>ContentProvider</code>的启动过程以后会新开文章进行分析，这里只需要知道<code>ContentProvider</code>启动的入口在这就行了</p>
</li>
<li><p>执行<code>Application</code>的<code>onCreate</code>方法</p>
<p>当创建完<code>Application</code>，执行<code>attachBaseContext</code>方法后，便会调用<code>onCreate</code>方法</p>
</li>
</ul>
<p>我们拣重点来看，首先是<code>Application</code>的创建过程</p>
<h2 id="LoadedApk-makeApplication"><a href="#LoadedApk-makeApplication" class="headerlink" title="LoadedApk.makeApplication"></a>LoadedApk.makeApplication</h2><p>在上文的方法中，调用了<code>data.info.makeApplication</code>方法创建<code>Application</code>，其中<code>data.info</code>为<code>LoadedApk</code>类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果之前创建过了就可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Application类名（App可以自定义Application这个应该所有开发都知道吧）</span></span><br><span class="line">    <span class="comment">//对应AndroidManifest中application标签下的android:name属性</span></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    <span class="comment">//没有设置自定义Application或强制使用默认Application的情况下，使用默认Application</span></span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化ContextClassLoader</span></span><br><span class="line">        <span class="keyword">final</span> java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rewrite the R 'constants' for all library apks.</span></span><br><span class="line">        <span class="comment">//Android共享库资源ID动态映射</span></span><br><span class="line">        SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers(</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = packageIdentifiers.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = packageIdentifiers.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0x01</span> || id == <span class="number">0x7f</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rewriteRValues(cl, packageIdentifiers.valueAt(i), id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Context</span></span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// The network security config needs to be aware of multiple</span></span><br><span class="line">        <span class="comment">// applications in the same process to handle discrepancies</span></span><br><span class="line">        <span class="comment">//网络安全设置</span></span><br><span class="line">        NetworkSecurityConfigProvider.handleNewApplication(appContext);</span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入Application列表中（多个App可以运行在同一个进程中）</span></span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instrumentation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用Application的OnCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法首先尝试取成员变量<code>mApplication</code>，如果不为<code>null</code>，说明曾创建过，直接返回就可以了</p>
<p>然后再去获取<code>Application</code>类名，默认为<code>android.app.Application</code>，开发可以通过设置<code>AndroidManifest</code>中<code>application</code>标签下的<code>android:name</code>属性来选择创建自定义的<code>Application</code></p>
<p>然后对共享库资源ID做动态映射，关于这部分感兴趣的同学可以去搜索<code>Android Dynamic Reference</code></p>
<p>接着创建出<code>ContextImpl</code>作为<code>Application</code>的<code>BaseContext</code>，<code>Application</code>继承自<code>ContextWrapper</code>，而<code>ContextWrapper</code>又继承自<code>Context</code>，<code>ContextWrapper</code>是对<code>Context</code>的包装，里面有一个<code>mBase</code>成员变量，调用任何方法实际上都是调用<code>mBase</code>这个实例的方法，在<code>Application</code>创建后会调用<code>attachBaseContext</code>将刚刚创建出来的<code>ContextImpl</code>赋值给<code>mBase</code>成员变量，所以调用<code>Application</code>中的任何<code>Context</code>方法，实际上最终都是调用<code>ContextImpl</code>的方法</p>
<p>然后创建<code>Application</code>，并将其设置成<code>ContextImpl</code>的<code>OuterContext</code></p>
<p>最后将创建好的<code>Application</code>设置给成员变量<code>mApplication</code>，方便以后获取，然后将其再添加到<code>mActivityThread.mAllApplications</code>列表中，返回</p>
<h3 id="ContextImpl-createAppContext"><a href="#ContextImpl-createAppContext" class="headerlink" title="ContextImpl.createAppContext"></a>ContextImpl.createAppContext</h3><p>我们简单看一下<code>ContextImpl</code>的创建，对于不同的组件，创建<code>ContextImpl</code>对象的方法不同，比如说<code>Activity</code>的<code>Context</code>是通过<code>createActivityContext</code>方法创建的，我们这里是通过<code>createAppContext</code>创建<code>Application</code>的<code>Context</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAppContext(mainThread, packageInfo, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String opPackageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</span><br><span class="line">    ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo,</span><br><span class="line">        ContextParams.EMPTY, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, opPackageName);</span><br><span class="line">    context.setResources(packageInfo.getResources());</span><br><span class="line">    <span class="comment">//检查android.permission.STATUS_BAR_SERVICE权限</span></span><br><span class="line">    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI</span><br><span class="line">            : CONTEXT_TYPE_NON_UI;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看看就好，我们的重点不在这里，这个方法实例化了一个<code>ContextImpl</code>对象，然后通过<code>ResourcesManager</code>获得<code>Apk</code>的<code>Resource</code>，将其设置到<code>ContextImpl</code>中</p>
<h3 id="Instrumentation-newApplication"><a href="#Instrumentation-newApplication" class="headerlink" title="Instrumentation.newApplication"></a>Instrumentation.newApplication</h3><p>接着我们来看一下<code>Application</code>是怎么创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = getFactory(context.getPackageName())</span><br><span class="line">            .instantiateApplication(cl, className);</span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>getFactory</code>方法返回的是一个<code>AppComponentFactory</code>对象，这个类是在<code>Android 9</code>之后加入的，它包括一个实例化<code>ClassLoader</code>的方法，一个实例化<code>Application</code>的方法和四个实例化四大组件的方法</p>
<p>我们可以在<code>AndroidManifest</code>中设置<code>application</code>标签的<code>android:appComponentFactory</code>属性，将其设置成我们自定义的<code>AppComponentFactory</code>，从而进行一些监控或别的操作</p>
<p>我们看一下<code>AppComponentFactory</code>的默认实现是怎样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Application <span class="title">instantiateApplication</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Application) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到非常简单，就是通过<code>className</code>反射实例化出一个<code>Application</code></p>
<p>接着我们回到<code>newApplication</code>方法中，我们对新创建的<code>Application</code>调用了<code>attach</code>方法去绑定<code>ContextImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>attachBaseContext</code>调用的是父类<code>ContextWrapper</code>中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，就是将<code>ContextImpl</code>赋值给<code>ContextWrapper</code>中的<code>mBase</code>赋值，这样后面对<code>Application</code>调用<code>Context</code>的方法，实际上就是代理给这个<code>mBase</code>去执行了</p>
<p>到这一步位置，<code>Application</code>就创建完成了，接下来在<code>ActivityThread.handleBindApplication</code>方法中，还有一步重要操作，就是调用<code>Application</code>的<code>onCreate</code>方法</p>
<p>这里是借助了<code>Instrumentation.callApplicationOnCreate</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是简简单单直接调用了<code>Application</code>的<code>onCreate</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里为止，整个<code>Application</code>的工作都做完了，接下来还剩检查并启动<code>Activity</code>、<code>Service</code>和<code>BroadcastReceiver</code>，这些内容就放到下一篇再讲吧</p>
<p>话说回来有点惭愧，这篇文章距离上一篇间隔了三个月，最近在忙一些别的项目，这篇文章断断续续写了一个多月才憋出来，感谢大家的支持，在这里我厚着脸皮<strong>求点赞求收藏</strong>，大家的支持就是我创作的动力</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/09/14/android/compile/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV+FFmpeg+x264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/">Android交叉编译OpenCV+FFmpeg+x264的艰难历程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">交叉编译</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/NDK/">NDK</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%BC%96%E8%AF%91/">编译</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">Android交叉编译</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NDK/">NDK</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/OpenCV/">OpenCV</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/FFmpeg/">FFmpeg</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/x264/">x264</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你没有兴趣看完本文，只想获得可编译的代码或编译后的产物，可以直接点击下面的链接，跟随步骤编译代码或直接下载我编译好的产物</p>
<p><strong>注：编译顺序要按照 x264 -&gt; FFmpeg -&gt; OpenCV 这样来</strong></p>
<p><a href="https://github.com/dreamgyf/x264/releases/tag/v0.164_compilable" target="_blank" rel="noopener">x264</a></p>
<p><a href="https://github.com/dreamgyf/FFmpeg/releases/tag/v5.0_compilable" target="_blank" rel="noopener">FFmpeg</a></p>
<p><a href="https://github.com/dreamgyf/opencv/releases/tag/v4.6.0_compilable" target="_blank" rel="noopener">OpenCV</a></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在做一个视频生成的app，使用<code>OpenCV</code>库实现，用的是C语言，一开始我是在<code>mac_x86</code>上书写代码，<code>fourcc</code>视频编码器选择的是<code>mp4v</code>，视频输出一切正常，然后当我将代码移植到<code>Android</code>上时发现，从<code>OpenCV</code>官网下载的<code>so</code>库它不支持编码<code>mp4v</code>格式，只能编码成<code>mjpg</code>格式，后缀名为<code>avi</code>，尴尬的是<code>Android</code>原生又不支持播放这种格式的视频，所以要想办法让<code>OpenCV</code>支持编码<code>mp4v</code>或<code>h264</code>等格式</p>
<p>我在网上搜索了一下为什么<code>OpenCV</code>默认不支持<code>h264</code>格式，得知<code>OpenCV</code>默认使用<code>FFmpeg</code>做视频处理，<code>FFmpeg</code>使用的是<code>LGPL</code>协议，而<code>x264</code>使用的是<code>GPL</code>协议，<code>GPL</code>协议具有传染性，如果代码中使用了<code>GPL</code>协议的软件，则要求你的代码也必须开源。我猜测是因为这个原因，<code>FFmpeg</code>默认不使用<code>GPL</code>协议的软件，避免产生一些不必要的问题和纠纷，如果想要使用<code>GPL</code>协议的软件，则需要在编译的时候加上<code>--enable-gpl</code>选项</p>
<p>基于此上原因，我开启了我艰难的编译之路</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇文章只针对<code>Linux</code>系统编译，其他系统不保证可以编译通过</p>
<p>本篇文章使用的<code>NDK</code>版本为<code>21.4.7075529</code>，不同的版本可能会有些差别，需要自行调整</p>
<p>本人对<code>c/c++</code>编译这块并不是很了解，很多东西也是边学习边尝试的，如果有什么错误的话也恳请大佬们指正，谢谢</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备一台<code>Linux</code>系统的电脑或使用虚拟机，安装一些最基本的编译工具（<code>make</code>、<code>cmake</code>等），我使用的是<code>Ubuntu</code>系统，强烈建议在安装的时候选择完整安装，这样这些编译工具应该都会跟随系统自动安装好</p>
<p><code>Android</code>交叉编译肯定是需要<code>NDK</code>的，我使用的是<code>21.4.7075529</code>版本，<code>r19</code>以上版本的NDK都是直接自带了工具链，而<code>r19</code>之前的版本则需要先生成工具链，具体可以参考<a href="https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn" target="_blank" rel="noopener">独立工具链（已弃用）</a>这篇文档</p>
<h1 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h1><p>既然需要依赖<code>x264</code>，那我们肯定是先要编译<code>x264</code>库，各位可以<code>clone</code>我准备好的<code>tag</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v0.164_compilable https://github.com/dreamgyf/x264.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>x264</code>镜像仓库的<code>stable</code>分支切出的，版本为<code>0.164</code>。想知道<code>x264</code>版本的话，可以运行其目录下的<code>version.sh</code>脚本，它会输出三串数字，前面的<code>164</code>是在<code>x264.h</code>中定义的<code>X264_BUILD</code>，第二个<code>3095+4</code>表示<code>master</code>分支的提交数 + <code>master</code>分支到HEAD的提交数，最后的一串数字表示当前分支最新的<code>commit id</code></p>
<p>在构建编译脚本之前，我们先要看看这个库提供了哪些编译选项，我们可以看到在<code>x264</code>根目录下有一个<code>configure</code>文件，这是一个脚本文件，大多数库都提供了这个脚本，用来负责生成<code>Makefile</code>，准备好构建环境，我们可以通过下面这个命令获取帮助文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --help &gt; help.txt</span><br></pre></td></tr></table></figure>

<p>可以看到，里面提供了一些编译选项及其描述，我们可以根据这些选项和描述构建编译脚本</p>
<p>先看一下我写好的脚本吧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang</span><br><span class="line">    export CFLAGS="-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security  -O0 -DNDEBUG  -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;"</span><br><span class="line"></span><br><span class="line">    ../../configure \</span><br><span class="line">        --host=$&#123;TRIPLE&#125; \</span><br><span class="line">        --prefix=$PREFIX \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --enable-pic \</span><br><span class="line">        --disable-lavf \</span><br><span class="line">        --sysroot=$TOOLCHAIN/sysroot</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这也是我其他库编译脚本的基本结构，首先需要<code>ANDROID_NDK</code>环境变量用来确定<code>NDK</code>的位置</p>
<p><code>OUTPUT_DIR</code>为编译的输出路径，我这里命名为<code>_output_</code>，防止和源码本身的目录重名</p>
<p><code>API</code>为最低支持的<code>Android API</code>版本，我这里写的<code>21</code>，也就是<code>Android 5.0</code></p>
<p><code>TOOLCHAIN</code>为交叉编译工具链的路径，对于<code>r19</code>之前的<code>NDK</code>，需要将其改为你生成出来的工具链的路径，<code>r19</code>之后不需要改动</p>
<p>我这里定义了一个<code>build</code>函数，通过输入的<code>ABI</code>编译出对应架构的产物。<code>ABI</code>总共有四种：<code>armeabi-v7a</code>，<code>arm64-v8a</code>，<code>x86</code>，<code>x86-64</code>，这个决定你的<code>App</code>能在哪些平台架构上运行</p>
<p>这里，我通过不同的<code>ABI</code>定义了不同的<code>TRIPLE</code>变量，这是遵循了<code>NDK</code>工具链的命名规则，可以在 <a href="https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn" target="_blank" rel="noopener">将 NDK 与其他构建系统配合使用</a> 这篇文档中找到</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_TRIPLE.png" alt="TRIPLE"></p>
<p>在<code>$TOOLCHAIN/bin</code>目录下，我们也能发现这种命名方式</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_TRIPLE2.png" alt="TRIPLE"></p>
<p>我们需要根据其命名规则，指定相应的编译器，设置相应的<code>host</code>，<code>target</code></p>
<p>关于<code>build</code>、<code>host</code>和<code>target</code>的含义可以参阅 <a href="https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html" target="_blank" rel="noopener">Cross-Compilation</a> 这篇文档</p>
<ul>
<li><p><code>build</code>: 编译该库所使用的平台，不设置的话，编译器会自动推测所在平台</p>
</li>
<li><p><code>host</code>: 编译出的库要运行在哪个平台上，不设置的话，默认为<code>build</code>值，但这样也就不再是交叉编译了</p>
</li>
<li><p><code>target</code>: 该库所处理的目标平台，不设置的话，默认为<code>host</code>值</p>
</li>
</ul>
<p>多数<code>UNIX</code>平台会通过<code>CC</code>调用C语言编译器，而<code>CFLAGS</code>则是C语言编译器的编译选项，根据我们上文所说的命名规则可以发现，工具链中C语言编译器的命名规则为<code>${TRIPLE}${API}-clang</code>，假设我们要编译<code>arm64-v8a ABI</code>，<code>API 21</code>的库，则需要指定<code>CC</code>为<code>aarch64-linux-android21-clang</code></p>
<p>至于<code>CFLAGS</code>这里就不多说了，可以自行查阅 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html" target="_blank" rel="noopener">Clang编译器参数手册</a> ，这里需要注意的是，必须要指定<code>--gcc-toolchain</code>和<code>--target</code>，否则编译会报错</p>
<p>然后就是<code>configure</code>的选项了，这里必须指定<code>--host</code>和<code>--sysroot</code>，<code>sysroot</code>表示使用这个值作为编译的头文件和库文件的查找目录，该目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sysroot</span><br><span class="line">└── usr</span><br><span class="line">    ├── include</span><br><span class="line">    └── lib</span><br><span class="line">        ├── aarch64-linux-android</span><br><span class="line">        ├── arm-linux-androideabi</span><br><span class="line">        ├── i686-linux-android</span><br><span class="line">        └── x86_64-linux-android</span><br></pre></td></tr></table></figure>

<p><code>--prefix</code>为编译后的安装路径，也就是编译产物的输出路径</p>
<p><code>--enable-static</code>和<code>--enable-shared</code>选项表示生成静态库和动态库，大家可以根据情况自行选择</p>
<p><code>nproc</code>是<code>Linux</code>下的一个命令，表示当前进程可用的<code>CPU</code>核数，一般<code>make</code>使用线程数为<code>CPU</code>核数就可以了，如果编译产生问题，可以尝试调小这个值</p>
<p>到这里基本上整个构建脚本就分析完了，大家调整完编译选项后保存，就可以执行命令<code>./build.sh</code>开始编译了</p>
<h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1><p>然后我们开始编译FFmpeg</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v5.0_compilable https://github.com/dreamgyf/FFmpeg.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>FFmpeg</code>镜像仓库的<code>n5.0</code>分支切出的，版本为<code>5.0</code>。其实我一开始用的是<code>5.1</code>版本，但当我解决了各种问题编译<code>OpenCV</code>到一半时，提示我<code>FFmpeg</code>的一些符号找不到，然后我去查了一下<code>OpenCV</code>的 Change Log ，发现它的最新版本<code>4.6.0</code>刚刚支持<code>FFmpeg 5.0</code>版本，无奈切到<code>5.0</code>重新编译</p>
<p>还是一样，先看编译脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">ROOT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译出的x264库地址</span></span><br><span class="line">X264_ANDROID_DIR=/home/dreamgyf/compile/x264/_output_/product</span><br><span class="line"></span><br><span class="line">EXTRA_CONFIGURATIONS="--disable-stripping \</span><br><span class="line">    --disable-ffmpeg \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-appkit \</span><br><span class="line">    --disable-avfoundation \</span><br><span class="line">    --disable-coreimage \</span><br><span class="line">    --disable-amf \</span><br><span class="line">    --disable-audiotoolbox \</span><br><span class="line">    --disable-cuda-llvm \</span><br><span class="line">    --disable-cuvid \</span><br><span class="line">    --disable-d3d11va \</span><br><span class="line">    --disable-dxva2 \</span><br><span class="line">    --disable-ffnvcodec \</span><br><span class="line">    --disable-nvdec \</span><br><span class="line">    --disable-nvenc \</span><br><span class="line">    --disable-vdpau \</span><br><span class="line">    --disable-videotoolbox"</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang</span><br><span class="line">    export CFLAGS="-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security  -O0 -DNDEBUG  -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;"</span><br><span class="line"></span><br><span class="line">    ../../configure \</span><br><span class="line">        --prefix=$PREFIX \</span><br><span class="line">        --enable-cross-compile \</span><br><span class="line">        --sysroot=$TOOLCHAIN/sysroot \</span><br><span class="line">        --cc=$CC \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --disable-asm \</span><br><span class="line">        --enable-gpl \</span><br><span class="line">        --enable-libx264 \</span><br><span class="line">        --extra-cflags="-I$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/include" \</span><br><span class="line">        --extra-ldflags="-L$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib" \</span><br><span class="line">        $EXTRA_CONFIGURATIONS</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd $PREFIX</span><br><span class="line">    `$ROOT_PATH/ffmpeg-config-gen.sh $&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib/libx264.a`</span><br><span class="line">    cd $OUTPUT_PATH</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这个脚本和<code>x264</code>的编译脚本基本相同，由于我们需要依赖<code>x264</code>库，所以我们要使刚刚编译出来的<code>x264</code>产物参与<code>FFmpeg</code>的编译，为此，需要将<code>X264_ANDROID_DIR</code>改成自己编译出来的<code>x264</code>产物路径</p>
<p>在<code>configure</code>选项中，我们需要<code>--enable-cross-compile</code>选项表示开启交叉编译，我们这里需要设置<code>--cc</code>选择C语言编译器，否则编译时会使用系统默认的编译器，<code>--disable-asm</code>选项我测试是必须要带上的，否则编译会报错，然后就是<code>--enable-libx264</code>开启<code>x264</code>依赖了，根据我在起因中说到的开源协议问题，所以<code>--enable-gpl</code>选项也要开启，最后需要指定<code>x264</code>的头文件和库文件目录，分别使用<code>--extra-cflags</code>和<code>--extra-ldflags</code>加上对应的参数</p>
<p>这里提一下，编译器会优先从<code>-I -L</code>两个参数指定的目录中去查找头文件和库文件，如果没找到的话再会从<code>sysroot</code>目录中查找</p>
<p>最后，我还写了一个<code>ffmpeg-config-gen.sh</code>脚本，它的作用是生成<code>ffmpeg-config.cmake</code>文件，用来给<code>OpenCV</code>编译提供<code>FFmpeg</code>依赖查找，这个等我们后面讲到<code>OpenCV</code>依赖<code>FFmpeg</code>的处理时再说</p>
<p>和<code>x264</code>一样，大家调整完编译选项后保存，就可以执行命令<code>./build.sh</code>开始编译了</p>
<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><p>最后，我们开始编译<code>OpenCV</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v4.6.0_compilable https://github.com/dreamgyf/opencv.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>OpenCV</code>仓库的<code>4.6.0</code>分支切出的，版本为<code>4.6.0</code>，是目前的最新版本。其实前面两个库的编译都挺顺利的，最麻烦的问题都出在<code>OpenCV</code>这里</p>
<p>我们还是先看编译脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译出的ffmpeg库地址</span></span><br><span class="line">FFMPEG_ANDROID_DIR=/home/dreamgyf/compile/FFmpeg/_output_/product</span><br><span class="line"></span><br><span class="line">EXTRA_ATTRS="-DWITH_CUDA=OFF \</span><br><span class="line">    -DWITH_GTK=OFF \</span><br><span class="line">    -DWITH_1394=OFF \</span><br><span class="line">    -DWITH_GSTREAMER=OFF \</span><br><span class="line">    -DWITH_LIBV4L=OFF \</span><br><span class="line">    -DWITH_TIFF=OFF \</span><br><span class="line">    -DBUILD_OPENEXR=OFF \</span><br><span class="line">    -DWITH_OPENEXR=OFF \</span><br><span class="line">    -DBUILD_opencv_ocl=OFF \</span><br><span class="line">    -DWITH_OPENCL=OFF"</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">        TOOLCHAIN_NAME="arm-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    cmake ../.. \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=$PREFIX \</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \</span><br><span class="line">        -DANDROID_ABI=$ABI \</span><br><span class="line">        -DANDROID_NDK=$ANDROID_NDK \</span><br><span class="line">        -DANDROID_PLATFORM="android-$&#123;API&#125;" \</span><br><span class="line">        -DANDROID_LINKER_FLAGS="-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API" \</span><br><span class="line">        -DBUILD_ANDROID_PROJECTS=OFF \</span><br><span class="line">        -DBUILD_ANDROID_EXAMPLES=OFF \</span><br><span class="line">        -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS \</span><br><span class="line">        -DWITH_FFMPEG=ON \</span><br><span class="line">        -DOPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">        -DOPENCV_FFMPEG_USE_FIND_PACKAGE=ON \</span><br><span class="line">        -DFFMPEG_DIR=$&#123;FFMPEG_ANDROID_DIR&#125;/$&#123;ABI&#125; \</span><br><span class="line">        $EXTRA_ATTRS</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    echo "Select build static or shared libs:"</span><br><span class="line">    select type in "static" "shared"</span><br><span class="line">    do</span><br><span class="line">        if [[ $type == "static" ]]; then</span><br><span class="line">            BUILD_SHARED_LIBS=OFF</span><br><span class="line">        elif [[ $type == "shared" ]]; then</span><br><span class="line">            BUILD_SHARED_LIBS=ON</span><br><span class="line">        else</span><br><span class="line">            BUILD_SHARED_LIBS=OFF</span><br><span class="line">        fi</span><br><span class="line">        break</span><br><span class="line">    done</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>上面的准备工作和前面的几个脚本一样，不同的是，<code>OpenCV</code>并没有为我们准备<code>configure</code>脚本，所以这次我们使用<code>cmake</code>生成<code>Makefile</code>，再进行编译</p>
<p>既然使用<code>cmake</code>了，我们就可以不再像之前一样，自己指定编译器等工具链了，<code>NDK</code>为我们提供了交叉编译工具链<code>cmake</code>脚本<code>$ANDROID_NDK/build/cmake/android.toolchain.cmake</code>，我们只需要指定其为<code>CMAKE_TOOLCHAIN_FILE</code>，然后为其提供相关参数即可，具体的使用方式可以参考 <a href="https://developer.android.com/ndk/guides/cmake?hl=zh-cn" target="_blank" rel="noopener">CMake</a> 这篇文档。我们这里只需要提供最低限度的几个参数<code>ANDROID_ABI</code>、<code>ANDROID_NDK</code>、<code>ANDROID_PLATFORM</code>即可</p>
<p>如果需要编译<code>Android</code>示例工程的话，还需要在环境变量中设置<code>ANDROID_HOME</code>和<code>ANDROID_SDK</code>，我这里就直接使用<code>-DBUILD_ANDROID_PROJECTS=OFF</code>和<code>-DBUILD_ANDROID_EXAMPLES=OFF</code>将其关闭了</p>
<p>然后就是如何让<code>OpenCV</code>依赖我们编译的<code>FFmpeg</code>的问题了，到这一步我们就需要去它的<code>CMakeLists.txt</code>中看看它是怎样声明<code>FFmpeg</code>的了</p>
<p>打开<code>CMakeLists.txt</code>文件，搜索<code>FFMPEG</code>关键字，我们可以找到这一段代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WITH_FFMPEG <span class="keyword">OR</span> HAVE_FFMPEG)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN <span class="string">"YES (find_package)"</span>                       <span class="keyword">ELSE</span> <span class="string">"NO (find_package)"</span>)</span><br><span class="line">  <span class="keyword">elseif</span>(WIN32)</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN <span class="string">"YES (prebuilt binaries)"</span>                  <span class="keyword">ELSE</span> NO)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN YES <span class="keyword">ELSE</span> NO)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  status(<span class="string">"      avcodec:"</span>      FFMPEG_libavcodec_VERSION    THEN <span class="string">"YES ($&#123;FFMPEG_libavcodec_VERSION&#125;)"</span>    <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avformat:"</span>     FFMPEG_libavformat_VERSION   THEN <span class="string">"YES ($&#123;FFMPEG_libavformat_VERSION&#125;)"</span>   <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avutil:"</span>       FFMPEG_libavutil_VERSION     THEN <span class="string">"YES ($&#123;FFMPEG_libavutil_VERSION&#125;)"</span>     <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      swscale:"</span>      FFMPEG_libswscale_VERSION    THEN <span class="string">"YES ($&#123;FFMPEG_libswscale_VERSION&#125;)"</span>    <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avresample:"</span>   FFMPEG_libavresample_VERSION THEN <span class="string">"YES ($&#123;FFMPEG_libavresample_VERSION&#125;)"</span> <span class="keyword">ELSE</span> NO)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>我们可以发现，要想依赖<code>FFmpeg</code>，我们需要将<code>HAVE_FFMPEG</code>的值设为<code>true</code>，并且要指定<code>FFmpeg libs</code>的版本</p>
<p>我们再看到<code>OPENCV_FFMPEG_USE_FIND_PACKAGE</code>这个参数，表示通过<code>find_package</code>的方式寻找<code>FFmpeg</code>库</p>
<p>这里，我们其实有两种办法依赖<code>FFmpeg</code>库，一是通过<code>find_package</code>，二是通过<code>pkg-config</code>，我两种方式都尝试了后，觉得还是使用<code>find_package</code>这种方式比较容易，侵入性较小，使用<code>pkg-config</code>需要手动修改<code>OpenCV</code>检测<code>FFmpeg</code>的<code>cmake</code>文件源码，不优雅</p>
<p>接着我们去看<code>OpenCV</code>是如何检测<code>FFmpeg</code>是否存在的，这里我们需要找到<code>$OPENCV/modules/videoio/cmake/detect_ffmpeg.cmake</code>这个文件，在开头第一段代码中，我们就可以发现</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> HAVE_FFMPEG <span class="keyword">AND</span> OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"1"</span> <span class="keyword">OR</span> OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"ON"</span>)</span><br><span class="line">    <span class="keyword">set</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="string">"FFMPEG"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">find_package</span>(<span class="variable">$&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;</span>) <span class="comment"># Required components: AVCODEC AVFORMAT AVUTIL SWSCALE</span></span><br><span class="line">  <span class="keyword">if</span>(FFMPEG_FOUND <span class="keyword">OR</span> FFmpeg_FOUND)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>如果<code>OPENCV_FFMPEG_USE_FIND_PACKAGE</code>选项被打开，则会使用<code>find_package(FFMPEG)</code>去查找这个库</p>
<p><code>find_package(&lt;PackageName&gt;)</code>有两种模式，一种是<code>Module</code>模式，一种是<code>Config</code>模式</p>
<p>在<code>Module</code>模式中，<code>cmake</code>需要找到一个名为<code>Find&lt;PackageName&gt;.cmake</code>的文件，这个文件负责找到库所在路径，引入头文件和库文件。<code>cmake</code>会在两个地方查找这个文件，先是我们手动指定的<code>CMAKE_MODULE_PATH</code>目录，搜索不到再搜索<code>$CMAKE/share/cmake-&lt;version&gt;/Modules</code>目录</p>
<p>如果<code>Module</code>模式没找到相应文件，则会转为<code>Config</code>模式，在这个模式下，<code>cmake</code>需要找到<code>&lt;lowercasePackageName&gt;-config.cmake</code>或<code>&lt;PackageName&gt;Config.cmake</code>文件，通过这个文件找到库所在路径，引入头文件和库文件。<code>cmake</code>会优先在<code>&lt;PackageName&gt;_DIR</code>目录下搜索相应文件</p>
<p>关于<code>find_package</code>更详细的解释，可以去查看 <a href="https://cmake.org/cmake/help/latest/command/find_package.html" target="_blank" rel="noopener">官方文档</a></p>
<p>我这里选用了<code>Config</code>模式，再结合之前在<code>CMakeLists.txt</code>和<code>detect_ffmpeg.cmake</code>中的内容，我们可以得出结论：</p>
<p>我们需要在构建脚本中设置<code>WITH_FFMPEG=ON</code>，<code>OPENCV_FFMPEG_USE_FIND_PACKAGE=ON</code>，<code>FFMPEG_DIR</code>并且<code>FFMPEG_DIR</code>目录下需要有<code>ffmpeg-config.cmake</code>或<code>FFMPEGConfig.cmake</code>文件</p>
<p>这里就衔接了上文，我为什么要写一个<code>ffmpeg-config-gen.sh</code>脚本，脚本的内容很简单，我们直接看它生成出来的<code>ffmpeg-config.cmake</code>文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(FFMPEG_PATH <span class="string">"$&#123;CMAKE_CURRENT_LIST_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_EXEC_DIR <span class="string">"$&#123;FFMPEG_PATH&#125;/bin"</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBDIR <span class="string">"$&#123;FFMPEG_PATH&#125;/lib"</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_INCLUDE_DIRS <span class="string">"$&#123;FFMPEG_PATH&#125;/include"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBRARIES</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavformat.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavdevice.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavcodec.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavutil.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libswscale.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libswresample.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavfilter.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libpostproc.a</span><br><span class="line">    /home/dreamgyf/compile/x264/_output_/product/arm64-v8a/lib/libx264.a</span><br><span class="line">    z</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavformat_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavdevice_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavcodec_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavutil_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswscale_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswresample_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavfilter_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libpostproc_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavcodec_VERSION <span class="number">59.18</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavdevice_VERSION <span class="number">59.4</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavfilter_VERSION <span class="number">8.24</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavformat_VERSION <span class="number">59.16</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavutil_VERSION <span class="number">57.17</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libpostproc_VERSION <span class="number">56.3</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswresample_VERSION <span class="number">4.3</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswscale_VERSION <span class="number">6.4</span>.<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBS <span class="variable">$&#123;FFMPEG_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这里主要为<code>cmake</code>提供了三个变量</p>
<ul>
<li><p><code>FFMPEG_INCLUDE_DIRS</code>：提供头文件目录</p>
</li>
<li><p><code>FFMPEG_LIBRARIES</code>：提供库文件链接</p>
</li>
<li><p><code>FFMPEG_FOUND</code>：告诉<code>cmake</code>找到了<code>FFmpeg</code>库</p>
</li>
</ul>
<p>这里还有几个点要说，首先，<code>cmake</code>中的库文件链接顺序符合<code>gcc</code>链接顺序规则，所以说库的书写顺序也是有严格要求的，被依赖的库要放在依赖它的库的后面，正如这个文件，<code>FFmpeg</code>需要依赖<code>x264</code>，所以我需要将<code>x264</code>放在所有<code>FFmpeg</code>库的最后面</p>
<p><code>FFmpeg</code>需要依赖<code>zlib</code>库，所以我在后面增加了一个<code>z</code>表示依赖<code>zlib</code>库</p>
<p><code>FFmpeg</code>这些库的版本定义是从<code>$FFMPEG_PRODUCT/$ABI/lib/pkgconfig</code>目录下各个文件读出来的</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_pkgconfig.png" alt="pkgconfig"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_version.png" alt="version"></p>
<p><code>ffmpeg-config.cmake</code>文件写完，我们再回过头来看一下<code>detect_ffmpeg.cmake</code></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> HAVE_FFMPEG <span class="keyword">AND</span> OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"1"</span> <span class="keyword">OR</span> OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"ON"</span>)</span><br><span class="line">    <span class="keyword">set</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="string">"FFMPEG"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">find_package</span>(<span class="variable">$&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;</span>) <span class="comment"># Required components: AVCODEC AVFORMAT AVUTIL SWSCALE</span></span><br><span class="line">  <span class="keyword">if</span>(FFMPEG_FOUND <span class="keyword">OR</span> FFmpeg_FOUND)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>可以看到最后的 if 中，如果<code>FFMPEG_FOUND</code>为<code>true</code>，则设置<code>HAVE_FFMPEG</code>为<code>true</code>，正好对应了我们在<code>ffmpeg-config.cmake</code>中的行为，这下，<code>CMakeLists.txt</code>就可以找到我们的<code>FFmpeg</code>库了</p>
<p>这里还有一点，<code>detect_ffmpeg.cmake</code>中有一段用来测试的代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(HAVE_FFMPEG <span class="keyword">AND</span> <span class="keyword">NOT</span> HAVE_FFMPEG_WRAPPER <span class="keyword">AND</span> <span class="keyword">NOT</span> OPENCV_FFMPEG_SKIP_BUILD_CHECK)</span><br><span class="line">  <span class="keyword">try_compile</span>(__VALID_FFMPEG</span><br><span class="line">      <span class="string">"$&#123;OpenCV_BINARY_DIR&#125;"</span></span><br><span class="line">      <span class="string">"$&#123;OpenCV_SOURCE_DIR&#125;/cmake/checks/ffmpeg_test.cpp"</span></span><br><span class="line">      CMAKE_FLAGS <span class="string">"-DINCLUDE_DIRECTORIES:STRING=$&#123;FFMPEG_INCLUDE_DIRS&#125;"</span></span><br><span class="line">                  <span class="string">"-DLINK_LIBRARIES:STRING=$&#123;FFMPEG_LIBRARIES&#125;"</span></span><br><span class="line">      OUTPUT_VARIABLE TRY_OUT</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> __VALID_FFMPEG)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">"FFMPEG: test check build log:\n$&#123;TRY_OUT&#125;"</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"WARNING: Can't build ffmpeg test code"</span>)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">FALSE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>其中的<code>message(FATAL_ERROR &quot;FFMPEG: test check build log:\n${TRY_OUT}&quot;)</code>原本是被注释了的，我强烈建议各位将其打开，这样如果哪里有误，一开始就可以报错并附带详细信息，免得到时候编到一半才报错，浪费时间</p>
<p>到这里，我本以为万事大吉了，于是开始编译，这里我使用了<code>BUILD_SHARED_LIBS=ON</code>选项编译动态库，<code>armeabi-v7a</code>顺利编译通过，但当<code>arm64-v8a</code>编译到一半时突然报错，提示<code>libz.so, needed by ../../lib/arm64-v8a/libopencv_core.so, not found (try using -rpath or -rpath-link)</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_rpath_error.png" alt="rpath_error"></p>
<p>我观察了一下<code>NDK</code>目录结构，发现<code>libz.so</code>动态库文件可以在<code>$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API</code>下找到，需要注意的是，这里的<code>TOOLCHAIN_NAME</code>和<code>TRIPLE</code>很相似，但在<code>armeabi-v7a</code>情况下又有些细微的不同，所以我又新定义了这个变量</p>
<p>然后我开始尝试加入<code>-rpath-link</code>选项，首先，我尝试添加了一项<code>cmake</code>选项<code>CMAKE_SHARED_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;</code>，发现，虽然在编译开头的输出中可以看出，这个参数确实被加上生效了，但在编译到同样的地方时，仍然会报相同的错误，这里我不太清楚，难道参数的顺序也会对编译造成影响吗？</p>
<p>于是我去查看了<code>android.toolchain.cmake</code>文件，看他是怎么添加这些选项的，发现了这么一行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"$&#123;ANDROID_LINKER_FLAGS&#125; $&#123;CMAKE_SHARED_LINKER_FLAGS&#125;"</span>)</span><br></pre></td></tr></table></figure>

<p>于是我在这行代码前加了这么一行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND ANDROID_LINKER_FLAGS -Wl,-rpath-link=<span class="variable">$&#123;ANDROID_TOOLCHAIN_ROOT&#125;</span>/sysroot/usr/lib/<span class="variable">$&#123;ANDROID_TOOLCHAIN_NAME&#125;</span>/<span class="variable">$&#123;ANDROID_PLATFORM_LEVEL&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>让<code>-rpath-link</code>这个选项提前一点，果不其然，编译顺利通过了，但这样做有点麻烦，还得改<code>NDK</code>里的配置，于是我在构建脚本里加了一个参数<code>ANDROID_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;</code>，这样的话，<code>-rpath-link</code>选项会被提到<code>Linker flags</code>的最前面，经过测试，这样也可以编译通过，于是<code>OpenCV</code>的编译脚本也就这么完成了</p>
<p>当然这里还剩一个疑点，为什么不加<code>-rpath-link</code>的时候，<code>arm64-v8a</code>编译报错但<code>armeabi-v7a</code>却编译通过，希望有大佬可以指点一下</p>
<h1 id="FreeType"><a href="#FreeType" class="headerlink" title="FreeType"></a>FreeType</h1><p>我的App中还用到了<code>FreeType</code>库渲染字体，在这里顺便也把它的编译方式放出来吧</p>
<p>直接去 <a href="https://github.com/dreamgyf/freetype/releases/tag/v2.12.1_compilable" target="_blank" rel="noopener">FreeType</a> 这里下载我编译好的版本或者源码，根据我写的步骤进行编译就可以了</p>
<h1 id="在Android中使用"><a href="#在Android中使用" class="headerlink" title="在Android中使用"></a>在Android中使用</h1><p>在Android中使用时需要注意，如果你使用静态库的方式的话，需要将<code>OpenCV</code>编译出来的第三方库也加入到链接中，放在<code>OpenCV</code>的后面，另外<code>FFmpeg</code>还需要<code>mediandk</code>和<code>zlib</code>这两个依赖，具体可以参考下面的代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        textvideo</span><br><span class="line"></span><br><span class="line">        freetype</span><br><span class="line"></span><br><span class="line">        <span class="comment"># opencv</span></span><br><span class="line">        opencv_videoio</span><br><span class="line">        opencv_photo</span><br><span class="line">        opencv_highgui</span><br><span class="line">        opencv_imgproc</span><br><span class="line">        opencv_imgcodecs</span><br><span class="line">        opencv_dnn</span><br><span class="line">        opencv_core</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ffmpeg</span></span><br><span class="line">        ffmpeg_avformat</span><br><span class="line">        ffmpeg_avdevice</span><br><span class="line">        ffmpeg_avcodec</span><br><span class="line">        ffmpeg_avutil</span><br><span class="line">        ffmpeg_swscale</span><br><span class="line">        ffmpeg_swresample</span><br><span class="line">        ffmpeg_avfilter</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ffmpeg依赖</span></span><br><span class="line">        mediandk</span><br><span class="line">        z</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x264</span></span><br><span class="line">        x264</span><br><span class="line"></span><br><span class="line">        <span class="comment"># opencv第三方支持库</span></span><br><span class="line">        ade</span><br><span class="line">        cpufeatures</span><br><span class="line">        ittnotify</span><br><span class="line">        libjpeg-turbo</span><br><span class="line">        libopenjp2</span><br><span class="line">        libpng</span><br><span class="line">        libprotobuf</span><br><span class="line">        libwebp</span><br><span class="line">        quirc</span><br><span class="line">        tegra_hal</span><br><span class="line"></span><br><span class="line">        <span class="comment"># android jni库</span></span><br><span class="line">        jnigraphics</span><br><span class="line">        android</span><br><span class="line">        log)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然我这篇文章写的看起来编译的过程很简单，根本不像标题所说的那么艰难，但实际上我前前后后弄了大概有一个多星期才真正完整编出可用版本，前前后后编译失败了不说一百次也有几十次，对我这种不懂c语言编译的简直是折磨。因为我是在全部弄完后才开始写的文章，所以基本上坑都踩的差不多了，其中有些坑印象也没那么清楚了，我也没那么多精力再去复现出那些坑了，怎么说呢，能成功就万事大吉吧 😭</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/08/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - Activity启动流程（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>作为一名<code>Android</code>开发，我们最熟悉并且最常打交道的当然非四大组件中的<code>Activity</code>莫属，这次我们就来讲讲一个<code>Activity</code>是怎样启动起来的</p>
<p>本来本篇想要讲<code>ActivityManagerService</code>的，但<code>AMS</code>中的内容过多过于繁杂，不如用这种以线及面的方式，通过<code>Activity</code>的启动流程这一条线，去了解<code>ActivityThread</code>，<code>AMS</code>等是怎么工作的</p>
<h1 id="Android窗口结构关系"><a href="#Android窗口结构关系" class="headerlink" title="Android窗口结构关系"></a>Android窗口结构关系</h1><p>在开始正式深入代码之前，我们需要先理一下<code>Android</code>的窗口结构关系，以免后面看到源码里各种<code>parent</code>、<code>child</code>头晕，我画了一张树状关系图来描述它</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-Android%E7%AA%97%E5%8F%A3%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="Android窗口结构关系"></p>
<p>上图中的所有类都是<code>WindowContainer</code>的子类，<code>WindowContainer</code>是一个窗口容器，它的<code>child</code>也是<code>WindowContainer</code>，它是用来管理窗口子容器的</p>
<p>可以先不用纠结理解这张图中的关系，顺着源码往下看，碰到不理解的地方回头看一下就可以了</p>
<h1 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h1><p>作为<code>Android</code>开发，<code>startActivity</code>这个方法一定非常熟悉，我们以这个函数作为入口来分析<code>Activity</code>的启动流程</p>
<p><code>Activity</code>和<code>ContextImpl</code>的<code>startActivity</code>方法实现不太一样，但最终都调用了<code>Instrumentation.execStartActivity</code>方法</p>
<h1 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>路径：<code>frameworks/base/core/java/android/app/Instrumentation.java</code></p>
<p>以下是Google官方对这个类功能的注释</p>
<p><em>Base class for implementing application instrumentation code.  When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application.  An Instrumentation implementation is described to the system through an AndroidManifest.xml’s &lt;instrumentation&gt; tag.</em></p>
<p>简单翻译一下，就是这个类是用于监控系统与应用的交互的（<code>onCreate</code>等生命周期会经历<code>Instrumentation</code>这么一环），它会在任何<code>App</code>代码执行前被初始化。</p>
<p>本人猜测，这个类主要存在的意义是为了给自动化测试提供一个切入点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">//记录调用者</span></span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动化测试相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//迁移额外的URI数据流到剪贴板（处理Intent使用ACTION_SEND或ACTION_SEND_MULTIPLE共享数据的情况）</span></span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        <span class="comment">//处理离开当前App进程的情况</span></span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">//请求ATMS启动Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查异常情况，抛出对应异常</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了<code>ActivityTaskManager.getService.startActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityTaskManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>getService</code>出来的很明显的是一个远程<code>binder</code>对象，我们之前已经分析过那么多<code>binder</code>知识了，以后就不再过多啰嗦了，这里实际上调用的是<code>ActivityTaskManagerSerivce</code>（以下简称<code>ATMS</code>）的<code>startActivity</code>方法</p>
<h1 id="ActivityTaskManagerSerivce"><a href="#ActivityTaskManagerSerivce" class="headerlink" title="ActivityTaskManagerSerivce"></a>ActivityTaskManagerSerivce</h1><p><code>ATMS</code>是<code>Android 10</code>以后新加的一个服务，用来专门处理<code>Activity</code>相关工作，分担<code>AMS</code>的工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*validateIncomingUser*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断言发起startActivity请求方的UID和callingPackage指向的是同一个App</span></span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    <span class="comment">//确认请求方没有被隔离</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并获取当前用户ID（多用户模式）</span></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ActivityStarter启动Activity</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller) <span class="comment">//调用方ApplicationThread</span></span><br><span class="line">            .setCallingPackage(callingPackage) <span class="comment">//调用方包名</span></span><br><span class="line">            .setCallingFeatureId(callingFeatureId) <span class="comment">// Context.getAttributionTag()</span></span><br><span class="line">            .setResolvedType(resolvedType) <span class="comment">//设置Intent解析类型</span></span><br><span class="line">            .setResultTo(resultTo) <span class="comment">//设置目标Activity Token（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setResultWho(resultWho) <span class="comment">//设置目标Activity（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setRequestCode(requestCode) <span class="comment">//设置requestCode</span></span><br><span class="line">            .setStartFlags(startFlags) <span class="comment">// startFlags == 0</span></span><br><span class="line">            .setProfilerInfo(profilerInfo) <span class="comment">// null</span></span><br><span class="line">            .setActivityOptions(bOptions) <span class="comment">//设置Activity Options Bundle</span></span><br><span class="line">            .setUserId(userId) <span class="comment">//设置用户ID</span></span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分内容都是检查，最重要的是最后一段使用<code>ActivityStarter</code>启动<code>Activity</code>，首先通过<code>ActivityStartController</code>的<code>obtainStarter</code>方法获取一个<code>ActivityStarter</code>实例，然后调用各种set方法设置参数，最后执行<code>execute</code>方法执行</p>
<h1 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h1><p>这个类从名字就能看出来，就是一个专门处理<code>Activity</code>启动的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">        <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.intent != <span class="keyword">null</span> &amp;&amp; mRequest.intent.hasFileDescriptors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LaunchingState launchingState;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">//通过Token获取调用方ActivityRecord</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo);</span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(</span><br><span class="line">                    mRequest.intent, caller);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the caller hasn't already resolved the activity, we're willing</span></span><br><span class="line">        <span class="comment">// to do so here. If the caller is already holding the WM lock here,</span></span><br><span class="line">        <span class="comment">// and we need to check dynamic Uri permissions, then we're forced</span></span><br><span class="line">        <span class="comment">// to assume those permissions are denied to avoid deadlocking.</span></span><br><span class="line">        <span class="comment">//通过Intent解析Activity信息</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.activityInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRequest.resolveActivity(mSupervisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            ... <span class="comment">//处理Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//清除Binder调用方UID和PID，用当前进程的UID和PID替代，并返回之前的UID和PID（UID：前32位，PID：后32位）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析成为重量级进程（如果设置了相关flag的话）</span></span><br><span class="line">            <span class="comment">//这里的重量级进程指的是不能保存状态的应用进程</span></span><br><span class="line">            res = resolveToHeavyWeightSwitcherIfNeeded();</span><br><span class="line">            <span class="keyword">if</span> (res != START_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行请求</span></span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复之前的Binder调用方UID和PID</span></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//更新Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify ActivityMetricsLogger that the activity has launched.</span></span><br><span class="line">            <span class="comment">// ActivityMetricsLogger will then wait for the windows to be drawn and populate</span></span><br><span class="line">            <span class="comment">// WaitResult.</span></span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res,</span><br><span class="line">                    mLastStartActivityRecord);</span><br><span class="line">            <span class="comment">//返回启动结果</span></span><br><span class="line">            <span class="keyword">return</span> getExternalResult(mRequest.waitResult == <span class="keyword">null</span> ? res</span><br><span class="line">                    : waitForResult(res, mLastStartActivityRecord));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//清理回收工作</span></span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数每一步做了什么我都用注释标出来了，大家看看就好，重点在于其中的<code>executeRequest(mRequest)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Executing activity start request and starts the journey of starting an activity. Here</span></span><br><span class="line"><span class="comment">    * begins with performing several preliminary checks. The normally activity launch flow will</span></span><br><span class="line"><span class="comment">    * go through &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125; to &#123;<span class="doctag">@link</span> #startActivityInner&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(request.reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = request.reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IApplicationThread caller = request.caller;</span><br><span class="line">    Intent intent = request.intent;</span><br><span class="line">    NeededUriGrants intentGrants = request.intentGrants;</span><br><span class="line">    String resolvedType = request.resolvedType;</span><br><span class="line">    ActivityInfo aInfo = request.activityInfo;</span><br><span class="line">    ResolveInfo rInfo = request.resolveInfo;</span><br><span class="line">    <span class="keyword">final</span> IVoiceInteractionSession voiceSession = request.voiceSession;</span><br><span class="line">    <span class="keyword">final</span> IBinder resultTo = request.resultTo;</span><br><span class="line">    String resultWho = request.resultWho;</span><br><span class="line">    <span class="keyword">int</span> requestCode = request.requestCode;</span><br><span class="line">    <span class="keyword">int</span> callingPid = request.callingPid;</span><br><span class="line">    <span class="keyword">int</span> callingUid = request.callingUid;</span><br><span class="line">    String callingPackage = request.callingPackage;</span><br><span class="line">    String callingFeatureId = request.callingFeatureId;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = request.realCallingPid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = request.realCallingUid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startFlags = request.startFlags;</span><br><span class="line">    <span class="keyword">final</span> SafeActivityOptions options = request.activityOptions;</span><br><span class="line">    Task inTask = request.inTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle =</span><br><span class="line">            options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    WindowProcessController callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方应用进程对应的WindowProcessController</span></span><br><span class="line">        <span class="comment">//这个类是用于和ProcessRecord进行通讯的</span></span><br><span class="line">        callerApp = mService.getProcessController(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//异常情况，startActivity的调用方进程不存在或未启动</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">") when starting: "</span> + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前用户ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = aInfo != <span class="keyword">null</span> &amp;&amp; aInfo.applicationInfo != <span class="keyword">null</span></span><br><span class="line">            ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</span><br><span class="line">                + <span class="string">"&#125; from uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//调用方Activity Token != null</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方ActivityRecord（要求存在任意一个Window栈中，即是RootWindow的子嗣）</span></span><br><span class="line">        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) &#123;</span><br><span class="line">            Slog.v(TAG_RESULTS, <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用方需要response</span></span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line">    <span class="comment">//多Activity传值场景</span></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到可以处理此Intent的组件</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find a class that can handle the given Intent.</span></span><br><span class="line">        <span class="comment">// That's the end of that!</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Intent中解析不出相应的Activity信息</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">null</span> : resultRecord.getRootTask();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查启动Activity的权限</span></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, callingFeatureId,</span><br><span class="line">            request.ignoreTargetSecurity, inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPackage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> restrictedBgActivity = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,</span><br><span class="line">                    <span class="string">"shouldAbortBackgroundActivityStart"</span>);</span><br><span class="line">            <span class="comment">//检查是否要限制后台启动Activity</span></span><br><span class="line">            restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,</span><br><span class="line">                    callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,</span><br><span class="line">                    request.originatingPendingIntent, request.allowBackgroundActivityStart,</span><br><span class="line">                    intent);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two options bundles, while realCallerOptions takes precedence.</span></span><br><span class="line">    <span class="comment">//过渡动画相关</span></span><br><span class="line">    ActivityOptions checkedOptions = options != <span class="keyword">null</span></span><br><span class="line">            ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        checkedOptions = mService.getActivityStartController()</span><br><span class="line">                .getPendingRemoteAnimationRegistry()</span><br><span class="line">                .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// The Intent we give to the watcher has the extra data stripped off, since it</span></span><br><span class="line">            <span class="comment">// can contain private information.</span></span><br><span class="line">            Intent watchIntent = intent.cloneFilter();</span><br><span class="line">            <span class="comment">//这个方法似乎只打印了一些日志，恒返回true，即abort |= false</span></span><br><span class="line">            abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                    aInfo.applicationInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            mService.mController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化ActivityStartInterceptor</span></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage,</span><br><span class="line">            callingFeatureId);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity start was intercepted, e.g. because the target user is currently in quiet</span></span><br><span class="line">        <span class="comment">// mode (turn off work) or the target application is suspended</span></span><br><span class="line">        <span class="comment">//拦截并转化成其他的启动模式</span></span><br><span class="line">        intent = mInterceptor.mIntent;</span><br><span class="line">        rInfo = mInterceptor.mRInfo;</span><br><span class="line">        aInfo = mInterceptor.mAInfo;</span><br><span class="line">        resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">        inTask = mInterceptor.mInTask;</span><br><span class="line">        callingPid = mInterceptor.mCallingPid;</span><br><span class="line">        callingUid = mInterceptor.mCallingUid;</span><br><span class="line">        checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The interception target shouldn't get any permission grants</span></span><br><span class="line">        <span class="comment">// intended for the original destination</span></span><br><span class="line">        intentGrants = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We pretend to the caller that it was really started, but they will just get a</span></span><br><span class="line">        <span class="comment">// cancel result.</span></span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run, we</span></span><br><span class="line">    <span class="comment">// launch the review activity and pass a pending intent to start the activity</span></span><br><span class="line">    <span class="comment">// we are to launching now after the review is completed.</span></span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果启动的Activity没有相应权限，则需要用户手动确认允许权限后，再进行启动工作</span></span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            <span class="comment">//将原来的Intent包装在新的Intent中，用这个确认权限的新Intent继续后面的启动工作</span></span><br><span class="line">            <span class="keyword">final</span> IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingFeatureId,</span><br><span class="line">                    callingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Intent newIntent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flags = intent.getFlags();</span><br><span class="line">            flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Prevent reuse of review activity: Each app needs their own review activity. By</span></span><br><span class="line"><span class="comment">                * default activities launched with NEW_TASK or NEW_DOCUMENT try to reuse activities</span></span><br><span class="line"><span class="comment">                * with the same launch parameters (extras are ignored). Hence to avoid possible</span></span><br><span class="line"><span class="comment">                * reuse force a new activity via the MULTIPLE_TASK flag.</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * Activities that are not launched with NEW_TASK or NEW_DOCUMENT are not re-used,</span></span><br><span class="line"><span class="comment">                * hence no need to add the flag in this case.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">            newIntent.setFlags(flags);</span><br><span class="line"></span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The permissions review target shouldn't get any permission</span></span><br><span class="line">            <span class="comment">// grants intended for the original destination</span></span><br><span class="line">            intentGrants = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, request.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have an ephemeral app, abort the process of launching the resolved intent.</span></span><br><span class="line">    <span class="comment">// Instead, launch the ephemeral installer. Once the installer is finished, it</span></span><br><span class="line">    <span class="comment">// starts either the intent we resolved here [on install error] or the ephemeral</span></span><br><span class="line">    <span class="comment">// app [on install success].</span></span><br><span class="line">    <span class="keyword">if</span> (rInfo != <span class="keyword">null</span> &amp;&amp; rInfo.auxiliaryInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//Instant App相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建启动Activity的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">    mLastStartActivityRecord = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.appTimeTracker == <span class="keyword">null</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller didn't specify an explicit time tracker, we want to continue</span></span><br><span class="line">        <span class="comment">// tracking under any it has.</span></span><br><span class="line">        r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶层焦点的Acticity栈</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are starting an activity that is not from the same uid as the currently resumed</span></span><br><span class="line">    <span class="comment">// one, check whether app switches are allowed.</span></span><br><span class="line">    <span class="comment">//当此时栈顶Activity UID != 调用方 UID的时候（比如悬浮窗）</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">        <span class="comment">//检查是否可以直接切换应用</span></span><br><span class="line">        <span class="comment">// 1. 设置的 mAppSwitchesAllowedTime &lt; 当前系统时间（stopAppSwitches）</span></span><br><span class="line">        <span class="comment">// 2. 调用方在最近任务中</span></span><br><span class="line">        <span class="comment">// 3. 调用方具有 STOP_APP_SWITCHES 权限</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">            <span class="comment">//加入到延时启动列表中</span></span><br><span class="line">            <span class="keyword">if</span> (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">                mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                        sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调处理延迟应用切换</span></span><br><span class="line">    mService.onStartActivitySetDidAppSwitch();</span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心：进入Activity启动的下一阶段</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.outActivity[<span class="number">0</span>] = mLastStartActivityRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分都是检查工作，这些可以看我标的注释，基本上介绍的比较详细了，然后进入到Activity启动的下一步，<code>startActivityUnchecked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity while most of preliminary checks has been done and caller has been</span></span><br><span class="line"><span class="comment">    * confirmed that holds necessary permissions to do so.</span></span><br><span class="line"><span class="comment">    * Here also ensures that the starting activity is removed if the start wasn't successful.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack startedActivityStack;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//暂停布局工作，避免重复刷新</span></span><br><span class="line">        mService.deferWindowLayout();</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="string">"startActivityInner"</span>);</span><br><span class="line">        <span class="comment">//接着把启动Activity工作交给这个方法</span></span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        <span class="comment">//进行一些更新Configuration，清理栈等收尾工作</span></span><br><span class="line">        startedActivityStack = handleStartResult(r, result);</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, startedActivityStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也不是主要逻辑所在，我们往下接着看<code>startActivityInner</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity and determine if the activity should be adding to the top of an existing</span></span><br><span class="line"><span class="comment">    * task or delivered new intent to an existing activity. Also manipulating the activity task</span></span><br><span class="line"><span class="comment">    * onto requested or valid stack/display.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Note: This method should only be called from &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(b/152429287): Make it easier to exercise code paths through startActivityInner</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置初始化参数</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    <span class="comment">//计算处理Activity启动模式</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//计算调用方Activity任务栈</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将flags设置为调整后的LaunchFlags</span></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找是否有可复用的Task</span></span><br><span class="line">    <span class="keyword">final</span> Task reusedTask = getReusableTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If requested, freeze the task list</span></span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="keyword">null</span> &amp;&amp; mOptions.freezeRecentTasksReordering()</span><br><span class="line">            &amp;&amp; mSupervisor.mRecentTasks.isCallerRecents(r.launchedFromUid)</span><br><span class="line">            &amp;&amp; !mSupervisor.mRecentTasks.isFreezeTaskListReorderingSet()) &#123;</span><br><span class="line">        mFrozeTaskList = <span class="keyword">true</span>;</span><br><span class="line">        mSupervisor.mRecentTasks.setFreezeTaskListReordering();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute if there is an existing task that should be used for.</span></span><br><span class="line">    <span class="comment">//计算是否存在可使用的现有Task</span></span><br><span class="line">    <span class="keyword">final</span> Task targetTask = reusedTask != <span class="keyword">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newTask = targetTask == <span class="keyword">null</span>;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算启动参数</span></span><br><span class="line">    computeLaunchParams(r, sourceRecord, targetTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if starting activity on given task or on a new task is allowed.</span></span><br><span class="line">    <span class="comment">//检查是否允许在targetTask上或者新建Task启动</span></span><br><span class="line">    <span class="keyword">int</span> startResult = isAllowedToStart(r, newTask, targetTask);</span><br><span class="line">    <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得栈顶未finish的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord targetTaskTop = newTask</span><br><span class="line">            ? <span class="keyword">null</span> : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    <span class="keyword">if</span> (targetTaskTop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Recycle the target task for this launch.</span></span><br><span class="line">        <span class="comment">//回收，准备复用这个Task</span></span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAddingToTask = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="comment">//处理singleTop启动模式</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (topStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startResult = deliverToCurrentTopIfNeeded(topStack, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复用或创建Activity栈</span></span><br><span class="line">    <span class="keyword">if</span> (mTargetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123; <span class="comment">//开启新Task</span></span><br><span class="line">        <span class="keyword">final</span> Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">                ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//复用或新建一个Task，并建立Task与ActivityRecord之间的关联</span></span><br><span class="line">        setNewTask(taskToAffiliate);</span><br><span class="line">        <span class="keyword">if</span> (mService.getLockTaskController().isLockTaskModeViolation(</span><br><span class="line">                mStartActivity.getTask())) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation mStartActivity="</span> + mStartActivity);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAddingToTask) &#123; <span class="comment">//复用Task</span></span><br><span class="line">        <span class="comment">//将启动Activity添加到targetTask容器顶部或将其父容器替换成targetTask（也会将启动Activity添加到targetTask容器顶部）</span></span><br><span class="line">        addOrReparentStartingActivity(targetTask, <span class="string">"adding to task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123;</span><br><span class="line">        mTargetStack.getStack().moveToFront(<span class="string">"reuseOrNewTask"</span>, targetTask);</span><br><span class="line">        <span class="keyword">if</span> (mOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOptions.getTaskAlwaysOnTop()) &#123;</span><br><span class="line">                mTargetStack.setAlwaysOnTop(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123;</span><br><span class="line">            <span class="comment">// Launching underneath dream activity (fullscreen, always-on-top). Run the launch-</span></span><br><span class="line">            <span class="comment">// -behind transition so the Activity gets created and starts in visible state.</span></span><br><span class="line">            mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">            r.mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mTargetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded(</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* forceSend */</span>, mStartActivity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Task移到ActivityStack容器顶部</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(),</span><br><span class="line">            newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="comment">//启动的Activity不可获得焦点，无法恢复它</span></span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// If the activity is not focusable, we can't resume it, but still would like to</span></span><br><span class="line">            <span class="comment">// make sure it becomes visible as it starts (this will also trigger entry</span></span><br><span class="line">            <span class="comment">// animation). An example of this are PIP activities.</span></span><br><span class="line">            <span class="comment">// Also, we don't want to resume activities in a task that currently has an overlay</span></span><br><span class="line">            <span class="comment">// as the starting activity just needs to be in the visible paused state until the</span></span><br><span class="line">            <span class="comment">// over is removed.</span></span><br><span class="line">            <span class="comment">// Passing &#123;@code null&#125; as the start parameter ensures all activities are made</span></span><br><span class="line">            <span class="comment">// visible.</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisible(<span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                    <span class="number">0</span> <span class="comment">/* configChanges */</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// Go ahead and tell window manager to execute app transition for this activity</span></span><br><span class="line">            <span class="comment">// since the app transition will not be triggered through the resume channel.</span></span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">            <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">            <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">            <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">            <span class="comment">// accordingly.</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityInner"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重点：恢复栈顶Activities</span></span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the recent tasks list immediately when the activity starts</span></span><br><span class="line">    <span class="comment">//当Activity启动后立刻更新最近任务列表</span></span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了一些<code>Task</code>和栈的操作，是否可以复用栈，是否需要新栈，处理栈顶复用等相关操作。我们需要注意一下这里关于<code>Task</code>的操作，不管是新建<code>Task</code>（<code>newTask</code>）还是复用<code>Task</code>（<code>mAddingToTask</code>），都会调用到<code>addOrReparentStartingActivity</code>方法将启动<code>ActivityRecord</code>添加到<code>targetTask</code>容器顶部（<code>newTask</code>的情况下会调用<code>setNewTask</code>方法先复用或创建<code>Task</code>，然后再用这个<code>Task</code>调用<code>addOrReparentStartingActivity</code>方法），之后调用<code>mTargetStack.startActivityLocked</code>方法将<code>Task</code>移到<code>mTargetStack</code>容器顶部，此时调用<code>mTargetStack.topRunningActivity</code>便会得到我们将要启动的这个<code>ActivityRecord</code></p>
<p>最后判断目标<code>Activity</code>是否可获得焦点，当可获得焦点的时候，调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复<code>Activity</code></p>
<p>要注意，从这个方法开始的以后的方法不再只是针对<code>Activity</code>启动的方法，它们有可能被多方调用，所以其中的一些步骤case我们是不会经历的，可以忽略掉这部分</p>
<h1 id="RootWindowContainer"><a href="#RootWindowContainer" class="headerlink" title="RootWindowContainer"></a>RootWindowContainer</h1><p><code>RootWindowContainer</code>是显示窗口的根窗口容器，它主要是用来管理显示屏幕的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStacksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//目标栈在栈顶显示区域</span></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        <span class="comment">//使用目标栈进行恢复</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能存在多显示设备（投屏等）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> resumedOnDisplay = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tdaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; tdaNdx &gt;= <span class="number">0</span>; --tdaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; sNdx &gt;= <span class="number">0</span>; --sNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack stack = taskDisplayArea.getStackAt(sNdx);</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord topRunningActivity = stack.topRunningActivity();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isFocusableAndVisible() || topRunningActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack == targetStack) &#123;</span><br><span class="line">                    <span class="comment">//如果进入到这里，代表着targetStack在上面已经恢复过了，此时只需要记录结果即可</span></span><br><span class="line">                    resumedOnDisplay |= result;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123;</span><br><span class="line">                    <span class="comment">//执行切换效果</span></span><br><span class="line">                    stack.executeAppTransition(targetOptions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使顶部显示的Activity执行Resume、Pause或Start生命周期</span></span><br><span class="line">                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!resumedOnDisplay) &#123;</span><br><span class="line">            <span class="comment">// In cases when there are no valid activities (e.g. device just booted or launcher</span></span><br><span class="line">            <span class="comment">// crashed) it's possible that nothing was resumed on a display. Requesting resume</span></span><br><span class="line">            <span class="comment">// of top activity in focused stack explicitly will make sure that at least home</span></span><br><span class="line">            <span class="comment">// activity is started and resumed, and no recursion occurs.</span></span><br><span class="line">            <span class="comment">//当没有任何有效的Activity的时候（设备刚启动或Launcher崩溃），可能没有任何东西可被恢复</span></span><br><span class="line">            <span class="comment">//这时候使用DisplayContent中的焦点栈进行恢复</span></span><br><span class="line">            <span class="comment">//如果连存在焦点的栈都没有，则恢复Launcher的Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">"no-focusable-task"</span>,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了几件事：</p>
<ul>
<li><p>如果目标栈在栈顶显示区域，执行Resume</p>
</li>
<li><p>遍历显示设备，从中遍历所有有焦点并且可见的栈，对其栈顶<code>Activity</code>执行相应的切换效果及生命周期</p>
</li>
<li><p>对每个显示设备，如果存在焦点栈，则使用其执行Resume，否则启动<code>Launcher</code></p>
</li>
</ul>
<p>在正常情况下，我们会走进<code>ActivityStack.resumeTopActivityUncheckedLocked</code>这个方法</p>
<h1 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h1><p><code>Activity</code>栈，用于管理栈中的<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        mInResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">        <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">        <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">        <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">        <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">        <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">        <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            <span class="comment">//准备休眠</span></span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了一个防止递归调用的措施，接下来调用了<code>resumeTopActivityInnerLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="comment">//ATMS服务尚未准备好</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="comment">//在之前我们已经把要启动的ActivityRecord加到了栈顶</span></span><br><span class="line">    ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let's look somewhere else.</span></span><br><span class="line">        <span class="keyword">return</span> resumeNextFocusableActivityWhenStackIsEmpty(prev, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">    <span class="comment">//如果需要Resume的已在顶部且状态为Resume，不需要做任何事</span></span><br><span class="line">    <span class="comment">//启动Activity不会碰到这种case</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!next.canResumeByCompat()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">    <span class="comment">//如果有正在Pause的Activity，在它Pause完成前不要做任何事</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete();</span><br><span class="line">    <span class="keyword">if</span> (!allPausedComplete) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line">    <span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line">    <span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line">    <span class="comment">//确保拥有此Activity的用户已启动</span></span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">    <span class="comment">// appropriate for it.</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">    next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里似乎重复检查了，我去查看了一下master分支的代码，已经没有这一段了</span></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置启动Activity UID，获取WakeLock，保证在显示Activity的过程中，系统不会进行休眠状态</span></span><br><span class="line">    mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    ActivityRecord lastResumed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//上一个具有焦点的ActivityStack（目前仍是屏幕上正在显示的那个Activity的栈）</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (lastFocusedStack != <span class="keyword">null</span> &amp;&amp; lastFocusedStack != <span class="keyword">this</span>) &#123;</span><br><span class="line">        lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pause掉其他ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">boolean</span> pausing = taskDisplayArea.pauseBackStacks(userLeaving, next);</span><br><span class="line">    <span class="comment">//Pause掉当前ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing) &#123; <span class="comment">//有Activity执行了Pause</span></span><br><span class="line">        <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">        <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">        <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">        <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">        <span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line">            <span class="comment">//将启动的Activity进程信息移至lru列表的头部</span></span><br><span class="line">            <span class="comment">//因为很快就会使用它启动Activity</span></span><br><span class="line">            next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                    <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">false</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">            <span class="comment">// Since the start-process is asynchronous, if we already know the process of next</span></span><br><span class="line">            <span class="comment">// activity isn't running, we can start the process earlier to save the time to wait</span></span><br><span class="line">            <span class="comment">// for the current activity to be paused.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = <span class="keyword">this</span> == taskDisplayArea.getFocusedStack();</span><br><span class="line">            <span class="comment">//启动App进程</span></span><br><span class="line">            mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">                    isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//这里会先结束掉启动Activity的流程，等待onPause生命周期走完后</span></span><br><span class="line">        <span class="comment">//再重新调用这个方法执行下一步操作，避免Activity生命周期紊乱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">        <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">        <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        <span class="comment">//不需要等待其他的Activity onPause完成</span></span><br><span class="line">        <span class="comment">//执行完切换效果后就没有什么其他需要做的了</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动Activity流程不会进入这个case</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev != next &amp;&amp; next.nowVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改启动Activity的package的状态</span></span><br><span class="line">    mAtmService.getPackageManager().setPackageStoppedState(</span><br><span class="line">                next.packageName, <span class="keyword">false</span>, next.mUserId);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Activity转场动画准备</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next.attachedToProcess()) &#123; <span class="comment">//对于将要启动的ActivityRecord来说，此时尚未完成和Process的绑定，返回false</span></span><br><span class="line">        ...</span><br><span class="line">        ActivityRecord lastResumedActivity =</span><br><span class="line">                lastFocusedStack == <span class="keyword">null</span> ? <span class="keyword">null</span> : lastFocusedStack.mResumedActivity;</span><br><span class="line">        <span class="comment">//保存状态以做后面恢复使用</span></span><br><span class="line">        <span class="keyword">final</span> ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">        mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新ActivityRecord状态</span></span><br><span class="line">        next.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新启动Activity的进程信息并将其移至lru列表的头部</span></span><br><span class="line">        next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//更新Activity显示、方向和Configuration</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction =</span><br><span class="line">                    ClientTransaction.obtain(next.app.getThread(), next.appToken);</span><br><span class="line">            <span class="comment">// Deliver all pending results.</span></span><br><span class="line">            ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                            <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                    transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transaction.addCallback(</span><br><span class="line">                        NewIntentItem.obtain(next.newIntents, <span class="keyword">true</span> <span class="comment">/* resume */</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">            <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">            next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">            EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next),</span><br><span class="line">                    next.getTask().mTaskId, next.shortComponentName);</span><br><span class="line"></span><br><span class="line">            next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line">            mAtmService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">            next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState);</span><br><span class="line">            next.clearOptionsLocked();</span><br><span class="line">            <span class="comment">//设置onResume生命周期请求</span></span><br><span class="line">            transaction.setLifecycleStateRequest(</span><br><span class="line">                    ResumeActivityItem.obtain(next.app.getReportedProcState(),</span><br><span class="line">                            dc.isNextTransitionForward()));</span><br><span class="line">            <span class="comment">//调度执行Activity onResume生命周期</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span></span><br><span class="line">                    + next);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//resume失败需要尝试restart</span></span><br><span class="line">            <span class="comment">//恢复初始状态</span></span><br><span class="line">            next.setState(lastState, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastResumedActivity.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//重新启动Activity</span></span><br><span class="line">            mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// From this point on, if something goes wrong there is no way</span></span><br><span class="line">        <span class="comment">// to recover the activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//更新信息</span></span><br><span class="line">            next.completeResumeLocked();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If any exception gets thrown, toss away this</span></span><br><span class="line">            <span class="comment">// activity and try the next one.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</span><br><span class="line">            next.finishIfPossible(<span class="string">"resume-exception"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//尚未绑定Process</span></span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动Activity</span></span><br><span class="line">        mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码很长，其实我们只需要关注三个点：</p>
<ol>
<li><p><code>Pause</code>掉其他<code>Activity</code></p>
</li>
<li><p>如果对应<code>App</code>尚未启动，启动<code>App</code>进程</p>
</li>
<li><p>启动<code>Activity</code></p>
</li>
</ol>
<p>第一步，在启动<code>Activity</code>前，我们需要先<code>Pause</code>掉其他<code>Activity</code>，这一点很好理解，我们可以对照着看<code>Activity</code>生命周期也是这样的，这里会通过<code>ATMS</code>跨进程调用相应<code>Activity</code>的<code>onPause</code>生命周期，等待<code>onPause</code>执行完成后，再跨进程调用回<code>ATMS</code>，经过一系列方法调用，又重新调用<code>resumeTopActivityInnerLocked</code>方法，继续执行下一步操作</p>
<p>第二步，如果<code>App</code>尚未启动，则先去启动<code>App</code>进程，这主要体现在这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">    <span class="comment">//启动App进程</span></span><br><span class="line">    mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">            isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动完<code>App</code>进程后，会调用<code>ATMS</code>的<code>attachApplication</code>方法，最终调用到<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code>，这个方法后面会讲</p>
<p>第三步，如果<code>App</code>进程已经启动，这时候会调用<code>ActivityStackSupervisor.startSpecificActivity</code>方法，最终殊途同归调用<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这里篇幅有点过长了，所以我觉得还是分篇比较好，这一章其实重要内容不是很多，最主要的内容，像<code>Activity</code>的生命周期控制，<code>App</code>进程的启动，<code>Activity</code>具体的启动及其后续生命周期执行都会放在下一章来讲</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>