<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2024/08/10/common/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98/">你真的了解Emoji吗？Emoji全貌大揭秘</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-08-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Emoji/">Emoji</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着科技发展，智能手机的普及，<code>Emoji</code>已经融入到了我们的生活中，但每天使用<code>Emoji</code>的你真的清楚它是什么，是由什么东西组成的，和普通的字符有什么区别吗？本文就从技术的角度带你揭秘<code>Emoji</code>的全貌。</p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近项目里有一个AI聊天机器人，你可以向他提问，他会以流式打印的形式一字一字的将回答呈现给用户。在这过程中我就发现，每当打印到<code>Emoji</code>的时候，总会先出现一个问号形状的乱码，然后才能显示出<code>Emoji</code>，有的<code>Emoji</code>更奇特，以👨‍👩‍👧‍👦为例，在打印过程中会依此显示👨👩👧👦四个<code>Emoji</code>，最后突然啪的一下，合成一整个👨‍👩‍👧‍👦，是不是很神奇？这个现象引起了我的好奇，于是我开始翻阅资料，揭开<code>Emoji</code>的神秘面纱。</p>
<h1 id="Emoji的起源及发展"><a href="#Emoji的起源及发展" class="headerlink" title="Emoji的起源及发展"></a>Emoji的起源及发展</h1><p><code>Emoji</code>来自日语词汇”絵文字”（假名为“えもじ”，读音即 emoji），绘指图画，文字指字符，最早由栗田穰崇（Shigetaka Kurita）创作，设计灵感源于天气预报图标、汉字、漫画和路标等，最初的<code>Emoji</code>有176个，都是12 x 12像素的图片。</p>
<p>1999年，日本通讯运营商DOCOMO公司发布了在当时具有跨时代意义的iMode手机，最早的<code>Emoji</code>便搭载于其中。</p>
<p><code>Emoji</code>一经诞生，人们便发现这些形象的<code>Emoji</code>实在是太好用了，不仅方便，还能使聊天过程更加有趣，随即便立刻被日本各大科技公司注意到，日本的三大运营商开始把<code>Emoji</code>加入到自己的短信业务中，很快便横扫了全日本，但为了打击竞争对手，各大运营商都使用自己的<code>Emoji</code>标准。这导致了不同运营商的手机无法正常显示对方手机发的<code>Emoji</code>。</p>
<p>苹果是<code>Emoji</code>传遍全球的最大功臣。为了把<code>iPhone</code>打入日本市场，苹果决定在<code>iOS 2.2</code>中加入日本消费者的最爱emoji，为了迎合日本市场，他们在3个月的时间推出了400多个表情符号，极大地拓展了<code>Emoji</code>的表情数量，那时的<code>iOS Emoji</code>只在日本地区可用，但“好景不长”，北美的<code>iOS 2.2</code>用户发现了隐藏在系统中的<code>Emoji</code>，之后<code>Emoji</code>很快流行了起来，这种现象得到了其它科技公司的注意。</p>
<p>随着<code>Emoji</code>的流行，2010年，<code>Emoji</code> 首次被纳入<code>Unicode v6.0</code>字符集中。每个字符（表情）都被设定了统一且唯一的二进制码，从而保障了各平台手机都能使用<code>Emoji</code>，截止撰文期间，最新的<code>Unicode v15.1</code>字符集中已有3782个<code>Emoji</code>字符，而更新的<code>Unicode v16</code>版本预计于2024年9月发布release，届时会有更多的<code>Emoji</code>被支持。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>既然<code>Emoji</code>被<code>Unicode</code>所收纳，那我们必先得去了解<code>Unicode</code>。</p>
<p>广义上的<code>Unicode</code>是一个标准，定义了<code>Unicode</code>字符集以及一系列的编码规则，是一种收录了世界上所有语言的文字和符号的全球标准。</p>
<p>那么<code>Unicode</code>是怎样收录如此庞大的字符内容呢？很简单，给每个字符指定一个编号就行了，在<code>Unicode</code>中被称为<code>码点</code>（<code>CodePoint</code>），它的表现形式为<code>U+</code>后面跟上一个十六进制数，比如<code>U+0041</code>表示大写字母<code>A</code>。</p>
<p>世界上有那么多字符，<code>Unicode</code>并不是一次性定义的，而是分区定义，每个区可以存放 65536 (<code>2^16</code>) 个字符，称为一个平面（Plane），目前<code>Unicode</code>从第0平面到第16平面总共有17个平面，其中第0平面被称为基本平面（BMP），它的码点范围从0一直到65535，写成十六进制也就是 <code>U+0000</code> - <code>U+FFFF</code> ，所有的常见字符都被放在这个平面，这是<code>Unicode</code>最先定义和公布的一个平面，而剩下的平面被称为辅助平面，码点范围从 <code>U+010000</code> 一直到 <code>U+10FFFF</code></p>
<h1 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h1><p><code>Unicode</code>字符集只规定了每个字符的码点，但这一个个码点应该被计算机传输识别呢？这就涉及到编码的概念了，目前<code>Unicode</code>实际应用使用的编码方式为<code>UCS-2</code>，也就是每个字符占用2个字节，<code>Unicode</code>还有一种4字节的编码方式<code>UCS-4</code>，但这里不做讨论。</p>
<p>使用<code>UCS-2</code>编码方式包含65536个字符空间（2个字节的可用空间即为<code>2^16</code>），对应着表示着<code>Unicode</code>字符集中的基本平面，那剩余的辅助平面又该如何表示呢？<code>UTF-16</code>应运而生。</p>
<p><code>UTF-16</code>是<code>UCS-2</code>的超集，是一种变长编码，它的编码规则很简单：基本平面的字符占用2个字节，辅助平面的字符占用4个字节，也就是说<code>UTF-16</code>的编码长度要么是2个字节（<code>U+0000</code>-<code>U+FFFF</code>），要么是4个字节（<code>U+010000</code>-<code>U+10FFFF</code>）。</p>
<p>那么问题来了，采用<code>UTF-16</code>编码的时候，我们该怎么判断这个字符占用的是2个字节还是4个字节呢？这里有个巧妙的方式，在<code>Unicode</code>的基本平面中，从<code>U+D800</code>到<code>U+DFFF</code>是一个空段，即这些码点不对应任何字符，因此，这个空段可以用来映射辅助平面的字符。辅助平面的字符一共有<code>2^20</code>个（一个平面<code>2^16</code>个字符 * 16个平面(<code>2^4</code>)），因此表示这些字符至少需要20个二进制位。<code>UTF-16</code>将这20个二进制位分成两半，前10位映射在<code>U+D800</code>到<code>U+DBFF</code>（<code>UTF-16</code>的高半区，空间大小<code>2^10</code>），称为高位（H），后10位映射在<code>U+DC00</code>到<code>U+DFFF</code>（<code>UTF-16</code>的低半区，空间大小<code>2^10</code>），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>因此，每当程序遇到2个字节时，便会去判断它的码元是否在<code>U+D800</code>到<code>U+DBFF</code>之间，如果在的话则可以假定它是一个4字节的字符，此时接着往后读2个字节，如果这2个字节的的码元在<code>U+DC00</code>到<code>U+DFFF</code>之间，将他们组合起来获得到实际字符；而如果不在的话则可以判定为是一个2字节的字符。</p>
<p>我们以<code>Java</code>中获取码点的方法<code>Character.codePointAt</code>为例来解读一下代码中如何获取一个字符的码点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_HIGH_SURROGATE = <span class="string">'\uD800'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MAX_HIGH_SURROGATE = <span class="string">'\uDBFF'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_LOW_SURROGATE  = <span class="string">'\uDC00'</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MAX_LOW_SURROGATE  = <span class="string">'\uDFFF'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SUPPLEMENTARY_CODE_POINT = <span class="number">0x010000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(CharSequence seq, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = seq.charAt(index);</span><br><span class="line">        <span class="comment">// 码元在 U+D800 到 U+DBFF 之间，并且下一个char的index没到结尾</span></span><br><span class="line">        <span class="keyword">if</span> (isHighSurrogate(c1) &amp;&amp; ++index &lt; seq.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c2 = seq.charAt(index);</span><br><span class="line">            <span class="comment">// 下一个char的码元在 U+DC00 到 U+DFFF 之间</span></span><br><span class="line">            <span class="keyword">if</span> (isLowSurrogate(c2)) &#123;</span><br><span class="line">                <span class="comment">// 组合起来获得完整字符的码点</span></span><br><span class="line">                <span class="keyword">return</span> toCodePoint(c1, c2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符码点即是单个char的码元</span></span><br><span class="line">        <span class="keyword">return</span> c1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 码元是否在 U+D800 到 U+DBFF 之间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHighSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Help VM constant-fold; MAX_HIGH_SURROGATE + 1 == MIN_LOW_SURROGATE</span></span><br><span class="line">        <span class="keyword">return</span> ch &gt;= MIN_HIGH_SURROGATE &amp;&amp; ch &lt; (MAX_HIGH_SURROGATE + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 码元是否在 U+DC00 到 U+DFFF 之间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch &gt;= MIN_LOW_SURROGATE &amp;&amp; ch &lt; (MAX_LOW_SURROGATE + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算规则：</span></span><br><span class="line"><span class="comment">     * 1. 高位上的码元减掉高半区的起始值 0xD800 ，然后左移10位</span></span><br><span class="line"><span class="comment">     * 2. 低位上的码元减掉低半区的起始值 0xDC00</span></span><br><span class="line"><span class="comment">     * 3. 将 1 和 2 的计算结果以及辅助平面的起始值 0x010000 相加，获取到完整的码点值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toCodePoint</span><span class="params">(<span class="keyword">char</span> high, <span class="keyword">char</span> low)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Optimized form of:</span></span><br><span class="line">        <span class="comment">// return ((high - MIN_HIGH_SURROGATE) &lt;&lt; 10)</span></span><br><span class="line">        <span class="comment">//         + (low - MIN_LOW_SURROGATE)</span></span><br><span class="line">        <span class="comment">//         + MIN_SUPPLEMENTARY_CODE_POINT;</span></span><br><span class="line">        <span class="keyword">return</span> ((high &lt;&lt; <span class="number">10</span>) + low) + (MIN_SUPPLEMENTARY_CODE_POINT</span><br><span class="line">                                       - (MIN_HIGH_SURROGATE &lt;&lt; <span class="number">10</span>)</span><br><span class="line">                                       - MIN_LOW_SURROGATE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Emoji规则"><a href="#Emoji规则" class="headerlink" title="Emoji规则"></a>Emoji规则</h1><p>了解了<code>Unicode</code>标准后，我们回过头来思考一下，是不是说<code>Emoji</code>在<code>Unicode</code>标准中也仅仅只是被当成普通的字符看待呢？当然并非如此，除了之前说的平面规则等，<code>Emoji</code>在<code>Unicode</code>中还有一套自己的规则，这些规则都可以在 <a href="https://www.unicode.org/reports/tr51/" target="_blank" rel="noopener">Unicode 技术标准 #51 Emoji</a> 中找到，官方的文档乍一看可能比较难理解，接下来就由我来给大家做一个解读。</p>
<p>首先，<code>Emoji</code>在大类上可以分成两种，一种是基本<code>Emoji</code>，一种是多字符组合而成的复合<code>Emoji</code></p>
<h2 id="基本Emoji"><a href="#基本Emoji" class="headerlink" title="基本Emoji"></a>基本Emoji</h2><p>什么是基本<code>Emoji</code>呢？指的是直接在<code>Unicode</code>字符集里定义的一个<code>Emoji</code>字符，大多数基本<code>Emoji</code>字符都被划归到<code>U+1F300</code>-<code>U+1F6FF</code>和<code>U+1F900</code>-<code>U+1FAFF</code>这两个区域</p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_%E5%9F%BA%E6%9C%ACEmoji_U+1F300-U+1F6FF.png" alt="基本Emoji U+1F300-U+1F6FF"></p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_%E5%9F%BA%E6%9C%ACEmoji_U+1F900-U+1FAFF.png" alt="基本Emoji U+1F900-U+1FAFF"></p>
<p>具体都有哪些基本<code>Emoji</code>字符，我们可以在<code>Unicode</code>的官网文档 <a href="https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt" target="_blank" rel="noopener">emoji-data</a> 中找到</p>
<h2 id="复合Emoji"><a href="#复合Emoji" class="headerlink" title="复合Emoji"></a>复合Emoji</h2><p>所谓的复合<code>Emoji</code>（我自己取的名字）指的是由多个字符组成的<code>Emoji</code>，它有着多种构造方式</p>
<p>在 <a href="https://www.unicode.org/reports/tr51/" target="_blank" rel="noopener">Unicode 技术标准 #51 Emoji</a> 中的<code>1.4.9</code>小节中，我们可以找到<code>Unicode</code>对<code>Emoji</code>定义的正则表达式，接下来我们就通过对这个正则表达式进行一步步的解析来了解<code>Emoji</code>的组成规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;RI&#125; \p&#123;RI&#125; </span><br><span class="line">| \p&#123;Emoji&#125; </span><br><span class="line">  ( \p&#123;EMod&#125; </span><br><span class="line">  | \x&#123;FE0F&#125; \x&#123;20E3&#125;? </span><br><span class="line">  | [\x&#123;E0020&#125;-\x&#123;E007E&#125;]+ \x&#123;E007F&#125;</span><br><span class="line">  )?</span><br><span class="line">  (\x&#123;200D&#125;</span><br><span class="line">    ( \p&#123;RI&#125; \p&#123;RI&#125;</span><br><span class="line">    | \p&#123;Emoji&#125;</span><br><span class="line">      ( \p&#123;EMod&#125; </span><br><span class="line">      | \x&#123;FE0F&#125; \x&#123;20E3&#125;? </span><br><span class="line">      | [\x&#123;E0020&#125;-\x&#123;E007E&#125;]+ \x&#123;E007F&#125;</span><br><span class="line">      )?</span><br><span class="line">    )</span><br><span class="line">  )*</span><br></pre></td></tr></table></figure>

<h3 id="旗帜"><a href="#旗帜" class="headerlink" title="旗帜"></a>旗帜</h3><p>首先我们看第一行的匹配条件<code>\p{RI} \p{RI}</code>，这里的<code>\p{RI}</code>全称为<code>Regional Indicator</code>，翻译成中文就是区域指示符，根据这行正则我们可以了解到，两个区域指示符连接便可组成一个<code>Emoji</code>，那么这个区域指示符是什么呢？</p>
<p>通过 <a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E6%8C%87%E7%A4%BA%E7%AC%A6" target="_blank" rel="noopener">维基百科</a> 我们可以得知，区域指示符指的是从<code>U+1F1E6</code>到<code>U+1F1FF</code>中的字符，位于<code>Unicode</code>第一辅助平面的带圈字母数字补充区块内。</p>
<p>正如区块描述所说，这些字符看起来就像是一个个英文字母，外面套了个方框，这里是完整的字符表：🇦 🇧 🇨 🇩 🇪 🇫 🇬 🇭 🇮 🇯 🇰 🇱 🇲 🇳 🇴 🇵 🇶 🇷 🇸 🇹 🇺 🇻 🇼 🇽 🇾 🇿，通过两两组合的方式，将它们拼成国家或地区的代号，我们就能得到该国家或地区的旗帜。</p>
<p>以中国🇨🇳举例，中国的代号为<code>CN</code>，那我们就将🇨和🇳两个字符拼接到一起，便能得到中国国旗🇨🇳</p>
<h3 id="肤色修饰符"><a href="#肤色修饰符" class="headerlink" title="肤色修饰符"></a>肤色修饰符</h3><p>第二行的<code>\p{Emoji}</code>指的就是我们之前说过的基本<code>Emoji</code>，这个是构成除旗帜外的复合<code>Emoji</code>的基础条件，接着我们看正则的第三到第六行，这里用括号括起了一个条件，括号的尾部跟了一个问号，表示括号中的这个条件最多只可以出现一次（0次或1次），括号内的条件又是由三个子条件组成，用或号分割，满足任意一条条件则视为整个条件成立，我们首先看第一个子条件<code>\p{EMod}</code>。</p>
<p>全世界的人们都希望拥有反映更多人类多样性的<code>Emoji</code>，尤其是对于肤色。<code>Unicode v8.0</code>（2015年中）发行了五个为人类表情符号提供一系列肤色的符号修饰符符，具体的修饰符以及效果由下图所示：</p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_%E8%82%A4%E8%89%B2%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="肤色修饰符"></p>
<p>我们以基本<code>Emoji</code>✋为例，它的码点是<code>U+270B</code>，在他后面加上<code>U+1F3FB</code>，这个<code>Emoji</code>就变成了✋🏻，同样的：</p>
<ul>
<li>✋ + <code>U+1F3FC</code> = ✋🏼</li>
<li>✋ + <code>U+1F3FD</code> = ✋🏽</li>
<li>✋ + <code>U+1F3FE</code> = ✋🏾</li>
<li>✋ + <code>U+1F3FF</code> = ✋🏿</li>
</ul>
<h3 id="变体选择符"><a href="#变体选择符" class="headerlink" title="变体选择符"></a>变体选择符</h3><p>接着，我们再看第二个子条件<code>x{FE0F} \x{20E3}?</code>，这里的<code>x{FE0F}</code>指的是<code>变体选择符-16</code>（<code>Variation Selector-16</code>），那么首先，什么是变体选择符呢？</p>
<p>实际上，支持象形文字的字体最早可以追溯到1993年，我们可以看一下<code>Unicode</code>字符集的装饰符号区<code>U+2700</code>-<code>U+27FF</code></p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_%E8%A3%85%E9%A5%B0%E7%AC%A6%E5%8F%B7%E5%8C%BA.png" alt="装饰符号区"></p>
<p>那如果<code>Emoji</code>想要在这些象形文字的基础上做扩展，添加颜色，使其更加生动怎么办？没错，此时就需要使用到变体选择符了。</p>
<p>变体选择符（简称VS）是一个基本多文种平面的<code>Unicode</code>区段，包括16个变体选择符。这些选择器用于描述前一个字符的特点字形。目前 <code>Unicode</code>已定义数学符号、绘文字、八思巴字母及中日韩统一表意文字所对应的中日韩兼容表意文字。目前<code>Unicode</code>仅定义 VS1, VS2, VS3, VS15 及 VS16，VS15 和 VS16 分别用于标示某字符应该显示为普通文字或者是<code>Emoji</code>，这些字符被命名为<code>U+FE00</code>（VS1）至<code>U+FE0F</code>(VS16)。选择符仅应用于前一个字符。</p>
<p>以刚才我们在装饰符号区中看到的剪刀符号✂<code>U+2702</code>为例，在它的后面加上VS16 <code>U+FE0F</code>，这个字符就变成了<code>Emoji</code>✂️，是不是很神奇</p>
<h3 id="键帽符"><a href="#键帽符" class="headerlink" title="键帽符"></a>键帽符</h3><p>看完了变体选择符后，我们紧接着会疑惑，那这个条件后面的<code>\x{20E3}</code>又是啥呢？它被称为<code>COMBINING ENCLOSING KEYCAP</code>，它对前置的字符有一定的要求，只对数字、星号和井号生效，也就是说仅仅支持<code>*#0123456789</code>这12个字符。</p>
<p>它的规则是，当开头为这12个字符中的一个时，后面加上VS16 <code>U+FE0F</code>变成一个<code>Emoji</code>，然后在加上它<code>U+20E3</code>，这个字符就会变成一个键帽形状的字符：#️⃣ *️⃣ 0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣</p>
<h3 id="标签序列"><a href="#标签序列" class="headerlink" title="标签序列"></a>标签序列</h3><p>然后是最后一个子条件<code>[\x{E0020}-\x{E007E}]+ \x{E007F}</code>，这是一个标签序列，它由一个基础黑旗符号，一系列标签字符以及一个标签终止符组成，首先以基础黑旗符号🏴<code>U+1F3F4</code>开头，然后中间是一系列的<code>U+E0020</code>到<code>U+E007E</code>之间的字符，最后以标签终止符<code>U+E007F</code>结尾，这样就组成了一个标签序列<code>Emoji</code>。</p>
<p>目前这种<code>Emoji</code>不太常见，仅仅只有英格兰、苏格兰和威尔士的旗帜使用标签序列：</p>
<ul>
<li>🏴 + <code>U+E0067</code> + <code>U+E0062</code> + <code>U+E0065</code> + <code>U+E006E</code> + <code>U+E0067</code> + <code>U+E007F</code> = 🏴󠁧󠁢󠁥󠁮󠁧󠁿</li>
<li>🏴 + <code>U+E0067</code> + <code>U+E0062</code> + <code>U+E0073</code> + <code>U+E0063</code> + <code>U+E0074</code> + <code>U+E007F</code> = 🏴󠁧󠁢󠁳󠁣󠁴󠁿</li>
<li>🏴 + <code>U+E0067</code> + <code>U+E0062</code> + <code>U+E0077</code> + <code>U+E006C</code> + <code>U+E0073</code> + <code>U+E007F</code> = 🏴󠁧󠁢󠁷󠁬󠁳󠁿</li>
</ul>
<h3 id="零宽度连接符"><a href="#零宽度连接符" class="headerlink" title="零宽度连接符"></a>零宽度连接符</h3><p>这些子条件看完，我们再回归到正则表达式中来，可以观察到8到14行的条件和1到6行的条件其实是完全一样的，而在第7行出现了一个条件<code>\x{200D}</code>连接了这两个一样的条件，什么意思呢？</p>
<p>没错，结合本文的起因部分，我们很容易的就可以联想到，这个<code>\x{200D}</code>起到的就是连接作用，它被称为零宽度连接符（<code>ZERO-WIDTH JOINER</code>，简称<code>ZWJ</code>），通过上面正则表达式尾部的*号我们可以得知，通过这个连接符，可以连接多个<code>Emoji</code>合成新的<code>Emoji</code>，下面举几个有趣的例子：</p>
<ul>
<li>👩<code>U+1F469</code> + <code>U+200D</code> + ✈️<code>U+2708 U+FE0F</code> = 👩‍✈️</li>
<li>👨<code>U+1F468</code> + <code>U+200D</code> + 💻<code>U+1F4BB</code> = 👨‍💻</li>
<li>🐻<code>U+1F43B</code> + <code>U+200D</code> + ❄️<code>U+2744 U+FE0F</code> = 🐻‍❄️</li>
<li>🏴<code>U+1F3F4</code> + <code>U+200D</code> + ☠️<code>U+2620 U+FE0F</code> = 🏴‍☠️</li>
<li>🏳️<code>U+1F3F3 U+FE0F</code> + <code>U+200D</code> + 🌈<code>U+1F308</code> = 🏳️‍🌈</li>
</ul>
<p>以上是由两个<code>Emoji</code>组成一个新的<code>Emoji</code>的例子，而家庭以及人际关系相关的<code>Emoji</code>通常会由更多<code>Emoji</code>构成，就拿本文开头提到的例子👨‍👩‍👧‍👦，它的构成实际上是这样的：</p>
<p>👨<code>U+1F468</code> + <code>U+200D</code> + 👩<code>U+1F469</code> + 👧<code>U+1F467</code> + 👦<code>U+1F466</code> = 👨‍👩‍👧‍👦</p>
<p>这也就解释了在AI聊天机器人流式打印文字的时候，为什么会依此显示👨👩👧👦四个<code>Emoji</code>，最后突然合成一整个👨‍👩‍👧‍👦了</p>
<h1 id="Emoji字体"><a href="#Emoji字体" class="headerlink" title="Emoji字体"></a>Emoji字体</h1><p>以上便是<code>Emoji</code>构成的所有规则了，但你有没有考虑过，一般字体都是黑白的矢量图形，为什么<code>Emoji</code>会显示成图片呢？</p>
<p>操作系统一般都会内置一种<code>Emoji</code>字体，<code>MacOS</code>/<code>iOS</code>内置的是<code>Apple Color Emoji</code>字体，<code>Windows</code>内置的是<code>Segoe UI Emoji</code>字体，<code>Android</code>内置的是<code>Noto Color Emoji</code>字体。这也是同一个<code>Emoji</code>再不同的设备上长得不一样的原因，除此之外，很多应用也会自带<code>Emoji</code>字体，比如<code>WhatsApp</code>、<code>Twitter</code>和<code>Facebook</code></p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_Apple_Color_Emoji.png" alt="Apple Color Emoji"></p>
<p><img src="https://github.com/dreamgyf/ImageStorage/raw/master/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98_%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%9A%84Emoji%E6%A0%B7%E5%BC%8F.png" alt="不同平台下的Emoji样式"></p>
<h1 id="回归初心，如何解决流式打印问题"><a href="#回归初心，如何解决流式打印问题" class="headerlink" title="回归初心，如何解决流式打印问题"></a>回归初心，如何解决流式打印问题</h1><p>最后，让我们回到本文的出发点，了解了<code>Emoji</code>机制后，我们该如何解决AI聊天机器人的流式打印问题呢？其实很简单，根据字符串向后做一个预测就可以了，啥叫预测？就是往后匹配，看这个字符的结构当前是否符合<code>Emoji</code>规则，以及加上后面的字符后有没有可能组成一个完整的<code>Emoji</code>，这里具体的代码我就不放了，大家自行感悟吧😊</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97" target="_blank" rel="noopener">Emoji 维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16 维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E6%8C%87%E7%A4%BA%E7%AC%A6" target="_blank" rel="noopener">区域指示符 维基百科</a></li>
<li><a href="https://tech.sina.com.cn/roll/2018-03-05/doc-ifyrztfz8047785.shtml" target="_blank" rel="noopener">总被大做文章的它从哪来？ Emoji起源和历史科普</a></li>
<li><a href="https://www.canva.cn/learn/emoji-design-and-development/" target="_blank" rel="noopener">emoji的诞生、发展背后，有哪些设计开发者的故事？</a></li>
<li><a href="https://kawo.com/cn/%E7%A4%BE%E4%BA%A4%E5%AA%92%E4%BD%93%E6%9C%AF%E8%AF%AD%E8%A1%A8/emoji" target="_blank" rel="noopener">Emoji</a></li>
<li><a href="https://liyucang-git.github.io/2019/06/17/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Unicode%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">彻底弄懂Unicode编码</a></li>
<li><a href="https://blog.hackerpie.com/posts/text-processing/character-sets-and-encoding-formats/" target="_blank" rel="noopener">Unicode？UTF-8？GBK？……聊聊字符集和字符编码格式</a></li>
<li><a href="https://taoshu.in/emoji.html" target="_blank" rel="noopener">Emoji的奥秘</a></li>
<li><a href="https://www.unicode.org/reports/tr51/" target="_blank" rel="noopener">Unicode 技术标准 #51 Emoji</a></li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul>
<li><a href="https://apps.timwhitlock.info/emoji/tables/unicode" target="_blank" rel="noopener">Emoji Unicode Tables</a></li>
<li><a href="https://apps.timwhitlock.info/unicode/inspect" target="_blank" rel="noopener">Unicode character inspector</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/10/25/interview/2023%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85/">2023小红书Android面试之旅</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-10-25</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><ul>
<li><p>自我介绍</p>
</li>
<li><p>看你写了很多文章，拿你理解最深刻的一篇出来讲一讲</p>
<p>  讲了<code>Binder</code>相关内容</p>
</li>
<li><p><code>Binder</code>大概分了几层</p>
</li>
<li><p>哪些方法调用会涉及到<code>Binder</code>通信</p>
</li>
<li><p>大概讲一下<code>startActivity</code>的流程，包括与<code>AMS</code>的交互</p>
</li>
<li><p>全页面停留时长埋点是怎么做的</p>
<p>  我在项目中做过的内容，主要功能是计算用户在每个<code>Activity</code>的停留时长，并且支持多进程。这里的多进程支持主要是通过以<code>ContentProvider</code>作为中介，然后通过<code>ContentResolver.call</code>方法去调用它的各种方法以实现跨进程</p>
</li>
<li><p>动态权限申请是什么</p>
<p>  详见 <a href="https://juejin.cn/post/7225516176171188285" target="_blank" rel="noopener">Android动态权限申请从未如此简单</a> 这篇文章</p>
</li>
<li><p>你做的性能监测工具，<code>FPS</code>是怎么采集的</p>
</li>
<li><p>性能监测工具用在了什么场景</p>
</li>
<li><p>有没有通过这个性能监测工具去做一些优化</p>
</li>
<li><p>图片库，例如<code>Glide</code>，一般对<code>Bitmap</code>有哪些优化点</p>
</li>
<li><p>过期的<code>Bitmap</code>可以复用吗</p>
</li>
<li><p>有没有基于<code>ASM</code>插桩做过一些插件</p>
</li>
<li><p>讲了一下当时做过的一个个人项目 <a href="https://github.com/dreamgyf/FastInflate" target="_blank" rel="noopener">FastInflate</a></p>
<p>  这个项目没能达到最终的目标，但通过做这个项目学习了很多新知识，比如<code>APT</code>代码生成、阅读了<code>LayoutInflater</code>源码、<code>AppCompatDelegateImpl</code>实现的<code>LayoutInflater.Factory2</code>会极大的拖慢布局创建的速度等</p>
</li>
<li><p>怎么优化布局创建速度</p>
<p>  提示了预加载，但我当时脑抽在纠结<code>xml</code>的缓存，没想到可以提前把视图先创建好</p>
</li>
<li><p>说一下你觉得你最擅长或者了解最透的点</p>
<p>  我回答的自定义<code>View</code></p>
</li>
<li><p>解决过<code>View</code>的滑动冲突吗</p>
</li>
<li><p>讲解了一个之前写过的开源控件 <a href="https://github.com/dreamgyf/SwipeLoadingLayout" target="_blank" rel="noopener">SwipeLoadingLayout</a></p>
</li>
<li><p>一般遇到困难的解决方案是什么</p>
</li>
<li><p>算法题：<a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></p>
</li>
<li><p>反问阶段</p>
<ul>
<li><p>咱们组主要负责哪些内容</p>
</li>
<li><p>主要使用<code>Java</code>还是<code>Kotlin</code></p>
<p><code>Kotlin</code></p>
</li>
<li><p>小红书的面试一般是怎么个流程？多少轮？</p>
<p>一般三轮技术面，一轮HR面</p>
</li>
<li><p>面试完一般多久会给到结果</p>
<p>比较快，一两天的样子</p>
</li>
</ul>
</li>
</ul>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><ul>
<li><p>自我介绍</p>
</li>
<li><p>为什么这个时间节点想要出来换工作呢</p>
</li>
<li><p>在B站这些年做了什么</p>
</li>
<li><p>做了哪些基础组件</p>
<p>  讲解了一下之前写的 <a href="https://github.com/dreamgyf/SwipeLoadingLayout" target="_blank" rel="noopener">SwipeLoadingLayout</a></p>
</li>
<li><p>介绍一下<code>Android</code>的事件传递机制</p>
</li>
<li><p>你写的这个分享模块是如何设计的</p>
<p>  对外采用流式调用的形式，内部通过策略模式区分不同的平台以及分享类型，给每个平台创建了一个中间<code>Activity</code>作为分享SDK请求的发起方（<code>SDK.getApi().share()</code>）以及分享结果的接收方（<code>onActivityResult</code>），然后通过广播将分享的结果送入到分享模块内进行处理，最终调用用户设置的分享回调告知结果</p>
</li>
<li><p>看你之前在扇贝的时候有开发过一些性能监测工具，那有做过性能优化吗</p>
</li>
<li><p>你是如何收集这些性能数据的</p>
</li>
<li><p>有没有对哪方面做过一些针对性的优化</p>
</li>
<li><p><code>Android</code>系统为什么会触发ANR，它的机制是什么</p>
</li>
<li><p>有解过ANR相关的问题吗？有哪几种类型？</p>
</li>
<li><p>算法题：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></p>
</li>
<li><p><code>Queue</code>除了<code>LinkedList</code>还有哪些实现类</p>
</li>
<li><p>现在还在面其他公司吗？你自己后面职业生涯的选择是怎么样的？</p>
</li>
<li><p>给我介绍了一下团队，说我面试的这个部门应该说是小红书最核心的团队，包括主页、搜索、图文、视频等等都在部门业务范畴内，部门主要分三层，除了业务层之外还有基础架构层以及性能优化层</p>
</li>
<li><p>反问阶段</p>
<ul>
<li><p>部门分三层的话，那新人进来的话是需要从业务层做起吗？</p>
<p>  不是这样的，我们首先会考虑这个同学能干什么，然后会考虑这个同学愿意去做什么，进来后，有经验的同学也会来带你的，不会一上来就让你抗输出，总之会把人放到适合他的团队里</p>
</li>
<li><p>小红书会使用到一些跨端技术吗？</p>
<p>  会，之前在一些新的<code>App</code>上使用的<code>Flutter</code>，现在主要用的是<code>RN</code>，还会使用到一些<code>DSL</code>，这个不能算跨段。为什么在小红书社区<code>App</code>中跨端技术提及的比较少，是因为小红书<code>App</code>非常重视用户体验，对性能的要求比较高</p>
</li>
</ul>
</li>
</ul>
<h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><ul>
<li><p>自我介绍</p>
</li>
<li><p>介绍一下目前负责的业务</p>
</li>
<li><p>工作过程中有碰到过什么难题，最后是怎么解决的</p>
<p>  一开始脑抽了没想到该说什么，随便扯了一个没啥技术含量的东西，又扯了一个之前做的信号捕获的工具，后来回忆起来了，重新说了一个关于<code>DEX</code>编排的东西（主<code>DEX</code>中方法数超过65535导致打包失败，写了个脚本将一部分<code>Class</code>从主<code>DEX</code>中移除到其他DEX中）</p>
</li>
<li><p>如何设计一个头像的自定义<code>View</code>，要求使头像展示出来是一个圆形</p>
</li>
<li><p>介绍一下<code>Android</code>事件的分发流程</p>
</li>
<li><p>如何处理<code>View</code>的防误触</p>
</li>
<li><p>怎么处理滑动冲突</p>
</li>
<li><p><code>Activity</code>在<code>onCreate</code>方法中调用了<code>finish</code>方法，那它的生命周期会是怎样的</p>
</li>
<li><p>如果我想判断一个<code>Activity</code>中的一个<code>View</code>的尺寸，那我什么时候能够拿到</p>
</li>
<li><p><code>RecyclerView</code>如何实现一个吸顶效果</p>
</li>
<li><p><code>Java</code>和<code>Koltin</code>你哪个用的比较多</p>
</li>
<li><p>有用过<code>Kotlin</code>的协程吗</p>
</li>
<li><p><code>Kotlin</code>中的哪些Feature你用的多，觉得写的好呢</p>
</li>
<li><p>你是怎么理解<code>MVVM</code>的</p>
</li>
<li><p>你有用过<code>Jetpack Compose</code>吗</p>
</li>
<li><p>有用过<code>kotlin</code>中的<code>by lazy</code>和<code>lateinit</code>吗</p>
</li>
<li><p><code>kotlin</code>中怎么实现单例，怎么定义一个类的静态变量</p>
</li>
<li><p>算法题：<a href="https://leetcode.cn/problems/maximum-difference-between-increasing-elements/" target="_blank" rel="noopener">增量元素之间的最大差值</a></p>
</li>
<li><p>你这次看机会的原因是什么</p>
</li>
<li><p>反问阶段我感觉之前问的差不多了，这次就没再问什么问题了</p>
</li>
</ul>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><ul>
<li><p>现在是离职还是在职状态</p>
</li>
<li><p>介绍一下之前负责的工作</p>
</li>
<li><p>用户量怎么样</p>
</li>
<li><p>这个项目是从0到1开发的吗</p>
</li>
<li><p>这个业务有什么特点，对于客户端开发有什么挑战与困难</p>
</li>
<li><p>团队分工是怎样的</p>
</li>
<li><p>这个项目能做成现在这个样子，你自己的核心贡献有哪些</p>
</li>
<li><p>这个事情对你来说有什么收获吗</p>
</li>
<li><p>在B站的工作节奏是怎么样的</p>
</li>
<li><p>离职的原因是什么呢</p>
</li>
<li><p>你自己希望找一个什么样的环境或者什么阶段的业务</p>
</li>
<li><p>你对小红书有什么了解吗</p>
</li>
<li><p>未来两三年对于职业发展的想法</p>
</li>
<li><p>你觉得现在有什么限制了你或者你觉得你需要提升哪些部分</p>
</li>
<li><p>反问阶段</p>
<ul>
<li>问了一些作息、福利待遇之类的问题</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>小红书面试总体而言给我的体验是很好的，每轮面试后基本上都是当天就能出结果，然后约下一轮的面试。最终从一面到HR面结束出结果，一共花了9天时间，还是挺快的。二面结束后，一面的面试官加我微信说小红书目前很缺人，感兴趣的同学也可以来试试。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/09/14/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA/">Android源码分析 - Service的停止与重建</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Service/">Service</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service/">Service</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在上一篇文章 <a href="https://juejin.cn/post/7276363520554795064" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中，我们分析了一个<code>Service</code>是怎么启动的，这次我们再来看看一个<code>Service</code>是如何被停止的，什么情况下<code>Service</code>会被重建以及它的重建过程</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>由于<code>Service</code>的停止与重建在实际情况下会收到各种条件影响产生不同的情况，所以这里的流程图我也只画最简路径，以供大家参考</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E4%B8%BB%E5%8A%A8%E5%81%9C%E6%AD%A2%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service主动停止流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E4%B8%BB%E5%8A%A8%E8%A7%A3%E7%BB%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service主动解绑流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_Task%E7%A7%BB%E9%99%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Task移除流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA_service%E9%87%8D%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="service重建流程图"></p>
<h1 id="主动停止"><a href="#主动停止" class="headerlink" title="主动停止"></a>主动停止</h1><p>首先，我们来看主动停止的情况，主动停止也分三种：</p>
<ul>
<li><p><code>Service</code>自己调用<code>stopSelf</code>或<code>stopSelfResult</code>方法停止</p>
</li>
<li><p>使用<code>startService</code>启动的<code>Service</code>，使用<code>stopService</code>方法停止</p>
</li>
<li><p>使用<code>bindService</code>启动的<code>Service</code>，使用<code>unbindService</code>方法解除绑定，当没有任何<code>Client</code>和<code>Service</code>绑定时，<code>Service</code>就会自行停止</p>
</li>
</ul>
<h2 id="Service-stopSelf-或-Service-stopSelfResult"><a href="#Service-stopSelf-或-Service-stopSelfResult" class="headerlink" title="Service.stopSelf 或 Service.stopSelfResult"></a>Service.stopSelf 或 Service.stopSelfResult</h2><p><code>stopSelf</code>和<code>stopSelfResult</code>方法唯一的区别是一个没返回值，一个会返回是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Service.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopSelf(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">stopSelfResult</span><span class="params">(<span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mActivityManager.stopServiceToken(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, startId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也是直接调用了<code>AMS.stopServiceToken</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopServiceToken</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceTokenLocked(className, token, startId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>AMS</code>转手调用了<code>ActiveServices.stopServiceTokenLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stopServiceTokenLocked</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过className查找相应的ServiceRecord</span></span><br><span class="line">    <span class="comment">//在Service启动过程中调用的retrieveServiceLocked方法会查找Service，创建ServiceRecord</span></span><br><span class="line">    <span class="comment">//并将其添加到Map中，findServiceLocked方法只需要从这个Map中去获取即可</span></span><br><span class="line">    ServiceRecord r = findServiceLocked(className, token, UserHandle.getCallingUserId());</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (startId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Asked to only stop if done with all work.  Note that</span></span><br><span class="line">            <span class="comment">// to avoid leaks, we will take this as dropping all</span></span><br><span class="line">            <span class="comment">// start items up to and including this one.</span></span><br><span class="line">            <span class="comment">//查找startId所对应的已分发的启动项</span></span><br><span class="line">            ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//从已分发启动请求列表中移除</span></span><br><span class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r.deliveredStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ServiceRecord.StartItem cur = r.deliveredStarts.remove(<span class="number">0</span>);</span><br><span class="line">                    cur.removeUriPermissionsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (cur == si) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果传入的启动ID不是Service最后一次启动的ID，则不能停止服务</span></span><br><span class="line">            <span class="comment">//ps：每次启动Service，startId都会递增，初始值为1</span></span><br><span class="line">            <span class="keyword">if</span> (r.getLastStartId() != startId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//重置启动状态（重要，后文中会分析）</span></span><br><span class="line">        r.startRequested = <span class="keyword">false</span>;</span><br><span class="line">        r.callStart = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//接着停止Service</span></span><br><span class="line">        bringDownServiceIfNeededLocked(r, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="startId机制"><a href="#startId机制" class="headerlink" title="startId机制"></a>startId机制</h3><p>这里要说一下<code>Service</code>的<code>startId</code>机制，每次启动<code>Service</code>时，<code>ActiveServices.startServiceLocked</code>方法会向<code>ServiceRecord.pendingStarts</code>列表中添加一个启动项<code>ServiceRecord.StartItem</code>，构建这个启动项需要提供一个<code>startId</code>，而这个<code>startId</code>是由<code>ServiceRecord.makeNextStartId</code>生成的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeNextStartId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lastStartId++;</span><br><span class="line">    <span class="keyword">if</span> (lastStartId &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        lastStartId = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastStartId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>lastStartId</code>的初始值为 0 ，所以第一次调用这个方法，得到的<code>startId</code>就是 1 ，即<code>startId</code>是从 1 开始递增的，由于当<code>Service</code>被停止后，<code>ServiceRecord</code>会从之前的缓存Map中移除，所以下一次再启动<code>Service</code>时会重新创建<code>ServiceRecord</code>，<code>startId</code>会被重置</p>
<p>当我们调用<code>stopSelf</code>停止服务时，如果传入了大于等于 0 的<code>startId</code>，此时便会判断这个<code>startId</code>是不是最后一次启动所对应的<code>startId</code>，如果不是的话，则不能停止这个<code>Service</code></p>
<p>这个<code>startId</code>设计的意义是什么呢？我们从<code>IntentService</code>的设计中可以管中窥豹：</p>
<p><code>IntentService</code>是一个运行在另一个线程的，每次处理完任务都会自动停止的<code>Service</code>，但如果你调用多次<code>startService</code>会发现，<code>IntentService.onDestroy</code>方法只会调用一次，这是为什么呢？因为<code>IntentService</code>每次停止，调用<code>stopSelf</code>方法都是带上这次启动的<code>startId</code>的，这样如果一次性有多个启动请求，前面的任务执行完，停止时发现，此次启动请求的<code>startId</code>不是最后一个<code>startId</code>，这样就不会停止掉自身，直到最后一个任务处理完成，避免了<code>Service</code>的多次停止启动消耗系统资源</p>
<hr>
<p>接着，在这个方法的最后，调用<code>bringDownServiceIfNeededLocked</code>方法继续停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查此服务是否还被需要</span></span><br><span class="line">    <span class="comment">//在用stopSelf停止服务的这种情况下</span></span><br><span class="line">    <span class="comment">//检查的就是是否有auto-create的连接（flag为BIND_AUTO_CREATE）</span></span><br><span class="line">    <span class="comment">//如有则不能停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Are we in the process of launching?</span></span><br><span class="line">    <span class="comment">//不要停止正在启动中的Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续停止服务</span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就做了一些能否停止服务的检查，主要的停止操作都在下一个<code>bringDownServiceLocked</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//处理Client与Serivce的连接，进行断开连接以及解除绑定操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check to see if the service had been started as foreground, but being</span></span><br><span class="line">    <span class="comment">// brought down before actually showing a notification.  That is not allowed.</span></span><br><span class="line">    <span class="comment">//如果此Service是以前台服务的形式启动，并且当前还尚未成为前台服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        r.fgRequired = <span class="keyword">false</span>;</span><br><span class="line">        r.fgWaiting = <span class="keyword">false</span>;</span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//将前台服务的超时回调取消</span></span><br><span class="line">        mAm.mHandler.removeMessages(</span><br><span class="line">                ActivityManagerService.SERVICE_FOREGROUND_TIMEOUT_MSG, r);</span><br><span class="line">        <span class="comment">//这种情况直接令App崩溃，杀死应用</span></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_FOREGROUND_CRASH_MSG);</span><br><span class="line">            msg.obj = r.app;</span><br><span class="line">            msg.getData().putCharSequence(</span><br><span class="line">                ActivityManagerService.SERVICE_RECORD_KEY, r.toString());</span><br><span class="line">            mAm.mHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录销毁时间</span></span><br><span class="line">    r.destroyTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存中移除ServiceRecord</span></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    ServiceRecord found = smap.mServicesByInstanceName.remove(r.instanceName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note when this method is called by bringUpServiceLocked(), the service is not found</span></span><br><span class="line">    <span class="comment">// in mServicesByInstanceName and found will be null.</span></span><br><span class="line">    <span class="keyword">if</span> (found != <span class="keyword">null</span> &amp;&amp; found != r) &#123;</span><br><span class="line">        <span class="comment">// This is not actually the service we think is running...  this should not happen,</span></span><br><span class="line">        <span class="comment">// but if it does, fail hard.</span></span><br><span class="line">        <span class="comment">//如果找到的服务不是我们目前停止的服务，应该是一个不可能的情况</span></span><br><span class="line">        <span class="comment">//碰到这种情况，将ServiceRecord重新放回去并抛出异常</span></span><br><span class="line">        smap.mServicesByInstanceName.put(r.instanceName, found);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bringing down "</span> + r + <span class="string">" but actually running "</span></span><br><span class="line">                + found);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除ServiceRecord</span></span><br><span class="line">    smap.mServicesByIntent.remove(r.intent);</span><br><span class="line">    r.totalRestartCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">    unscheduleServiceRestartLocked(r, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also make sure it is not on the pending list.</span></span><br><span class="line">    <span class="comment">//从待启动Service列表中移除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingServices.get(i) == r) &#123;</span><br><span class="line">            mPendingServices.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭前台服务通知</span></span><br><span class="line">    cancelForegroundNotificationLocked(r);</span><br><span class="line">    <span class="comment">//对于已经成为前台服务的Service</span></span><br><span class="line">    <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">        <span class="comment">//修改应用的活动前台计数，如果计数小于等于0，将其从mActiveForegroundApps列表中移除</span></span><br><span class="line">        decActiveForegroundAppLocked(smap, r);</span><br><span class="line">        ... <span class="comment">//更新统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各种清理操作</span></span><br><span class="line">    r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">    r.foregroundId = <span class="number">0</span>;</span><br><span class="line">    r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line">    r.mAllowWhileInUsePermissionInFgs = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear start entries.</span></span><br><span class="line">    r.clearDeliveredStartsLocked();</span><br><span class="line">    r.pendingStarts.clear();</span><br><span class="line">    smap.mDelayedStartList.remove(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从ProcessRecord中移除Service记录</span></span><br><span class="line">        r.app.stopService(r);</span><br><span class="line">        <span class="comment">//更新服务进程绑定的应用uids</span></span><br><span class="line">        r.app.updateBoundClientUids();</span><br><span class="line">        <span class="comment">//允许绑定Service的应用程序管理白名单</span></span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//更新进程前台服务信息</span></span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">                <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">                <span class="comment">//添加到销毁中Service列表中</span></span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                <span class="comment">//标记正在销毁中</span></span><br><span class="line">                r.destroying = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                <span class="comment">//回到App进程，调度执行Service的stop操作</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除连接</span></span><br><span class="line">    <span class="keyword">if</span> (r.bindings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于主动停止的Service，不需要重启</span></span><br><span class="line">    <span class="keyword">if</span> (r.restarter <span class="keyword">instanceof</span> ServiceRestarter) &#123;</span><br><span class="line">        ((ServiceRestarter)r.restarter).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">    <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">    smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几件事：</p>
<ol>
<li>处理<code>Client</code>与<code>Serivce</code>的连接，进行断开连接以及解除绑定操作（具体等到后面分析<code>unbindService</code>时再说）</li>
<li>对于以前台服务形式启动，并且当前还尚未成为前台服务的<code>Service</code>，直接杀死App</li>
<li>各种重置，清理操作</li>
<li>关闭前台服务通知</li>
<li>将<code>Service</code>添加到销毁中服务列表，并调度执行停止操作，最终回调<code>Service.onDestroy</code></li>
<li>将<code>ServiceRestarter</code>内的<code>ServiceRecord</code>变量设为<code>null</code>，避免其后续重启</li>
</ol>
<p>我们重点看第5步，在这个方法中调用了<code>ActivityThread$ApplicationThread.scheduleStopService</code>去调度执行停止服务操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    sendMessage(H.STOP_SERVICE, token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也是通过<code>Handler</code>发送<code>Message</code>处理服务停止，这里最终调用的是<code>ActivityThread.handleStopService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopService</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从Service列表中取出并移除此服务</span></span><br><span class="line">    Service s = mServices.remove(token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用Service.onDestroy</span></span><br><span class="line">            s.onDestroy();</span><br><span class="line">            <span class="comment">//解绑以及清理（解除对ServiceRecord的Binder远程对象的引用）</span></span><br><span class="line">            s.detachAndCleanUp();</span><br><span class="line">            <span class="comment">//执行清理操作，具体来说就是断开其他客户端与Service的连接以及解除绑定</span></span><br><span class="line">            Context context = s.getBaseContext();</span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">                <span class="keyword">final</span> String who = s.getClassName();</span><br><span class="line">                ((ContextImpl) context).scheduleFinalCleanup(who, <span class="string">"Service"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步中会把之前的超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        token, SERVICE_DONE_EXECUTING_STOP, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to stop service "</span> + s</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里首先从<code>mServices</code>列表中取出并移除此服务，然后触发<code>Service.onDestroy</code>回调，之后还需要调用<code>ContextImpl.scheduleFinalCleanup</code>方法执行一些清理工作，这一部分的分析我们留到后面<code>unbindService</code>章节里再讲，这样，整个<code>Service</code>的停止流程就到此结束了</p>
<h2 id="stopService"><a href="#stopService" class="headerlink" title="stopService"></a>stopService</h2><p>接下来我们来看一下调用方调用<code>stopService</code>停止服务的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> stopServiceCommon(service, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stopServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//验证Intent有效性</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="comment">//跨进程处理</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//调用AMS.stopService</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().stopService(</span><br><span class="line">            mMainThread.getApplicationThread(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to stop service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里基本上是直接调用<code>AMS.stopService</code>进入系统进程处理服务停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stopService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"stopService"</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//转交给ActiveServices处理</span></span><br><span class="line">        <span class="keyword">return</span> mServices.stopServiceLocked(caller, service, resolvedType, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stopServiceLocked</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span> &amp;&amp; callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when stopping service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this service is active, make sure it is stopped.</span></span><br><span class="line">    <span class="comment">//查找相应的Service，其中入参createIfNeeded为false，所以如果从缓存中找不到ServiceRecord的话则会直接返回null</span></span><br><span class="line">    ServiceLookupResult r = retrieveServiceLocked(service, <span class="keyword">null</span>, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.record != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//接着处理停止服务</span></span><br><span class="line">                stopServiceLocked(r.record);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopServiceLocked</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service.delayed) &#123;</span><br><span class="line">        <span class="comment">// If service isn't actually running, but is being held in the</span></span><br><span class="line">        <span class="comment">// delayed list, then we need to keep it started but note that it</span></span><br><span class="line">        <span class="comment">// should be stopped once no longer delayed.</span></span><br><span class="line">        service.delayedStop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//统计信息记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置启动状态（重要，后文中会分析）</span></span><br><span class="line">    service.startRequested = <span class="keyword">false</span>;</span><br><span class="line">    service.callStart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和上文一样，停止Service</span></span><br><span class="line">    bringDownServiceIfNeededLocked(service, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里和上文中分析的以<code>stopSelf</code>方式停止服务一样，先重置启动状态，然后调用<code>bringDownServiceIfNeededLocked</code>停止服务</p>
<h2 id="unbindService"><a href="#unbindService" class="headerlink" title="unbindService"></a>unbindService</h2><p>接下来的是通过<code>bindService</code>方法，并且<code>flag</code>为<code>BIND_AUTO_CREATE</code>启动的<code>Service</code>，我们需要通过<code>unbindService</code>方法解除绑定，当最终没有任何<code>flag</code>为<code>BIND_AUTO_CREATE</code>的客户端与<code>Service</code>绑定，这个<code>Service</code>就会被停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//将ServiceDispatcher的状态设置为forgotten，之后便不再会回调ServiceConnection任何方法</span></span><br><span class="line">        IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                getOuterContext(), conn);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用AMS.unbindService方法</span></span><br><span class="line">            ActivityManager.getService().unbindService(sd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中首先调用了<code>LoadedApk.forgetServiceDispatcher</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">forgetServiceDispatcher</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceConnection c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map</span><br><span class="line">                = mServices.get(context);</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//移除ServiceDispatcher</span></span><br><span class="line">                map.remove(c);</span><br><span class="line">                <span class="comment">//清理连接并标记遗忘</span></span><br><span class="line">                sd.doForget();</span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    mServices.remove(context);</span><br><span class="line">                &#125;</span><br><span class="line">                ... <span class="comment">//debug</span></span><br><span class="line">                <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//debug</span></span><br><span class="line">        ... <span class="comment">//异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>ServiceDispatcher</code>从缓存中移除并调用<code>LoadedApk$ServiceDispatcher.doForget</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doForget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActiveConnections.size(); i++) &#123;</span><br><span class="line">            ServiceDispatcher.ConnectionInfo ci = mActiveConnections.valueAt(i);</span><br><span class="line">            ci.binder.unlinkToDeath(ci.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mActiveConnections.clear();</span><br><span class="line">        mForgotten = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将所有连接的<code>binder</code>死亡回调移除，然后清除所有连接，再将<code>mForgotten</code>标记设为<code>true</code></p>
<p>接着我们会走到<code>AMS.unbindService</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unbindService</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，将工作转交给<code>ActiveServices</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line">    IBinder binder = connection.asBinder();</span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="comment">//找不到连接记录，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历连接</span></span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ConnectionRecord r = clist.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            removeConnectionLocked(r, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//removeConnectionLocked方法会将此ConnectionRecord从连接列表中移除</span></span><br><span class="line">            <span class="comment">//如果此ConnectionRecord仍然存在的话，是一个严重的错误，这里再移除一次</span></span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">                <span class="comment">// In case it didn't get removed above, do it now.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Connection "</span> + r + <span class="string">" not removed for binder "</span> + binder);</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                    r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                            r.binding.service.app.hasClientActivities()</span><br><span class="line">                            || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新顶层应用进程优先级</span></span><br><span class="line">        mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没看到什么特别重要的逻辑，看来重点应该在<code>removeConnectionLocked</code>这个方法中了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConnectionLocked</span><span class="params">(ConnectionRecord c, ProcessRecord skipApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityServiceConnectionsHolder skipAct)</span> </span>&#123;</span><br><span class="line">    IBinder binder = c.conn.asBinder();</span><br><span class="line">    AppBindRecord b = c.binding;</span><br><span class="line">    ServiceRecord s = b.service;</span><br><span class="line">    <span class="comment">//这里的clist是ServiceRecord中的列表，和上一个方法中的clist不是一个对象</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.getConnections().get(binder);</span><br><span class="line">    <span class="comment">//移除各种连接</span></span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            s.removeConnection(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.connections.remove(c);</span><br><span class="line">    c.stopAssociation();</span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="keyword">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        c.activity.removeConnection(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line">        ... <span class="comment">//各种flag的处理</span></span><br><span class="line">        <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将连接从mServiceConnections列表中移除</span></span><br><span class="line">    <span class="comment">//这个clist才是和上一个方法是同一个对象</span></span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid,</span><br><span class="line">            s.appInfo.longVersionCode, s.instanceName, s.processName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果调用方App没有其他连接和Service绑定</span></span><br><span class="line">    <span class="comment">//则将整个AppBindRecord移除</span></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="comment">//如果服务端进程存活并且没有其他连接绑定了，同时服务还处在绑定关系中（尚未回调过Service.onUnbind）</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">                    <span class="comment">// If this service's process is not already in the cached list,</span></span><br><span class="line">                    <span class="comment">// then update it in the LRU list here because this may be causing</span></span><br><span class="line">                    <span class="comment">// it to go down there and we want it to start out near the top.</span></span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAm.updateOomAdjLocked(s.app, <span class="keyword">true</span>,</span><br><span class="line">                        OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">                <span class="comment">//标记为未绑定</span></span><br><span class="line">                b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// Assume the client doesn't want to know about a rebind;</span></span><br><span class="line">                <span class="comment">// we will deal with that later if it asks for one.</span></span><br><span class="line">                b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//回到App进程，调度执行Service的unbind操作</span></span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If unbound while waiting to start and there is no connection left in this service,</span></span><br><span class="line">        <span class="comment">// remove the pending service</span></span><br><span class="line">        <span class="keyword">if</span> (s.getConnections().isEmpty()) &#123;</span><br><span class="line">            mPendingServices.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//是否有其他含有BIND_AUTO_CREATE标记的连接</span></span><br><span class="line">            <span class="keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();</span><br><span class="line">            ... <span class="comment">//记录</span></span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="keyword">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几件事：</p>
<ol>
<li><p>执行各种移除操作</p>
</li>
<li><p>如果目标服务在此次解绑后不再有任何其他连接与其绑定，则调度执行<code>Service</code>的<code>unbind</code>操作</p>
</li>
<li><p>如果此次断开的连接的<code>flag</code>中包含<code>BIND_AUTO_CREATE</code>，则调用<code>bringDownServiceIfNeededLocked</code>尝试停止服务</p>
</li>
</ol>
<p>2、3两点都很重要，我们首先看第2点，什么情况下会在这里调度执行<code>Service</code>的<code>unbind</code>操作，前面描述的其实不是很准确，准确的来说应该是目标服务在同一个<code>IntentBindRecord</code>下，此次解绑后不再有任何其他连接与其绑定。那么什么叫同一个<code>IntentBindRecord</code>呢？这和我们启动服务传入的<code>Intent</code>有关，<code>IntentBindRecord</code>的第一次创建是在我们调用<code>bindService</code>后，走到<code>ActiveServices.bindServiceLocked</code>方法中，其中有一段代码调用了<code>ServiceRecord.retrieveAppBindingLocked</code>方法产生的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppBindRecord <span class="title">retrieveAppBindingLocked</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">    IntentBindRecord i = bindings.get(filter);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = <span class="keyword">new</span> IntentBindRecord(<span class="keyword">this</span>, filter);</span><br><span class="line">        bindings.put(filter, i);</span><br><span class="line">    &#125;</span><br><span class="line">    AppBindRecord a = i.apps.get(app);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="keyword">new</span> AppBindRecord(<span class="keyword">this</span>, i, app);</span><br><span class="line">    i.apps.put(app, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，它将我们传入的<code>Intent</code>包装成了<code>Intent.FilterComparison</code>对象，然后尝试用它作为<code>key</code>从<code>ArrayMap``bindings</code>中取获取<code>IntentBindRecord</code>，如果获取不到则会创建一个新的，那么是否是同一个<code>IntentBindRecord</code>的判断标准就是包装后的<code>Intent.FilterComparison</code>对象的<code>HashCode</code>是否相等，我们来看一下它的<code>HashCode</code>是怎样计算的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/content/Intent.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterComparison</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Intent mIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mHashCode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FilterComparison</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        mIntent = intent;</span><br><span class="line">        mHashCode = intent.filterHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHashCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAction != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mAction.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mData.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mType.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mIdentifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mIdentifier.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mPackage.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mComponent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mComponent.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCategories != <span class="keyword">null</span>) &#123;</span><br><span class="line">        code += mCategories.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，只有以上参数全部相等，才会被视为同一个<code>Intent</code>，而我们通常使用<code>Intent</code>只会设置它的<code>mComponent</code>，所以在一般情况下<code>Service</code>的<code>onBind</code>和<code>onUnbind</code>也只会触发一次（在<code>Service</code>没有被销毁的情况下）</p>
<p>接着我们来看第3点，如果此次断开的连接的<code>flag</code>中包含<code>BIND_AUTO_CREATE</code>，首先会去查询是否有其他含有<code>BIND_AUTO_CREATE</code>标记的连接，然后以此作为参数调用<code>bringDownServiceIfNeededLocked</code>尝试停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查此服务是否还被需要</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeededLocked(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Are we in the process of launching?</span></span><br><span class="line">    <span class="comment">//不要停止正在启动中的Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续停止服务</span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isServiceNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Are we still explicitly being asked to run?</span></span><br><span class="line">    <span class="comment">//Service之前是否通过startService启动过并且未stop</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is someone still bound to us keeping us running?</span></span><br><span class="line">    <span class="comment">//这里我们传入的是true</span></span><br><span class="line">    <span class="comment">//因为我们之前已经做了检查，知道了是否还有其他auto-create的连接</span></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果还有其他auto-create的连接</span></span><br><span class="line">    <span class="comment">//则此服务还被需要</span></span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，经过上述检查，如果发现此<code>Service</code>确实可以被停止了，则会调用<code>bringDownServiceLocked</code>方法停止服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断开所有连接</span></span><br><span class="line">    ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> conni = connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size(); i++) &#123;</span><br><span class="line">            ConnectionRecord cr = c.get(i);</span><br><span class="line">            <span class="comment">// There is still a connection to the service that is</span></span><br><span class="line">            <span class="comment">// being brought down.  Mark it as dead.</span></span><br><span class="line">            <span class="comment">//将服务标记为死亡</span></span><br><span class="line">            cr.serviceDead = <span class="keyword">true</span>;</span><br><span class="line">            cr.stopAssociation();</span><br><span class="line">            <span class="comment">//回调ServiceConnection各种方法</span></span><br><span class="line">            <span class="comment">//通知client服务断开连接以及死亡</span></span><br><span class="line">            cr.conn.connected(r.name, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the service that it has been unbound.</span></span><br><span class="line">    <span class="comment">//通知Service解除绑定</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needOomAdj = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//遍历所有连接，解除绑定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r.bindings.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">            <span class="comment">//如果还处在绑定关系中（尚未回调过Service.onUnbind）</span></span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">                    <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">                    bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line">                    needOomAdj = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//标记为未绑定</span></span><br><span class="line">                    ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                    ibr.requested = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//回到App进程，调度执行Service的unbind操作</span></span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    needOomAdj = <span class="keyword">false</span>;</span><br><span class="line">                    serviceProcessGoneLocked(r);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新服务端进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (needOomAdj) &#123;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>,</span><br><span class="line">                    OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//和上文相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法我们在前面分析<code>stopSelf</code>的时候说过了，这次我们只看和绑定服务有关的部分</p>
<p>首先断开所有连接，回调<code>ServiceConnection</code>各种方法，通知客户端服务断开连接以及死亡，这里需要注意的是，我们本次执行<code>unbindService</code>操作的连接已经在上一步中从<code>ServiceRecord.connections</code>列表中移除，所以并不会回调它的<code>ServiceConnection</code>的任何方法，这也是很多人对<code>unbindService</code>方法的误解（包括我自己），<code>bindService</code>方法在成功绑定服务后会回调<code>ServiceConnection.onServiceConnected</code>方法，但<code>unbindService</code>方法在成功解绑服务后并不会回调<code>ServiceConnection.onServiceDisconnected</code>以及任何其它方法，这些方法只会在<code>Service</code>被以其他方式停止（比如后面会分析的混合启动的服务如何停止）或者<code>Service</code>意外停止（比如服务端应用崩溃或被杀死）的情况才会被调用</p>
<p>所以这里处理的是断开其他的连接，我们假设一个场景，使用同一个<code>Intent</code>和两个不同的<code>ServiceConnection</code>，一个使用<code>BIND_AUTO_CREATE</code>标记，一个使用其他标记，先绑定<code>BIND_AUTO_CREATE</code>标记的<code>Service</code>，然后再绑定其他标记的<code>Service</code>，接着我们对<code>BIND_AUTO_CREATE</code>标记的<code>Serivce</code>调用<code>unbindService</code>解绑，此时就会走到这个方法中，<code>ServiceRecord.connections</code>列表中会存在那个使用其他标记的连接，然后其内部成员变量<code>conn</code>的<code>connected</code>方法，这个<code>conn</code>是一个<code>IServiceConnection</code>类型，实际上的实现类为<code>LoadedApk$ServiceDispatcher$InnerConnection</code>，最终会调用到<code>LoadedApk$ServiceDispatcher.doConnected</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//被标记为遗忘则不处理任何事情</span></span><br><span class="line">        <span class="comment">//调用unbindService就会将这个标志设为true</span></span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="comment">//如果旧的连接信息中的IBinder对象和本次调用传入的IBinder对象是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            <span class="comment">//建立一个新的连接信息</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注册Binder死亡通知</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//保存本次连接信息</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                <span class="comment">//服务已死亡，移除连接信息</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除Binder死亡通知</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="comment">//回调ServiceConnection.onServiceDisconnected</span></span><br><span class="line">    <span class="comment">//通知client之前的连接已被断开</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Service死亡需要回调ServiceConnection.onBindingDied通知client服务死亡</span></span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new viable service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        <span class="comment">//告知client已建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        <span class="comment">//当Service.onBind方法返回null，或者Service停止时</span></span><br><span class="line">        <span class="comment">//回调ServiceConnection.onNullBinding方法</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法其实我们在上一篇文章中已经说过了，不过在上一篇文章中我们关注的是<code>Service</code>绑定的部分，而这次我们关注的是解绑的部分</p>
<p>首先映入眼帘的就是对<code>mForgotten</code>变量的判断，它在客户端调用<code>unbindService</code>就会被设为<code>true</code>，然后便会直接返回，不再处理后续事项。当然，实际上执行完<code>unbindService</code>方法后，客户端与<code>Service</code>的连接会被移除，理论上应该也不会再走到这个方法里才对（这里我也感觉有点疑惑）</p>
<p>根据这段代码，我们能看出来<code>Service</code>停止后，对客户端的回调是什么：</p>
<ul>
<li><p>当<code>Service.onBind</code>方法的返回不为<code>null</code>时，此时会依次回调<code>ServiceConnection.onServiceDisconnected</code>、<code>ServiceConnection.onBindingDied</code>和<code>ServiceConnection.onNullBinding</code>方法</p>
</li>
<li><p>当<code>Service.onBind</code>方法的返回为<code>null</code>时，此时会依次回调<code>ServiceConnection.onBindingDied</code>和<code>ServiceConnection.onNullBinding</code>方法</p>
</li>
</ul>
<p>大家也可以自己写写<code>Demo</code>来检验一下我说的是否正确</p>
<p>这一步处理完后，接下来要做的便是处理<code>Service</code>那边的解绑，遍历<code>IntentBindRecord</code>列表，调用<code>ActivityThread$ApplicationThread.scheduleUnbindService</code>去调度执行服务解绑操作，这里通过<code>Handler</code>最终调用的是<code>ActivityThread.handleUnbindService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUnbindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="comment">//回调Service.onUnbind方法，如果返回值为true</span></span><br><span class="line">            <span class="comment">//当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">            <span class="keyword">boolean</span> doRebind = s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    ActivityManager.getService().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to unbind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里回调了<code>Service.onUnbind</code>方法，它的返回值表示当<code>Service</code>后面再与其他客户端建立连接时，是否需要回调<code>Service.onRebind</code>方法，但是这有一个前提，那就是<code>Service</code>中途没有被停止，具体原因以及<code>rebind</code>流程我们稍后再分析</p>
<p>到了这一步，解绑就完成了，接下来和之前在<code>stopSelf</code>章节里分析的后续流程就一样了，最终调用<code>ActivityThread.handleStopService</code>方法停止服务，还记得我们之前分析在这个方法中触发完<code>Service.onDestroy</code>回调，之后还需要调用<code>ContextImpl.scheduleFinalCleanup</code>方法吗？现在我们就来看看这个方法又做了什么事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleFinalCleanup</span><span class="params">(String who, String what)</span> </span>&#123;</span><br><span class="line">    mMainThread.scheduleContextCleanup(<span class="keyword">this</span>, who, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>mMainThread</code>就是应用的<code>ActivityThread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleContextCleanup</span><span class="params">(ContextImpl context, String who,</span></span></span><br><span class="line"><span class="function"><span class="params">        String what)</span> </span>&#123;</span><br><span class="line">    ContextCleanupInfo cci = <span class="keyword">new</span> ContextCleanupInfo();</span><br><span class="line">    cci.context = context;</span><br><span class="line">    cci.who = who;</span><br><span class="line">    cci.what = what;</span><br><span class="line">    sendMessage(H.CLEAN_UP_CONTEXT, cci);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是老样子通过<code>Handler</code>发消息，最终调用的是<code>ContextImpl.performFinalCleanup</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performFinalCleanup</span><span class="params">(String who, String what)</span> </span>&#123;</span><br><span class="line">    mPackageInfo.removeContextRegistrations(getOuterContext(), who, what);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>LoadedApk.removeContextRegistrations</code>方法执行清理操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContextRegistrations</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        String who, String what)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//清理广播接收器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; smap =</span><br><span class="line">                mServices.remove(context);</span><br><span class="line">        <span class="keyword">if</span> (smap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smap.size(); i++) &#123;</span><br><span class="line">                LoadedApk.ServiceDispatcher sd = smap.valueAt(i);</span><br><span class="line">                ... <span class="comment">//报告ServiceConnection泄露</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ActivityManager.getService().unbindService(</span><br><span class="line">                            sd.getIServiceConnection());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">                sd.doForget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mUnboundServices.remove(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能看到这里，有很多小伙伴会有疑问，为什么之前已经清理过了，这里还要再进行清理、这里为什么会有<code>ServiceConnection</code>泄露、这里为什么还要再次<code>unbindService</code>？那我们需要注意了，这里被调用的对象到底是谁？其实是<code>Service</code>的<code>Context</code>，假设我们在<code>Serivce</code>里调用<code>bindService</code>又绑定了一个其他<code>Service</code>，那这个<code>Service</code>被销毁后，它和另一个<code>Service</code>的连接怎么办？是不是就产生了泄露？为了防止这种情况，所以我们需要在<code>Service</code>销毁时调用一下这个方法解除它与其他<code>Service</code>的绑定</p>
<p>而且这个方法不仅会在这里被调用到哦，在我们之前分析过的 <a href="https://juejin.cn/post/7216142711614799930" target="_blank" rel="noopener">Android源码分析 - Activity销毁流程</a> 中，也存在它的身影，当<code>Activity</code>被销毁，走到<code>handleDestroyActivity</code>方法时，会调用到我们<code>ContextImpl.scheduleFinalCleanup</code>方法，进行广播接收器的清理以及服务的解绑</p>
<p>至此，<code>Service</code>的主动停止流程我们都分析完了，还有一些细枝末节的事情可以说一说</p>
<h1 id="rebind流程"><a href="#rebind流程" class="headerlink" title="rebind流程"></a>rebind流程</h1><p>之前我们说过，<code>rebind</code>的前提是<code>Service</code>中途没有被停止，为什么呢？带着疑问，我们来看之前没有分析的，当<code>Service.onUnbind</code>方法返回值为<code>true</code>时，会调用的<code>AMS.unbindFinished</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindFinished</span><span class="params">(IBinder token, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是转交给<code>ActiveServices</code>去实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unbindFinishedLocked</span><span class="params">(ServiceRecord r, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//服务unbind的前提就是IntentBindRecord.apps.size == 0</span></span><br><span class="line">                <span class="keyword">if</span> (b.apps.size() &gt; <span class="number">0</span> &amp;&amp; !inDestroying) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Note to tell the service the next time there is</span></span><br><span class="line">                    <span class="comment">// a new client.</span></span><br><span class="line">                    <span class="comment">//将doRebind标记置为true，下一次再次建立连接时</span></span><br><span class="line">                    <span class="comment">//服务会回调Service.onRebind方法</span></span><br><span class="line">                    b.doRebind = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据我们之前的分析，我们知道，回调<code>Service.onUnbind</code>的前提就是这个<code>Service</code>没有任何连接与其绑定了，即<code>IntentBindRecord.apps.size == 0</code>，在这个case下，这个方法会将<code>IntentBindRecord</code>的<code>doRebind</code>变量置为<code>true</code></p>
<p>此时让我们再回顾一下上一篇文章 <a href="https://juejin.cn/post/7276363520554795064#heading-10" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中分析的<code>bindService</code>流程，在<code>ActiveServices.bindServiceLocked</code>方法中有这么一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">        <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">        <span class="comment">// publish the connection.</span></span><br><span class="line">        <span class="comment">//如果服务之前就已经在运行，即Service.onBind方法已经被执行，返回的IBinder对象也已经被保存</span></span><br><span class="line">        <span class="comment">//调用LoadedApk$ServiceDispatcher$InnerConnection.connected方法</span></span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        c.conn.connected(s.name, b.intent.binder, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">        <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">        <span class="comment">// rebound, then do so.</span></span><br><span class="line">        <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">        <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">        <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">        <span class="comment">//如果服务是因这次绑定而创建的</span></span><br><span class="line">        <span class="comment">//请求执行Service.onBind方法，获取返回的IBinder对象</span></span><br><span class="line">        <span class="comment">//发布Service，回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>Service</code>被停止了，那么它相应的<code>ServiceRecord</code>会从缓存<code>mServicesByInstanceName</code>和<code>mServicesByIntent</code>中移除，那么等到重新启动<code>Service</code>时会新建出一个<code>ServiceRecord</code>，此时里面的变量全部被初始化，<code>b.intent.received == false</code>，<code>b.intent.requested == false</code>，<code>b.intent.doRebind == false</code>，在这种情况下，调用<code>requestServiceBindingLocked</code>方法的最后一个入参<code>rebind</code>为<code>false</code>，就会直接回调<code>Service.onBind</code>方法，而不会回调<code>Service.onRebind</code>方法</p>
<p>如果<code>Service</code>没有被停止，且之前有被绑定过，那么<code>b.intent.received == true</code>，代表<code>IBinder</code>对象已获取到，此时如果之前的<code>Service.onUnbind</code>回调返回值为<code>true</code>，那么这里的<code>b.intent.doRebind</code>也为<code>true</code>，再加上如果这是<code>Service</code>断开所有连接后建立的第一次连接，即<code>b.intent.apps.size() == 1</code>，那么此时调用的<code>requestServiceBindingLocked</code>方法的最后一个入参<code>rebind</code>为<code>true</code>，就会直接回调<code>Service.onRebind</code>方法，而不会回调<code>Service.onBind</code>方法</p>
<h1 id="混合启动的Service该如何停止"><a href="#混合启动的Service该如何停止" class="headerlink" title="混合启动的Service该如何停止"></a>混合启动的Service该如何停止</h1><p>单一启动方式的<code>Service</code>的停止很简单，那么混合启动的<code>Service</code>该如何停止呢？</p>
<p>何为混合启动？指的是通过<code>startService</code>方式启动<code>Service</code>并且以<code>BIND_AUTO_CREATE</code>标志调用<code>bindService</code>方法绑定<code>Service</code>，两者不分先后</p>
<p>在上面的分析中，我们注意到，不管用哪种方式停止服务，最后都会走到<code>bringDownServiceIfNeededLocked</code>方法中，在这个方法里又会调用<code>isServiceNeededLocked</code>判断是否<code>Service</code>是否被需要，那被需要的条件是什么呢？<code>Service.startRequested</code>为<code>true</code>，并且没有标志为<code>BIND_AUTO_CREATE</code>的连接绑定，那么，只要不符合这两个条件，服务自然就可以被停止了</p>
<p>没有标志为<code>BIND_AUTO_CREATE</code>的连接绑定这个简单，只需要把标记为<code>BIND_AUTO_CREATE</code>的连接全部解绑了就好，那么怎么让<code>Service.startRequested</code>为<code>false</code>呢？我们回顾一下之前对<code>stopSelf</code>和<code>stopService</code>的分析，在他们调用<code>bringDownServiceIfNeededLocked</code>方法之前，都会先将<code>Service.startRequested</code>设置为<code>false</code>，所以答案就很明显了：只要<code>unbindService</code>掉所有<code>BIND_AUTO_CREATE</code>的标志的连接，然后<code>stopService</code>就能停止掉混合启动的服务，当然你也可以先<code>stopService</code>，再<code>unbindService</code>掉所有<code>BIND_AUTO_CREATE</code>的标志的连接</p>
<h1 id="小测验"><a href="#小测验" class="headerlink" title="小测验"></a>小测验</h1><p>经过以上一系列的分析，我给大家出几个小问题：</p>
<ol>
<li><p>先通过<code>startService</code>启动服务，然后再用<code>BIND_AUTO_CREATE</code>标志<code>bindService</code>（连接1），此时，<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>在上一题的基础上，再使用一个非<code>BIND_AUTO_CREATE</code>标志<code>bindService</code>（连接2），此时，<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>此时，使用<code>unbindService</code>解绑连接1，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>此时，使用<code>unbindService</code>解绑连接2，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>接着，再使用连接1<code>bindService</code>，会发生什么？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>然后，调用<code>stopService</code>停止服务，服务真的会被停止吗？<code>Service</code>的生命周期是怎样的？连接1的<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>紧接着，再使用连接2<code>bindService</code>，会发生什么？连接2的<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
<li><p>最后，调用<code>unbindService</code>解绑连接1，会发生什么？<code>Service</code>的生命周期是怎样的？<code>ServiceConnection</code>会回调哪些方法？</p>
</li>
</ol>
<p>请大家思考片刻，可以去回顾之前的<code>Service</code>启动分析以及停止流程分析，如果以上问题能全部回答正确，证明你对<code>Service</code>已经有了一个很深刻的理解，接下来揭晓答案：</p>
<ol>
<li><p>生命周期：<code>onCreate</code> -&gt; <code>onStartCommand</code> -&gt; <code>onBind</code>，如果<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>生命周期不会发生变化，如果<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>生命周期不会发生变化，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>生命周期：<code>onUnbind</code>，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>如果之前<code>onUnbind</code>的返回值为<code>true</code>，则生命周期为：<code>onRebind</code>，否则生命周期不会发生变化，如果之前<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>不会真的被停止，生命周期不会发生变化，<code>ServiceConnection</code>不会回调任何方法</p>
</li>
<li><p>生命周期不会发生变化，如果之前<code>onBind</code>的返回值不为<code>null</code>，<code>ServiceConnection</code>会回调<code>onServiceConnected</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，<code>ServiceConnection</code>会回调<code>onNullBinding</code>方法</p>
</li>
<li><p>服务会被停止，生命周期：<code>onUnbind</code> -&gt; <code>onDestroy</code>，连接1的<code>ServiceConnection</code>不会回调任何方法，如果之前<code>onBind</code>的返回值不为<code>null</code>，连接2的<code>ServiceConnection</code>会回调<code>onServiceDisconnected</code>、<code>onBindingDied</code>以及<code>onNullBinding</code>方法，如果之前<code>onBind</code>的返回值为<code>null</code>，连接2的<code>ServiceConnection</code>会回调<code>onBindingDied</code>以及<code>onNullBinding</code>方法</p>
</li>
</ol>
<h1 id="被动停止"><a href="#被动停止" class="headerlink" title="被动停止"></a>被动停止</h1><p><code>Service</code>除了主动停止，还会因为各种情况导致被动停止</p>
<h2 id="用户手动从最近任务移除Task"><a href="#用户手动从最近任务移除Task" class="headerlink" title="用户手动从最近任务移除Task"></a>用户手动从最近任务移除Task</h2><p>注：由于各家系统对进程或任务调度策略不同，所以这里的<code>Task</code>移除逻辑和<code>Service</code>停止逻辑可能会有些许不同，我们还是以原生<code>Android</code>为准分析</p>
<p>不管用户是从最近任务划走了一个<code>Task</code>，还是点击了全部清除，最终都会走到<code>ActivityStackSupervisor.removeTaskById</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeTaskById</span><span class="params">(<span class="keyword">int</span> taskId, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过id查询Task</span></span><br><span class="line">    <span class="keyword">final</span> Task task =</span><br><span class="line">            mRootWindowContainer.anyTaskForId(taskId, MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        removeTask(task, killProcess, removeFromRecents, reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的入参，<code>killProcess</code>为<code>true</code>，如果是移除单一<code>Task</code>，那么<code>removeFromRecents</code>为<code>true</code>，如果是清除全部<code>Task</code>，那么<code>removeFromRecents</code>为<code>false</code></p>
<p>先通过<code>id</code>，使用<code>RootWindowContainer</code>查询相应的<code>Task</code>，然后再调用<code>removeTask</code>方法继续移除<code>Task</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTask</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果Task正在清理中则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (task.mInRemoveTask) &#123;</span><br><span class="line">        <span class="comment">// Prevent recursion.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记Task正在清理中</span></span><br><span class="line">    task.mInRemoveTask = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//销毁此Task下所有Activity</span></span><br><span class="line">        task.performClearTask(reason);</span><br><span class="line">        <span class="comment">//清理Task</span></span><br><span class="line">        cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents);</span><br><span class="line">        <span class="comment">//关闭屏幕固定</span></span><br><span class="line">        mService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">        <span class="comment">//通知任务栈发生变化</span></span><br><span class="line">        mService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        <span class="comment">//启动任务持久化程序，将任何挂起的任务写入磁盘</span></span><br><span class="line">        <span class="keyword">if</span> (task.isPersistable) &#123;</span><br><span class="line">            mService.notifyTaskPersisterLocked(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//取消标记</span></span><br><span class="line">        task.mInRemoveTask = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法最重要的有两个部分，一个是销毁此<code>Task</code>下所有<code>Activity</code>，对于我们本次而言不需要关注，另一个是调用<code>cleanUpRemovedTaskLocked</code>继续清理<code>Task</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanUpRemovedTaskLocked</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从最近任务列表中移除</span></span><br><span class="line">    <span class="comment">//对于清除全部Task而言，之前在RecentTasks中已经进行过移除操作了</span></span><br><span class="line">    <span class="comment">//所以传入的removeFromRecents为false</span></span><br><span class="line">    <span class="keyword">if</span> (removeFromRecents) &#123;</span><br><span class="line">        mRecentTasks.remove(task);</span><br><span class="line">    &#125;</span><br><span class="line">    ComponentName component = task.getBaseIntent().getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find any running services associated with this app and stop if needed.</span></span><br><span class="line">    <span class="comment">//清理和此Task有关联的服务</span></span><br><span class="line">    <span class="keyword">final</span> Message msg = PooledLambda.obtainMessage(ActivityManagerInternal::cleanUpServices,</span><br><span class="line">            mService.mAmInternal, task.mUserId, component, <span class="keyword">new</span> Intent(task.getBaseIntent()));</span><br><span class="line">    mService.mH.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不需要杀死进程，到这里就为止了</span></span><br><span class="line">    <span class="keyword">if</span> (!killProcess) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine if the process(es) for this task should be killed.</span></span><br><span class="line">    <span class="keyword">final</span> String pkg = component.getPackageName();</span><br><span class="line">    ArrayList&lt;Object&gt; procsToKill = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayMap&lt;String, SparseArray&lt;WindowProcessController&gt;&gt; pmap = </span><br><span class="line">            mService.mProcessNames.getMap();</span><br><span class="line">    <span class="comment">//遍历App进程，确定要杀死的进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pmap.size(); i++) &#123;</span><br><span class="line">        SparseArray&lt;WindowProcessController&gt; uids = pmap.valueAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; uids.size(); j++) &#123;</span><br><span class="line">            WindowProcessController proc = uids.valueAt(j);</span><br><span class="line">            <span class="comment">//不要杀死其他用户下的进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc.mUserId != task.mUserId) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process for a different user.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不要杀死首页进程</span></span><br><span class="line">            <span class="comment">//HomeProcess指的是含有分类为android.intent.category.HOME的进程</span></span><br><span class="line">            <span class="comment">//也就是能成为首页Launcher的进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc == mService.mHomeProcess) &#123;</span><br><span class="line">                <span class="comment">// Don't kill the home process along with tasks from the same package.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不要杀死和这个Task无关的进程</span></span><br><span class="line">            <span class="keyword">if</span> (!proc.mPkgList.contains(pkg)) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process that is not associated with this task.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果这个进程有Activity在不同的Task里，并且这个Task也在最近任务里</span></span><br><span class="line">            <span class="comment">//或者有Activity还没有被停止，则不要杀死进程</span></span><br><span class="line">            <span class="keyword">if</span> (!proc.shouldKillProcessForRemovedTask(task)) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process(es) that has an activity in a different task that is also</span></span><br><span class="line">                <span class="comment">// in recents, or has an activity not stopped.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有前台服务的话不要杀死进程</span></span><br><span class="line">            <span class="keyword">if</span> (proc.hasForegroundServices()) &#123;</span><br><span class="line">                <span class="comment">// Don't kill process(es) with foreground service.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Add process to kill list.</span></span><br><span class="line">            procsToKill.add(proc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kill the running processes. Post on handle since we don't want to hold the service lock</span></span><br><span class="line">    <span class="comment">// while calling into AM.</span></span><br><span class="line">    <span class="comment">//杀死进程</span></span><br><span class="line">    <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(</span><br><span class="line">            ActivityManagerInternal::killProcessesForRemovedTask, mService.mAmInternal,</span><br><span class="line">            procsToKill);</span><br><span class="line">    mService.mH.sendMessage(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做两件事，一是清理和此<code>Task</code>有关联的服务，二是杀死应该杀死的进程</p>
<p>清理服务这一步用到了池化技术，这里大家不用管，就当做调用了<code>mService.mAmInternal.cleanUpServices</code>即可，这里的<code>mService.mAmInternal</code>是<code>AMS</code>里的一个内部类<code>LocalService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUpServices</span><span class="params">(<span class="keyword">int</span> userId, ComponentName component, Intent baseIntent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        mServices.cleanUpServices(userId, component, baseIntent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，关于<code>Service</code>的工作都转交给<code>ActiveServices</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanUpServices</span><span class="params">(<span class="keyword">int</span> userId, ComponentName component, Intent baseIntent)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ServiceRecord&gt; services = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//获得此用户下所有的活动Service</span></span><br><span class="line">    ArrayMap&lt;ComponentName, ServiceRecord&gt; alls = getServicesLocked(userId);</span><br><span class="line">    <span class="comment">//筛选出此Task下的所有活动Service</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = alls.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = alls.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.packageName.equals(component.getPackageName())) &#123;</span><br><span class="line">            services.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of any running services associated with the app.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = services.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = services.get(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果在manifest里设置了stopWithTask，那么会直接停止Service</span></span><br><span class="line">                stopServiceLocked(sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果没有设置stopWithTask的话，则会回调Service.onTaskRemoved方法</span></span><br><span class="line">                sr.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(sr, <span class="keyword">true</span>,</span><br><span class="line">                        sr.getLastStartId(), baseIntent, <span class="keyword">null</span>, <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span> (sr.app != <span class="keyword">null</span> &amp;&amp; sr.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We always run in the foreground, since this is called as</span></span><br><span class="line">                    <span class="comment">// part of the "remove task" UI operation.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sendServiceArgsLocked(sr, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        <span class="comment">// Ignore, keep going.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要获取到所有需要清理的<code>Service</code>记录，然后再对它们进行处理</p>
<p>对于在<code>manifest</code>文件里设置了<code>stopWithTask</code>标识的<code>Service</code>，直接调用<code>stopServiceLocked</code>方法停止服务，而对于没有这个标识的<code>Service</code>，则是增加一个启动项，接着调用<code>sendServiceArgsLocked</code>处理这个启动项</p>
<p>我们观察这个启动项的构建，第二个参数为<code>true</code>，我们可以去这个类的构造方法那里看到，第二个参数的名字为<code>_taskRemoved</code>，意思很明显了，然后根据我们在上一篇文章 <a href="https://juejin.cn/post/7276363520554795064#heading-9" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中分析的<code>sendServiceArgsLocked</code>方法可以知道，它最终会走到<code>ActivityThread.handleServiceArgs</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">        <span class="comment">//正常情况调用</span></span><br><span class="line">        res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">        s.onTaskRemoved(data.args);</span><br><span class="line">        res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，当<code>taskRemoved</code>变量为<code>true</code>时，会回调<code>Service.onTaskRemoved</code>方法</p>
<p>我们接着回到<code>cleanUpRemovedTaskLocked</code>方法中，当它清理完服务后，便会尝试杀死进程，这里面其他的判断条件我们都不用管，我们只需要关心其中的一段，有前台服务的话不要杀死进程</p>
<p>以上是我根据<code>AOSP</code>源码分析得出的结果，在模拟器上也验证通过，但在我的小米MIX4上表现却完全不是这样，大家开发时还是要以实际为准</p>
<h2 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h2><p>当内存不足时，系统会通过<code>OOM Killer</code>或<code>Low Memory Killer</code>等手段杀死各种进程，如果被杀死的进程里有<code>Service</code>正在运行，那自然也会被停止</p>
<h1 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h1><p>当<code>Service</code>所在进程被杀死后，根据<code>Service.onStartCommand</code>的返回值，系统会决定是否重建，怎么重建。我们先把其可能的返回值以及产生的结果先列出来：</p>
<ul>
<li><code>START_STICKY_COMPATIBILITY</code>：<code>targetSdkVersion</code> &lt; 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，但<code>onStartCommand</code>方法不会被执行</li>
<li><code>START_STICKY</code>：<code>targetSdkVersion</code> &gt;= 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，但此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>null</code></li>
<li><code>START_NOT_STICKY</code>：<code>Service</code>被杀后不会被重建</li>
<li><code>START_REDELIVER_INTENT</code>：<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>Service</code>被杀死前最后一次调用<code>onStartCommand</code>方法时传递的<code>Intent</code></li>
</ul>
<p>对于其返回值我们需要先了解一下是怎么处理的，这需要回顾一下上一篇文章分析的<code>handleServiceArgs</code>方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                <span class="comment">//正常情况调用</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步会根据onStartCommand的返回值，调整Service死亡重建策略</span></span><br><span class="line">                <span class="comment">//同时会把之前的启动超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里从<code>Service.onStartCommand</code>得到返回值后以其作为参数调用了<code>AMS.serviceDoneExecuting</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转交给了<code>ActiveServices.serviceDoneExecutingLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            <span class="comment">// This is a call from a service start...  take care of</span></span><br><span class="line">            <span class="comment">// book-keeping.</span></span><br><span class="line">            r.callStart = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY: &#123;</span><br><span class="line">                    <span class="comment">// We are done with the associated start arguments.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                    r.stopIfKilled = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_NOT_STICKY: &#123;</span><br><span class="line">                    <span class="comment">// We are done with the associated start arguments.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (r.getLastStartId() == startId) &#123;</span><br><span class="line">                        <span class="comment">// There is no more work, and this service</span></span><br><span class="line">                        <span class="comment">// doesn't want to hang around if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line">                    <span class="comment">// We'll keep this item until they explicitly</span></span><br><span class="line">                    <span class="comment">// call stop for it, but keep track of the fact</span></span><br><span class="line">                    <span class="comment">// that it was delivered.</span></span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        si.deliveryCount = <span class="number">0</span>;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line">                        <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line">                    <span class="comment">// Special processing for onTaskRemoved().  Don't</span></span><br><span class="line">                    <span class="comment">// impact normal onStartCommand() processing.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Unknown service start result: "</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就只看对<code>Service.onStartCommand</code>的返回值进行处理的部分</p>
<p>首先，不管返回值是什么，都会调用<code>ServiceRecord.findDeliveredStart</code>方法，只不过入参不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StartItem <span class="title">findDeliveredStart</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">boolean</span> remove)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = deliveredStarts.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        StartItem si = deliveredStarts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (si.id == id &amp;&amp; si.taskRemoved == taskRemoved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remove) deliveredStarts.remove(i);</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两个参数，不管返回值是什么，传进来的都是一样的，而第三个参数<code>remove</code>就不同了，当返回值为<code>START_REDELIVER_INTENT</code>的时候，它为<code>false</code>，其他情况都为<code>true</code>，意味着要删除这个已分发的启动项，<code>START_REDELIVER_INTENT</code>由于需要保留最后一次调用<code>onStartCommand</code>时的<code>Intent</code>，所以它不应该被删除</p>
<p>接着我们回到<code>serviceDoneExecutingLocked</code>方法，可以发现，<code>START_STICKY</code>和<code>START_STICKY_COMPATIBILITY</code>情况下的<code>ServiceRecord.stopIfKilled</code>被置为了<code>false</code>，其他则被置为了<code>true</code>，这和我们之前对结果的描述不同啊？不是说好了返回<code>START_REDELIVER_INTENT</code>也会重启吗？这是因为<code>START_REDELIVER_INTENT</code>比较特殊，它的重启不需要看<code>stopIfKilled</code>这个标志位，这个等到我们后面分析到怎么判断是否应该停止服务时就知道了</p>
<p>以上的内容我们先记下来，会在后面的重启流程中发挥作用</p>
<p>然后我们来看进程死亡后会发生什么，我们曾在之前的文章 <a href="https://juejin.cn/post/7172464885492613128#heading-7" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中提到过，当App启动时，<code>AMS</code>会为其注册一个App进程死亡回调<code>AppDeathRecipient</code>，当App进程死亡后便会回调其<code>binderDied</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</span><br><span class="line"></span><br><span class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</span><br><span class="line">            IApplicationThread thread) &#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mPid = pid;</span><br><span class="line">        mAppThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着便会调用<code>appDiedLocked</code>方法处理进程死亡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appDiedLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> pid, IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fromBinderDied, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check if this ProcessRecord is actually active for the pid.</span></span><br><span class="line">    <span class="comment">//检查pid所属ProcessRecord是否与传入ProcessRecord相符</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">        ProcessRecord curProc = mPidsSelfLocked.get(pid);</span><br><span class="line">        <span class="keyword">if</span> (curProc != app) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录电池统计信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果App进程尚未死亡的话，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (!app.killed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromBinderDied) &#123;</span><br><span class="line">            killProcessQuiet(pid);</span><br><span class="line">            mProcessList.noteAppKill(app, ApplicationExitInfo.REASON_OTHER,</span><br><span class="line">                    ApplicationExitInfo.SUBREASON_UNKNOWN, reason);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessList.killProcessGroup(app.uid, pid);</span><br><span class="line">        app.killed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up already done if the process has been re-started.</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid == pid &amp;&amp; app.thread != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            app.thread.asBinder() == thread.asBinder()) &#123;</span><br><span class="line">        <span class="comment">//一般情况下非自动化测试，先置为true</span></span><br><span class="line">        <span class="keyword">boolean</span> doLowMem = app.getActiveInstrumentation() == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> doOomAdj = doLowMem;</span><br><span class="line">        <span class="keyword">if</span> (!app.killedByAm) &#123; <span class="comment">//不通过AMS杀死的进程，一般就是被 Low Memory Killer (LMK) 杀死的</span></span><br><span class="line">            ... <span class="comment">//报告信息</span></span><br><span class="line">            <span class="comment">//被LMK杀死，说明系统内存不足</span></span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//通过AMS杀死的进程</span></span><br><span class="line">            <span class="comment">// Note that we always want to do oom adj to update our state with the</span></span><br><span class="line">            <span class="comment">// new number of procs.</span></span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//正常情况下非内存不足</span></span><br><span class="line">            doLowMem = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//事件记录</span></span><br><span class="line">        <span class="comment">//继续处理App进程死亡</span></span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (doOomAdj) &#123;</span><br><span class="line">            updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_PROCESS_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当因为内存不足而杀死App进程时</span></span><br><span class="line">        <span class="comment">//调用App层各处的的onLowMemory方法，释放内存</span></span><br><span class="line">        <span class="keyword">if</span> (doLowMem) &#123;</span><br><span class="line">            doLowMemReportIfNeededLocked(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) &#123; <span class="comment">//新进程已启动</span></span><br><span class="line">        <span class="comment">// A new process has already been started.</span></span><br><span class="line">        ... <span class="comment">//报告记录信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的其他代码我们都不用关心，直接看<code>handleAppDiedLocked</code>方法继续处理App进程死亡</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleAppDiedLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//清理进程的主要方法</span></span><br><span class="line">    <span class="keyword">boolean</span> kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mServices.killServicesLocked(app, allowRestart);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>ActiveServices.killServicesLocked</code>方法停止还在运行中的服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">killServicesLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clean up any connections this application has to other services.</span></span><br><span class="line">    <span class="comment">//清理所有连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ConnectionRecord r = app.connections.valueAt(i);</span><br><span class="line">        removeConnectionLocked(r, app, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    updateServiceConnectionActivitiesLocked(app);</span><br><span class="line">    app.connections.clear();</span><br><span class="line"></span><br><span class="line">    app.whitelistManager = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear app state from services.</span></span><br><span class="line">    <span class="comment">//遍历所有正在运行中的服务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.numberOfRunningServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.getRunningServiceAt(i);</span><br><span class="line">        <span class="keyword">synchronized</span> (sr.stats.getBatteryStats()) &#123;</span><br><span class="line">            sr.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sr.app != app &amp;&amp; sr.app != <span class="keyword">null</span> &amp;&amp; !sr.app.isPersistent()) &#123;</span><br><span class="line">            <span class="comment">//记录服务已停止</span></span><br><span class="line">            sr.app.stopService(sr);</span><br><span class="line">            <span class="comment">//更新绑定的客户端uids</span></span><br><span class="line">            sr.app.updateBoundClientUids();</span><br><span class="line">        &#125;</span><br><span class="line">        sr.setProcess(<span class="keyword">null</span>);</span><br><span class="line">        sr.isolatedProc = <span class="keyword">null</span>;</span><br><span class="line">        sr.executeNesting = <span class="number">0</span>;</span><br><span class="line">        sr.forceClearTracker();</span><br><span class="line">        <span class="keyword">if</span> (mDestroyingServices.remove(sr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"killServices remove destroying "</span> + sr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numClients = sr.bindings.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bindingi=numClients-<span class="number">1</span>; bindingi&gt;=<span class="number">0</span>; bindingi--) &#123;</span><br><span class="line">            IntentBindRecord b = sr.bindings.valueAt(bindingi);</span><br><span class="line">            <span class="comment">//释放对服务Binder的引用</span></span><br><span class="line">            b.binder = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//重置</span></span><br><span class="line">            b.requested = b.received = b.hasBound = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// If this binding is coming from a cached process and is asking to keep</span></span><br><span class="line">            <span class="comment">// the service created, then we'll kill the cached process as well -- we</span></span><br><span class="line">            <span class="comment">// don't want to be thrashing around restarting processes that are only</span></span><br><span class="line">            <span class="comment">// there to be cached.</span></span><br><span class="line">            ... <span class="comment">//遍历客户端进程（实际上没做任何事）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceMap smap = getServiceMapLocked(app.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now do remaining service cleanup.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.numberOfRunningServices() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.getRunningServiceAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unless the process is persistent, this process record is going away,</span></span><br><span class="line">        <span class="comment">// so make sure the service is cleaned out of it.</span></span><br><span class="line">        <span class="comment">//非持久化进程</span></span><br><span class="line">        <span class="keyword">if</span> (!app.isPersistent()) &#123;</span><br><span class="line">            <span class="comment">//记录服务已停止</span></span><br><span class="line">            app.stopService(sr);</span><br><span class="line">            <span class="comment">//更新绑定的客户端uids</span></span><br><span class="line">            app.updateBoundClientUids();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sanity check: if the service listed for the app is not one</span></span><br><span class="line">        <span class="comment">// we actually are maintaining, just let it drop.</span></span><br><span class="line">        <span class="comment">//一致性检查</span></span><br><span class="line">        <span class="keyword">final</span> ServiceRecord curRec = smap.mServicesByInstanceName.get(sr.instanceName);</span><br><span class="line">        <span class="keyword">if</span> (curRec != sr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curRec != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Service "</span> + sr + <span class="string">" in process "</span> + app</span><br><span class="line">                        + <span class="string">" not same as in map: "</span> + curRec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Any services running in the application may need to be placed</span></span><br><span class="line">        <span class="comment">// back in the pending list.</span></span><br><span class="line">        <span class="comment">//允许重启，但Service崩溃的次数超出重试上限（默认为16），并且它不是系统应用</span></span><br><span class="line">        <span class="keyword">if</span> (allowRestart &amp;&amp; sr.crashCount &gt;= mAm.mConstants.BOUND_SERVICE_MAX_CRASH_RETRY</span><br><span class="line">                &amp;&amp; (sr.serviceInfo.applicationInfo.flags</span><br><span class="line">                    &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123;</span><br><span class="line">            ... <span class="comment">//记录</span></span><br><span class="line">            <span class="comment">//停止服务</span></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowRestart</span><br><span class="line">                || !mAm.mUserController.isUserRunning(sr.userId, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//不允许重启或者服务进程所在用户不在运行，停止服务</span></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尝试调度重启服务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> scheduled = scheduleServiceRestartLocked(sr, <span class="keyword">true</span> <span class="comment">/* allowCancel */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Should the service remain running?  Note that in the</span></span><br><span class="line">            <span class="comment">// extreme case of so many attempts to deliver a command</span></span><br><span class="line">            <span class="comment">// that it failed we also will stop it here.</span></span><br><span class="line">            <span class="keyword">if</span> (!scheduled) &#123; <span class="comment">//未调度重启</span></span><br><span class="line">                <span class="comment">//停止服务</span></span><br><span class="line">                bringDownServiceLocked(sr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sr.canStopIfKilled(<span class="keyword">false</span> <span class="comment">/* isStartCanceled */</span>)) &#123;</span><br><span class="line">                <span class="comment">// Update to stopped state because the explicit start is gone. The service is</span></span><br><span class="line">                <span class="comment">// scheduled to restart for other reason (e.g. connections) so we don't bring</span></span><br><span class="line">                <span class="comment">// down it.</span></span><br><span class="line">                <span class="comment">//将服务的启动状态更新为停止</span></span><br><span class="line">                sr.startRequested = <span class="keyword">false</span>;</span><br><span class="line">                ... <span class="comment">//记录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不允许重启的话</span></span><br><span class="line">    <span class="keyword">if</span> (!allowRestart) &#123;</span><br><span class="line">        <span class="comment">//停止所有服务</span></span><br><span class="line">        app.stopAllServices();</span><br><span class="line">        <span class="comment">//清理绑定的客户端uids</span></span><br><span class="line">        app.clearBoundClientUids();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure there are no more restarting services for this process.</span></span><br><span class="line">        <span class="comment">//确保这个进程不再会重启服务，清理所有待重启待启动的服务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord r = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line">                mRestartingServices.remove(i);</span><br><span class="line">                clearRestartingIfNeededLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord r = mPendingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we have no more records on the stopping list.</span></span><br><span class="line">    <span class="comment">//清理所有停止中的服务</span></span><br><span class="line">    <span class="keyword">int</span> i = mDestroyingServices.size();</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        ServiceRecord sr = mDestroyingServices.get(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.app == app) &#123;</span><br><span class="line">            sr.forceClearTracker();</span><br><span class="line">            mDestroyingServices.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理所有执行中的服务</span></span><br><span class="line">    <span class="comment">//这里的执行中指的是有事务正在运行，比如说正在停止过程中，不是指运行中</span></span><br><span class="line">    app.executingServices.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了各种清理工作，客户端进程的清理呀，服务端进程的清理，然后就是<code>Service</code>重启的核心，<code>scheduleServiceRestartLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">scheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> allowCancel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//系统正在关机，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.mAtmInternal.isShuttingDown()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一致性检查</span></span><br><span class="line">    ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="keyword">if</span> (smap.mServicesByInstanceName.get(r.instanceName) != r) &#123;</span><br><span class="line">        ServiceRecord cur = smap.mServicesByInstanceName.get(r.instanceName);</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Attempting to schedule restart of "</span> + r</span><br><span class="line">                + <span class="string">" when found in map: "</span> + cur);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String reason;</span><br><span class="line">    <span class="keyword">if</span> ((r.serviceInfo.applicationInfo.flags</span><br><span class="line">            &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123; <span class="comment">//对于非系统应用</span></span><br><span class="line">        <span class="comment">//服务至少要过多长时间才能重启，默认1000ms</span></span><br><span class="line">        <span class="keyword">long</span> minDuration = mAm.mConstants.SERVICE_RESTART_DURATION;</span><br><span class="line">        <span class="comment">//服务被杀死重启后需要运行多长时间，默认60s</span></span><br><span class="line">        <span class="keyword">long</span> resetTime = mAm.mConstants.SERVICE_RESET_RUN_DURATION;</span><br><span class="line">        <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Any delivered but not yet finished starts should be put back</span></span><br><span class="line">        <span class="comment">// on the pending list.</span></span><br><span class="line">        <span class="comment">//对应着返回值为START_REDELIVER_INTENT的情况</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = r.deliveredStarts.size();</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ServiceRecord.StartItem si = r.deliveredStarts.get(i);</span><br><span class="line">                si.removeUriPermissionsLocked();</span><br><span class="line">                <span class="keyword">if</span> (si.intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We'll generate this again if needed.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowCancel || (si.deliveryCount &lt; ServiceRecord.MAX_DELIVERY_COUNT</span><br><span class="line">                        &amp;&amp; si.doneExecutingCount &lt; ServiceRecord.MAX_DONE_EXECUTING_COUNT)) &#123;</span><br><span class="line">                    <span class="comment">//如果该启动项的失败次数小于最大容忍次数</span></span><br><span class="line">                    <span class="comment">//MAX_DELIVERY_COUNT默认为3</span></span><br><span class="line">                    <span class="comment">//MAX_DONE_EXECUTING_COUNT默认为6</span></span><br><span class="line">                    r.pendingStarts.add(<span class="number">0</span>, si);</span><br><span class="line">                    <span class="comment">//这种情况下延时是现在距离启动时间的两倍</span></span><br><span class="line">                    <span class="keyword">long</span> dur = SystemClock.uptimeMillis() - si.deliveredTime;</span><br><span class="line">                    dur *= <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (minDuration &lt; dur) minDuration = dur;</span><br><span class="line">                    <span class="keyword">if</span> (resetTime &lt; dur) resetTime = dur;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果该启动项的失败次数大于等于最大容忍次数</span></span><br><span class="line">                    canceled = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.deliveredStarts.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowCancel) &#123;</span><br><span class="line">            <span class="comment">//判断是否应该停止（只考虑非绑定启动的情况）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> shouldStop = r.canStopIfKilled(canceled);</span><br><span class="line">            <span class="keyword">if</span> (shouldStop &amp;&amp; !r.hasAutoCreateConnections()) &#123;</span><br><span class="line">                <span class="comment">// Nothing to restart.</span></span><br><span class="line">                <span class="comment">//如果应该停止，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            reason = (r.startRequested &amp;&amp; !shouldStop) ? <span class="string">"start-requested"</span> : <span class="string">"connection"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reason = <span class="string">"always"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.totalRestartCount++;</span><br><span class="line">        <span class="keyword">if</span> (r.restartDelay == <span class="number">0</span>) &#123; <span class="comment">//第一次重启的情况</span></span><br><span class="line">            r.restartCount++;</span><br><span class="line">            r.restartDelay = minDuration;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.crashCount &gt; <span class="number">1</span>) &#123; <span class="comment">//Service所在进程在Service运行过程中发生崩溃导致重启的话</span></span><br><span class="line">            <span class="comment">//重启延时为 30min * (崩溃次数 - 1)</span></span><br><span class="line">            r.restartDelay = mAm.mConstants.BOUND_SERVICE_CRASH_RESTART_DURATION</span><br><span class="line">                    * (r.crashCount - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//非第一次重启的情况</span></span><br><span class="line">            <span class="comment">// If it has been a "reasonably long time" since the service</span></span><br><span class="line">            <span class="comment">// was started, then reset our restart duration back to</span></span><br><span class="line">            <span class="comment">// the beginning, so we don't infinitely increase the duration</span></span><br><span class="line">            <span class="comment">// on a service that just occasionally gets killed (which is</span></span><br><span class="line">            <span class="comment">// a normal case, due to process being killed to reclaim memory).</span></span><br><span class="line">            <span class="keyword">if</span> (now &gt; (r.restartTime+resetTime)) &#123;</span><br><span class="line">                <span class="comment">//如果服务重启后运行达到了一定时间，则重启延时为</span></span><br><span class="line">                r.restartCount = <span class="number">1</span>;</span><br><span class="line">                r.restartDelay = minDuration;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果服务重启后运行没有达到一定时间（短时间内又要重启）</span></span><br><span class="line">                <span class="comment">//则增长重启延时，默认因子为4</span></span><br><span class="line">                r.restartDelay *= mAm.mConstants.SERVICE_RESTART_DURATION_FACTOR;</span><br><span class="line">                <span class="keyword">if</span> (r.restartDelay &lt; minDuration) &#123;</span><br><span class="line">                    r.restartDelay = minDuration;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定重启时间</span></span><br><span class="line">        r.nextRestartTime = now + r.restartDelay;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that we don't end up restarting a bunch of services</span></span><br><span class="line">        <span class="comment">// all at the same time.</span></span><br><span class="line">        <span class="comment">//确保不会在同一时间启动大量服务</span></span><br><span class="line">        <span class="keyword">boolean</span> repeat;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            repeat = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> restartTimeBetween = mAm.mConstants.SERVICE_MIN_RESTART_TIME_BETWEEN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ServiceRecord r2 = mRestartingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (r2 != r &amp;&amp; r.nextRestartTime &gt;= (r2.nextRestartTime-restartTimeBetween)</span><br><span class="line">                        &amp;&amp; r.nextRestartTime &lt; (r2.nextRestartTime+restartTimeBetween)) &#123;</span><br><span class="line">                    r.nextRestartTime = r2.nextRestartTime + restartTimeBetween;</span><br><span class="line">                    r.restartDelay = r.nextRestartTime - now;</span><br><span class="line">                    repeat = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (repeat);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//对于系统进程，立马重启</span></span><br><span class="line">        <span class="comment">// Persistent processes are immediately restarted, so there is no</span></span><br><span class="line">        <span class="comment">// reason to hold of on restarting their services.</span></span><br><span class="line">        r.totalRestartCount++;</span><br><span class="line">        r.restartCount = <span class="number">0</span>;</span><br><span class="line">        r.restartDelay = <span class="number">0</span>;</span><br><span class="line">        r.nextRestartTime = now;</span><br><span class="line">        reason = <span class="string">"persistent"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加到重启列表中</span></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        r.createdFromFg = <span class="keyword">false</span>;</span><br><span class="line">        mRestartingServices.add(r);</span><br><span class="line">        r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消前台服务通知</span></span><br><span class="line">    cancelForegroundNotificationLocked(r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Handler调度重启</span></span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line">    mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime);</span><br><span class="line">    r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay;</span><br><span class="line">    ... <span class="comment">//事件记录</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了几件事情，一是判断服务需不需要重启，二是计算服务的下次重启时间，最后通过<code>Handler</code>执行延时重启</p>
<p>还记得我们前面说的当返回值为<code>START_REDELIVER_INTENT</code>时，不会从<code>ServiceRecord.deliveredStarts</code>中删除启动项吗？这里就体现出了这一点，遍历整个<code>deliveredStarts</code>列表，从中找出符合重启条件的启动项，将其加入到<code>pendingStarts</code>列表中，需要注意的是，在这种情况下，重启延时为现在距离启动时间的两倍，所以一般情况下<code>START_REDELIVER_INTENT</code>比<code>START_STICKY</code>重启的要更慢</p>
<p>接下来便要判断服务需不需要重启，这里调用了<code>ServiceRecord.canStopIfKilled</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canStopIfKilled</span><span class="params">(<span class="keyword">boolean</span> isStartCanceled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startRequested &amp;&amp; (stopIfKilled || isStartCanceled) &amp;&amp; pendingStarts.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说过，如果返回值为<code>START_STICKY</code>或<code>START_STICKY_COMPATIBILITY</code>，那这里的<code>stopIfKilled</code>就为<code>false</code>，所以整体会返回<code>false</code>，而对于返回值<code>START_REDELIVER_INTENT</code>而言，之前已经进行过操作，将启动项添加到<code>pendingStarts</code>列表中了，所以只要这里为<code>false</code>，整体就为<code>false</code>，<code>stopIfKilled</code>的值就不重要了</p>
<p>最后就是通过<code>Handler</code>执行延时重启了，这里<code>Handler</code>传入的<code>Runnable</code>是<code>ServiceRecord.restarter</code>，它是在服务启动，调用<code>retrieveServiceLocked</code>方法时被创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setService</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在一定的延时后，会调用到<code>performServiceRestartLocked</code>方法重启服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performServiceRestartLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isServiceNeededLocked(r, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// Paranoia: is this service actually needed?  In theory a service that is not</span></span><br><span class="line">        <span class="comment">// needed should never remain on the restart list.  In practice...  well, there</span></span><br><span class="line">        <span class="comment">// have been bugs where this happens, and bad things happen because the process</span></span><br><span class="line">        <span class="comment">// ends up just being cached, so quickly killed, then restarted again and again.</span></span><br><span class="line">        <span class="comment">// Let's not let that happen.</span></span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Restarting service that is not needed: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//参考上一篇文章，Service启动流程</span></span><br><span class="line">        bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore, it's been logged and nothing upstack cares.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了<code>bringUpServiceLocked</code>方法启动服务，这一部分可以看上一篇文章 <a href="https://juejin.cn/post/7276363520554795064" target="_blank" rel="noopener">Android源码分析 - Service启动流程</a> 中的分析，还记得上一篇文章中分析的<code>realStartServiceLocked</code>方法中，有一个逻辑是：如果<code>Service</code>已经启动，并且没有启动项，则构建一个假的启动参数供<code>onStartCommand</code>使用 吗？之前看到这个逻辑的时候我还有些疑惑为什么需要这样，现在就豁然开朗了，原来这是为<code>Service</code>重启做的逻辑，而对于返回值<code>START_REDELIVER_INTENT</code>而言，<code>pendingStarts</code>列表本身就不为空，直接正常执行启动任务就可以了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个<code>Service</code>篇章就到此结束了，通过这次的写作，我自身也是受益匪浅，了解到了很多我以前不知道的知识，也纠正了一些我以前错误的认知，如果也能帮到正在看文章的你们，那就再好不过了</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Android源码分析 - Service启动流程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Service/">Service</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service/">Service</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在之前的文章中，我们已经分析过了四大组件中<code>Activity</code>和<code>ContentProvider</code>的启动流程，这次我们就来讲讲四大组件之一的<code>Service</code>是如何启动和绑定的</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p>在查阅资料的过程中，我发现有些博主会将梳理好的流程图贴在开头，我觉得这样有助于从宏观上去理解源码的整个流程和设计理念，所以以后的文章我都会尽量将源码梳理成流程图，以便大家理解</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_startService%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="startService流程图"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_bindService%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="bindService流程图"></p>
<h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>启动<code>Service</code>有两种方式，一是<code>startService</code>，一是<code>bindService</code>，它们最终的实现都在<code>ContextImpl</code>中</p>
<h2 id="Context-startService"><a href="#Context-startService" class="headerlink" title="Context.startService"></a>Context.startService</h2><p>当<code>Service</code>通过这种方式启动后，会一直运行下去，直到外部调用了<code>stopService</code>或内部调用<code>stopSelf</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> startServiceCommon(service, <span class="keyword">false</span>, mUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, <span class="keyword">boolean</span> requireForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//确保Intent有效</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        <span class="comment">//跨进程准备</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//调用AMS.startService</span></span><br><span class="line">        ComponentName cn = ActivityManager.getService().startService(</span><br><span class="line">                mMainThread.getApplicationThread(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()), requireForeground,</span><br><span class="line">                getOpPackageName(), getAttributionTag(), user.getIdentifier());</span><br><span class="line">        <span class="comment">//通过AMS层返回的ComponentName.packageName来判断是否出错以及错误类型</span></span><br><span class="line">        <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service</span><br><span class="line">                        + <span class="string">" without permission "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + service</span><br><span class="line">                        + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"?"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，这里就是做了一下简单的校验，然后便调用了<code>AMS.startService</code>启动<code>Service</code>，最终通过返回的<code>ComponentName</code>中的<code>packageName</code>来判断是否出错以及错误类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">boolean</span> requireForeground, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方包名不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        ComponentName res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用ActiveServices.startServiceLocked方法</span></span><br><span class="line">            res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                    resolvedType, callingPid, callingUid,</span><br><span class="line">                    requireForeground, callingPackage, callingFeatureId, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，这里做了一些简单的检查，然后调用<code>ActiveServices.startServiceLocked</code>方法，<code>ActiveServices</code>是一个辅助<code>AMS</code>进行<code>Service</code>管理的类，包括<code>Service</code>的启动、绑定和停止等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired,</span><br><span class="line">            callingPackage, callingFeatureId, userId, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">boolean</span> fgRequired, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, <span class="keyword">final</span> <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowBackgroundActivityStarts)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//判断调用方是否为前台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">") when starting service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找待启动Service</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, <span class="keyword">null</span>, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//如果找不到待启动Service，直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果待启动的Service所在package和uid无法与调用方package和uid建立关联，则无法启动Service</span></span><br><span class="line">    <span class="comment">//返回异常ComponentName，由上层抛出SecurityException异常</span></span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!"</span>, res.permission != <span class="keyword">null</span></span><br><span class="line">                ? res.permission : <span class="string">"private to package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//试图用一个不存在的用户启动Service</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Trying to start service with non-existent user! "</span> + r.userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're starting indirectly (e.g. from PendingIntent), figure out whether</span></span><br><span class="line">    <span class="comment">// we're launching into an app in a background state.  This keys off of the same</span></span><br><span class="line">    <span class="comment">// idleness state tracking as e.g. O+ background service start policy.</span></span><br><span class="line">    <span class="comment">//Service所在应用未启动或处在后台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> bgLaunch = !mAm.isUidActiveLocked(r.appInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the app has strict background restrictions, we treat any bg service</span></span><br><span class="line">    <span class="comment">// start analogously to the legacy-app forced-restrictions case, regardless</span></span><br><span class="line">    <span class="comment">// of its target SDK version.</span></span><br><span class="line">    <span class="comment">//检查Service所在应用后台启动限制</span></span><br><span class="line">    <span class="keyword">boolean</span> forcedStandby = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (bgLaunch &amp;&amp; appRestrictedAnyInBackground(r.appInfo.uid, r.packageName)) &#123;</span><br><span class="line">        forcedStandby = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is a direct-to-foreground start, make sure it is allowed as per the app op.</span></span><br><span class="line">    <span class="keyword">boolean</span> forceSilentAbort = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (fgRequired) &#123; <span class="comment">//作为前台服务启动</span></span><br><span class="line">        <span class="comment">//权限检查</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mAm.getAppOpsManager().checkOpNoThrow(</span><br><span class="line">                AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName);</span><br><span class="line">        <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">            <span class="comment">//默认和允许都可以作为前台服务启动</span></span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_ALLOWED:</span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_DEFAULT:</span><br><span class="line">                <span class="comment">// All okay.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//不允许的话，回退到作为普通后台服务启动</span></span><br><span class="line">            <span class="keyword">case</span> AppOpsManager.MODE_IGNORED:</span><br><span class="line">                <span class="comment">// Not allowed, fall back to normal start service, failing siliently</span></span><br><span class="line">                <span class="comment">// if background check restricts that.</span></span><br><span class="line">                Slog.w(TAG, <span class="string">"startForegroundService not allowed due to app op: service "</span></span><br><span class="line">                        + service + <span class="string">" to "</span> + r.shortInstanceName</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid + <span class="string">" uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" pkg="</span> + callingPackage);</span><br><span class="line">                fgRequired = <span class="keyword">false</span>;</span><br><span class="line">                forceSilentAbort = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//错误的话直接返回，由上层抛出SecurityException异常</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, <span class="string">"foreground not allowed as per app op"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this isn't a direct-to-foreground start, check our ability to kick off an</span></span><br><span class="line">    <span class="comment">// arbitrary service</span></span><br><span class="line">    <span class="comment">//如果不是从前台启动</span></span><br><span class="line">    <span class="comment">//startRequested表示Service是否由startService方式所启动，fgRequired表示作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123;</span><br><span class="line">        <span class="comment">// Before going further -- if this app is not allowed to start services in the</span></span><br><span class="line">        <span class="comment">// background, then at this point we aren't going to let it period.</span></span><br><span class="line">        <span class="comment">//服务是否允许在后台启动</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> allowed = mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName,</span><br><span class="line">                r.appInfo.targetSdkVersion, callingPid, <span class="keyword">false</span>, <span class="keyword">false</span>, forcedStandby);</span><br><span class="line">        <span class="comment">//如果不允许，则无法启动服务</span></span><br><span class="line">        <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">//静默的停止启动</span></span><br><span class="line">            <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123;</span><br><span class="line">                <span class="comment">// In this case we are silently disabling the app, to disrupt as</span></span><br><span class="line">                <span class="comment">// little as possible existing apps.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (forcedStandby) &#123;</span><br><span class="line">                <span class="comment">// This is an O+ app, but we might be here because the user has placed</span></span><br><span class="line">                <span class="comment">// it under strict background restrictions.  Don't punish the app if it's</span></span><br><span class="line">                <span class="comment">// trying to do the right thing but we're denying it for that reason.</span></span><br><span class="line">                <span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This app knows it is in the new model where this operation is not</span></span><br><span class="line">            <span class="comment">// allowed, so tell it what has happened.</span></span><br><span class="line">            <span class="comment">//明确的告知不允许启动，上层抛出异常</span></span><br><span class="line">            UidRecord uidRec = mAm.mProcessList.getUidRecordLocked(r.appInfo.uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"?"</span>, <span class="string">"app is in background uid "</span> + uidRec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we've applied allowed-to-start policy based on whether this was</span></span><br><span class="line">    <span class="comment">// an ordinary startService() or a startForegroundService().  Now, only require that</span></span><br><span class="line">    <span class="comment">// the app follow through on the startForegroundService() -&gt; startForeground()</span></span><br><span class="line">    <span class="comment">// contract if it actually targets O+.</span></span><br><span class="line">    <span class="comment">//对于targetSdk 26以下（Android 8.0以下）的应用来说，不需要作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (r.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O &amp;&amp; fgRequired) &#123;</span><br><span class="line">        fgRequired = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查通过Intent被临时授权的Uris</span></span><br><span class="line">    NeededUriGrants neededGrants = mAm.mUgmInternal.checkGrantUriPermissionFromIntent(</span><br><span class="line">            service, callingUid, r.packageName, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line">    <span class="comment">// we do not start the service and launch a review activity if the calling app</span></span><br><span class="line">    <span class="comment">// is in the foreground passing it a pending intent to start the service when</span></span><br><span class="line">    <span class="comment">// review is completed.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX This is not dealing with fgRequired!</span></span><br><span class="line">    <span class="comment">//如果待启动的Service需要相应权限，则需要用户手动确认权限后，再进行启动</span></span><br><span class="line">    <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage, callingFeatureId,</span><br><span class="line">            callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">    <span class="keyword">if</span> (unscheduleServiceRestartLocked(r, callingUid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"START SERVICE WHILE RESTART PENDING: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//表示Service是否由startService方式所启动的</span></span><br><span class="line">    r.startRequested = <span class="keyword">true</span>;</span><br><span class="line">    r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否作为前台服务启动</span></span><br><span class="line">    r.fgRequired = fgRequired;</span><br><span class="line">    <span class="comment">//构造启动参数</span></span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants, callingUid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为前台服务启动</span></span><br><span class="line">    <span class="keyword">if</span> (fgRequired) &#123;</span><br><span class="line">        <span class="comment">// We are now effectively running a foreground service.</span></span><br><span class="line">        ... <span class="comment">//使用ServiceState记录</span></span><br><span class="line">        ... <span class="comment">//通过AppOpsService监控</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMapLocked(r.userId);</span><br><span class="line">    <span class="keyword">boolean</span> addToStarting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//对于后台启动的非前台服务，需要判断其是否需要延迟启动</span></span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; !fgRequired &amp;&amp; r.app == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="comment">//获取Service所处进程信息</span></span><br><span class="line">        ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//没有对应进程或进程状态级别低于 [进程在后台运行Receiver]</span></span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span> || proc.getCurProcState() &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            <span class="comment">// If this is not coming from a foreground caller, then we may want</span></span><br><span class="line">            <span class="comment">// to delay the start if there are already other background services</span></span><br><span class="line">            <span class="comment">// that are starting.  This is to avoid process start spam when lots</span></span><br><span class="line">            <span class="comment">// of applications are all handling things like connectivity broadcasts.</span></span><br><span class="line">            <span class="comment">// We only do this for cached processes, because otherwise an application</span></span><br><span class="line">            <span class="comment">// can have assumptions about calling startService() for a service to run</span></span><br><span class="line">            <span class="comment">// in its own process, and for that process to not be killed before the</span></span><br><span class="line">            <span class="comment">// service is started.  This is especially the case for receivers, which</span></span><br><span class="line">            <span class="comment">// may start a service in onReceive() to do some additional work and have</span></span><br><span class="line">            <span class="comment">// initialized some global state as part of that.</span></span><br><span class="line">            <span class="comment">//对于之前已经设置为延迟启动的服务，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">                <span class="comment">// This service is already scheduled for a delayed start; just leave</span></span><br><span class="line">                <span class="comment">// it still waiting.</span></span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前正在后台启动的Service数大于等于允许同时在后台启动的最大服务数</span></span><br><span class="line">            <span class="comment">//将这个Service设置为延迟启动</span></span><br><span class="line">            <span class="keyword">if</span> (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                <span class="comment">// Something else is starting, delay!</span></span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                r.delayed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加到正在启动服务列表中</span></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.getCurProcState() &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            <span class="comment">//进程状态为 [正在运行Service的后台进程] 或 [正在运行Receiver的后台进程] 时</span></span><br><span class="line">            <span class="comment">// We slightly loosen when we will enqueue this new service as a background</span></span><br><span class="line">            <span class="comment">// starting service we are waiting for, to also include processes that are</span></span><br><span class="line">            <span class="comment">// currently running other services or receivers.</span></span><br><span class="line">            <span class="comment">//添加到正在启动服务列表中</span></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果允许Service后台启动Activity，则将其加入到白名单中</span></span><br><span class="line">    <span class="keyword">if</span> (allowBackgroundActivityStarts) &#123;</span><br><span class="line">        r.whitelistBgActivityStartsOnServiceStart();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续启动Service</span></span><br><span class="line">    ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否允许前台服务使用while-in-use权限</span></span><br><span class="line">    <span class="keyword">if</span> (!r.mAllowWhileInUsePermissionInFgs) &#123;</span><br><span class="line">        r.mAllowWhileInUsePermissionInFgs =</span><br><span class="line">                shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, callingPid,</span><br><span class="line">                        callingUid, service, r, allowBackgroundActivityStarts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法涉及到很多前后台判断，我想这里的前后台其实分为三个概念，一是调用方App是否在前台，二是<code>Service</code>方App是否在前台，三是<code>Service</code>是否作为前台服务启动，当然，大部分情况启动的都是App内的<code>Service</code>，即一二中的前后台状态是一致的，但也不排除启动其他App的<code>Service</code>这种情况，所以这里还是需要好好区分开来</p>
<p>这个方法看起来很长，但总之都是一些<code>Service</code>启动前的预处理工作，主要做了以下几点工作：</p>
<ol>
<li>判断调用方进程是否在前台（<code>callerFg</code>）：对于调用方在后台启动的<code>Service</code>，需要判断其是否需要延迟启动</li>
<li>调用<code>retrieveServiceLocked</code>查找待启动<code>Service</code>信息（<code>ServiceRecord</code>）</li>
<li>各种检查，一旦发现不满足启动条件就终止启动<code>Service</code></li>
<li>检查<code>Service</code>所在应用的前后台状态以及后台启动限制，不符合条件则终止启动<code>Service</code></li>
<li>判断是否可以作为前台服务启动</li>
<li>如果待启动的<code>Service</code>需要相应权限，则需要用户手动确认权限后，再进行启动</li>
<li>取消之前的<code>Service</code>重启任务（如果有）</li>
<li>设置<code>ServiceRecord</code>状态，包括上次活动时间，是否由startService方式所启动的，是否作为前台服务启动等</li>
<li>如果作为前台服务启动，则需要进行记录和监控</li>
<li>对于后台启动的非前台服务，需要判断其是否需要延迟启动</li>
<li>调用<code>startServiceInnerLocked</code>继续启动<code>Service</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line">    <span class="comment">//启动前初始化</span></span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line">    ... <span class="comment">//记录</span></span><br><span class="line">    <span class="comment">//拉起服务，如果服务未启动，则会启动服务并调用其onCreate和onStartCommand方法</span></span><br><span class="line">    <span class="comment">//如果服务已启动，由于之前构造了启动参数，则会直接调用其onStartCommand方法</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123; <span class="comment">//对于后台启动服务的情况</span></span><br><span class="line">        <span class="comment">//是否为第一个后台启动的服务</span></span><br><span class="line">        <span class="keyword">boolean</span> first = smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//添加到正在后台启动服务列表中</span></span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line">        <span class="comment">//设置后台启动服务超时时间（默认15秒）</span></span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT;</span><br><span class="line">        <span class="comment">//如果为第一个后台启动的服务，则代表后面暂时没有正在后台启动的服务了</span></span><br><span class="line">        <span class="comment">//此时将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStartsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg || r.fgRequired) &#123; <span class="comment">//对于调用方进程为前台或作为前台服务启动的情况</span></span><br><span class="line">        <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">        <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        smap.ensureNotStartingBackgroundLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先会调用<code>bringUpServiceLocked</code>方法拉起服务，然后根据服务是否为前台启动，分别调用<code>ServiceMap.rescheduleDelayedStartsLocked</code>和<code>ServiceMap.ensureNotStartingBackgroundLocked</code>方法从后台延迟启动服务列表<code>mDelayedStartList</code>中不断地调度启动服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//如果Service所在的进程存在，并且其IApplicationThread也存在</span></span><br><span class="line">    <span class="comment">//说明服务已启动（因为在启动服务时，会给ServiceRecord.app赋值，并且app.thread不为null说明进程没有被杀死）</span></span><br><span class="line">    <span class="comment">//此时直接拉起Service.onStartCommand方法</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果服务正在重启中，则什么都不做，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="comment">// If waiting for a restart, then do nothing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are now bringing the service up, so no longer in the</span></span><br><span class="line">    <span class="comment">// restarting state.</span></span><br><span class="line">    <span class="comment">//Service马上启动，将其从重启中服务列表中移除，并清除其重启中状态</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this service is no longer considered delayed, we are starting it now.</span></span><br><span class="line">    <span class="comment">//走到这里，需要确保此服务不再被视为延迟启动，同时将其从延迟启动服务列表中移除</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this service is started.  If not,</span></span><br><span class="line">    <span class="comment">// we don't want to allow it to run.</span></span><br><span class="line">    <span class="comment">//确保Service所在的用户已启动</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        <span class="comment">//停止服务</span></span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Service is now being launched, its package can't be stopped.</span></span><br><span class="line">    <span class="comment">//Service即将启动，Service所属的App不该为stopped状态</span></span><br><span class="line">    <span class="comment">//将App状态置为unstopped，设置休眠状态为false</span></span><br><span class="line">    AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">            r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务所在进程是否为隔离进程，指服务是否在其自己的独立进程中运行</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    HostingRecord hostingRecord = <span class="keyword">new</span> HostingRecord(<span class="string">"service"</span>, r.instanceName);</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123; <span class="comment">//非隔离进程</span></span><br><span class="line">        <span class="comment">//获取进程的ProcessRecord对象</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">            app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats);</span><br><span class="line">            <span class="comment">//接着启动Service</span></span><br><span class="line">            realStartServiceLocked(r, app, execInFg);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//隔离进程</span></span><br><span class="line">        <span class="comment">// If this service runs in an isolated process, then each time</span></span><br><span class="line">        <span class="comment">// we call startProcessLocked() we will get a new isolated</span></span><br><span class="line">        <span class="comment">// process, starting another process if we are currently waiting</span></span><br><span class="line">        <span class="comment">// for a previous process to come up.  To deal with this, we store</span></span><br><span class="line">        <span class="comment">// in the service any current isolated process it is running in or</span></span><br><span class="line">        <span class="comment">// waiting to have come up.</span></span><br><span class="line">        <span class="comment">//获取服务之前所在的进程</span></span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">        <span class="comment">//辅助zygote进程，用于创建isolated_app进程来渲染不可信的web内容，具有最为严格的安全限制</span></span><br><span class="line">        <span class="keyword">if</span> (WebViewZygote.isMultiprocessEnabled()</span><br><span class="line">                &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byWebviewZygote(r.instanceName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//应用zygote进程，与常规zygote创建的应用相比受到更多限制</span></span><br><span class="line">        <span class="keyword">if</span> ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != <span class="number">0</span>) &#123;</span><br><span class="line">            hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName,</span><br><span class="line">                    r.definingUid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not running -- get it started, and enqueue this service record</span></span><br><span class="line">    <span class="comment">// to be executed when the app comes up.</span></span><br><span class="line">    <span class="comment">//如果Service所在进程尚未启动</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">        <span class="comment">// TODO (chriswailes): Change the Zygote policy flags based on if the launch-for-service</span></span><br><span class="line">        <span class="comment">//  was initiated from a notification tap or not.</span></span><br><span class="line">        <span class="comment">//启动App进程</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                hostingRecord, ZYGOTE_POLICY_FLAG_EMPTY, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果启动进程失败，停止服务</span></span><br><span class="line">            bringDownServiceLocked(r);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            <span class="comment">//如果是隔离进程，将这次启动的进程记录保存下来</span></span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于要启动的前台服务，加入到临时白名单，暂时绕过省电模式</span></span><br><span class="line">    <span class="keyword">if</span> (r.fgRequired) &#123;</span><br><span class="line">        mAm.tempWhitelistUidLocked(r.appInfo.uid,</span><br><span class="line">                SERVICE_START_FOREGROUND_TIMEOUT, <span class="string">"fg-service-launch"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将启动的服务添加到mPendingServices列表中</span></span><br><span class="line">    <span class="comment">//如果服务进程尚未启动，进程在启动的过程中会检查此列表并启动需要启动的Service</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Service被要求stop，停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法看起来长，其实做的事情并不多：</p>
<ol>
<li>如果<code>Service</code>已经启动，则调用<code>sendServiceArgsLocked</code>方法直接拉起<code>Service.onStartCommand</code>方法</li>
<li>各种检查准备操作（待重启、用户是否启动等，具体见注释）</li>
<li>如果<code>Service</code>所在进程已启动，调用<code>realStartServiceLocked</code>方法接着启动<code>Service</code></li>
<li>如果<code>Service</code>所在进程未启动，调用<code>AMS.startProcessLocked</code>方法启动进程</li>
<li>将要启动的<code>Service</code>添加到<code>mPendingServices</code>列表中，对于<code>Service</code>所在进程未启动的这种情况，在进程的启动过程中会检查此列表并启动需要启动的<code>Service</code>（即此<code>Service</code>）</li>
</ol>
<p>从这里可以看出来，<code>Service</code>的启动分为两个分支，一个是进程已启动，一个是进程未启动</p>
<h3 id="进程未启动"><a href="#进程未启动" class="headerlink" title="进程未启动"></a>进程未启动</h3><p>在进程未启动的情况下，这里会调用<code>AMS.startProcessLocked</code>方法启动进程，接着等待进程启动完成后，会调用到<code>AMS.attachApplicationLocked</code>方法，在这个方法中有一段关于<code>Service</code>启动的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Services等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这里调用了<code>ActiveServices.attachApplicationLocked</code>方法去启动待启动的<code>Service</code></p>
<p>关于<code>App</code>进程启动的流程详见我之前的文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> ，这里就不赘述了</p>
<h4 id="ActiveServices-attachApplicationLocked"><a href="#ActiveServices-attachApplicationLocked" class="headerlink" title="ActiveServices.attachApplicationLocked"></a>ActiveServices.attachApplicationLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the app background restriction of the caller</span></span><br><span class="line">    <span class="comment">//更新Service所在App后台限制</span></span><br><span class="line">    proc.mState.setBackgroundRestricted(appRestrictedAnyInBackground(</span><br><span class="line">            proc.uid, proc.info.packageName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Collect any services that are waiting for this process to come up.</span></span><br><span class="line">    <span class="comment">//启动mPendingServices列表内，该进程下的所有Service</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolationHostProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> IApplicationThread thread = proc.getThread();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> pid = proc.getPid();</span><br><span class="line">                <span class="keyword">final</span> UidRecord uidRecord = proc.getUidRecord();</span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                <span class="comment">//启动Service</span></span><br><span class="line">                realStartServiceLocked(sr, proc, thread, pid, uidRecord, sr.createdFromFg,</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//如果此Service不再需要了，则停止它</span></span><br><span class="line">                <span class="comment">//e.g. 通过bindService启动的服务，但此时调用bindService的Activity已死亡</span></span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeededLocked(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// We were waiting for this service to start, but it is actually no</span></span><br><span class="line">                    <span class="comment">// longer needed.  This could happen because bringDownServiceIfNeeded</span></span><br><span class="line">                    <span class="comment">// won't bring down a service that is pending...  so now the pending</span></span><br><span class="line">                    <span class="comment">// is done, so let's drop it.</span></span><br><span class="line">                    bringDownServiceLocked(sr, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Will be a no-op if nothing pending */</span></span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                mAm.updateOomAdjPendingTargetsLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Also, if there are any services that are waiting to restart and</span></span><br><span class="line">    <span class="comment">// would run in this process, now is a good time to start them.  It would</span></span><br><span class="line">    <span class="comment">// be weird to bring up the process but arbitrarily not let the services</span></span><br><span class="line">    <span class="comment">// run at this point just because their restart time hasn't come up.</span></span><br><span class="line">    <span class="comment">//App被杀重启机制，后续文章再详细说明</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会从<code>mPendingServices</code>列表内寻找该进程下的所有待启动<code>Service</code>，然后调用<code>ActiveServices.realStartServiceLocked</code>方法启动它</p>
<h3 id="进程已启动"><a href="#进程已启动" class="headerlink" title="进程已启动"></a>进程已启动</h3><p>对于进程已启动的情况，我们通过<code>ActiveServices.bringUpServiceLocked</code>方法也可以得知，调用了<code>ActiveServices.realStartServiceLocked</code>方法，所以不管进程是否启动，最终都会殊途同归走到<code>ActiveServices.realStartServiceLocked</code>方法启动<code>Service</code></p>
<h3 id="ActiveServices-realStartServiceLocked"><a href="#ActiveServices-realStartServiceLocked" class="headerlink" title="ActiveServices.realStartServiceLocked"></a>ActiveServices.realStartServiceLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note the name of this method should not be confused with the started services concept.</span></span><br><span class="line"><span class="comment"> * The "start" here means bring up the instance in the client, and this method is called</span></span><br><span class="line"><span class="comment"> * from bindService() as well.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//IApplicationThread不存在则抛移除</span></span><br><span class="line">    <span class="comment">//即确保ActivityThread存在</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为ServiceRecord设置所属进程</span></span><br><span class="line">    r.setProcess(app);</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在此进程中将Service记录为运行中</span></span><br><span class="line">    <span class="comment">//返回值为此Service是否之前未启动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.startService(r);</span><br><span class="line">    <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">    <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line">    <span class="comment">//更新进程优先级</span></span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    updateServiceForegroundLocked(r.app, <span class="comment">/* oomAdj= */</span> <span class="keyword">false</span>);</span><br><span class="line">    mAm.updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ... <span class="comment">//记录</span></span><br><span class="line">        <span class="comment">//记录信息</span></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        <span class="comment">//设置进程状态</span></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">//回到App进程，调度创建Service</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.getReportedProcState());</span><br><span class="line">        <span class="comment">//显示前台服务通知</span></span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        <span class="comment">//杀死进程</span></span><br><span class="line">        mAm.appDiedLocked(app, <span class="string">"Died when creating service"</span>);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果没能成功创建Service</span></span><br><span class="line">        <span class="keyword">if</span> (!created) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="comment">//保证executeNesting计数的准确</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cleanup.</span></span><br><span class="line">            <span class="comment">//停止服务，清除信息</span></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.stopService(r);</span><br><span class="line">                r.setProcess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Retry.</span></span><br><span class="line">            <span class="comment">//重试</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许管理白名单，如省电模式白名单</span></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行Service.onBind方法（通过bindService启动的情况下）</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加绑定到Service所在进程的UID</span></span><br><span class="line">    <span class="keyword">if</span> (newService &amp;&amp; created) &#123;</span><br><span class="line">        app.addBoundClientUidsOfNewService(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the service is in the started state, and there are no</span></span><br><span class="line">    <span class="comment">// pending arguments, then fake up one so its onStartCommand() will</span></span><br><span class="line">    <span class="comment">// be called.</span></span><br><span class="line">    <span class="comment">//如果Service已经启动，并且没有启动项，则构建一个假的启动参数供onStartCommand使用</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拉起Service.onStartCommand方法</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到这里，需要确保此服务不再被视为延迟启动，同时将其从延迟启动服务列表中移除</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        getServiceMapLocked(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Service被要求stop，停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>到了这一步，进程理应启动和初始化完成了，接下来就该实际的去创建<code>Service</code>并启动它了，首先创建<code>Service</code>这一块我们看<code>app.thread.scheduleCreateService</code>方法，这里的<code>app</code>是<code>ProcessRecord</code>，里面的<code>thread</code>是<code>IApplicationThread</code>，<code>ActivityThread</code>中的内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新进程状态</span></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//将创建Service的必要信息包装</span></span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line">    <span class="comment">//通过Handler发送Message</span></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将创建<code>Service</code>的必要信息包装成<code>CreateServiceData</code>对象后，通过<code>Handler</code>发送<code>Message</code>处理服务创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ActivityThread</code>的<code>Handler</code>在接收到<code>CREATE_SERVICE</code>消息后调用了<code>handleCreateService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    <span class="comment">//此时不要进行GC</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建Context</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        <span class="comment">//创建或获取Application（到了这里进程的初始化应该都完成了，所以是直接获取Application）</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        <span class="comment">//通过AppComponentFactory反射创建Service实例</span></span><br><span class="line">        service = packageInfo.getAppFactory()</span><br><span class="line">                .instantiateService(cl, data.info.name, data.intent);</span><br><span class="line">        <span class="comment">// Service resources must be initialized with the same loaders as the application</span></span><br><span class="line">        <span class="comment">// context.</span></span><br><span class="line">        <span class="comment">//加载资源</span></span><br><span class="line">        context.getResources().addLoaders(</span><br><span class="line">                app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManager.getService());</span><br><span class="line">        <span class="comment">//执行onCreate回调</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        <span class="comment">//保存运行中的Service</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">            <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">            ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Service</code>的创建和之前文章中所分析的<code>Activity</code>的创建流程基本一致，都是创建<code>Context</code>，通过<code>AppComponentFactory</code>反射实例化对象，然后加载资源，<code>attach</code>做绑定，最后执行<code>onCreate</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/AppComponentFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Service <span class="title">instantiateService</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className, @Nullable Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Service) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有特别在<code>AndroidManifest.xml</code>中设置<code>android:appComponentFactory</code>的话，默认的实现就是这样，通过传进来的<code>ClassLoader</code>和<code>className</code>反射实例化<code>Service</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/Service.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定BaseContext</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mThread = thread;           <span class="comment">// <span class="doctag">NOTE:</span>  unused - remove?</span></span><br><span class="line">    mClassName = className;</span><br><span class="line">    <span class="comment">//保存ServiceRecord</span></span><br><span class="line">    mToken = token;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">    <span class="comment">//启动兼容性设置</span></span><br><span class="line">    mStartCompatibility = getApplicationInfo().targetSdkVersion</span><br><span class="line">            &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">    <span class="comment">//设置内容捕获功能</span></span><br><span class="line">    setContentCaptureOptions(application.getContentCaptureOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attach</code>方法也很简单，做了一些绑定<code>Context</code>等基本操作</p>
<p>最后调用<code>onCreate</code>方法，这个方法默认是个空实现，让继承<code>Service</code>的类去实现这个方法</p>
<h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p><code>Service</code>创建完成后就该启动它了，这里对应着<code>ActiveServices.realStartServiceLocked</code>方法中调用的<code>sendServiceArgsLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//如果待启动项列表中没有内容则直接返回</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.pendingStarts.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ServiceStartArgs&gt; args = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历待启动项</span></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord.StartItem si = r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果在多个启动项中有假启动项，则跳过假启动项</span></span><br><span class="line">        <span class="comment">//但如果这个假启动项是唯一的启动项则不要跳过它，这是为了支持onStartCommand(null)的情况</span></span><br><span class="line">        <span class="keyword">if</span> (si.intent == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// If somehow we got a dummy null intent in the middle,</span></span><br><span class="line">            <span class="comment">// then skip it.  DO NOT skip a null intent when it is</span></span><br><span class="line">            <span class="comment">// the only one in the list -- this is to support the</span></span><br><span class="line">            <span class="comment">// onStartCommand(null) case.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">        r.deliveredStarts.add(si);</span><br><span class="line">        si.deliveryCount++;</span><br><span class="line">        <span class="comment">//处理Uri权限</span></span><br><span class="line">        <span class="keyword">if</span> (si.neededGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAm.mUgmInternal.grantUriPermissionUncheckedFromIntent(si.neededGrants,</span><br><span class="line">                    si.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//授权访问权限</span></span><br><span class="line">        mAm.grantImplicitAccess(r.userId, si.intent, si.callingId,</span><br><span class="line">                UserHandle.getAppId(r.appInfo.uid)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">        <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">            oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app, <span class="keyword">true</span>, OomAdjuster.OOM_ADJ_REASON_START_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是以前台服务的方式启动的Service（startForegroundService），并且之前没有设置启动前台服务超时回调</span></span><br><span class="line">        <span class="keyword">if</span> (r.fgRequired &amp;&amp; !r.fgWaiting) &#123;</span><br><span class="line">            <span class="comment">//如果当前服务还没成为前台服务，设置启动前台服务超时回调</span></span><br><span class="line">            <span class="comment">//在10s内需要调用Service.startForeground成为前台服务，否则停止服务</span></span><br><span class="line">            <span class="comment">//注：Android 11这个超时时间是10s，在后面的Android版本中这个时间有变化</span></span><br><span class="line">            <span class="keyword">if</span> (!r.isForeground) &#123;</span><br><span class="line">                scheduleServiceForegroundTransitionTimeoutLocked(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.fgRequired = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_RETRY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加启动项</span></span><br><span class="line">        args.add(<span class="keyword">new</span> ServiceStartArgs(si.taskRemoved, si.id, flags, si.intent));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建出一个支持Binder跨进程传输大量数据的列表来传输启动参数数据</span></span><br><span class="line">    ParceledListSlice&lt;ServiceStartArgs&gt; slice = <span class="keyword">new</span> ParceledListSlice&lt;&gt;(args);</span><br><span class="line">    slice.setInlineCountLimit(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//回到App进程，调度启动Service</span></span><br><span class="line">        r.app.thread.scheduleServiceArgs(r, slice);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中有几个比较重要的点需要注意：</p>
<ol>
<li><code>pendingStarts</code>中至少要有一个启动项才会执行<code>onStartCommand</code>，所以在前面的<code>ActiveServices.realStartServiceLocked</code>方法中才会有这样一段代码：如果<code>Service</code>已经启动，并且没有启动项，则构建一个假的启动参数供<code>onStartCommand</code>使用</li>
<li>如果在多个启动项中有假启动项，则跳过假启动项，但如果这个假启动项是唯一的启动项则不要跳过它，这是为了支持<code>onStartCommand</code>方法的第一个参数<code>Intent</code>未<code>null</code>的情况</li>
<li>如果服务是以前台服务的方式启动的（<code>startForegroundService</code>），如果当前服务还没成为前台服务，则需要设置一个启动前台服务的超时回调，如果在限制的时间范围内还没有成为前台服务（调用<code>Service.startForeground</code>方法），则会触发超时逻辑，停止服务，这个时间在<code>Android 11</code>上是10s，在后面的<code>Android</code>版本中有变化</li>
<li>最后将所有的启动项放到一个支持<code>Binder</code>跨进程传输大量数据的列表中，然后调用<code>App</code>进程中的<code>ActivityThread$ApplicationThread.scheduleServiceArgs</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, ParceledListSlice args)</span> </span>&#123;</span><br><span class="line">    List&lt;ServiceStartArgs&gt; list = args.getList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ServiceStartArgs ssa = list.get(i);</span><br><span class="line">        ServiceArgsData s = <span class="keyword">new</span> ServiceArgsData();</span><br><span class="line">        s.token = token;</span><br><span class="line">        s.taskRemoved = ssa.taskRemoved;</span><br><span class="line">        s.startId = ssa.startId;</span><br><span class="line">        s.flags = ssa.flags;</span><br><span class="line">        s.args = ssa.args;</span><br><span class="line"></span><br><span class="line">        sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和前面一样，这里也是将启动<code>Service</code>的必要信息包装成一个个<code>ServiceStartArgs</code>对象后，通过<code>Handler</code>依次发送<code>Message</code>处理服务启动，这里最终调用的是<code>ActivityThread.handleServiceArgs</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Intent跨进程处理</span></span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123;</span><br><span class="line">                <span class="comment">//正常情况调用</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户关闭Task栈时调用</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//确保其他异步任务执行完成</span></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                <span class="comment">//这一步会根据onStartCommand的返回值，调整Service死亡重建策略</span></span><br><span class="line">                <span class="comment">//同时会把之前的启动超时定时器取消</span></span><br><span class="line">                ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断<code>taskRemoved</code>标志，这个标志为<code>true</code>则代表用户之前从最近任务界面里划掉了这个任务栈或者在最近任务界面里点击了清理，此时会调用<code>Service.onTaskRemoved</code>方法（从最近任务界面关闭应用，进程不一定会被杀死，而且<code>Service</code>具有死亡重建机制），在正常情况下则是调用<code>Service.onStartCommand</code>处理服务启动</p>
<p>当任务执行完成后，会调用<code>AMS.serviceDoneExecuting</code>方法告知，在这个方法中会根据<code>onStartCommand</code>的返回值（或执行完<code>onTaskRemoved</code>被赋值为<code>START_TASK_REMOVED_COMPLETE</code>），调整<code>Service</code>的死亡重建策略，并且会把之前的启动超时定时器取消</p>
<p><code>onStartCommand</code>可以有以下几种返回值：</p>
<ul>
<li><code>START_STICKY_COMPATIBILITY</code>：<code>targetSdkVersion</code> &lt; 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，但<code>onStartCommand</code>方法不会被执行</li>
<li><code>START_STICKY</code>：<code>targetSdkVersion</code> &gt;= 5 (<code>Android 2.0</code>) 的App默认会返回这个，<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，但此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>null</code></li>
<li><code>START_NOT_STICKY</code>：<code>Service</code>被杀后不会被重建</li>
<li><code>START_REDELIVER_INTENT</code>：<code>Service</code>被杀后会被重建，<code>onStartCommand</code>方法也会被执行，此时<code>onStartCommand</code>方法的第一个参数<code>Intent</code>为<code>Service</code>被杀死前最后一次调用<code>onStartCommand</code>方法时传递的<code>Intent</code></li>
</ul>
<p>在这里我们只摆出结论，暂时不分析原理，如果感兴趣的话我会在后面的文章中再去详细分析</p>
<h2 id="Context-bindService"><a href="#Context-bindService" class="headerlink" title="Context.bindService"></a>Context.bindService</h2><p>到这里，<code>Service</code>通过<code>startService</code>路径的启动流程我们就基本分析完了，接着我们看另一条路径，<code>bindService</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ContextImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="keyword">null</span>, mMainThread.getHandler(), <span class="keyword">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    <span class="comment">//获取LoadedApk$ServiceDispatcher$IServiceConnection</span></span><br><span class="line">    <span class="comment">//这个类是用来后续连接建立完成后发布连接，回调ServiceConnection各种方法的</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler != <span class="keyword">null</span> &amp;&amp; executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Handler and Executor both supplied"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保Intent有效</span></span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取ActivityRecord的远程Binder对象</span></span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="comment">//targetSdkVersion &lt; 14 (Android 4.0)的情况下，如果没有设置BIND_AUTO_CREATE</span></span><br><span class="line">        <span class="comment">//则该Service的优先级将会被视为等同于后台任务</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跨进程准备</span></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//跨进程使用AMS绑定Service</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要就做了两件事：</p>
<ol>
<li>创建或获取<code>IServiceConnection</code>：这里实际获取到的是<code>LoadedApk</code>中的内部类<code>ServiceDispatcher</code>中的内部类<code>InnerConnection</code>，这个类主要是用来后面建立或断开连接后，回调<code>ServiceConnection</code>接口的各个方法的</li>
<li>跨进程调用<code>AMS.bindIsolatedService</code>方法绑定<code>Service</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindIsolatedService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String instanceName,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验调用方包名</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure that instanceName, which is caller provided, does not contain</span></span><br><span class="line">    <span class="comment">// unusual characters.</span></span><br><span class="line">    <span class="keyword">if</span> (instanceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instanceName.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = instanceName.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">                        || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'_'</span> || c == <span class="string">'.'</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal instanceName"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, instanceName, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里仅仅做了一些简单的校验，然后将绑定服务的任务转交给了<code>ActiveServices.bindServiceLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instanceName, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="comment">//获取调用方进程记录</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt; activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//token不为空表示是从Activity发起的，token实际为ActivityRecord的远程Binder对象</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取Activity与Service的连接记录</span></span><br><span class="line">        activity = mAm.mAtmInternal.getServiceConnectionsHolder(token);</span><br><span class="line">        <span class="comment">//ServiceConnectionsHolder为null说明调用方Activity不在栈中，直接异常返回</span></span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clientLabel = <span class="number">0</span>;</span><br><span class="line">    PendingIntent clientIntent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果调用方为系统级应用</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        <span class="comment">// Hacky kind of thing -- allow system stuff to tell us</span></span><br><span class="line">        <span class="comment">// what they are, so we can report this elsewhere for</span></span><br><span class="line">        <span class="comment">// others to know why certain services are running.</span></span><br><span class="line">        service.setDefusable(<span class="keyword">true</span>);</span><br><span class="line">        clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);</span><br><span class="line">        <span class="keyword">if</span> (clientIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (clientLabel != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// There are no useful extras in the intent, trash them.</span></span><br><span class="line">                <span class="comment">// System code calling with this stuff just needs to know</span></span><br><span class="line">                <span class="comment">// this will happen.</span></span><br><span class="line">                service = service.cloneFilter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像对待Activity一样对待该Service</span></span><br><span class="line">    <span class="comment">//需要校验调用方应用是否具有MANAGE_ACTIVITY_STACKS权限</span></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,</span><br><span class="line">                <span class="string">"BIND_TREAT_LIKE_ACTIVITY"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此标志仅用于系统调整IMEs（以及与顶层App密切合作的其他跨进程的用户可见组件）的调度策略，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_SCHEDULE_LIKE_TOP_APP) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Non-system caller (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") set BIND_SCHEDULE_LIKE_TOP_APP when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许绑定Service的应用程序管理白名单，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Non-system caller "</span> + caller + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许绑定到免安装应用提供的服务，仅限系统级App使用</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_INSTANT) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Non-system caller "</span> + caller + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") set BIND_ALLOW_INSTANT when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许Service后台启动Activity</span></span><br><span class="line">    <span class="comment">//需要校验调用方应用是否具有START_ACTIVITIES_FROM_BACKGROUND权限</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAm.enforceCallingPermission(</span><br><span class="line">                android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">"BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断调用方是否为前台</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allowInstant = (flags &amp; Context.BIND_ALLOW_INSTANT) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找相应的Service</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="keyword">true</span>,</span><br><span class="line">                callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line">    <span class="keyword">boolean</span> permissionsReviewRequired = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run,</span></span><br><span class="line">    <span class="comment">// we schedule binding to the service but do not start its process, then</span></span><br><span class="line">    <span class="comment">// we launch a review activity to which is passed a callback to invoke</span></span><br><span class="line">    <span class="comment">// when done to start the bound service's process to completing the binding.</span></span><br><span class="line">    <span class="comment">//如果需要用户手动确认授权</span></span><br><span class="line">    <span class="keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">            s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">        permissionsReviewRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show a permission review UI only for binding from a foreground app</span></span><br><span class="line">        <span class="comment">//只有调用方进程在前台才可以显示授权弹窗</span></span><br><span class="line">        <span class="keyword">if</span> (!callerFg) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ServiceRecord serviceRecord = s;</span><br><span class="line">        <span class="keyword">final</span> Intent serviceIntent = service;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户手动确认授权后执行的回调</span></span><br><span class="line">        RemoteCallback callback = <span class="keyword">new</span> RemoteCallback(</span><br><span class="line">                <span class="keyword">new</span> RemoteCallback.OnResultListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Bundle result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// If there is still a pending record, then the service</span></span><br><span class="line">                        <span class="comment">// binding request is still valid, so hook them up. We</span></span><br><span class="line">                        <span class="comment">// proceed only if the caller cleared the review requirement</span></span><br><span class="line">                        <span class="comment">// otherwise we unbind because the user didn't approve.</span></span><br><span class="line">                        <span class="comment">//二次检查权限</span></span><br><span class="line">                        <span class="keyword">if</span> (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                .isPermissionsReviewRequired(</span><br><span class="line">                                        serviceRecord.packageName,</span><br><span class="line">                                        serviceRecord.userId)) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//拉起服务，如果服务未创建，则会创建服务并调用其onCreate方法</span></span><br><span class="line">                                <span class="comment">//如果服务已创建则什么都不会做</span></span><br><span class="line">                                bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                        serviceIntent.getFlags(),</span><br><span class="line">                                        callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                <span class="comment">/* ignore - local call */</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//无相应权限则解绑Service</span></span><br><span class="line">                            unbindServiceLocked(connection);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        Binder.restoreCallingIdentity(identity);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_MULTIPLE_TASK</span><br><span class="line">                | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出授权弹窗</span></span><br><span class="line">        mAm.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mAm.mContext.startActivityAsUser(intent, <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取消之前的Service重启任务（如果有）</span></span><br><span class="line">        <span class="keyword">if</span> (unscheduleServiceRestartLocked(s, callerApp.info.uid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"BIND SERVICE WHILE RESTART PENDING: "</span></span><br><span class="line">                    + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//如果是第一次绑定的话，设置跟踪器</span></span><br><span class="line">            <span class="keyword">if</span> (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line">                <span class="comment">// This is the first binding, let the tracker know.</span></span><br><span class="line">                ServiceState stracker = s.getTracker();</span><br><span class="line">                <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stracker.setBound(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            s.lastActivity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定的服务代表受保护的系统组件，因此必须对其应用关联做限制</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Context.BIND_RESTRICT_ASSOCIATIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            mAm.requireAllowedAssociationsLocked(s.appInfo.packageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立调用方与服务方之间的关联</span></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName,</span><br><span class="line">                callerApp.getCurProcState(), s.appInfo.uid, s.appInfo.longVersionCode,</span><br><span class="line">                s.instanceName, s.processName);</span><br><span class="line">        <span class="comment">// Once the apps have become associated, if one of them is caller is ephemeral</span></span><br><span class="line">        <span class="comment">// the target app should now be able to see the calling app</span></span><br><span class="line">        mAm.grantImplicitAccess(callerApp.userId, service,</span><br><span class="line">                callerApp.uid, UserHandle.getAppId(s.appInfo.uid));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询App绑定信息</span></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="comment">//创建连接信息</span></span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line"></span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line">        <span class="comment">//添加连接</span></span><br><span class="line">        s.addConnection(binder, c);</span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activity.addConnection(c);</span><br><span class="line">        &#125;</span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        c.startAssociationIfNeeded();</span><br><span class="line">        <span class="comment">//表示此服务比发起绑定的应用重要性更高</span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.hasAboveClient = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//允许绑定Service的应用程序管理白名单</span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//允许Service后台启动Activity</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.setHasBindingWhitelistingBgActivityStarts(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新是否有与Service建立连接的Activity</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新连接列表</span></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            mServiceConnections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定存在就会自动创建服务</span></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//拉起服务，如果服务未创建，则会创建服务并调用其onCreate方法</span></span><br><span class="line">            <span class="comment">//如果服务已创建则什么都不会做</span></span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查是否允许前台服务使用while-in-use权限</span></span><br><span class="line">        <span class="keyword">if</span> (!s.mAllowWhileInUsePermissionInFgs) &#123;</span><br><span class="line">            s.mAllowWhileInUsePermissionInFgs =</span><br><span class="line">                    shouldAllowWhileInUsePermissionInFgsLocked(callingPackage,</span><br><span class="line">                            Binder.getCallingPid(), Binder.getCallingUid(),</span><br><span class="line">                            service, s, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新flag以及进程优先级</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">                s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// This could have made the service more important.</span></span><br><span class="line">            mAm.updateLruProcessLocked(s.app,</span><br><span class="line">                    (callerApp.hasActivitiesOrRecentTasks() &amp;&amp; s.app.hasClientActivities())</span><br><span class="line">                            || (callerApp.getCurProcState() &lt;= ActivityManager.PROCESS_STATE_TOP</span><br><span class="line">                                    &amp;&amp; (flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>),</span><br><span class="line">                    b.client);</span><br><span class="line">            mAm.updateOomAdjLocked(s.app, OomAdjuster.OOM_ADJ_REASON_BIND_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">            <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">            <span class="comment">// publish the connection.</span></span><br><span class="line">            <span class="comment">//如果服务之前就已经在运行，即Service.onBind方法已经被执行，返回的IBinder对象也已经被保存</span></span><br><span class="line">            <span class="comment">//调用LoadedApk$ServiceDispatcher$InnerConnection.connected方法</span></span><br><span class="line">            <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">            c.conn.connected(s.name, b.intent.binder, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">            <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line">            <span class="comment">//如果服务是因这次绑定而创建的</span></span><br><span class="line">            <span class="comment">//请求执行Service.onBind方法，获取返回的IBinder对象</span></span><br><span class="line">            <span class="comment">//发布Service，回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maybeLogBindCrossProfileService(userId, callingPackage, callerApp.info.uid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将此Service从正在后台启动服务列表和延迟启动服务列表中移除</span></span><br><span class="line">        <span class="comment">//如果正在后台启动服务列表中存在此服务的话，将之前设置为延迟启动的服务调度出来后台启动</span></span><br><span class="line">        getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值大于0则视为成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做的事就比较多了，我们挑重点来说：</p>
<ul>
<li><p>获取或创建各种连接记录（<code>ActivityServiceConnectionsHolder</code>、<code>AppBindRecord</code>、<code>ConnectionRecord</code>等）</p>
</li>
<li><p>校验各种<code>flags</code></p>
</li>
<li><p>查找相应的<code>Service</code></p>
</li>
<li><p>检查是否需要用户手动确认权限并弹出权限确认弹窗</p>
</li>
<li><p>向各个连接记录类中添加<code>ConnectionRecord</code>连接信息</p>
</li>
<li><p>如果<code>flags</code>设置了<code>BIND_AUTO_CREATE</code>便会调用<code>bringUpServiceLocked</code>方法尝试拉起服务，如果服务未创建，则会创建服务并调用其<code>onCreate</code>方法，如果服务已创建，则什么都不会做：这里和<code>startService</code>路径一样都调用到了<code>bringUpServiceLocked</code>方法，但最终调用的结果却不太一样，这是因为<code>startService</code>路径中，<code>ServiceRecord.startRequested</code>为<code>true</code>并且向<code>ServiceRecord.pendingStarts</code>中添加了启动项，而<code>bindService</code>路径不会向<code>ServiceRecord.pendingStarts</code>中添加启动项，并且由于<code>ServiceRecord.startRequested</code>为<code>false</code>，因此也不会去添加假的启动项，所以和<code>startService</code>不同，最终不会回调<code>Service.onStartCommand</code>方法</p>
</li>
<li><p>如果服务之前就已经在运行，则表示<code>Service.onBind</code>方法已经被执行，返回的<code>IBinder</code>对象也已经被保存，此时直接调用<code>LoadedApk$ServiceDispatcher$InnerConnection.connected</code>方法，在这个方法中会回调<code>ServiceConnection.onServiceConnected</code>方法</p>
</li>
<li><p>如果服务是因这次绑定而创建的，则调用<code>requestServiceBindingLocked</code>方法请求执行<code>Service.onBind</code>方法，获取返回的<code>IBinder</code>对象，然后发布<code>Service</code>，回调<code>ServiceConnection.onServiceConnected</code>方法</p>
</li>
<li><p>最后调用<code>ActiveServices$ServiceMap.ensureNotStartingBackgroundLocked</code>方法继续调度后台<code>Service</code>的启动</p>
</li>
</ul>
<p><code>bringUpServiceLocked</code>方法我们之前已经分析过了，我们接下来看服务创建后所要调用的<code>requestServiceBindingLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If service is not currently running, can't yet bind.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//记录Service执行操作并设置超时回调</span></span><br><span class="line">            <span class="comment">//前台服务超时时间为20s，后台服务超时时间为200s</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            <span class="comment">//设置进程状态</span></span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            <span class="comment">//回到App进程，调度执行Service的bind操作</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.getReportedProcState());</span><br><span class="line">            <span class="comment">//请求绑定完成</span></span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">            i.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前一样，这里也是调用<code>App</code>进程中的<code>ActivityThread$ApplicationThread.scheduleBindService</code>方法进行绑定操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//更新进程信息</span></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将绑定<code>Service</code>的必要信息包装成<code>BindServiceData</code>对象后，通过<code>Handler</code>依次发送<code>Message</code>处理服务启动，这里最终调用的是<code>ActivityThread.handleBindService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">//正常情况下回调Service.onBind方法，获得控制Service的IBinder对象</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">//发布Service</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当服务解绑，调用到Service.onUnbind方法时返回true，此时doRebind变量就会被赋值为true</span></span><br><span class="line">                    <span class="comment">//此时，当再次建立连接时，服务会回调Service.onRebind方法</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">                    <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法里面调用了<code>Service.onBind</code>方法，获得到了控制<code>Service</code>的<code>IBinder</code>对象，然后再调用<code>AMS.publishService</code>发布服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转交给ActiveServices处理</span></span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            <span class="comment">//获取Intent绑定记录</span></span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;</span><br><span class="line">                <span class="comment">//保存控制Service的IBinder对象</span></span><br><span class="line">                b.binder = service;</span><br><span class="line">                <span class="comment">//请求绑定完成</span></span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//IBinder对象获取完成</span></span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//遍历所有与此服务绑定的客户端连接</span></span><br><span class="line">                ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni = connections.size() - <span class="number">1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//调用LoadedApk$ServiceDispatcher$IServiceConnection.connected方法</span></span><br><span class="line">                        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">                        c.conn.connected(r.name, service, <span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Service相关任务执行完成</span></span><br><span class="line">            <span class="comment">//这一步中会把之前的启动超时定时器取消</span></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，首先将通过<code>Service.onBind</code>获得到的控制<code>Service</code>的<code>IBinder</code>对象保存在<code>IntentBindRecord</code>中，这样之后再有其他<code>client</code>绑定服务，就只需要用它作为参数回调<code>ServiceConnection.onServiceConnected</code>方法就可以了</p>
<p>接下来遍历所有与此服务绑定的客户端连接，对符合条件的连接执行<code>LoadedApk$ServiceDispatcher$IServiceConnection.connected</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/android/app/LoadedApk.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//mDispatcher是对ServiceDispatcher的弱引用</span></span><br><span class="line">    LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用ServiceDispatcher.connected方法</span></span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RunConnection里也是调用了doConnected方法</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="keyword">boolean</span> dead)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="comment">//如果旧的连接信息中的IBinder对象和本次调用传入的IBinder对象是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            <span class="comment">//建立一个新的连接信息</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//注册Binder死亡通知</span></span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                <span class="comment">//保存本次连接信息</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                <span class="comment">//服务已死亡，移除连接信息</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除Binder死亡通知</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="comment">//回调ServiceConnection.onServiceDisconnected</span></span><br><span class="line">    <span class="comment">//通知client之前的连接已被断开</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Service死亡需要回调ServiceConnection.onBindingDied通知client服务死亡</span></span><br><span class="line">    <span class="keyword">if</span> (dead) &#123;</span><br><span class="line">        mConnection.onBindingDied(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new viable service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//回调ServiceConnection.onServiceConnected方法</span></span><br><span class="line">        <span class="comment">//告知client已建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        <span class="comment">//当Service.onBind方法返回null时，回调ServiceConnection.onNullBinding方法</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法里最终执行了<code>ServiceConnection.onServiceConnected</code>回调，通知客户端已与<code>Service</code>建立连接</p>
<p>至此，整个<code>bindService</code>的流程就结束了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Service</code>的整个启动流程到这里基本上都分析完了，至于<code>Service</code>的停止，重建等流程，我将会在后面的文章中再慢慢分析</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/07/31/android/view/%E8%B0%88%E8%B0%88Android%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9C%86%E8%A7%92/">谈谈Android如何实现不同大小的圆角</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-07-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%9C%86%E8%A7%92/">圆角</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在开发过程中，设计常常会有一些比较炫酷的想法，比如两边不一样大小的圆角啦，甚至四角的<code>radius</code>各不相同，对于这种情况我们该怎么实现呢？</p>
<h1 id="背景圆角"><a href="#背景圆角" class="headerlink" title="背景圆角"></a>背景圆角</h1><h2 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h2><p>对于一般的背景，我们可以直接使用<code>shape</code>，这种方法天生支持设置四角不同的<code>radius</code>，比如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#8358FF"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomLeftRadius</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:bottomRightRadius</span>=<span class="string">"20dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:topLeftRadius</span>=<span class="string">"30dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:topRightRadius</span>=<span class="string">"40dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>小贴士：<code>shape</code>在代码层的实现为<code>GradientDrawable</code>，可以直接在代码层构建圆角背景，顺便推荐一下我写的库：<a href="https://github.com/dreamgyf/ShapeLayout" target="_blank" rel="noopener">ShapeLayout</a>，可以方便的实现<code>shape</code>背景，告别<code>xml</code></p>
<h1 id="内容圆角"><a href="#内容圆角" class="headerlink" title="内容圆角"></a>内容圆角</h1><p>很多情况下，设置背景的四边不同圆角并不能满足我们，大多数情况下，我们需要连着里面的内容一起切圆角，这里我们需要先指正一下网上的一个错误写法</p>
<p>有人发文说，可以通过<code>outline.setConvexPath</code>方法，实现四角不同<code>radius</code>，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">outline?.setConvexPath(</span><br><span class="line">    Path().apply &#123;</span><br><span class="line">        addRoundRect(</span><br><span class="line">            <span class="number">0f</span>, <span class="number">0f</span>, width.toFloat(), height.toFloat(),</span><br><span class="line">            floatArrayOf(</span><br><span class="line">                topLeftRadius,</span><br><span class="line">                topLeftRadius,</span><br><span class="line">                topRightRadius,</span><br><span class="line">                topRightRadius,</span><br><span class="line">                bottomRightRadius,</span><br><span class="line">                bottomRightRadius,</span><br><span class="line">                bottomLeftRadius,</span><br><span class="line">                bottomLeftRadius</span><br><span class="line">            ),</span><br><span class="line">            Path.Direction.CCW</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>经过实测，这样写是不行的，准确的来说，在大部分系统上是不行的（MIUI上可以，我不知道是该夸它兼容性太好了还是该吐槽它啥，我的测试机用的小米，这导致我在最后的测试阶段才发现这个问题）</p>
<p>指出错误方法后，让我们来看看正确解法有哪些</p>
<h2 id="CardView"><a href="#CardView" class="headerlink" title="CardView"></a>CardView</h2><p>说到切内容圆角，我们自然而然会去想到<code>CardView</code>，其实<code>CardView</code>的圆角也是通过<code>Outline</code>实现的</p>
<p>有人可能要问了，<code>CardView</code>不是只支持四角相同<code>radius</code>吗？别急，且看我灵机一动想出来的神奇嵌套大法</p>
<h3 id="神奇嵌套大法"><a href="#神奇嵌套大法" class="headerlink" title="神奇嵌套大法"></a>神奇嵌套大法</h3><p>既然一个<code>CardView</code>只能设一个<code>radius</code>，那我多用几个<code>CardView</code>嵌套是否能解决问题呢？</p>
<p>举个最简单的例子，比如说设计想要上半部分为<code>12dp</code>的圆角，下半部分没有圆角，我们需要一个辅助<code>View</code>，让他的顶部和父布局的底部对齐，然后设置成圆角大小的高度或者<code>margin</code>，接着使用<code>CardView</code>，让它的底部对齐这个辅助<code>View</code>的底部，再设置一个圆角大小的<code>padding</code>，这样，由于<code>CardView</code>超出了父布局的边界，所以底部的圆角不会显示出来，再由于我们设置了恰好的<code>padding</code>，所以<code>CardView</code>里面的内容也能完整展示，可谓完美，实例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardCornerRadius</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:contentPaddingBottom</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"@+id/guideline"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:adjustViewBounds</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"#8358FF"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子没有嵌套，因为另一边没有圆角，那么如果我们需要上半部分为<code>12dp</code>的圆角，下半部分为<code>6dp</code>的圆角，我们可以这样操作</p>
<p>手法和上面的例子一样，不过我们在最外层再嵌套一个<code>CardView</code>，并且将其圆角设为较小的那个圆角大小<code>6dp</code>，将里面的<code>CardView</code>的圆角设置成较大的那个圆角大小<code>12dp</code>，具体实现如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardCornerRadius</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginTop</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:cardCornerRadius</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:contentPaddingBottom</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">"@+id/guideline"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:adjustViewBounds</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:background</span>=<span class="string">"#8358FF"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本质上就是大圆角套小圆角，大圆角的裁切范围更大，会覆盖小圆角裁切的范围，从视觉上看就实现了两边的不同圆角</p>
<p>那么如果我们想进一步实现三边不同圆角或者四边不同圆角呢？原理和上面是一样的，只不过嵌套和占位会变得更加复杂，记住一个原则，小圆角在外，大圆角在内即可，我直接把具体实现贴在下面，各位自取即可：</p>
<ul>
<li>三边不同圆角（左下6dp，左上12dp，右上24dp）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardCornerRadius</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:contentPaddingRight</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/guideline2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardCornerRadius</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:contentPaddingBottom</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">"@+id/guideline2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/guideline3"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginEnd</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/guideline4"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginTop</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardCornerRadius</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:contentPaddingBottom</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:contentPaddingLeft</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"@+id/guideline4"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"@+id/guideline3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:adjustViewBounds</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:background</span>=<span class="string">"#8358FF"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>四边不同圆角（左下6dp，左上12dp，右上24dp，右下48dp）</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardCornerRadius</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:contentPaddingRight</span>=<span class="string">"6dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"@+id/guideline"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/guideline2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_marginTop</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardCornerRadius</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:contentPaddingBottom</span>=<span class="string">"12dp"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">"@+id/guideline2"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/guideline3"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginEnd</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:id</span>=<span class="string">"@+id/guideline4"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_marginTop</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardCornerRadius</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:contentPaddingBottom</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:contentPaddingLeft</span>=<span class="string">"24dp"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"@+id/guideline4"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"@+id/guideline3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:id</span>=<span class="string">"@+id/guideline5"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_marginEnd</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Space</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:id</span>=<span class="string">"@+id/guideline6"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_marginBottom</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:cardBackgroundColor</span>=<span class="string">"@android:color/transparent"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:cardCornerRadius</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:cardElevation</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:contentPaddingLeft</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:contentPaddingTop</span>=<span class="string">"48dp"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"@+id/guideline5"</span></span></span><br><span class="line"><span class="tag">                                <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"@+id/guideline6"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                                <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">android:adjustViewBounds</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                                    <span class="attr">android:background</span>=<span class="string">"#8358FF"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.cardview.widget.CardView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义ImageView"><a href="#自定义ImageView" class="headerlink" title="自定义ImageView"></a>自定义ImageView</h2><p>由于大部分裁切内容的需求，其中的内容都是图片，所以我们也可以直接对图片进行裁切，此时我们就可以自定义<code>ImageView</code>来将图片裁剪出不同大小的圆角</p>
<h3 id="clipPath"><a href="#clipPath" class="headerlink" title="clipPath"></a>clipPath</h3><p>先说这个方法的缺点，那就是无法使用抗锯齿，这一点缺陷注定了它无法被正式使用，但我们还是来看看他是如何实现的</p>
<p>首先，我们需要重写<code>ImageView</code>的<code>onSizeChanged</code>方法，为我们的<code>Path</code>确定路线</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">    path.reset()</span><br><span class="line">    <span class="comment">//这里的radii便是我们自定义的四边圆角大小的数组（size为8，从左上顺时针到左下）</span></span><br><span class="line">    path.addRoundRect(<span class="number">0f</span>, <span class="number">0f</span>, w.toFloat(), h.toFloat(), radii, Path.Direction.CW)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们重写<code>onDraw</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    canvas.clipPath(path)</span><br><span class="line">    <span class="keyword">super</span>.onDraw(rawBitmapCanvas)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上有的教程说要设置<code>PaintFlagsDrawFilter</code>，但实际上就算为这个<code>PaintFlagsDrawFilter</code>设置了<code>Paint.ANTI_ALIAS_FLAG</code>抗锯齿属性也没用，抗锯齿只在使用了<code>Paint</code>的情况下才可以生效</p>
<h3 id="PorterDuff"><a href="#PorterDuff" class="headerlink" title="PorterDuff"></a>PorterDuff</h3><p>既然<code>clipPath</code>无法使用抗锯齿，那我们可以换一条路线曲线救国，那就是使用<code>PorterDuff</code></p>
<p>当然，这种方法也有它的缺点，那就是不能使用硬件加速，但相比无法使用抗锯齿而言，这点缺点也就不算什么了</p>
<p>首先，我们要在构造方法中禁用硬件加速</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    setLayerType(LAYER_TYPE_SOFTWARE, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重写<code>onSizeChanged</code>方法，在这个方法中，我们需要确定<code>Path</code>，构造出相应大小的<code>Bitmap</code>和<code>Canvas</code>，这俩是用来获取原始无圆角的<code>Bitmap</code>的</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">    path.reset()</span><br><span class="line">    path.addRoundRect(<span class="number">0f</span>, <span class="number">0f</span>, w.toFloat(), h.toFloat(), radii, Path.Direction.CW)</span><br><span class="line"></span><br><span class="line">    rawBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">    rawBitmapCanvas = Canvas(rawBitmap!!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们重写<code>onDraw</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> paint = Paint(Paint.ANTI_ALIAS_FLAG)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rawBitmap = rawBitmap ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> rawBitmapCanvas = rawBitmapCanvas ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onDraw(rawBitmapCanvas)</span><br><span class="line"></span><br><span class="line">    canvas.drawPath(path, paint)</span><br><span class="line">    paint.xfermode = xfermode</span><br><span class="line">    canvas.drawBitmap(rawBitmap, <span class="number">0f</span>, <span class="number">0f</span>, paint)</span><br><span class="line">    paint.xfermode = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们调用父类的<code>onDraw</code>方法，获取到原始无圆角的<code>Bitmap</code>，然后绘制<code>Path</code>，再通过<code>PorterDuff</code>的叠加效果绘制我们刚刚得到的原始<code>Bitmap</code>，由于<code>PorterDuff.Mode.SRC_IN</code>的效果是取两层绘制交集，显示上层，所以我们最终便获得了一个带圆角的图片</p>
<h3 id="BitmapShader"><a href="#BitmapShader" class="headerlink" title="BitmapShader"></a>BitmapShader</h3><p>有人指出，可以使用<code>BitmapShader</code>方案，我去实测了一下，确实可以在开启了硬件加速的情况下使用，目前看上去似乎没有什么缺点，在此感谢评论区的大神们，这种方案实现起来也很简单，和上面的差不多</p>
<p>首先重写<code>onSizeChanged</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> bitmapShader: BitmapShader? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSizeChanged</span><span class="params">(w: <span class="type">Int</span>, h: <span class="type">Int</span>, oldw: <span class="type">Int</span>, oldh: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh)</span><br><span class="line">    path.reset()</span><br><span class="line">    path.addRoundRect(<span class="number">0f</span>, <span class="number">0f</span>, w.toFloat(), h.toFloat(), radii, Path.Direction.CW)</span><br><span class="line"></span><br><span class="line">    rawBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888)</span><br><span class="line">    rawBitmapCanvas = Canvas(rawBitmap!!)</span><br><span class="line">    bitmapShader = BitmapShader(rawBitmap!!, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP)</span><br><span class="line">    paint.shader = bitmapShader</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>onDraw</code>方法就更简单了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rawBitmapCanvas = rawBitmapCanvas ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">super</span>.onDraw(rawBitmapCanvas)</span><br><span class="line">    canvas.drawPath(path, paint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="截图问题"><a href="#截图问题" class="headerlink" title="截图问题"></a>截图问题</h1><p>如果想要将<code>View</code>截图成<code>Bitmap</code>，在<code>Android 8.0</code>及以上系统中我们可以使用<code>PixelCopy</code>，此时使用<code>CardView</code>或<code>Outline</code>裁切的圆角不会有任何问题，而在<code>Android 8.0</code>以下的系统中，通常我们是构建一个带<code>Bitmap</code>的<code>Canvas</code>，然后对要截图的<code>View</code>调用<code>draw</code>方法达成截图效果，而在这种情况下，使用<code>CardView</code>或<code>Outline</code>裁切的圆角便会出现无效的情况（截图出来的<code>Bitmap</code>中，圆角没了），这种情况的出现似乎也和硬件加速有关，针对这种问题，如果是图片圆角的情况，建议直接使用<code>BitmapShader</code>方案，这样无论使用哪种方式截图都不会出现问题</p>
<p>这里顺便把截图的代码也贴一下吧</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">screenshot</span><span class="params">(activity: <span class="type">Activity</span>?, onSuccess: (<span class="type">Bitmap</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O &amp;&amp; activity != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> locationOfViewInWindow = IntArray(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">this</span>.getLocationInWindow(locationOfViewInWindow)</span><br><span class="line"></span><br><span class="line">        PixelCopy.request(</span><br><span class="line">            activity.window,</span><br><span class="line">            Rect(</span><br><span class="line">                locationOfViewInWindow[<span class="number">0</span>],</span><br><span class="line">                locationOfViewInWindow[<span class="number">1</span>],</span><br><span class="line">                locationOfViewInWindow[<span class="number">0</span>] + width,</span><br><span class="line">                locationOfViewInWindow[<span class="number">1</span>] + height</span><br><span class="line">            ),</span><br><span class="line">            bitmap, &#123; copyResult -&gt;</span><br><span class="line">                <span class="keyword">if</span> (copyResult == PixelCopy.SUCCESS) &#123;</span><br><span class="line">                    onSuccess(bitmap)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    screenshotBackup(onSuccess)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            Handler(Looper.getMainLooper())</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        screenshotBackup(onSuccess)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> View.<span class="title">screenshotBackup</span><span class="params">(onSuccess: (<span class="type">Bitmap</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)</span><br><span class="line">    <span class="keyword">val</span> canvas = Canvas(bitmap)</span><br><span class="line">    draw(canvas)</span><br><span class="line">    onSuccess(bitmap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是我本人目前对<code>Android</code>实现不同大小的圆角的一些想法和遇到的问题，至于<code>CardView</code>嵌套会不会带来什么性能问题，我用<code>BitmapShader</code>方案做了一下对比，不管加载速度，还是内存占用，都没有发现明显差别（甚至用<code>CardView</code>嵌套速度还快点？），所以各位不用担心性能问题，选适合自己的方案就行了，各位小伙伴有什么更好的解决方案，欢迎在评论区指出，大家一起集思广益</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/20/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84ContentProvider%E5%85%A8%E8%A7%A3%E6%9E%90/">Android源码分析 - Framework层的ContentProvider全解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-20</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ContentProvider/">ContentProvider</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ContentProvider/">ContentProvider</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>在四大组件中，可能我们平时用到最少的便是<code>ContentProvider</code>了，<code>ContentProvider</code>是用来帮助应用管理其自身和其他应用所存储数据的访问，并提供与其他应用共享数据的方法，使用<code>ContentProvider</code>可以安全的在应用之间共享和修改数据，比如说访问图库，通讯录等</p>
<p>在之前的文章中，我们提到了<code>ContentProvider</code>的启动时机，不妨顺水推舟，干脆把这一块分析个明白，本篇文章并不会教大家怎样使用<code>ContentProvider</code>，只将精力集中在<code>ContentProvider</code>在系统层面的启动与交互上</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a>ContentResolver</h2><p>想要通过<code>ContentProvider</code>访问应用数据，我们通常需要借助<code>ContentResolver</code>的API，我们可以通过<code>Context.getContentResolver</code>方法获取其实例对象</p>
<p><code>ContentResolver</code>是一个抽象类，它的抽象方法由<code>ContextImpl.ApplicationContentResolver</code>继承实现，我们实际上获取到的也是这个实例对象</p>
<h2 id="Uri格式"><a href="#Uri格式" class="headerlink" title="Uri格式"></a>Uri格式</h2><p><code>ContentProvider</code>的使用需要先获得提供者的Uri，它的格式如下：</p>
<ol>
<li>Scheme：固定为<code>content://</code></li>
<li>Authority：为提供者在<code>AndroidManifest</code>里设置的<code>android:authorities</code>属性</li>
<li>资源相对路径</li>
<li>资源ID</li>
</ol>
<p>其中，资源相对路径和资源ID不是必须的，要看资源存储的数量及形式</p>
<p>举个栗子，外部存储中某张图片的Uri为：<code>content://media/external/images/media/${id}</code>，其中<code>media</code>为Authority，<code>/external/images/media</code>为外部存储图片的相对路径，<code>id</code>为这张图片资源在数据库中存储的<code>id</code></p>
<h1 id="获取ContentProvider"><a href="#获取ContentProvider" class="headerlink" title="获取ContentProvider"></a>获取ContentProvider</h1><p><code>ContentProvider</code>作为共享数据的桥梁，最主要的几个功能无非是增、删、改、查，我们就以查作为入口来分析<code>ContentProvider</code>对象是怎么获取的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContentResolver.query</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @RequiresPermission.Read @NonNull Uri uri,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] projection, @Nullable Bundle queryArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试获取unstableProvider</span></span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用远程对象query</span></span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, mAttributionTag, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></span><br><span class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></span><br><span class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line">            <span class="comment">//尝试获取stableProvider</span></span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用远程对象query</span></span><br><span class="line">            qCursor = stableProvider.query(mPackageName, mAttributionTag, uri, projection,</span><br><span class="line">                    queryArgs, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qCursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force query execution.  Might fail and throw a runtime exception here.</span></span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wrap the cursor object into CursorWrapperInner object.</span></span><br><span class="line">        <span class="comment">//将qCursor和provider包装成CursorWrapperInner对象返回</span></span><br><span class="line">        <span class="keyword">final</span> IContentProvider provider = (stableProvider != <span class="keyword">null</span>) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        <span class="keyword">final</span> CursorWrapperInner wrapper = <span class="keyword">new</span> CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = <span class="keyword">null</span>;</span><br><span class="line">        qCursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">// Arbitrary and not worth documenting, as Activity</span></span><br><span class="line">        <span class="comment">// Manager will kill this process shortly anyway.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (qCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qCursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.setRemote(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unstableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseUnstableProvider(unstableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseProvider(stableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这个方法大致分成以下几个步骤：</p>
<ol>
<li>获取<code>unstableProvider</code>远程对象</li>
<li>调用<code>unstableProvider</code>对象的<code>query</code>方法，获取<code>qCursor</code></li>
<li>如果<code>query</code>过程中远程对象死亡，尝试获取<code>stableProvider</code>并调用<code>query</code>方法获取<code>qCursor</code></li>
<li>获取<code>stableProvider</code>（如果之前没获取的话）</li>
<li>将<code>qCursor</code>和<code>stableProvider</code>包装成<code>CursorWrapperInner</code>对象返回</li>
<li>释放资源</li>
</ol>
<p>既然<code>ContentProvider</code>可以在应用之前共享数据，那它必然是支持跨进程的，没错，用的还是我们熟悉的<code>Binder</code>通信，<code>IContentProvider</code>对象即是给调用方进程使用的远程<code>Binder</code>对象，回顾这个方法我们发现，<code>IContentProvider</code>远程对象是通过<code>acquireUnstableProvider</code>或<code>acquireProvider</code>获取的，我们接下来看看这两个方法做了什么</p>
<p>这里有一个关于<code>unstable</code>和<code>stable</code>的概念，对于通过这两种方式获取的<code>ContentProvider</code>分别会有<code>unstableCount</code>和<code>stableCount</code>两种引用计数，如果远程<code>ContentProvider</code>所在进程死亡，且其<code>stableCount &gt; 0</code>的话，则会将其通过<code>stable</code>方式关联的调用方进程一同杀死，具体的流程我们会在后面分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acquireProvider(mContext, auth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acquireUnstableProvider(mContext, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acquireProvider(mContext, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContextImpl.ApplicationContentResolver 内实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ContextImpl.ApplicationContentResolver 内实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityThread-acquireProvider"><a href="#ActivityThread-acquireProvider" class="headerlink" title="ActivityThread.acquireProvider"></a>ActivityThread.acquireProvider</h2><p>Android系统是通过<code>Authority</code>来区分不同的<code>ContentProvider</code>的，经过一些简单的判断处理后，最终调用了<code>ActivityThread.acquireProvider</code>方法去获取<code>ContentProvider</code>，而<code>acquireUnstableProvider</code>和<code>acquireProvider</code>的区别只是最后一个布尔值入参不同罢了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从本地缓存中获取ContentProvider对象</span></span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There is a possible race here.  Another thread may try to acquire</span></span><br><span class="line">    <span class="comment">// the same provider at the same time.  When this happens, we want to ensure</span></span><br><span class="line">    <span class="comment">// that the first one wins.</span></span><br><span class="line">    <span class="comment">// Note that we cannot hold the lock while acquiring and installing the</span></span><br><span class="line">    <span class="comment">// provider since it might take a long time to run and it could also potentially</span></span><br><span class="line">    <span class="comment">// be re-entrant in the case where the provider is in the same process.</span></span><br><span class="line">    ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getGetProviderLock(auth, userId)) &#123;</span><br><span class="line">            <span class="comment">//使用AMS获取ContentProvider对象</span></span><br><span class="line">            holder = ActivityManager.getService().getContentProvider(</span><br><span class="line">                    getApplicationThread(), c.getOpPackageName(), auth, userId, stable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install provider will increment the reference count for us, and break</span></span><br><span class="line">    <span class="comment">// any ties in the race.</span></span><br><span class="line">    <span class="comment">//安装ContentProvider</span></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法大概做了以下几件事：</p>
<ol>
<li>首先从缓存中尝试获取<code>IContentProvider</code>对象</li>
<li>使用<code>AMS</code>获取<code>ContentProviderHolder</code>对象</li>
<li>安装<code>ContentProvider</code></li>
<li>返回<code>IContentProvider</code>对象</li>
</ol>
<h3 id="ActivityThread-acquireExistingProvider"><a href="#ActivityThread-acquireExistingProvider" class="headerlink" title="ActivityThread.acquireExistingProvider"></a>ActivityThread.acquireExistingProvider</h3><p>我们首先看通过<code>acquireExistingProvider</code>方法尝试从缓存中获取<code>IContentProvider</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//从缓存Map中查找</span></span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IContentProvider provider = pr.mProvider;</span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="comment">//判断远端进程是否已被杀死</span></span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class="line">            <span class="comment">// The hosting process of the provider has died; we can't</span></span><br><span class="line">            <span class="comment">// use this one.</span></span><br><span class="line">            <span class="comment">//清理ContentProvider</span></span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only increment the ref count if we have one.  If we don't then the</span></span><br><span class="line">        <span class="comment">// provider is not reference counted and never needs to be released.</span></span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//更新引用计数</span></span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>Authority</code>和<code>userId</code>来从Map中查找是否已存在对应的<code>ProviderClientRecord</code>对象，然后从中取出<code>IContentProvider</code>对象，再检查其中的远程<code>Binder</code>对象是否已被杀死，最后一切无误，增加<code>ContentProvider</code>的引用计数</p>
<h3 id="AMS-getContentProvider"><a href="#AMS-getContentProvider" class="headerlink" title="AMS.getContentProvider"></a>AMS.getContentProvider</h3><p>如果这一步没有获取到，程序会继续从<code>AMS</code>获取<code>ContentProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IApplicationThread caller, String callingPackage, String name, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String msg = <span class="string">"null IApplicationThread when getting content provider "</span></span><br><span class="line">                + name;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The incoming user check is now handled in checkContentProviderPermissionLocked() to deal</span></span><br><span class="line">    <span class="comment">// with cross-user grant.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">if</span> (callingPackage != <span class="keyword">null</span> &amp;&amp; mAppOpsService.checkPackage(callingUid, callingPackage)</span><br><span class="line">            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Given calling package "</span> + callingPackage</span><br><span class="line">                + <span class="string">" does not match caller's uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, callingUid, callingPackage,</span><br><span class="line">            <span class="keyword">null</span>, stable, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一些检查后调用<code>getContentProviderImpl</code>方法，这个方法有点长，我们分段来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方所在进程记录</span></span><br><span class="line">        ProcessRecord r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                        + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") when getting content provider "</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> checkCrossUser = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First check if this content provider has been published...</span></span><br><span class="line">        <span class="comment">//检查需要的ContentProvider是否已被发布</span></span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line">        <span class="comment">// If that didn't work, check if it exists for user 0 and then</span></span><br><span class="line">        <span class="comment">// verify that it's a singleton provider before using it.</span></span><br><span class="line">        <span class="comment">//如果没找到，尝试从系统用户中查找已发布的ContentProvider</span></span><br><span class="line">        <span class="comment">//并确保它是可用的单例组件，条件如下：</span></span><br><span class="line">        <span class="comment">//是用户级应用程序且组件设置了单例flag且拥有INTERACT_ACROSS_USERS权限 或 App运行在system进程中 或 组件设置了单例flag且是同一个App</span></span><br><span class="line">        <span class="keyword">if</span> (cpr == <span class="keyword">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">            <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cpi = cpr.info;</span><br><span class="line">                <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r == <span class="keyword">null</span> ? callingUid : r.uid,</span><br><span class="line">                                cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                    userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                    checkCrossUser = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cpr = <span class="keyword">null</span>;</span><br><span class="line">                    cpi = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断ContentProvider所在进程是否已死亡</span></span><br><span class="line">        ProcessRecord dyingProc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="keyword">null</span> &amp;&amp; cpr.proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            providerRunning = !cpr.proc.killed;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Note if killedByAm is also set, this means the provider process has just been</span></span><br><span class="line">            <span class="comment">// killed by AM (in ProcessRecord.kill()), but appDiedLocked() hasn't been called</span></span><br><span class="line">            <span class="comment">// yet. So we need to call appDiedLocked() here and let it clean up.</span></span><br><span class="line">            <span class="comment">// (See the commit message on I2c4ba1e87c2d47f2013befff10c49b3dc337a9a7 to see</span></span><br><span class="line">            <span class="comment">// how to test this case.)</span></span><br><span class="line">            <span class="keyword">if</span> (cpr.proc.killed &amp;&amp; cpr.proc.killedByAm) &#123;</span><br><span class="line">                Slog.wtf(TAG, cpr.proc.toString() + <span class="string">" was killed by AM but isn't really dead"</span>);</span><br><span class="line">                <span class="comment">// Now we are going to wait for the death before starting the new process.</span></span><br><span class="line">                dyingProc = cpr.proc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，第一部分，检查目标<code>ContentProvider</code>是否已被发布并记录在了<code>mProviderMap</code>中，注意这里的<code>mProviderMap</code>是<code>AMS</code>中的一个成员变量，一系列Map的一个集合，和<code>ActivityThread</code>中的<code>mProviderMap</code>不是一个东西。如果在当前用户中找不到，且当前用户不是系统用户（UserHandle.USER_SYSTEM == 0），则尝试从系统用户中查找合法可用的单例<code>ContentProvider</code>，符合以下任一一个条件的<code>ContentProvider</code>即可被视作单例<code>ContentProvider</code>：</p>
<ul>
<li>App是用户级应用程序（uid &gt;= 10000）且<code>ContentProvider</code>组件设置了单例flag（<code>android:singleUser</code>）且App拥有<code>INTERACT_ACROSS_USERS</code>权限</li>
<li>App运行在<code>system</code>进程中</li>
<li><code>ContentProvider</code>组件设置了单例flag（<code>android:singleUser</code>）且是同一个App</li>
</ul>
<p>至于为什么跨用户访问需要单例这个条件，这个和多用户相关，我也不是很清楚，以后如果分析到了多用户这块再回来补充。目前国内厂商的应用分身、手机分身功能大部分用的就是多用户技术</p>
<p>接着通过目标<code>ContentProviderRecord</code>是否存在和其所在进程是否还存活判断目标<code>ContentProvider</code>是否在运行中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ContentProvider正在运行中</span></span><br><span class="line">        <span class="keyword">if</span> (providerRunning) &#123;</span><br><span class="line">            cpi = cpr.info;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果此ContentProvider可以在调用者进程中直接运行（同一个App的同进程 或 同一个App且Provider组件支持多进程）</span></span><br><span class="line">            <span class="comment">//直接返回一个新的ContentProviderHolder让调用者进程自己启动ContentProvider</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                ... <span class="comment">//权限检查</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// This provider has been published or is in the process</span></span><br><span class="line">                <span class="comment">// of being published...  but it is also allowed to run</span></span><br><span class="line">                <span class="comment">// in the caller's process, so don't make a connection</span></span><br><span class="line">                <span class="comment">// and just let the caller instantiate its own instance.</span></span><br><span class="line">                ContentProviderHolder holder = cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// don't give caller the provider object, it needs</span></span><br><span class="line">                <span class="comment">// to make its own.</span></span><br><span class="line">                holder.provider = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't expose providers between normal apps and instant apps</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (AppGlobals.getPackageManager()</span><br><span class="line">                        .resolveContentProvider(name, <span class="number">0</span> <span class="comment">/*flags*/</span>, userId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//权限检查</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In this case the provider instance already exists, so we can</span></span><br><span class="line">            <span class="comment">// return it right away.</span></span><br><span class="line">            <span class="comment">//获取连接并更新引用计数</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">                    stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span> &amp;&amp; (conn.stableCount+conn.unstableCount) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; r != <span class="keyword">null</span> &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_LOW_APP_ADJ) &#123;</span><br><span class="line">                    <span class="comment">// If this is a perceptible app accessing the provider,</span></span><br><span class="line">                    <span class="comment">// make sure to count it as being accessed and thus</span></span><br><span class="line">                    <span class="comment">// back up on the LRU list.  This is good because</span></span><br><span class="line">                    <span class="comment">// content providers are often expensive to start.</span></span><br><span class="line">                    <span class="comment">//更新进程优先级</span></span><br><span class="line">                    mProcessList.updateLruProcessLocked(cpr.proc, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verifiedAdj = cpr.proc.verifiedAdj;</span><br><span class="line">            <span class="comment">//更新进程adj</span></span><br><span class="line">            <span class="keyword">boolean</span> success = updateOomAdjLocked(cpr.proc, <span class="keyword">true</span>,</span><br><span class="line">                    OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER);</span><br><span class="line">            <span class="comment">// XXX things have changed so updateOomAdjLocked doesn't actually tell us</span></span><br><span class="line">            <span class="comment">// if the process has been successfully adjusted.  So to reduce races with</span></span><br><span class="line">            <span class="comment">// it, we will check whether the process still exists.  Note that this doesn't</span></span><br><span class="line">            <span class="comment">// completely get rid of races with LMK killing the process, but should make</span></span><br><span class="line">            <span class="comment">// them much smaller.</span></span><br><span class="line">            <span class="keyword">if</span> (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123;</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> there is still a race here where a signal could be</span></span><br><span class="line">            <span class="comment">// pending on the process even though we managed to update its</span></span><br><span class="line">            <span class="comment">// adj level.  Not sure what to do about this, but at least</span></span><br><span class="line">            <span class="comment">// the race is now smaller.</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">// Uh oh...  it looks like the provider's process</span></span><br><span class="line">                <span class="comment">// has been killed on us.  We need to wait for a new</span></span><br><span class="line">                <span class="comment">// process to be started, and make sure its death</span></span><br><span class="line">                <span class="comment">// doesn't kill our process.</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Existing provider "</span> + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" is crashing; detaching "</span> + r);</span><br><span class="line">                <span class="comment">//ContentProvider所在进程被杀了，更新引用计数</span></span><br><span class="line">                <span class="keyword">boolean</span> lastRef = decProviderCountLocked(conn, cpr, token, stable);</span><br><span class="line">                <span class="comment">//仍有别的地方对这个ContentProvider有引用，直接返回null（需要等待进程清理干净才能重启）</span></span><br><span class="line">                <span class="keyword">if</span> (!lastRef) &#123;</span><br><span class="line">                    <span class="comment">// This wasn't the last ref our process had on</span></span><br><span class="line">                    <span class="comment">// the provider...  we will be killed during cleaning up, bail.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// We'll just start a new process to host the content provider</span></span><br><span class="line">                <span class="comment">//将运行状态标为false，使得重新启动ContentProvider所在进程</span></span><br><span class="line">                providerRunning = <span class="keyword">false</span>;</span><br><span class="line">                conn = <span class="keyword">null</span>;</span><br><span class="line">                dyingProc = cpr.proc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cpr.proc.verifiedAdj = cpr.proc.setAdj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分，如果目标<code>ContentProvider</code>正在运行中，首先检查目标<code>ContentProvider</code>是否可以在调用者进程中直接运行，需要满足以下任一一个条件：</p>
<ul>
<li>调用者和目标<code>ContentProvider</code>是同一个App中的同进程</li>
<li>调用者和目标<code>ContentProvider</code>属同一个App且<code>ContentProvider</code>组件支持多进程（<code>android:multiprocess</code>）</li>
</ul>
<p>在这种情况下，直接返回一个新的<code>ContentProviderHolder</code>让调用者进程自己处理获得<code>ContentProvider</code>即可，具体逻辑在<code>ActivityThread.installProvider</code>方法中，后面会分析</p>
<p>如果不满足这种情况，即调用方进程和目标<code>ContentProvider</code>不在一个进程中，需要跨进程调用，获取<code>ContentProviderConnection</code>连接并更新引用计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ContentProvider未在运行</span></span><br><span class="line">        <span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">            <span class="comment">//通过PMS获取ContentProvider信息</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cpi = AppGlobals.getPackageManager().</span><br><span class="line">                    resolveContentProvider(name,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cpi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If the provider is a singleton AND</span></span><br><span class="line">            <span class="comment">// (it's a call within the same user || the provider is a</span></span><br><span class="line">            <span class="comment">// privileged app)</span></span><br><span class="line">            <span class="comment">// Then allow connecting to the singleton provider</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags)</span><br><span class="line">                    &amp;&amp; isValidSingletonCall(r == <span class="keyword">null</span> ? callingUid : r.uid,</span><br><span class="line">                            cpi.applicationInfo.uid);</span><br><span class="line">            <span class="keyword">if</span> (singleton) &#123;</span><br><span class="line">                userId = UserHandle.USER_SYSTEM;</span><br><span class="line">            &#125;</span><br><span class="line">            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//各项检查</span></span><br><span class="line"></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            <span class="comment">//通过Class（android:name属性）获取ContentProviderRecord</span></span><br><span class="line">            cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="comment">//此ContentProvider是第一次运行</span></span><br><span class="line">            <span class="keyword">boolean</span> firstClass = cpr == <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                ... <span class="comment">//权限处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取应用信息</span></span><br><span class="line">                    ApplicationInfo ai =</span><br><span class="line">                        AppGlobals.getPackageManager().</span><br><span class="line">                            getApplicationInfo(</span><br><span class="line">                                    cpi.applicationInfo.packageName,</span><br><span class="line">                                    STOCK_PM_FLAGS, userId);</span><br><span class="line">                    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"No package info for content provider "</span></span><br><span class="line">                                + cpi.name);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ai = getAppInfoForUser(ai, userId);</span><br><span class="line">                    <span class="comment">//新建ContentProvider记录</span></span><br><span class="line">                    cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, ai, comp, singleton);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                    <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(ident);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyingProc == cpr.proc &amp;&amp; dyingProc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The old stable connection's client should be killed during proc cleaning up,</span></span><br><span class="line">                <span class="comment">// so do not re-use the old ContentProviderRecord, otherwise the new clients</span></span><br><span class="line">                <span class="comment">// could get killed unexpectedly.</span></span><br><span class="line">                <span class="comment">//旧的ContentProvider进程在死亡过程中，不要复用旧的ContentProviderRecord，避免出现预期之外的问题</span></span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(cpr);</span><br><span class="line">                <span class="comment">// This is sort of "firstClass"</span></span><br><span class="line">                firstClass = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果此ContentProvider可以在调用者进程中直接运行（同一个App的同进程 或 同一个App且Provider组件支持多进程）</span></span><br><span class="line">            <span class="comment">//直接返回一个新的ContentProviderHolder让调用者进程自己启动ContentProvider</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                <span class="comment">// If this is a multiprocess provider, then just return its</span></span><br><span class="line">                <span class="comment">// info and allow the caller to instantiate it.  Only do</span></span><br><span class="line">                <span class="comment">// this if the provider is the same user as the caller's</span></span><br><span class="line">                <span class="comment">// process, or can run as root (so can be in any process).</span></span><br><span class="line">                <span class="keyword">return</span> cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is single process, and our app is now connecting to it.</span></span><br><span class="line">            <span class="comment">// See if we are already in the process of launching this</span></span><br><span class="line">            <span class="comment">// provider.</span></span><br><span class="line">            <span class="comment">//查找正在启动中的ContentProvider</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mLaunchingProviders.size();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the provider is not already being launched, then get it</span></span><br><span class="line">            <span class="comment">// started.</span></span><br><span class="line">            <span class="comment">//目标ContentProvider不在启动中</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Content provider is now in use, its package can't be stopped.</span></span><br><span class="line">                    <span class="comment">//将App状态置为unstopped，设置休眠状态为false</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                                cpr.appInfo.packageName, <span class="keyword">false</span>, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                                + cpr.appInfo.packageName + <span class="string">": "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Use existing process if already started</span></span><br><span class="line">                    <span class="comment">//获取目标ContentProvider所在进程记录</span></span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123; <span class="comment">//进程存活</span></span><br><span class="line">                        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                            <span class="comment">//将ContentProviderRecord保存到进程已发布ContentProvider列表中</span></span><br><span class="line">                            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//调度ActivityThread直接安装ContentProvider</span></span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//进程死亡</span></span><br><span class="line">                        <span class="comment">//启动App（App启动过程中会自动启动ContentProvider）</span></span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>,</span><br><span class="line">                                <span class="keyword">new</span> HostingRecord(<span class="string">"content provider"</span>,</span><br><span class="line">                                    <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                            cpi.name)),</span><br><span class="line">                                ZYGOTE_POLICY_FLAG_EMPTY, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    <span class="comment">//将目标ContentProvider添加到启动中列表</span></span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure the provider is published (the same provider class</span></span><br><span class="line">            <span class="comment">// may be published under multiple names).</span></span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">            <span class="comment">//获取连接并更新引用计数</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag,</span><br><span class="line">                    stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grantImplicitAccess(userId, <span class="keyword">null</span> <span class="comment">/*intent*/</span>, callingUid,</span><br><span class="line">                UserHandle.getAppId(cpi.applicationInfo.uid));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三部分，如果目标<code>ContentProvider</code>未在运行，先通过<code>PMS</code>获取<code>ContentProvider</code>信息，接着尝试通过Class（<code>android:name</code>属性）获取<code>ContentProviderRecord</code>，如果获取不到，说明这个<code>ContentProvider</code>是第一次运行（开机后），这种情况下需要新建<code>ContentProviderRecord</code>，如果获取到了，但是其所在进程被标记为正在死亡，此时同样需要新建<code>ContentProviderRecord</code>，不要复用旧的<code>ContentProviderRecord</code>，避免出现预期之外的问题</p>
<p>接下来同样检查目标<code>ContentProvider</code>是否可以在调用者进程中直接运行，如果可以直接返回一个新的<code>ContentProviderHolder</code>让调用者进程自己启动获取<code>ContentProvider</code></p>
<p>接着检查正在启动中的<code>ContentProvider</code>列表，如果不在列表中，我们可能需要手动启动它，此时又有两种情况：</p>
<ol>
<li><code>ContentProvider</code>所在进程已启动：如果进程已发布<code>ContentProvider</code>列表中不包含这个<code>ContentProviderRecord</code>，则将其添加到列表中，然后调用目标进程中的<code>ApplicationThread.scheduleInstallProvider</code>方法安装启动<code>ContentProvider</code></li>
<li><code>ContentProvider</code>所在进程未启动：启动目标进程，目标进程启动过程中会自动安装启动<code>ContentProvider</code>（<code>ActivityThread.handleBindApplication</code>方法中）</li>
</ol>
<p>最后更新<code>mProviderMap</code>，获取<code>ContentProviderConnection</code>连接并更新引用计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> providerRunning = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for the provider to be published...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeout =</span><br><span class="line">            SystemClock.uptimeMillis() + ContentResolver.CONTENT_PROVIDER_READY_TIMEOUT_MILLIS;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//ContentProvider启动过程中进程死亡，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//计算最大等待时间</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> wait = Math.max(<span class="number">0L</span>, timeout - SystemClock.uptimeMillis());</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//释放锁，等待ContentProvider启动完成</span></span><br><span class="line">                cpr.wait(wait);</span><br><span class="line">                <span class="comment">//等待时间已过，ContentProvider还是没能启动完成并发布，超时</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    timedOut = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timedOut) &#123;</span><br><span class="line">        ... <span class="comment">//超时处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回新的ContentProviderHolder</span></span><br><span class="line">    <span class="keyword">return</span> cpr.newHolder(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四部分，如果<code>ContentProvider</code>已存在，直接新建一个<code>ContentProviderHolder</code>返回，如果<code>ContentProvider</code>之前不存在，现在正在启动中，则以当前时间加上<code>CONTENT_PROVIDER_READY_TIMEOUT_MILLIS</code>推算出一个超时时间，给目标<code>ContentProviderRecord</code>上锁后，调用<code>wait</code>方法等待，直到<code>ContentProvider</code>成功发布后<code>notify</code>解除<code>wait</code>状态（在<code>AMS.publishContentProviders</code>方法中，之后会分析到），或一直等待直到超时。<code>wait</code>状态解除后，判断内部<code>ContentProvider</code>是否已被赋值，如果没有，则可以断定超时，此时返回<code>null</code>，如有，则返回一个新的<code>ContentProviderHolder</code></p>
<h3 id="ActivityThread-installProvider"><a href="#ActivityThread-installProvider" class="headerlink" title="ActivityThread.installProvider"></a>ActivityThread.installProvider</h3><p>由于这个方法同时包含了启动安装本地<code>ContentProvider</code>和获取安装远程<code>ContentProvider</code>的逻辑，所以放到后面<code>启动ContentProvider</code>章节里一起分析</p>
<h1 id="启动ContentProvider"><a href="#启动ContentProvider" class="headerlink" title="启动ContentProvider"></a>启动ContentProvider</h1><p>从前面的章节<code>获取ContentProvider</code>中，我们已经归纳出<code>ContentProvider</code>的启动分为两种情况，接着我们就来分析在这两种情况下，<code>ContentProvider</code>的启动路径</p>
<h2 id="进程已启动"><a href="#进程已启动" class="headerlink" title="进程已启动"></a>进程已启动</h2><p>在进程已启动的情况下，如果进程已发布<code>ContentProvider</code>列表中不包含这个<code>ContentProviderRecord</code>，则将其添加到列表中，然后调用目标进程中的<code>ApplicationThread.scheduleInstallProvider</code>方法安装启动<code>ContentProvider</code></p>
<p><code>ApplicationThread.scheduleInstallProvider</code>会通过<code>Hander</code>发送一条<code>what</code>值为<code>H.INSTALL_PROVIDER</code>的消息，我们根据这个<code>what</code>值搜索，发现会走到<code>ActivityThread.handleInstallProvider</code>方法中，在这个方法内又会调用<code>installContentProviders</code>方法安装启动<code>ContentProvider</code></p>
<h2 id="进程未启动"><a href="#进程未启动" class="headerlink" title="进程未启动"></a>进程未启动</h2><p>在进程未启动的情况下，直接启动目标进程，在之前的文章 <a href="https://juejin.cn/post/7172464885492613128#heading-7" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 里，我们分析了App的启动流程，其中有两个地方对启动<code>ContentProvider</code>至关重要</p>
<h3 id="AMS-attachApplicationLocked"><a href="#AMS-attachApplicationLocked" class="headerlink" title="AMS.attachApplicationLocked"></a>AMS.attachApplicationLocked</h3><p>在这个方法中会调用<code>generateApplicationProvidersLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//normalMode一般情况下均为true</span></span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ProviderInfo&gt; <span class="title">generateApplicationProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PMS获取App中同一个进程内的所有的ContentProvider组件信息</span></span><br><span class="line">        providers = AppGlobals.getPackageManager()</span><br><span class="line">                .queryContentProviders(app.processName, app.uid,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS</span><br><span class="line">                                | MATCH_DEBUG_TRIAGED_MISSING, <span class="comment">/*metadastaKey=*/</span> <span class="keyword">null</span>)</span><br><span class="line">                .getList();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> userId = app.userId;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="comment">//有必要的情况下进行Map扩容</span></span><br><span class="line">        app.pubProviders.ensureCapacity(N + app.pubProviders.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> keep logic in sync with installEncryptionUnawareProviders</span></span><br><span class="line">            ProviderInfo cpi =</span><br><span class="line">                (ProviderInfo)providers.get(i);</span><br><span class="line">            <span class="comment">//对于单例ContentProvider，需要在默认用户中启动，如果不是默认用户的话则直接将其丢弃掉，不启动</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags);</span><br><span class="line">            <span class="keyword">if</span> (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                <span class="comment">// This is a singleton provider, but a user besides the</span></span><br><span class="line">                <span class="comment">// default user is asking to initialize a process it runs</span></span><br><span class="line">                <span class="comment">// in...  well, no, it doesn't actually run in this process,</span></span><br><span class="line">                <span class="comment">// it runs in the process of the default user.  Get rid of it.</span></span><br><span class="line">                providers.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//新建ContentProviderRecord并将其加入到缓存中</span></span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, app.info, comp, singleton);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将ContentProviderRecord保存到进程已发布ContentProvider列表中</span></span><br><span class="line">            app.pubProviders.put(cpi.name, cpr);</span><br><span class="line">            <span class="keyword">if</span> (!cpi.multiprocess || !<span class="string">"android"</span>.equals(cpi.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                <span class="comment">//将App添加至进程中运行的包列表中</span></span><br><span class="line">                app.addPackage(cpi.applicationInfo.packageName,</span><br><span class="line">                        cpi.applicationInfo.longVersionCode, mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            notifyPackageUse(cpi.applicationInfo.packageName,</span><br><span class="line">                                PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是获取需要启动的<code>ContentProvider</code>的<code>ContentProviderRecord</code>，如果是第一次启动这个<code>ContentProvider</code>则需要新建一个<code>ContentProviderRecord</code>并将其存入缓存，然后将其保存到进程已发布<code>ContentProvider</code>列表中，以供后面使用。同时这个方法返回了需要启动的<code>ProviderInfo</code>列表，<code>AMS.attachApplicationLocked</code>方法可以根据这个列表判断是否有需要启动的<code>ContentProvider</code>并设置<code>ContentProvider</code>启动超时检测</p>
<h3 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication"></a>ActivityThread.handleBindApplication</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">        <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">        <span class="comment">// app's custom Application class</span></span><br><span class="line">        <span class="comment">//在非受限模式下启动ContentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Application的onCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">        <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">        <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法中直接调用了<code>installContentProviders</code>方法安装启动<code>ContentProvider</code></p>
<p>另外提一点，为什么我要把<code>Application</code>的创建和<code>onCreate</code>也放进来呢？现在市面上有很多库，包括很多教程告诉我们，可以通过注册<code>ContentProvider</code>的方式初始化SDK，获取全局<code>Context</code>，比如说著名的内存泄漏检测工具<code>LeakCanary</code>的新版本，想要使用它，直接添加它的依赖就行了，不需要对代码做哪怕一点的改动，究其原理，就是因为<code>ContentProvider</code>的启动时机是在<code>Application</code>创建后，<code>Application.onCreate</code>调用前，并且<code>ContentProvider</code>内的<code>Context</code>成员变量大概率就是<code>Application</code>，大家以后在开发过程中也可以妙用这一点</p>
<h2 id="ActivityThread-installContentProviders"><a href="#ActivityThread-installContentProviders" class="headerlink" title="ActivityThread.installContentProviders"></a>ActivityThread.installContentProviders</h2><p>好了，现在这两种情况最终都走到了<code>ActivityThread.installContentProviders</code>方法中，那我们接下来就好好分析<code>ContentProvider</code>实际的启动安装流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="comment">//逐个启动</span></span><br><span class="line">        ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发布ContentProvider</span></span><br><span class="line">        ActivityManager.getService().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，便利所有待启动的<code>ContentProvider</code>信息列表，逐个启动安装<code>ContentProvider</code>，最后一起发布</p>
<h3 id="ActivityThread-installProvider-1"><a href="#ActivityThread-installProvider-1" class="headerlink" title="ActivityThread.installProvider"></a>ActivityThread.installProvider</h3><p>我们先看<code>installProvider</code>方法，我们在上一章中分析到，获取<code>ContentProvider</code>的时候也会调用这个方法，这次我们就结合起来一起分析</p>
<p>通过上文的代码，我们发现，有两处地方会调用<code>installProvider</code>方法，方法的入参有三种形式，分别为：</p>
<ul>
<li><p><code>holder</code>不为<code>null</code>，<code>info</code>不为<code>null</code>，<code>holder.provider</code>为<code>null</code>：在<code>ActivityThread.acquireProvider</code>方法中被调用，路径为 没有获取到已存在的<code>ContentProvider</code> -&gt; <code>AMS.getContentProvider</code> -&gt; <code>AMS.getContentProviderImpl</code> -&gt; 发现目标<code>ContentProvider</code>可以在调用者进程中直接运行 -&gt; 直接返回一个新的<code>ContentProviderHolder</code>（包含<code>ProviderInfo</code>） -&gt; <code>ActivityThread.installProvider</code>，在这种情况下<code>installProvider</code>方法会在本地启动安装<code>ContentProvider</code></p>
</li>
<li><p><code>holder</code>为<code>null</code>，<code>info</code>不为<code>null</code>：在<code>ActivityThread.installContentProviders</code>方法中被调用，两条路径，一是App进程启动后自动执行，二是在<code>AMS.getContentProvider</code>方法中发现目标进程已启动但是<code>ContentProvider</code>未启动，调用<code>ActivityThread.scheduleInstallProvider</code>方法执行，在这种情况下<code>installProvider</code>方法会在本地启动安装<code>ContentProvider</code></p>
</li>
<li><p><code>holder</code>不为<code>null</code>，<code>holder.provider</code>不为<code>null</code>：在<code>ActivityThread.acquireProvider</code>方法中被调用，路径为 没有获取到已存在的<code>ContentProvider</code> -&gt; <code>AMS.getContentProvider</code> -&gt; <code>AMS.getContentProviderImpl</code> -&gt; 获取到目标进程的远程<code>ContentProvider</code>引用 -&gt; 包装成<code>ContentProviderHolder</code>返回 -&gt; <code>ActivityThread.installProvider</code>，在这种情况下<code>installProvider</code>方法直接可以获取到远程<code>ContentProvider</code>引用，然后进行处理</p>
</li>
</ul>
<p>我们将这三种情况分成两种case分别分析</p>
<h4 id="本地启动ContentProvider"><a href="#本地启动ContentProvider" class="headerlink" title="本地启动ContentProvider"></a>本地启动ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123; <span class="comment">//启动本地ContentProvider</span></span><br><span class="line">        Context c = <span class="keyword">null</span>;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">        <span class="comment">//首先获取Context，一般情况下就是Application</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Split Apks动态加载相关</span></span><br><span class="line">        <span class="keyword">if</span> (info.splitName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = c.createContextForSplit(info.splitName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            <span class="comment">//获取应用信息</span></span><br><span class="line">            LoadedApk packageInfo = peekPackageInfo(ai.packageName, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// System startup case.</span></span><br><span class="line">                packageInfo = getSystemContext().mPackageInfo;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过AppComponentFactory实例化ContentProvider</span></span><br><span class="line">            localProvider = packageInfo.getAppFactory()</span><br><span class="line">                    .instantiateProvider(cl, info.name);</span><br><span class="line">            <span class="comment">//Transport类，继承自ContentProviderNative（Binder服务端）</span></span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// XXX Need to create the correct context for this provider.</span></span><br><span class="line">            <span class="comment">//初始化ContentProvider，调用其onCreate方法</span></span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(<span class="keyword">null</span>, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to get provider "</span> + info.name</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取外部ContentProvider</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//对于本地ContentProvider来说，这里的实际类型是Transport，继承自ContentProviderNative（Binder服务端）</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123; <span class="comment">//本地启动ContentProvider的情况</span></span><br><span class="line">            ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line">            ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经存在相应的ContentProvider记录，使用其内部已存在的ContentProvider</span></span><br><span class="line">                provider = pr.mProvider;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则使用新创建的ContentProvider</span></span><br><span class="line">                holder = <span class="keyword">new</span> ContentProviderHolder(info);</span><br><span class="line">                holder.provider = provider;</span><br><span class="line">                <span class="comment">//对于本地ContentProvider来说，不存在释放引用这种情况</span></span><br><span class="line">                holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//创建ProviderClientRecord并将其保存到mProviderMap本地缓存中</span></span><br><span class="line">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                <span class="comment">//保存ProviderClientRecord到本地缓存中</span></span><br><span class="line">                mLocalProviders.put(jBinder, pr);</span><br><span class="line">                mLocalProvidersByName.put(cname, pr);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = pr.mHolder;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取远程ContentProvider的情况</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在这里找到了<code>ContentProvider</code>创建并启动的入口，首先通过传入的<code>Context</code>（实际上就是<code>Application</code>）判断并确定创建并给<code>ContentProvider</code>使用的的<code>Context</code>是什么（一般情况下也是<code>Application</code>），然后获取到应用信息<code>LoadedApk</code>，再通过它得到<code>AppComponentFactory</code>（前面的文章中介绍过，如果没有在<code>AndroidManifest</code>中设置<code>android:appComponentFactory</code>属性，使用的便是默认的<code>AppComponentFactory</code>），接着通过<code>AppComponentFactory.instantiateProvider</code>方法实例化<code>ContentProvider</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ContentProvider <span class="title">instantiateProvider</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ContentProvider) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的话就是通过<code>ClassName</code>反射调用默认构造函数实例化<code>ContentProvider</code>对象，最后再调用<code>ContentProvider.attachInfo</code>方法初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info)</span> </span>&#123;</span><br><span class="line">    attachInfo(context, info, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="keyword">boolean</span> testing)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        ...</span><br><span class="line">        ContentProvider.<span class="keyword">this</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细内容我们就不分析了，只需要知道这里给<code>mContext</code>赋了值，然后调用了<code>ContentProvider.onCreate</code>方法就可以了</p>
<p>到了这一步，<code>ContentProvider</code>就算是启动完成了，接下来需要执行一些安装步骤，其实也就是对缓存等进行一些处理。在<code>ContentProvider</code>实例化后，会调用其<code>getIContentProvider</code>方法给<code>provider</code>变量赋值，这里获得的对象其实是一个<code>Transport</code>对象，继承自<code>ContentProviderNative</code>，是一个<code>Binder</code>服务端对象，在<code>ContentProvider</code>初始化后，会对<code>Transport</code>对象调用<code>asBinder</code>方法获得<code>Binder</code>对象，这里获得的其实还是自己本身，接着从缓存中尝试获取<code>ProviderClientRecord</code>对象，如果获取到了，说明已经存在了相应的<code>ContentProvider</code>，使用<code>ProviderClientRecord</code>内部的<code>ContentProvider</code>，刚刚新创建的那个就可以丢弃了，如果没获取到，就去新建<code>ContentProviderHolder</code>以及<code>ProviderClientRecord</code>，然后将他们添加到各种缓存中，至此，<code>ContentProvider</code>的安装过程也到此结束</p>
<h4 id="获取处理远程ContentProvider"><a href="#获取处理远程ContentProvider" class="headerlink" title="获取处理远程ContentProvider"></a>获取处理远程ContentProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123; <span class="comment">//启动本地ContentProvider</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取外部ContentProvider</span></span><br><span class="line">        <span class="comment">//实际类型为ContentProviderProxy</span></span><br><span class="line">        provider = holder.provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//对于外部ContentProvider来说，这里的实际类型是BinderProxy</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123; <span class="comment">//本地启动ContentProvider的情况</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//获取远程ContentProvider的情况</span></span><br><span class="line">            ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">            <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123; <span class="comment">//如果ContentProvider引用已存在</span></span><br><span class="line">                <span class="comment">// We need to transfer our new reference to the existing</span></span><br><span class="line">                <span class="comment">// ref count, releasing the old one...  but only if</span></span><br><span class="line">                <span class="comment">// release is needed (that is, it is not running in the</span></span><br><span class="line">                <span class="comment">// system process).</span></span><br><span class="line">                <span class="comment">//对于远程ContentProvider来说，如果目标App为system应用（UID为ROOT_UID或SYSTEM_UID）</span></span><br><span class="line">                <span class="comment">//并且目标App不为设置（包名不为com.android.settings），则noReleaseNeeded为true</span></span><br><span class="line">                <span class="keyword">if</span> (!noReleaseNeeded) &#123;</span><br><span class="line">                    <span class="comment">//增加已存在的ContentProvider引用的引用计数</span></span><br><span class="line">                    incProviderRefLocked(prc, stable);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//释放传入的引用，移除ContentProviderConnection相关信息，更新引用计数</span></span><br><span class="line">                        ActivityManager.getService().removeContentProvider(</span><br><span class="line">                                holder.connection, stable);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//创建ProviderClientRecord并将其保存到mProviderMap本地缓存中</span></span><br><span class="line">                ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                        provider, localProvider, holder);</span><br><span class="line">                <span class="keyword">if</span> (noReleaseNeeded) &#123; <span class="comment">//同上，目标App为system应用，不需要释放引用</span></span><br><span class="line">                    <span class="comment">//新建一个ProviderRefCount，但引用计数初始化为一个较大的数值</span></span><br><span class="line">                    <span class="comment">//这样后续无论调用方进程的ContentProvider引用计数如何变动都不会影响到AMS</span></span><br><span class="line">                    prc = <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//需要释放引用的情况下</span></span><br><span class="line">                    <span class="comment">//正常的新建初始化一个ProviderRefCount</span></span><br><span class="line">                    prc = stable</span><br><span class="line">                            ? <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                            : <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//保存至缓存</span></span><br><span class="line">                mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = prc.holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>holder.provider</code>不为<code>null</code>的情况，直接获取远程<code>ContentProvider</code>引用，然后进行处理就可以了。这里获取到的<code>IContentProvider</code>的实际类型是<code>ContentProviderProxy</code>，然后对其调用<code>asBinder</code>方法，获取到的是<code>BinderProxy</code>对象，接着从缓存中尝试获取<code>ProviderRefCount</code>对象，如果缓存中已经有相应的引用对象了，则在需要释放引用（<code>!noReleaseNeeded</code>）的情况下使用原有的引用，释放参数传入进来的<code>ContentProvider</code>引用</p>
<p>这里<code>noReleaseNeeded</code>是在<code>ContentProviderRecord</code>构造时赋值的，为<code>true</code>的条件是目标App为system应用（<code>UID</code>为<code>ROOT_UID</code>或<code>SYSTEM_UID</code>）并且目标App不为设置（包名不为<code>com.android.settings</code>）</p>
<p>如果缓存中没有查找到相应的<code>ProviderRefCount</code>对象，新建<code>ProviderClientRecord</code>和<code>ProviderRefCount</code>对象，并将他们保存到缓存中，至于为什么在<code>noReleaseNeeded</code>的情况下，新建的<code>ProviderRefCount</code>的引用计数初始值为1000，我猜测是因为<code>noReleaseNeeded</code>代表了不需要释放引用，所以这里干脆设置一个比较大的值，这样无论调用方进程的<code>ContentProvider</code>引用计数怎样变动，都不会再调用到<code>AMS</code>的方法中去处理引用的变化，在非常早期的<code>Android</code>版本中（<code>Android 4.0.1</code>），这个值曾被设置为<code>10000</code></p>
<p>至此，远程<code>ContentProvider</code>的安装也结束了</p>
<h4 id="ActivityThread-installProviderAuthoritiesLocked"><a href="#ActivityThread-installProviderAuthoritiesLocked" class="headerlink" title="ActivityThread.installProviderAuthoritiesLocked"></a>ActivityThread.installProviderAuthoritiesLocked</h4><p>接下来我们再简单的看一下两种case都会走到的<code>installProviderAuthoritiesLocked</code>方法吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProviderClientRecord <span class="title">installProviderAuthoritiesLocked</span><span class="params">(IContentProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProvider localProvider, ContentProviderHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String auths[] = holder.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(holder.info.applicationInfo.uid);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ProviderClientRecord pcr = <span class="keyword">new</span> ProviderClientRecord(</span><br><span class="line">            auths, provider, localProvider, holder);</span><br><span class="line">    <span class="keyword">for</span> (String auth : auths) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord existing = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Content provider "</span> + pcr.mHolder.info.name</span><br><span class="line">                    + <span class="string">" already published as "</span> + auth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProviderMap.put(key, pcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，新建了一个<code>ProviderClientRecord</code>并将其添加到<code>mProviderMap</code>缓存中，这里的操作对应着最前面的<code>acquireExistingProvider</code>方法，有了这个缓存，以后就可以直接拿，而不用再复杂的经过一系列的<code>AMS</code>跨进程操作了</p>
<h3 id="AMS-publishContentProviders"><a href="#AMS-publishContentProviders" class="headerlink" title="AMS.publishContentProviders"></a>AMS.publishContentProviders</h3><p><code>ContentProvider</code>全部启动安装完后，便要调用<code>AMS.publishContentProviders</code>将他们发布出去，供外部使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                    + <span class="string">") when publishing content providers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ContentProviderHolder src = providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//App进程启动时或AMS.getContentProvider中已经将相应ContentProviderRecord添加到了pubProviders中</span></span><br><span class="line">            ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//保存至缓存中</span></span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ContentProvider已经启动完毕，将其从正在启动的ContentProvider列表中移除</span></span><br><span class="line">                <span class="keyword">int</span> launchingCount = mLaunchingProviders.size();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">boolean</span> wasInLaunchingProviders = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        wasInLaunchingProviders = <span class="keyword">true</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                        launchingCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//移除ContentProvider启动超时监听</span></span><br><span class="line">                <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                    mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Make sure the package is associated with the process.</span></span><br><span class="line">                <span class="comment">// XXX We shouldn't need to do this, since we have added the package</span></span><br><span class="line">                <span class="comment">// when we generated the providers in generateApplicationProvidersLocked().</span></span><br><span class="line">                <span class="comment">// But for some reason in some cases we get here with the package no longer</span></span><br><span class="line">                <span class="comment">// added...  for now just patch it in to make things happy.</span></span><br><span class="line">                r.addPackage(dst.info.applicationInfo.packageName,</span><br><span class="line">                        dst.info.applicationInfo.longVersionCode, mProcessStats);</span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.setProcess(r);</span><br><span class="line">                    <span class="comment">//让出锁，通知其他wait的地方</span></span><br><span class="line">                    <span class="comment">//对应着AMS.getContentProvider的第四部分：等待ContentProvider启动完成</span></span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                dst.mRestartCount = <span class="number">0</span>;</span><br><span class="line">                updateOomAdjLocked(r, <span class="keyword">true</span>, OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER);</span><br><span class="line">                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                        src.info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历整个待发布的<code>ContentProvider</code>列表，从<code>ProcessRecord.pubProviders</code>中查找相对应的<code>ContentProviderRecord</code>，我们在之前的章节中已经分析过了，App进程启动时或<code>AMS.getContentProvider</code>中已经将相应<code>ContentProviderRecord</code>添加到了<code>pubProviders</code>中，然后就是将其保存到各个缓存中，由于<code>ContentProvider</code>已经启动完毕，所以需要将其从正在启动的<code>ContentProvider</code>列表中移除，在<code>ContentProvider</code>正常启动的情况下，我们需要将<code>ContentProvider</code>的启动超时监听移除，最后，获取<code>ContentProviderRecord</code>同步锁，将准备好的<code>ContentProvider</code>赋值到<code>ContentProviderRecord</code>中，接着调用<code>notifyAll</code>方法通知其他调用过<code>wait</code>的地方，将锁让出，这里对应的就是<code>AMS.getContentProvider</code>的第四部分：等待<code>ContentProvider</code>启动完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">int</span> callingUid, String callingPackage, String callingTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//这里的cpr和在publishContentProviders获得的dst是一个对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//释放锁，等待ContentProvider启动完成</span></span><br><span class="line">            cpr.wait(wait);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>ContentProvider</code>一发布，这里就会收到通知，解除<code>wait</code>状态，获得到<code>ContentProvider</code>，返回出去，是不是感觉一切都串起来了？</p>
<h1 id="ContentProvider引用计数"><a href="#ContentProvider引用计数" class="headerlink" title="ContentProvider引用计数"></a>ContentProvider引用计数</h1><p><code>ContentProvider</code>的获取与启动分析完了，接下来我们聊聊它的引用计数，为下一小节分析<code>ContentProvider</code>死亡杀死调用方进程的过程做准备</p>
<p><code>ActivityThread</code>层的引用计数是和<code>AMS</code>层的引用计数分开的，<code>ActivityThread</code>记录的是目标<code>ContentProvider</code>在本进程中有多少处正在使用，而<code>AMS</code>记录的是目标<code>ContentProvider</code>正在被多少个进程使用</p>
<h2 id="ActivityThread层的引用计数"><a href="#ActivityThread层的引用计数" class="headerlink" title="ActivityThread层的引用计数"></a>ActivityThread层的引用计数</h2><h3 id="增加引用计数"><a href="#增加引用计数" class="headerlink" title="增加引用计数"></a>增加引用计数</h3><p>我们先从<code>ActivityThread</code>层增加引用计数开始说起，在<code>ActivityThread</code>获取<code>ContentProvider</code>时，便会调用<code>incProviderRefLocked</code>方法来增加引用计数，具体的时机为<code>acquireExistingProvider</code>或<code>installProvider</code>时，代码我就不重复放了，大家看前面几个小节就行（后同）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incProviderRefLocked</span><span class="params">(ProviderRefCount prc, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">        <span class="comment">//增加ActivityThread的stable引用计数</span></span><br><span class="line">        prc.stableCount += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//本进程对目标ContentProvider产生了stable引用关系</span></span><br><span class="line">        <span class="keyword">if</span> (prc.stableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// We are acquiring a new stable reference on the provider.</span></span><br><span class="line">            <span class="keyword">int</span> unstableDelta;</span><br><span class="line">            <span class="comment">//正在移除ContentProvider引用中（释放ContentProvider后发现stable和unstable引用计数均为0）</span></span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// We have a pending remove operation, which is holding the</span></span><br><span class="line">                <span class="comment">// last unstable reference.  At this point we are converting</span></span><br><span class="line">                <span class="comment">// that unstable reference to our new stable reference.</span></span><br><span class="line">                <span class="comment">//当ActivityThread释放一个stable的ContentProvider时，如果释放完后，</span></span><br><span class="line">                <span class="comment">//发现stable和unstable引用计数均为0，则会暂时保留一个unstable引用</span></span><br><span class="line">                <span class="comment">//所以这里需要为 -1 ，将这个unstable引用移除</span></span><br><span class="line">                unstableDelta = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// Cancel the removal of the provider.</span></span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// There is a race! It fails to remove the message, which</span></span><br><span class="line">                <span class="comment">// will be handled in completeRemoveProvider().</span></span><br><span class="line">                <span class="comment">//取消移除ContentProvider引用</span></span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对于正常情况，只需要增加stable引用计数，不需要动unstable引用计数</span></span><br><span class="line">                unstableDelta = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//AMS层修改引用计数</span></span><br><span class="line">                ActivityManager.getService().refContentProvider(</span><br><span class="line">                        prc.holder.connection, <span class="number">1</span>, unstableDelta);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//增加ActivityThread的unstable引用计数</span></span><br><span class="line">        prc.unstableCount += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//本进程对目标ContentProvider产生了unstable引用关系</span></span><br><span class="line">        <span class="keyword">if</span> (prc.unstableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// We are acquiring a new unstable reference on the provider.</span></span><br><span class="line">            <span class="comment">//正在移除ContentProvider引用中（释放ContentProvider后发现stable和unstable引用计数均为0）</span></span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// Oh look, we actually have a remove pending for the</span></span><br><span class="line">                <span class="comment">// provider, which is still holding the last unstable</span></span><br><span class="line">                <span class="comment">// reference.  We just need to cancel that to take new</span></span><br><span class="line">                <span class="comment">// ownership of the reference.</span></span><br><span class="line">                <span class="comment">//取消移除ContentProvider引用</span></span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// First unstable ref, increment our count in the</span></span><br><span class="line">                <span class="comment">// activity manager.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//增加AMS层的unstable引用计数</span></span><br><span class="line">                    ActivityManager.getService().refContentProvider(</span><br><span class="line">                            prc.holder.connection, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑需要配合着<code>ContentProvider</code>释放引用那里一起看才好理解，我先提前解释一下</p>
<p>首先，<code>removePending</code>这个变量表示此<code>ContentProvider</code>正在移除中，当<code>ActivityThread</code>减少引用计数，检查到<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>后被赋值为<code>true</code>，并且会向<code>Handler</code>发送一条<code>what</code>值为<code>REMOVE_PROVIDER</code>的延时消息，在一定时间后便会触发<code>ContentProvider</code>移除操作，清理本地缓存，再将<code>removePending</code>重新置为<code>false</code>，所以当这里<code>removePending</code>为<code>true</code>则说明此<code>ContentProvider</code>还没完全被移除，我们把这个消息取消掉继续使用这个<code>ContentProvider</code></p>
<p>对于<code>stable</code>引用的情况下，当<code>ActivityThread</code>减少引用计数，检查到<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>后，会暂时保留一个<code>unstable</code>引用，等到后面真正触发到了移除<code>ContentProvider</code>的时候再将这个<code>unstable</code>引用移除，所以在增加引用计数的时候需要考虑到这一点，在这种情况下要将<code>AMS</code>层的<code>unstable</code>引用计数减一</p>
<p>对于其他的情况就是正常的增加<code>ActivityThread</code>层引用计数，然后调用<code>AMS.refContentProvider</code>方法操作<code>AMS</code>层的引用计数</p>
<h3 id="减少引用计数"><a href="#减少引用计数" class="headerlink" title="减少引用计数"></a>减少引用计数</h3><p><code>ContentProvider</code>使用完后会调用<code>ActivityThread.releaseProvider</code>方法，以<code>query</code>方法为例，最后会调用<code>releaseUnstableProvider</code>和<code>releaseProvider</code>方法，最终都会走到这里来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseProvider</span><span class="params">(IContentProvider provider, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder jBinder = provider.asBinder();</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The provider has no ref count, no release is needed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> lastRef = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            <span class="comment">//引用计数已经为0，无法再减了</span></span><br><span class="line">            <span class="keyword">if</span> (prc.stableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减少ActivityThread的stable引用计数</span></span><br><span class="line">            prc.stableCount -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (prc.stableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// What we do at this point depends on whether there are</span></span><br><span class="line">                <span class="comment">// any unstable refs left: if there are, we just tell the</span></span><br><span class="line">                <span class="comment">// activity manager to decrement its stable count; if there</span></span><br><span class="line">                <span class="comment">// aren't, we need to enqueue this provider to be removed,</span></span><br><span class="line">                <span class="comment">// and convert to holding a single unstable ref while</span></span><br><span class="line">                <span class="comment">// doing so.</span></span><br><span class="line">                lastRef = prc.unstableCount == <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//如果是最后的引用，则暂时保留一个unstable引用</span></span><br><span class="line">                    ActivityManager.getService().refContentProvider(</span><br><span class="line">                            prc.holder.connection, -<span class="number">1</span>, lastRef ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//引用计数已经为0，无法再减了</span></span><br><span class="line">            <span class="keyword">if</span> (prc.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减少ActivityThread的unstable引用计数</span></span><br><span class="line">            prc.unstableCount -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (prc.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If this is the last reference, we need to enqueue</span></span><br><span class="line">                <span class="comment">// this provider to be removed instead of telling the</span></span><br><span class="line">                <span class="comment">// activity manager to remove it at this point.</span></span><br><span class="line">                lastRef = prc.stableCount == <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果是最后的引用，则不进入到这里，暂时保留一个unstable引用</span></span><br><span class="line">                <span class="keyword">if</span> (!lastRef) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//减少AMS引用计数</span></span><br><span class="line">                        ActivityManager.getService().refContentProvider(</span><br><span class="line">                                prc.holder.connection, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastRef) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!prc.removePending) &#123;</span><br><span class="line">                <span class="comment">// Schedule the actual remove asynchronously, since we don't know the context</span></span><br><span class="line">                <span class="comment">// this will be called in.</span></span><br><span class="line">                <span class="comment">//表面此ContentProvider正在移除中</span></span><br><span class="line">                prc.removePending = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//发送延时消息，等待一定时间后移除ContentProvider</span></span><br><span class="line">                Message msg = mH.obtainMessage(H.REMOVE_PROVIDER, prc);</span><br><span class="line">                mH.sendMessageDelayed(msg, CONTENT_PROVIDER_RETAIN_TIME);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Duplicate remove pending of provider "</span> + prc.holder.info.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在减完引用计数后，如果发现是最后一个引用，即<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>，此时无论是<code>stable</code>还是<code>unstable</code>都会让<code>AMS</code>暂时保留一个<code>unstable</code>引用，然后发送一条<code>what</code>值为<code>REMOVE_PROVIDER</code>的延时消息，等待一定时间后移除<code>ContentProvider</code>，当时间到了触发这条消息时，会调用到<code>ActivityThread.completeRemoveProvider</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">completeRemoveProvider</span><span class="params">(ProviderRefCount prc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!prc.removePending) &#123;</span><br><span class="line">            <span class="comment">// There was a race!  Some other client managed to acquire</span></span><br><span class="line">            <span class="comment">// the provider before the removal was completed.</span></span><br><span class="line">            <span class="comment">// Abort the removal.  We will do it later.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// More complicated race!! Some client managed to acquire the</span></span><br><span class="line">        <span class="comment">// provider and release it before the removal was completed.</span></span><br><span class="line">        <span class="comment">// Continue the removal, and abort the next remove message.</span></span><br><span class="line">        prc.removePending = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">final</span> IBinder jBinder = prc.holder.provider.asBinder();</span><br><span class="line">        ProviderRefCount existingPrc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (existingPrc == prc) &#123;</span><br><span class="line">            mProviderRefCountMap.remove(jBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mProviderMap.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProviderClientRecord pr = mProviderMap.valueAt(i);</span><br><span class="line">            IBinder myBinder = pr.mProvider.asBinder();</span><br><span class="line">            <span class="keyword">if</span> (myBinder == jBinder) &#123;</span><br><span class="line">                mProviderMap.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//处理AMS层引用计数</span></span><br><span class="line">        ActivityManager.getService().removeContentProvider(</span><br><span class="line">                prc.holder.connection, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将进程内所持有的<code>ContentProvider</code>相关缓存清除，然后调用<code>AMS.removeContentProvider</code>方法通知<code>AMS</code>移除<code>ContentProvider</code>，处理相应的引用计数。这里我们发现，调用<code>AMS.removeContentProvider</code>方法传入的最后一个参数<code>stable</code>为<code>false</code>，因为我们之前在<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>的情况下，保留了一个<code>unstable</code>引用，所以这时移除的<code>ContentProvider</code>引用也是<code>unstable</code>引用</p>
<h2 id="AMS层的引用计数"><a href="#AMS层的引用计数" class="headerlink" title="AMS层的引用计数"></a>AMS层的引用计数</h2><p>接着我们来看<code>AMS</code>层的引用计数</p>
<h3 id="AMS-refContentProvider"><a href="#AMS-refContentProvider" class="headerlink" title="AMS.refContentProvider"></a>AMS.refContentProvider</h3><p>我们就先从我们刚刚分析的<code>ActivityThread</code>层的引用计数修改后续：<code>refContentProvider</code> 看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refContentProvider</span><span class="params">(IBinder connection, <span class="keyword">int</span> stable, <span class="keyword">int</span> unstable)</span> </span>&#123;</span><br><span class="line">    ContentProviderConnection conn;</span><br><span class="line">    ...</span><br><span class="line">    conn = (ContentProviderConnection)connection;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn.numStableIncs += stable;</span><br><span class="line">        &#125;</span><br><span class="line">        stable = conn.stableCount + stable;</span><br><span class="line">        <span class="keyword">if</span> (stable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"stableCount &lt; 0: "</span> + stable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unstable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            conn.numUnstableIncs += unstable;</span><br><span class="line">        &#125;</span><br><span class="line">        unstable = conn.unstableCount + unstable;</span><br><span class="line">        <span class="keyword">if</span> (unstable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unstableCount &lt; 0: "</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((stable+unstable) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ref counts can't go to zero here: stable="</span></span><br><span class="line">                    + stable + <span class="string">" unstable="</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line">        conn.stableCount = stable;</span><br><span class="line">        conn.unstableCount = unstable;</span><br><span class="line">        <span class="keyword">return</span> !conn.dead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，应该不需要再多做分析了吧？就是简单的修改<code>ContentProviderConnection</code>的引用计数值</p>
<h3 id="AMS-incProviderCountLocked"><a href="#AMS-incProviderCountLocked" class="headerlink" title="AMS.incProviderCountLocked"></a>AMS.incProviderCountLocked</h3><p>接下来我们看<code>AMS</code>层引用计数的增加，<code>AMS.incProviderCountLocked</code>这个方法的触发时机是在<code>AMS.getContentProviderImpl</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ContentProviderConnection <span class="title">incProviderCountLocked</span><span class="params">(ProcessRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, String callingTag, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;r.conProviders.size(); i++) &#123;</span><br><span class="line">            ContentProviderConnection conn = r.conProviders.get(i);</span><br><span class="line">            <span class="comment">//如果连接已存在，在其基础上增加引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (conn.provider == cpr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">                    conn.stableCount++;</span><br><span class="line">                    conn.numStableIncs++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    conn.unstableCount++;</span><br><span class="line">                    conn.numUnstableIncs++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新建ContentProviderConnection连接</span></span><br><span class="line">        ContentProviderConnection conn = <span class="keyword">new</span> ContentProviderConnection(cpr, r, callingPackage);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        conn.startAssociationIfNeeded();</span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numStableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numUnstableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加连接</span></span><br><span class="line">        cpr.connections.add(conn);</span><br><span class="line">        r.conProviders.add(conn);</span><br><span class="line">        <span class="comment">//建立关联</span></span><br><span class="line">        startAssociationLocked(r.uid, r.processName, r.getCurProcState(),</span><br><span class="line">                cpr.uid, cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.addExternalProcessHandleLocked(externalProcessToken, callingUid, callingTag);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用方进程已存在对应<code>ContentProviderConnection</code>连接，则在其基础上增加引用计数，否则新建连接，然后初始化引用计数值</p>
<h3 id="AMS-decProviderCountLocked"><a href="#AMS-decProviderCountLocked" class="headerlink" title="AMS.decProviderCountLocked"></a>AMS.decProviderCountLocked</h3><p>然后是减少引用计数，之前在<code>ActivityThread</code>减引用到0后，会延时调用<code>ActivityThread.completeRemoveProvider</code>方法，在这个方法中会调用到<code>AMS.removeContentProvider</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContentProvider</span><span class="params">(IBinder connection, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ContentProviderConnection conn = (ContentProviderConnection)connection;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//减少引用计数</span></span><br><span class="line">            <span class="keyword">if</span> (decProviderCountLocked(conn, <span class="keyword">null</span>, <span class="keyword">null</span>, stable)) &#123;</span><br><span class="line">                <span class="comment">//更新进程优先级</span></span><br><span class="line">                updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_REMOVE_PROVIDER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中便会调用<code>AMS.decProviderCountLocked</code>减少引用计数，然后更新进程优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">decProviderCountLocked</span><span class="params">(ContentProviderConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cpr = conn.provider;</span><br><span class="line">        <span class="comment">//减少引用计数值</span></span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount == <span class="number">0</span> &amp;&amp; conn.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//停止关联</span></span><br><span class="line">            conn.stopAssociation();</span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            cpr.connections.remove(conn);</span><br><span class="line">            conn.client.conProviders.remove(conn);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.setProcState &lt; PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                <span class="comment">// The client is more important than last activity -- note the time this</span></span><br><span class="line">                <span class="comment">// is happening, so we keep the old provider process around a bit as last</span></span><br><span class="line">                <span class="comment">// activity to avoid thrashing it.</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cpr.proc.lastProviderTime = SystemClock.uptimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//停止关联</span></span><br><span class="line">            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid,</span><br><span class="line">                    cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.removeExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减少引用计数值，如果<code>stable</code>和<code>unstable</code>引用计数均为<code>0</code>，则将这个连接移除</p>
<h1 id="ContentProvider死亡杀死调用方进程的过程"><a href="#ContentProvider死亡杀死调用方进程的过程" class="headerlink" title="ContentProvider死亡杀死调用方进程的过程"></a>ContentProvider死亡杀死调用方进程的过程</h1><p>我们前面提到过，<code>ContentProvider</code>所在进程死亡会将与其所有有<code>stable</code>关联的调用方进程杀死，这是怎么做到的呢？在之前的文章中，我们介绍过进程启动时，在调用<code>AMS.attachApplicationLocked</code>时会注册一个App进程死亡回调，我们就从进程死亡，触发死亡回调开始分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册App进程死亡回调</span></span><br><span class="line">    AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</span><br><span class="line">            app, pid, thread);</span><br><span class="line">    thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">    app.deathRecipient = adr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册了死亡回调后，如果对应<code>binder</code>进程死亡，便会回调<code>IBinder.DeathRecipient.binderDied</code>方法，我们来看一下<code>AppDeathRecipient</code>对这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread;</span><br><span class="line"></span><br><span class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</span><br><span class="line">            IApplicationThread thread) &#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mPid = pid;</span><br><span class="line">        mAppThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接转手调用<code>AMS.appDiedLocked</code>方法，然后经过<code>handleAppDiedLocked</code>调用到<code>cleanUpApplicationRecordLocked</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> restart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove published content providers.</span></span><br><span class="line">    <span class="comment">//清除已发布的ContentProvider</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.pubProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderRecord cpr = app.pubProviders.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (cpr.proc != app) &#123;</span><br><span class="line">            <span class="comment">// If the hosting process record isn't really us, bail out</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> alwaysRemove = app.bad || !allowRestart;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> inLaunching = removeDyingProviderLocked(app, cpr, alwaysRemove);</span><br><span class="line">        <span class="keyword">if</span> (!alwaysRemove &amp;&amp; inLaunching &amp;&amp; cpr.hasConnectionOrHandle()) &#123;</span><br><span class="line">            <span class="comment">// We left the provider in the launching list, need to</span></span><br><span class="line">            <span class="comment">// restart it.</span></span><br><span class="line">            restart = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cpr.provider = <span class="keyword">null</span>;</span><br><span class="line">        cpr.setProcess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    app.pubProviders.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take care of any launching providers waiting for this process.</span></span><br><span class="line">    <span class="comment">//清除正在启动中的ContentProvider</span></span><br><span class="line">    <span class="keyword">if</span> (cleanupAppInLaunchingProvidersLocked(app, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        mProcessList.noteProcessDiedLocked(app);</span><br><span class="line">        restart = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unregister from connected content providers.</span></span><br><span class="line">    <span class="comment">//清除已连接的ContentProvider</span></span><br><span class="line">    <span class="keyword">if</span> (!app.conProviders.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = app.conProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ContentProviderConnection conn = app.conProviders.get(i);</span><br><span class="line">            conn.provider.connections.remove(conn);</span><br><span class="line">            stopAssociationLocked(app.uid, app.processName, conn.provider.uid,</span><br><span class="line">                    conn.provider.appInfo.longVersionCode, conn.provider.name,</span><br><span class="line">                    conn.provider.info.processName);</span><br><span class="line">        &#125;</span><br><span class="line">        app.conProviders.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法中遍历了<code>ProcessRecord.pubProviders</code>，逐个对发布的<code>ContentProvider</code>调用<code>removeDyingProviderLocked</code>方法执行移除操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">removeDyingProviderLocked</span><span class="params">(ProcessRecord proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderRecord cpr, <span class="keyword">boolean</span> always)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inLaunching = mLaunchingProviders.contains(cpr);</span><br><span class="line">    <span class="keyword">if</span> (inLaunching &amp;&amp; !always &amp;&amp; ++cpr.mRestartCount &gt; ContentProviderRecord.MAX_RETRY_COUNT) &#123;</span><br><span class="line">        <span class="comment">// It's being launched but we've reached maximum attempts, force the removal</span></span><br><span class="line">        always = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inLaunching || always) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">            cpr.launchingApp = <span class="keyword">null</span>;</span><br><span class="line">            cpr.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(cpr.uid);</span><br><span class="line">        <span class="comment">// Don't remove from provider map if it doesn't match</span></span><br><span class="line">        <span class="comment">// could be a new content provider is starting</span></span><br><span class="line">        <span class="comment">//移除缓存</span></span><br><span class="line">        <span class="keyword">if</span> (mProviderMap.getProviderByClass(cpr.name, userId) == cpr) &#123;</span><br><span class="line">            mProviderMap.removeProviderByClass(cpr.name, userId);</span><br><span class="line">        &#125;</span><br><span class="line">        String names[] = cpr.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            <span class="comment">// Don't remove from provider map if it doesn't match</span></span><br><span class="line">            <span class="comment">// could be a new content provider is starting</span></span><br><span class="line">            <span class="comment">//移除缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mProviderMap.getProviderByName(names[j], userId) == cpr) &#123;</span><br><span class="line">                mProviderMap.removeProviderByName(names[j], userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cpr.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">        <span class="keyword">if</span> (conn.waiting) &#123;</span><br><span class="line">            <span class="comment">// If this connection is waiting for the provider, then we don't</span></span><br><span class="line">            <span class="comment">// need to mess with its process unless we are always removing</span></span><br><span class="line">            <span class="comment">// or for some reason the provider is not currently launching.</span></span><br><span class="line">            <span class="keyword">if</span> (inLaunching &amp;&amp; !always) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord capp = conn.client;</span><br><span class="line">        conn.dead = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!capp.isPersistent() &amp;&amp; capp.thread != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; capp.pid != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; capp.pid != MY_PID) &#123;</span><br><span class="line">                <span class="comment">//当调用方与被杀死的目标ContentProvider进程间有stable连接</span></span><br><span class="line">                <span class="comment">//并且调用方App进程非persistent进程并且非system_server进程中的情况下</span></span><br><span class="line">                <span class="comment">//杀死调用方进程</span></span><br><span class="line">                capp.kill(<span class="string">"depends on provider "</span></span><br><span class="line">                        + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" in dying proc "</span> + (proc != <span class="keyword">null</span> ? proc.processName : <span class="string">"??"</span>)</span><br><span class="line">                        + <span class="string">" (adj "</span> + (proc != <span class="keyword">null</span> ? proc.setAdj : <span class="string">"??"</span>) + <span class="string">")"</span>,</span><br><span class="line">                        ApplicationExitInfo.REASON_DEPENDENCY_DIED,</span><br><span class="line">                        ApplicationExitInfo.SUBREASON_UNKNOWN,</span><br><span class="line">                        <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (capp.thread != <span class="keyword">null</span> &amp;&amp; conn.provider.provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通知调用方移除ContentProvider</span></span><br><span class="line">                capp.thread.unstableProviderDied(conn.provider.provider.asBinder());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// In the protocol here, we don't expect the client to correctly</span></span><br><span class="line">            <span class="comment">// clean up this connection, we'll just remove it.</span></span><br><span class="line">            <span class="comment">//移除连接</span></span><br><span class="line">            cpr.connections.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.conProviders.remove(conn)) &#123;</span><br><span class="line">                stopAssociationLocked(capp.uid, capp.processName, cpr.uid,</span><br><span class="line">                        cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inLaunching &amp;&amp; always) &#123;</span><br><span class="line">        mLaunchingProviders.remove(cpr);</span><br><span class="line">        cpr.mRestartCount = <span class="number">0</span>;</span><br><span class="line">        inLaunching = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inLaunching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在这个方法中遍历了<code>ContentProvider</code>下的所有连接，当发现有其他进程与自己建立了<code>stable</code>连接（<code>conn.stableCount &gt; 0</code>），且调用方进程不是<code>persistent</code>进程（常驻进程，只有拥有系统签名的App设置这个属性才生效），也不是运行在<code>system_server</code>进程，调用<code>ProcessRecord.kill</code>方法直接杀死进程，对于没有建立<code>stable</code>连接的调用方进程，调用<code>IApplicationThread.unstableProviderDied</code>方法通知调用方进程移除相应的<code>ContentProvider</code></p>
<p>所以，使用<code>ContentProvider</code>是有一定风险的，大家要注意规避</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，整个<code>Framework</code>层关于<code>ContentProvider</code>的内容应该都分析完了，希望大家看完后能获得一些收获，接下来的文章应该会去分析<code>Service</code>相关源码，敬请期待~</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/06/AI/AI%E4%BA%BA%E5%A3%B0/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">有手就行！Sovits AI人声模型训练</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI/">AI</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AI/AI%E4%BA%BA%E5%A3%B0/">AI人声</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI/">AI</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AIGC/">AIGC</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AI%E4%BA%BA%E5%A3%B0/">AI人声</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Sovits/">Sovits</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着AI孙燕姿的爆火出圈，各大视频平台的AI人声投稿量激增，B站首页频频给我推送相关视频，正好我对AIGC方面也挺感兴趣，心动不如行动，于是我用自己的声音训练了一个模型，发现整个过程异常的简单，并且最终出来的效果也不错，真的是有手就行，所以这次将我自己训练推理的过程经验分享给大家</p>
<h1 id="Sovits"><a href="#Sovits" class="headerlink" title="Sovits"></a>Sovits</h1><p>首先介绍一下今天要讲的Sovits，So-vits-svc（也称Sovits）是由是中国民间歌声合成爱好者Rcell基于VITS、soft-vc、VISinger2等一系列项目开发的一款开源免费AI语音转换软件，通过SoftVC内容编码器提取源音频语音特征，与F0同时输入VITS替换原本的文本输入达到歌声转换的效果。</p>
<p>由于某些原因，原作者Rcell删除了原代码仓库，现由svc-develop-team接手进行后续维护，现仓库地址：<a href="https://github.com/svc-develop-team/so-vits-svc" target="_blank" rel="noopener">https://github.com/svc-develop-team/so-vits-svc</a></p>
<h1 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h1><ul>
<li>一张支持 CUDA 的，拥有至少 6G 以上显存的 NVIDIA 显卡</li>
<li>推荐使用<code>Windows</code>系统，教程后续的素材处理、训练、推理均在<code>Windows</code>平台上完成，同时使用整合包GUI也可以帮助新手将注意力集中在训练/推理本身上，避免了繁杂的环境配置等工作</li>
</ul>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>本次的环境使用的是 <a href="https://space.bilibili.com/3493141443250876" target="_blank" rel="noopener">bilibili@羽毛布団</a> 大佬提供的整合包：<a href="https://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r" target="_blank" rel="noopener">https://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r</a> ，在这里能找到下载地址和一些说明</p>
<p>下载完后，你会得到一个Sovits的压缩包和一些工具软件，将其中的so-vits-svc解压缩后，打开里面的<code>启动webui.bat</code>文件，它会自动准备环境，然后弹出一个网页</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_sovits%E7%9B%AE%E5%BD%95.jpg" alt="sovits目录"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%90%AF%E5%8A%A8webui.png" alt="启动webui"></p>
<p>在网页中将Tab页切换至训练页，可以看到我们的显卡信息</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%98%BE%E5%8D%A1%E4%BF%A1%E6%81%AF.jpg" alt="显卡信息"></p>
<p>确认无误后我们就可以开始训练了</p>
<h1 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h1><p>数据集的质量及多少决定了训练模型质量的上下限，质量差的数据集无论你训练多久，训练了多少万个step，都不可能达到一个理想的效果</p>
<h2 id="准备干声"><a href="#准备干声" class="headerlink" title="准备干声"></a>准备干声</h2><p>Sovits的训练我们需要找一些想训练的声线所对应的干声素材，不可混杂多种声线，时长最好在2个小时以上，最低不要少于30分钟，否则无法保证训练出来的模型的质量，可以是说话、读书或唱歌的声音（有的人说加入一些哭闹、大笑等各种各样的声音有奇效，我没尝试过，大家可以试试看），如果想让你的模型唱歌的话，唱歌的素材需要覆盖低中高音多个频率</p>
<p>干声素材中不能有伴奏、混响、和声（避免转换后的声音自带BGM），不要有换气声、颤音、转音等，尽量将背景噪音去除干净</p>
<h2 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h2><p>如果你本来的素材就是不带伴奏混响的干声文件，但是有一些嘈杂的背景噪音，可以使用<code>Adobe Audition</code>（以下简称AU）进行降噪处理</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html</a></p>
<h2 id="去伴奏混响"><a href="#去伴奏混响" class="headerlink" title="去伴奏混响"></a>去伴奏混响</h2><p>如果你的素材是之前录好的歌曲，那么需要对它进行去伴奏去混响处理，这里推荐使用 <a href="https://ultimatevocalremover.com/" target="_blank" rel="noopener">Ultimate Vocal Remover v5</a>（简称UVR5）</p>
<p>下载完UVR5，在处理音频前建议先去<code>Advanced VR Options</code>中将<code>Post-Process</code>选项打开，这样去混响的效果可能更好（玄学）</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_Settings.jpg" alt="UVR5 Settings"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_AdvancedVROptions.jpg" alt="UVR5 Advanced VR Options"></p>
<p>接着开始去伴奏，推荐采用以下配置：</p>
<ol>
<li>Process Method: Demucs</li>
<li>Stems: Vocals</li>
<li>Demucs Model: v3 | UVR_Model_1 <strong>注：找不到对应模型的可以在下拉框中选择Download在软件内下载相应模型</strong></li>
<li>勾选GPU Conversion</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_%E5%8E%BB%E4%BC%B4%E5%A5%8F.jpg" alt="UVR5去伴奏"></p>
<p>然后对处理完后的人声文件再做一次去混响处理，推荐采用以下配置：</p>
<ol>
<li>Process Method: VR Architecture</li>
<li>Window Size: 320</li>
<li>Aggression Setting: 10</li>
<li>VR Model: 5_HP-Karaoke_UVR</li>
<li>勾选GPU Conversion</li>
<li>勾选Voacls Only</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_UVR5_%E5%8E%BB%E6%B7%B7%E5%93%8D.jpg" alt="UVR5去混响"></p>
<p>这样简单的几步，我们就将干声从歌曲文件中提取出来了，如果你觉得提取出来的效果差强人意，也可以使用 <a href="https://hitnmix.com/audio-manipulation/" target="_blank" rel="noopener">RipX DeepAudio</a> 做一些精修</p>
<p>将文件导入RipX中，会产生如下图一样的一段曲线</p>
<p>点击其中的某段黄色曲线可以播放这段音频，我们可以一段段听过去，遇到杂音部分可以将其手动删除</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_ripx.jpg" alt="RipX"></p>
<h2 id="匹配响度"><a href="#匹配响度" class="headerlink" title="匹配响度"></a>匹配响度</h2><p>如果你的干声素材的来源不同，很可能会有素材响度大小不一的情况，这种情况下需要使用AU对所有音频去做匹配响度，使所有素材的分贝值在一个统一的范围内</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/match-loudness.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/match-loudness.html</a></p>
<h2 id="压限"><a href="#压限" class="headerlink" title="压限"></a>压限</h2><p>干声的响度不宜超过-6db，建议使用<code>Adobe Audition</code>中的压限器将声音的分贝限制在-6db以内</p>
<p>教程：<a href="https://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html" target="_blank" rel="noopener">https://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html</a></p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>干声素材都处理完后，下一步就是将这些素材切成一个个2-15s的小片段（片段太长容易爆显存，最好不要超过20s），这里推荐使用 <a href="https://github.com/flutydeer/audio-slicer" target="_blank" rel="noopener">Audio Slicer</a> ，可以根据响度阈值和间隔时间等自动将音频切片</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_AudioSlicer.jpg" alt="Audio Slicer"></p>
<p>将干声文件拖进去后可以先使用默认参数切一遍，然后去输出目录，将文件按文件大小由大到小排列，查看是否还有大于15s的音频切片，如有的话，将这些音频重新拖入软件中，按照以下参数重新切片一次：</p>
<ol>
<li>Threshold（db）: -20</li>
<li>Minimum Interval: 100</li>
<li>Maximum Silence Length（ms）: 500</li>
</ol>
<p>一般这样就不会有大于15s的音频了，如果还有的话，我将这些参数的含义列在下面，大家可以自己调整参数尝试，大家也可以使用其他的一些音频处理工具（如：AU）手动切片</p>
<ul>
<li>Threshold（阈值）</li>
</ul>
<p>以 dB 表示的 RMS 阈值。所有 RMS 值都低于此阈值的区域将被视为静音。如果音频有噪音，请增加此值。默认值为 -40。</p>
<ul>
<li>Minimum Length（最小长度）</li>
</ul>
<p>每个切片音频剪辑所需的最小长度，以毫秒为单位。默认值为 5000。</p>
<ul>
<li>Minimum Interval（最小间距）</li>
</ul>
<p>要切片的静音部分的最小长度，以毫秒为单位。如果音频仅包含短暂的中断，请将此值设置得更小。此值越小，此应用程序可能生成的切片音频剪辑就越多。请注意，此值必须小于 min length 且大于 hop size。默认值为 300。</p>
<ul>
<li>Hop Size（跳跃步长）</li>
</ul>
<p>每个 RMS 帧的长度，以毫秒为单位。增加此值将提高切片的精度，但会降低处理速度。默认值为 10。</p>
<ul>
<li>Maximum Silence Length（最大静音长度）</li>
</ul>
<p>在切片音频周围保持的最大静音长度，以毫秒为单位。根据需要调整此值。请注意，设置此值并不意味着切片音频中的静音部分具有完全给定的长度。如上所述，该算法将搜索要切片的最佳位置。默认值为 1000。</p>
<p>最后，记得把过短的音频切片删除掉</p>
<h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>数据集的格式必须是<code>wav</code>原始波形格式，大家检查一下，如果如果有非<code>wav</code>格式的文件，需要做一下格式转换，推荐使用<code>Foobar2000</code>，或者直接使用<code>FFmepg</code>进行转换</p>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p>数据集中不能出现中文等非英文字符，特殊字符推荐只使用下划线，<code>Windows</code>下直接将文件全选后重命名，文件名会变成以下这种格式：</p>
<ul>
<li>xxx (1).wav</li>
<li>xxx (2).wav</li>
<li>…</li>
</ul>
<p>本人亲测这样命名虽然会报Warning，但不影响训练，是可行的</p>
<h1 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h1><p>接着我们就开始准备训练了</p>
<h2 id="放置数据集"><a href="#放置数据集" class="headerlink" title="放置数据集"></a>放置数据集</h2><p>首先将处理好的干声全部放到一个文件夹下，然后再将这个文件夹放到<code>so-vits-svc</code>目录下的<code>dataset_raw</code>文件夹下</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%94%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E9%9B%86.jpg" alt="放置数据集"></p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>打开webui界面，切换到训练选项卡，首先点击<code>识别数据集</code>，上面的文本框中便会显示出我们准备好的数据集名，然后选择训练使用的<code>编码器</code>和<code>f0预测器</code>，这里选择我图中标出的两个选项，是目前效果比较好的选项，接着点击数据预处理，在预处理输出信息那一栏会打印进度，耐心等待它跑完</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86.jpg" alt="数据预处理"></p>
<h2 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h2><p>等待数据预处理完成后，我们要将训练的设置和参数写入到配置文件中</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E8%AE%AD%E7%BB%83%E9%85%8D%E7%BD%AE.jpg" alt="训练配置"></p>
<p>介绍一下这里参数的含义和推荐设置：</p>
<ol>
<li>每隔多少步(steps)生成一次评估日志：每隔一定步数输出一下当前步数下的学习率，loss值等信息，根据个人偏好自己填写即可</li>
<li>每隔多少步(steps)验证并保存一次模型：字面意思，根据个人偏好自己填写即可</li>
<li>仅保留最新的X个模型：我训练到11万步时一个模型接近600MB，大家根据自己的硬盘大小和个人偏好填写即可</li>
<li>批量大小：大的batch size可以减少训练时间，提高稳定性，但同时也会导致模型泛化能力下降，所以，就算你的显存很大也不建议将本参数设置的过大，推荐使用4</li>
<li>学习率：初始学习率过大会导致模型无法收敛，过小则会导致模型收敛特别慢或无法学习，建议使用默认值0.0001</li>
<li>使用fp16混合精度训练：混合精度训练是在尽可能减少精度损失的情况下利用半精度浮点数加速训练，它使用FP16即半精度浮点数存储权重和梯度，在减少占用内存的同时起到了加速训练的效果，理论上来说使用混合精度几乎不会造成精度损失，但目前没对模型质量的影响尚未查证，在显卡性能足够的情况下建议还是先不要勾选</li>
<li>加载数据集到内存中：在内存足够的情况下建议勾选，可以加快训练速度</li>
</ol>
<p>所有训练参数设置好后，点击下面的写入配置文件按钮，在下面的输出信息那里会显示<code>配置文件写入完成</code>，接下来就可以开始正式训练了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%86%99%E5%85%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg" alt="写入配置文件"></p>
<h1 id="正式训练"><a href="#正式训练" class="headerlink" title="正式训练"></a>正式训练</h1><p>点击下面的<code>从头开始训练</code>，会弹出一个新的终端窗口，在这个终端窗口中，会不断的输出当前训练的日志</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83.jpg" alt="开始训练"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E8%AE%AD%E7%BB%83%E7%BB%88%E7%AB%AF%E7%AA%97%E5%8F%A3.jpg" alt="训练终端窗口"></p>
<p>我的训练参数设置的是每隔200步生成一次评估日志，每隔1000步保存一次模型，日志中输出的<code>reference_loss</code>值代表了模型的输出与真实值之间的差距，理论来说，这个值越低越好，越低，模型输出的声音就和真人的声音越像，但从经验来说未必如此，过低的loss值也可能代表了模型过拟合，我们只能将这个参数作为一个参考，实际效果要使用测试了这个模型后才能得知，我们可以参考这个值初步选择模型进行推理测试</p>
<p>训练是不会自动终止的，当我们感觉训练的差不多了，想试一下模型的实际效果时，可以在训练终端窗口中键盘键入<code>Ctrl + C</code>停止训练，如果对本次训练出来的模型还不满意，想要继续训练，则可以点击<code>继续上一次的训练进度</code>，程序会从上一个自动保存的模型的进度开始继续训练</p>
<h1 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h1><h2 id="加载模型"><a href="#加载模型" class="headerlink" title="加载模型"></a>加载模型</h2><p>模型训练完后我们就可以将选项卡切换到<code>推理</code>来测试模型的实际效果了</p>
<p>我们先点击<code>刷新选项</code>，此时在<code>模型选择</code>和<code>配置文件</code>的下拉菜单中就出现了我们之前训练好的模型，参考之前的<code>reference_loss</code>值我们选取一个模型（G开头），并且选择训练所使用的配置文件，点击加载模型，等待下面的<code>Output Message</code>文本框出现<code>模型加载成功</code>字样，就可以正式开始我们的推理了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B.jpg" alt="加载模型"></p>
<h2 id="开始推理"><a href="#开始推理" class="headerlink" title="开始推理"></a>开始推理</h2><p>Sovits是一个声音转换工具，我们首先需要找一段想要转换的原声音频，和准备数据集那一章的要求一样，我们需要一段干声，不能有伴奏、混响、和声。如果想让模型唱歌的话，我们可以采用前面准备数据集所用的方法，直接将原曲去伴奏混响，处理好后将其拖入音频上传区域中</p>
<p>默认的 <code>pm</code> f0预测器推理出来的音质效果最好，所以建议先使用默认参数推理一遍，出现问题再针对性的对参数进行调整</p>
<p>我们点击下面的<code>音频转换</code>按钮，稍等一会儿，在<code>Output Audio</code>那里便会生成一段推理后的音频</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83_%E6%8E%A8%E7%90%86.png" alt="推理"></p>
<p>我们试听后根据具体的问题设置转换参数：</p>
<ul>
<li>出现哑音</li>
</ul>
<p>哑音是因为原声音频中的和声部分没有去处干净，导致f0预测器对音高的预测出现了错误，预测成了一个极高的音高，模型唱不上去导致的</p>
<p>有两种办法解决这个问题，一种就是从源头解决问题，想办法将原声音频的和声混响去除，获得更纯净的干声重新推理，另一种方法可以将f0预测器换成<code>crepe</code>，适度调节<code>F0过滤阈值</code>（一般使用默认值就行，改大改小没什么区别），然后重新进行推理基本就可以解决这个问题，但是音质不如f0预测器<code>pm</code>，电流音等杂音会变多，两种方法大家可以自行判断选取</p>
<ul>
<li>音域差距过大</li>
</ul>
<p>如果训练的模型是男声，但推理使用的原声是女声，或者反过来，碰到这种音域差距过大的情况会导致推理出来的音频不堪入耳</p>
<p>我们可以打开f0自动预测选项来解决这个问题，但正如选项里描述的那样，此选择仅限于转换语音时才可用，转换歌声时打开此选项会导致灾难性的跑调</p>
<p>如果是歌声并且实在是想要唱这首歌的话，建议去找一个和自己音域比较契合的翻唱音频，用这个音频处理后作为原声进行推理</p>
<ul>
<li>部分音调唱不上（下）去</li>
</ul>
<p>训练时喂的数据集没有覆盖到部分音域</p>
<p>这里的变调选项似乎是先推理再变调？所以对这种情况不起作用，建议使用AU先将原声音频升降调到合适的音域，再进行推理</p>
<ul>
<li>爆显存</li>
</ul>
<p>在推理的过程中有可能会出现爆显存的情况，因为推理也是将原音频按照响度阈值切成一段段小切片分别进行推理，最后再合成，如果其中有一段切片时常过长就可能会导致爆显存</p>
<p>我们可以将切片阈值调高，使得原声音频可以切的更加细碎，甚至你也可以直接调整音频自动切片的值开启强制切片，比如输入10，音频就会被切成每10s一段，确保音频时常不会爆显存</p>
<h1 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h1><p>如果转换的是歌声，最后可以将转换出来的干声和伴奏合并成一个音频文件，可以使用AU等软件，在合成之前还可以对干声进行一些EQ、混响的调整等，关于音乐方面的知识这里就不多说了</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>最后贴一下我自己练的模型所推理出来的歌声，使用了30分钟质量较好的干声素材和30分钟质量较差的素材（噪音和混响比较多），训练了11万步，使用<code>crepe</code>f0预测器推理得出</p>
<p>链接：<a href="https://www.bilibili.com/audio/au3907000" target="_blank" rel="noopener">https://www.bilibili.com/audio/au3907000</a></p>
<p>这是我第一次尝试训练Sovits模型，如果有什么疏漏或错误欢迎大家指出</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/01/android/animation/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E7%9B%91%E5%90%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%EF%BC%9FAnimationDrawable%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">如何完美监听帧动画？AnimationDrawable深度解析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%8A%A8%E7%94%BB/">动画</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8A%A8%E7%94%BB/">动画</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AnimationDrawable/">AnimationDrawable</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作为苦逼的程序员，产品和设计提出来的需求咱也没法拒绝，这不，前两天设计就给提了个需求，要求在帧动画结束后，把原位置的动画替换成一段文字。我们知道，在<code>Android</code>中，帧动画的实现类为<code>AnimationDrawable</code>，而这玩意儿又不像<code>Animator</code>一样可以通过<code>addListener</code>之类的方法监听动画的开始、结束等事件，那我们该怎么监听<code>AnimationDrawable</code>的结束事件呢？</p>
<p>目前网上大多数的做法都是获取帧动画的总时长，然后用<code>Handler</code>做一个<code>postDelayed</code>执行结束后的事情。这种方法怎么说呢？能用，但是不够精准也不够优雅，本文我们将从源码层面解析<code>AnimationDrawable</code>是如何将一帧帧的图片组合起来展示成连续的动画的，再从中寻求动画监听的切入点。</p>
<p><strong>注：只想看实现的朋友们可以直接跳到 包装Drawable.Callback 这一节看最终实现</strong></p>
<h1 id="ImageView如何展示Drawable"><a href="#ImageView如何展示Drawable" class="headerlink" title="ImageView如何展示Drawable"></a>ImageView如何展示Drawable</h1><p><code>AnimationDrawable</code>说到底它也就是个<code>Drawable</code>，而我们一般都是使用<code>ImageView</code>作为<code>Drawable</code>展示的布局，那我们就以此作为入口开始分析<code>Drawable</code>在<code>ImageView</code>中是如何被展示的。</p>
<p>回想一下，我们想要给一个<code>ImageView</code>设置图片一般可以用下面几种方法：</p>
<ul>
<li><code>setImageBitmap</code></li>
<li><code>setImageResource</code></li>
<li><code>setImageURI</code></li>
<li><code>setImageDrawable</code></li>
</ul>
<p><code>setImageBitmap</code>会将<code>Bitmap</code>包装成一个<code>BitmapDrawable</code>，然后再调用<code>setImageDrawable</code>方法。</p>
<p><code>setImageResource</code>和<code>setImageURI</code>方法会通过<code>resolveUri</code>方法从<code>Resource</code>或<code>Uri</code>中解析出<code>Drawable</code>，然后调用<code>updateDrawable</code>方法</p>
<p><code>setImageDrawable</code>方法则会直接调用<code>updateDrawable</code>方法</p>
<p>最终殊途同归走到<code>updateDrawable</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDrawable</span><span class="params">(Drawable d)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sameDrawable = mDrawable == d;</span><br><span class="line">        mDrawable.setCallback(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleDrawable(mDrawable);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawable = d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d != <span class="keyword">null</span>) &#123;</span><br><span class="line">        d.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将我们设置的图片资源赋值到<code>mDrawable</code>上。注意，这里有一个<code>Drawable</code>动起来的关键点，同时也是我们动画监听的最终切入点：<code>Drawable.setCallback(this)</code>，我们后面分析帧切换的时候会详细去聊它。</p>
<p>我们知道，一个控件想要绘制内容得在<code>onDraw</code>方法中操作<code>Canvas</code>，所以让我们再来看看<code>onDraw</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// couldn't resolve the URI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDrawableWidth == <span class="number">0</span> || mDrawableHeight == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;     <span class="comment">// nothing to draw (empty bounds)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    mDrawable.draw(canvas);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里调用了<code>Drawable.draw</code>方法将<code>Drawable</code>自身绘制到<code>ImageView</code>的<code>Canvas</code>上</p>
<h1 id="DrawableContainer"><a href="#DrawableContainer" class="headerlink" title="DrawableContainer"></a>DrawableContainer</h1><p>查看<code>AnimationDrawable</code>的继承关系我们可以得知它继承自<code>DrawableContainer</code>，从命名中我们就能看出来，它是<code>Drawable</code>的容器，我们来看一下它所实现的<code>draw</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCurrDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCurrDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLastDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLastDrawable.draw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mLastDrawable</code>是为了完成动画的切换效果（出入场动画）所准备的，我们可以不用关心它。</p>
<p>我们可以发现，它的内部有一个名为<code>mCurrDrawable</code>的成员变量，我们可以合理猜测它是通过切换<code>mCurrDrawable</code>指向的目标<code>Drawable</code>来完成展示不同图片的功能，那么事实是这样吗？</p>
<p>没错，<code>DrawableContainer</code>给我们提供了一个<code>selectDrawable</code>方法，用来切换不同的图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">selectDrawable</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == mCurIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; mDrawableContainerState.mNumChildren) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable d = mDrawableContainerState.getChild(index);</span><br><span class="line">        mCurrDrawable = d;</span><br><span class="line">        mCurIndex = index;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCurrDrawable = <span class="keyword">null</span>;</span><br><span class="line">        mCurIndex = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    invalidateSelf();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和我们猜想的一样，在<code>DrawableContainer</code>的内部有一个子类<code>DrawableContainerState</code>用于保存所有的<code>Drawable</code>，它继承自<code>Drawable.ConstantState</code>，是用来储存<code>Drawable</code>间的常量状态和数据的。在<code>DrawableContainerState</code>中有一个<code>mDrawables</code>数组用于保存所有的<code>Drawable</code>，通过<code>addChild</code>方法将<code>Drawable</code>加入到这个数组中</p>
<p>而在<code>selectDrawable</code>方法中，它通过<code>getChild</code>方法去获取当前应该显示的<code>Drawable</code>，并将其和<code>index</code>分别赋值给它的两个成员变量<code>mCurrDrawable</code>和<code>mCurIndex</code>，然后调用<code>invalidateSelf</code>方法执行重绘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.invalidateDrawable(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invalidateSelf</code>被定义实现在<code>Drawable</code>类中，还记得我之前让大家注意的<code>Callback</code>吗？在设置图片这一步时，它就被赋值了，实际上这个接口被<code>View</code>所实现，所以在前面我们可以看到调用<code>setCallback</code>时，我们传入的参数为<code>this</code></p>
<p>不过<code>ImageView</code>在继承<code>View</code>的同时也重写了这个<code>invalidateDrawable</code>方法，最终调用了<code>invalidate</code>方法执行重绘，此时，一张新的图片就被展示到我们的屏幕上了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ImageView.invalidateDrawable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidateDrawable</span><span class="params">(@NonNull Drawable dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dr == mDrawable) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// update cached drawable dimensions if they've changed</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> w = dr.getIntrinsicWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> h = dr.getIntrinsicHeight();</span><br><span class="line">            <span class="keyword">if</span> (w != mDrawableWidth || h != mDrawableHeight) &#123;</span><br><span class="line">                mDrawableWidth = w;</span><br><span class="line">                mDrawableHeight = h;</span><br><span class="line">                <span class="comment">// updates the matrix, which is dependent on the bounds</span></span><br><span class="line">                configureBounds();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* we invalidate the whole view in this case because it's very</span></span><br><span class="line"><span class="comment">            * hard to know where the drawable actually is. This is made</span></span><br><span class="line"><span class="comment">            * complicated because of the offsets and transformations that</span></span><br><span class="line"><span class="comment">            * can be applied. In theory we could get the drawable's bounds</span></span><br><span class="line"><span class="comment">            * and run them through the transformation and offsets, but this</span></span><br><span class="line"><span class="comment">            * is probably not worth the effort.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        invalidate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.invalidateDrawable(dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AnimationDrawable"><a href="#AnimationDrawable" class="headerlink" title="AnimationDrawable"></a>AnimationDrawable</h1><p><code>DrawableContainer</code>分析完后，我们可以很自然的想到，<code>AnimationDrawable</code>就是通过<code>DrawableContainer</code>这种可以切换图片的机制，每隔一定时间执行一下<code>selectDrawable</code>便可以达成帧动画的效果了。</p>
<p>我们先回想一下，在代码中怎么构造出一个多帧的<code>AnimationDrawable</code>？没错，用默认构造方法实例化出来后，调用它的<code>addFrame</code>方法往里一帧帧的添加图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrame</span><span class="params">(@NonNull Drawable frame, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mAnimationState.addFrame(frame, duration);</span><br><span class="line">    <span class="keyword">if</span> (!mRunning) &#123;</span><br><span class="line">        setFrame(<span class="number">0</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>AnimationDrawable</code>也有一个内部类<code>AnimationState</code>，继承自<code>DrawableContainerState</code>，它的<code>addFrame</code>方法就是调用<code>DrawableContainerState.addChild</code>方法添加图片，同时将这张图片的持续时间保存在<code>mDurations</code>数组中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFrame</span><span class="params">(Drawable dr, <span class="keyword">int</span> dur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="keyword">super</span>.addChild(dr);</span><br><span class="line">    mDurations[pos] = dur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想让<code>AnimationDrawable</code>动起来的话，我们得要调用它的<code>start</code>方法，那我们就从这个方法开始分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAnimating = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRunning()) &#123;</span><br><span class="line">        <span class="comment">// Start from 0th frame.</span></span><br><span class="line">        setFrame(<span class="number">0</span>, <span class="keyword">false</span>, mAnimationState.getChildCount() &gt; <span class="number">1</span></span><br><span class="line">                || !mAnimationState.mOneShot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将<code>mAnimating</code>状态置为<code>true</code>，然后调用<code>setFrame</code>方法从第0帧开始展示图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> frame, <span class="keyword">boolean</span> unschedule, <span class="keyword">boolean</span> animate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame &gt;= mAnimationState.getChildCount()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimating = animate;</span><br><span class="line">    mCurFrame = frame;</span><br><span class="line">    selectDrawable(frame);</span><br><span class="line">    <span class="keyword">if</span> (unschedule || animate) &#123;</span><br><span class="line">        unscheduleSelf(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (animate) &#123;</span><br><span class="line">        <span class="comment">// Unscheduling may have clobbered these values; restore them</span></span><br><span class="line">        mCurFrame = frame;</span><br><span class="line">        mRunning = <span class="keyword">true</span>;</span><br><span class="line">        scheduleSelf(<span class="keyword">this</span>, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，和我们所想的一样，调用了<code>DrawableContainer.selectDrawable</code>切换当前展示图片，由于我们之前将<code>mAnimating</code>赋值为了<code>true</code>，所以会调用<code>scheduleSelf</code>方法调度展示下一张图片，时间为当前帧持续时间后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleSelf</span><span class="params">(@NonNull Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Callback callback = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callback.scheduleDrawable(<span class="keyword">this</span>, what, when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>scheduleSelf</code>方法调用了<code>Drawable.Callback.scheduleDrawable</code>方法，我们去<code>View</code>里面看实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleDrawable</span><span class="params">(@NonNull Drawable who, @NonNull Runnable what, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (verifyDrawable(who) &amp;&amp; what != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = when - SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed(</span><br><span class="line">                    Choreographer.CALLBACK_ANIMATION, what, who,</span><br><span class="line">                    Choreographer.subtractFrameDelay(delay));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Postpone the runnable until we know</span></span><br><span class="line">            <span class="comment">// on which thread it needs to run.</span></span><br><span class="line">            getRunQueue().postDelayed(what, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上两个分支最终都是通过<code>Handler</code>实现延时调用，而调用的<code>Runnable</code>对象就是之前<code>scheduleSelf</code>传入的<code>this</code>。没错，<code>AnimationDrawable</code>实现了<code>Runnable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    nextFrame(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextFrame</span><span class="params">(<span class="keyword">boolean</span> unschedule)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nextFrame = mCurFrame + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numFrames = mAnimationState.getChildCount();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop if necessary. One-shot animations should never hit this case.</span></span><br><span class="line">    <span class="keyword">if</span> (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) &#123;</span><br><span class="line">        nextFrame = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setFrame(nextFrame, unschedule, !isLastFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在一帧持续时间结束后，便会调用<code>nextFrame</code>方法，计算下一帧的<code>index</code>，然后调用<code>setFrame</code>方法切换下一帧，形成一个循环，这样一帧帧的图片便动了起来，形成了帧动画</p>
<h1 id="包装Drawable-Callback"><a href="#包装Drawable-Callback" class="headerlink" title="包装Drawable.Callback"></a>包装Drawable.Callback</h1><p>我们从源码层面分析了帧动画是如何运作的，那么怎么监听动画事件相信各位应该都能得出结论了吧？没错，就是重设<code>Drawable</code>的<code>Callback</code></p>
<p>当<code>Drawable</code>被设置到控件中后，控件会将自身作为<code>Drawable.Callback</code>设置给<code>Drawable</code>，那么我们只需要重新给<code>Drawable</code>设置一个<code>Drawable.Callback</code>，在其中调用<code>View</code>回调方法的同时，加入自己的监听逻辑即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animDrawable = imageView.drawable <span class="keyword">as</span> AnimationDrawable</span><br><span class="line"><span class="keyword">val</span> callback = <span class="keyword">object</span> : Drawable.Callback &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invalidateDrawable</span><span class="params">(who: <span class="type">Drawable</span>)</span></span> &#123;</span><br><span class="line">        imageView.invalidateDrawable(who)</span><br><span class="line">        <span class="keyword">if</span> (animDrawable.getFrame(animDrawable.numberOfFrames - <span class="number">1</span>) == current </span><br><span class="line">                &amp;&amp; animDrawable.isOneShot </span><br><span class="line">                &amp;&amp; animDrawable.isRunning </span><br><span class="line">                &amp;&amp; animDrawable.isVisible</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">val</span> lastFrameDuration = getDuration(animDrawable.numberOfFrames - <span class="number">1</span>)</span><br><span class="line">            postDelayed(&#123; ...<span class="comment">//结束后需要做的事 &#125;, lastFrameDuration.toLong())</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>, `<span class="keyword">when</span>`: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">        imageView.scheduleDrawable(who, what, `<span class="keyword">when</span>`)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">unscheduleDrawable</span><span class="params">(who: <span class="type">Drawable</span>, what: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        imageView.unscheduleDrawable(who, what)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意一定需要用一个成员变量或其他方式持有这个Callback</span></span><br><span class="line"><span class="comment">//因为Drawable.Callback是以弱引用的形式被保存在Drawable内的，很容易被回收</span></span><br><span class="line">mCallbackHolder = callback</span><br><span class="line">animDrawable.callback = callback</span><br><span class="line">animDrawable.start()</span><br></pre></td></tr></table></figure>

<p>以上的代码便是示例，当满足动画运行到最后一帧，且满足结束状态时，在最后一帧的持续时间后处理结束后需要做的事</p>
<p>当<code>AnimationDrawable</code>切换<code>Visible</code>状态为<code>false</code>时，动画会被暂停，如果在动画结束后触发<code>setVisible(false)</code>事件，也会触发<code>invalidateDrawable</code>回调，所以这里需要额外判断一下<code>isVisible</code></p>
<p>自己包装的<code>Drawable.Callback</code>一定需要找个东西将它强引用起来，因为<code>Drawable.Callback</code>是以弱引用的形式被保存在<code>Drawable</code>内的，很容易被回收，一旦被回收，整个<code>AnimationDrawable</code>动画就动不起来了</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>为了这么简单一个小功能，还得跑到源码里看怎么实现，对此我的感受是：一入安卓深似海，从此头发是路人</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/04/23/android/common/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/">Android动态权限申请从未如此简单</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%9D%83%E9%99%90/">权限</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android/">Android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%9D%83%E9%99%90/">权限</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>注：只想看实现的朋友们可以直接跳到最后面的最终实现</strong></p>
<p>大家是否还在为动态权限申请感到苦恼呢？传统的动态权限申请需要在<code>Activity</code>中重写<code>onRequestPermissionsResult</code>方法来接收用户权限授予的结果。试想一下，你需要在一个子模块中申请权限，那得从这个模块所在的<code>Activity</code>的<code>onRequestPermissionsResult</code>中将结果一层层再传回到这个模块中，相当的麻烦，代码也相当冗余和不干净，逼死强迫症。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>为了解决这个痛点，我封装出了两个方法，用于随时随地快速的动态申请权限，我们先来看看我们的封装方法是如何调用的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">activity.requestPermission(Manifest.permission.CAMERA, onPermit = &#123;</span><br><span class="line">    <span class="comment">//申请权限成功 Do something</span></span><br><span class="line">&#125;, onDeny = &#123; shouldShowCustomRequest -&gt;</span><br><span class="line">    <span class="comment">//申请权限失败 Do something</span></span><br><span class="line">    <span class="keyword">if</span> (shouldShowCustomRequest) &#123;</span><br><span class="line">        <span class="comment">//用户选择了拒绝并且不在询问，此时应该使用自定义弹窗提醒用户授权（可选）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样是不是非常的简单便捷？申请和结果回调都在一个方法内处理，并且支持随用随调。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>那么，这么方便好用的方法是怎么实现的呢？不知道小伙伴们在平时开发中有没有注意到过，当你调用<code>startActivityForResult</code>时，AS会提示你该方法已被弃用，点进去看会告诉你应该使用<code>registerForActivityResult</code>方法替代。没错，这就是<code>androidx</code>给我们提供的<code>ActivityResult</code>功能，并且这个功能不仅支持<code>ActivityResult</code>回调，还支持打开文档，拍摄照片，选择文件等各种各样的回调，同样也包括我们今天要说的权限申请</p>
<p>其实Android在官方文档 <a href="https://developer.android.com/training/permissions/requesting?hl=zh-cn" target="_blank" rel="noopener">请求运行时权限</a> 中就已经将其作为动态权限申请的推荐方法了，如下示例代码所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> requestPermissionLauncher =</span><br><span class="line">    registerForActivityResult(RequestPermission()</span><br><span class="line">    ) &#123; isGranted: <span class="built_in">Boolean</span> -&gt;</span><br><span class="line">        <span class="keyword">if</span> (isGranted) &#123;</span><br><span class="line">            <span class="comment">// Permission is granted. Continue the action or workflow in your</span></span><br><span class="line">            <span class="comment">// app.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Explain to the user that the feature is unavailable because the</span></span><br><span class="line">            <span class="comment">// feature requires a permission that the user has denied. At the</span></span><br><span class="line">            <span class="comment">// same time, respect the user's decision. Don't link to system</span></span><br><span class="line">            <span class="comment">// settings in an effort to convince the user to change their</span></span><br><span class="line">            <span class="comment">// decision.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">when</span> &#123;</span><br><span class="line">    ContextCompat.checkSelfPermission(</span><br><span class="line">            CONTEXT,</span><br><span class="line">            Manifest.permission.REQUESTED_PERMISSION</span><br><span class="line">            ) == PackageManager.PERMISSION_GRANTED -&gt; &#123;</span><br><span class="line">        <span class="comment">// You can use the API that requires the permission.</span></span><br><span class="line">    &#125;</span><br><span class="line">    shouldShowRequestPermissionRationale(...) -&gt; &#123;</span><br><span class="line">        <span class="comment">// In an educational UI, explain to the user why your app requires this</span></span><br><span class="line">        <span class="comment">// permission for a specific feature to behave as expected, and what</span></span><br><span class="line">        <span class="comment">// features are disabled if it's declined. In this UI, include a</span></span><br><span class="line">        <span class="comment">// "cancel" or "no thanks" button that lets the user continue</span></span><br><span class="line">        <span class="comment">// using your app without granting the permission.</span></span><br><span class="line">        showInContextUI(...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">        <span class="comment">// You can directly ask for the permission.</span></span><br><span class="line">        <span class="comment">// The registered ActivityResultCallback gets the result of this request.</span></span><br><span class="line">        requestPermissionLauncher.launch(</span><br><span class="line">                Manifest.permission.REQUESTED_PERMISSION)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到这里，可能有小伙伴要质疑我了：“官方文档里都写明了的东西，你还特地写一遍，还起了这么个标题，是不是在水文章？！”</p>
<p>莫急，如果你遵照以上方法这么写的话，在实际调用的时候会直接发生崩溃：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: </span><br><span class="line">LifecycleOwner Activity is attempting to register while current state is RESUMED. </span><br><span class="line">LifecycleOwners must call register before they are STARTED.</span><br></pre></td></tr></table></figure>

<p>这段报错很明显的告诉我们，我们的注册工作必须要在<code>Activity</code>声明周期<code>STARTED</code>之前进行（也就是<code>onCreate</code>时和<code>onStart</code>完成前），但这样我们就必须要事先注册好所有可能会用到的权限，没办法做到随时随地有需要时再申请权限了，有办法解决这个问题吗？答案是肯定的。</p>
<h1 id="绕过生命周期检测"><a href="#绕过生命周期检测" class="headerlink" title="绕过生命周期检测"></a>绕过生命周期检测</h1><p>想解决这个问题，我们必须要知道问题的成因，让我们带着问题进到源码中一探究竟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">registerForActivityResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerForActivityResult(contract, mActivityResultRegistry, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">registerForActivityResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registry.register(</span><br><span class="line">            <span class="string">"activity_rq#"</span> + mNextLocalRequestCode.getAndIncrement(), <span class="keyword">this</span>, contract, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> String key,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> LifecycleOwner lifecycleOwner,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Lifecycle lifecycle = lifecycleOwner.getLifecycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"LifecycleOwner "</span> + lifecycleOwner + <span class="string">" is "</span></span><br><span class="line">                + <span class="string">"attempting to register while current state is "</span></span><br><span class="line">                + lifecycle.getCurrentState() + <span class="string">". LifecycleOwners must call register before "</span></span><br><span class="line">                + <span class="string">"they are STARTED."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    registerKey(key);</span><br><span class="line">    LifecycleContainer lifecycleContainer = mKeyToLifecycleContainers.get(key);</span><br><span class="line">    <span class="keyword">if</span> (lifecycleContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lifecycleContainer = <span class="keyword">new</span> LifecycleContainer(lifecycle);</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleEventObserver observer = <span class="keyword">new</span> LifecycleEventObserver() &#123; ... &#125;;</span><br><span class="line">    lifecycleContainer.addObserver(observer);</span><br><span class="line">    mKeyToLifecycleContainers.put(key, lifecycleContainer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，<code>registerForActivityResult</code>实际上就是调用了<code>ComponentActivity</code>内部成员变量的<code>mActivityResultRegistry.register</code>方法，而在这个方法的一开头就检查了当前<code>Activity</code>的生命周期，如果生命周期位于<code>STARTED</code>后则直接抛出异常，那我们该如何绕过这个限制呢？</p>
<p>其实在<code>register</code>方法的下面就有一个同名重载方法，这个方法并没有做生命周期的检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;I, O&gt; <span class="function">ActivityResultLauncher&lt;I&gt; <span class="title">register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> String key,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultContract&lt;I, O&gt; contract,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull <span class="keyword">final</span> ActivityResultCallback&lt;O&gt; callback)</span> </span>&#123;</span><br><span class="line">    registerKey(key);</span><br><span class="line">    mKeyToCallback.put(key, <span class="keyword">new</span> CallbackAndContract&lt;&gt;(callback, contract));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParsedPendingResults.containsKey(key)) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> O parsedPendingResult = (O) mParsedPendingResults.get(key);</span><br><span class="line">        mParsedPendingResults.remove(key);</span><br><span class="line">        callback.onActivityResult(parsedPendingResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ActivityResult pendingResult = mPendingResults.getParcelable(key);</span><br><span class="line">    <span class="keyword">if</span> (pendingResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingResults.remove(key);</span><br><span class="line">        callback.onActivityResult(contract.parseResult(</span><br><span class="line">                pendingResult.getResultCode(),</span><br><span class="line">                pendingResult.getData()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到这个方法就简单了，我们将<code>registerForActivityResult</code>方法调用替换成<code>activityResultRegistry.register</code>调用就可以了</p>
<p>当然，我们还需要注意一些小细节，检查生命周期的<code>register</code>方法同时也会注册生命周期回调，当<code>Activity</code>被销毁时会将我们注册的<code>ActivityResult</code>回调移除，我们也需要给我们封装的方法加上这个逻辑，最终实现就如下所示。</p>
<h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> nextLocalRequestCode = AtomicInteger()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> nextKey: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="string">"activity_rq#<span class="subst">$&#123;nextLocalRequestCode.getAndIncrement()&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">requestPermission</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    permission: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onPermit: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onDeny: (<span class="type">shouldShowCustomRequest</span>: <span class="type">Boolean</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, permission) == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        onPermit()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> launcher <span class="keyword">by</span> Delegates.notNull&lt;ActivityResultLauncher&lt;String&gt;&gt;()</span><br><span class="line">    launcher = activityResultRegistry.register(</span><br><span class="line">        nextKey,</span><br><span class="line">        ActivityResultContracts.RequestPermission()</span><br><span class="line">    ) &#123; result -&gt;</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            onPermit()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onDeny(!ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, permission))</span><br><span class="line">        &#125;</span><br><span class="line">        launcher.unregister()</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                launcher.unregister()</span><br><span class="line">                lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    launcher.launch(permission)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">requestPermissions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    onPermit: () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onDeny: (<span class="type">shouldShowCustomRequest</span>: <span class="type">Boolean</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> hasPermissions = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (permission <span class="keyword">in</span> permissions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                permission</span><br><span class="line">            ) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        ) &#123;</span><br><span class="line">            hasPermissions = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasPermissions) &#123;</span><br><span class="line">        onPermit()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> launcher <span class="keyword">by</span> Delegates.notNull&lt;ActivityResultLauncher&lt;Array&lt;String&gt;&gt;&gt;()</span><br><span class="line">    launcher = activityResultRegistry.register(</span><br><span class="line">        nextKey,</span><br><span class="line">        ActivityResultContracts.RequestMultiplePermissions()</span><br><span class="line">    ) &#123; result -&gt;</span><br><span class="line">        <span class="keyword">var</span> allAllow = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> (allow <span class="keyword">in</span> result.values) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!allow) &#123;</span><br><span class="line">                allAllow = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allAllow) &#123;</span><br><span class="line">            onPermit()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> shouldShowCustomRequest = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">for</span> (permission <span class="keyword">in</span> permissions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ActivityCompat.shouldShowRequestPermissionRationale(<span class="keyword">this</span>, permission)) &#123;</span><br><span class="line">                    shouldShowCustomRequest = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            onDeny(shouldShowCustomRequest)</span><br><span class="line">        &#125;</span><br><span class="line">        launcher.unregister()</span><br><span class="line">    &#125;</span><br><span class="line">    lifecycle.addObserver(<span class="keyword">object</span> : LifecycleEventObserver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStateChanged</span><span class="params">(source: <span class="type">LifecycleOwner</span>, event: <span class="type">Lifecycle</span>.<span class="type">Event</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                launcher.unregister()</span><br><span class="line">                lifecycle.removeObserver(<span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    launcher.launch(permissions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多实用技巧本质上都是很简单的，但没有接触过就很难想到，我将我的开发经验分享给大家，希望能帮助到大家。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/03/08/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/">Android源码分析 - Activity销毁流程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-03-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityTaskManagerService/">ActivityTaskManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityTaskManagerService/">ActivityTaskManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>我们在之前的几篇<code>Activity</code>启动流程分析中已经了解了<code>Activity</code>一半的生命周期，接下来这篇文章我们就来分析一下<code>Activity</code>销毁相关的生命周期</p>
<p>前几期文章回顾：</p>
<p><a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a></p>
<p><a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a></p>
<p><a href="https://juejin.cn/post/7195458962328649788" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a></p>
<h1 id="触发销毁"><a href="#触发销毁" class="headerlink" title="触发销毁"></a>触发销毁</h1><p>既然要分析<code>Activity</code>销毁流程，那我们就从最常见的入口<code>Activity.finish</code>入手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    finish(DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的<code>finish</code>方法调用了另一个同名重载方法，接受一个int类型的参数表明是否需要在销毁<code>Activity</code>的同时销毁<code>Task</code>，该参数有以下三种：</p>
<ul>
<li><p><code>DONT_FINISH_TASK_WITH_ACTIVITY</code>：默认参数，表示在销毁<code>Activity</code>的时候不要销毁<code>Task</code></p>
</li>
<li><p><code>FINISH_TASK_WITH_ROOT_ACTIVITY</code>：当<code>Activity</code>为跟<code>Activity</code>的时候，销毁的同时销毁<code>Task</code>，同时这个任务也会从最近任务中移除</p>
</li>
<li><p><code>FINISH_TASK_WITH_ACTIVITY</code>：销毁<code>Activity</code>的时候同时销毁<code>Task</code>，但不会从最近任务中移除</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当finish后才可能会触发onActivityResult回调</span></span><br><span class="line">        <span class="comment">//这里准备将result返回给之前调用startActivityForResult的Activity</span></span><br><span class="line">        <span class="keyword">int</span> resultCode;</span><br><span class="line">        Intent resultData;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            resultCode = mResultCode;</span><br><span class="line">            resultData = mResultData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//两个Activity可能处于不同进程中，做进程间通信的准备</span></span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用ATMS销毁Activity</span></span><br><span class="line">            <span class="keyword">if</span> (ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(mToken, resultCode, resultData, finishTask)) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Empty</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mParent.finishFromChild(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Activity was launched when user tapped a link in the Autofill Save UI - Save UI must</span></span><br><span class="line">    <span class="comment">// be restored now.</span></span><br><span class="line">    <span class="keyword">if</span> (mIntent != <span class="keyword">null</span> &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123;</span><br><span class="line">        restoreAutofillSaveUi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onActivityResult</code>回调是在对应<code>Activity</code> <code>resume</code>时才可能触发，具体过程后面会分析，将<code>ActivityRecord.Token</code>和<code>Result</code>作为参数调用<code>ATMS.finishActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">finishActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> finishTask)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="comment">//回传的ResultIntent中不允许包含fd，防止泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (resultData != <span class="keyword">null</span> &amp;&amp; resultData.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//获取ActivityRecord并保证其在栈中</span></span><br><span class="line">        r = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="comment">//为null说明已被移出ActivityStack，视作已被finish</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Carefully collect grants without holding lock</span></span><br><span class="line">    <span class="comment">//检查调用方（即待finish的Activity）是否能授予result所对应Activity package访问uri的权限</span></span><br><span class="line">    <span class="keyword">final</span> NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// Sanity check in case activity was removed before entering global lock.</span></span><br><span class="line">        <span class="keyword">if</span> (!r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of the root activity of the task before we finish it</span></span><br><span class="line">        <span class="keyword">final</span> Task tr = r.getTask();</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord rootR = tr.getRootActivity();</span><br><span class="line">        <span class="comment">// Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can</span></span><br><span class="line">        <span class="comment">// finish.</span></span><br><span class="line">        <span class="comment">//LockTask模式下，如果此为最后一个Task，则不允许被销毁</span></span><br><span class="line">        <span class="comment">//详见：https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode</span></span><br><span class="line">        <span class="keyword">if</span> (getLockTaskController().activityBlockedFromFinish(r)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> There is a dup. of this block of code in ActivityStack.navigateUpToLocked</span></span><br><span class="line">        <span class="comment">// We should consolidate.</span></span><br><span class="line">        <span class="comment">//IActivityController分发Activity状态变化</span></span><br><span class="line">        <span class="keyword">if</span> (mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Find the first activity that is not finishing.</span></span><br><span class="line">            <span class="comment">//寻找该Activity销毁后的下一个顶层Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord next =</span><br><span class="line">                    r.getRootTask().topRunningActivity(token, INVALID_TASK_ID);</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ask watcher if this is allowed</span></span><br><span class="line">                <span class="keyword">boolean</span> resumeOK = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    resumeOK = mController.activityResuming(next.packageName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    mController = <span class="keyword">null</span>;</span><br><span class="line">                    Watchdog.getInstance().setActivityController(<span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!resumeOK) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// note down that the process has finished an activity and is in background activity</span></span><br><span class="line">        <span class="comment">// starts grace period</span></span><br><span class="line">        <span class="comment">//设置Activity销毁的最新时间</span></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> res;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> finishWithRootActivity =</span><br><span class="line">                    finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;</span><br><span class="line">            <span class="keyword">if</span> (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY</span><br><span class="line">                    || (finishWithRootActivity &amp;&amp; r == rootR)) &#123; <span class="comment">//需要同时销毁Task</span></span><br><span class="line">                <span class="comment">// If requested, remove the task that is associated to this activity only if it</span></span><br><span class="line">                <span class="comment">// was the root activity in the task. The result code and data is ignored</span></span><br><span class="line">                <span class="comment">// because we don't support returning them across task boundaries. Also, to</span></span><br><span class="line">                <span class="comment">// keep backwards compatibility we remove the task from recents when finishing</span></span><br><span class="line">                <span class="comment">// task with root activity.</span></span><br><span class="line">                <span class="comment">//移除Task</span></span><br><span class="line">                mStackSupervisor.removeTask(tr, <span class="keyword">false</span> <span class="comment">/*killProcess*/</span>,</span><br><span class="line">                        finishWithRootActivity, <span class="string">"finish-activity"</span>);</span><br><span class="line">                res = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// Explicitly dismissing the activity so reset its relaunch flag.</span></span><br><span class="line">                r.mRelaunchReason = RELAUNCH_REASON_NONE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不需要同时销毁Task</span></span><br><span class="line">                r.finishIfPossible(resultCode, resultData, resultGrants,</span><br><span class="line">                        <span class="string">"app-request"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">                res = r.finishing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法里分了两个case，当需要同时销毁<code>Task</code>的时候，直接调用<code>ActivityStackSupervisor.removeTask</code>，当不需要同时销毁<code>Task</code>的时候，调用<code>ActivityRecord.finishIfPossible</code></p>
<p>我们先看需要同时销毁<code>Task</code>的case</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeTask</span><span class="params">(Task task, <span class="keyword">boolean</span> killProcess, <span class="keyword">boolean</span> removeFromRecents, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task.mInRemoveTask) &#123;</span><br><span class="line">        <span class="comment">// Prevent recursion.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    task.mInRemoveTask = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行Task移除操作</span></span><br><span class="line">        task.performClearTask(reason);</span><br><span class="line">        <span class="comment">//对Task执行杀进程，从最近任务列表移除等操作</span></span><br><span class="line">        cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents);</span><br><span class="line">        <span class="comment">//关闭LockTask模式</span></span><br><span class="line">        mService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">        <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">        mService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        <span class="comment">//将最近任务持久化保存</span></span><br><span class="line">        <span class="keyword">if</span> (task.isPersistable) &#123;</span><br><span class="line">            mService.notifyTaskPersisterLocked(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        task.mInRemoveTask = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇文章我们主要关注的是<code>Activity</code>销毁流程，至于进程的关闭，最近任务列表的更新我们在这里就不关心了，而这里<code>Activity</code>销毁的重点在于<code>Task.performClearTask</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Completely remove all activities associated with an existing task. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performClearTask</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Broken down into to cases to avoid object create due to capturing mStack.</span></span><br><span class="line">    <span class="keyword">if</span> (getStack() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// Task was restored from persistent storage.</span></span><br><span class="line">            r.takeFromHistory();</span><br><span class="line">            removeChild(r);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        forAllActivities((r) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> figure-out how to avoid object creation due to capture of reason variable.</span></span><br><span class="line">            r.finishIfPossible(Activity.RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* resultData */</span>, <span class="keyword">null</span> <span class="comment">/* resultGrants */</span>, reason, <span class="keyword">false</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看后半部分代码可以发现，这个方法对<code>Task</code>中所有未销毁的<code>Activity</code>都执行了<code>ActivityRecord.finishIfPossible</code>方法，这样路径就和上面<code>ATMS.finishActivity</code>方法中第二个case统一了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish activity if possible. If activity was resumed - we must first pause it to make the</span></span><br><span class="line"><span class="comment"> * activity below resumed. Otherwise we will try to complete the request immediately by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #completeFinishing(String)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> One of &#123;<span class="doctag">@link</span> FinishRequest&#125; values:</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REMOVED&#125; if this activity has been removed from the history list.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_REQUESTED&#125; if removal process was started, but it is still in the list</span></span><br><span class="line"><span class="comment"> * and will be removed from history later.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #FINISH_RESULT_CANCELLED&#125; if activity is already finishing or in invalid state and the</span></span><br><span class="line"><span class="comment"> * request to finish it was not ignored.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FinishRequest</span> <span class="function"><span class="keyword">int</span> <span class="title">finishIfPossible</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants, String reason, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//防止重复销毁</span></span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此Activity不在任务栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!isInStackLocked()) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="comment">//应该调整顶部Activity</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mayAdjustTop = (isState(RESUMED) || stack.mResumedActivity == <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; stack.isFocusedStackOnDisplay();</span><br><span class="line">    <span class="comment">//应该调整全局焦点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldAdjustGlobalFocus = mayAdjustTop</span><br><span class="line">            <span class="comment">// It must be checked before &#123;@link #makeFinishingLocked&#125; is called, because a stack</span></span><br><span class="line">            <span class="comment">// is not visible if it only contains finishing activities.</span></span><br><span class="line">            &amp;&amp; mRootWindowContainer.isTopDisplayFocusedStack(stack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停布局工作</span></span><br><span class="line">    mAtmService.deferWindowLayout();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//设置当前Activity状态为finishing</span></span><br><span class="line">        makeFinishingLocked();</span><br><span class="line">        <span class="comment">// Make a local reference to its task since this.task could be set to null once this</span></span><br><span class="line">        <span class="comment">// activity is destroyed and detached from task.</span></span><br><span class="line">        <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">        <span class="comment">//获取上一个ActivityRecord</span></span><br><span class="line">        ActivityRecord next = task.getActivityAbove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//传递FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET：重置该Task时清除此Activity</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// If the caller asked that this activity (and all above it)</span></span><br><span class="line">                <span class="comment">// be cleared when the task is reset, don't lose that information,</span></span><br><span class="line">                <span class="comment">// but propagate it up to the next activity.</span></span><br><span class="line">                next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂停输入事件分发</span></span><br><span class="line">        pauseKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are finishing the top focused activity and its task has nothing to be focused so</span></span><br><span class="line">        <span class="comment">// the next focusable task should be focused.</span></span><br><span class="line">        <span class="comment">//应该调整顶部Activity，但此Task没有Activity可以被运行在顶部，将焦点转移至下一个可聚焦的Task</span></span><br><span class="line">        <span class="keyword">if</span> (mayAdjustTop &amp;&amp; ((ActivityStack) task).topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>)</span><br><span class="line">                == <span class="keyword">null</span>) &#123;</span><br><span class="line">            task.adjustFocusToNextFocusableTask(<span class="string">"finish-top"</span>, <span class="keyword">false</span> <span class="comment">/* allowFocusSelf */</span>,</span><br><span class="line">                        shouldAdjustGlobalFocus);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Result信息写入到对应ActivityRecord中，待后面resume的时候触发onActivityResult回调</span></span><br><span class="line">        finishActivityResults(resultCode, resultData, resultGrants);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止Task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> endTask = task.getActivityBelow(<span class="keyword">this</span>) == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !task.isClearingToReuseTask();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE;</span><br><span class="line">        <span class="keyword">if</span> (isState(RESUMED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//通知Task移除已开始</span></span><br><span class="line">                mAtmService.getTaskChangeNotificationController().notifyTaskRemovalStarted(</span><br><span class="line">                        task.getTaskInfo());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Prepare app close transition, but don't execute just yet. It is possible that</span></span><br><span class="line">            <span class="comment">// an activity that will be made resumed in place of this one will immediately</span></span><br><span class="line">            <span class="comment">// launch another new activity. In this case current closing transition will be</span></span><br><span class="line">            <span class="comment">// combined with open transition for the new activity.</span></span><br><span class="line">            <span class="comment">//准备Activity转场动画</span></span><br><span class="line">            mDisplayContent.prepareAppTransition(transit, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// When finishing the activity preemptively take the snapshot before the app window</span></span><br><span class="line">            <span class="comment">// is marked as hidden and any configuration changes take place</span></span><br><span class="line">            <span class="comment">//更新Task快照</span></span><br><span class="line">            <span class="keyword">if</span> (mAtmService.mWindowManager.mTaskSnapshotController != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ArraySet&lt;Task&gt; tasks = Sets.newArraySet(task);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController.snapshotTasks(tasks);</span><br><span class="line">                mAtmService.mWindowManager.mTaskSnapshotController</span><br><span class="line">                        .addSkipClosingAppSnapshotTasks(tasks);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell window manager to prepare for this one to be removed.</span></span><br><span class="line">            <span class="comment">//设置可见性</span></span><br><span class="line">            setVisibility(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//开始暂停此Activity</span></span><br><span class="line">                stack.startPausingLocked(<span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* resuming */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (endTask) &#123;</span><br><span class="line">                <span class="comment">//屏幕固定功能</span></span><br><span class="line">                mAtmService.getLockTaskController().clearLockedTask(task);</span><br><span class="line">                <span class="comment">// This activity was in the top focused stack and this is the last activity in</span></span><br><span class="line">                <span class="comment">// that task, give this activity a higher layer so it can stay on top before the</span></span><br><span class="line">                <span class="comment">// closing task transition be executed.</span></span><br><span class="line">                <span class="comment">//更新窗口层级</span></span><br><span class="line">                <span class="keyword">if</span> (mayAdjustTop) &#123;</span><br><span class="line">                    mNeedsZBoost = <span class="keyword">true</span>;</span><br><span class="line">                    mDisplayContent.assignWindowLayers(<span class="keyword">false</span> <span class="comment">/* setLayoutNeeded */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isState(PAUSING)) &#123;</span><br><span class="line">            ... <span class="comment">//正常不会进入此case</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FINISH_RESULT_REQUESTED;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mAtmService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，我们需要关注一下对于<code>Result</code>信息的处理，这里调用了<code>finishActivityResults</code>方法，将<code>Result</code>信息写入到对应<code>ActivityRecord</code>中，待后面<code>resume</code>的时候触发<code>onActivityResult</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the result for activity that started this one, clears the references to activities</span></span><br><span class="line"><span class="comment"> * started for result from this one, and clears new intents.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishActivityResults</span><span class="params">(<span class="keyword">int</span> resultCode, Intent resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        NeededUriGrants resultGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Send the result if needed</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultTo.mUserId != mUserId) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resultData.prepareToLeaveUser(mUserId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (info.applicationInfo.uid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAtmService.mUgmInternal.grantUriPermissionUncheckedFromIntent(resultGrants,</span><br><span class="line">                    resultTo.getUriPermissionsLocked());</span><br><span class="line">        &#125;</span><br><span class="line">        resultTo.addResultLocked(<span class="keyword">this</span>, resultWho, requestCode, resultCode, resultData);</span><br><span class="line">        resultTo = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this HistoryRecord is not holding on to other resources,</span></span><br><span class="line">    <span class="comment">// because clients have remote IPC references to this object so we</span></span><br><span class="line">    <span class="comment">// can't assume that will go away and want to avoid circular IPC refs.</span></span><br><span class="line">    results = <span class="keyword">null</span>;</span><br><span class="line">    pendingResults = <span class="keyword">null</span>;</span><br><span class="line">    newIntents = <span class="keyword">null</span>;</span><br><span class="line">    setSavedState(<span class="keyword">null</span> <span class="comment">/* savedState */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Result结果添加到results列表中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResultLocked</span><span class="params">(ActivityRecord from, String resultWho,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent resultData)</span> </span>&#123;</span><br><span class="line">    ActivityResult r = <span class="keyword">new</span> ActivityResult(from, resultWho,</span><br><span class="line">            requestCode, resultCode, resultData);</span><br><span class="line">    <span class="keyword">if</span> (results == <span class="keyword">null</span>) &#123;</span><br><span class="line">        results = <span class="keyword">new</span> ArrayList&lt;ResultInfo&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    results.add(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，就是将<code>Result</code>信息添加到<code>ActivityRecord.results</code>列表中</p>
<p>然后我们继续沿着<code>finish</code>主线链路走，后面有一个<code>isState</code>的判断，正常来说，<code>ActivityRecord</code>的<code>state</code>应该为<code>RESUMED</code>，具体为什么我们可以回顾一下之前分析的<code>Activity</code>启动流程，在<code>ActivityStackSupervisor.realStartActivityLocked</code>方法最后，会调用<code>ActivityStack.minimalResumeActivityLocked</code>，在这个方法中，会将<code>ActivityRecord</code>的<code>state</code>设置为<code>RESUMED</code>，由于<code>ClientTransaction</code>的执行是通过<code>Handler.sendMessage</code>进行的，所以早在<code>Activity</code> <code>onCreate</code>之前，<code>ActivityRecord</code>的状态就已经被设为了<code>RESUMED</code></p>
<p>根据以上分析，我们会走进<code>isState(RESUMED)</code>这个case中，接着调用<code>ActivityStack.startPausingLocked</code>方法暂停<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Start pausing the currently resumed activity.  It is an error to call this if there</span></span><br><span class="line"><span class="comment"> * is already an activity being paused or there is no resumed activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userLeaving True if this should result in an onUserLeaving to the current activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uiSleeping True if this is happening with the user interface going to sleep (the</span></span><br><span class="line"><span class="comment"> * screen turning off).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resuming The activity we are currently trying to resume or null if this is not being</span></span><br><span class="line"><span class="comment"> *                 called as part of resuming the top activity, so we shouldn't try to instigate</span></span><br><span class="line"><span class="comment"> *                 a resume here if not null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if an activity now is in the PAUSING state, and we are waiting for</span></span><br><span class="line"><span class="comment"> * it to tell us when it is done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已有Activity正在暂停中</span></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">            <span class="comment">// Avoid recursion among check for sleep and complete pause during sleeping.</span></span><br><span class="line">            <span class="comment">// Because activity will be paused immediately after resume, just let pause</span></span><br><span class="line">            <span class="comment">// be completed by the order of activity paused from clients.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上一个已resume的Activity</span></span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//既没有已resume的Activity，也没有正在resume的Activity</span></span><br><span class="line">    <span class="comment">//从栈顶找一个Activity恢复</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能暂停一个正在resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (prev == resuming) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置各种状态</span></span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = prev.isNoHistory() ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">"startPausingLocked"</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新统计信息</span></span><br><span class="line">    mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pauseImmediately = <span class="keyword">false</span>;</span><br><span class="line">    ... <span class="comment">//当前流程下pauseImmediately始终为false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev.attachedToProcess()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度Pause生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(),</span><br><span class="line">                    prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are not going to sleep, we want to ensure the device is</span></span><br><span class="line">    <span class="comment">// awake until the next activity is started.</span></span><br><span class="line">    <span class="comment">//获取Wakelock，确保设备awake状态直到下一个Activity启动</span></span><br><span class="line">    <span class="keyword">if</span> (!uiSleeping &amp;&amp; !mAtmService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">        mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Have the window manager pause its key dispatching until the new</span></span><br><span class="line">        <span class="comment">// activity has started.  If we're pausing the activity just because</span></span><br><span class="line">        <span class="comment">// the screen is being turned off and the UI is sleeping, don't interrupt</span></span><br><span class="line">        <span class="comment">// key dispatch; the same activity will pick it up again on wakeup.</span></span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            <span class="comment">//暂停输入事件分发</span></span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123; <span class="comment">//不会进入此case</span></span><br><span class="line">            <span class="comment">// If the caller said they don't want to wait for the pause, then complete</span></span><br><span class="line">            <span class="comment">// the pause now.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置超时监听（500ms内没有完成便视为超时）</span></span><br><span class="line">            prev.schedulePauseTimeout();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity failed to schedule the</span></span><br><span class="line">        <span class="comment">// pause, so just treat it as being paused now.</span></span><br><span class="line">        <span class="comment">//未能成功暂停此Activity，从栈顶找一个Activity恢复</span></span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，和<code>Activity</code>启动流程类似，该方法里面调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法来调度<code>Activity</code>暂停的生命周期，具体是怎样调度的可以看我之前的文章 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a>，里面分析了<code>ClientTransaction</code>事务是怎么被调度执行的</p>
<p>了解完后我们就可以知道，生命周期事务的执行也就相当于分别调用<code>ActivityLifecycleItem</code>的<code>preExecute</code>、<code>execute</code>、<code>postExecute</code>方法，而<code>PauseActivityItem</code>没有重写<code>preExecute</code>方法，所以我们就依次分析其<code>execute</code>、<code>postExecute</code>方法就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClientTransactionHandler</code>这个我们之前说过，这是一个抽象类，被<code>ActivityThread</code>继承实现，所以这里实际上就是调用<code>ActivityThread.handlePauseActivity</code>方法</p>
<h1 id="handlePauseActivity"><a href="#handlePauseActivity" class="headerlink" title="handlePauseActivity"></a>handlePauseActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新标记</span></span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pause the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Saved instance state for pre-Honeycomb apps if it was saved, &#123;<span class="doctag">@code</span> null&#125; otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//异常状态检查</span></span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-Honeycomb apps always save their state before pausing</span></span><br><span class="line">    <span class="comment">//是否需要保存状态信息（Android 3.0前无论是否finish都会触发保存）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState) &#123;</span><br><span class="line">        <span class="comment">//回调Activity的onSaveInstanceState方法</span></span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//回调OnActivityPausedListener，目前看来只有NFC部分有注册这个回调</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Android 3.0之前的特殊处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回保存状态的Bundle</span></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已暂停，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always reporting top resumed position loss when pausing an activity. If necessary, it</span></span><br><span class="line">    <span class="comment">// will be restored in performResumeActivity().</span></span><br><span class="line">    <span class="comment">//报告resume状态变更</span></span><br><span class="line">    reportTopResumedActivityChanged(r, <span class="keyword">false</span> <span class="comment">/* onTop */</span>, <span class="string">"pausing"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//回调Activity的onPause方法</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onPause方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ...</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一条调用链路看下来还是很简单的，和之前我们分析过的其他生命周期调用是一个套路，这里显示调用了<code>callActivityOnSaveInstanceState</code>方法保存状态信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnSaveInstanceState</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line">    r.state = <span class="keyword">new</span> Bundle();</span><br><span class="line">    r.state.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">        r.persistentState = <span class="keyword">new</span> PersistableBundle();</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state,</span><br><span class="line">                r.persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPreSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//回调onSaveInstanceState</span></span><br><span class="line">    onSaveInstanceState(outState);</span><br><span class="line">    <span class="comment">//保存受管理的Dialog的状态</span></span><br><span class="line">    saveManagedDialogs(outState);</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.saveState(outState);</span><br><span class="line">    <span class="comment">//保存权限请求状态</span></span><br><span class="line">    storeHasCurrentPermissionRequest(outState);</span><br><span class="line">    <span class="comment">//分发PostSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostSaveInstanceState回调</span></span><br><span class="line">    dispatchActivityPostSaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终回调<code>Activity.onSaveInstanceState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(@NonNull Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存窗口信息</span></span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    <span class="comment">//保存Fragment状态</span></span><br><span class="line">    Parcelable p = mFragments.saveAllState();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发SaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivitySaveInstanceState回调</span></span><br><span class="line">    dispatchActivitySaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存状态的流程就基本完成了，我们再回过头来看<code>onPause</code>的触发</p>
<p>在上面<code>performPauseActivityIfNeeded</code>方法中有一行代码调用了<code>Instrumentation.callActivityOnPause</code>方法，<br>通过<code>Instrumentation</code>调用了<code>Activity.performPause</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PrePaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPrePaused回调</span></span><br><span class="line">    dispatchActivityPrePaused();</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//FragmentManager分发pause状态</span></span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//回调onPause</span></span><br><span class="line">    onPause();</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Target Sdk 9以上（Android 2.3）需要保证在onPause中调用super.onPause方法</span></span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostPaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostPaused回调</span></span><br><span class="line">    dispatchActivityPostPaused();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>onPause</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发Paused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPaused回调</span></span><br><span class="line">    dispatchActivityPaused();</span><br><span class="line">    <span class="comment">//自动填充相关</span></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAutoFillIgnoreFirstResumePause) &#123;</span><br><span class="line">            View focus = getCurrentFocus();</span><br><span class="line">            <span class="keyword">if</span> (focus != <span class="keyword">null</span> &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123;</span><br><span class="line">                getAutofillManager().notifyViewExited(focus);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// reset after first pause()</span></span><br><span class="line">            mAutoFillIgnoreFirstResumePause = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE);</span><br><span class="line">    <span class="comment">//super.onPause标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，<code>Activity</code>的<code>onPause</code>生命周期已经基本走完了，此时我们再回到<code>PauseActivityItem.postExecute</code>方法中做一些善后处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mDontReport为我们之前obtain方法中传入的pauseImmediately参数，始终为false</span></span><br><span class="line">    <span class="keyword">if</span> (mDontReport) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        <span class="comment">//调用ATMS.activityPaused方法</span></span><br><span class="line">        ActivityTaskManager.getService().activityPaused(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用<code>ATMS.activityPaused</code>方法回到<code>system_server</code>进程处理<code>Activity</code>暂停后的事项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">//通过ActivityRecord.Token获取ActivityRecord</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.activityPaused(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>ActivityRecord.activityPaused</code>方法继续处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(<span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//移除超时监听</span></span><br><span class="line">        removePauseTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.mPausingActivity == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//暂停布局工作</span></span><br><span class="line">            mAtmService.deferWindowLayout();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stack.completePauseLocked(<span class="keyword">true</span> <span class="comment">/* resumeNext */</span>, <span class="keyword">null</span> <span class="comment">/* resumingActivity */</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//恢复布局工作</span></span><br><span class="line">                mAtmService.continueWindowLayout();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//暂停Activity失败</span></span><br><span class="line">            <span class="keyword">if</span> (isState(PAUSING)) &#123;</span><br><span class="line">                setState(PAUSED, <span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    completeFinishing(<span class="string">"activityPausedLocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下会进入到<code>ActivityStack.completePauseLocked</code>方法中，但在暂停<code>Activity</code>失败的情况下，如果当前状态为<code>PAUSING</code>，则直接将其状态置为<code>PAUSED</code>已暂停，如果被标记为<code>finishing</code>，则会调用<code>ActivityRecord.completeFinishing</code>继续<code>finish</code>流程，这其实和正常情况下的调用链路差不多，具体我们往下就能看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">completePauseLocked</span><span class="params">(<span class="keyword">boolean</span> resumeNext, ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    ActivityRecord prev = mPausingActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.setWillCloseOrEnterPip(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//之前的状态是否为正在停止</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasStopping = prev.isState(STOPPING);</span><br><span class="line">        <span class="comment">//设置状态为已暂停</span></span><br><span class="line">        prev.setState(PAUSED, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            <span class="comment">//继续finish流程</span></span><br><span class="line">            prev = prev.completeFinishing(<span class="string">"completePausedLocked"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev.hasProcess()) &#123;</span><br><span class="line">            <span class="comment">//Configuration发生变化时可能会设置这个flag</span></span><br><span class="line">            <span class="keyword">if</span> (prev.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                <span class="comment">// Complete the deferred relaunch that was waiting for pause to complete.</span></span><br><span class="line">                <span class="comment">//等待暂停完成后relaunch Activity</span></span><br><span class="line">                prev.relaunchActivityLocked(prev.preserveWindowOnDeferredRelaunch);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wasStopping) &#123;</span><br><span class="line">                <span class="comment">// We are also stopping, the stop request must have gone soon after the pause.</span></span><br><span class="line">                <span class="comment">// We can't clobber it, because the stop confirmation will not be handled.</span></span><br><span class="line">                <span class="comment">// We don't need to schedule another stop, we only need to let it happen.</span></span><br><span class="line">                <span class="comment">//之前的状态为正在停止，将状态置回即可</span></span><br><span class="line">                prev.setState(STOPPING, <span class="string">"completePausedLocked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!prev.mVisibleRequested || shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                <span class="comment">// Clear out any deferred client hide we might currently have.</span></span><br><span class="line">                prev.setDeferHidingClient(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// If we were visible then resumeTopActivities will release resources before</span></span><br><span class="line">                <span class="comment">// stopping.</span></span><br><span class="line">                <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">                prev.addToStopping(<span class="keyword">true</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                        <span class="string">"completePauseLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//App在pause过程中死亡</span></span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// It is possible the activity was freezing the screen before it was paused.</span></span><br><span class="line">        <span class="comment">// In that case go ahead and remove the freeze this activity has on the screen</span></span><br><span class="line">        <span class="comment">// since it is no longer visible.</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//停止屏幕冻结</span></span><br><span class="line">            prev.stopFreezingScreenLocked(<span class="keyword">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Activity暂停完毕</span></span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复前一个顶层Activity</span></span><br><span class="line">    <span class="keyword">if</span> (resumeNext) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (topStack != <span class="keyword">null</span> &amp;&amp; !topStack.shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(topStack, prev, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = topStack != <span class="keyword">null</span> ? topStack.topRunningActivity() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="keyword">null</span> || (prev != <span class="keyword">null</span> &amp;&amp; top != prev)) &#123;</span><br><span class="line">                <span class="comment">// If there are no more activities available to run, do resume anyway to start</span></span><br><span class="line">                <span class="comment">// something. Also if the top activity on the stack is not the just paused</span></span><br><span class="line">                <span class="comment">// activity, we need to go ahead and resume it to ensure we complete an</span></span><br><span class="line">                <span class="comment">// in-flight app switch.</span></span><br><span class="line">                mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//恢复按键分发</span></span><br><span class="line">        prev.resumeKeyDispatchingLocked();</span><br><span class="line">        ... <span class="comment">//更新统计信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Activity可见性</span></span><br><span class="line">    mRootWindowContainer.ensureActivitiesVisible(resuming, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify when the task stack has changed, but only if visibilities changed (not just</span></span><br><span class="line">    <span class="comment">// focus). Also if there is an active pinned stack - we always want to notify it about</span></span><br><span class="line">    <span class="comment">// task stack changes, because its positioning may depend on it.</span></span><br><span class="line">    <span class="comment">//通知Task状态发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause</span><br><span class="line">            || (getDisplayArea() != <span class="keyword">null</span> &amp;&amp; getDisplayArea().hasPinnedTask())) &#123;</span><br><span class="line">        mAtmService.getTaskChangeNotificationController().notifyTaskStackChanged();</span><br><span class="line">        mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，无论暂停成功与否，最后都会走到<code>ActivityRecord.completeFinishing</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete activity finish request that was initiated earlier. If the activity is still</span></span><br><span class="line"><span class="comment"> * pausing we will wait for it to complete its transition. If the activity that should appear in</span></span><br><span class="line"><span class="comment"> * place of this one is not visible yet - we'll wait for it first. Otherwise - activity can be</span></span><br><span class="line"><span class="comment"> * destroyed right away.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for finishing the activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Flag indicating whether the activity was removed from history.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ActivityRecord <span class="title">completeFinishing</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//状态检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCurrentVisible = mVisibleRequested || isState(PAUSED);</span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible) &#123;</span><br><span class="line">        ... <span class="comment">//更新Activity可见性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this activity is currently visible, and the resumed activity is not yet visible, then</span></span><br><span class="line">    <span class="comment">// hold off on finishing until the resumed one becomes visible.</span></span><br><span class="line">    <span class="comment">// The activity that we are finishing may be over the lock screen. In this case, we do not</span></span><br><span class="line">    <span class="comment">// want to consider activities that cannot be shown on the lock screen as running and should</span></span><br><span class="line">    <span class="comment">// proceed with finishing the activity if there is no valid next top running activity.</span></span><br><span class="line">    <span class="comment">// Note that if this finishing activity is floating task, we don't need to wait the</span></span><br><span class="line">    <span class="comment">// next activity resume and can destroy it directly.</span></span><br><span class="line">    <span class="comment">// TODO(b/137329632): find the next activity directly underneath this one, not just anywhere</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = getDisplayArea().topRunningActivity(</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* considerKeyguardState */</span>);</span><br><span class="line">    <span class="comment">// isNextNotYetVisible is to check if the next activity is invisible, or it has been</span></span><br><span class="line">    <span class="comment">// requested to be invisible but its windows haven't reported as invisible.  If so, it</span></span><br><span class="line">    <span class="comment">// implied that the current finishing activity should be added into stopping list rather</span></span><br><span class="line">    <span class="comment">// than destroy immediately.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isNextNotYetVisible = next != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; (!next.nowVisible || !next.mVisibleRequested);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此Activity当前可见，而要恢复的Activity还不可见，则推迟finish，直到要恢复的Activity可见为止</span></span><br><span class="line">    <span class="keyword">if</span> (isCurrentVisible &amp;&amp; isNextNotYetVisible) &#123;</span><br><span class="line">        <span class="comment">// Add this activity to the list of stopping activities. It will be processed and</span></span><br><span class="line">        <span class="comment">// destroyed when the next activity reports idle.</span></span><br><span class="line">        <span class="comment">//添加到stop列表中等待空闲时执行stop</span></span><br><span class="line">        addToStopping(<span class="keyword">false</span> <span class="comment">/* scheduleIdle */</span>, <span class="keyword">false</span> <span class="comment">/* idleDelayed */</span>,</span><br><span class="line">                <span class="string">"completeFinishing"</span>);</span><br><span class="line">        <span class="comment">//设置状态为stop中</span></span><br><span class="line">        setState(STOPPING, <span class="string">"completeFinishing"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addToFinishingAndWaitForIdle()) &#123;</span><br><span class="line">        <span class="comment">// We added this activity to the finishing list and something else is becoming resumed.</span></span><br><span class="line">        <span class="comment">// The activity will complete finishing when the next activity reports idle. No need to</span></span><br><span class="line">        <span class="comment">// do anything else here.</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not waiting for the next one to become visible, and nothing else will be resumed in</span></span><br><span class="line">        <span class="comment">// place of this activity - requesting destruction right away.</span></span><br><span class="line">        <span class="comment">//立刻销毁此Activity</span></span><br><span class="line">        activityRemoved = destroyIfPossible(reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved ? <span class="keyword">null</span> : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于非锁屏状态且当前要销毁的<code>Activity</code>在前台的情况下，该<code>Activity</code>可见而待恢复的<code>Activity</code>尚不可见，此时优先完成待恢复<code>Activity</code>的<code>resume</code>生命周期，等到之后空闲再去处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>所以在面试中常问的<code>Activity</code>从<code>B</code>返回到<code>A</code>的生命周期顺序我们从这里就可以看出来，理解后我们就不用去死记硬背了：</p>
<p><code>B.onPause</code> -&gt; <code>A.onRestart</code> -&gt; <code>A.onResume</code> -&gt; <code>B.onStop</code> -&gt; <code>B.onDestory</code></p>
<p>对于锁屏状态或者要销毁的<code>Activity</code>不在前台的情况下，由于不需要立刻恢复<code>Activity</code>，所以可能会直接处理待销毁<code>Activity</code>的<code>destroy</code>生命周期</p>
<p>我们以第一种当前要销毁的<code>Activity</code>在前台的情况分析，此时会将这个<code>Activity</code>添加到<code>stop</code>列表中，并将状态设置为<code>STOPPING</code>，之后返回到<code>ActivityStack.completePauseLocked</code>方法中，继续执行<code>resumeNext</code>工作</p>
<p>在<code>resumeNext</code>中会调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复栈顶<code>Activity</code>，由于这个方法之前已经在<br><a href="https://juejin.cn/post/7130182223231188999#heading-6" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中分析过了，这里就不再赘述了，我们还是将目光放在销毁流程上</p>
<p>通过之前的文章，我们知道恢复<code>Activity</code>会调用到<code>ActivityThread.handleResumeActivity</code>方法，而当<code>Activity</code>恢复完毕后，此方法最后一行会向<code>MessageQueue</code>添加一个<code>IdleHandler</code>，关于<code>IdleHandler</code>这里就不再介绍了，这是每位<code>Android</code>开发都应该了解的东西</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Idler</code>是<code>ActivityThread</code>的一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityTaskManager am = ActivityTaskManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="comment">//遍历整条ActivityClientRecord.nextIdle链，依次调用ATMS.activityIdle</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会遍历整个进程内所有的<code>ActivityClientRecord</code>，并依次调用<code>ATMS.activityIdle</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStackSupervisor.activityIdleInternal(r, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>ActivityRecord.Token</code>获取到<code>ActivityRecord</code>，接着调用<code>ActivityStackSupervisor.activityIdleInternal</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activityIdleInternal</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    processStoppingAndFinishingActivities(r, processPausingActivities, <span class="string">"idle"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只需要重点关注<code>processStoppingAndFinishingActivities</code>这一个方法，从方法名我们也能看出来，它是用来处理<code>Activity</code> <code>stop</code>或<code>destroy</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Processes the activities to be stopped or destroyed. This should be called when the resumed</span></span><br><span class="line"><span class="comment"> * activities are idle or drawn.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStoppingAndFinishingActivities</span><span class="params">(ActivityRecord launchedActivity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> processPausingActivities, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been waiting for the transition</span></span><br><span class="line">    <span class="comment">// animation to finish.</span></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; readyToStopActivities = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mStoppingActivities.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord s = mStoppingActivities.get(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> animating = s.isAnimating(TRANSITION | PARENTS,</span><br><span class="line">                ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS);</span><br><span class="line">        <span class="comment">//不在动画中或者ATMS服务正在关闭</span></span><br><span class="line">        <span class="keyword">if</span> (!animating || mService.mShuttingDown) &#123;</span><br><span class="line">            <span class="comment">//跳过正在pause的Activitiy</span></span><br><span class="line">            <span class="keyword">if</span> (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123;</span><br><span class="line">                <span class="comment">// Defer processing pausing activities in this iteration and reschedule</span></span><br><span class="line">                <span class="comment">// a delayed idle to reprocess it again</span></span><br><span class="line">                removeIdleTimeoutForActivity(launchedActivity);</span><br><span class="line">                scheduleIdleTimeout(launchedActivity);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (readyToStopActivities == <span class="keyword">null</span>) &#123;</span><br><span class="line">                readyToStopActivities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将准备好stop的Activitiy加入列表中</span></span><br><span class="line">            readyToStopActivities.add(s);</span><br><span class="line"></span><br><span class="line">            mStoppingActivities.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numReadyStops = readyToStopActivities == <span class="keyword">null</span> ? <span class="number">0</span> : readyToStopActivities.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numReadyStops; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = readyToStopActivities.get(i);</span><br><span class="line">        <span class="comment">//Activity是否在任务栈中</span></span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                <span class="comment">// TODO(b/137329632): Wait for idle of the right activity, not just any.</span></span><br><span class="line">                <span class="comment">//被标记为finishing，尝试销毁Activity</span></span><br><span class="line">                r.destroyIfPossible(reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则仅仅只是stop Activity</span></span><br><span class="line">                r.stopIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numFinishingActivities = mFinishingActivities.size();</span><br><span class="line">    <span class="keyword">if</span> (numFinishingActivities == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish any activities that are scheduled to do so but have been waiting for the next one</span></span><br><span class="line">    <span class="comment">// to start.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; finishingActivities = <span class="keyword">new</span> ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">    mFinishingActivities.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFinishingActivities; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = finishingActivities.get(i);</span><br><span class="line">        <span class="keyword">if</span> (r.isInHistory()) &#123;</span><br><span class="line">            <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">            r.destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>, <span class="string">"finish-"</span> + reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于被标记为<code>finishing</code>的<code>Activity</code>，调用<code>destroyIfPossible</code>方法销毁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy and cleanup the activity both on client and server if possible. If activity is the</span></span><br><span class="line"><span class="comment"> * last one left on display with home stack and there is no other running activity - delay</span></span><br><span class="line"><span class="comment"> * destroying it until the next one starts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyIfPossible</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置状态</span></span><br><span class="line">    setState(FINISHING, <span class="string">"destroyIfPossible"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the record is cleaned out of other places.</span></span><br><span class="line">    <span class="comment">//确保此Activity已从待stop列表中移除</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = getRootTask();</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = taskDisplayArea.topRunningActivity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isLastStackOverEmptyHome =</span><br><span class="line">            next == <span class="keyword">null</span> &amp;&amp; stack.isFocusedStackOnDisplay()</span><br><span class="line">                    &amp;&amp; taskDisplayArea.getOrCreateRootHomeTask() != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLastStackOverEmptyHome) &#123;</span><br><span class="line">        <span class="comment">// Don't destroy activity immediately if this is the last activity on the display and</span></span><br><span class="line">        <span class="comment">// the display contains home stack. Although there is no next activity at the moment,</span></span><br><span class="line">        <span class="comment">// another home activity should be started later. Keep this activity alive until next</span></span><br><span class="line">        <span class="comment">// home activity is resumed. This way the user won't see a temporary black screen.</span></span><br><span class="line">        <span class="comment">//如果Home栈存在且这是当前焦点栈中最后一个Activity，则不要立即销毁它</span></span><br><span class="line">        <span class="comment">//将此Activity添加到待finish列表中，等待空闲时执行finish</span></span><br><span class="line">        addToFinishingAndWaitForIdle();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置finishing标记（之前设过了，这里是重复设置）</span></span><br><span class="line">    makeFinishingLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//立刻执行Activity的销毁流程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> activityRemoved = destroyImmediately(<span class="keyword">true</span> <span class="comment">/* removeFromApp */</span>,</span><br><span class="line">            <span class="string">"finish-imm:"</span> + reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the display does not have running activity, the configuration may need to be</span></span><br><span class="line">    <span class="comment">// updated for restoring original orientation of the display.</span></span><br><span class="line">    <span class="comment">//更新可见性和屏幕显示方向</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(),</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新恢复栈顶Activity</span></span><br><span class="line">    <span class="keyword">if</span> (activityRemoved) &#123;</span><br><span class="line">        mRootWindowContainer.resumeFocusedStacksTopActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activityRemoved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了最后的一些判断，然后调用<code>destroyImmediately</code>方法，立刻执行Activity的销毁流程（这里和上一个方法<code>processStoppingAndFinishingActivities</code>中，待<code>finish</code>列表的处理是一样的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Destroy the current CLIENT SIDE instance of an activity. This may be called both when</span></span><br><span class="line"><span class="comment"> * actually finishing an activity, or when performing a configuration switch where we destroy</span></span><br><span class="line"><span class="comment"> * the current client-side object but then create a new client-side object for this same</span></span><br><span class="line"><span class="comment"> * HistoryRecord.</span></span><br><span class="line"><span class="comment"> * Normally the server-side record will be removed when the client reports back after</span></span><br><span class="line"><span class="comment"> * destruction. If, however, at this point there is no client process attached, the record will</span></span><br><span class="line"><span class="comment"> * be removed immediately.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if activity was immediately removed from history, &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">destroyImmediately</span><span class="params">(<span class="keyword">boolean</span> removeFromApp, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//已经被销毁或正在被销毁，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isState(DESTROYING, DESTROYED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> removedFromHistory = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理工作</span></span><br><span class="line">    cleanUp(<span class="keyword">false</span> <span class="comment">/* cleanServices */</span>, <span class="keyword">false</span> <span class="comment">/* setState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasProcess()) &#123;</span><br><span class="line">        <span class="comment">//清理更新工作</span></span><br><span class="line">        <span class="keyword">if</span> (removeFromApp) &#123;</span><br><span class="line">            app.removeActivity(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!app.hasActivities()) &#123;</span><br><span class="line">                mAtmService.clearHeavyWeightProcessIfEquals(app);</span><br><span class="line">                <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">                <span class="comment">// their client may have activities.</span></span><br><span class="line">                <span class="comment">// No longer have activities, so update LRU list and oom adj.</span></span><br><span class="line">                <span class="comment">//更新进程信息</span></span><br><span class="line">                app.updateProcessInfo(<span class="keyword">true</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> skipDestroy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调度销毁生命周期事务</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken,</span><br><span class="line">                    DestroyActivityItem.obtain(finishing, configChangeFlags));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// We can just ignore exceptions here...  if the process has crashed, our death</span></span><br><span class="line">            <span class="comment">// notification will clean things up.</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//从历史任务中移除</span></span><br><span class="line">                removeFromHistory(reason + <span class="string">" exceptionInScheduleDestroy"</span>);</span><br><span class="line">                removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">                skipDestroy = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nowVisible = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the activity is finishing, we need to wait on removing it from the list to give it</span></span><br><span class="line">        <span class="comment">// a chance to do its cleanup.  During that time it may make calls back with its token</span></span><br><span class="line">        <span class="comment">// so we need to be able to find it on the list and so we don't want to remove it from</span></span><br><span class="line">        <span class="comment">// the list yet.  Otherwise, we can just immediately put it in the destroyed state since</span></span><br><span class="line">        <span class="comment">// we are not removing it from the list.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing &amp;&amp; !skipDestroy) &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYING,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. finishing and not skipping destroy"</span>);</span><br><span class="line">            <span class="comment">//设置销毁超时回调</span></span><br><span class="line">            mAtmService.mH.postDelayed(mDestroyTimeoutRunnable, DESTROY_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置状态</span></span><br><span class="line">            setState(DESTROYED,</span><br><span class="line">                    <span class="string">"destroyActivityLocked. not finishing or skipping destroy"</span>);</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove this record from the history.</span></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程，从历史任务中移除</span></span><br><span class="line">            removeFromHistory(reason + <span class="string">" hadNoApp"</span>);</span><br><span class="line">            removedFromHistory = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有绑定进程且不在finishing中，直接设置状态为已被销毁</span></span><br><span class="line">            setState(DESTROYED, <span class="string">"destroyActivityLocked. not finishing and had no app"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    configChangeFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removedFromHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="scheduleTransaction"><a href="#scheduleTransaction" class="headerlink" title="scheduleTransaction"></a>scheduleTransaction</h1><p>这个方法做了一些清理工作，重头戏在于调用了<code>ClientLifecycleManager.scheduleTransaction</code>方法调度销毁生命周期事务，接下来我们就重点分析这个事务的执行路径</p>
<p><code>scheduleTransaction</code>的调用链路我们在 <a href="https://juejin.cn/post/7195458962328649788#heading-5" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（下）</a> 中已经分析过了，这里我就简单的标注一下流程：</p>
<p><code>ClientLifecycleManager.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.schedule</code> -&gt;<br><code>ActivityThread.scheduleTransaction</code> -&gt;<br><code>ClientTransaction.preExecute</code> -&gt;<br><code>ActivityLifecycleItem.preExecute</code>-&gt;<br><code>ActivityThread.sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction)</code> -&gt;<br><code>TransactionExecutor.execute</code> -&gt;<br><code>TransactionExecutor.executeCallbacks</code> -&gt;<br><code>TransactionExecutor.executeLifecycleState</code> -&gt;<br><code>TransactionExecutor.cycleToPath</code> -&gt;<br><code>ActivityLifecycleItem.execute</code> -&gt;<br><code>ActivityLifecycleItem.postExecute</code></p>
<p>这里的链路基本上和<code>Activity</code>启动事务链路相差无几，甚至更短了（<code>Activity</code>销毁事务没有添加<code>callback</code>），所以没看过我上篇文章的强烈推荐去看一下，这里我就不再做分析了</p>
<p>我们从<code>TransactionExecutor.cycleToPath</code>开始，之前我们分析过，我们在事务中设置的<code>ActivityLifecycleItem</code>代表了<code>Activity</code>最终需要到达执行的生命周期，而中间的那些过渡生命周期就由<code>cycleToPath</code>方法推进执行，我们目前的生命周期状态为<code>ON_PAUSE</code>，而我们的目标生命周期为<code>ON_DESTROY</code>，中间还夹着一个<code>ON_STOP</code>，所以这个方法会帮我们执行<code>ClientTransactionHandler.handleStopActivity</code>方法，也就是<code>ActivityThread.handleStopActivity</code>方法</p>
<h1 id="handleStopActivity"><a href="#handleStopActivity" class="headerlink" title="handleStopActivity"></a>handleStopActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">    <span class="comment">//执行onStop生命周期</span></span><br><span class="line">    performStopActivityInner(r, stopInfo, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">            reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新可见性</span></span><br><span class="line">    updateVisibility(r, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="comment">//确保所有全局任务都被处理完成</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录Stop信息（不过在后续销毁链路中似乎并没有被用到）</span></span><br><span class="line">    stopInfo.setActivity(r);</span><br><span class="line">    stopInfo.setState(r.state);</span><br><span class="line">    stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">    pendingActions.setStopInfo(stopInfo);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的路径就和其他生命周期差不多了，大部分内容我都用注释标注了，大家顺着往下看就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Core implementation of stopping an activity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r Target activity client record.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info Action that will report activity stop to server.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> saveState Flag indicating whether the activity state should be saved.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> finalStateRequest Flag indicating if this call is handling final lifecycle state</span></span><br><span class="line"><span class="comment"> *                          request for a transaction.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> reason Reason for performing this operation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r, StopInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> saveState, <span class="keyword">boolean</span> finalStateRequest <span class="comment">/* false */</span>, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//异常状态处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//设置描述（Activity.onCreateDescription）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调Activity的onStop方法</span></span><br><span class="line">        callActivityOnStop(r, saveState, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls &#123;<span class="doctag">@link</span> Activity#onStop()&#125; and &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125;, and updates</span></span><br><span class="line"><span class="comment"> * the client record's state.</span></span><br><span class="line"><span class="comment"> * All calls to stop an activity must be done through this method to make sure that</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Activity#onSaveInstanceState(Bundle)&#125; is also executed in the same call.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callActivityOnStop</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Before P onSaveInstanceState was called before onStop, starting with P it's</span></span><br><span class="line">    <span class="comment">// called after. Before Honeycomb state was always saved before onPause.</span></span><br><span class="line">    <span class="comment">//这里shouldSaveState为true，因为activity.mFinished早在performPauseActivity的时候就被设为了true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; !r.isPreHoneycomb();</span><br><span class="line">    <span class="comment">//targetSdkVersion为Android P (Android 9)之前</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isPreP = r.isPreP();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行stop生命周期</span></span><br><span class="line">        r.activity.performStop(r.mPreserveWindow, reason);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置生命周期状态</span></span><br><span class="line">    r.setState(ON_STOP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState &amp;&amp; !isPreP) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStop</span><span class="params">(<span class="keyword">boolean</span> preserveWindow, String reason)</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//Loader相关，详见https://developer.android.com/guide/components/loaders</span></span><br><span class="line">    mFragments.doLoaderStop(mChangingConfigurations <span class="comment">/*retain*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disallow entering picture-in-picture after the activity has been stopped</span></span><br><span class="line">    <span class="comment">//stop后禁用画中画</span></span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">        <span class="comment">//分发PreStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreStopped回调</span></span><br><span class="line">        dispatchActivityPreStopped();</span><br><span class="line">        <span class="comment">//关闭所有子窗口</span></span><br><span class="line">        <span class="keyword">if</span> (mWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mWindow.closeAllPanels();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we're preserving the window, don't setStoppedState to true, since we</span></span><br><span class="line">        <span class="comment">// need the window started immediately again. Stopping the window will</span></span><br><span class="line">        <span class="comment">// destroys hardware resources and causes flicker.</span></span><br><span class="line">        <span class="keyword">if</span> (!preserveWindow &amp;&amp; mToken != <span class="keyword">null</span> &amp;&amp; mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置停止状态，释放硬件资源，销毁Surface</span></span><br><span class="line">            WindowManagerGlobal.getInstance().setStoppedState(mToken, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//FragmentManager分发stop状态</span></span><br><span class="line">        mFragments.dispatchStop();</span><br><span class="line"></span><br><span class="line">        mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//执行onStop回调</span></span><br><span class="line">        mInstrumentation.callActivityOnStop(<span class="keyword">this</span>);</span><br><span class="line">        EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason);</span><br><span class="line">        <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">            <span class="comment">//必须要调用super.onStop方法</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onStop()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放Cursors</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mManagedCursors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                ManagedCursor mc = mManagedCursors.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!mc.mReleased) &#123;</span><br><span class="line">                    mc.mCursor.deactivate();</span><br><span class="line">                    mc.mReleased = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStopped = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">        dispatchActivityPostStopped();</span><br><span class="line">    &#125;</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>执行<code>onStop</code>回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ActionBar动画</span></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) mActionBar.setShowHideAnimationEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//共享元素动画</span></span><br><span class="line">    mActivityTransitionState.onStop();</span><br><span class="line">    <span class="comment">//分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调</span></span><br><span class="line">    dispatchActivityStopped();</span><br><span class="line">    mTranslucentCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//super.onStop标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    mEnterAnimationComplete = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一整个<code>onStop</code>生命周期就执行完成了，最后还剩下个<code>onDestroy</code>，根据之前写的事务调度链路，现在应该走到了<code>DestroyActivityItem.execute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleDestroyActivity(token, mFinished, mConfigChanges,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>, <span class="string">"DestroyActivityItem"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上就直接调用了<code>ActivityThread.handleDestroyActivity</code>方法</p>
<h1 id="handleDestroyActivity"><a href="#handleDestroyActivity" class="headerlink" title="handleDestroyActivity"></a>handleDestroyActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing, <span class="keyword">int</span> configChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行onDestroy生命周期</span></span><br><span class="line">    ActivityClientRecord r = performDestroyActivity(token, finishing,</span><br><span class="line">            configChanges, getNonConfigInstance, reason);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//清理之前设置的延时移除的window</span></span><br><span class="line">        cleanUpPendingRemoveWindows(r, finishing);</span><br><span class="line">        WindowManager wm = r.activity.getWindowManager();</span><br><span class="line">        View v = r.activity.mDecor;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromServer) &#123;</span><br><span class="line">                mNumVisibleActivities--;</span><br><span class="line">            &#125;</span><br><span class="line">            IBinder wtoken = v.getWindowToken();</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mWindowAdded) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    <span class="comment">// Hold off on removing this until the new activity's</span></span><br><span class="line">                    <span class="comment">// window is being added.</span></span><br><span class="line">                    r.mPendingRemoveWindow = r.window;</span><br><span class="line">                    r.mPendingRemoveWindowManager = wm;</span><br><span class="line">                    <span class="comment">// We can only keep the part of the view hierarchy that we control,</span></span><br><span class="line">                    <span class="comment">// everything else must be removed, because it might not be able to</span></span><br><span class="line">                    <span class="comment">// behave properly when activity is relaunching.</span></span><br><span class="line">                    <span class="comment">//从DecorView中移除ContentView</span></span><br><span class="line">                    r.window.clearContentView();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//立刻执行View的移除操作，释放硬件资源，销毁Surface，回调View.onDetachedFromWindow</span></span><br><span class="line">                    wm.removeViewImmediate(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (wtoken != <span class="keyword">null</span> &amp;&amp; r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//移除指定Window下的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAll(wtoken,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We're preserving only one window, others should be closed so app views</span></span><br><span class="line">                <span class="comment">// will be detached before the final tear down. It should be done now because</span></span><br><span class="line">                <span class="comment">// some components (e.g. WebView) rely on detach callbacks to perform receiver</span></span><br><span class="line">                <span class="comment">// unregister and other cleanup.</span></span><br><span class="line">                <span class="comment">//移除指定Window下除了当前DecorView以外的所有rootView</span></span><br><span class="line">                WindowManagerGlobal.getInstance().closeAllExceptView(token, v,</span><br><span class="line">                        r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity.mDecor = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.mPendingRemoveWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are delaying the removal of the activity window, then</span></span><br><span class="line">            <span class="comment">// we can't clean up all windows here.  Note that we can't do</span></span><br><span class="line">            <span class="comment">// so later either, which means any windows that aren't closed</span></span><br><span class="line">            <span class="comment">// by the app will leak.  Well we try to warning them a lot</span></span><br><span class="line">            <span class="comment">// about leaking windows, because that is a bug, so if they are</span></span><br><span class="line">            <span class="comment">// using this recreate facility then they get to live with leaks.</span></span><br><span class="line">            WindowManagerGlobal.getInstance().closeAll(token,</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mocked out contexts won't be participating in the normal</span></span><br><span class="line">        <span class="comment">// process lifecycle, but if we're running with a proper</span></span><br><span class="line">        <span class="comment">// ApplicationContext we need to have it tear down things</span></span><br><span class="line">        <span class="comment">// cleanly.</span></span><br><span class="line">        <span class="comment">//清理Context</span></span><br><span class="line">        Context c = r.activity.getBaseContext();</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> ContextImpl) &#123;</span><br><span class="line">            ((ContextImpl) c).scheduleFinalCleanup(</span><br><span class="line">                    r.activity.getClass().getName(), <span class="string">"Activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//处理一些销毁后的事项，移除超时回调等</span></span><br><span class="line">            ActivityTaskManager.getService().activityDestroyed(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Window</code>这块的处理我目前也不太了解，等以后我学习了<code>WMS</code>那块再补吧</p>
<p>其他的和之前的套路一样，调用<code>performDestroyActivity</code>方法执行销毁<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Core implementation of activity destroy call. */</span></span><br><span class="line"><span class="function">ActivityClientRecord <span class="title">performDestroyActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finishing,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> getNonConfigInstance, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activityClass = r.activity.getClass();</span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被暂停则先执行pause生命周期</span></span><br><span class="line">        performPauseActivityIfNeeded(r, <span class="string">"destroy"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有被停职则先执行stop生命周期</span></span><br><span class="line">        <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">            callActivityOnStop(r, <span class="keyword">false</span> <span class="comment">/* saveState */</span>, <span class="string">"destroy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getNonConfigInstance) &#123;</span><br><span class="line">            ... <span class="comment">//getNonConfigInstance为false，这里不执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//执行onDestroy回调</span></span><br><span class="line">            mInstrumentation.callActivityOnDestroy(r.activity);</span><br><span class="line">            <span class="comment">//必须要调用super.onDestroy方法</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + safeToComponentShortString(r.intent) +</span><br><span class="line">                    <span class="string">" did not call through to super.onDestroy()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭所有子窗口</span></span><br><span class="line">            <span class="keyword">if</span> (r.window != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.window.closeAllPanels();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置生命周期状态</span></span><br><span class="line">        r.setState(ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空闲时清理资源</span></span><br><span class="line">    schedulePurgeIdler();</span><br><span class="line">    <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">    <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">    <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        mActivities.remove(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格模式更新Activity计数器，与实际Activity数量对比，判断是否产生内存泄漏</span></span><br><span class="line">    StrictMode.decrementExpectedActivityCount(activityClass);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>Instrumentation</code>调用<code>Activity.performDestroy</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreDestroyed回调</span></span><br><span class="line">    dispatchActivityPreDestroyed();</span><br><span class="line">    mDestroyed = <span class="keyword">true</span>;</span><br><span class="line">    mWindow.destroy();</span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">    onDestroy();</span><br><span class="line">    EventLogTags.writeWmOnDestroyCalled(mIdent, getComponentName().getClassName(),</span><br><span class="line">            <span class="string">"performDestroy"</span>);</span><br><span class="line">    mFragments.doLoaderDestroy();</span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.detachActivity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分发PostDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostDestroyed回调</span></span><br><span class="line">    dispatchActivityPostDestroyed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//super.onDestroy标注为已被执行</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dismiss any dialogs we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Dialog</span></span><br><span class="line">    <span class="keyword">if</span> (mManagedDialogs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDialogs = mManagedDialogs.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDialogs; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ManagedDialog md = mManagedDialogs.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (md.mDialog.isShowing()) &#123;</span><br><span class="line">                md.mDialog.dismiss();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedDialogs = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close any cursors we are managing.</span></span><br><span class="line">    <span class="comment">//关闭所有被管理的Cursor</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mManagedCursors) &#123;</span><br><span class="line">        <span class="keyword">int</span> numCursors = mManagedCursors.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCursors; i++) &#123;</span><br><span class="line">            ManagedCursor c = mManagedCursors.get(i);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c.mCursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mManagedCursors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close any open search dialog</span></span><br><span class="line">    <span class="comment">//关闭系统搜索服务的弹窗</span></span><br><span class="line">    <span class="keyword">if</span> (mSearchManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSearchManager.stopSearch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActionBar != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActionBar.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分发Destroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityDestroyed回调</span></span><br><span class="line">    dispatchActivityDestroyed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容捕获服务</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DestroyActivityItem</code>没有重写<code>postExecute</code>方法，所以到此为止，<code>Activity</code>整个销毁流程就结束了</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>我们通过本篇文章的分析，可以发现，触发<code>Activity</code>销毁后，<code>onStop</code>和<code>onDestroy</code>这两个生命周期回调的触发时机是不确定的，如果有需求需要在确定<code>Activity</code>要被销毁后立刻执行，我们可以在<code>onPause</code>回调中调用<code>Activity.isFinishing</code>方法判断<code>mFinished</code>标志是否被置<code>true</code>，如果为<code>true</code>则可以判定这个<code>Activity</code>将被销毁</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，<code>Activity</code>的启动流程和销毁流程我们都分析完了，后面应该暂时不会再写<code>Activity</code>相关的源码分析了</p>
<p>之后的一段时间，我可能会将我的精力投入到<code>AIGC</code>的技术调研中，<code>Android源码分析</code>这一系列的后续更新可能会放慢，希望大家多多谅解</p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>