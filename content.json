{"meta":{"title":"å§‹ç»ˆéƒ½æ˜¯æ¢¦","subtitle":"","description":"","author":"dreamgyf","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","date":"2020-06-26T17:21:13.000Z","updated":"2022-11-13T09:55:54.351Z","comments":true,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"åˆ†ç±»","date":"2020-06-26T17:15:50.000Z","updated":"2022-11-13T09:55:54.362Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"æ ‡ç­¾","date":"2020-06-26T17:15:01.000Z","updated":"2022-11-13T09:55:54.370Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Markdown"}],"posts":[{"title":"ä½ çœŸçš„äº†è§£Emojiå—ï¼ŸEmojiå…¨è²Œå¤§æ­ç§˜","slug":"common/ä½ çœŸçš„äº†è§£Emojiå—ï¼ŸEmojiå…¨è²Œå¤§æ­ç§˜","date":"2024-08-10T07:13:23.000Z","updated":"2025-01-12T06:21:52.841Z","comments":true,"path":"2024/08/10/common/ä½ çœŸçš„äº†è§£Emojiå—ï¼ŸEmojiå…¨è²Œå¤§æ­ç§˜/","link":"","permalink":"http://yoursite.com/2024/08/10/common/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3Emoji%E5%90%97%EF%BC%9FEmoji%E5%85%A8%E8%B2%8C%E5%A4%A7%E6%8F%AD%E7%A7%98/","excerpt":"","text":"å‰è¨€éšç€ç§‘æŠ€å‘å±•ï¼Œæ™ºèƒ½æ‰‹æœºçš„æ™®åŠï¼ŒEmojiå·²ç»èå…¥åˆ°äº†æˆ‘ä»¬çš„ç”Ÿæ´»ä¸­ï¼Œä½†æ¯å¤©ä½¿ç”¨Emojiçš„ä½ çœŸçš„æ¸…æ¥šå®ƒæ˜¯ä»€ä¹ˆï¼Œæ˜¯ç”±ä»€ä¹ˆä¸œè¥¿ç»„æˆçš„ï¼Œå’Œæ™®é€šçš„å­—ç¬¦æœ‰ä»€ä¹ˆåŒºåˆ«å—ï¼Ÿæœ¬æ–‡å°±ä»æŠ€æœ¯çš„è§’åº¦å¸¦ä½ æ­ç§˜Emojiçš„å…¨è²Œã€‚ èµ·å› æœ€è¿‘é¡¹ç›®é‡Œæœ‰ä¸€ä¸ªAIèŠå¤©æœºå™¨äººï¼Œä½ å¯ä»¥å‘ä»–æé—®ï¼Œä»–ä¼šä»¥æµå¼æ‰“å°çš„å½¢å¼ä¸€å­—ä¸€å­—çš„å°†å›ç­”å‘ˆç°ç»™ç”¨æˆ·ã€‚åœ¨è¿™è¿‡ç¨‹ä¸­æˆ‘å°±å‘ç°ï¼Œæ¯å½“æ‰“å°åˆ°Emojiçš„æ—¶å€™ï¼Œæ€»ä¼šå…ˆå‡ºç°ä¸€ä¸ªé—®å·å½¢çŠ¶çš„ä¹±ç ï¼Œç„¶åæ‰èƒ½æ˜¾ç¤ºå‡ºEmojiï¼Œæœ‰çš„Emojiæ›´å¥‡ç‰¹ï¼Œä»¥ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ä¸ºä¾‹ï¼Œåœ¨æ‰“å°è¿‡ç¨‹ä¸­ä¼šä¾æ­¤æ˜¾ç¤ºğŸ‘¨ğŸ‘©ğŸ‘§ğŸ‘¦å››ä¸ªEmojiï¼Œæœ€åçªç„¶å•ªçš„ä¸€ä¸‹ï¼Œåˆæˆä¸€æ•´ä¸ªğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ï¼Œæ˜¯ä¸æ˜¯å¾ˆç¥å¥‡ï¼Ÿè¿™ä¸ªç°è±¡å¼•èµ·äº†æˆ‘çš„å¥½å¥‡ï¼Œäºæ˜¯æˆ‘å¼€å§‹ç¿»é˜…èµ„æ–™ï¼Œæ­å¼€Emojiçš„ç¥ç§˜é¢çº±ã€‚ Emojiçš„èµ·æºåŠå‘å±•Emojiæ¥è‡ªæ—¥è¯­è¯æ±‡â€çµµæ–‡å­—â€ï¼ˆå‡åä¸ºâ€œãˆã‚‚ã˜â€ï¼Œè¯»éŸ³å³ emojiï¼‰ï¼Œç»˜æŒ‡å›¾ç”»ï¼Œæ–‡å­—æŒ‡å­—ç¬¦ï¼Œæœ€æ—©ç”±æ —ç”°ç©°å´‡ï¼ˆShigetaka Kuritaï¼‰åˆ›ä½œï¼Œè®¾è®¡çµæ„Ÿæºäºå¤©æ°”é¢„æŠ¥å›¾æ ‡ã€æ±‰å­—ã€æ¼«ç”»å’Œè·¯æ ‡ç­‰ï¼Œæœ€åˆçš„Emojiæœ‰176ä¸ªï¼Œéƒ½æ˜¯12 x 12åƒç´ çš„å›¾ç‰‡ã€‚ 1999å¹´ï¼Œæ—¥æœ¬é€šè®¯è¿è¥å•†DOCOMOå…¬å¸å‘å¸ƒäº†åœ¨å½“æ—¶å…·æœ‰è·¨æ—¶ä»£æ„ä¹‰çš„iModeæ‰‹æœºï¼Œæœ€æ—©çš„Emojiä¾¿æ­è½½äºå…¶ä¸­ã€‚ Emojiä¸€ç»è¯ç”Ÿï¼Œäººä»¬ä¾¿å‘ç°è¿™äº›å½¢è±¡çš„Emojiå®åœ¨æ˜¯å¤ªå¥½ç”¨äº†ï¼Œä¸ä»…æ–¹ä¾¿ï¼Œè¿˜èƒ½ä½¿èŠå¤©è¿‡ç¨‹æ›´åŠ æœ‰è¶£ï¼Œéšå³ä¾¿ç«‹åˆ»è¢«æ—¥æœ¬å„å¤§ç§‘æŠ€å…¬å¸æ³¨æ„åˆ°ï¼Œæ—¥æœ¬çš„ä¸‰å¤§è¿è¥å•†å¼€å§‹æŠŠEmojiåŠ å…¥åˆ°è‡ªå·±çš„çŸ­ä¿¡ä¸šåŠ¡ä¸­ï¼Œå¾ˆå¿«ä¾¿æ¨ªæ‰«äº†å…¨æ—¥æœ¬ï¼Œä½†ä¸ºäº†æ‰“å‡»ç«äº‰å¯¹æ‰‹ï¼Œå„å¤§è¿è¥å•†éƒ½ä½¿ç”¨è‡ªå·±çš„Emojiæ ‡å‡†ã€‚è¿™å¯¼è‡´äº†ä¸åŒè¿è¥å•†çš„æ‰‹æœºæ— æ³•æ­£å¸¸æ˜¾ç¤ºå¯¹æ–¹æ‰‹æœºå‘çš„Emojiã€‚ è‹¹æœæ˜¯Emojiä¼ éå…¨çƒçš„æœ€å¤§åŠŸè‡£ã€‚ä¸ºäº†æŠŠiPhoneæ‰“å…¥æ—¥æœ¬å¸‚åœºï¼Œè‹¹æœå†³å®šåœ¨iOS 2.2ä¸­åŠ å…¥æ—¥æœ¬æ¶ˆè´¹è€…çš„æœ€çˆ±emojiï¼Œä¸ºäº†è¿åˆæ—¥æœ¬å¸‚åœºï¼Œä»–ä»¬åœ¨3ä¸ªæœˆçš„æ—¶é—´æ¨å‡ºäº†400å¤šä¸ªè¡¨æƒ…ç¬¦å·ï¼Œæå¤§åœ°æ‹“å±•äº†Emojiçš„è¡¨æƒ…æ•°é‡ï¼Œé‚£æ—¶çš„iOS Emojiåªåœ¨æ—¥æœ¬åœ°åŒºå¯ç”¨ï¼Œä½†â€œå¥½æ™¯ä¸é•¿â€ï¼ŒåŒ—ç¾çš„iOS 2.2ç”¨æˆ·å‘ç°äº†éšè—åœ¨ç³»ç»Ÿä¸­çš„Emojiï¼Œä¹‹åEmojiå¾ˆå¿«æµè¡Œäº†èµ·æ¥ï¼Œè¿™ç§ç°è±¡å¾—åˆ°äº†å…¶å®ƒç§‘æŠ€å…¬å¸çš„æ³¨æ„ã€‚ éšç€Emojiçš„æµè¡Œï¼Œ2010å¹´ï¼ŒEmoji é¦–æ¬¡è¢«çº³å…¥Unicode v6.0å­—ç¬¦é›†ä¸­ã€‚æ¯ä¸ªå­—ç¬¦ï¼ˆè¡¨æƒ…ï¼‰éƒ½è¢«è®¾å®šäº†ç»Ÿä¸€ä¸”å”¯ä¸€çš„äºŒè¿›åˆ¶ç ï¼Œä»è€Œä¿éšœäº†å„å¹³å°æ‰‹æœºéƒ½èƒ½ä½¿ç”¨Emojiï¼Œæˆªæ­¢æ’°æ–‡æœŸé—´ï¼Œæœ€æ–°çš„Unicode v15.1å­—ç¬¦é›†ä¸­å·²æœ‰3782ä¸ªEmojiå­—ç¬¦ï¼Œè€Œæ›´æ–°çš„Unicode v16ç‰ˆæœ¬é¢„è®¡äº2024å¹´9æœˆå‘å¸ƒreleaseï¼Œå±Šæ—¶ä¼šæœ‰æ›´å¤šçš„Emojiè¢«æ”¯æŒã€‚ Unicodeæ—¢ç„¶Emojiè¢«Unicodeæ‰€æ”¶çº³ï¼Œé‚£æˆ‘ä»¬å¿…å…ˆå¾—å»äº†è§£Unicodeã€‚ å¹¿ä¹‰ä¸Šçš„Unicodeæ˜¯ä¸€ä¸ªæ ‡å‡†ï¼Œå®šä¹‰äº†Unicodeå­—ç¬¦é›†ä»¥åŠä¸€ç³»åˆ—çš„ç¼–ç è§„åˆ™ï¼Œæ˜¯ä¸€ç§æ”¶å½•äº†ä¸–ç•Œä¸Šæ‰€æœ‰è¯­è¨€çš„æ–‡å­—å’Œç¬¦å·çš„å…¨çƒæ ‡å‡†ã€‚ é‚£ä¹ˆUnicodeæ˜¯æ€æ ·æ”¶å½•å¦‚æ­¤åºå¤§çš„å­—ç¬¦å†…å®¹å‘¢ï¼Ÿå¾ˆç®€å•ï¼Œç»™æ¯ä¸ªå­—ç¬¦æŒ‡å®šä¸€ä¸ªç¼–å·å°±è¡Œäº†ï¼Œåœ¨Unicodeä¸­è¢«ç§°ä¸ºç ç‚¹ï¼ˆCodePointï¼‰ï¼Œå®ƒçš„è¡¨ç°å½¢å¼ä¸ºU+åé¢è·Ÿä¸Šä¸€ä¸ªåå…­è¿›åˆ¶æ•°ï¼Œæ¯”å¦‚U+0041è¡¨ç¤ºå¤§å†™å­—æ¯Aã€‚ ä¸–ç•Œä¸Šæœ‰é‚£ä¹ˆå¤šå­—ç¬¦ï¼ŒUnicodeå¹¶ä¸æ˜¯ä¸€æ¬¡æ€§å®šä¹‰çš„ï¼Œè€Œæ˜¯åˆ†åŒºå®šä¹‰ï¼Œæ¯ä¸ªåŒºå¯ä»¥å­˜æ”¾ 65536 (2^16) ä¸ªå­—ç¬¦ï¼Œç§°ä¸ºä¸€ä¸ªå¹³é¢ï¼ˆPlaneï¼‰ï¼Œç›®å‰Unicodeä»ç¬¬0å¹³é¢åˆ°ç¬¬16å¹³é¢æ€»å…±æœ‰17ä¸ªå¹³é¢ï¼Œå…¶ä¸­ç¬¬0å¹³é¢è¢«ç§°ä¸ºåŸºæœ¬å¹³é¢ï¼ˆBMPï¼‰ï¼Œå®ƒçš„ç ç‚¹èŒƒå›´ä»0ä¸€ç›´åˆ°65535ï¼Œå†™æˆåå…­è¿›åˆ¶ä¹Ÿå°±æ˜¯ U+0000 - U+FFFF ï¼Œæ‰€æœ‰çš„å¸¸è§å­—ç¬¦éƒ½è¢«æ”¾åœ¨è¿™ä¸ªå¹³é¢ï¼Œè¿™æ˜¯Unicodeæœ€å…ˆå®šä¹‰å’Œå…¬å¸ƒçš„ä¸€ä¸ªå¹³é¢ï¼Œè€Œå‰©ä¸‹çš„å¹³é¢è¢«ç§°ä¸ºè¾…åŠ©å¹³é¢ï¼Œç ç‚¹èŒƒå›´ä» U+010000 ä¸€ç›´åˆ° U+10FFFF UTF-16Unicodeå­—ç¬¦é›†åªè§„å®šäº†æ¯ä¸ªå­—ç¬¦çš„ç ç‚¹ï¼Œä½†è¿™ä¸€ä¸ªä¸ªç ç‚¹åº”è¯¥è¢«è®¡ç®—æœºä¼ è¾“è¯†åˆ«å‘¢ï¼Ÿè¿™å°±æ¶‰åŠåˆ°ç¼–ç çš„æ¦‚å¿µäº†ï¼Œç›®å‰Unicodeå®é™…åº”ç”¨ä½¿ç”¨çš„ç¼–ç æ–¹å¼ä¸ºUCS-2ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸ªå­—ç¬¦å ç”¨2ä¸ªå­—èŠ‚ï¼ŒUnicodeè¿˜æœ‰ä¸€ç§4å­—èŠ‚çš„ç¼–ç æ–¹å¼UCS-4ï¼Œä½†è¿™é‡Œä¸åšè®¨è®ºã€‚ ä½¿ç”¨UCS-2ç¼–ç æ–¹å¼åŒ…å«65536ä¸ªå­—ç¬¦ç©ºé—´ï¼ˆ2ä¸ªå­—èŠ‚çš„å¯ç”¨ç©ºé—´å³ä¸º2^16ï¼‰ï¼Œå¯¹åº”ç€è¡¨ç¤ºç€Unicodeå­—ç¬¦é›†ä¸­çš„åŸºæœ¬å¹³é¢ï¼Œé‚£å‰©ä½™çš„è¾…åŠ©å¹³é¢åˆè¯¥å¦‚ä½•è¡¨ç¤ºå‘¢ï¼ŸUTF-16åº”è¿è€Œç”Ÿã€‚ UTF-16æ˜¯UCS-2çš„è¶…é›†ï¼Œæ˜¯ä¸€ç§å˜é•¿ç¼–ç ï¼Œå®ƒçš„ç¼–ç è§„åˆ™å¾ˆç®€å•ï¼šåŸºæœ¬å¹³é¢çš„å­—ç¬¦å ç”¨2ä¸ªå­—èŠ‚ï¼Œè¾…åŠ©å¹³é¢çš„å­—ç¬¦å ç”¨4ä¸ªå­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯è¯´UTF-16çš„ç¼–ç é•¿åº¦è¦ä¹ˆæ˜¯2ä¸ªå­—èŠ‚ï¼ˆU+0000-U+FFFFï¼‰ï¼Œè¦ä¹ˆæ˜¯4ä¸ªå­—èŠ‚ï¼ˆU+010000-U+10FFFFï¼‰ã€‚ é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œé‡‡ç”¨UTF-16ç¼–ç çš„æ—¶å€™ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆåˆ¤æ–­è¿™ä¸ªå­—ç¬¦å ç”¨çš„æ˜¯2ä¸ªå­—èŠ‚è¿˜æ˜¯4ä¸ªå­—èŠ‚å‘¢ï¼Ÿè¿™é‡Œæœ‰ä¸ªå·§å¦™çš„æ–¹å¼ï¼Œåœ¨Unicodeçš„åŸºæœ¬å¹³é¢ä¸­ï¼Œä»U+D800åˆ°U+DFFFæ˜¯ä¸€ä¸ªç©ºæ®µï¼Œå³è¿™äº›ç ç‚¹ä¸å¯¹åº”ä»»ä½•å­—ç¬¦ï¼Œå› æ­¤ï¼Œè¿™ä¸ªç©ºæ®µå¯ä»¥ç”¨æ¥æ˜ å°„è¾…åŠ©å¹³é¢çš„å­—ç¬¦ã€‚è¾…åŠ©å¹³é¢çš„å­—ç¬¦ä¸€å…±æœ‰2^20ä¸ªï¼ˆä¸€ä¸ªå¹³é¢2^16ä¸ªå­—ç¬¦ * 16ä¸ªå¹³é¢(2^4)ï¼‰ï¼Œå› æ­¤è¡¨ç¤ºè¿™äº›å­—ç¬¦è‡³å°‘éœ€è¦20ä¸ªäºŒè¿›åˆ¶ä½ã€‚UTF-16å°†è¿™20ä¸ªäºŒè¿›åˆ¶ä½åˆ†æˆä¸¤åŠï¼Œå‰10ä½æ˜ å°„åœ¨U+D800åˆ°U+DBFFï¼ˆUTF-16çš„é«˜åŠåŒºï¼Œç©ºé—´å¤§å°2^10ï¼‰ï¼Œç§°ä¸ºé«˜ä½ï¼ˆHï¼‰ï¼Œå10ä½æ˜ å°„åœ¨U+DC00åˆ°U+DFFFï¼ˆUTF-16çš„ä½åŠåŒºï¼Œç©ºé—´å¤§å°2^10ï¼‰ï¼Œç§°ä¸ºä½ä½ï¼ˆLï¼‰ã€‚è¿™æ„å‘³ç€ï¼Œä¸€ä¸ªè¾…åŠ©å¹³é¢çš„å­—ç¬¦ï¼Œè¢«æ‹†æˆä¸¤ä¸ªåŸºæœ¬å¹³é¢çš„å­—ç¬¦è¡¨ç¤ºã€‚ å› æ­¤ï¼Œæ¯å½“ç¨‹åºé‡åˆ°2ä¸ªå­—èŠ‚æ—¶ï¼Œä¾¿ä¼šå»åˆ¤æ–­å®ƒçš„ç å…ƒæ˜¯å¦åœ¨U+D800åˆ°U+DBFFä¹‹é—´ï¼Œå¦‚æœåœ¨çš„è¯åˆ™å¯ä»¥å‡å®šå®ƒæ˜¯ä¸€ä¸ª4å­—èŠ‚çš„å­—ç¬¦ï¼Œæ­¤æ—¶æ¥ç€å¾€åè¯»2ä¸ªå­—èŠ‚ï¼Œå¦‚æœè¿™2ä¸ªå­—èŠ‚çš„çš„ç å…ƒåœ¨U+DC00åˆ°U+DFFFä¹‹é—´ï¼Œå°†ä»–ä»¬ç»„åˆèµ·æ¥è·å¾—åˆ°å®é™…å­—ç¬¦ï¼›è€Œå¦‚æœä¸åœ¨çš„è¯åˆ™å¯ä»¥åˆ¤å®šä¸ºæ˜¯ä¸€ä¸ª2å­—èŠ‚çš„å­—ç¬¦ã€‚ æˆ‘ä»¬ä»¥Javaä¸­è·å–ç ç‚¹çš„æ–¹æ³•Character.codePointAtä¸ºä¾‹æ¥è§£è¯»ä¸€ä¸‹ä»£ç ä¸­å¦‚ä½•è·å–ä¸€ä¸ªå­—ç¬¦çš„ç ç‚¹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public finalclass Character implements java.io.Serializable, Comparable&lt;Character&gt; &#123; // ... public static final char MIN_HIGH_SURROGATE = '\\uD800'; public static final char MAX_HIGH_SURROGATE = '\\uDBFF'; public static final char MIN_LOW_SURROGATE = '\\uDC00'; public static final char MAX_LOW_SURROGATE = '\\uDFFF'; public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000; // ... public static int codePointAt(CharSequence seq, int index) &#123; char c1 = seq.charAt(index); // ç å…ƒåœ¨ U+D800 åˆ° U+DBFF ä¹‹é—´ï¼Œå¹¶ä¸”ä¸‹ä¸€ä¸ªcharçš„indexæ²¡åˆ°ç»“å°¾ if (isHighSurrogate(c1) &amp;&amp; ++index &lt; seq.length()) &#123; char c2 = seq.charAt(index); // ä¸‹ä¸€ä¸ªcharçš„ç å…ƒåœ¨ U+DC00 åˆ° U+DFFF ä¹‹é—´ if (isLowSurrogate(c2)) &#123; // ç»„åˆèµ·æ¥è·å¾—å®Œæ•´å­—ç¬¦çš„ç ç‚¹ return toCodePoint(c1, c2); &#125; &#125; // å­—ç¬¦ç ç‚¹å³æ˜¯å•ä¸ªcharçš„ç å…ƒ return c1; &#125; // ç å…ƒæ˜¯å¦åœ¨ U+D800 åˆ° U+DBFF ä¹‹é—´ public static boolean isHighSurrogate(char ch) &#123; // Help VM constant-fold; MAX_HIGH_SURROGATE + 1 == MIN_LOW_SURROGATE return ch &gt;= MIN_HIGH_SURROGATE &amp;&amp; ch &lt; (MAX_HIGH_SURROGATE + 1); &#125; // ç å…ƒæ˜¯å¦åœ¨ U+DC00 åˆ° U+DFFF ä¹‹é—´ public static boolean isLowSurrogate(char ch) &#123; return ch &gt;= MIN_LOW_SURROGATE &amp;&amp; ch &lt; (MAX_LOW_SURROGATE + 1); &#125; /** * è®¡ç®—è§„åˆ™ï¼š * 1. é«˜ä½ä¸Šçš„ç å…ƒå‡æ‰é«˜åŠåŒºçš„èµ·å§‹å€¼ 0xD800 ï¼Œç„¶åå·¦ç§»10ä½ * 2. ä½ä½ä¸Šçš„ç å…ƒå‡æ‰ä½åŠåŒºçš„èµ·å§‹å€¼ 0xDC00 * 3. å°† 1 å’Œ 2 çš„è®¡ç®—ç»“æœä»¥åŠè¾…åŠ©å¹³é¢çš„èµ·å§‹å€¼ 0x010000 ç›¸åŠ ï¼Œè·å–åˆ°å®Œæ•´çš„ç ç‚¹å€¼ */ public static int toCodePoint(char high, char low) &#123; // Optimized form of: // return ((high - MIN_HIGH_SURROGATE) &lt;&lt; 10) // + (low - MIN_LOW_SURROGATE) // + MIN_SUPPLEMENTARY_CODE_POINT; return ((high &lt;&lt; 10) + low) + (MIN_SUPPLEMENTARY_CODE_POINT - (MIN_HIGH_SURROGATE &lt;&lt; 10) - MIN_LOW_SURROGATE); &#125; // ...&#125; Emojiè§„åˆ™äº†è§£äº†Unicodeæ ‡å‡†åï¼Œæˆ‘ä»¬å›è¿‡å¤´æ¥æ€è€ƒä¸€ä¸‹ï¼Œæ˜¯ä¸æ˜¯è¯´Emojiåœ¨Unicodeæ ‡å‡†ä¸­ä¹Ÿä»…ä»…åªæ˜¯è¢«å½“æˆæ™®é€šçš„å­—ç¬¦çœ‹å¾…å‘¢ï¼Ÿå½“ç„¶å¹¶éå¦‚æ­¤ï¼Œé™¤äº†ä¹‹å‰è¯´çš„å¹³é¢è§„åˆ™ç­‰ï¼ŒEmojiåœ¨Unicodeä¸­è¿˜æœ‰ä¸€å¥—è‡ªå·±çš„è§„åˆ™ï¼Œè¿™äº›è§„åˆ™éƒ½å¯ä»¥åœ¨ Unicode æŠ€æœ¯æ ‡å‡† #51 Emoji ä¸­æ‰¾åˆ°ï¼Œå®˜æ–¹çš„æ–‡æ¡£ä¹ä¸€çœ‹å¯èƒ½æ¯”è¾ƒéš¾ç†è§£ï¼Œæ¥ä¸‹æ¥å°±ç”±æˆ‘æ¥ç»™å¤§å®¶åšä¸€ä¸ªè§£è¯»ã€‚ é¦–å…ˆï¼ŒEmojiåœ¨å¤§ç±»ä¸Šå¯ä»¥åˆ†æˆä¸¤ç§ï¼Œä¸€ç§æ˜¯åŸºæœ¬Emojiï¼Œä¸€ç§æ˜¯å¤šå­—ç¬¦ç»„åˆè€Œæˆçš„å¤åˆEmoji åŸºæœ¬Emojiä»€ä¹ˆæ˜¯åŸºæœ¬Emojiå‘¢ï¼ŸæŒ‡çš„æ˜¯ç›´æ¥åœ¨Unicodeå­—ç¬¦é›†é‡Œå®šä¹‰çš„ä¸€ä¸ªEmojiå­—ç¬¦ï¼Œå¤§å¤šæ•°åŸºæœ¬Emojiå­—ç¬¦éƒ½è¢«åˆ’å½’åˆ°U+1F300-U+1F6FFå’ŒU+1F900-U+1FAFFè¿™ä¸¤ä¸ªåŒºåŸŸ å…·ä½“éƒ½æœ‰å“ªäº›åŸºæœ¬Emojiå­—ç¬¦ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Unicodeçš„å®˜ç½‘æ–‡æ¡£ emoji-data ä¸­æ‰¾åˆ° å¤åˆEmojiæ‰€è°“çš„å¤åˆEmojiï¼ˆæˆ‘è‡ªå·±å–çš„åå­—ï¼‰æŒ‡çš„æ˜¯ç”±å¤šä¸ªå­—ç¬¦ç»„æˆçš„Emojiï¼Œå®ƒæœ‰ç€å¤šç§æ„é€ æ–¹å¼ åœ¨ Unicode æŠ€æœ¯æ ‡å‡† #51 Emoji ä¸­çš„1.4.9å°èŠ‚ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°Unicodeå¯¹Emojiå®šä¹‰çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±é€šè¿‡å¯¹è¿™ä¸ªæ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œä¸€æ­¥æ­¥çš„è§£ææ¥äº†è§£Emojiçš„ç»„æˆè§„åˆ™ 123456789101112131415\\p&#123;RI&#125; \\p&#123;RI&#125; | \\p&#123;Emoji&#125; ( \\p&#123;EMod&#125; | \\x&#123;FE0F&#125; \\x&#123;20E3&#125;? | [\\x&#123;E0020&#125;-\\x&#123;E007E&#125;]+ \\x&#123;E007F&#125; )? (\\x&#123;200D&#125; ( \\p&#123;RI&#125; \\p&#123;RI&#125; | \\p&#123;Emoji&#125; ( \\p&#123;EMod&#125; | \\x&#123;FE0F&#125; \\x&#123;20E3&#125;? | [\\x&#123;E0020&#125;-\\x&#123;E007E&#125;]+ \\x&#123;E007F&#125; )? ) )* æ——å¸œé¦–å…ˆæˆ‘ä»¬çœ‹ç¬¬ä¸€è¡Œçš„åŒ¹é…æ¡ä»¶\\p{RI} \\p{RI}ï¼Œè¿™é‡Œçš„\\p{RI}å…¨ç§°ä¸ºRegional Indicatorï¼Œç¿»è¯‘æˆä¸­æ–‡å°±æ˜¯åŒºåŸŸæŒ‡ç¤ºç¬¦ï¼Œæ ¹æ®è¿™è¡Œæ­£åˆ™æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°ï¼Œä¸¤ä¸ªåŒºåŸŸæŒ‡ç¤ºç¬¦è¿æ¥ä¾¿å¯ç»„æˆä¸€ä¸ªEmojiï¼Œé‚£ä¹ˆè¿™ä¸ªåŒºåŸŸæŒ‡ç¤ºç¬¦æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ é€šè¿‡ ç»´åŸºç™¾ç§‘ æˆ‘ä»¬å¯ä»¥å¾—çŸ¥ï¼ŒåŒºåŸŸæŒ‡ç¤ºç¬¦æŒ‡çš„æ˜¯ä»U+1F1E6åˆ°U+1F1FFä¸­çš„å­—ç¬¦ï¼Œä½äºUnicodeç¬¬ä¸€è¾…åŠ©å¹³é¢çš„å¸¦åœˆå­—æ¯æ•°å­—è¡¥å……åŒºå—å†…ã€‚ æ­£å¦‚åŒºå—æè¿°æ‰€è¯´ï¼Œè¿™äº›å­—ç¬¦çœ‹èµ·æ¥å°±åƒæ˜¯ä¸€ä¸ªä¸ªè‹±æ–‡å­—æ¯ï¼Œå¤–é¢å¥—äº†ä¸ªæ–¹æ¡†ï¼Œè¿™é‡Œæ˜¯å®Œæ•´çš„å­—ç¬¦è¡¨ï¼šğŸ‡¦ ğŸ‡§ ğŸ‡¨ ğŸ‡© ğŸ‡ª ğŸ‡« ğŸ‡¬ ğŸ‡­ ğŸ‡® ğŸ‡¯ ğŸ‡° ğŸ‡± ğŸ‡² ğŸ‡³ ğŸ‡´ ğŸ‡µ ğŸ‡¶ ğŸ‡· ğŸ‡¸ ğŸ‡¹ ğŸ‡º ğŸ‡» ğŸ‡¼ ğŸ‡½ ğŸ‡¾ ğŸ‡¿ï¼Œé€šè¿‡ä¸¤ä¸¤ç»„åˆçš„æ–¹å¼ï¼Œå°†å®ƒä»¬æ‹¼æˆå›½å®¶æˆ–åœ°åŒºçš„ä»£å·ï¼Œæˆ‘ä»¬å°±èƒ½å¾—åˆ°è¯¥å›½å®¶æˆ–åœ°åŒºçš„æ——å¸œã€‚ ä»¥ä¸­å›½ğŸ‡¨ğŸ‡³ä¸¾ä¾‹ï¼Œä¸­å›½çš„ä»£å·ä¸ºCNï¼Œé‚£æˆ‘ä»¬å°±å°†ğŸ‡¨å’ŒğŸ‡³ä¸¤ä¸ªå­—ç¬¦æ‹¼æ¥åˆ°ä¸€èµ·ï¼Œä¾¿èƒ½å¾—åˆ°ä¸­å›½å›½æ——ğŸ‡¨ğŸ‡³ è‚¤è‰²ä¿®é¥°ç¬¦ç¬¬äºŒè¡Œçš„\\p{Emoji}æŒ‡çš„å°±æ˜¯æˆ‘ä»¬ä¹‹å‰è¯´è¿‡çš„åŸºæœ¬Emojiï¼Œè¿™ä¸ªæ˜¯æ„æˆé™¤æ——å¸œå¤–çš„å¤åˆEmojiçš„åŸºç¡€æ¡ä»¶ï¼Œæ¥ç€æˆ‘ä»¬çœ‹æ­£åˆ™çš„ç¬¬ä¸‰åˆ°ç¬¬å…­è¡Œï¼Œè¿™é‡Œç”¨æ‹¬å·æ‹¬èµ·äº†ä¸€ä¸ªæ¡ä»¶ï¼Œæ‹¬å·çš„å°¾éƒ¨è·Ÿäº†ä¸€ä¸ªé—®å·ï¼Œè¡¨ç¤ºæ‹¬å·ä¸­çš„è¿™ä¸ªæ¡ä»¶æœ€å¤šåªå¯ä»¥å‡ºç°ä¸€æ¬¡ï¼ˆ0æ¬¡æˆ–1æ¬¡ï¼‰ï¼Œæ‹¬å·å†…çš„æ¡ä»¶åˆæ˜¯ç”±ä¸‰ä¸ªå­æ¡ä»¶ç»„æˆï¼Œç”¨æˆ–å·åˆ†å‰²ï¼Œæ»¡è¶³ä»»æ„ä¸€æ¡æ¡ä»¶åˆ™è§†ä¸ºæ•´ä¸ªæ¡ä»¶æˆç«‹ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ç¬¬ä¸€ä¸ªå­æ¡ä»¶\\p{EMod}ã€‚ å…¨ä¸–ç•Œçš„äººä»¬éƒ½å¸Œæœ›æ‹¥æœ‰åæ˜ æ›´å¤šäººç±»å¤šæ ·æ€§çš„Emojiï¼Œå°¤å…¶æ˜¯å¯¹äºè‚¤è‰²ã€‚Unicode v8.0ï¼ˆ2015å¹´ä¸­ï¼‰å‘è¡Œäº†äº”ä¸ªä¸ºäººç±»è¡¨æƒ…ç¬¦å·æä¾›ä¸€ç³»åˆ—è‚¤è‰²çš„ç¬¦å·ä¿®é¥°ç¬¦ç¬¦ï¼Œå…·ä½“çš„ä¿®é¥°ç¬¦ä»¥åŠæ•ˆæœç”±ä¸‹å›¾æ‰€ç¤ºï¼š æˆ‘ä»¬ä»¥åŸºæœ¬Emojiâœ‹ä¸ºä¾‹ï¼Œå®ƒçš„ç ç‚¹æ˜¯U+270Bï¼Œåœ¨ä»–åé¢åŠ ä¸ŠU+1F3FBï¼Œè¿™ä¸ªEmojiå°±å˜æˆäº†âœ‹ğŸ»ï¼ŒåŒæ ·çš„ï¼š âœ‹ + U+1F3FC = âœ‹ğŸ¼ âœ‹ + U+1F3FD = âœ‹ğŸ½ âœ‹ + U+1F3FE = âœ‹ğŸ¾ âœ‹ + U+1F3FF = âœ‹ğŸ¿ å˜ä½“é€‰æ‹©ç¬¦æ¥ç€ï¼Œæˆ‘ä»¬å†çœ‹ç¬¬äºŒä¸ªå­æ¡ä»¶x{FE0F} \\x{20E3}?ï¼Œè¿™é‡Œçš„x{FE0F}æŒ‡çš„æ˜¯å˜ä½“é€‰æ‹©ç¬¦-16ï¼ˆVariation Selector-16ï¼‰ï¼Œé‚£ä¹ˆé¦–å…ˆï¼Œä»€ä¹ˆæ˜¯å˜ä½“é€‰æ‹©ç¬¦å‘¢ï¼Ÿ å®é™…ä¸Šï¼Œæ”¯æŒè±¡å½¢æ–‡å­—çš„å­—ä½“æœ€æ—©å¯ä»¥è¿½æº¯åˆ°1993å¹´ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹Unicodeå­—ç¬¦é›†çš„è£…é¥°ç¬¦å·åŒºU+2700-U+27FF é‚£å¦‚æœEmojiæƒ³è¦åœ¨è¿™äº›è±¡å½¢æ–‡å­—çš„åŸºç¡€ä¸Šåšæ‰©å±•ï¼Œæ·»åŠ é¢œè‰²ï¼Œä½¿å…¶æ›´åŠ ç”ŸåŠ¨æ€ä¹ˆåŠï¼Ÿæ²¡é”™ï¼Œæ­¤æ—¶å°±éœ€è¦ä½¿ç”¨åˆ°å˜ä½“é€‰æ‹©ç¬¦äº†ã€‚ å˜ä½“é€‰æ‹©ç¬¦ï¼ˆç®€ç§°VSï¼‰æ˜¯ä¸€ä¸ªåŸºæœ¬å¤šæ–‡ç§å¹³é¢çš„UnicodeåŒºæ®µï¼ŒåŒ…æ‹¬16ä¸ªå˜ä½“é€‰æ‹©ç¬¦ã€‚è¿™äº›é€‰æ‹©å™¨ç”¨äºæè¿°å‰ä¸€ä¸ªå­—ç¬¦çš„ç‰¹ç‚¹å­—å½¢ã€‚ç›®å‰ Unicodeå·²å®šä¹‰æ•°å­¦ç¬¦å·ã€ç»˜æ–‡å­—ã€å…«æ€å·´å­—æ¯åŠä¸­æ—¥éŸ©ç»Ÿä¸€è¡¨æ„æ–‡å­—æ‰€å¯¹åº”çš„ä¸­æ—¥éŸ©å…¼å®¹è¡¨æ„æ–‡å­—ã€‚ç›®å‰Unicodeä»…å®šä¹‰ VS1, VS2, VS3, VS15 åŠ VS16ï¼ŒVS15 å’Œ VS16 åˆ†åˆ«ç”¨äºæ ‡ç¤ºæŸå­—ç¬¦åº”è¯¥æ˜¾ç¤ºä¸ºæ™®é€šæ–‡å­—æˆ–è€…æ˜¯Emojiï¼Œè¿™äº›å­—ç¬¦è¢«å‘½åä¸ºU+FE00ï¼ˆVS1ï¼‰è‡³U+FE0F(VS16)ã€‚é€‰æ‹©ç¬¦ä»…åº”ç”¨äºå‰ä¸€ä¸ªå­—ç¬¦ã€‚ ä»¥åˆšæ‰æˆ‘ä»¬åœ¨è£…é¥°ç¬¦å·åŒºä¸­çœ‹åˆ°çš„å‰ªåˆ€ç¬¦å·âœ‚U+2702ä¸ºä¾‹ï¼Œåœ¨å®ƒçš„åé¢åŠ ä¸ŠVS16 U+FE0Fï¼Œè¿™ä¸ªå­—ç¬¦å°±å˜æˆäº†Emojiâœ‚ï¸ï¼Œæ˜¯ä¸æ˜¯å¾ˆç¥å¥‡ é”®å¸½ç¬¦çœ‹å®Œäº†å˜ä½“é€‰æ‹©ç¬¦åï¼Œæˆ‘ä»¬ç´§æ¥ç€ä¼šç–‘æƒ‘ï¼Œé‚£è¿™ä¸ªæ¡ä»¶åé¢çš„\\x{20E3}åˆæ˜¯å•¥å‘¢ï¼Ÿå®ƒè¢«ç§°ä¸ºCOMBINING ENCLOSING KEYCAPï¼Œå®ƒå¯¹å‰ç½®çš„å­—ç¬¦æœ‰ä¸€å®šçš„è¦æ±‚ï¼Œåªå¯¹æ•°å­—ã€æ˜Ÿå·å’Œäº•å·ç”Ÿæ•ˆï¼Œä¹Ÿå°±æ˜¯è¯´ä»…ä»…æ”¯æŒ*#0123456789è¿™12ä¸ªå­—ç¬¦ã€‚ å®ƒçš„è§„åˆ™æ˜¯ï¼Œå½“å¼€å¤´ä¸ºè¿™12ä¸ªå­—ç¬¦ä¸­çš„ä¸€ä¸ªæ—¶ï¼Œåé¢åŠ ä¸ŠVS16 U+FE0Få˜æˆä¸€ä¸ªEmojiï¼Œç„¶ååœ¨åŠ ä¸Šå®ƒU+20E3ï¼Œè¿™ä¸ªå­—ç¬¦å°±ä¼šå˜æˆä¸€ä¸ªé”®å¸½å½¢çŠ¶çš„å­—ç¬¦ï¼š#ï¸âƒ£ *ï¸âƒ£ 0ï¸âƒ£ 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£ æ ‡ç­¾åºåˆ—ç„¶åæ˜¯æœ€åä¸€ä¸ªå­æ¡ä»¶[\\x{E0020}-\\x{E007E}]+ \\x{E007F}ï¼Œè¿™æ˜¯ä¸€ä¸ªæ ‡ç­¾åºåˆ—ï¼Œå®ƒç”±ä¸€ä¸ªåŸºç¡€é»‘æ——ç¬¦å·ï¼Œä¸€ç³»åˆ—æ ‡ç­¾å­—ç¬¦ä»¥åŠä¸€ä¸ªæ ‡ç­¾ç»ˆæ­¢ç¬¦ç»„æˆï¼Œé¦–å…ˆä»¥åŸºç¡€é»‘æ——ç¬¦å·ğŸ´U+1F3F4å¼€å¤´ï¼Œç„¶åä¸­é—´æ˜¯ä¸€ç³»åˆ—çš„U+E0020åˆ°U+E007Eä¹‹é—´çš„å­—ç¬¦ï¼Œæœ€åä»¥æ ‡ç­¾ç»ˆæ­¢ç¬¦U+E007Fç»“å°¾ï¼Œè¿™æ ·å°±ç»„æˆäº†ä¸€ä¸ªæ ‡ç­¾åºåˆ—Emojiã€‚ ç›®å‰è¿™ç§Emojiä¸å¤ªå¸¸è§ï¼Œä»…ä»…åªæœ‰è‹±æ ¼å…°ã€è‹æ ¼å…°å’Œå¨å°”å£«çš„æ——å¸œä½¿ç”¨æ ‡ç­¾åºåˆ—ï¼š ğŸ´ + U+E0067 + U+E0062 + U+E0065 + U+E006E + U+E0067 + U+E007F = ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿ ğŸ´ + U+E0067 + U+E0062 + U+E0073 + U+E0063 + U+E0074 + U+E007F = ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ ğŸ´ + U+E0067 + U+E0062 + U+E0077 + U+E006C + U+E0073 + U+E007F = ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿ é›¶å®½åº¦è¿æ¥ç¬¦è¿™äº›å­æ¡ä»¶çœ‹å®Œï¼Œæˆ‘ä»¬å†å›å½’åˆ°æ­£åˆ™è¡¨è¾¾å¼ä¸­æ¥ï¼Œå¯ä»¥è§‚å¯Ÿåˆ°8åˆ°14è¡Œçš„æ¡ä»¶å’Œ1åˆ°6è¡Œçš„æ¡ä»¶å…¶å®æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œè€Œåœ¨ç¬¬7è¡Œå‡ºç°äº†ä¸€ä¸ªæ¡ä»¶\\x{200D}è¿æ¥äº†è¿™ä¸¤ä¸ªä¸€æ ·çš„æ¡ä»¶ï¼Œä»€ä¹ˆæ„æ€å‘¢ï¼Ÿ æ²¡é”™ï¼Œç»“åˆæœ¬æ–‡çš„èµ·å› éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“çš„å°±å¯ä»¥è”æƒ³åˆ°ï¼Œè¿™ä¸ª\\x{200D}èµ·åˆ°çš„å°±æ˜¯è¿æ¥ä½œç”¨ï¼Œå®ƒè¢«ç§°ä¸ºé›¶å®½åº¦è¿æ¥ç¬¦ï¼ˆZERO-WIDTH JOINERï¼Œç®€ç§°ZWJï¼‰ï¼Œé€šè¿‡ä¸Šé¢æ­£åˆ™è¡¨è¾¾å¼å°¾éƒ¨çš„*å·æˆ‘ä»¬å¯ä»¥å¾—çŸ¥ï¼Œé€šè¿‡è¿™ä¸ªè¿æ¥ç¬¦ï¼Œå¯ä»¥è¿æ¥å¤šä¸ªEmojiåˆæˆæ–°çš„Emojiï¼Œä¸‹é¢ä¸¾å‡ ä¸ªæœ‰è¶£çš„ä¾‹å­ï¼š ğŸ‘©U+1F469 + U+200D + âœˆï¸U+2708 U+FE0F = ğŸ‘©â€âœˆï¸ ğŸ‘¨U+1F468 + U+200D + ğŸ’»U+1F4BB = ğŸ‘¨â€ğŸ’» ğŸ»U+1F43B + U+200D + â„ï¸U+2744 U+FE0F = ğŸ»â€â„ï¸ ğŸ´U+1F3F4 + U+200D + â˜ ï¸U+2620 U+FE0F = ğŸ´â€â˜ ï¸ ğŸ³ï¸U+1F3F3 U+FE0F + U+200D + ğŸŒˆU+1F308 = ğŸ³ï¸â€ğŸŒˆ ä»¥ä¸Šæ˜¯ç”±ä¸¤ä¸ªEmojiç»„æˆä¸€ä¸ªæ–°çš„Emojiçš„ä¾‹å­ï¼Œè€Œå®¶åº­ä»¥åŠäººé™…å…³ç³»ç›¸å…³çš„Emojié€šå¸¸ä¼šç”±æ›´å¤šEmojiæ„æˆï¼Œå°±æ‹¿æœ¬æ–‡å¼€å¤´æåˆ°çš„ä¾‹å­ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ï¼Œå®ƒçš„æ„æˆå®é™…ä¸Šæ˜¯è¿™æ ·çš„ï¼š ğŸ‘¨U+1F468 + U+200D + ğŸ‘©U+1F469 + ğŸ‘§U+1F467 + ğŸ‘¦U+1F466 = ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ è¿™ä¹Ÿå°±è§£é‡Šäº†åœ¨AIèŠå¤©æœºå™¨äººæµå¼æ‰“å°æ–‡å­—çš„æ—¶å€™ï¼Œä¸ºä»€ä¹ˆä¼šä¾æ­¤æ˜¾ç¤ºğŸ‘¨ğŸ‘©ğŸ‘§ğŸ‘¦å››ä¸ªEmojiï¼Œæœ€åçªç„¶åˆæˆä¸€æ•´ä¸ªğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦äº† Emojiå­—ä½“ä»¥ä¸Šä¾¿æ˜¯Emojiæ„æˆçš„æ‰€æœ‰è§„åˆ™äº†ï¼Œä½†ä½ æœ‰æ²¡æœ‰è€ƒè™‘è¿‡ï¼Œä¸€èˆ¬å­—ä½“éƒ½æ˜¯é»‘ç™½çš„çŸ¢é‡å›¾å½¢ï¼Œä¸ºä»€ä¹ˆEmojiä¼šæ˜¾ç¤ºæˆå›¾ç‰‡å‘¢ï¼Ÿ æ“ä½œç³»ç»Ÿä¸€èˆ¬éƒ½ä¼šå†…ç½®ä¸€ç§Emojiå­—ä½“ï¼ŒMacOS/iOSå†…ç½®çš„æ˜¯Apple Color Emojiå­—ä½“ï¼ŒWindowså†…ç½®çš„æ˜¯Segoe UI Emojiå­—ä½“ï¼ŒAndroidå†…ç½®çš„æ˜¯Noto Color Emojiå­—ä½“ã€‚è¿™ä¹Ÿæ˜¯åŒä¸€ä¸ªEmojiå†ä¸åŒçš„è®¾å¤‡ä¸Šé•¿å¾—ä¸ä¸€æ ·çš„åŸå› ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå¾ˆå¤šåº”ç”¨ä¹Ÿä¼šè‡ªå¸¦Emojiå­—ä½“ï¼Œæ¯”å¦‚WhatsAppã€Twitterå’ŒFacebook å›å½’åˆå¿ƒï¼Œå¦‚ä½•è§£å†³æµå¼æ‰“å°é—®é¢˜æœ€åï¼Œè®©æˆ‘ä»¬å›åˆ°æœ¬æ–‡çš„å‡ºå‘ç‚¹ï¼Œäº†è§£äº†Emojiæœºåˆ¶åï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•è§£å†³AIèŠå¤©æœºå™¨äººçš„æµå¼æ‰“å°é—®é¢˜å‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œæ ¹æ®å­—ç¬¦ä¸²å‘ååšä¸€ä¸ªé¢„æµ‹å°±å¯ä»¥äº†ï¼Œå•¥å«é¢„æµ‹ï¼Ÿå°±æ˜¯å¾€ååŒ¹é…ï¼Œçœ‹è¿™ä¸ªå­—ç¬¦çš„ç»“æ„å½“å‰æ˜¯å¦ç¬¦åˆEmojiè§„åˆ™ï¼Œä»¥åŠåŠ ä¸Šåé¢çš„å­—ç¬¦åæœ‰æ²¡æœ‰å¯èƒ½ç»„æˆä¸€ä¸ªå®Œæ•´çš„Emojiï¼Œè¿™é‡Œå…·ä½“çš„ä»£ç æˆ‘å°±ä¸æ”¾äº†ï¼Œå¤§å®¶è‡ªè¡Œæ„Ÿæ‚Ÿå§ğŸ˜Š å‚è€ƒæ–‡çŒ® Emoji ç»´åŸºç™¾ç§‘ UTF-16 ç»´åŸºç™¾ç§‘ åŒºåŸŸæŒ‡ç¤ºç¬¦ ç»´åŸºç™¾ç§‘ æ€»è¢«å¤§åšæ–‡ç« çš„å®ƒä»å“ªæ¥ï¼Ÿ Emojièµ·æºå’Œå†å²ç§‘æ™® emojiçš„è¯ç”Ÿã€å‘å±•èƒŒåï¼Œæœ‰å“ªäº›è®¾è®¡å¼€å‘è€…çš„æ•…äº‹ï¼Ÿ Emoji å½»åº•å¼„æ‡‚Unicodeç¼–ç  Unicodeï¼ŸUTF-8ï¼ŸGBKï¼Ÿâ€¦â€¦èŠèŠå­—ç¬¦é›†å’Œå­—ç¬¦ç¼–ç æ ¼å¼ Emojiçš„å¥¥ç§˜ Unicode æŠ€æœ¯æ ‡å‡† #51 Emoji å·¥å…· Emoji Unicode Tables Unicode character inspector","categories":[{"name":"å…¶ä»–","slug":"å…¶ä»–","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Emoji","slug":"Emoji","permalink":"http://yoursite.com/tags/Emoji/"}]},{"title":"2023å°çº¢ä¹¦Androidé¢è¯•ä¹‹æ—…","slug":"interview/2023å°çº¢ä¹¦Androidé¢è¯•ä¹‹æ—…","date":"2023-10-25T04:48:21.000Z","updated":"2023-11-23T04:55:35.567Z","comments":true,"path":"2023/10/25/interview/2023å°çº¢ä¹¦Androidé¢è¯•ä¹‹æ—…/","link":"","permalink":"http://yoursite.com/2023/10/25/interview/2023%E5%B0%8F%E7%BA%A2%E4%B9%A6Android%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%97%85/","excerpt":"","text":"ä¸€é¢ è‡ªæˆ‘ä»‹ç» çœ‹ä½ å†™äº†å¾ˆå¤šæ–‡ç« ï¼Œæ‹¿ä½ ç†è§£æœ€æ·±åˆ»çš„ä¸€ç¯‡å‡ºæ¥è®²ä¸€è®² è®²äº†Binderç›¸å…³å†…å®¹ Binderå¤§æ¦‚åˆ†äº†å‡ å±‚ å“ªäº›æ–¹æ³•è°ƒç”¨ä¼šæ¶‰åŠåˆ°Binderé€šä¿¡ å¤§æ¦‚è®²ä¸€ä¸‹startActivityçš„æµç¨‹ï¼ŒåŒ…æ‹¬ä¸AMSçš„äº¤äº’ å…¨é¡µé¢åœç•™æ—¶é•¿åŸ‹ç‚¹æ˜¯æ€ä¹ˆåšçš„ æˆ‘åœ¨é¡¹ç›®ä¸­åšè¿‡çš„å†…å®¹ï¼Œä¸»è¦åŠŸèƒ½æ˜¯è®¡ç®—ç”¨æˆ·åœ¨æ¯ä¸ªActivityçš„åœç•™æ—¶é•¿ï¼Œå¹¶ä¸”æ”¯æŒå¤šè¿›ç¨‹ã€‚è¿™é‡Œçš„å¤šè¿›ç¨‹æ”¯æŒä¸»è¦æ˜¯é€šè¿‡ä»¥ContentProviderä½œä¸ºä¸­ä»‹ï¼Œç„¶åé€šè¿‡ContentResolver.callæ–¹æ³•å»è°ƒç”¨å®ƒçš„å„ç§æ–¹æ³•ä»¥å®ç°è·¨è¿›ç¨‹ åŠ¨æ€æƒé™ç”³è¯·æ˜¯ä»€ä¹ˆ è¯¦è§ AndroidåŠ¨æ€æƒé™ç”³è¯·ä»æœªå¦‚æ­¤ç®€å• è¿™ç¯‡æ–‡ç«  ä½ åšçš„æ€§èƒ½ç›‘æµ‹å·¥å…·ï¼ŒFPSæ˜¯æ€ä¹ˆé‡‡é›†çš„ æ€§èƒ½ç›‘æµ‹å·¥å…·ç”¨åœ¨äº†ä»€ä¹ˆåœºæ™¯ æœ‰æ²¡æœ‰é€šè¿‡è¿™ä¸ªæ€§èƒ½ç›‘æµ‹å·¥å…·å»åšä¸€äº›ä¼˜åŒ– å›¾ç‰‡åº“ï¼Œä¾‹å¦‚Glideï¼Œä¸€èˆ¬å¯¹Bitmapæœ‰å“ªäº›ä¼˜åŒ–ç‚¹ è¿‡æœŸçš„Bitmapå¯ä»¥å¤ç”¨å— æœ‰æ²¡æœ‰åŸºäºASMæ’æ¡©åšè¿‡ä¸€äº›æ’ä»¶ è®²äº†ä¸€ä¸‹å½“æ—¶åšè¿‡çš„ä¸€ä¸ªä¸ªäººé¡¹ç›® FastInflate è¿™ä¸ªé¡¹ç›®æ²¡èƒ½è¾¾åˆ°æœ€ç»ˆçš„ç›®æ ‡ï¼Œä½†é€šè¿‡åšè¿™ä¸ªé¡¹ç›®å­¦ä¹ äº†å¾ˆå¤šæ–°çŸ¥è¯†ï¼Œæ¯”å¦‚APTä»£ç ç”Ÿæˆã€é˜…è¯»äº†LayoutInflateræºç ã€AppCompatDelegateImplå®ç°çš„LayoutInflater.Factory2ä¼šæå¤§çš„æ‹–æ…¢å¸ƒå±€åˆ›å»ºçš„é€Ÿåº¦ç­‰ æ€ä¹ˆä¼˜åŒ–å¸ƒå±€åˆ›å»ºé€Ÿåº¦ æç¤ºäº†é¢„åŠ è½½ï¼Œä½†æˆ‘å½“æ—¶è„‘æŠ½åœ¨çº ç»“xmlçš„ç¼“å­˜ï¼Œæ²¡æƒ³åˆ°å¯ä»¥æå‰æŠŠè§†å›¾å…ˆåˆ›å»ºå¥½ è¯´ä¸€ä¸‹ä½ è§‰å¾—ä½ æœ€æ“…é•¿æˆ–è€…äº†è§£æœ€é€çš„ç‚¹ æˆ‘å›ç­”çš„è‡ªå®šä¹‰View è§£å†³è¿‡Viewçš„æ»‘åŠ¨å†²çªå— è®²è§£äº†ä¸€ä¸ªä¹‹å‰å†™è¿‡çš„å¼€æºæ§ä»¶ SwipeLoadingLayout ä¸€èˆ¬é‡åˆ°å›°éš¾çš„è§£å†³æ–¹æ¡ˆæ˜¯ä»€ä¹ˆ ç®—æ³•é¢˜ï¼šåè½¬é“¾è¡¨ åé—®é˜¶æ®µ å’±ä»¬ç»„ä¸»è¦è´Ÿè´£å“ªäº›å†…å®¹ ä¸»è¦ä½¿ç”¨Javaè¿˜æ˜¯Kotlin Kotlin å°çº¢ä¹¦çš„é¢è¯•ä¸€èˆ¬æ˜¯æ€ä¹ˆä¸ªæµç¨‹ï¼Ÿå¤šå°‘è½®ï¼Ÿ ä¸€èˆ¬ä¸‰è½®æŠ€æœ¯é¢ï¼Œä¸€è½®HRé¢ é¢è¯•å®Œä¸€èˆ¬å¤šä¹…ä¼šç»™åˆ°ç»“æœ æ¯”è¾ƒå¿«ï¼Œä¸€ä¸¤å¤©çš„æ ·å­ äºŒé¢ è‡ªæˆ‘ä»‹ç» ä¸ºä»€ä¹ˆè¿™ä¸ªæ—¶é—´èŠ‚ç‚¹æƒ³è¦å‡ºæ¥æ¢å·¥ä½œå‘¢ åœ¨Bç«™è¿™äº›å¹´åšäº†ä»€ä¹ˆ åšäº†å“ªäº›åŸºç¡€ç»„ä»¶ è®²è§£äº†ä¸€ä¸‹ä¹‹å‰å†™çš„ SwipeLoadingLayout ä»‹ç»ä¸€ä¸‹Androidçš„äº‹ä»¶ä¼ é€’æœºåˆ¶ ä½ å†™çš„è¿™ä¸ªåˆ†äº«æ¨¡å—æ˜¯å¦‚ä½•è®¾è®¡çš„ å¯¹å¤–é‡‡ç”¨æµå¼è°ƒç”¨çš„å½¢å¼ï¼Œå†…éƒ¨é€šè¿‡ç­–ç•¥æ¨¡å¼åŒºåˆ†ä¸åŒçš„å¹³å°ä»¥åŠåˆ†äº«ç±»å‹ï¼Œç»™æ¯ä¸ªå¹³å°åˆ›å»ºäº†ä¸€ä¸ªä¸­é—´Activityä½œä¸ºåˆ†äº«SDKè¯·æ±‚çš„å‘èµ·æ–¹ï¼ˆSDK.getApi().share()ï¼‰ä»¥åŠåˆ†äº«ç»“æœçš„æ¥æ”¶æ–¹ï¼ˆonActivityResultï¼‰ï¼Œç„¶åé€šè¿‡å¹¿æ’­å°†åˆ†äº«çš„ç»“æœé€å…¥åˆ°åˆ†äº«æ¨¡å—å†…è¿›è¡Œå¤„ç†ï¼Œæœ€ç»ˆè°ƒç”¨ç”¨æˆ·è®¾ç½®çš„åˆ†äº«å›è°ƒå‘ŠçŸ¥ç»“æœ çœ‹ä½ ä¹‹å‰åœ¨æ‰‡è´çš„æ—¶å€™æœ‰å¼€å‘è¿‡ä¸€äº›æ€§èƒ½ç›‘æµ‹å·¥å…·ï¼Œé‚£æœ‰åšè¿‡æ€§èƒ½ä¼˜åŒ–å— ä½ æ˜¯å¦‚ä½•æ”¶é›†è¿™äº›æ€§èƒ½æ•°æ®çš„ æœ‰æ²¡æœ‰å¯¹å“ªæ–¹é¢åšè¿‡ä¸€äº›é’ˆå¯¹æ€§çš„ä¼˜åŒ– Androidç³»ç»Ÿä¸ºä»€ä¹ˆä¼šè§¦å‘ANRï¼Œå®ƒçš„æœºåˆ¶æ˜¯ä»€ä¹ˆ æœ‰è§£è¿‡ANRç›¸å…³çš„é—®é¢˜å—ï¼Ÿæœ‰å“ªå‡ ç§ç±»å‹ï¼Ÿ ç®—æ³•é¢˜ï¼šäºŒå‰æ ‘çš„å±‚åºéå† Queueé™¤äº†LinkedListè¿˜æœ‰å“ªäº›å®ç°ç±» ç°åœ¨è¿˜åœ¨é¢å…¶ä»–å…¬å¸å—ï¼Ÿä½ è‡ªå·±åé¢èŒä¸šç”Ÿæ¶¯çš„é€‰æ‹©æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ ç»™æˆ‘ä»‹ç»äº†ä¸€ä¸‹å›¢é˜Ÿï¼Œè¯´æˆ‘é¢è¯•çš„è¿™ä¸ªéƒ¨é—¨åº”è¯¥è¯´æ˜¯å°çº¢ä¹¦æœ€æ ¸å¿ƒçš„å›¢é˜Ÿï¼ŒåŒ…æ‹¬ä¸»é¡µã€æœç´¢ã€å›¾æ–‡ã€è§†é¢‘ç­‰ç­‰éƒ½åœ¨éƒ¨é—¨ä¸šåŠ¡èŒƒç•´å†…ï¼Œéƒ¨é—¨ä¸»è¦åˆ†ä¸‰å±‚ï¼Œé™¤äº†ä¸šåŠ¡å±‚ä¹‹å¤–è¿˜æœ‰åŸºç¡€æ¶æ„å±‚ä»¥åŠæ€§èƒ½ä¼˜åŒ–å±‚ åé—®é˜¶æ®µ éƒ¨é—¨åˆ†ä¸‰å±‚çš„è¯ï¼Œé‚£æ–°äººè¿›æ¥çš„è¯æ˜¯éœ€è¦ä»ä¸šåŠ¡å±‚åšèµ·å—ï¼Ÿ ä¸æ˜¯è¿™æ ·çš„ï¼Œæˆ‘ä»¬é¦–å…ˆä¼šè€ƒè™‘è¿™ä¸ªåŒå­¦èƒ½å¹²ä»€ä¹ˆï¼Œç„¶åä¼šè€ƒè™‘è¿™ä¸ªåŒå­¦æ„¿æ„å»åšä»€ä¹ˆï¼Œè¿›æ¥åï¼Œæœ‰ç»éªŒçš„åŒå­¦ä¹Ÿä¼šæ¥å¸¦ä½ çš„ï¼Œä¸ä¼šä¸€ä¸Šæ¥å°±è®©ä½ æŠ—è¾“å‡ºï¼Œæ€»ä¹‹ä¼šæŠŠäººæ”¾åˆ°é€‚åˆä»–çš„å›¢é˜Ÿé‡Œ å°çº¢ä¹¦ä¼šä½¿ç”¨åˆ°ä¸€äº›è·¨ç«¯æŠ€æœ¯å—ï¼Ÿ ä¼šï¼Œä¹‹å‰åœ¨ä¸€äº›æ–°çš„Appä¸Šä½¿ç”¨çš„Flutterï¼Œç°åœ¨ä¸»è¦ç”¨çš„æ˜¯RNï¼Œè¿˜ä¼šä½¿ç”¨åˆ°ä¸€äº›DSLï¼Œè¿™ä¸ªä¸èƒ½ç®—è·¨æ®µã€‚ä¸ºä»€ä¹ˆåœ¨å°çº¢ä¹¦ç¤¾åŒºAppä¸­è·¨ç«¯æŠ€æœ¯æåŠçš„æ¯”è¾ƒå°‘ï¼Œæ˜¯å› ä¸ºå°çº¢ä¹¦Appéå¸¸é‡è§†ç”¨æˆ·ä½“éªŒï¼Œå¯¹æ€§èƒ½çš„è¦æ±‚æ¯”è¾ƒé«˜ ä¸‰é¢ è‡ªæˆ‘ä»‹ç» ä»‹ç»ä¸€ä¸‹ç›®å‰è´Ÿè´£çš„ä¸šåŠ¡ å·¥ä½œè¿‡ç¨‹ä¸­æœ‰ç¢°åˆ°è¿‡ä»€ä¹ˆéš¾é¢˜ï¼Œæœ€åæ˜¯æ€ä¹ˆè§£å†³çš„ ä¸€å¼€å§‹è„‘æŠ½äº†æ²¡æƒ³åˆ°è¯¥è¯´ä»€ä¹ˆï¼Œéšä¾¿æ‰¯äº†ä¸€ä¸ªæ²¡å•¥æŠ€æœ¯å«é‡çš„ä¸œè¥¿ï¼Œåˆæ‰¯äº†ä¸€ä¸ªä¹‹å‰åšçš„ä¿¡å·æ•è·çš„å·¥å…·ï¼Œåæ¥å›å¿†èµ·æ¥äº†ï¼Œé‡æ–°è¯´äº†ä¸€ä¸ªå…³äºDEXç¼–æ’çš„ä¸œè¥¿ï¼ˆä¸»DEXä¸­æ–¹æ³•æ•°è¶…è¿‡65535å¯¼è‡´æ‰“åŒ…å¤±è´¥ï¼Œå†™äº†ä¸ªè„šæœ¬å°†ä¸€éƒ¨åˆ†Classä»ä¸»DEXä¸­ç§»é™¤åˆ°å…¶ä»–DEXä¸­ï¼‰ å¦‚ä½•è®¾è®¡ä¸€ä¸ªå¤´åƒçš„è‡ªå®šä¹‰Viewï¼Œè¦æ±‚ä½¿å¤´åƒå±•ç¤ºå‡ºæ¥æ˜¯ä¸€ä¸ªåœ†å½¢ ä»‹ç»ä¸€ä¸‹Androidäº‹ä»¶çš„åˆ†å‘æµç¨‹ å¦‚ä½•å¤„ç†Viewçš„é˜²è¯¯è§¦ æ€ä¹ˆå¤„ç†æ»‘åŠ¨å†²çª Activityåœ¨onCreateæ–¹æ³•ä¸­è°ƒç”¨äº†finishæ–¹æ³•ï¼Œé‚£å®ƒçš„ç”Ÿå‘½å‘¨æœŸä¼šæ˜¯æ€æ ·çš„ å¦‚æœæˆ‘æƒ³åˆ¤æ–­ä¸€ä¸ªActivityä¸­çš„ä¸€ä¸ªViewçš„å°ºå¯¸ï¼Œé‚£æˆ‘ä»€ä¹ˆæ—¶å€™èƒ½å¤Ÿæ‹¿åˆ° RecyclerViewå¦‚ä½•å®ç°ä¸€ä¸ªå¸é¡¶æ•ˆæœ Javaå’ŒKoltinä½ å“ªä¸ªç”¨çš„æ¯”è¾ƒå¤š æœ‰ç”¨è¿‡Kotlinçš„åç¨‹å— Kotlinä¸­çš„å“ªäº›Featureä½ ç”¨çš„å¤šï¼Œè§‰å¾—å†™çš„å¥½å‘¢ ä½ æ˜¯æ€ä¹ˆç†è§£MVVMçš„ ä½ æœ‰ç”¨è¿‡Jetpack Composeå— æœ‰ç”¨è¿‡kotlinä¸­çš„by lazyå’Œlateinitå— kotlinä¸­æ€ä¹ˆå®ç°å•ä¾‹ï¼Œæ€ä¹ˆå®šä¹‰ä¸€ä¸ªç±»çš„é™æ€å˜é‡ ç®—æ³•é¢˜ï¼šå¢é‡å…ƒç´ ä¹‹é—´çš„æœ€å¤§å·®å€¼ ä½ è¿™æ¬¡çœ‹æœºä¼šçš„åŸå› æ˜¯ä»€ä¹ˆ åé—®é˜¶æ®µæˆ‘æ„Ÿè§‰ä¹‹å‰é—®çš„å·®ä¸å¤šäº†ï¼Œè¿™æ¬¡å°±æ²¡å†é—®ä»€ä¹ˆé—®é¢˜äº† HRé¢ ç°åœ¨æ˜¯ç¦»èŒè¿˜æ˜¯åœ¨èŒçŠ¶æ€ ä»‹ç»ä¸€ä¸‹ä¹‹å‰è´Ÿè´£çš„å·¥ä½œ ç”¨æˆ·é‡æ€ä¹ˆæ · è¿™ä¸ªé¡¹ç›®æ˜¯ä»0åˆ°1å¼€å‘çš„å— è¿™ä¸ªä¸šåŠ¡æœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼Œå¯¹äºå®¢æˆ·ç«¯å¼€å‘æœ‰ä»€ä¹ˆæŒ‘æˆ˜ä¸å›°éš¾ å›¢é˜Ÿåˆ†å·¥æ˜¯æ€æ ·çš„ è¿™ä¸ªé¡¹ç›®èƒ½åšæˆç°åœ¨è¿™ä¸ªæ ·å­ï¼Œä½ è‡ªå·±çš„æ ¸å¿ƒè´¡çŒ®æœ‰å“ªäº› è¿™ä¸ªäº‹æƒ…å¯¹ä½ æ¥è¯´æœ‰ä»€ä¹ˆæ”¶è·å— åœ¨Bç«™çš„å·¥ä½œèŠ‚å¥æ˜¯æ€ä¹ˆæ ·çš„ ç¦»èŒçš„åŸå› æ˜¯ä»€ä¹ˆå‘¢ ä½ è‡ªå·±å¸Œæœ›æ‰¾ä¸€ä¸ªä»€ä¹ˆæ ·çš„ç¯å¢ƒæˆ–è€…ä»€ä¹ˆé˜¶æ®µçš„ä¸šåŠ¡ ä½ å¯¹å°çº¢ä¹¦æœ‰ä»€ä¹ˆäº†è§£å— æœªæ¥ä¸¤ä¸‰å¹´å¯¹äºèŒä¸šå‘å±•çš„æƒ³æ³• ä½ è§‰å¾—ç°åœ¨æœ‰ä»€ä¹ˆé™åˆ¶äº†ä½ æˆ–è€…ä½ è§‰å¾—ä½ éœ€è¦æå‡å“ªäº›éƒ¨åˆ† åé—®é˜¶æ®µ é—®äº†ä¸€äº›ä½œæ¯ã€ç¦åˆ©å¾…é‡ä¹‹ç±»çš„é—®é¢˜ æ€»ç»“å°çº¢ä¹¦é¢è¯•æ€»ä½“è€Œè¨€ç»™æˆ‘çš„ä½“éªŒæ˜¯å¾ˆå¥½çš„ï¼Œæ¯è½®é¢è¯•ååŸºæœ¬ä¸Šéƒ½æ˜¯å½“å¤©å°±èƒ½å‡ºç»“æœï¼Œç„¶åçº¦ä¸‹ä¸€è½®çš„é¢è¯•ã€‚æœ€ç»ˆä»ä¸€é¢åˆ°HRé¢ç»“æŸå‡ºç»“æœï¼Œä¸€å…±èŠ±äº†9å¤©æ—¶é—´ï¼Œè¿˜æ˜¯æŒºå¿«çš„ã€‚äºŒé¢ç»“æŸåï¼Œä¸€é¢çš„é¢è¯•å®˜åŠ æˆ‘å¾®ä¿¡è¯´å°çº¢ä¹¦ç›®å‰å¾ˆç¼ºäººï¼Œæ„Ÿå…´è¶£çš„åŒå­¦ä¹Ÿå¯ä»¥æ¥è¯•è¯•ã€‚","categories":[{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"é¢è¯•","slug":"Android/é¢è¯•","permalink":"http://yoursite.com/categories/Android/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Androidæºç åˆ†æ - Serviceçš„åœæ­¢ä¸é‡å»º","slug":"android/aosp/Androidæºç åˆ†æ-Serviceçš„åœæ­¢ä¸é‡å»º","date":"2023-09-14T03:32:56.000Z","updated":"2023-10-25T04:46:27.806Z","comments":true,"path":"2023/09/14/android/aosp/Androidæºç åˆ†æ-Serviceçš„åœæ­¢ä¸é‡å»º/","link":"","permalink":"http://yoursite.com/2023/09/14/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E7%9A%84%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%BB%BA/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ åœ¨ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Serviceå¯åŠ¨æµç¨‹ ä¸­ï¼Œæˆ‘ä»¬åˆ†æäº†ä¸€ä¸ªServiceæ˜¯æ€ä¹ˆå¯åŠ¨çš„ï¼Œè¿™æ¬¡æˆ‘ä»¬å†æ¥çœ‹çœ‹ä¸€ä¸ªServiceæ˜¯å¦‚ä½•è¢«åœæ­¢çš„ï¼Œä»€ä¹ˆæƒ…å†µä¸‹Serviceä¼šè¢«é‡å»ºä»¥åŠå®ƒçš„é‡å»ºè¿‡ç¨‹ æµç¨‹å›¾ç”±äºServiceçš„åœæ­¢ä¸é‡å»ºåœ¨å®é™…æƒ…å†µä¸‹ä¼šæ”¶åˆ°å„ç§æ¡ä»¶å½±å“äº§ç”Ÿä¸åŒçš„æƒ…å†µï¼Œæ‰€ä»¥è¿™é‡Œçš„æµç¨‹å›¾æˆ‘ä¹Ÿåªç”»æœ€ç®€è·¯å¾„ï¼Œä»¥ä¾›å¤§å®¶å‚è€ƒ ä¸»åŠ¨åœæ­¢é¦–å…ˆï¼Œæˆ‘ä»¬æ¥çœ‹ä¸»åŠ¨åœæ­¢çš„æƒ…å†µï¼Œä¸»åŠ¨åœæ­¢ä¹Ÿåˆ†ä¸‰ç§ï¼š Serviceè‡ªå·±è°ƒç”¨stopSelfæˆ–stopSelfResultæ–¹æ³•åœæ­¢ ä½¿ç”¨startServiceå¯åŠ¨çš„Serviceï¼Œä½¿ç”¨stopServiceæ–¹æ³•åœæ­¢ ä½¿ç”¨bindServiceå¯åŠ¨çš„Serviceï¼Œä½¿ç”¨unbindServiceæ–¹æ³•è§£é™¤ç»‘å®šï¼Œå½“æ²¡æœ‰ä»»ä½•Clientå’ŒServiceç»‘å®šæ—¶ï¼ŒServiceå°±ä¼šè‡ªè¡Œåœæ­¢ Service.stopSelf æˆ– Service.stopSelfResultstopSelfå’ŒstopSelfResultæ–¹æ³•å”¯ä¸€çš„åŒºåˆ«æ˜¯ä¸€ä¸ªæ²¡è¿”å›å€¼ï¼Œä¸€ä¸ªä¼šè¿”å›æ˜¯å¦æˆåŠŸ 123456789101112131415161718192021222324252627//frameworks/base/core/java/android/app/Service.javapublic final void stopSelf() &#123; stopSelf(-1);&#125;public final void stopSelf(int startId) &#123; if (mActivityManager == null) &#123; return; &#125; try &#123; mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125;&#125;public final boolean stopSelfResult(int startId) &#123; if (mActivityManager == null) &#123; return false; &#125; try &#123; return mActivityManager.stopServiceToken( new ComponentName(this, mClassName), mToken, startId); &#125; catch (RemoteException ex) &#123; &#125; return false;&#125; è¿™ä¸ªæ–¹æ³•ä¹Ÿæ˜¯ç›´æ¥è°ƒç”¨äº†AMS.stopServiceTokenæ–¹æ³• 1234567//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic boolean stopServiceToken(ComponentName className, IBinder token, int startId) &#123; synchronized(this) &#123; return mServices.stopServiceTokenLocked(className, token, startId); &#125;&#125; ç„¶åAMSè½¬æ‰‹è°ƒç”¨äº†ActiveServices.stopServiceTokenLockedæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaboolean stopServiceTokenLocked(ComponentName className, IBinder token, int startId) &#123; //é€šè¿‡classNameæŸ¥æ‰¾ç›¸åº”çš„ServiceRecord //åœ¨Serviceå¯åŠ¨è¿‡ç¨‹ä¸­è°ƒç”¨çš„retrieveServiceLockedæ–¹æ³•ä¼šæŸ¥æ‰¾Serviceï¼Œåˆ›å»ºServiceRecord //å¹¶å°†å…¶æ·»åŠ åˆ°Mapä¸­ï¼ŒfindServiceLockedæ–¹æ³•åªéœ€è¦ä»è¿™ä¸ªMapä¸­å»è·å–å³å¯ ServiceRecord r = findServiceLocked(className, token, UserHandle.getCallingUserId()); if (r != null) &#123; if (startId &gt;= 0) &#123; // Asked to only stop if done with all work. Note that // to avoid leaks, we will take this as dropping all // start items up to and including this one. //æŸ¥æ‰¾startIdæ‰€å¯¹åº”çš„å·²åˆ†å‘çš„å¯åŠ¨é¡¹ ServiceRecord.StartItem si = r.findDeliveredStart(startId, false, false); //ä»å·²åˆ†å‘å¯åŠ¨è¯·æ±‚åˆ—è¡¨ä¸­ç§»é™¤ if (si != null) &#123; while (r.deliveredStarts.size() &gt; 0) &#123; ServiceRecord.StartItem cur = r.deliveredStarts.remove(0); cur.removeUriPermissionsLocked(); if (cur == si) &#123; break; &#125; &#125; &#125; //å¦‚æœä¼ å…¥çš„å¯åŠ¨IDä¸æ˜¯Serviceæœ€åä¸€æ¬¡å¯åŠ¨çš„IDï¼Œåˆ™ä¸èƒ½åœæ­¢æœåŠ¡ //psï¼šæ¯æ¬¡å¯åŠ¨Serviceï¼ŒstartIdéƒ½ä¼šé€’å¢ï¼Œåˆå§‹å€¼ä¸º1 if (r.getLastStartId() != startId) &#123; return false; &#125; &#125; ... //è®°å½• //é‡ç½®å¯åŠ¨çŠ¶æ€ï¼ˆé‡è¦ï¼Œåæ–‡ä¸­ä¼šåˆ†æï¼‰ r.startRequested = false; r.callStart = false; final long origId = Binder.clearCallingIdentity(); //æ¥ç€åœæ­¢Service bringDownServiceIfNeededLocked(r, false, false); Binder.restoreCallingIdentity(origId); return true; &#125; return false;&#125; startIdæœºåˆ¶è¿™é‡Œè¦è¯´ä¸€ä¸‹Serviceçš„startIdæœºåˆ¶ï¼Œæ¯æ¬¡å¯åŠ¨Serviceæ—¶ï¼ŒActiveServices.startServiceLockedæ–¹æ³•ä¼šå‘ServiceRecord.pendingStartsåˆ—è¡¨ä¸­æ·»åŠ ä¸€ä¸ªå¯åŠ¨é¡¹ServiceRecord.StartItemï¼Œæ„å»ºè¿™ä¸ªå¯åŠ¨é¡¹éœ€è¦æä¾›ä¸€ä¸ªstartIdï¼Œè€Œè¿™ä¸ªstartIdæ˜¯ç”±ServiceRecord.makeNextStartIdç”Ÿæˆçš„ 12345678//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.javapublic int makeNextStartId() &#123; lastStartId++; if (lastStartId &lt; 1) &#123; lastStartId = 1; &#125; return lastStartId;&#125; ç”±äºlastStartIdçš„åˆå§‹å€¼ä¸º 0 ï¼Œæ‰€ä»¥ç¬¬ä¸€æ¬¡è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œå¾—åˆ°çš„startIdå°±æ˜¯ 1 ï¼Œå³startIdæ˜¯ä» 1 å¼€å§‹é€’å¢çš„ï¼Œç”±äºå½“Serviceè¢«åœæ­¢åï¼ŒServiceRecordä¼šä»ä¹‹å‰çš„ç¼“å­˜Mapä¸­ç§»é™¤ï¼Œæ‰€ä»¥ä¸‹ä¸€æ¬¡å†å¯åŠ¨Serviceæ—¶ä¼šé‡æ–°åˆ›å»ºServiceRecordï¼ŒstartIdä¼šè¢«é‡ç½® å½“æˆ‘ä»¬è°ƒç”¨stopSelfåœæ­¢æœåŠ¡æ—¶ï¼Œå¦‚æœä¼ å…¥äº†å¤§äºç­‰äº 0 çš„startIdï¼Œæ­¤æ—¶ä¾¿ä¼šåˆ¤æ–­è¿™ä¸ªstartIdæ˜¯ä¸æ˜¯æœ€åä¸€æ¬¡å¯åŠ¨æ‰€å¯¹åº”çš„startIdï¼Œå¦‚æœä¸æ˜¯çš„è¯ï¼Œåˆ™ä¸èƒ½åœæ­¢è¿™ä¸ªService è¿™ä¸ªstartIdè®¾è®¡çš„æ„ä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬ä»IntentServiceçš„è®¾è®¡ä¸­å¯ä»¥ç®¡ä¸­çª¥è±¹ï¼š IntentServiceæ˜¯ä¸€ä¸ªè¿è¡Œåœ¨å¦ä¸€ä¸ªçº¿ç¨‹çš„ï¼Œæ¯æ¬¡å¤„ç†å®Œä»»åŠ¡éƒ½ä¼šè‡ªåŠ¨åœæ­¢çš„Serviceï¼Œä½†å¦‚æœä½ è°ƒç”¨å¤šæ¬¡startServiceä¼šå‘ç°ï¼ŒIntentService.onDestroyæ–¹æ³•åªä¼šè°ƒç”¨ä¸€æ¬¡ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºIntentServiceæ¯æ¬¡åœæ­¢ï¼Œè°ƒç”¨stopSelfæ–¹æ³•éƒ½æ˜¯å¸¦ä¸Šè¿™æ¬¡å¯åŠ¨çš„startIdçš„ï¼Œè¿™æ ·å¦‚æœä¸€æ¬¡æ€§æœ‰å¤šä¸ªå¯åŠ¨è¯·æ±‚ï¼Œå‰é¢çš„ä»»åŠ¡æ‰§è¡Œå®Œï¼Œåœæ­¢æ—¶å‘ç°ï¼Œæ­¤æ¬¡å¯åŠ¨è¯·æ±‚çš„startIdä¸æ˜¯æœ€åä¸€ä¸ªstartIdï¼Œè¿™æ ·å°±ä¸ä¼šåœæ­¢æ‰è‡ªèº«ï¼Œç›´åˆ°æœ€åä¸€ä¸ªä»»åŠ¡å¤„ç†å®Œæˆï¼Œé¿å…äº†Serviceçš„å¤šæ¬¡åœæ­¢å¯åŠ¨æ¶ˆè€—ç³»ç»Ÿèµ„æº æ¥ç€ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•çš„æœ€åï¼Œè°ƒç”¨bringDownServiceIfNeededLockedæ–¹æ³•ç»§ç»­åœæ­¢æœåŠ¡ 1234567891011121314151617181920//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; //æ£€æŸ¥æ­¤æœåŠ¡æ˜¯å¦è¿˜è¢«éœ€è¦ //åœ¨ç”¨stopSelfåœæ­¢æœåŠ¡çš„è¿™ç§æƒ…å†µä¸‹ //æ£€æŸ¥çš„å°±æ˜¯æ˜¯å¦æœ‰auto-createçš„è¿æ¥ï¼ˆflagä¸ºBIND_AUTO_CREATEï¼‰ //å¦‚æœ‰åˆ™ä¸èƒ½åœæ­¢æœåŠ¡ if (isServiceNeededLocked(r, knowConn, hasConn)) &#123; return; &#125; // Are we in the process of launching? //ä¸è¦åœæ­¢æ­£åœ¨å¯åŠ¨ä¸­çš„Service if (mPendingServices.contains(r)) &#123; return; &#125; //ç»§ç»­åœæ­¢æœåŠ¡ bringDownServiceLocked(r);&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦å°±åšäº†ä¸€äº›èƒ½å¦åœæ­¢æœåŠ¡çš„æ£€æŸ¥ï¼Œä¸»è¦çš„åœæ­¢æ“ä½œéƒ½åœ¨ä¸‹ä¸€ä¸ªbringDownServiceLockedæ–¹æ³•ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final void bringDownServiceLocked(ServiceRecord r) &#123; ... //å¤„ç†Clientä¸Serivceçš„è¿æ¥ï¼Œè¿›è¡Œæ–­å¼€è¿æ¥ä»¥åŠè§£é™¤ç»‘å®šæ“ä½œ // Check to see if the service had been started as foreground, but being // brought down before actually showing a notification. That is not allowed. //å¦‚æœæ­¤Serviceæ˜¯ä»¥å‰å°æœåŠ¡çš„å½¢å¼å¯åŠ¨ï¼Œå¹¶ä¸”å½“å‰è¿˜å°šæœªæˆä¸ºå‰å°æœåŠ¡ if (r.fgRequired) &#123; r.fgRequired = false; r.fgWaiting = false; ... //è®°å½• //å°†å‰å°æœåŠ¡çš„è¶…æ—¶å›è°ƒå–æ¶ˆ mAm.mHandler.removeMessages( ActivityManagerService.SERVICE_FOREGROUND_TIMEOUT_MSG, r); //è¿™ç§æƒ…å†µç›´æ¥ä»¤Appå´©æºƒï¼Œæ€æ­»åº”ç”¨ if (r.app != null) &#123; Message msg = mAm.mHandler.obtainMessage( ActivityManagerService.SERVICE_FOREGROUND_CRASH_MSG); msg.obj = r.app; msg.getData().putCharSequence( ActivityManagerService.SERVICE_RECORD_KEY, r.toString()); mAm.mHandler.sendMessage(msg); &#125; &#125; //è®°å½•é”€æ¯æ—¶é—´ r.destroyTime = SystemClock.uptimeMillis(); //ä»ç¼“å­˜ä¸­ç§»é™¤ServiceRecord final ServiceMap smap = getServiceMapLocked(r.userId); ServiceRecord found = smap.mServicesByInstanceName.remove(r.instanceName); // Note when this method is called by bringUpServiceLocked(), the service is not found // in mServicesByInstanceName and found will be null. if (found != null &amp;&amp; found != r) &#123; // This is not actually the service we think is running... this should not happen, // but if it does, fail hard. //å¦‚æœæ‰¾åˆ°çš„æœåŠ¡ä¸æ˜¯æˆ‘ä»¬ç›®å‰åœæ­¢çš„æœåŠ¡ï¼Œåº”è¯¥æ˜¯ä¸€ä¸ªä¸å¯èƒ½çš„æƒ…å†µ //ç¢°åˆ°è¿™ç§æƒ…å†µï¼Œå°†ServiceRecordé‡æ–°æ”¾å›å»å¹¶æŠ›å‡ºå¼‚å¸¸ smap.mServicesByInstanceName.put(r.instanceName, found); throw new IllegalStateException(\"Bringing down \" + r + \" but actually running \" + found); &#125; //æ¸…é™¤ServiceRecord smap.mServicesByIntent.remove(r.intent); r.totalRestartCount = 0; //å–æ¶ˆä¹‹å‰çš„Serviceé‡å¯ä»»åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰ unscheduleServiceRestartLocked(r, 0, true); // Also make sure it is not on the pending list. //ä»å¾…å¯åŠ¨Serviceåˆ—è¡¨ä¸­ç§»é™¤ for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; if (mPendingServices.get(i) == r) &#123; mPendingServices.remove(i); &#125; &#125; //å…³é—­å‰å°æœåŠ¡é€šçŸ¥ cancelForegroundNotificationLocked(r); //å¯¹äºå·²ç»æˆä¸ºå‰å°æœåŠ¡çš„Service if (r.isForeground) &#123; //ä¿®æ”¹åº”ç”¨çš„æ´»åŠ¨å‰å°è®¡æ•°ï¼Œå¦‚æœè®¡æ•°å°äºç­‰äº0ï¼Œå°†å…¶ä»mActiveForegroundAppsåˆ—è¡¨ä¸­ç§»é™¤ decActiveForegroundAppLocked(smap, r); ... //æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ &#125; //å„ç§æ¸…ç†æ“ä½œ r.isForeground = false; r.foregroundId = 0; r.foregroundNoti = null; r.mAllowWhileInUsePermissionInFgs = false; // Clear start entries. r.clearDeliveredStartsLocked(); r.pendingStarts.clear(); smap.mDelayedStartList.remove(r); if (r.app != null) &#123; synchronized (r.stats.getBatteryStats()) &#123; r.stats.stopLaunchedLocked(); &#125; //ä»ProcessRecordä¸­ç§»é™¤Serviceè®°å½• r.app.stopService(r); //æ›´æ–°æœåŠ¡è¿›ç¨‹ç»‘å®šçš„åº”ç”¨uids r.app.updateBoundClientUids(); //å…è®¸ç»‘å®šServiceçš„åº”ç”¨ç¨‹åºç®¡ç†ç™½åå• if (r.whitelistManager) &#123; updateWhitelistManagerLocked(r.app); &#125; if (r.app.thread != null) &#123; //æ›´æ–°è¿›ç¨‹å‰å°æœåŠ¡ä¿¡æ¯ updateServiceForegroundLocked(r.app, false); try &#123; //è®°å½•Serviceæ‰§è¡Œæ“ä½œå¹¶è®¾ç½®è¶…æ—¶å›è°ƒ //å‰å°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º20sï¼Œåå°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º200s bumpServiceExecutingLocked(r, false, \"destroy\"); //æ·»åŠ åˆ°é”€æ¯ä¸­Serviceåˆ—è¡¨ä¸­ mDestroyingServices.add(r); //æ ‡è®°æ­£åœ¨é”€æ¯ä¸­ r.destroying = true; //æ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ mAm.updateOomAdjLocked(r.app, true, OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE); //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦æ‰§è¡ŒServiceçš„stopæ“ä½œ r.app.thread.scheduleStopService(r); &#125; catch (Exception e) &#123; serviceProcessGoneLocked(r); &#125; &#125; &#125; //æ¸…é™¤è¿æ¥ if (r.bindings.size() &gt; 0) &#123; r.bindings.clear(); &#125; //å¯¹äºä¸»åŠ¨åœæ­¢çš„Serviceï¼Œä¸éœ€è¦é‡å¯ if (r.restarter instanceof ServiceRestarter) &#123; ((ServiceRestarter)r.restarter).setService(null); &#125; ... //è®°å½• //å°†æ­¤Serviceä»æ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨å’Œå»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ //å¦‚æœæ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­å­˜åœ¨æ­¤æœåŠ¡çš„è¯ï¼Œå°†ä¹‹å‰è®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨çš„æœåŠ¡è°ƒåº¦å‡ºæ¥åå°å¯åŠ¨ smap.ensureNotStartingBackgroundLocked(r);&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š å¤„ç†Clientä¸Serivceçš„è¿æ¥ï¼Œè¿›è¡Œæ–­å¼€è¿æ¥ä»¥åŠè§£é™¤ç»‘å®šæ“ä½œï¼ˆå…·ä½“ç­‰åˆ°åé¢åˆ†æunbindServiceæ—¶å†è¯´ï¼‰ å¯¹äºä»¥å‰å°æœåŠ¡å½¢å¼å¯åŠ¨ï¼Œå¹¶ä¸”å½“å‰è¿˜å°šæœªæˆä¸ºå‰å°æœåŠ¡çš„Serviceï¼Œç›´æ¥æ€æ­»App å„ç§é‡ç½®ï¼Œæ¸…ç†æ“ä½œ å…³é—­å‰å°æœåŠ¡é€šçŸ¥ å°†Serviceæ·»åŠ åˆ°é”€æ¯ä¸­æœåŠ¡åˆ—è¡¨ï¼Œå¹¶è°ƒåº¦æ‰§è¡Œåœæ­¢æ“ä½œï¼Œæœ€ç»ˆå›è°ƒService.onDestroy å°†ServiceRestarterå†…çš„ServiceRecordå˜é‡è®¾ä¸ºnullï¼Œé¿å…å…¶åç»­é‡å¯ æˆ‘ä»¬é‡ç‚¹çœ‹ç¬¬5æ­¥ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­è°ƒç”¨äº†ActivityThread$ApplicationThread.scheduleStopServiceå»è°ƒåº¦æ‰§è¡Œåœæ­¢æœåŠ¡æ“ä½œ 1234//frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleStopService(IBinder token) &#123; sendMessage(H.STOP_SERVICE, token);&#125; åŒæ ·çš„ï¼Œä¹Ÿæ˜¯é€šè¿‡Handlerå‘é€Messageå¤„ç†æœåŠ¡åœæ­¢ï¼Œè¿™é‡Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ActivityThread.handleStopServiceæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleStopService(IBinder token) &#123; //ä»Serviceåˆ—è¡¨ä¸­å–å‡ºå¹¶ç§»é™¤æ­¤æœåŠ¡ Service s = mServices.remove(token); if (s != null) &#123; try &#123; //è°ƒç”¨Service.onDestroy s.onDestroy(); //è§£ç»‘ä»¥åŠæ¸…ç†ï¼ˆè§£é™¤å¯¹ServiceRecordçš„Binderè¿œç¨‹å¯¹è±¡çš„å¼•ç”¨ï¼‰ s.detachAndCleanUp(); //æ‰§è¡Œæ¸…ç†æ“ä½œï¼Œå…·ä½“æ¥è¯´å°±æ˜¯æ–­å¼€å…¶ä»–å®¢æˆ·ç«¯ä¸Serviceçš„è¿æ¥ä»¥åŠè§£é™¤ç»‘å®š Context context = s.getBaseContext(); if (context instanceof ContextImpl) &#123; final String who = s.getClassName(); ((ContextImpl) context).scheduleFinalCleanup(who, \"Service\"); &#125; //ç¡®ä¿å…¶ä»–å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆ QueuedWork.waitToFinish(); try &#123; //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¸­ä¼šæŠŠä¹‹å‰çš„è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ ActivityManager.getService().serviceDoneExecuting( token, SERVICE_DONE_EXECUTING_STOP, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to stop service \" + s + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œé¦–å…ˆä»mServicesåˆ—è¡¨ä¸­å–å‡ºå¹¶ç§»é™¤æ­¤æœåŠ¡ï¼Œç„¶åè§¦å‘Service.onDestroyå›è°ƒï¼Œä¹‹åè¿˜éœ€è¦è°ƒç”¨ContextImpl.scheduleFinalCleanupæ–¹æ³•æ‰§è¡Œä¸€äº›æ¸…ç†å·¥ä½œï¼Œè¿™ä¸€éƒ¨åˆ†çš„åˆ†ææˆ‘ä»¬ç•™åˆ°åé¢unbindServiceç« èŠ‚é‡Œå†è®²ï¼Œè¿™æ ·ï¼Œæ•´ä¸ªServiceçš„åœæ­¢æµç¨‹å°±åˆ°æ­¤ç»“æŸäº† stopServiceæ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è°ƒç”¨æ–¹è°ƒç”¨stopServiceåœæ­¢æœåŠ¡çš„æƒ…å†µ 12345678910111213141516171819202122232425//frameworks/base/core/java/android/app/ContextImpl.javapublic boolean stopService(Intent service) &#123; warnIfCallingFromSystemProcess(); return stopServiceCommon(service, mUser);&#125;private boolean stopServiceCommon(Intent service, UserHandle user) &#123; try &#123; //éªŒè¯Intentæœ‰æ•ˆæ€§ validateServiceIntent(service); //è·¨è¿›ç¨‹å¤„ç† service.prepareToLeaveProcess(this); //è°ƒç”¨AMS.stopService int res = ActivityManager.getService().stopService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( \"Not allowed to stop service \" + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; è¿™é‡ŒåŸºæœ¬ä¸Šæ˜¯ç›´æ¥è°ƒç”¨AMS.stopServiceè¿›å…¥ç³»ç»Ÿè¿›ç¨‹å¤„ç†æœåŠ¡åœæ­¢ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; enforceNotIsolatedCaller(\"stopService\"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; //è½¬äº¤ç»™ActiveServiceså¤„ç† return mServices.stopServiceLocked(caller, service, resolvedType, userId); &#125;&#125;//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaint stopServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (caller != null &amp;&amp; callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when stopping service \" + service); &#125; // If this service is active, make sure it is stopped. //æŸ¥æ‰¾ç›¸åº”çš„Serviceï¼Œå…¶ä¸­å…¥å‚createIfNeededä¸ºfalseï¼Œæ‰€ä»¥å¦‚æœä»ç¼“å­˜ä¸­æ‰¾ä¸åˆ°ServiceRecordçš„è¯åˆ™ä¼šç›´æ¥è¿”å›null ServiceLookupResult r = retrieveServiceLocked(service, null, resolvedType, null, Binder.getCallingPid(), Binder.getCallingUid(), userId, false, false, false, false); if (r != null) &#123; if (r.record != null) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; //æ¥ç€å¤„ç†åœæ­¢æœåŠ¡ stopServiceLocked(r.record); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return 1; &#125; return -1; &#125; return 0;&#125;private void stopServiceLocked(ServiceRecord service) &#123; if (service.delayed) &#123; // If service isn't actually running, but is being held in the // delayed list, then we need to keep it started but note that it // should be stopped once no longer delayed. service.delayedStop = true; return; &#125; ... //ç»Ÿè®¡ä¿¡æ¯è®°å½• //é‡ç½®å¯åŠ¨çŠ¶æ€ï¼ˆé‡è¦ï¼Œåæ–‡ä¸­ä¼šåˆ†æï¼‰ service.startRequested = false; service.callStart = false; //å’Œä¸Šæ–‡ä¸€æ ·ï¼Œåœæ­¢Service bringDownServiceIfNeededLocked(service, false, false);&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå’Œä¸Šæ–‡ä¸­åˆ†æçš„ä»¥stopSelfæ–¹å¼åœæ­¢æœåŠ¡ä¸€æ ·ï¼Œå…ˆé‡ç½®å¯åŠ¨çŠ¶æ€ï¼Œç„¶åè°ƒç”¨bringDownServiceIfNeededLockedåœæ­¢æœåŠ¡ unbindServiceæ¥ä¸‹æ¥çš„æ˜¯é€šè¿‡bindServiceæ–¹æ³•ï¼Œå¹¶ä¸”flagä¸ºBIND_AUTO_CREATEå¯åŠ¨çš„Serviceï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡unbindServiceæ–¹æ³•è§£é™¤ç»‘å®šï¼Œå½“æœ€ç»ˆæ²¡æœ‰ä»»ä½•flagä¸ºBIND_AUTO_CREATEçš„å®¢æˆ·ç«¯ä¸Serviceç»‘å®šï¼Œè¿™ä¸ªServiceå°±ä¼šè¢«åœæ­¢ 12345678910111213141516171819//frameworks/base/core/java/android/app/ContextImpl.javapublic void unbindService(ServiceConnection conn) &#123; if (conn == null) &#123; throw new IllegalArgumentException(\"connection is null\"); &#125; if (mPackageInfo != null) &#123; //å°†ServiceDispatcherçš„çŠ¶æ€è®¾ç½®ä¸ºforgottenï¼Œä¹‹åä¾¿ä¸å†ä¼šå›è°ƒServiceConnectionä»»ä½•æ–¹æ³• IServiceConnection sd = mPackageInfo.forgetServiceDispatcher( getOuterContext(), conn); try &#123; //è°ƒç”¨AMS.unbindServiceæ–¹æ³• ActivityManager.getService().unbindService(sd); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¸­é¦–å…ˆè°ƒç”¨äº†LoadedApk.forgetServiceDispatcheræ–¹æ³• 12345678910111213141516171819202122232425//frameworks/base/core/java/android/app/LoadedApk.javapublic final IServiceConnection forgetServiceDispatcher(Context context, ServiceConnection c) &#123; synchronized (mServices) &#123; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); LoadedApk.ServiceDispatcher sd = null; if (map != null) &#123; sd = map.get(c); if (sd != null) &#123; //ç§»é™¤ServiceDispatcher map.remove(c); //æ¸…ç†è¿æ¥å¹¶æ ‡è®°é—å¿˜ sd.doForget(); if (map.size() == 0) &#123; mServices.remove(context); &#125; ... //debug return sd.getIServiceConnection(); &#125; &#125; ... //debug ... //å¼‚å¸¸ &#125;&#125; å°†ServiceDispatcherä»ç¼“å­˜ä¸­ç§»é™¤å¹¶è°ƒç”¨LoadedApk$ServiceDispatcher.doForgetæ–¹æ³• 1234567891011//frameworks/base/core/java/android/app/LoadedApk.javavoid doForget() &#123; synchronized(this) &#123; for (int i=0; i&lt;mActiveConnections.size(); i++) &#123; ServiceDispatcher.ConnectionInfo ci = mActiveConnections.valueAt(i); ci.binder.unlinkToDeath(ci.deathMonitor, 0); &#125; mActiveConnections.clear(); mForgotten = true; &#125;&#125; è¿™é‡Œå°†æ‰€æœ‰è¿æ¥çš„binderæ­»äº¡å›è°ƒç§»é™¤ï¼Œç„¶åæ¸…é™¤æ‰€æœ‰è¿æ¥ï¼Œå†å°†mForgottenæ ‡è®°è®¾ä¸ºtrue æ¥ç€æˆ‘ä»¬ä¼šèµ°åˆ°AMS.unbindServiceæ–¹æ³•ä¸­ 123456//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic boolean unbindService(IServiceConnection connection) &#123; synchronized (this) &#123; return mServices.unbindServiceLocked(connection); &#125;&#125; åŒæ ·çš„ï¼Œå°†å·¥ä½œè½¬äº¤ç»™ActiveServices 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaboolean unbindServiceLocked(IServiceConnection connection) &#123; IBinder binder = connection.asBinder(); ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder); //æ‰¾ä¸åˆ°è¿æ¥è®°å½•ï¼Œç›´æ¥è¿”å› if (clist == null) &#123; return false; &#125; final long origId = Binder.clearCallingIdentity(); try &#123; //éå†è¿æ¥ while (clist.size() &gt; 0) &#123; ConnectionRecord r = clist.get(0); //ç§»é™¤è¿æ¥ removeConnectionLocked(r, null, null); //removeConnectionLockedæ–¹æ³•ä¼šå°†æ­¤ConnectionRecordä»è¿æ¥åˆ—è¡¨ä¸­ç§»é™¤ //å¦‚æœæ­¤ConnectionRecordä»ç„¶å­˜åœ¨çš„è¯ï¼Œæ˜¯ä¸€ä¸ªä¸¥é‡çš„é”™è¯¯ï¼Œè¿™é‡Œå†ç§»é™¤ä¸€æ¬¡ if (clist.size() &gt; 0 &amp;&amp; clist.get(0) == r) &#123; // In case it didn't get removed above, do it now. Slog.wtf(TAG, \"Connection \" + r + \" not removed for binder \" + binder); clist.remove(0); &#125; if (r.binding.service.app != null) &#123; if (r.binding.service.app.whitelistManager) &#123; updateWhitelistManagerLocked(r.binding.service.app); &#125; // This could have made the service less important. if ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; r.binding.service.app.treatLikeActivity = true; mAm.updateLruProcessLocked(r.binding.service.app, r.binding.service.app.hasClientActivities() || r.binding.service.app.treatLikeActivity, null); &#125; &#125; &#125; //æ›´æ–°é¡¶å±‚åº”ç”¨è¿›ç¨‹ä¼˜å…ˆçº§ mAm.updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return true;&#125; æ²¡çœ‹åˆ°ä»€ä¹ˆç‰¹åˆ«é‡è¦çš„é€»è¾‘ï¼Œçœ‹æ¥é‡ç‚¹åº”è¯¥åœ¨removeConnectionLockedè¿™ä¸ªæ–¹æ³•ä¸­äº† 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javavoid removeConnectionLocked(ConnectionRecord c, ProcessRecord skipApp, ActivityServiceConnectionsHolder skipAct) &#123; IBinder binder = c.conn.asBinder(); AppBindRecord b = c.binding; ServiceRecord s = b.service; //è¿™é‡Œçš„clistæ˜¯ServiceRecordä¸­çš„åˆ—è¡¨ï¼Œå’Œä¸Šä¸€ä¸ªæ–¹æ³•ä¸­çš„clistä¸æ˜¯ä¸€ä¸ªå¯¹è±¡ ArrayList&lt;ConnectionRecord&gt; clist = s.getConnections().get(binder); //ç§»é™¤å„ç§è¿æ¥ if (clist != null) &#123; clist.remove(c); if (clist.size() == 0) &#123; s.removeConnection(binder); &#125; &#125; b.connections.remove(c); c.stopAssociation(); if (c.activity != null &amp;&amp; c.activity != skipAct) &#123; c.activity.removeConnection(c); &#125; if (b.client != skipApp) &#123; b.client.connections.remove(c); ... //å„ç§flagçš„å¤„ç† //æ›´æ–°æ˜¯å¦æœ‰ä¸Serviceå»ºç«‹è¿æ¥çš„Activity if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; &#125; //å°†è¿æ¥ä»mServiceConnectionsåˆ—è¡¨ä¸­ç§»é™¤ //è¿™ä¸ªclistæ‰æ˜¯å’Œä¸Šä¸€ä¸ªæ–¹æ³•æ˜¯åŒä¸€ä¸ªå¯¹è±¡ clist = mServiceConnections.get(binder); if (clist != null) &#123; clist.remove(c); if (clist.size() == 0) &#123; mServiceConnections.remove(binder); &#125; &#125; mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.appInfo.longVersionCode, s.instanceName, s.processName); //å¦‚æœè°ƒç”¨æ–¹Appæ²¡æœ‰å…¶ä»–è¿æ¥å’ŒServiceç»‘å®š //åˆ™å°†æ•´ä¸ªAppBindRecordç§»é™¤ if (b.connections.size() == 0) &#123; b.intent.apps.remove(b.client); &#125; if (!c.serviceDead) &#123; //å¦‚æœæœåŠ¡ç«¯è¿›ç¨‹å­˜æ´»å¹¶ä¸”æ²¡æœ‰å…¶ä»–è¿æ¥ç»‘å®šäº†ï¼ŒåŒæ—¶æœåŠ¡è¿˜å¤„åœ¨ç»‘å®šå…³ç³»ä¸­ï¼ˆå°šæœªå›è°ƒè¿‡Service.onUnbindï¼‰ if (s.app != null &amp;&amp; s.app.thread != null &amp;&amp; b.intent.apps.size() == 0 &amp;&amp; b.intent.hasBound) &#123; try &#123; bumpServiceExecutingLocked(s, false, \"unbind\"); if (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == 0 &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123; // If this service's process is not already in the cached list, // then update it in the LRU list here because this may be causing // it to go down there and we want it to start out near the top. mAm.updateLruProcessLocked(s.app, false, null); &#125; mAm.updateOomAdjLocked(s.app, true, OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE); //æ ‡è®°ä¸ºæœªç»‘å®š b.intent.hasBound = false; // Assume the client doesn't want to know about a rebind; // we will deal with that later if it asks for one. b.intent.doRebind = false; //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦æ‰§è¡ŒServiceçš„unbindæ“ä½œ s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent()); &#125; catch (Exception e) &#123; serviceProcessGoneLocked(s); &#125; &#125; // If unbound while waiting to start and there is no connection left in this service, // remove the pending service if (s.getConnections().isEmpty()) &#123; mPendingServices.remove(s); &#125; if ((c.flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; //æ˜¯å¦æœ‰å…¶ä»–å«æœ‰BIND_AUTO_CREATEæ ‡è®°çš„è¿æ¥ boolean hasAutoCreate = s.hasAutoCreateConnections(); ... //è®°å½• bringDownServiceIfNeededLocked(s, true, hasAutoCreate); &#125; &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š æ‰§è¡Œå„ç§ç§»é™¤æ“ä½œ å¦‚æœç›®æ ‡æœåŠ¡åœ¨æ­¤æ¬¡è§£ç»‘åä¸å†æœ‰ä»»ä½•å…¶ä»–è¿æ¥ä¸å…¶ç»‘å®šï¼Œåˆ™è°ƒåº¦æ‰§è¡ŒServiceçš„unbindæ“ä½œ å¦‚æœæ­¤æ¬¡æ–­å¼€çš„è¿æ¥çš„flagä¸­åŒ…å«BIND_AUTO_CREATEï¼Œåˆ™è°ƒç”¨bringDownServiceIfNeededLockedå°è¯•åœæ­¢æœåŠ¡ 2ã€3ä¸¤ç‚¹éƒ½å¾ˆé‡è¦ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ç¬¬2ç‚¹ï¼Œä»€ä¹ˆæƒ…å†µä¸‹ä¼šåœ¨è¿™é‡Œè°ƒåº¦æ‰§è¡ŒServiceçš„unbindæ“ä½œï¼Œå‰é¢æè¿°çš„å…¶å®ä¸æ˜¯å¾ˆå‡†ç¡®ï¼Œå‡†ç¡®çš„æ¥è¯´åº”è¯¥æ˜¯ç›®æ ‡æœåŠ¡åœ¨åŒä¸€ä¸ªIntentBindRecordä¸‹ï¼Œæ­¤æ¬¡è§£ç»‘åä¸å†æœ‰ä»»ä½•å…¶ä»–è¿æ¥ä¸å…¶ç»‘å®šã€‚é‚£ä¹ˆä»€ä¹ˆå«åŒä¸€ä¸ªIntentBindRecordå‘¢ï¼Ÿè¿™å’Œæˆ‘ä»¬å¯åŠ¨æœåŠ¡ä¼ å…¥çš„Intentæœ‰å…³ï¼ŒIntentBindRecordçš„ç¬¬ä¸€æ¬¡åˆ›å»ºæ˜¯åœ¨æˆ‘ä»¬è°ƒç”¨bindServiceåï¼Œèµ°åˆ°ActiveServices.bindServiceLockedæ–¹æ³•ä¸­ï¼Œå…¶ä¸­æœ‰ä¸€æ®µä»£ç è°ƒç”¨äº†ServiceRecord.retrieveAppBindingLockedæ–¹æ³•äº§ç”Ÿçš„ 1234567891011121314151617//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.javapublic AppBindRecord retrieveAppBindingLocked(Intent intent, ProcessRecord app) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord i = bindings.get(filter); if (i == null) &#123; i = new IntentBindRecord(this, filter); bindings.put(filter, i); &#125; AppBindRecord a = i.apps.get(app); if (a != null) &#123; return a; &#125; a = new AppBindRecord(this, i, app); i.apps.put(app, a); return a;&#125; åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œå®ƒå°†æˆ‘ä»¬ä¼ å…¥çš„IntentåŒ…è£…æˆäº†Intent.FilterComparisonå¯¹è±¡ï¼Œç„¶åå°è¯•ç”¨å®ƒä½œä¸ºkeyä»ArrayMap``bindingsä¸­å–è·å–IntentBindRecordï¼Œå¦‚æœè·å–ä¸åˆ°åˆ™ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ï¼Œé‚£ä¹ˆæ˜¯å¦æ˜¯åŒä¸€ä¸ªIntentBindRecordçš„åˆ¤æ–­æ ‡å‡†å°±æ˜¯åŒ…è£…åçš„Intent.FilterComparisonå¯¹è±¡çš„HashCodeæ˜¯å¦ç›¸ç­‰ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒçš„HashCodeæ˜¯æ€æ ·è®¡ç®—çš„ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041//frameworks/base/core/java/android/content/Intent.javapublic static final class FilterComparison &#123; private final Intent mIntent; private final int mHashCode; public FilterComparison(Intent intent) &#123; mIntent = intent; mHashCode = intent.filterHashCode(); &#125; ... @Override public int hashCode() &#123; return mHashCode; &#125;&#125;public int filterHashCode() &#123; int code = 0; if (mAction != null) &#123; code += mAction.hashCode(); &#125; if (mData != null) &#123; code += mData.hashCode(); &#125; if (mType != null) &#123; code += mType.hashCode(); &#125; if (mIdentifier != null) &#123; code += mIdentifier.hashCode(); &#125; if (mPackage != null) &#123; code += mPackage.hashCode(); &#125; if (mComponent != null) &#123; code += mComponent.hashCode(); &#125; if (mCategories != null) &#123; code += mCategories.hashCode(); &#125; return code;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåªæœ‰ä»¥ä¸Šå‚æ•°å…¨éƒ¨ç›¸ç­‰ï¼Œæ‰ä¼šè¢«è§†ä¸ºåŒä¸€ä¸ªIntentï¼Œè€Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨Intentåªä¼šè®¾ç½®å®ƒçš„mComponentï¼Œæ‰€ä»¥åœ¨ä¸€èˆ¬æƒ…å†µä¸‹Serviceçš„onBindå’ŒonUnbindä¹Ÿåªä¼šè§¦å‘ä¸€æ¬¡ï¼ˆåœ¨Serviceæ²¡æœ‰è¢«é”€æ¯çš„æƒ…å†µä¸‹ï¼‰ æ¥ç€æˆ‘ä»¬æ¥çœ‹ç¬¬3ç‚¹ï¼Œå¦‚æœæ­¤æ¬¡æ–­å¼€çš„è¿æ¥çš„flagä¸­åŒ…å«BIND_AUTO_CREATEï¼Œé¦–å…ˆä¼šå»æŸ¥è¯¢æ˜¯å¦æœ‰å…¶ä»–å«æœ‰BIND_AUTO_CREATEæ ‡è®°çš„è¿æ¥ï¼Œç„¶åä»¥æ­¤ä½œä¸ºå‚æ•°è°ƒç”¨bringDownServiceIfNeededLockedå°è¯•åœæ­¢æœåŠ¡ 12345678910111213141516171819202122232425262728293031323334353637383940//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final void bringDownServiceIfNeededLocked(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; //æ£€æŸ¥æ­¤æœåŠ¡æ˜¯å¦è¿˜è¢«éœ€è¦ if (isServiceNeededLocked(r, knowConn, hasConn)) &#123; return; &#125; // Are we in the process of launching? //ä¸è¦åœæ­¢æ­£åœ¨å¯åŠ¨ä¸­çš„Service if (mPendingServices.contains(r)) &#123; return; &#125; //ç»§ç»­åœæ­¢æœåŠ¡ bringDownServiceLocked(r);&#125;private final boolean isServiceNeededLocked(ServiceRecord r, boolean knowConn, boolean hasConn) &#123; // Are we still explicitly being asked to run? //Serviceä¹‹å‰æ˜¯å¦é€šè¿‡startServiceå¯åŠ¨è¿‡å¹¶ä¸”æœªstop if (r.startRequested) &#123; return true; &#125; // Is someone still bound to us keeping us running? //è¿™é‡Œæˆ‘ä»¬ä¼ å…¥çš„æ˜¯true //å› ä¸ºæˆ‘ä»¬ä¹‹å‰å·²ç»åšäº†æ£€æŸ¥ï¼ŒçŸ¥é“äº†æ˜¯å¦è¿˜æœ‰å…¶ä»–auto-createçš„è¿æ¥ if (!knowConn) &#123; hasConn = r.hasAutoCreateConnections(); &#125; //å¦‚æœè¿˜æœ‰å…¶ä»–auto-createçš„è¿æ¥ //åˆ™æ­¤æœåŠ¡è¿˜è¢«éœ€è¦ if (hasConn) &#123; return true; &#125; return false;&#125; å¯ä»¥çœ‹åˆ°ï¼Œç»è¿‡ä¸Šè¿°æ£€æŸ¥ï¼Œå¦‚æœå‘ç°æ­¤Serviceç¡®å®å¯ä»¥è¢«åœæ­¢äº†ï¼Œåˆ™ä¼šè°ƒç”¨bringDownServiceLockedæ–¹æ³•åœæ­¢æœåŠ¡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final void bringDownServiceLocked(ServiceRecord r) &#123; //æ–­å¼€æ‰€æœ‰è¿æ¥ ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections(); for (int conni = connections.size() - 1; conni &gt;= 0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; c = connections.valueAt(conni); for (int i=0; i&lt;c.size(); i++) &#123; ConnectionRecord cr = c.get(i); // There is still a connection to the service that is // being brought down. Mark it as dead. //å°†æœåŠ¡æ ‡è®°ä¸ºæ­»äº¡ cr.serviceDead = true; cr.stopAssociation(); //å›è°ƒServiceConnectionå„ç§æ–¹æ³• //é€šçŸ¥clientæœåŠ¡æ–­å¼€è¿æ¥ä»¥åŠæ­»äº¡ cr.conn.connected(r.name, null, true); &#125; &#125; // Tell the service that it has been unbound. //é€šçŸ¥Serviceè§£é™¤ç»‘å®š if (r.app != null &amp;&amp; r.app.thread != null) &#123; boolean needOomAdj = false; //éå†æ‰€æœ‰è¿æ¥ï¼Œè§£é™¤ç»‘å®š for (int i = r.bindings.size() - 1; i &gt;= 0; i--) &#123; IntentBindRecord ibr = r.bindings.valueAt(i); //å¦‚æœè¿˜å¤„åœ¨ç»‘å®šå…³ç³»ä¸­ï¼ˆå°šæœªå›è°ƒè¿‡Service.onUnbindï¼‰ if (ibr.hasBound) &#123; try &#123; //è®°å½•Serviceæ‰§è¡Œæ“ä½œå¹¶è®¾ç½®è¶…æ—¶å›è°ƒ //å‰å°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º20sï¼Œåå°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º200s bumpServiceExecutingLocked(r, false, \"bring down unbind\"); needOomAdj = true; //æ ‡è®°ä¸ºæœªç»‘å®š ibr.hasBound = false; ibr.requested = false; //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦æ‰§è¡ŒServiceçš„unbindæ“ä½œ r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent()); &#125; catch (Exception e) &#123; needOomAdj = false; serviceProcessGoneLocked(r); break; &#125; &#125; &#125; //æ›´æ–°æœåŠ¡ç«¯è¿›ç¨‹ä¼˜å…ˆçº§ if (needOomAdj) &#123; mAm.updateOomAdjLocked(r.app, true, OomAdjuster.OOM_ADJ_REASON_UNBIND_SERVICE); &#125; &#125; ... //å’Œä¸Šæ–‡ç›¸åŒ&#125; è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬åœ¨å‰é¢åˆ†æstopSelfçš„æ—¶å€™è¯´è¿‡äº†ï¼Œè¿™æ¬¡æˆ‘ä»¬åªçœ‹å’Œç»‘å®šæœåŠ¡æœ‰å…³çš„éƒ¨åˆ† é¦–å…ˆæ–­å¼€æ‰€æœ‰è¿æ¥ï¼Œå›è°ƒServiceConnectionå„ç§æ–¹æ³•ï¼Œé€šçŸ¥å®¢æˆ·ç«¯æœåŠ¡æ–­å¼€è¿æ¥ä»¥åŠæ­»äº¡ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬æœ¬æ¬¡æ‰§è¡ŒunbindServiceæ“ä½œçš„è¿æ¥å·²ç»åœ¨ä¸Šä¸€æ­¥ä¸­ä»ServiceRecord.connectionsåˆ—è¡¨ä¸­ç§»é™¤ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šå›è°ƒå®ƒçš„ServiceConnectionçš„ä»»ä½•æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯å¾ˆå¤šäººå¯¹unbindServiceæ–¹æ³•çš„è¯¯è§£ï¼ˆåŒ…æ‹¬æˆ‘è‡ªå·±ï¼‰ï¼ŒbindServiceæ–¹æ³•åœ¨æˆåŠŸç»‘å®šæœåŠ¡åä¼šå›è°ƒServiceConnection.onServiceConnectedæ–¹æ³•ï¼Œä½†unbindServiceæ–¹æ³•åœ¨æˆåŠŸè§£ç»‘æœåŠ¡åå¹¶ä¸ä¼šå›è°ƒServiceConnection.onServiceDisconnectedä»¥åŠä»»ä½•å…¶å®ƒæ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•åªä¼šåœ¨Serviceè¢«ä»¥å…¶ä»–æ–¹å¼åœæ­¢ï¼ˆæ¯”å¦‚åé¢ä¼šåˆ†æçš„æ··åˆå¯åŠ¨çš„æœåŠ¡å¦‚ä½•åœæ­¢ï¼‰æˆ–è€…Serviceæ„å¤–åœæ­¢ï¼ˆæ¯”å¦‚æœåŠ¡ç«¯åº”ç”¨å´©æºƒæˆ–è¢«æ€æ­»ï¼‰çš„æƒ…å†µæ‰ä¼šè¢«è°ƒç”¨ æ‰€ä»¥è¿™é‡Œå¤„ç†çš„æ˜¯æ–­å¼€å…¶ä»–çš„è¿æ¥ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªåœºæ™¯ï¼Œä½¿ç”¨åŒä¸€ä¸ªIntentå’Œä¸¤ä¸ªä¸åŒçš„ServiceConnectionï¼Œä¸€ä¸ªä½¿ç”¨BIND_AUTO_CREATEæ ‡è®°ï¼Œä¸€ä¸ªä½¿ç”¨å…¶ä»–æ ‡è®°ï¼Œå…ˆç»‘å®šBIND_AUTO_CREATEæ ‡è®°çš„Serviceï¼Œç„¶åå†ç»‘å®šå…¶ä»–æ ‡è®°çš„Serviceï¼Œæ¥ç€æˆ‘ä»¬å¯¹BIND_AUTO_CREATEæ ‡è®°çš„Serivceè°ƒç”¨unbindServiceè§£ç»‘ï¼Œæ­¤æ—¶å°±ä¼šèµ°åˆ°è¿™ä¸ªæ–¹æ³•ä¸­ï¼ŒServiceRecord.connectionsåˆ—è¡¨ä¸­ä¼šå­˜åœ¨é‚£ä¸ªä½¿ç”¨å…¶ä»–æ ‡è®°çš„è¿æ¥ï¼Œç„¶åå…¶å†…éƒ¨æˆå‘˜å˜é‡connçš„connectedæ–¹æ³•ï¼Œè¿™ä¸ªconnæ˜¯ä¸€ä¸ªIServiceConnectionç±»å‹ï¼Œå®é™…ä¸Šçš„å®ç°ç±»ä¸ºLoadedApk$ServiceDispatcher$InnerConnectionï¼Œæœ€ç»ˆä¼šè°ƒç”¨åˆ°LoadedApk$ServiceDispatcher.doConnectedæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void doConnected(ComponentName name, IBinder service, boolean dead) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; //è¢«æ ‡è®°ä¸ºé—å¿˜åˆ™ä¸å¤„ç†ä»»ä½•äº‹æƒ… //è°ƒç”¨unbindServiceå°±ä¼šå°†è¿™ä¸ªæ ‡å¿—è®¾ä¸ºtrue if (mForgotten) &#123; // We unbound before receiving the connection; ignore // any connection received. return; &#125; old = mActiveConnections.get(name); //å¦‚æœæ—§çš„è¿æ¥ä¿¡æ¯ä¸­çš„IBinderå¯¹è±¡å’Œæœ¬æ¬¡è°ƒç”¨ä¼ å…¥çš„IBinderå¯¹è±¡æ˜¯åŒä¸€ä¸ªå¯¹è±¡ if (old != null &amp;&amp; old.binder == service) &#123; // Huh, already have this one. Oh well! return; &#125; if (service != null) &#123; // A new service is being connected... set it all up. //å»ºç«‹ä¸€ä¸ªæ–°çš„è¿æ¥ä¿¡æ¯ info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); try &#123; //æ³¨å†ŒBinderæ­»äº¡é€šçŸ¥ service.linkToDeath(info.deathMonitor, 0); //ä¿å­˜æœ¬æ¬¡è¿æ¥ä¿¡æ¯ mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. //æœåŠ¡å·²æ­»äº¡ï¼Œç§»é™¤è¿æ¥ä¿¡æ¯ mActiveConnections.remove(name); return; &#125; &#125; else &#123; // The named service is being disconnected... clean up. mActiveConnections.remove(name); &#125; //ç§»é™¤Binderæ­»äº¡é€šçŸ¥ if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // If there was an old service, it is now disconnected. //å›è°ƒServiceConnection.onServiceDisconnected //é€šçŸ¥clientä¹‹å‰çš„è¿æ¥å·²è¢«æ–­å¼€ if (old != null) &#123; mConnection.onServiceDisconnected(name); &#125; //å¦‚æœServiceæ­»äº¡éœ€è¦å›è°ƒServiceConnection.onBindingDiedé€šçŸ¥clientæœåŠ¡æ­»äº¡ if (dead) &#123; mConnection.onBindingDied(name); &#125; // If there is a new viable service, it is now connected. if (service != null) &#123; //å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• //å‘ŠçŸ¥clientå·²å»ºç«‹è¿æ¥ mConnection.onServiceConnected(name, service); &#125; else &#123; // The binding machinery worked, but the remote returned null from onBind(). //å½“Service.onBindæ–¹æ³•è¿”å›nullï¼Œæˆ–è€…Serviceåœæ­¢æ—¶ //å›è°ƒServiceConnection.onNullBindingæ–¹æ³• mConnection.onNullBinding(name); &#125;&#125; è¿™ä¸ªæ–¹æ³•å…¶å®æˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­å·²ç»è¯´è¿‡äº†ï¼Œä¸è¿‡åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å…³æ³¨çš„æ˜¯Serviceç»‘å®šçš„éƒ¨åˆ†ï¼Œè€Œè¿™æ¬¡æˆ‘ä»¬å…³æ³¨çš„æ˜¯è§£ç»‘çš„éƒ¨åˆ† é¦–å…ˆæ˜ å…¥çœ¼å¸˜çš„å°±æ˜¯å¯¹mForgottenå˜é‡çš„åˆ¤æ–­ï¼Œå®ƒåœ¨å®¢æˆ·ç«¯è°ƒç”¨unbindServiceå°±ä¼šè¢«è®¾ä¸ºtrueï¼Œç„¶åä¾¿ä¼šç›´æ¥è¿”å›ï¼Œä¸å†å¤„ç†åç»­äº‹é¡¹ã€‚å½“ç„¶ï¼Œå®é™…ä¸Šæ‰§è¡Œå®ŒunbindServiceæ–¹æ³•åï¼Œå®¢æˆ·ç«¯ä¸Serviceçš„è¿æ¥ä¼šè¢«ç§»é™¤ï¼Œç†è®ºä¸Šåº”è¯¥ä¹Ÿä¸ä¼šå†èµ°åˆ°è¿™ä¸ªæ–¹æ³•é‡Œæ‰å¯¹ï¼ˆè¿™é‡Œæˆ‘ä¹Ÿæ„Ÿè§‰æœ‰ç‚¹ç–‘æƒ‘ï¼‰ æ ¹æ®è¿™æ®µä»£ç ï¼Œæˆ‘ä»¬èƒ½çœ‹å‡ºæ¥Serviceåœæ­¢åï¼Œå¯¹å®¢æˆ·ç«¯çš„å›è°ƒæ˜¯ä»€ä¹ˆï¼š å½“Service.onBindæ–¹æ³•çš„è¿”å›ä¸ä¸ºnullæ—¶ï¼Œæ­¤æ—¶ä¼šä¾æ¬¡å›è°ƒServiceConnection.onServiceDisconnectedã€ServiceConnection.onBindingDiedå’ŒServiceConnection.onNullBindingæ–¹æ³• å½“Service.onBindæ–¹æ³•çš„è¿”å›ä¸ºnullæ—¶ï¼Œæ­¤æ—¶ä¼šä¾æ¬¡å›è°ƒServiceConnection.onBindingDiedå’ŒServiceConnection.onNullBindingæ–¹æ³• å¤§å®¶ä¹Ÿå¯ä»¥è‡ªå·±å†™å†™Demoæ¥æ£€éªŒä¸€ä¸‹æˆ‘è¯´çš„æ˜¯å¦æ­£ç¡® è¿™ä¸€æ­¥å¤„ç†å®Œåï¼Œæ¥ä¸‹æ¥è¦åšçš„ä¾¿æ˜¯å¤„ç†Serviceé‚£è¾¹çš„è§£ç»‘ï¼Œéå†IntentBindRecordåˆ—è¡¨ï¼Œè°ƒç”¨ActivityThread$ApplicationThread.scheduleUnbindServiceå»è°ƒåº¦æ‰§è¡ŒæœåŠ¡è§£ç»‘æ“ä½œï¼Œè¿™é‡Œé€šè¿‡Handleræœ€ç»ˆè°ƒç”¨çš„æ˜¯ActivityThread.handleUnbindServiceæ–¹æ³• 123456789101112131415161718192021222324252627282930//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleUnbindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); //å›è°ƒService.onUnbindæ–¹æ³•ï¼Œå¦‚æœè¿”å›å€¼ä¸ºtrue //å½“å†æ¬¡å»ºç«‹è¿æ¥æ—¶ï¼ŒæœåŠ¡ä¼šå›è°ƒService.onRebindæ–¹æ³• boolean doRebind = s.onUnbind(data.intent); try &#123; if (doRebind) &#123; ActivityManager.getService().unbindFinished( data.token, data.intent, doRebind); &#125; else &#123; ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to unbind to service \" + s + \" with \" + data.intent + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå›è°ƒäº†Service.onUnbindæ–¹æ³•ï¼Œå®ƒçš„è¿”å›å€¼è¡¨ç¤ºå½“Serviceåé¢å†ä¸å…¶ä»–å®¢æˆ·ç«¯å»ºç«‹è¿æ¥æ—¶ï¼Œæ˜¯å¦éœ€è¦å›è°ƒService.onRebindæ–¹æ³•ï¼Œä½†æ˜¯è¿™æœ‰ä¸€ä¸ªå‰æï¼Œé‚£å°±æ˜¯Serviceä¸­é€”æ²¡æœ‰è¢«åœæ­¢ï¼Œå…·ä½“åŸå› ä»¥åŠrebindæµç¨‹æˆ‘ä»¬ç¨åå†åˆ†æ åˆ°äº†è¿™ä¸€æ­¥ï¼Œè§£ç»‘å°±å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥å’Œä¹‹å‰åœ¨stopSelfç« èŠ‚é‡Œåˆ†æçš„åç»­æµç¨‹å°±ä¸€æ ·äº†ï¼Œæœ€ç»ˆè°ƒç”¨ActivityThread.handleStopServiceæ–¹æ³•åœæ­¢æœåŠ¡ï¼Œè¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰åˆ†æåœ¨è¿™ä¸ªæ–¹æ³•ä¸­è§¦å‘å®ŒService.onDestroyå›è°ƒï¼Œä¹‹åè¿˜éœ€è¦è°ƒç”¨ContextImpl.scheduleFinalCleanupæ–¹æ³•å—ï¼Ÿç°åœ¨æˆ‘ä»¬å°±æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•åˆåšäº†ä»€ä¹ˆäº‹æƒ… 1234//frameworks/base/core/java/android/app/ContextImpl.javafinal void scheduleFinalCleanup(String who, String what) &#123; mMainThread.scheduleContextCleanup(this, who, what);&#125; è¿™é‡Œçš„mMainThreadå°±æ˜¯åº”ç”¨çš„ActivityThread 123456789//frameworks/base/core/java/android/app/ActivityThread.javafinal void scheduleContextCleanup(ContextImpl context, String who, String what) &#123; ContextCleanupInfo cci = new ContextCleanupInfo(); cci.context = context; cci.who = who; cci.what = what; sendMessage(H.CLEAN_UP_CONTEXT, cci);&#125; è¿˜æ˜¯è€æ ·å­é€šè¿‡Handlerå‘æ¶ˆæ¯ï¼Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ContextImpl.performFinalCleanupæ–¹æ³• 1234//frameworks/base/core/java/android/app/ContextImpl.javafinal void performFinalCleanup(String who, String what) &#123; mPackageInfo.removeContextRegistrations(getOuterContext(), who, what);&#125; ç„¶åè°ƒç”¨LoadedApk.removeContextRegistrationsæ–¹æ³•æ‰§è¡Œæ¸…ç†æ“ä½œ 123456789101112131415161718192021222324//frameworks/base/core/java/android/app/LoadedApk.javapublic void removeContextRegistrations(Context context, String who, String what) &#123; ... //æ¸…ç†å¹¿æ’­æ¥æ”¶å™¨ synchronized (mServices) &#123; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; smap = mServices.remove(context); if (smap != null) &#123; for (int i = 0; i &lt; smap.size(); i++) &#123; LoadedApk.ServiceDispatcher sd = smap.valueAt(i); ... //æŠ¥å‘ŠServiceConnectionæ³„éœ² try &#123; ActivityManager.getService().unbindService( sd.getIServiceConnection()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; sd.doForget(); &#125; &#125; mUnboundServices.remove(context); &#125;&#125; å¯èƒ½çœ‹åˆ°è¿™é‡Œï¼Œæœ‰å¾ˆå¤šå°ä¼™ä¼´ä¼šæœ‰ç–‘é—®ï¼Œä¸ºä»€ä¹ˆä¹‹å‰å·²ç»æ¸…ç†è¿‡äº†ï¼Œè¿™é‡Œè¿˜è¦å†è¿›è¡Œæ¸…ç†ã€è¿™é‡Œä¸ºä»€ä¹ˆä¼šæœ‰ServiceConnectionæ³„éœ²ã€è¿™é‡Œä¸ºä»€ä¹ˆè¿˜è¦å†æ¬¡unbindServiceï¼Ÿé‚£æˆ‘ä»¬éœ€è¦æ³¨æ„äº†ï¼Œè¿™é‡Œè¢«è°ƒç”¨çš„å¯¹è±¡åˆ°åº•æ˜¯è°ï¼Ÿå…¶å®æ˜¯Serviceçš„Contextï¼Œå‡è®¾æˆ‘ä»¬åœ¨Serivceé‡Œè°ƒç”¨bindServiceåˆç»‘å®šäº†ä¸€ä¸ªå…¶ä»–Serviceï¼Œé‚£è¿™ä¸ªServiceè¢«é”€æ¯åï¼Œå®ƒå’Œå¦ä¸€ä¸ªServiceçš„è¿æ¥æ€ä¹ˆåŠï¼Ÿæ˜¯ä¸æ˜¯å°±äº§ç”Ÿäº†æ³„éœ²ï¼Ÿä¸ºäº†é˜²æ­¢è¿™ç§æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨Serviceé”€æ¯æ—¶è°ƒç”¨ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•è§£é™¤å®ƒä¸å…¶ä»–Serviceçš„ç»‘å®š è€Œä¸”è¿™ä¸ªæ–¹æ³•ä¸ä»…ä¼šåœ¨è¿™é‡Œè¢«è°ƒç”¨åˆ°å“¦ï¼Œåœ¨æˆ‘ä»¬ä¹‹å‰åˆ†æè¿‡çš„ Androidæºç åˆ†æ - Activityé”€æ¯æµç¨‹ ä¸­ï¼Œä¹Ÿå­˜åœ¨å®ƒçš„èº«å½±ï¼Œå½“Activityè¢«é”€æ¯ï¼Œèµ°åˆ°handleDestroyActivityæ–¹æ³•æ—¶ï¼Œä¼šè°ƒç”¨åˆ°æˆ‘ä»¬ContextImpl.scheduleFinalCleanupæ–¹æ³•ï¼Œè¿›è¡Œå¹¿æ’­æ¥æ”¶å™¨çš„æ¸…ç†ä»¥åŠæœåŠ¡çš„è§£ç»‘ è‡³æ­¤ï¼ŒServiceçš„ä¸»åŠ¨åœæ­¢æµç¨‹æˆ‘ä»¬éƒ½åˆ†æå®Œäº†ï¼Œè¿˜æœ‰ä¸€äº›ç»†ææœ«èŠ‚çš„äº‹æƒ…å¯ä»¥è¯´ä¸€è¯´ rebindæµç¨‹ä¹‹å‰æˆ‘ä»¬è¯´è¿‡ï¼Œrebindçš„å‰ææ˜¯Serviceä¸­é€”æ²¡æœ‰è¢«åœæ­¢ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå¸¦ç€ç–‘é—®ï¼Œæˆ‘ä»¬æ¥çœ‹ä¹‹å‰æ²¡æœ‰åˆ†æçš„ï¼Œå½“Service.onUnbindæ–¹æ³•è¿”å›å€¼ä¸ºtrueæ—¶ï¼Œä¼šè°ƒç”¨çš„AMS.unbindFinishedæ–¹æ³• 1234567891011//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic void unbindFinished(IBinder token, Intent intent, boolean doRebind) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind); &#125;&#125; è¿˜æ˜¯è½¬äº¤ç»™ActiveServiceså»å®ç° 1234567891011121314151617181920212223242526272829//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javavoid unbindFinishedLocked(ServiceRecord r, Intent intent, boolean doRebind) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (r != null) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); IntentBindRecord b = r.bindings.get(filter); boolean inDestroying = mDestroyingServices.contains(r); if (b != null) &#123; //æœåŠ¡unbindçš„å‰æå°±æ˜¯IntentBindRecord.apps.size == 0 if (b.apps.size() &gt; 0 &amp;&amp; !inDestroying) &#123; ... &#125; else &#123; // Note to tell the service the next time there is // a new client. //å°†doRebindæ ‡è®°ç½®ä¸ºtrueï¼Œä¸‹ä¸€æ¬¡å†æ¬¡å»ºç«‹è¿æ¥æ—¶ //æœåŠ¡ä¼šå›è°ƒService.onRebindæ–¹æ³• b.doRebind = true; &#125; &#125; serviceDoneExecutingLocked(r, inDestroying, false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; æ ¹æ®æˆ‘ä»¬ä¹‹å‰çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå›è°ƒService.onUnbindçš„å‰æå°±æ˜¯è¿™ä¸ªServiceæ²¡æœ‰ä»»ä½•è¿æ¥ä¸å…¶ç»‘å®šäº†ï¼Œå³IntentBindRecord.apps.size == 0ï¼Œåœ¨è¿™ä¸ªcaseä¸‹ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šå°†IntentBindRecordçš„doRebindå˜é‡ç½®ä¸ºtrue æ­¤æ—¶è®©æˆ‘ä»¬å†å›é¡¾ä¸€ä¸‹ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Serviceå¯åŠ¨æµç¨‹ ä¸­åˆ†æçš„bindServiceæµç¨‹ï¼Œåœ¨ActiveServices.bindServiceLockedæ–¹æ³•ä¸­æœ‰è¿™ä¹ˆä¸€æ®µä»£ç  123456789101112131415161718192021222324252627282930//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaint bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String instanceName, String callingPackage, final int userId) throws TransactionTooLargeException &#123; ... if (s.app != null &amp;&amp; b.intent.received) &#123; // Service is already running, so we can immediately // publish the connection. //å¦‚æœæœåŠ¡ä¹‹å‰å°±å·²ç»åœ¨è¿è¡Œï¼Œå³Service.onBindæ–¹æ³•å·²ç»è¢«æ‰§è¡Œï¼Œè¿”å›çš„IBinderå¯¹è±¡ä¹Ÿå·²ç»è¢«ä¿å­˜ //è°ƒç”¨LoadedApk$ServiceDispatcher$InnerConnection.connectedæ–¹æ³• //å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• c.conn.connected(s.name, b.intent.binder, false); // If this is the first app connected back to this binding, // and the service had previously asked to be told when // rebound, then do so. //å½“æœåŠ¡è§£ç»‘ï¼Œè°ƒç”¨åˆ°Service.onUnbindæ–¹æ³•æ—¶è¿”å›trueï¼Œæ­¤æ—¶doRebindå˜é‡å°±ä¼šè¢«èµ‹å€¼ä¸ºtrue //æ­¤æ—¶ï¼Œå½“å†æ¬¡å»ºç«‹è¿æ¥æ—¶ï¼ŒæœåŠ¡ä¼šå›è°ƒService.onRebindæ–¹æ³• if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; requestServiceBindingLocked(s, b.intent, callerFg, true); &#125; &#125; else if (!b.intent.requested) &#123; //å¦‚æœæœåŠ¡æ˜¯å› è¿™æ¬¡ç»‘å®šè€Œåˆ›å»ºçš„ //è¯·æ±‚æ‰§è¡ŒService.onBindæ–¹æ³•ï¼Œè·å–è¿”å›çš„IBinderå¯¹è±¡ //å‘å¸ƒServiceï¼Œå›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• requestServiceBindingLocked(s, b.intent, callerFg, false); &#125; ...&#125; å¦‚æœServiceè¢«åœæ­¢äº†ï¼Œé‚£ä¹ˆå®ƒç›¸åº”çš„ServiceRecordä¼šä»ç¼“å­˜mServicesByInstanceNameå’ŒmServicesByIntentä¸­ç§»é™¤ï¼Œé‚£ä¹ˆç­‰åˆ°é‡æ–°å¯åŠ¨Serviceæ—¶ä¼šæ–°å»ºå‡ºä¸€ä¸ªServiceRecordï¼Œæ­¤æ—¶é‡Œé¢çš„å˜é‡å…¨éƒ¨è¢«åˆå§‹åŒ–ï¼Œb.intent.received == falseï¼Œb.intent.requested == falseï¼Œb.intent.doRebind == falseï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè°ƒç”¨requestServiceBindingLockedæ–¹æ³•çš„æœ€åä¸€ä¸ªå…¥å‚rebindä¸ºfalseï¼Œå°±ä¼šç›´æ¥å›è°ƒService.onBindæ–¹æ³•ï¼Œè€Œä¸ä¼šå›è°ƒService.onRebindæ–¹æ³• å¦‚æœServiceæ²¡æœ‰è¢«åœæ­¢ï¼Œä¸”ä¹‹å‰æœ‰è¢«ç»‘å®šè¿‡ï¼Œé‚£ä¹ˆb.intent.received == trueï¼Œä»£è¡¨IBinderå¯¹è±¡å·²è·å–åˆ°ï¼Œæ­¤æ—¶å¦‚æœä¹‹å‰çš„Service.onUnbindå›è°ƒè¿”å›å€¼ä¸ºtrueï¼Œé‚£ä¹ˆè¿™é‡Œçš„b.intent.doRebindä¹Ÿä¸ºtrueï¼Œå†åŠ ä¸Šå¦‚æœè¿™æ˜¯Serviceæ–­å¼€æ‰€æœ‰è¿æ¥åå»ºç«‹çš„ç¬¬ä¸€æ¬¡è¿æ¥ï¼Œå³b.intent.apps.size() == 1ï¼Œé‚£ä¹ˆæ­¤æ—¶è°ƒç”¨çš„requestServiceBindingLockedæ–¹æ³•çš„æœ€åä¸€ä¸ªå…¥å‚rebindä¸ºtrueï¼Œå°±ä¼šç›´æ¥å›è°ƒService.onRebindæ–¹æ³•ï¼Œè€Œä¸ä¼šå›è°ƒService.onBindæ–¹æ³• æ··åˆå¯åŠ¨çš„Serviceè¯¥å¦‚ä½•åœæ­¢å•ä¸€å¯åŠ¨æ–¹å¼çš„Serviceçš„åœæ­¢å¾ˆç®€å•ï¼Œé‚£ä¹ˆæ··åˆå¯åŠ¨çš„Serviceè¯¥å¦‚ä½•åœæ­¢å‘¢ï¼Ÿ ä½•ä¸ºæ··åˆå¯åŠ¨ï¼ŸæŒ‡çš„æ˜¯é€šè¿‡startServiceæ–¹å¼å¯åŠ¨Serviceå¹¶ä¸”ä»¥BIND_AUTO_CREATEæ ‡å¿—è°ƒç”¨bindServiceæ–¹æ³•ç»‘å®šServiceï¼Œä¸¤è€…ä¸åˆ†å…ˆå åœ¨ä¸Šé¢çš„åˆ†æä¸­ï¼Œæˆ‘ä»¬æ³¨æ„åˆ°ï¼Œä¸ç®¡ç”¨å“ªç§æ–¹å¼åœæ­¢æœåŠ¡ï¼Œæœ€åéƒ½ä¼šèµ°åˆ°bringDownServiceIfNeededLockedæ–¹æ³•ä¸­ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•é‡Œåˆä¼šè°ƒç”¨isServiceNeededLockedåˆ¤æ–­æ˜¯å¦Serviceæ˜¯å¦è¢«éœ€è¦ï¼Œé‚£è¢«éœ€è¦çš„æ¡ä»¶æ˜¯ä»€ä¹ˆå‘¢ï¼ŸService.startRequestedä¸ºtrueï¼Œå¹¶ä¸”æ²¡æœ‰æ ‡å¿—ä¸ºBIND_AUTO_CREATEçš„è¿æ¥ç»‘å®šï¼Œé‚£ä¹ˆï¼Œåªè¦ä¸ç¬¦åˆè¿™ä¸¤ä¸ªæ¡ä»¶ï¼ŒæœåŠ¡è‡ªç„¶å°±å¯ä»¥è¢«åœæ­¢äº† æ²¡æœ‰æ ‡å¿—ä¸ºBIND_AUTO_CREATEçš„è¿æ¥ç»‘å®šè¿™ä¸ªç®€å•ï¼Œåªéœ€è¦æŠŠæ ‡è®°ä¸ºBIND_AUTO_CREATEçš„è¿æ¥å…¨éƒ¨è§£ç»‘äº†å°±å¥½ï¼Œé‚£ä¹ˆæ€ä¹ˆè®©Service.startRequestedä¸ºfalseå‘¢ï¼Ÿæˆ‘ä»¬å›é¡¾ä¸€ä¸‹ä¹‹å‰å¯¹stopSelfå’ŒstopServiceçš„åˆ†æï¼Œåœ¨ä»–ä»¬è°ƒç”¨bringDownServiceIfNeededLockedæ–¹æ³•ä¹‹å‰ï¼Œéƒ½ä¼šå…ˆå°†Service.startRequestedè®¾ç½®ä¸ºfalseï¼Œæ‰€ä»¥ç­”æ¡ˆå°±å¾ˆæ˜æ˜¾äº†ï¼šåªè¦unbindServiceæ‰æ‰€æœ‰BIND_AUTO_CREATEçš„æ ‡å¿—çš„è¿æ¥ï¼Œç„¶åstopServiceå°±èƒ½åœæ­¢æ‰æ··åˆå¯åŠ¨çš„æœåŠ¡ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥å…ˆstopServiceï¼Œå†unbindServiceæ‰æ‰€æœ‰BIND_AUTO_CREATEçš„æ ‡å¿—çš„è¿æ¥ å°æµ‹éªŒç»è¿‡ä»¥ä¸Šä¸€ç³»åˆ—çš„åˆ†æï¼Œæˆ‘ç»™å¤§å®¶å‡ºå‡ ä¸ªå°é—®é¢˜ï¼š å…ˆé€šè¿‡startServiceå¯åŠ¨æœåŠ¡ï¼Œç„¶åå†ç”¨BIND_AUTO_CREATEæ ‡å¿—bindServiceï¼ˆè¿æ¥1ï¼‰ï¼Œæ­¤æ—¶ï¼ŒServiceçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ€æ ·çš„ï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ åœ¨ä¸Šä¸€é¢˜çš„åŸºç¡€ä¸Šï¼Œå†ä½¿ç”¨ä¸€ä¸ªéBIND_AUTO_CREATEæ ‡å¿—bindServiceï¼ˆè¿æ¥2ï¼‰ï¼Œæ­¤æ—¶ï¼ŒServiceçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ€æ ·çš„ï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ æ­¤æ—¶ï¼Œä½¿ç”¨unbindServiceè§£ç»‘è¿æ¥1ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ æ­¤æ—¶ï¼Œä½¿ç”¨unbindServiceè§£ç»‘è¿æ¥2ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ æ¥ç€ï¼Œå†ä½¿ç”¨è¿æ¥1bindServiceï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ ç„¶åï¼Œè°ƒç”¨stopServiceåœæ­¢æœåŠ¡ï¼ŒæœåŠ¡çœŸçš„ä¼šè¢«åœæ­¢å—ï¼ŸServiceçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ€æ ·çš„ï¼Ÿè¿æ¥1çš„ServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ ç´§æ¥ç€ï¼Œå†ä½¿ç”¨è¿æ¥2bindServiceï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿè¿æ¥2çš„ServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ æœ€åï¼Œè°ƒç”¨unbindServiceè§£ç»‘è¿æ¥1ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼ŸServiceçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ€æ ·çš„ï¼ŸServiceConnectionä¼šå›è°ƒå“ªäº›æ–¹æ³•ï¼Ÿ è¯·å¤§å®¶æ€è€ƒç‰‡åˆ»ï¼Œå¯ä»¥å»å›é¡¾ä¹‹å‰çš„Serviceå¯åŠ¨åˆ†æä»¥åŠåœæ­¢æµç¨‹åˆ†æï¼Œå¦‚æœä»¥ä¸Šé—®é¢˜èƒ½å…¨éƒ¨å›ç­”æ­£ç¡®ï¼Œè¯æ˜ä½ å¯¹Serviceå·²ç»æœ‰äº†ä¸€ä¸ªå¾ˆæ·±åˆ»çš„ç†è§£ï¼Œæ¥ä¸‹æ¥æ­æ™“ç­”æ¡ˆï¼š ç”Ÿå‘½å‘¨æœŸï¼šonCreate -&gt; onStartCommand -&gt; onBindï¼Œå¦‚æœonBindçš„è¿”å›å€¼ä¸ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonServiceConnectedæ–¹æ³•ï¼Œå¦‚æœonBindçš„è¿”å›å€¼ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonNullBindingæ–¹æ³• ç”Ÿå‘½å‘¨æœŸä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœonBindçš„è¿”å›å€¼ä¸ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonServiceConnectedæ–¹æ³•ï¼Œå¦‚æœonBindçš„è¿”å›å€¼ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonNullBindingæ–¹æ³• ç”Ÿå‘½å‘¨æœŸä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼ŒServiceConnectionä¸ä¼šå›è°ƒä»»ä½•æ–¹æ³• ç”Ÿå‘½å‘¨æœŸï¼šonUnbindï¼ŒServiceConnectionä¸ä¼šå›è°ƒä»»ä½•æ–¹æ³• å¦‚æœä¹‹å‰onUnbindçš„è¿”å›å€¼ä¸ºtrueï¼Œåˆ™ç”Ÿå‘½å‘¨æœŸä¸ºï¼šonRebindï¼Œå¦åˆ™ç”Ÿå‘½å‘¨æœŸä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonServiceConnectedæ–¹æ³•ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonNullBindingæ–¹æ³• ä¸ä¼šçœŸçš„è¢«åœæ­¢ï¼Œç”Ÿå‘½å‘¨æœŸä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼ŒServiceConnectionä¸ä¼šå›è°ƒä»»ä½•æ–¹æ³• ç”Ÿå‘½å‘¨æœŸä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonServiceConnectedæ–¹æ³•ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ºnullï¼ŒServiceConnectionä¼šå›è°ƒonNullBindingæ–¹æ³• æœåŠ¡ä¼šè¢«åœæ­¢ï¼Œç”Ÿå‘½å‘¨æœŸï¼šonUnbind -&gt; onDestroyï¼Œè¿æ¥1çš„ServiceConnectionä¸ä¼šå›è°ƒä»»ä½•æ–¹æ³•ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ä¸ºnullï¼Œè¿æ¥2çš„ServiceConnectionä¼šå›è°ƒonServiceDisconnectedã€onBindingDiedä»¥åŠonNullBindingæ–¹æ³•ï¼Œå¦‚æœä¹‹å‰onBindçš„è¿”å›å€¼ä¸ºnullï¼Œè¿æ¥2çš„ServiceConnectionä¼šå›è°ƒonBindingDiedä»¥åŠonNullBindingæ–¹æ³• è¢«åŠ¨åœæ­¢Serviceé™¤äº†ä¸»åŠ¨åœæ­¢ï¼Œè¿˜ä¼šå› ä¸ºå„ç§æƒ…å†µå¯¼è‡´è¢«åŠ¨åœæ­¢ ç”¨æˆ·æ‰‹åŠ¨ä»æœ€è¿‘ä»»åŠ¡ç§»é™¤Taskæ³¨ï¼šç”±äºå„å®¶ç³»ç»Ÿå¯¹è¿›ç¨‹æˆ–ä»»åŠ¡è°ƒåº¦ç­–ç•¥ä¸åŒï¼Œæ‰€ä»¥è¿™é‡Œçš„Taskç§»é™¤é€»è¾‘å’ŒServiceåœæ­¢é€»è¾‘å¯èƒ½ä¼šæœ‰äº›è®¸ä¸åŒï¼Œæˆ‘ä»¬è¿˜æ˜¯ä»¥åŸç”ŸAndroidä¸ºå‡†åˆ†æ ä¸ç®¡ç”¨æˆ·æ˜¯ä»æœ€è¿‘ä»»åŠ¡åˆ’èµ°äº†ä¸€ä¸ªTaskï¼Œè¿˜æ˜¯ç‚¹å‡»äº†å…¨éƒ¨æ¸…é™¤ï¼Œæœ€ç»ˆéƒ½ä¼šèµ°åˆ°ActivityStackSupervisor.removeTaskByIdæ–¹æ³• 123456789101112//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.javaboolean removeTaskById(int taskId, boolean killProcess, boolean removeFromRecents, String reason) &#123; //é€šè¿‡idæŸ¥è¯¢Task final Task task = mRootWindowContainer.anyTaskForId(taskId, MATCH_TASK_IN_STACKS_OR_RECENT_TASKS); if (task != null) &#123; removeTask(task, killProcess, removeFromRecents, reason); return true; &#125; return false;&#125; è¿™é‡Œçš„å…¥å‚ï¼ŒkillProcessä¸ºtrueï¼Œå¦‚æœæ˜¯ç§»é™¤å•ä¸€Taskï¼Œé‚£ä¹ˆremoveFromRecentsä¸ºtrueï¼Œå¦‚æœæ˜¯æ¸…é™¤å…¨éƒ¨Taskï¼Œé‚£ä¹ˆremoveFromRecentsä¸ºfalse å…ˆé€šè¿‡idï¼Œä½¿ç”¨RootWindowContaineræŸ¥è¯¢ç›¸åº”çš„Taskï¼Œç„¶åå†è°ƒç”¨removeTaskæ–¹æ³•ç»§ç»­ç§»é™¤Task 123456789101112131415161718192021222324252627//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.javavoid removeTask(Task task, boolean killProcess, boolean removeFromRecents, String reason) &#123; //å¦‚æœTaskæ­£åœ¨æ¸…ç†ä¸­åˆ™ç›´æ¥è¿”å› if (task.mInRemoveTask) &#123; // Prevent recursion. return; &#125; //æ ‡è®°Taskæ­£åœ¨æ¸…ç†ä¸­ task.mInRemoveTask = true; try &#123; //é”€æ¯æ­¤Taskä¸‹æ‰€æœ‰Activity task.performClearTask(reason); //æ¸…ç†Task cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents); //å…³é—­å±å¹•å›ºå®š mService.getLockTaskController().clearLockedTask(task); //é€šçŸ¥ä»»åŠ¡æ ˆå‘ç”Ÿå˜åŒ– mService.getTaskChangeNotificationController().notifyTaskStackChanged(); //å¯åŠ¨ä»»åŠ¡æŒä¹…åŒ–ç¨‹åºï¼Œå°†ä»»ä½•æŒ‚èµ·çš„ä»»åŠ¡å†™å…¥ç£ç›˜ if (task.isPersistable) &#123; mService.notifyTaskPersisterLocked(null, true); &#125; &#125; finally &#123; //å–æ¶ˆæ ‡è®° task.mInRemoveTask = false; &#125;&#125; è¿™ä¸ªæ–¹æ³•æœ€é‡è¦çš„æœ‰ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯é”€æ¯æ­¤Taskä¸‹æ‰€æœ‰Activityï¼Œå¯¹äºæˆ‘ä»¬æœ¬æ¬¡è€Œè¨€ä¸éœ€è¦å…³æ³¨ï¼Œå¦ä¸€ä¸ªæ˜¯è°ƒç”¨cleanUpRemovedTaskLockedç»§ç»­æ¸…ç†Task 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.javavoid cleanUpRemovedTaskLocked(Task task, boolean killProcess, boolean removeFromRecents) &#123; //ä»æœ€è¿‘ä»»åŠ¡åˆ—è¡¨ä¸­ç§»é™¤ //å¯¹äºæ¸…é™¤å…¨éƒ¨Taskè€Œè¨€ï¼Œä¹‹å‰åœ¨RecentTasksä¸­å·²ç»è¿›è¡Œè¿‡ç§»é™¤æ“ä½œäº† //æ‰€ä»¥ä¼ å…¥çš„removeFromRecentsä¸ºfalse if (removeFromRecents) &#123; mRecentTasks.remove(task); &#125; ComponentName component = task.getBaseIntent().getComponent(); if (component == null) &#123; return; &#125; // Find any running services associated with this app and stop if needed. //æ¸…ç†å’Œæ­¤Taskæœ‰å…³è”çš„æœåŠ¡ final Message msg = PooledLambda.obtainMessage(ActivityManagerInternal::cleanUpServices, mService.mAmInternal, task.mUserId, component, new Intent(task.getBaseIntent())); mService.mH.sendMessage(msg); //å¦‚æœä¸éœ€è¦æ€æ­»è¿›ç¨‹ï¼Œåˆ°è¿™é‡Œå°±ä¸ºæ­¢äº† if (!killProcess) &#123; return; &#125; // Determine if the process(es) for this task should be killed. final String pkg = component.getPackageName(); ArrayList&lt;Object&gt; procsToKill = new ArrayList&lt;&gt;(); ArrayMap&lt;String, SparseArray&lt;WindowProcessController&gt;&gt; pmap = mService.mProcessNames.getMap(); //éå†Appè¿›ç¨‹ï¼Œç¡®å®šè¦æ€æ­»çš„è¿›ç¨‹ for (int i = 0; i &lt; pmap.size(); i++) &#123; SparseArray&lt;WindowProcessController&gt; uids = pmap.valueAt(i); for (int j = 0; j &lt; uids.size(); j++) &#123; WindowProcessController proc = uids.valueAt(j); //ä¸è¦æ€æ­»å…¶ä»–ç”¨æˆ·ä¸‹çš„è¿›ç¨‹ if (proc.mUserId != task.mUserId) &#123; // Don't kill process for a different user. continue; &#125; //ä¸è¦æ€æ­»é¦–é¡µè¿›ç¨‹ //HomeProcessæŒ‡çš„æ˜¯å«æœ‰åˆ†ç±»ä¸ºandroid.intent.category.HOMEçš„è¿›ç¨‹ //ä¹Ÿå°±æ˜¯èƒ½æˆä¸ºé¦–é¡µLauncherçš„è¿›ç¨‹ if (proc == mService.mHomeProcess) &#123; // Don't kill the home process along with tasks from the same package. continue; &#125; //ä¸è¦æ€æ­»å’Œè¿™ä¸ªTaskæ— å…³çš„è¿›ç¨‹ if (!proc.mPkgList.contains(pkg)) &#123; // Don't kill process that is not associated with this task. continue; &#125; //å¦‚æœè¿™ä¸ªè¿›ç¨‹æœ‰Activityåœ¨ä¸åŒçš„Taské‡Œï¼Œå¹¶ä¸”è¿™ä¸ªTaskä¹Ÿåœ¨æœ€è¿‘ä»»åŠ¡é‡Œ //æˆ–è€…æœ‰Activityè¿˜æ²¡æœ‰è¢«åœæ­¢ï¼Œåˆ™ä¸è¦æ€æ­»è¿›ç¨‹ if (!proc.shouldKillProcessForRemovedTask(task)) &#123; // Don't kill process(es) that has an activity in a different task that is also // in recents, or has an activity not stopped. return; &#125; //æœ‰å‰å°æœåŠ¡çš„è¯ä¸è¦æ€æ­»è¿›ç¨‹ if (proc.hasForegroundServices()) &#123; // Don't kill process(es) with foreground service. return; &#125; // Add process to kill list. procsToKill.add(proc); &#125; &#125; // Kill the running processes. Post on handle since we don't want to hold the service lock // while calling into AM. //æ€æ­»è¿›ç¨‹ final Message m = PooledLambda.obtainMessage( ActivityManagerInternal::killProcessesForRemovedTask, mService.mAmInternal, procsToKill); mService.mH.sendMessage(m);&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšä¸¤ä»¶äº‹ï¼Œä¸€æ˜¯æ¸…ç†å’Œæ­¤Taskæœ‰å…³è”çš„æœåŠ¡ï¼ŒäºŒæ˜¯æ€æ­»åº”è¯¥æ€æ­»çš„è¿›ç¨‹ æ¸…ç†æœåŠ¡è¿™ä¸€æ­¥ç”¨åˆ°äº†æ± åŒ–æŠ€æœ¯ï¼Œè¿™é‡Œå¤§å®¶ä¸ç”¨ç®¡ï¼Œå°±å½“åšè°ƒç”¨äº†mService.mAmInternal.cleanUpServiceså³å¯ï¼Œè¿™é‡Œçš„mService.mAmInternalæ˜¯AMSé‡Œçš„ä¸€ä¸ªå†…éƒ¨ç±»LocalService 123456//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic void cleanUpServices(int userId, ComponentName component, Intent baseIntent) &#123; synchronized(ActivityManagerService.this) &#123; mServices.cleanUpServices(userId, component, baseIntent); &#125;&#125; åŒæ ·ï¼Œå…³äºServiceçš„å·¥ä½œéƒ½è½¬äº¤ç»™ActiveServices 12345678910111213141516171819202122232425262728293031323334353637//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javavoid cleanUpServices(int userId, ComponentName component, Intent baseIntent) &#123; ArrayList&lt;ServiceRecord&gt; services = new ArrayList&lt;&gt;(); //è·å¾—æ­¤ç”¨æˆ·ä¸‹æ‰€æœ‰çš„æ´»åŠ¨Service ArrayMap&lt;ComponentName, ServiceRecord&gt; alls = getServicesLocked(userId); //ç­›é€‰å‡ºæ­¤Taskä¸‹çš„æ‰€æœ‰æ´»åŠ¨Service for (int i = alls.size() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = alls.valueAt(i); if (sr.packageName.equals(component.getPackageName())) &#123; services.add(sr); &#125; &#125; // Take care of any running services associated with the app. for (int i = services.size() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = services.get(i); if (sr.startRequested) &#123; if ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != 0) &#123; //å¦‚æœåœ¨manifesté‡Œè®¾ç½®äº†stopWithTaskï¼Œé‚£ä¹ˆä¼šç›´æ¥åœæ­¢Service stopServiceLocked(sr); &#125; else &#123; //å¦‚æœæ²¡æœ‰è®¾ç½®stopWithTaskçš„è¯ï¼Œåˆ™ä¼šå›è°ƒService.onTaskRemovedæ–¹æ³• sr.pendingStarts.add(new ServiceRecord.StartItem(sr, true, sr.getLastStartId(), baseIntent, null, 0)); if (sr.app != null &amp;&amp; sr.app.thread != null) &#123; // We always run in the foreground, since this is called as // part of the \"remove task\" UI operation. try &#123; sendServiceArgsLocked(sr, true, false); &#125; catch (TransactionTooLargeException e) &#123; // Ignore, keep going. &#125; &#125; &#125; &#125; &#125;&#125; é¦–å…ˆè¦è·å–åˆ°æ‰€æœ‰éœ€è¦æ¸…ç†çš„Serviceè®°å½•ï¼Œç„¶åå†å¯¹å®ƒä»¬è¿›è¡Œå¤„ç† å¯¹äºåœ¨manifestæ–‡ä»¶é‡Œè®¾ç½®äº†stopWithTaskæ ‡è¯†çš„Serviceï¼Œç›´æ¥è°ƒç”¨stopServiceLockedæ–¹æ³•åœæ­¢æœåŠ¡ï¼Œè€Œå¯¹äºæ²¡æœ‰è¿™ä¸ªæ ‡è¯†çš„Serviceï¼Œåˆ™æ˜¯å¢åŠ ä¸€ä¸ªå¯åŠ¨é¡¹ï¼Œæ¥ç€è°ƒç”¨sendServiceArgsLockedå¤„ç†è¿™ä¸ªå¯åŠ¨é¡¹ æˆ‘ä»¬è§‚å¯Ÿè¿™ä¸ªå¯åŠ¨é¡¹çš„æ„å»ºï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºtrueï¼Œæˆ‘ä»¬å¯ä»¥å»è¿™ä¸ªç±»çš„æ„é€ æ–¹æ³•é‚£é‡Œçœ‹åˆ°ï¼Œç¬¬äºŒä¸ªå‚æ•°çš„åå­—ä¸º_taskRemovedï¼Œæ„æ€å¾ˆæ˜æ˜¾äº†ï¼Œç„¶åæ ¹æ®æˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Serviceå¯åŠ¨æµç¨‹ ä¸­åˆ†æçš„sendServiceArgsLockedæ–¹æ³•å¯ä»¥çŸ¥é“ï¼Œå®ƒæœ€ç»ˆä¼šèµ°åˆ°ActivityThread.handleServiceArgsæ–¹æ³•ä¸­ 1234567891011121314//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleServiceArgs(ServiceArgsData data) &#123; ... int res; if (!data.taskRemoved) &#123; //æ­£å¸¸æƒ…å†µè°ƒç”¨ res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; //ç”¨æˆ·å…³é—­Taskæ ˆæ—¶è°ƒç”¨ s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; ...&#125; å¯ä»¥å‘ç°ï¼Œå½“taskRemovedå˜é‡ä¸ºtrueæ—¶ï¼Œä¼šå›è°ƒService.onTaskRemovedæ–¹æ³• æˆ‘ä»¬æ¥ç€å›åˆ°cleanUpRemovedTaskLockedæ–¹æ³•ä¸­ï¼Œå½“å®ƒæ¸…ç†å®ŒæœåŠ¡åï¼Œä¾¿ä¼šå°è¯•æ€æ­»è¿›ç¨‹ï¼Œè¿™é‡Œé¢å…¶ä»–çš„åˆ¤æ–­æ¡ä»¶æˆ‘ä»¬éƒ½ä¸ç”¨ç®¡ï¼Œæˆ‘ä»¬åªéœ€è¦å…³å¿ƒå…¶ä¸­çš„ä¸€æ®µï¼Œæœ‰å‰å°æœåŠ¡çš„è¯ä¸è¦æ€æ­»è¿›ç¨‹ ä»¥ä¸Šæ˜¯æˆ‘æ ¹æ®AOSPæºç åˆ†æå¾—å‡ºçš„ç»“æœï¼Œåœ¨æ¨¡æ‹Ÿå™¨ä¸Šä¹ŸéªŒè¯é€šè¿‡ï¼Œä½†åœ¨æˆ‘çš„å°ç±³MIX4ä¸Šè¡¨ç°å´å®Œå…¨ä¸æ˜¯è¿™æ ·ï¼Œå¤§å®¶å¼€å‘æ—¶è¿˜æ˜¯è¦ä»¥å®é™…ä¸ºå‡† å†…å­˜ä¸è¶³å½“å†…å­˜ä¸è¶³æ—¶ï¼Œç³»ç»Ÿä¼šé€šè¿‡OOM Killeræˆ–Low Memory Killerç­‰æ‰‹æ®µæ€æ­»å„ç§è¿›ç¨‹ï¼Œå¦‚æœè¢«æ€æ­»çš„è¿›ç¨‹é‡Œæœ‰Serviceæ­£åœ¨è¿è¡Œï¼Œé‚£è‡ªç„¶ä¹Ÿä¼šè¢«åœæ­¢ é‡å»ºå½“Serviceæ‰€åœ¨è¿›ç¨‹è¢«æ€æ­»åï¼Œæ ¹æ®Service.onStartCommandçš„è¿”å›å€¼ï¼Œç³»ç»Ÿä¼šå†³å®šæ˜¯å¦é‡å»ºï¼Œæ€ä¹ˆé‡å»ºã€‚æˆ‘ä»¬å…ˆæŠŠå…¶å¯èƒ½çš„è¿”å›å€¼ä»¥åŠäº§ç”Ÿçš„ç»“æœå…ˆåˆ—å‡ºæ¥ï¼š START_STICKY_COMPATIBILITYï¼štargetSdkVersion &lt; 5 (Android 2.0) çš„Appé»˜è®¤ä¼šè¿”å›è¿™ä¸ªï¼ŒServiceè¢«æ€åä¼šè¢«é‡å»ºï¼Œä½†onStartCommandæ–¹æ³•ä¸ä¼šè¢«æ‰§è¡Œ START_STICKYï¼štargetSdkVersion &gt;= 5 (Android 2.0) çš„Appé»˜è®¤ä¼šè¿”å›è¿™ä¸ªï¼ŒServiceè¢«æ€åä¼šè¢«é‡å»ºï¼ŒonStartCommandæ–¹æ³•ä¹Ÿä¼šè¢«æ‰§è¡Œï¼Œä½†æ­¤æ—¶onStartCommandæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°Intentä¸ºnull START_NOT_STICKYï¼šServiceè¢«æ€åä¸ä¼šè¢«é‡å»º START_REDELIVER_INTENTï¼šServiceè¢«æ€åä¼šè¢«é‡å»ºï¼ŒonStartCommandæ–¹æ³•ä¹Ÿä¼šè¢«æ‰§è¡Œï¼Œæ­¤æ—¶onStartCommandæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°Intentä¸ºServiceè¢«æ€æ­»å‰æœ€åä¸€æ¬¡è°ƒç”¨onStartCommandæ–¹æ³•æ—¶ä¼ é€’çš„Intent å¯¹äºå…¶è¿”å›å€¼æˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹æ˜¯æ€ä¹ˆå¤„ç†çš„ï¼Œè¿™éœ€è¦å›é¡¾ä¸€ä¸‹ä¸Šä¸€ç¯‡æ–‡ç« åˆ†æçš„handleServiceArgsæ–¹æ³•äº† 12345678910111213141516171819202122232425262728293031323334353637//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; ... int res; if (!data.taskRemoved) &#123; //æ­£å¸¸æƒ…å†µè°ƒç”¨ res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; //ç”¨æˆ·å…³é—­Taskæ ˆæ—¶è°ƒç”¨ s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; //ç¡®ä¿å…¶ä»–å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆ QueuedWork.waitToFinish(); try &#123; //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¼šæ ¹æ®onStartCommandçš„è¿”å›å€¼ï¼Œè°ƒæ•´Serviceæ­»äº¡é‡å»ºç­–ç•¥ //åŒæ—¶ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to start service \" + s + \" with \" + data.args + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œä»Service.onStartCommandå¾—åˆ°è¿”å›å€¼åä»¥å…¶ä½œä¸ºå‚æ•°è°ƒç”¨äº†AMS.serviceDoneExecutingæ–¹æ³• 1234567//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic void serviceDoneExecuting(IBinder token, int type, int startId, int res) &#123; synchronized(this) &#123; ... mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res); &#125;&#125; è½¬äº¤ç»™äº†ActiveServices.serviceDoneExecutingLockedæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javavoid serviceDoneExecutingLocked(ServiceRecord r, int type, int startId, int res) &#123; boolean inDestroying = mDestroyingServices.contains(r); if (r != null) &#123; if (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123; // This is a call from a service start... take care of // book-keeping. r.callStart = true; switch (res) &#123; case Service.START_STICKY_COMPATIBILITY: case Service.START_STICKY: &#123; // We are done with the associated start arguments. r.findDeliveredStart(startId, false, true); // Don't stop if killed. r.stopIfKilled = false; break; &#125; case Service.START_NOT_STICKY: &#123; // We are done with the associated start arguments. r.findDeliveredStart(startId, false, true); if (r.getLastStartId() == startId) &#123; // There is no more work, and this service // doesn't want to hang around if killed. r.stopIfKilled = true; &#125; break; &#125; case Service.START_REDELIVER_INTENT: &#123; // We'll keep this item until they explicitly // call stop for it, but keep track of the fact // that it was delivered. ServiceRecord.StartItem si = r.findDeliveredStart(startId, false, false); if (si != null) &#123; si.deliveryCount = 0; si.doneExecutingCount++; // Don't stop if killed. r.stopIfKilled = true; &#125; break; &#125; case Service.START_TASK_REMOVED_COMPLETE: &#123; // Special processing for onTaskRemoved(). Don't // impact normal onStartCommand() processing. r.findDeliveredStart(startId, true, true); break; &#125; default: throw new IllegalArgumentException( \"Unknown service start result: \" + res); &#125; if (res == Service.START_STICKY_COMPATIBILITY) &#123; r.callStart = false; &#125; &#125; else if (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123; ... &#125; ... &#125; else &#123; ... &#125;&#125; æˆ‘ä»¬å°±åªçœ‹å¯¹Service.onStartCommandçš„è¿”å›å€¼è¿›è¡Œå¤„ç†çš„éƒ¨åˆ† é¦–å…ˆï¼Œä¸ç®¡è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Œéƒ½ä¼šè°ƒç”¨ServiceRecord.findDeliveredStartæ–¹æ³•ï¼Œåªä¸è¿‡å…¥å‚ä¸åŒ 12345678910111213//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.javapublic StartItem findDeliveredStart(int id, boolean taskRemoved, boolean remove) &#123; final int N = deliveredStarts.size(); for (int i=0; i&lt;N; i++) &#123; StartItem si = deliveredStarts.get(i); if (si.id == id &amp;&amp; si.taskRemoved == taskRemoved) &#123; if (remove) deliveredStarts.remove(i); return si; &#125; &#125; return null;&#125; å‰ä¸¤ä¸ªå‚æ•°ï¼Œä¸ç®¡è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Œä¼ è¿›æ¥çš„éƒ½æ˜¯ä¸€æ ·çš„ï¼Œè€Œç¬¬ä¸‰ä¸ªå‚æ•°removeå°±ä¸åŒäº†ï¼Œå½“è¿”å›å€¼ä¸ºSTART_REDELIVER_INTENTçš„æ—¶å€™ï¼Œå®ƒä¸ºfalseï¼Œå…¶ä»–æƒ…å†µéƒ½ä¸ºtrueï¼Œæ„å‘³ç€è¦åˆ é™¤è¿™ä¸ªå·²åˆ†å‘çš„å¯åŠ¨é¡¹ï¼ŒSTART_REDELIVER_INTENTç”±äºéœ€è¦ä¿ç•™æœ€åä¸€æ¬¡è°ƒç”¨onStartCommandæ—¶çš„Intentï¼Œæ‰€ä»¥å®ƒä¸åº”è¯¥è¢«åˆ é™¤ æ¥ç€æˆ‘ä»¬å›åˆ°serviceDoneExecutingLockedæ–¹æ³•ï¼Œå¯ä»¥å‘ç°ï¼ŒSTART_STICKYå’ŒSTART_STICKY_COMPATIBILITYæƒ…å†µä¸‹çš„ServiceRecord.stopIfKilledè¢«ç½®ä¸ºäº†falseï¼Œå…¶ä»–åˆ™è¢«ç½®ä¸ºäº†trueï¼Œè¿™å’Œæˆ‘ä»¬ä¹‹å‰å¯¹ç»“æœçš„æè¿°ä¸åŒå•Šï¼Ÿä¸æ˜¯è¯´å¥½äº†è¿”å›START_REDELIVER_INTENTä¹Ÿä¼šé‡å¯å—ï¼Ÿè¿™æ˜¯å› ä¸ºSTART_REDELIVER_INTENTæ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒçš„é‡å¯ä¸éœ€è¦çœ‹stopIfKilledè¿™ä¸ªæ ‡å¿—ä½ï¼Œè¿™ä¸ªç­‰åˆ°æˆ‘ä»¬åé¢åˆ†æåˆ°æ€ä¹ˆåˆ¤æ–­æ˜¯å¦åº”è¯¥åœæ­¢æœåŠ¡æ—¶å°±çŸ¥é“äº† ä»¥ä¸Šçš„å†…å®¹æˆ‘ä»¬å…ˆè®°ä¸‹æ¥ï¼Œä¼šåœ¨åé¢çš„é‡å¯æµç¨‹ä¸­å‘æŒ¥ä½œç”¨ ç„¶åæˆ‘ä»¬æ¥çœ‹è¿›ç¨‹æ­»äº¡åä¼šå‘ç”Ÿä»€ä¹ˆï¼Œæˆ‘ä»¬æ›¾åœ¨ä¹‹å‰çš„æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ ä¸­æåˆ°è¿‡ï¼Œå½“Appå¯åŠ¨æ—¶ï¼ŒAMSä¼šä¸ºå…¶æ³¨å†Œä¸€ä¸ªAppè¿›ç¨‹æ­»äº¡å›è°ƒAppDeathRecipientï¼Œå½“Appè¿›ç¨‹æ­»äº¡åä¾¿ä¼šå›è°ƒå…¶binderDiedæ–¹æ³• 1234567891011121314151617181920//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javaprivate final class AppDeathRecipient implements IBinder.DeathRecipient &#123; final ProcessRecord mApp; final int mPid; final IApplicationThread mAppThread; AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) &#123; mApp = app; mPid = pid; mAppThread = thread; &#125; @Override public void binderDied() &#123; synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread, true, null); &#125; &#125;&#125; æ¥ç€ä¾¿ä¼šè°ƒç”¨appDiedLockedæ–¹æ³•å¤„ç†è¿›ç¨‹æ­»äº¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javafinal void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied, String reason) &#123; // First check if this ProcessRecord is actually active for the pid. //æ£€æŸ¥pidæ‰€å±ProcessRecordæ˜¯å¦ä¸ä¼ å…¥ProcessRecordç›¸ç¬¦ synchronized (mPidsSelfLocked) &#123; ProcessRecord curProc = mPidsSelfLocked.get(pid); if (curProc != app) &#123; return; &#125; &#125; ... //è®°å½•ç”µæ± ç»Ÿè®¡ä¿¡æ¯ //å¦‚æœAppè¿›ç¨‹å°šæœªæ­»äº¡çš„è¯ï¼Œæ€æ­»è¿›ç¨‹ if (!app.killed) &#123; if (!fromBinderDied) &#123; killProcessQuiet(pid); mProcessList.noteAppKill(app, ApplicationExitInfo.REASON_OTHER, ApplicationExitInfo.SUBREASON_UNKNOWN, reason); &#125; ProcessList.killProcessGroup(app.uid, pid); app.killed = true; &#125; // Clean up already done if the process has been re-started. if (app.pid == pid &amp;&amp; app.thread != null &amp;&amp; app.thread.asBinder() == thread.asBinder()) &#123; //ä¸€èˆ¬æƒ…å†µä¸‹éè‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œå…ˆç½®ä¸ºtrue boolean doLowMem = app.getActiveInstrumentation() == null; boolean doOomAdj = doLowMem; if (!app.killedByAm) &#123; //ä¸é€šè¿‡AMSæ€æ­»çš„è¿›ç¨‹ï¼Œä¸€èˆ¬å°±æ˜¯è¢« Low Memory Killer (LMK) æ€æ­»çš„ ... //æŠ¥å‘Šä¿¡æ¯ //è¢«LMKæ€æ­»ï¼Œè¯´æ˜ç³»ç»Ÿå†…å­˜ä¸è¶³ mAllowLowerMemLevel = true; &#125; else &#123; //é€šè¿‡AMSæ€æ­»çš„è¿›ç¨‹ // Note that we always want to do oom adj to update our state with the // new number of procs. mAllowLowerMemLevel = false; //æ­£å¸¸æƒ…å†µä¸‹éå†…å­˜ä¸è¶³ doLowMem = false; &#125; ... //äº‹ä»¶è®°å½• //ç»§ç»­å¤„ç†Appè¿›ç¨‹æ­»äº¡ handleAppDiedLocked(app, false, true); //è°ƒæ•´è¿›ç¨‹ä¼˜å…ˆçº§ if (doOomAdj) &#123; updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_PROCESS_END); &#125; //å½“å› ä¸ºå†…å­˜ä¸è¶³è€Œæ€æ­»Appè¿›ç¨‹æ—¶ //è°ƒç”¨Appå±‚å„å¤„çš„çš„onLowMemoryæ–¹æ³•ï¼Œé‡Šæ”¾å†…å­˜ if (doLowMem) &#123; doLowMemReportIfNeededLocked(app); &#125; &#125; else if (app.pid != pid) &#123; //æ–°è¿›ç¨‹å·²å¯åŠ¨ // A new process has already been started. ... //æŠ¥å‘Šè®°å½•ä¿¡æ¯ &#125; ...&#125; è¿™é‡Œçš„å…¶ä»–ä»£ç æˆ‘ä»¬éƒ½ä¸ç”¨å…³å¿ƒï¼Œç›´æ¥çœ‹handleAppDiedLockedæ–¹æ³•ç»§ç»­å¤„ç†Appè¿›ç¨‹æ­»äº¡ 12345678910111213141516//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javafinal void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) &#123; ... //æ¸…ç†è¿›ç¨‹çš„ä¸»è¦æ–¹æ³• boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1, false /*replacingPid*/); ...&#125;final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) &#123; ... mServices.killServicesLocked(app, allowRestart); ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè°ƒç”¨äº†ActiveServices.killServicesLockedæ–¹æ³•åœæ­¢è¿˜åœ¨è¿è¡Œä¸­çš„æœåŠ¡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152final void killServicesLocked(ProcessRecord app, boolean allowRestart) &#123; // Clean up any connections this application has to other services. //æ¸…ç†æ‰€æœ‰è¿æ¥ for (int i = app.connections.size() - 1; i &gt;= 0; i--) &#123; ConnectionRecord r = app.connections.valueAt(i); removeConnectionLocked(r, app, null); &#125; updateServiceConnectionActivitiesLocked(app); app.connections.clear(); app.whitelistManager = false; // Clear app state from services. //éå†æ‰€æœ‰æ­£åœ¨è¿è¡Œä¸­çš„æœåŠ¡ for (int i = app.numberOfRunningServices() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = app.getRunningServiceAt(i); synchronized (sr.stats.getBatteryStats()) &#123; sr.stats.stopLaunchedLocked(); &#125; if (sr.app != app &amp;&amp; sr.app != null &amp;&amp; !sr.app.isPersistent()) &#123; //è®°å½•æœåŠ¡å·²åœæ­¢ sr.app.stopService(sr); //æ›´æ–°ç»‘å®šçš„å®¢æˆ·ç«¯uids sr.app.updateBoundClientUids(); &#125; sr.setProcess(null); sr.isolatedProc = null; sr.executeNesting = 0; sr.forceClearTracker(); if (mDestroyingServices.remove(sr)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"killServices remove destroying \" + sr); &#125; final int numClients = sr.bindings.size(); for (int bindingi=numClients-1; bindingi&gt;=0; bindingi--) &#123; IntentBindRecord b = sr.bindings.valueAt(bindingi); //é‡Šæ”¾å¯¹æœåŠ¡Binderçš„å¼•ç”¨ b.binder = null; //é‡ç½® b.requested = b.received = b.hasBound = false; // If this binding is coming from a cached process and is asking to keep // the service created, then we'll kill the cached process as well -- we // don't want to be thrashing around restarting processes that are only // there to be cached. ... //éå†å®¢æˆ·ç«¯è¿›ç¨‹ï¼ˆå®é™…ä¸Šæ²¡åšä»»ä½•äº‹ï¼‰ &#125; &#125; ServiceMap smap = getServiceMapLocked(app.userId); // Now do remaining service cleanup. for (int i = app.numberOfRunningServices() - 1; i &gt;= 0; i--) &#123; ServiceRecord sr = app.getRunningServiceAt(i); // Unless the process is persistent, this process record is going away, // so make sure the service is cleaned out of it. //éæŒä¹…åŒ–è¿›ç¨‹ if (!app.isPersistent()) &#123; //è®°å½•æœåŠ¡å·²åœæ­¢ app.stopService(sr); //æ›´æ–°ç»‘å®šçš„å®¢æˆ·ç«¯uids app.updateBoundClientUids(); &#125; // Sanity check: if the service listed for the app is not one // we actually are maintaining, just let it drop. //ä¸€è‡´æ€§æ£€æŸ¥ final ServiceRecord curRec = smap.mServicesByInstanceName.get(sr.instanceName); if (curRec != sr) &#123; if (curRec != null) &#123; Slog.wtf(TAG, \"Service \" + sr + \" in process \" + app + \" not same as in map: \" + curRec); &#125; continue; &#125; // Any services running in the application may need to be placed // back in the pending list. //å…è®¸é‡å¯ï¼Œä½†Serviceå´©æºƒçš„æ¬¡æ•°è¶…å‡ºé‡è¯•ä¸Šé™ï¼ˆé»˜è®¤ä¸º16ï¼‰ï¼Œå¹¶ä¸”å®ƒä¸æ˜¯ç³»ç»Ÿåº”ç”¨ if (allowRestart &amp;&amp; sr.crashCount &gt;= mAm.mConstants.BOUND_SERVICE_MAX_CRASH_RETRY &amp;&amp; (sr.serviceInfo.applicationInfo.flags &amp;ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; ... //è®°å½• //åœæ­¢æœåŠ¡ bringDownServiceLocked(sr); &#125; else if (!allowRestart || !mAm.mUserController.isUserRunning(sr.userId, 0)) &#123; //ä¸å…è®¸é‡å¯æˆ–è€…æœåŠ¡è¿›ç¨‹æ‰€åœ¨ç”¨æˆ·ä¸åœ¨è¿è¡Œï¼Œåœæ­¢æœåŠ¡ bringDownServiceLocked(sr); &#125; else &#123; //å°è¯•è°ƒåº¦é‡å¯æœåŠ¡ final boolean scheduled = scheduleServiceRestartLocked(sr, true /* allowCancel */); // Should the service remain running? Note that in the // extreme case of so many attempts to deliver a command // that it failed we also will stop it here. if (!scheduled) &#123; //æœªè°ƒåº¦é‡å¯ //åœæ­¢æœåŠ¡ bringDownServiceLocked(sr); &#125; else if (sr.canStopIfKilled(false /* isStartCanceled */)) &#123; // Update to stopped state because the explicit start is gone. The service is // scheduled to restart for other reason (e.g. connections) so we don't bring // down it. //å°†æœåŠ¡çš„å¯åŠ¨çŠ¶æ€æ›´æ–°ä¸ºåœæ­¢ sr.startRequested = false; ... //è®°å½• &#125; &#125; &#125; //ä¸å…è®¸é‡å¯çš„è¯ if (!allowRestart) &#123; //åœæ­¢æ‰€æœ‰æœåŠ¡ app.stopAllServices(); //æ¸…ç†ç»‘å®šçš„å®¢æˆ·ç«¯uids app.clearBoundClientUids(); // Make sure there are no more restarting services for this process. //ç¡®ä¿è¿™ä¸ªè¿›ç¨‹ä¸å†ä¼šé‡å¯æœåŠ¡ï¼Œæ¸…ç†æ‰€æœ‰å¾…é‡å¯å¾…å¯åŠ¨çš„æœåŠ¡ for (int i=mRestartingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r = mRestartingServices.get(i); if (r.processName.equals(app.processName) &amp;&amp; r.serviceInfo.applicationInfo.uid == app.info.uid) &#123; mRestartingServices.remove(i); clearRestartingIfNeededLocked(r); &#125; &#125; for (int i=mPendingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r = mPendingServices.get(i); if (r.processName.equals(app.processName) &amp;&amp; r.serviceInfo.applicationInfo.uid == app.info.uid) &#123; mPendingServices.remove(i); &#125; &#125; &#125; // Make sure we have no more records on the stopping list. //æ¸…ç†æ‰€æœ‰åœæ­¢ä¸­çš„æœåŠ¡ int i = mDestroyingServices.size(); while (i &gt; 0) &#123; i--; ServiceRecord sr = mDestroyingServices.get(i); if (sr.app == app) &#123; sr.forceClearTracker(); mDestroyingServices.remove(i); &#125; &#125; //æ¸…ç†æ‰€æœ‰æ‰§è¡Œä¸­çš„æœåŠ¡ //è¿™é‡Œçš„æ‰§è¡Œä¸­æŒ‡çš„æ˜¯æœ‰äº‹åŠ¡æ­£åœ¨è¿è¡Œï¼Œæ¯”å¦‚è¯´æ­£åœ¨åœæ­¢è¿‡ç¨‹ä¸­ï¼Œä¸æ˜¯æŒ‡è¿è¡Œä¸­ app.executingServices.clear();&#125; è¿™é‡Œåšäº†å„ç§æ¸…ç†å·¥ä½œï¼Œå®¢æˆ·ç«¯è¿›ç¨‹çš„æ¸…ç†å‘€ï¼ŒæœåŠ¡ç«¯è¿›ç¨‹çš„æ¸…ç†ï¼Œç„¶åå°±æ˜¯Serviceé‡å¯çš„æ ¸å¿ƒï¼ŒscheduleServiceRestartLockedæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final boolean scheduleServiceRestartLocked(ServiceRecord r, boolean allowCancel) &#123; //ç³»ç»Ÿæ­£åœ¨å…³æœºï¼Œç›´æ¥è¿”å› if (mAm.mAtmInternal.isShuttingDown()) &#123; return false; &#125; //ä¸€è‡´æ€§æ£€æŸ¥ ServiceMap smap = getServiceMapLocked(r.userId); if (smap.mServicesByInstanceName.get(r.instanceName) != r) &#123; ServiceRecord cur = smap.mServicesByInstanceName.get(r.instanceName); Slog.wtf(TAG, \"Attempting to schedule restart of \" + r + \" when found in map: \" + cur); return false; &#125; final long now = SystemClock.uptimeMillis(); final String reason; if ((r.serviceInfo.applicationInfo.flags &amp;ApplicationInfo.FLAG_PERSISTENT) == 0) &#123; //å¯¹äºéç³»ç»Ÿåº”ç”¨ //æœåŠ¡è‡³å°‘è¦è¿‡å¤šé•¿æ—¶é—´æ‰èƒ½é‡å¯ï¼Œé»˜è®¤1000ms long minDuration = mAm.mConstants.SERVICE_RESTART_DURATION; //æœåŠ¡è¢«æ€æ­»é‡å¯åéœ€è¦è¿è¡Œå¤šé•¿æ—¶é—´ï¼Œé»˜è®¤60s long resetTime = mAm.mConstants.SERVICE_RESET_RUN_DURATION; boolean canceled = false; // Any delivered but not yet finished starts should be put back // on the pending list. //å¯¹åº”ç€è¿”å›å€¼ä¸ºSTART_REDELIVER_INTENTçš„æƒ…å†µ final int N = r.deliveredStarts.size(); if (N &gt; 0) &#123; for (int i=N-1; i&gt;=0; i--) &#123; ServiceRecord.StartItem si = r.deliveredStarts.get(i); si.removeUriPermissionsLocked(); if (si.intent == null) &#123; // We'll generate this again if needed. &#125; else if (!allowCancel || (si.deliveryCount &lt; ServiceRecord.MAX_DELIVERY_COUNT &amp;&amp; si.doneExecutingCount &lt; ServiceRecord.MAX_DONE_EXECUTING_COUNT)) &#123; //å¦‚æœè¯¥å¯åŠ¨é¡¹çš„å¤±è´¥æ¬¡æ•°å°äºæœ€å¤§å®¹å¿æ¬¡æ•° //MAX_DELIVERY_COUNTé»˜è®¤ä¸º3 //MAX_DONE_EXECUTING_COUNTé»˜è®¤ä¸º6 r.pendingStarts.add(0, si); //è¿™ç§æƒ…å†µä¸‹å»¶æ—¶æ˜¯ç°åœ¨è·ç¦»å¯åŠ¨æ—¶é—´çš„ä¸¤å€ long dur = SystemClock.uptimeMillis() - si.deliveredTime; dur *= 2; if (minDuration &lt; dur) minDuration = dur; if (resetTime &lt; dur) resetTime = dur; &#125; else &#123; //å¦‚æœè¯¥å¯åŠ¨é¡¹çš„å¤±è´¥æ¬¡æ•°å¤§äºç­‰äºæœ€å¤§å®¹å¿æ¬¡æ•° canceled = true; &#125; &#125; r.deliveredStarts.clear(); &#125; if (allowCancel) &#123; //åˆ¤æ–­æ˜¯å¦åº”è¯¥åœæ­¢ï¼ˆåªè€ƒè™‘éç»‘å®šå¯åŠ¨çš„æƒ…å†µï¼‰ final boolean shouldStop = r.canStopIfKilled(canceled); if (shouldStop &amp;&amp; !r.hasAutoCreateConnections()) &#123; // Nothing to restart. //å¦‚æœåº”è¯¥åœæ­¢ï¼Œç›´æ¥è¿”å› return false; &#125; reason = (r.startRequested &amp;&amp; !shouldStop) ? \"start-requested\" : \"connection\"; &#125; else &#123; reason = \"always\"; &#125; r.totalRestartCount++; if (r.restartDelay == 0) &#123; //ç¬¬ä¸€æ¬¡é‡å¯çš„æƒ…å†µ r.restartCount++; r.restartDelay = minDuration; &#125; else if (r.crashCount &gt; 1) &#123; //Serviceæ‰€åœ¨è¿›ç¨‹åœ¨Serviceè¿è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿå´©æºƒå¯¼è‡´é‡å¯çš„è¯ //é‡å¯å»¶æ—¶ä¸º 30min * (å´©æºƒæ¬¡æ•° - 1) r.restartDelay = mAm.mConstants.BOUND_SERVICE_CRASH_RESTART_DURATION * (r.crashCount - 1); &#125; else &#123; //éç¬¬ä¸€æ¬¡é‡å¯çš„æƒ…å†µ // If it has been a \"reasonably long time\" since the service // was started, then reset our restart duration back to // the beginning, so we don't infinitely increase the duration // on a service that just occasionally gets killed (which is // a normal case, due to process being killed to reclaim memory). if (now &gt; (r.restartTime+resetTime)) &#123; //å¦‚æœæœåŠ¡é‡å¯åè¿è¡Œè¾¾åˆ°äº†ä¸€å®šæ—¶é—´ï¼Œåˆ™é‡å¯å»¶æ—¶ä¸º r.restartCount = 1; r.restartDelay = minDuration; &#125; else &#123; //å¦‚æœæœåŠ¡é‡å¯åè¿è¡Œæ²¡æœ‰è¾¾åˆ°ä¸€å®šæ—¶é—´ï¼ˆçŸ­æ—¶é—´å†…åˆè¦é‡å¯ï¼‰ //åˆ™å¢é•¿é‡å¯å»¶æ—¶ï¼Œé»˜è®¤å› å­ä¸º4 r.restartDelay *= mAm.mConstants.SERVICE_RESTART_DURATION_FACTOR; if (r.restartDelay &lt; minDuration) &#123; r.restartDelay = minDuration; &#125; &#125; &#125; //ç¡®å®šé‡å¯æ—¶é—´ r.nextRestartTime = now + r.restartDelay; // Make sure that we don't end up restarting a bunch of services // all at the same time. //ç¡®ä¿ä¸ä¼šåœ¨åŒä¸€æ—¶é—´å¯åŠ¨å¤§é‡æœåŠ¡ boolean repeat; do &#123; repeat = false; final long restartTimeBetween = mAm.mConstants.SERVICE_MIN_RESTART_TIME_BETWEEN; for (int i=mRestartingServices.size()-1; i&gt;=0; i--) &#123; ServiceRecord r2 = mRestartingServices.get(i); if (r2 != r &amp;&amp; r.nextRestartTime &gt;= (r2.nextRestartTime-restartTimeBetween) &amp;&amp; r.nextRestartTime &lt; (r2.nextRestartTime+restartTimeBetween)) &#123; r.nextRestartTime = r2.nextRestartTime + restartTimeBetween; r.restartDelay = r.nextRestartTime - now; repeat = true; break; &#125; &#125; &#125; while (repeat); &#125; else &#123; //å¯¹äºç³»ç»Ÿè¿›ç¨‹ï¼Œç«‹é©¬é‡å¯ // Persistent processes are immediately restarted, so there is no // reason to hold of on restarting their services. r.totalRestartCount++; r.restartCount = 0; r.restartDelay = 0; r.nextRestartTime = now; reason = \"persistent\"; &#125; //æ·»åŠ åˆ°é‡å¯åˆ—è¡¨ä¸­ if (!mRestartingServices.contains(r)) &#123; r.createdFromFg = false; mRestartingServices.add(r); r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now); &#125; //å–æ¶ˆå‰å°æœåŠ¡é€šçŸ¥ cancelForegroundNotificationLocked(r); //é€šè¿‡Handlerè°ƒåº¦é‡å¯ mAm.mHandler.removeCallbacks(r.restarter); mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime); r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay; ... //äº‹ä»¶è®°å½• return true;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†å‡ ä»¶äº‹æƒ…ï¼Œä¸€æ˜¯åˆ¤æ–­æœåŠ¡éœ€ä¸éœ€è¦é‡å¯ï¼ŒäºŒæ˜¯è®¡ç®—æœåŠ¡çš„ä¸‹æ¬¡é‡å¯æ—¶é—´ï¼Œæœ€åé€šè¿‡Handleræ‰§è¡Œå»¶æ—¶é‡å¯ è¿˜è®°å¾—æˆ‘ä»¬å‰é¢è¯´çš„å½“è¿”å›å€¼ä¸ºSTART_REDELIVER_INTENTæ—¶ï¼Œä¸ä¼šä»ServiceRecord.deliveredStartsä¸­åˆ é™¤å¯åŠ¨é¡¹å—ï¼Ÿè¿™é‡Œå°±ä½“ç°å‡ºäº†è¿™ä¸€ç‚¹ï¼Œéå†æ•´ä¸ªdeliveredStartsåˆ—è¡¨ï¼Œä»ä¸­æ‰¾å‡ºç¬¦åˆé‡å¯æ¡ä»¶çš„å¯åŠ¨é¡¹ï¼Œå°†å…¶åŠ å…¥åˆ°pendingStartsåˆ—è¡¨ä¸­ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé‡å¯å»¶æ—¶ä¸ºç°åœ¨è·ç¦»å¯åŠ¨æ—¶é—´çš„ä¸¤å€ï¼Œæ‰€ä»¥ä¸€èˆ¬æƒ…å†µä¸‹START_REDELIVER_INTENTæ¯”START_STICKYé‡å¯çš„è¦æ›´æ…¢ æ¥ä¸‹æ¥ä¾¿è¦åˆ¤æ–­æœåŠ¡éœ€ä¸éœ€è¦é‡å¯ï¼Œè¿™é‡Œè°ƒç”¨äº†ServiceRecord.canStopIfKilledæ–¹æ³• 1234//frameworks/base/services/core/java/com/android/server/am/ServiceRecord.javaboolean canStopIfKilled(boolean isStartCanceled) &#123; return startRequested &amp;&amp; (stopIfKilled || isStartCanceled) &amp;&amp; pendingStarts.isEmpty();&#125; ä¹‹å‰è¯´è¿‡ï¼Œå¦‚æœè¿”å›å€¼ä¸ºSTART_STICKYæˆ–START_STICKY_COMPATIBILITYï¼Œé‚£è¿™é‡Œçš„stopIfKilledå°±ä¸ºfalseï¼Œæ‰€ä»¥æ•´ä½“ä¼šè¿”å›falseï¼Œè€Œå¯¹äºè¿”å›å€¼START_REDELIVER_INTENTè€Œè¨€ï¼Œä¹‹å‰å·²ç»è¿›è¡Œè¿‡æ“ä½œï¼Œå°†å¯åŠ¨é¡¹æ·»åŠ åˆ°pendingStartsåˆ—è¡¨ä¸­äº†ï¼Œæ‰€ä»¥åªè¦è¿™é‡Œä¸ºfalseï¼Œæ•´ä½“å°±ä¸ºfalseï¼ŒstopIfKilledçš„å€¼å°±ä¸é‡è¦äº† æœ€åå°±æ˜¯é€šè¿‡Handleræ‰§è¡Œå»¶æ—¶é‡å¯äº†ï¼Œè¿™é‡ŒHandlerä¼ å…¥çš„Runnableæ˜¯ServiceRecord.restarterï¼Œå®ƒæ˜¯åœ¨æœåŠ¡å¯åŠ¨ï¼Œè°ƒç”¨retrieveServiceLockedæ–¹æ³•æ—¶è¢«åˆ›å»ºçš„ 1234567891011121314//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate class ServiceRestarter implements Runnable &#123; private ServiceRecord mService; void setService(ServiceRecord service) &#123; mService = service; &#125; public void run() &#123; synchronized(mAm) &#123; performServiceRestartLocked(mService); &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ä¸€å®šçš„å»¶æ—¶åï¼Œä¼šè°ƒç”¨åˆ°performServiceRestartLockedæ–¹æ³•é‡å¯æœåŠ¡ 123456789101112131415161718192021//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javafinal void performServiceRestartLocked(ServiceRecord r) &#123; if (!mRestartingServices.contains(r)) &#123; return; &#125; if (!isServiceNeededLocked(r, false, false)) &#123; // Paranoia: is this service actually needed? In theory a service that is not // needed should never remain on the restart list. In practice... well, there // have been bugs where this happens, and bad things happen because the process // ends up just being cached, so quickly killed, then restarted again and again. // Let's not let that happen. Slog.wtf(TAG, \"Restarting service that is not needed: \" + r); return; &#125; try &#123; //å‚è€ƒä¸Šä¸€ç¯‡æ–‡ç« ï¼ŒServiceå¯åŠ¨æµç¨‹ bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, true, false); &#125; catch (TransactionTooLargeException e) &#123; // Ignore, it's been logged and nothing upstack cares. &#125;&#125; æœ€ç»ˆè°ƒç”¨äº†bringUpServiceLockedæ–¹æ³•å¯åŠ¨æœåŠ¡ï¼Œè¿™ä¸€éƒ¨åˆ†å¯ä»¥çœ‹ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Serviceå¯åŠ¨æµç¨‹ ä¸­çš„åˆ†æï¼Œè¿˜è®°å¾—ä¸Šä¸€ç¯‡æ–‡ç« ä¸­åˆ†æçš„realStartServiceLockedæ–¹æ³•ä¸­ï¼Œæœ‰ä¸€ä¸ªé€»è¾‘æ˜¯ï¼šå¦‚æœServiceå·²ç»å¯åŠ¨ï¼Œå¹¶ä¸”æ²¡æœ‰å¯åŠ¨é¡¹ï¼Œåˆ™æ„å»ºä¸€ä¸ªå‡çš„å¯åŠ¨å‚æ•°ä¾›onStartCommandä½¿ç”¨ å—ï¼Ÿä¹‹å‰çœ‹åˆ°è¿™ä¸ªé€»è¾‘çš„æ—¶å€™æˆ‘è¿˜æœ‰äº›ç–‘æƒ‘ä¸ºä»€ä¹ˆéœ€è¦è¿™æ ·ï¼Œç°åœ¨å°±è±ç„¶å¼€æœ—äº†ï¼ŒåŸæ¥è¿™æ˜¯ä¸ºServiceé‡å¯åšçš„é€»è¾‘ï¼Œè€Œå¯¹äºè¿”å›å€¼START_REDELIVER_INTENTè€Œè¨€ï¼ŒpendingStartsåˆ—è¡¨æœ¬èº«å°±ä¸ä¸ºç©ºï¼Œç›´æ¥æ­£å¸¸æ‰§è¡Œå¯åŠ¨ä»»åŠ¡å°±å¯ä»¥äº† æ€»ç»“è‡³æ­¤ï¼Œæ•´ä¸ªServiceç¯‡ç« å°±åˆ°æ­¤ç»“æŸäº†ï¼Œé€šè¿‡è¿™æ¬¡çš„å†™ä½œï¼Œæˆ‘è‡ªèº«ä¹Ÿæ˜¯å—ç›ŠåŒªæµ…ï¼Œäº†è§£åˆ°äº†å¾ˆå¤šæˆ‘ä»¥å‰ä¸çŸ¥é“çš„çŸ¥è¯†ï¼Œä¹Ÿçº æ­£äº†ä¸€äº›æˆ‘ä»¥å‰é”™è¯¯çš„è®¤çŸ¥ï¼Œå¦‚æœä¹Ÿèƒ½å¸®åˆ°æ­£åœ¨çœ‹æ–‡ç« çš„ä½ ä»¬ï¼Œé‚£å°±å†å¥½ä¸è¿‡äº†","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}]},{"title":"Androidæºç åˆ†æ - Serviceå¯åŠ¨æµç¨‹","slug":"android/aosp/Androidæºç åˆ†æ-Serviceå¯åŠ¨æµç¨‹","date":"2023-08-24T08:10:53.000Z","updated":"2023-10-25T04:46:27.805Z","comments":true,"path":"2023/08/24/android/aosp/Androidæºç åˆ†æ-Serviceå¯åŠ¨æµç¨‹/","link":"","permalink":"http://yoursite.com/2023/08/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å·²ç»åˆ†æè¿‡äº†å››å¤§ç»„ä»¶ä¸­Activityå’ŒContentProviderçš„å¯åŠ¨æµç¨‹ï¼Œè¿™æ¬¡æˆ‘ä»¬å°±æ¥è®²è®²å››å¤§ç»„ä»¶ä¹‹ä¸€çš„Serviceæ˜¯å¦‚ä½•å¯åŠ¨å’Œç»‘å®šçš„ æµç¨‹å›¾åœ¨æŸ¥é˜…èµ„æ–™çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘å‘ç°æœ‰äº›åšä¸»ä¼šå°†æ¢³ç†å¥½çš„æµç¨‹å›¾è´´åœ¨å¼€å¤´ï¼Œæˆ‘è§‰å¾—è¿™æ ·æœ‰åŠ©äºä»å®è§‚ä¸Šå»ç†è§£æºç çš„æ•´ä¸ªæµç¨‹å’Œè®¾è®¡ç†å¿µï¼Œæ‰€ä»¥ä»¥åçš„æ–‡ç« æˆ‘éƒ½ä¼šå°½é‡å°†æºç æ¢³ç†æˆæµç¨‹å›¾ï¼Œä»¥ä¾¿å¤§å®¶ç†è§£ å…¥å£å¯åŠ¨Serviceæœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€æ˜¯startServiceï¼Œä¸€æ˜¯bindServiceï¼Œå®ƒä»¬æœ€ç»ˆçš„å®ç°éƒ½åœ¨ContextImplä¸­ Context.startServiceå½“Serviceé€šè¿‡è¿™ç§æ–¹å¼å¯åŠ¨åï¼Œä¼šä¸€ç›´è¿è¡Œä¸‹å»ï¼Œç›´åˆ°å¤–éƒ¨è°ƒç”¨äº†stopServiceæˆ–å†…éƒ¨è°ƒç”¨stopSelf 1234567891011121314151617181920212223242526272829303132333435363738//frameworks/base/core/java/android/app/ContextImpl.javapublic ComponentName startService(Intent service) &#123; warnIfCallingFromSystemProcess(); return startServiceCommon(service, false, mUser);&#125;private ComponentName startServiceCommon(Intent service, boolean requireForeground, UserHandle user) &#123; try &#123; //ç¡®ä¿Intentæœ‰æ•ˆ validateServiceIntent(service); //è·¨è¿›ç¨‹å‡†å¤‡ service.prepareToLeaveProcess(this); //è°ƒç”¨AMS.startService ComponentName cn = ActivityManager.getService().startService( mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(getContentResolver()), requireForeground, getOpPackageName(), getAttributionTag(), user.getIdentifier()); //é€šè¿‡AMSå±‚è¿”å›çš„ComponentName.packageNameæ¥åˆ¤æ–­æ˜¯å¦å‡ºé”™ä»¥åŠé”™è¯¯ç±»å‹ if (cn != null) &#123; if (cn.getPackageName().equals(\"!\")) &#123; throw new SecurityException( \"Not allowed to start service \" + service + \" without permission \" + cn.getClassName()); &#125; else if (cn.getPackageName().equals(\"!!\")) &#123; throw new SecurityException( \"Unable to start service \" + service + \": \" + cn.getClassName()); &#125; else if (cn.getPackageName().equals(\"?\")) &#123; throw new IllegalStateException( \"Not allowed to start service \" + service + \": \" + cn.getClassName()); &#125; &#125; return cn; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; ä»ä»£ç å¯ä»¥çœ‹å‡ºï¼Œè¿™é‡Œå°±æ˜¯åšäº†ä¸€ä¸‹ç®€å•çš„æ ¡éªŒï¼Œç„¶åä¾¿è°ƒç”¨äº†AMS.startServiceå¯åŠ¨Serviceï¼Œæœ€ç»ˆé€šè¿‡è¿”å›çš„ComponentNameä¸­çš„packageNameæ¥åˆ¤æ–­æ˜¯å¦å‡ºé”™ä»¥åŠé”™è¯¯ç±»å‹ 123456789101112131415161718192021222324252627282930313233//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, String callingFeatureId, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"startService\"); // Refuse possible leaked file descriptors //æ ¡éªŒIntentï¼Œä¸å…è®¸å…¶æºå¸¦fd if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; //è°ƒç”¨æ–¹åŒ…åä¸èƒ½ä¸ºç©º if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res; try &#123; //è°ƒç”¨ActiveServices.startServiceLockedæ–¹æ³• res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, requireForeground, callingPackage, callingFeatureId, userId); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; return res; &#125;&#125; åŒæ ·ï¼Œè¿™é‡Œåšäº†ä¸€äº›ç®€å•çš„æ£€æŸ¥ï¼Œç„¶åè°ƒç”¨ActiveServices.startServiceLockedæ–¹æ³•ï¼ŒActiveServicesæ˜¯ä¸€ä¸ªè¾…åŠ©AMSè¿›è¡ŒServiceç®¡ç†çš„ç±»ï¼ŒåŒ…æ‹¬Serviceçš„å¯åŠ¨ã€ç»‘å®šå’Œåœæ­¢ç­‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, @Nullable String callingFeatureId, final int userId) throws TransactionTooLargeException &#123; return startServiceLocked(caller, service, resolvedType, callingPid, callingUid, fgRequired, callingPackage, callingFeatureId, userId, false);&#125;ComponentName startServiceLocked(IApplicationThread caller, Intent service, String resolvedType, int callingPid, int callingUid, boolean fgRequired, String callingPackage, @Nullable String callingFeatureId, final int userId, boolean allowBackgroundActivityStarts) throws TransactionTooLargeException &#123; //åˆ¤æ–­è°ƒç”¨æ–¹æ˜¯å¦ä¸ºå‰å° final boolean callerFg; if (caller != null) &#123; final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting service \" + service); &#125; callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND; &#125; else &#123; callerFg = true; &#125; //æŸ¥æ‰¾å¾…å¯åŠ¨Service ServiceLookupResult res = retrieveServiceLocked(service, null, resolvedType, callingPackage, callingPid, callingUid, userId, true, callerFg, false, false); //å¦‚æœæ‰¾ä¸åˆ°å¾…å¯åŠ¨Serviceï¼Œç›´æ¥è¿”å›null if (res == null) &#123; return null; &#125; //å¦‚æœå¾…å¯åŠ¨çš„Serviceæ‰€åœ¨packageå’Œuidæ— æ³•ä¸è°ƒç”¨æ–¹packageå’Œuidå»ºç«‹å…³è”ï¼Œåˆ™æ— æ³•å¯åŠ¨Service //è¿”å›å¼‚å¸¸ComponentNameï¼Œç”±ä¸Šå±‚æŠ›å‡ºSecurityExceptionå¼‚å¸¸ if (res.record == null) &#123; return new ComponentName(\"!\", res.permission != null ? res.permission : \"private to package\"); &#125; ServiceRecord r = res.record; //è¯•å›¾ç”¨ä¸€ä¸ªä¸å­˜åœ¨çš„ç”¨æˆ·å¯åŠ¨Service if (!mAm.mUserController.exists(r.userId)) &#123; Slog.w(TAG, \"Trying to start service with non-existent user! \" + r.userId); return null; &#125; // If we're starting indirectly (e.g. from PendingIntent), figure out whether // we're launching into an app in a background state. This keys off of the same // idleness state tracking as e.g. O+ background service start policy. //Serviceæ‰€åœ¨åº”ç”¨æœªå¯åŠ¨æˆ–å¤„åœ¨åå° final boolean bgLaunch = !mAm.isUidActiveLocked(r.appInfo.uid); // If the app has strict background restrictions, we treat any bg service // start analogously to the legacy-app forced-restrictions case, regardless // of its target SDK version. //æ£€æŸ¥Serviceæ‰€åœ¨åº”ç”¨åå°å¯åŠ¨é™åˆ¶ boolean forcedStandby = false; if (bgLaunch &amp;&amp; appRestrictedAnyInBackground(r.appInfo.uid, r.packageName)) &#123; forcedStandby = true; &#125; // If this is a direct-to-foreground start, make sure it is allowed as per the app op. boolean forceSilentAbort = false; if (fgRequired) &#123; //ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ //æƒé™æ£€æŸ¥ final int mode = mAm.getAppOpsManager().checkOpNoThrow( AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName); switch (mode) &#123; //é»˜è®¤å’Œå…è®¸éƒ½å¯ä»¥ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ case AppOpsManager.MODE_ALLOWED: case AppOpsManager.MODE_DEFAULT: // All okay. break; //ä¸å…è®¸çš„è¯ï¼Œå›é€€åˆ°ä½œä¸ºæ™®é€šåå°æœåŠ¡å¯åŠ¨ case AppOpsManager.MODE_IGNORED: // Not allowed, fall back to normal start service, failing siliently // if background check restricts that. Slog.w(TAG, \"startForegroundService not allowed due to app op: service \" + service + \" to \" + r.shortInstanceName + \" from pid=\" + callingPid + \" uid=\" + callingUid + \" pkg=\" + callingPackage); fgRequired = false; forceSilentAbort = true; break; //é”™è¯¯çš„è¯ç›´æ¥è¿”å›ï¼Œç”±ä¸Šå±‚æŠ›å‡ºSecurityExceptionå¼‚å¸¸ default: return new ComponentName(\"!!\", \"foreground not allowed as per app op\"); &#125; &#125; // If this isn't a direct-to-foreground start, check our ability to kick off an // arbitrary service //å¦‚æœä¸æ˜¯ä»å‰å°å¯åŠ¨ //startRequestedè¡¨ç¤ºServiceæ˜¯å¦ç”±startServiceæ–¹å¼æ‰€å¯åŠ¨ï¼ŒfgRequiredè¡¨ç¤ºä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ if (forcedStandby || (!r.startRequested &amp;&amp; !fgRequired)) &#123; // Before going further -- if this app is not allowed to start services in the // background, then at this point we aren't going to let it period. //æœåŠ¡æ˜¯å¦å…è®¸åœ¨åå°å¯åŠ¨ final int allowed = mAm.getAppStartModeLocked(r.appInfo.uid, r.packageName, r.appInfo.targetSdkVersion, callingPid, false, false, forcedStandby); //å¦‚æœä¸å…è®¸ï¼Œåˆ™æ— æ³•å¯åŠ¨æœåŠ¡ if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123; //é™é»˜çš„åœæ­¢å¯åŠ¨ if (allowed == ActivityManager.APP_START_MODE_DELAYED || forceSilentAbort) &#123; // In this case we are silently disabling the app, to disrupt as // little as possible existing apps. return null; &#125; if (forcedStandby) &#123; // This is an O+ app, but we might be here because the user has placed // it under strict background restrictions. Don't punish the app if it's // trying to do the right thing but we're denying it for that reason. if (fgRequired) &#123; return null; &#125; &#125; // This app knows it is in the new model where this operation is not // allowed, so tell it what has happened. //æ˜ç¡®çš„å‘ŠçŸ¥ä¸å…è®¸å¯åŠ¨ï¼Œä¸Šå±‚æŠ›å‡ºå¼‚å¸¸ UidRecord uidRec = mAm.mProcessList.getUidRecordLocked(r.appInfo.uid); return new ComponentName(\"?\", \"app is in background uid \" + uidRec); &#125; &#125; // At this point we've applied allowed-to-start policy based on whether this was // an ordinary startService() or a startForegroundService(). Now, only require that // the app follow through on the startForegroundService() -&gt; startForeground() // contract if it actually targets O+. //å¯¹äºtargetSdk 26ä»¥ä¸‹ï¼ˆAndroid 8.0ä»¥ä¸‹ï¼‰çš„åº”ç”¨æ¥è¯´ï¼Œä¸éœ€è¦ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ if (r.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O &amp;&amp; fgRequired) &#123; fgRequired = false; &#125; //æ£€æŸ¥é€šè¿‡Intentè¢«ä¸´æ—¶æˆæƒçš„Uris NeededUriGrants neededGrants = mAm.mUgmInternal.checkGrantUriPermissionFromIntent( service, callingUid, r.packageName, r.userId); // If permissions need a review before any of the app components can run, // we do not start the service and launch a review activity if the calling app // is in the foreground passing it a pending intent to start the service when // review is completed. // XXX This is not dealing with fgRequired! //å¦‚æœå¾…å¯åŠ¨çš„Serviceéœ€è¦ç›¸åº”æƒé™ï¼Œåˆ™éœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æƒé™åï¼Œå†è¿›è¡Œå¯åŠ¨ if (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage, callingFeatureId, callingUid, service, callerFg, userId)) &#123; return null; &#125; //å–æ¶ˆä¹‹å‰çš„Serviceé‡å¯ä»»åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰ if (unscheduleServiceRestartLocked(r, callingUid, false)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"START SERVICE WHILE RESTART PENDING: \" + r); &#125; r.lastActivity = SystemClock.uptimeMillis(); //è¡¨ç¤ºServiceæ˜¯å¦ç”±startServiceæ–¹å¼æ‰€å¯åŠ¨çš„ r.startRequested = true; r.delayedStop = false; //æ˜¯å¦ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ r.fgRequired = fgRequired; //æ„é€ å¯åŠ¨å‚æ•° r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), service, neededGrants, callingUid)); //ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ if (fgRequired) &#123; // We are now effectively running a foreground service. ... //ä½¿ç”¨ServiceStateè®°å½• ... //é€šè¿‡AppOpsServiceç›‘æ§ &#125; final ServiceMap smap = getServiceMapLocked(r.userId); boolean addToStarting = false; //å¯¹äºåå°å¯åŠ¨çš„éå‰å°æœåŠ¡ï¼Œéœ€è¦åˆ¤æ–­å…¶æ˜¯å¦éœ€è¦å»¶è¿Ÿå¯åŠ¨ if (!callerFg &amp;&amp; !fgRequired &amp;&amp; r.app == null &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123; //è·å–Serviceæ‰€å¤„è¿›ç¨‹ä¿¡æ¯ ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, false); //æ²¡æœ‰å¯¹åº”è¿›ç¨‹æˆ–è¿›ç¨‹çŠ¶æ€çº§åˆ«ä½äº [è¿›ç¨‹åœ¨åå°è¿è¡ŒReceiver] if (proc == null || proc.getCurProcState() &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123; // If this is not coming from a foreground caller, then we may want // to delay the start if there are already other background services // that are starting. This is to avoid process start spam when lots // of applications are all handling things like connectivity broadcasts. // We only do this for cached processes, because otherwise an application // can have assumptions about calling startService() for a service to run // in its own process, and for that process to not be killed before the // service is started. This is especially the case for receivers, which // may start a service in onReceive() to do some additional work and have // initialized some global state as part of that. //å¯¹äºä¹‹å‰å·²ç»è®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨çš„æœåŠ¡ï¼Œç›´æ¥è¿”å› if (r.delayed) &#123; // This service is already scheduled for a delayed start; just leave // it still waiting. return r.name; &#125; //å¦‚æœå½“å‰æ­£åœ¨åå°å¯åŠ¨çš„Serviceæ•°å¤§äºç­‰äºå…è®¸åŒæ—¶åœ¨åå°å¯åŠ¨çš„æœ€å¤§æœåŠ¡æ•° //å°†è¿™ä¸ªServiceè®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨ if (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123; // Something else is starting, delay! smap.mDelayedStartList.add(r); r.delayed = true; return r.name; &#125; //æ·»åŠ åˆ°æ­£åœ¨å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ addToStarting = true; &#125; else if (proc.getCurProcState() &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123; //è¿›ç¨‹çŠ¶æ€ä¸º [æ­£åœ¨è¿è¡ŒServiceçš„åå°è¿›ç¨‹] æˆ– [æ­£åœ¨è¿è¡ŒReceiverçš„åå°è¿›ç¨‹] æ—¶ // We slightly loosen when we will enqueue this new service as a background // starting service we are waiting for, to also include processes that are // currently running other services or receivers. //æ·»åŠ åˆ°æ­£åœ¨å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ addToStarting = true; &#125; &#125; //å¦‚æœå…è®¸Serviceåå°å¯åŠ¨Activityï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°ç™½åå•ä¸­ if (allowBackgroundActivityStarts) &#123; r.whitelistBgActivityStartsOnServiceStart(); &#125; //ç»§ç»­å¯åŠ¨Service ComponentName cmp = startServiceInnerLocked(smap, service, r, callerFg, addToStarting); //æ£€æŸ¥æ˜¯å¦å…è®¸å‰å°æœåŠ¡ä½¿ç”¨while-in-useæƒé™ if (!r.mAllowWhileInUsePermissionInFgs) &#123; r.mAllowWhileInUsePermissionInFgs = shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, callingPid, callingUid, service, r, allowBackgroundActivityStarts); &#125; return cmp;&#125; è¿™ä¸ªæ–¹æ³•æ¶‰åŠåˆ°å¾ˆå¤šå‰åå°åˆ¤æ–­ï¼Œæˆ‘æƒ³è¿™é‡Œçš„å‰åå°å…¶å®åˆ†ä¸ºä¸‰ä¸ªæ¦‚å¿µï¼Œä¸€æ˜¯è°ƒç”¨æ–¹Appæ˜¯å¦åœ¨å‰å°ï¼ŒäºŒæ˜¯Serviceæ–¹Appæ˜¯å¦åœ¨å‰å°ï¼Œä¸‰æ˜¯Serviceæ˜¯å¦ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ï¼Œå½“ç„¶ï¼Œå¤§éƒ¨åˆ†æƒ…å†µå¯åŠ¨çš„éƒ½æ˜¯Appå†…çš„Serviceï¼Œå³ä¸€äºŒä¸­çš„å‰åå°çŠ¶æ€æ˜¯ä¸€è‡´çš„ï¼Œä½†ä¹Ÿä¸æ’é™¤å¯åŠ¨å…¶ä»–Appçš„Serviceè¿™ç§æƒ…å†µï¼Œæ‰€ä»¥è¿™é‡Œè¿˜æ˜¯éœ€è¦å¥½å¥½åŒºåˆ†å¼€æ¥ è¿™ä¸ªæ–¹æ³•çœ‹èµ·æ¥å¾ˆé•¿ï¼Œä½†æ€»ä¹‹éƒ½æ˜¯ä¸€äº›Serviceå¯åŠ¨å‰çš„é¢„å¤„ç†å·¥ä½œï¼Œä¸»è¦åšäº†ä»¥ä¸‹å‡ ç‚¹å·¥ä½œï¼š åˆ¤æ–­è°ƒç”¨æ–¹è¿›ç¨‹æ˜¯å¦åœ¨å‰å°ï¼ˆcallerFgï¼‰ï¼šå¯¹äºè°ƒç”¨æ–¹åœ¨åå°å¯åŠ¨çš„Serviceï¼Œéœ€è¦åˆ¤æ–­å…¶æ˜¯å¦éœ€è¦å»¶è¿Ÿå¯åŠ¨ è°ƒç”¨retrieveServiceLockedæŸ¥æ‰¾å¾…å¯åŠ¨Serviceä¿¡æ¯ï¼ˆServiceRecordï¼‰ å„ç§æ£€æŸ¥ï¼Œä¸€æ—¦å‘ç°ä¸æ»¡è¶³å¯åŠ¨æ¡ä»¶å°±ç»ˆæ­¢å¯åŠ¨Service æ£€æŸ¥Serviceæ‰€åœ¨åº”ç”¨çš„å‰åå°çŠ¶æ€ä»¥åŠåå°å¯åŠ¨é™åˆ¶ï¼Œä¸ç¬¦åˆæ¡ä»¶åˆ™ç»ˆæ­¢å¯åŠ¨Service åˆ¤æ–­æ˜¯å¦å¯ä»¥ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ å¦‚æœå¾…å¯åŠ¨çš„Serviceéœ€è¦ç›¸åº”æƒé™ï¼Œåˆ™éœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æƒé™åï¼Œå†è¿›è¡Œå¯åŠ¨ å–æ¶ˆä¹‹å‰çš„Serviceé‡å¯ä»»åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰ è®¾ç½®ServiceRecordçŠ¶æ€ï¼ŒåŒ…æ‹¬ä¸Šæ¬¡æ´»åŠ¨æ—¶é—´ï¼Œæ˜¯å¦ç”±startServiceæ–¹å¼æ‰€å¯åŠ¨çš„ï¼Œæ˜¯å¦ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ç­‰ å¦‚æœä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨ï¼Œåˆ™éœ€è¦è¿›è¡Œè®°å½•å’Œç›‘æ§ å¯¹äºåå°å¯åŠ¨çš„éå‰å°æœåŠ¡ï¼Œéœ€è¦åˆ¤æ–­å…¶æ˜¯å¦éœ€è¦å»¶è¿Ÿå¯åŠ¨ è°ƒç”¨startServiceInnerLockedç»§ç»­å¯åŠ¨Service 12345678910111213141516171819202122232425262728293031323334//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) throws TransactionTooLargeException &#123; ... //è®°å½• //å¯åŠ¨å‰åˆå§‹åŒ– r.callStart = false; ... //è®°å½• //æ‹‰èµ·æœåŠ¡ï¼Œå¦‚æœæœåŠ¡æœªå¯åŠ¨ï¼Œåˆ™ä¼šå¯åŠ¨æœåŠ¡å¹¶è°ƒç”¨å…¶onCreateå’ŒonStartCommandæ–¹æ³• //å¦‚æœæœåŠ¡å·²å¯åŠ¨ï¼Œç”±äºä¹‹å‰æ„é€ äº†å¯åŠ¨å‚æ•°ï¼Œåˆ™ä¼šç›´æ¥è°ƒç”¨å…¶onStartCommandæ–¹æ³• String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false, false); if (error != null) &#123; return new ComponentName(\"!!\", error); &#125; if (r.startRequested &amp;&amp; addToStarting) &#123; //å¯¹äºåå°å¯åŠ¨æœåŠ¡çš„æƒ…å†µ //æ˜¯å¦ä¸ºç¬¬ä¸€ä¸ªåå°å¯åŠ¨çš„æœåŠ¡ boolean first = smap.mStartingBackground.size() == 0; //æ·»åŠ åˆ°æ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ smap.mStartingBackground.add(r); //è®¾ç½®åå°å¯åŠ¨æœåŠ¡è¶…æ—¶æ—¶é—´ï¼ˆé»˜è®¤15ç§’ï¼‰ r.startingBgTimeout = SystemClock.uptimeMillis() + mAm.mConstants.BG_START_TIMEOUT; //å¦‚æœä¸ºç¬¬ä¸€ä¸ªåå°å¯åŠ¨çš„æœåŠ¡ï¼Œåˆ™ä»£è¡¨åé¢æš‚æ—¶æ²¡æœ‰æ­£åœ¨åå°å¯åŠ¨çš„æœåŠ¡äº† //æ­¤æ—¶å°†ä¹‹å‰è®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨çš„æœåŠ¡è°ƒåº¦å‡ºæ¥åå°å¯åŠ¨ if (first) &#123; smap.rescheduleDelayedStartsLocked(); &#125; &#125; else if (callerFg || r.fgRequired) &#123; //å¯¹äºè°ƒç”¨æ–¹è¿›ç¨‹ä¸ºå‰å°æˆ–ä½œä¸ºå‰å°æœåŠ¡å¯åŠ¨çš„æƒ…å†µ //å°†æ­¤Serviceä»æ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨å’Œå»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ //å¦‚æœæ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­å­˜åœ¨æ­¤æœåŠ¡çš„è¯ï¼Œå°†ä¹‹å‰è®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨çš„æœåŠ¡è°ƒåº¦å‡ºæ¥åå°å¯åŠ¨ smap.ensureNotStartingBackgroundLocked(r); &#125; return r.name;&#125; åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œé¦–å…ˆä¼šè°ƒç”¨bringUpServiceLockedæ–¹æ³•æ‹‰èµ·æœåŠ¡ï¼Œç„¶åæ ¹æ®æœåŠ¡æ˜¯å¦ä¸ºå‰å°å¯åŠ¨ï¼Œåˆ†åˆ«è°ƒç”¨ServiceMap.rescheduleDelayedStartsLockedå’ŒServiceMap.ensureNotStartingBackgroundLockedæ–¹æ³•ä»åå°å»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨mDelayedStartListä¸­ä¸æ–­åœ°è°ƒåº¦å¯åŠ¨æœåŠ¡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException &#123; //å¦‚æœServiceæ‰€åœ¨çš„è¿›ç¨‹å­˜åœ¨ï¼Œå¹¶ä¸”å…¶IApplicationThreadä¹Ÿå­˜åœ¨ //è¯´æ˜æœåŠ¡å·²å¯åŠ¨ï¼ˆå› ä¸ºåœ¨å¯åŠ¨æœåŠ¡æ—¶ï¼Œä¼šç»™ServiceRecord.appèµ‹å€¼ï¼Œå¹¶ä¸”app.threadä¸ä¸ºnullè¯´æ˜è¿›ç¨‹æ²¡æœ‰è¢«æ€æ­»ï¼‰ //æ­¤æ—¶ç›´æ¥æ‹‰èµ·Service.onStartCommandæ–¹æ³• if (r.app != null &amp;&amp; r.app.thread != null) &#123; sendServiceArgsLocked(r, execInFg, false); return null; &#125; //å¦‚æœæœåŠ¡æ­£åœ¨é‡å¯ä¸­ï¼Œåˆ™ä»€ä¹ˆéƒ½ä¸åšï¼Œç›´æ¥è¿”å› if (!whileRestarting &amp;&amp; mRestartingServices.contains(r)) &#123; // If waiting for a restart, then do nothing. return null; &#125; // We are now bringing the service up, so no longer in the // restarting state. //Serviceé©¬ä¸Šå¯åŠ¨ï¼Œå°†å…¶ä»é‡å¯ä¸­æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ï¼Œå¹¶æ¸…é™¤å…¶é‡å¯ä¸­çŠ¶æ€ if (mRestartingServices.remove(r)) &#123; clearRestartingIfNeededLocked(r); &#125; // Make sure this service is no longer considered delayed, we are starting it now. //èµ°åˆ°è¿™é‡Œï¼Œéœ€è¦ç¡®ä¿æ­¤æœåŠ¡ä¸å†è¢«è§†ä¸ºå»¶è¿Ÿå¯åŠ¨ï¼ŒåŒæ—¶å°†å…¶ä»å»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ if (r.delayed) &#123; getServiceMapLocked(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; // Make sure that the user who owns this service is started. If not, // we don't want to allow it to run. //ç¡®ä¿Serviceæ‰€åœ¨çš„ç”¨æˆ·å·²å¯åŠ¨ if (!mAm.mUserController.hasStartedUserState(r.userId)) &#123; //åœæ­¢æœåŠ¡ bringDownServiceLocked(r); return msg; &#125; // Service is now being launched, its package can't be stopped. //Serviceå³å°†å¯åŠ¨ï¼ŒServiceæ‰€å±çš„Appä¸è¯¥ä¸ºstoppedçŠ¶æ€ //å°†AppçŠ¶æ€ç½®ä¸ºunstoppedï¼Œè®¾ç½®ä¼‘çœ çŠ¶æ€ä¸ºfalse AppGlobals.getPackageManager().setPackageStoppedState( r.packageName, false, r.userId); //æœåŠ¡æ‰€åœ¨è¿›ç¨‹æ˜¯å¦ä¸ºéš”ç¦»è¿›ç¨‹ï¼ŒæŒ‡æœåŠ¡æ˜¯å¦åœ¨å…¶è‡ªå·±çš„ç‹¬ç«‹è¿›ç¨‹ä¸­è¿è¡Œ final boolean isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != 0; final String procName = r.processName; HostingRecord hostingRecord = new HostingRecord(\"service\", r.instanceName); ProcessRecord app; if (!isolated) &#123; //ééš”ç¦»è¿›ç¨‹ //è·å–è¿›ç¨‹çš„ProcessRecordå¯¹è±¡ app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null &amp;&amp; app.thread != null) &#123; //å°†Appæ·»åŠ è‡³è¿›ç¨‹ä¸­è¿è¡Œçš„åŒ…åˆ—è¡¨ä¸­ app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats); //æ¥ç€å¯åŠ¨Service realStartServiceLocked(r, app, execInFg); return null; // If a dead object exception was thrown -- fall through to // restart the application. &#125; &#125; else &#123; //éš”ç¦»è¿›ç¨‹ // If this service runs in an isolated process, then each time // we call startProcessLocked() we will get a new isolated // process, starting another process if we are currently waiting // for a previous process to come up. To deal with this, we store // in the service any current isolated process it is running in or // waiting to have come up. //è·å–æœåŠ¡ä¹‹å‰æ‰€åœ¨çš„è¿›ç¨‹ app = r.isolatedProc; //è¾…åŠ©zygoteè¿›ç¨‹ï¼Œç”¨äºåˆ›å»ºisolated_appè¿›ç¨‹æ¥æ¸²æŸ“ä¸å¯ä¿¡çš„webå†…å®¹ï¼Œå…·æœ‰æœ€ä¸ºä¸¥æ ¼çš„å®‰å…¨é™åˆ¶ if (WebViewZygote.isMultiprocessEnabled() &amp;&amp; r.serviceInfo.packageName.equals(WebViewZygote.getPackageName())) &#123; hostingRecord = HostingRecord.byWebviewZygote(r.instanceName); &#125; //åº”ç”¨zygoteè¿›ç¨‹ï¼Œä¸å¸¸è§„zygoteåˆ›å»ºçš„åº”ç”¨ç›¸æ¯”å—åˆ°æ›´å¤šé™åˆ¶ if ((r.serviceInfo.flags &amp; ServiceInfo.FLAG_USE_APP_ZYGOTE) != 0) &#123; hostingRecord = HostingRecord.byAppZygote(r.instanceName, r.definingPackageName, r.definingUid); &#125; &#125; // Not running -- get it started, and enqueue this service record // to be executed when the app comes up. //å¦‚æœServiceæ‰€åœ¨è¿›ç¨‹å°šæœªå¯åŠ¨ if (app == null &amp;&amp; !permissionsReviewRequired) &#123; // TODO (chriswailes): Change the Zygote policy flags based on if the launch-for-service // was initiated from a notification tap or not. //å¯åŠ¨Appè¿›ç¨‹ if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, hostingRecord, ZYGOTE_POLICY_FLAG_EMPTY, false, isolated, false)) == null) &#123; //å¦‚æœå¯åŠ¨è¿›ç¨‹å¤±è´¥ï¼Œåœæ­¢æœåŠ¡ bringDownServiceLocked(r); return msg; &#125; if (isolated) &#123; //å¦‚æœæ˜¯éš”ç¦»è¿›ç¨‹ï¼Œå°†è¿™æ¬¡å¯åŠ¨çš„è¿›ç¨‹è®°å½•ä¿å­˜ä¸‹æ¥ r.isolatedProc = app; &#125; &#125; //å¯¹äºè¦å¯åŠ¨çš„å‰å°æœåŠ¡ï¼ŒåŠ å…¥åˆ°ä¸´æ—¶ç™½åå•ï¼Œæš‚æ—¶ç»•è¿‡çœç”µæ¨¡å¼ if (r.fgRequired) &#123; mAm.tempWhitelistUidLocked(r.appInfo.uid, SERVICE_START_FOREGROUND_TIMEOUT, \"fg-service-launch\"); &#125; //å°†å¯åŠ¨çš„æœåŠ¡æ·»åŠ åˆ°mPendingServicesåˆ—è¡¨ä¸­ //å¦‚æœæœåŠ¡è¿›ç¨‹å°šæœªå¯åŠ¨ï¼Œè¿›ç¨‹åœ¨å¯åŠ¨çš„è¿‡ç¨‹ä¸­ä¼šæ£€æŸ¥æ­¤åˆ—è¡¨å¹¶å¯åŠ¨éœ€è¦å¯åŠ¨çš„Service if (!mPendingServices.contains(r)) &#123; mPendingServices.add(r); &#125; //Serviceè¢«è¦æ±‚stopï¼Œåœæ­¢æœåŠ¡ if (r.delayedStop) &#123; // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; stopServiceLocked(r); &#125; &#125; return null;&#125; è¿™ä¸ªæ–¹æ³•çœ‹èµ·æ¥é•¿ï¼Œå…¶å®åšçš„äº‹æƒ…å¹¶ä¸å¤šï¼š å¦‚æœServiceå·²ç»å¯åŠ¨ï¼Œåˆ™è°ƒç”¨sendServiceArgsLockedæ–¹æ³•ç›´æ¥æ‹‰èµ·Service.onStartCommandæ–¹æ³• å„ç§æ£€æŸ¥å‡†å¤‡æ“ä½œï¼ˆå¾…é‡å¯ã€ç”¨æˆ·æ˜¯å¦å¯åŠ¨ç­‰ï¼Œå…·ä½“è§æ³¨é‡Šï¼‰ å¦‚æœServiceæ‰€åœ¨è¿›ç¨‹å·²å¯åŠ¨ï¼Œè°ƒç”¨realStartServiceLockedæ–¹æ³•æ¥ç€å¯åŠ¨Service å¦‚æœServiceæ‰€åœ¨è¿›ç¨‹æœªå¯åŠ¨ï¼Œè°ƒç”¨AMS.startProcessLockedæ–¹æ³•å¯åŠ¨è¿›ç¨‹ å°†è¦å¯åŠ¨çš„Serviceæ·»åŠ åˆ°mPendingServicesåˆ—è¡¨ä¸­ï¼Œå¯¹äºServiceæ‰€åœ¨è¿›ç¨‹æœªå¯åŠ¨çš„è¿™ç§æƒ…å†µï¼Œåœ¨è¿›ç¨‹çš„å¯åŠ¨è¿‡ç¨‹ä¸­ä¼šæ£€æŸ¥æ­¤åˆ—è¡¨å¹¶å¯åŠ¨éœ€è¦å¯åŠ¨çš„Serviceï¼ˆå³æ­¤Serviceï¼‰ ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¥ï¼ŒServiceçš„å¯åŠ¨åˆ†ä¸ºä¸¤ä¸ªåˆ†æ”¯ï¼Œä¸€ä¸ªæ˜¯è¿›ç¨‹å·²å¯åŠ¨ï¼Œä¸€ä¸ªæ˜¯è¿›ç¨‹æœªå¯åŠ¨ è¿›ç¨‹æœªå¯åŠ¨åœ¨è¿›ç¨‹æœªå¯åŠ¨çš„æƒ…å†µä¸‹ï¼Œè¿™é‡Œä¼šè°ƒç”¨AMS.startProcessLockedæ–¹æ³•å¯åŠ¨è¿›ç¨‹ï¼Œæ¥ç€ç­‰å¾…è¿›ç¨‹å¯åŠ¨å®Œæˆåï¼Œä¼šè°ƒç”¨åˆ°AMS.attachApplicationLockedæ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­æœ‰ä¸€æ®µå…³äºServiceå¯åŠ¨çš„ä»£ç ï¼š 123456789101112131415//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javaprivate boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... // Find any services that should be running in this process... //æ£€æŸ¥æ˜¯å¦æœ‰Servicesç­‰å¾…å¯åŠ¨ if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™é‡Œè°ƒç”¨äº†ActiveServices.attachApplicationLockedæ–¹æ³•å»å¯åŠ¨å¾…å¯åŠ¨çš„Service å…³äºAppè¿›ç¨‹å¯åŠ¨çš„æµç¨‹è¯¦è§æˆ‘ä¹‹å‰çš„æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ ï¼Œè¿™é‡Œå°±ä¸èµ˜è¿°äº† ActiveServices.attachApplicationLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaboolean attachApplicationLocked(ProcessRecord proc, String processName) throws RemoteException &#123; boolean didSomething = false; // Update the app background restriction of the caller //æ›´æ–°Serviceæ‰€åœ¨Appåå°é™åˆ¶ proc.mState.setBackgroundRestricted(appRestrictedAnyInBackground( proc.uid, proc.info.packageName)); // Collect any services that are waiting for this process to come up. //å¯åŠ¨mPendingServicesåˆ—è¡¨å†…ï¼Œè¯¥è¿›ç¨‹ä¸‹çš„æ‰€æœ‰Service if (mPendingServices.size() &gt; 0) &#123; ServiceRecord sr = null; try &#123; for (int i=0; i&lt;mPendingServices.size(); i++) &#123; sr = mPendingServices.get(i); if (proc != sr.isolationHostProc &amp;&amp; (proc.uid != sr.appInfo.uid || !processName.equals(sr.processName))) &#123; continue; &#125; final IApplicationThread thread = proc.getThread(); final int pid = proc.getPid(); final UidRecord uidRecord = proc.getUidRecord(); mPendingServices.remove(i); i--; //å°†Appæ·»åŠ è‡³è¿›ç¨‹ä¸­è¿è¡Œçš„åŒ…åˆ—è¡¨ä¸­ proc.addPackage(sr.appInfo.packageName, sr.appInfo.longVersionCode, mAm.mProcessStats); //å¯åŠ¨Service realStartServiceLocked(sr, proc, thread, pid, uidRecord, sr.createdFromFg, true); didSomething = true; //å¦‚æœæ­¤Serviceä¸å†éœ€è¦äº†ï¼Œåˆ™åœæ­¢å®ƒ //e.g. é€šè¿‡bindServiceå¯åŠ¨çš„æœåŠ¡ï¼Œä½†æ­¤æ—¶è°ƒç”¨bindServiceçš„Activityå·²æ­»äº¡ if (!isServiceNeededLocked(sr, false, false)) &#123; // We were waiting for this service to start, but it is actually no // longer needed. This could happen because bringDownServiceIfNeeded // won't bring down a service that is pending... so now the pending // is done, so let's drop it. bringDownServiceLocked(sr, true); &#125; /* Will be a no-op if nothing pending */ //æ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ mAm.updateOomAdjPendingTargetsLocked(OomAdjuster.OOM_ADJ_REASON_START_SERVICE); &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; // Also, if there are any services that are waiting to restart and // would run in this process, now is a good time to start them. It would // be weird to bring up the process but arbitrarily not let the services // run at this point just because their restart time hasn't come up. //Appè¢«æ€é‡å¯æœºåˆ¶ï¼Œåç»­æ–‡ç« å†è¯¦ç»†è¯´æ˜ if (mRestartingServices.size() &gt; 0) &#123; ... &#125; return didSomething;&#125; è¿™ä¸ªæ–¹æ³•ä¼šä»mPendingServicesåˆ—è¡¨å†…å¯»æ‰¾è¯¥è¿›ç¨‹ä¸‹çš„æ‰€æœ‰å¾…å¯åŠ¨Serviceï¼Œç„¶åè°ƒç”¨ActiveServices.realStartServiceLockedæ–¹æ³•å¯åŠ¨å®ƒ è¿›ç¨‹å·²å¯åŠ¨å¯¹äºè¿›ç¨‹å·²å¯åŠ¨çš„æƒ…å†µï¼Œæˆ‘ä»¬é€šè¿‡ActiveServices.bringUpServiceLockedæ–¹æ³•ä¹Ÿå¯ä»¥å¾—çŸ¥ï¼Œè°ƒç”¨äº†ActiveServices.realStartServiceLockedæ–¹æ³•ï¼Œæ‰€ä»¥ä¸ç®¡è¿›ç¨‹æ˜¯å¦å¯åŠ¨ï¼Œæœ€ç»ˆéƒ½ä¼šæ®Šé€”åŒå½’èµ°åˆ°ActiveServices.realStartServiceLockedæ–¹æ³•å¯åŠ¨Service ActiveServices.realStartServiceLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//frameworks/base/services/core/java/com/android/server/am/ActiveServices.java/** * Note the name of this method should not be confused with the started services concept. * The \"start\" here means bring up the instance in the client, and this method is called * from bindService() as well. */private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException &#123; //IApplicationThreadä¸å­˜åœ¨åˆ™æŠ›ç§»é™¤ //å³ç¡®ä¿ActivityThreadå­˜åœ¨ if (app.thread == null) &#123; throw new RemoteException(); &#125; //ä¸ºServiceRecordè®¾ç½®æ‰€å±è¿›ç¨‹ r.setProcess(app); r.restartTime = r.lastActivity = SystemClock.uptimeMillis(); //åœ¨æ­¤è¿›ç¨‹ä¸­å°†Serviceè®°å½•ä¸ºè¿è¡Œä¸­ //è¿”å›å€¼ä¸ºæ­¤Serviceæ˜¯å¦ä¹‹å‰æœªå¯åŠ¨ final boolean newService = app.startService(r); //è®°å½•Serviceæ‰§è¡Œæ“ä½œå¹¶è®¾ç½®è¶…æ—¶å›è°ƒ //å‰å°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º20sï¼Œåå°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º200s bumpServiceExecutingLocked(r, execInFg, \"create\"); //æ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ mAm.updateLruProcessLocked(app, false, null); updateServiceForegroundLocked(r.app, /* oomAdj= */ false); mAm.updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_START_SERVICE); boolean created = false; try &#123; ... //è®°å½• //è®°å½•ä¿¡æ¯ mAm.notifyPackageUse(r.serviceInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_SERVICE); //è®¾ç½®è¿›ç¨‹çŠ¶æ€ app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦åˆ›å»ºService app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo), app.getReportedProcState()); //æ˜¾ç¤ºå‰å°æœåŠ¡é€šçŸ¥ r.postNotification(); created = true; &#125; catch (DeadObjectException e) &#123; //æ€æ­»è¿›ç¨‹ mAm.appDiedLocked(app, \"Died when creating service\"); throw e; &#125; finally &#123; //å¦‚æœæ²¡èƒ½æˆåŠŸåˆ›å»ºService if (!created) &#123; // Keep the executeNesting count accurate. //ä¿è¯executeNestingè®¡æ•°çš„å‡†ç¡® final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); // Cleanup. //åœæ­¢æœåŠ¡ï¼Œæ¸…é™¤ä¿¡æ¯ if (newService) &#123; app.stopService(r); r.setProcess(null); &#125; // Retry. //é‡è¯• if (!inDestroying) &#123; scheduleServiceRestartLocked(r, false); &#125; &#125; &#125; //å…è®¸ç®¡ç†ç™½åå•ï¼Œå¦‚çœç”µæ¨¡å¼ç™½åå• if (r.whitelistManager) &#123; app.whitelistManager = true; &#125; //æ‰§è¡ŒService.onBindæ–¹æ³•ï¼ˆé€šè¿‡bindServiceå¯åŠ¨çš„æƒ…å†µä¸‹ï¼‰ requestServiceBindingsLocked(r, execInFg); //æ›´æ–°æ˜¯å¦æœ‰ä¸Serviceå»ºç«‹è¿æ¥çš„Activity updateServiceClientActivitiesLocked(app, null, true); //æ·»åŠ ç»‘å®šåˆ°Serviceæ‰€åœ¨è¿›ç¨‹çš„UID if (newService &amp;&amp; created) &#123; app.addBoundClientUidsOfNewService(r); &#125; // If the service is in the started state, and there are no // pending arguments, then fake up one so its onStartCommand() will // be called. //å¦‚æœServiceå·²ç»å¯åŠ¨ï¼Œå¹¶ä¸”æ²¡æœ‰å¯åŠ¨é¡¹ï¼Œåˆ™æ„å»ºä¸€ä¸ªå‡çš„å¯åŠ¨å‚æ•°ä¾›onStartCommandä½¿ç”¨ if (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == 0) &#123; r.pendingStarts.add(new ServiceRecord.StartItem(r, false, r.makeNextStartId(), null, null, 0)); &#125; //æ‹‰èµ·Service.onStartCommandæ–¹æ³• sendServiceArgsLocked(r, execInFg, true); //èµ°åˆ°è¿™é‡Œï¼Œéœ€è¦ç¡®ä¿æ­¤æœåŠ¡ä¸å†è¢«è§†ä¸ºå»¶è¿Ÿå¯åŠ¨ï¼ŒåŒæ—¶å°†å…¶ä»å»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ if (r.delayed) &#123; getServiceMapLocked(r.userId).mDelayedStartList.remove(r); r.delayed = false; &#125; //Serviceè¢«è¦æ±‚stopï¼Œåœæ­¢æœåŠ¡ if (r.delayedStop) &#123; // Oh and hey we've already been asked to stop! r.delayedStop = false; if (r.startRequested) &#123; stopServiceLocked(r); &#125; &#125;&#125; åˆ›å»ºServiceåˆ°äº†è¿™ä¸€æ­¥ï¼Œè¿›ç¨‹ç†åº”å¯åŠ¨å’Œåˆå§‹åŒ–å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥å°±è¯¥å®é™…çš„å»åˆ›å»ºServiceå¹¶å¯åŠ¨å®ƒäº†ï¼Œé¦–å…ˆåˆ›å»ºServiceè¿™ä¸€å—æˆ‘ä»¬çœ‹app.thread.scheduleCreateServiceæ–¹æ³•ï¼Œè¿™é‡Œçš„appæ˜¯ProcessRecordï¼Œé‡Œé¢çš„threadæ˜¯IApplicationThreadï¼ŒActivityThreadä¸­çš„å†…éƒ¨ç±» 12345678910111213//frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; //æ›´æ–°è¿›ç¨‹çŠ¶æ€ updateProcessState(processState, false); //å°†åˆ›å»ºServiceçš„å¿…è¦ä¿¡æ¯åŒ…è£… CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; //é€šè¿‡Handlerå‘é€Message sendMessage(H.CREATE_SERVICE, s);&#125; è¿™é‡Œå°†åˆ›å»ºServiceçš„å¿…è¦ä¿¡æ¯åŒ…è£…æˆCreateServiceDataå¯¹è±¡åï¼Œé€šè¿‡Handlerå‘é€Messageå¤„ç†æœåŠ¡åˆ›å»º 1234567891011//frameworks/base/core/java/android/app/ActivityThread.javapublic void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case CREATE_SERVICE: handleCreateService((CreateServiceData)msg.obj); break; ... &#125; ...&#125; ActivityThreadçš„Handleråœ¨æ¥æ”¶åˆ°CREATE_SERVICEæ¶ˆæ¯åè°ƒç”¨äº†handleCreateServiceæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleCreateService(CreateServiceData data) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. //æ­¤æ—¶ä¸è¦è¿›è¡ŒGC unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; //åˆ›å»ºContext ContextImpl context = ContextImpl.createAppContext(this, packageInfo); //åˆ›å»ºæˆ–è·å–Applicationï¼ˆåˆ°äº†è¿™é‡Œè¿›ç¨‹çš„åˆå§‹åŒ–åº”è¯¥éƒ½å®Œæˆäº†ï¼Œæ‰€ä»¥æ˜¯ç›´æ¥è·å–Applicationï¼‰ Application app = packageInfo.makeApplication(false, mInstrumentation); java.lang.ClassLoader cl = packageInfo.getClassLoader(); //é€šè¿‡AppComponentFactoryåå°„åˆ›å»ºServiceå®ä¾‹ service = packageInfo.getAppFactory() .instantiateService(cl, data.info.name, data.intent); // Service resources must be initialized with the same loaders as the application // context. //åŠ è½½èµ„æº context.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); context.setOuterContext(service); //åˆå§‹åŒ– service.attach(context, this, data.info.name, data.token, app, ActivityManager.getService()); //æ‰§è¡ŒonCreateå›è°ƒ service.onCreate(); //ä¿å­˜è¿è¡Œä¸­çš„Service mServices.put(data.token, service); try &#123; //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¸­ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( \"Unable to create service \" + data.info.name + \": \" + e.toString(), e); &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼ŒServiceçš„åˆ›å»ºå’Œä¹‹å‰æ–‡ç« ä¸­æ‰€åˆ†æçš„Activityçš„åˆ›å»ºæµç¨‹åŸºæœ¬ä¸€è‡´ï¼Œéƒ½æ˜¯åˆ›å»ºContextï¼Œé€šè¿‡AppComponentFactoryåå°„å®ä¾‹åŒ–å¯¹è±¡ï¼Œç„¶ååŠ è½½èµ„æºï¼Œattachåšç»‘å®šï¼Œæœ€åæ‰§è¡ŒonCreateå›è°ƒ 123456//frameworks/base/core/java/android/app/AppComponentFactory.javapublic @NonNull Service instantiateService(@NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Service) cl.loadClass(className).newInstance();&#125; å¦‚æœæ²¡æœ‰ç‰¹åˆ«åœ¨AndroidManifest.xmlä¸­è®¾ç½®android:appComponentFactoryçš„è¯ï¼Œé»˜è®¤çš„å®ç°å°±æ˜¯è¿™æ ·ï¼Œé€šè¿‡ä¼ è¿›æ¥çš„ClassLoaderå’ŒclassNameåå°„å®ä¾‹åŒ–Serviceå¯¹è±¡ 12345678910111213141516171819//frameworks/base/core/java/android/app/Service.javapublic final void attach( Context context, ActivityThread thread, String className, IBinder token, Application application, Object activityManager) &#123; //ç»‘å®šBaseContext attachBaseContext(context); mThread = thread; // NOTE: unused - remove? mClassName = className; //ä¿å­˜ServiceRecord mToken = token; mApplication = application; mActivityManager = (IActivityManager)activityManager; //å¯åŠ¨å…¼å®¹æ€§è®¾ç½® mStartCompatibility = getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.ECLAIR; //è®¾ç½®å†…å®¹æ•è·åŠŸèƒ½ setContentCaptureOptions(application.getContentCaptureOptions());&#125; attachæ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œåšäº†ä¸€äº›ç»‘å®šContextç­‰åŸºæœ¬æ“ä½œ æœ€åè°ƒç”¨onCreateæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•é»˜è®¤æ˜¯ä¸ªç©ºå®ç°ï¼Œè®©ç»§æ‰¿Serviceçš„ç±»å»å®ç°è¿™ä¸ªæ–¹æ³• å¯åŠ¨ServiceServiceåˆ›å»ºå®Œæˆåå°±è¯¥å¯åŠ¨å®ƒäº†ï¼Œè¿™é‡Œå¯¹åº”ç€ActiveServices.realStartServiceLockedæ–¹æ³•ä¸­è°ƒç”¨çš„sendServiceArgsLockedæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final void sendServiceArgsLocked(ServiceRecord r, boolean execInFg, boolean oomAdjusted) throws TransactionTooLargeException &#123; //å¦‚æœå¾…å¯åŠ¨é¡¹åˆ—è¡¨ä¸­æ²¡æœ‰å†…å®¹åˆ™ç›´æ¥è¿”å› final int N = r.pendingStarts.size(); if (N == 0) &#123; return; &#125; ArrayList&lt;ServiceStartArgs&gt; args = new ArrayList&lt;&gt;(); //éå†å¾…å¯åŠ¨é¡¹ while (r.pendingStarts.size() &gt; 0) &#123; ServiceRecord.StartItem si = r.pendingStarts.remove(0); //å¦‚æœåœ¨å¤šä¸ªå¯åŠ¨é¡¹ä¸­æœ‰å‡å¯åŠ¨é¡¹ï¼Œåˆ™è·³è¿‡å‡å¯åŠ¨é¡¹ //ä½†å¦‚æœè¿™ä¸ªå‡å¯åŠ¨é¡¹æ˜¯å”¯ä¸€çš„å¯åŠ¨é¡¹åˆ™ä¸è¦è·³è¿‡å®ƒï¼Œè¿™æ˜¯ä¸ºäº†æ”¯æŒonStartCommand(null)çš„æƒ…å†µ if (si.intent == null &amp;&amp; N &gt; 1) &#123; // If somehow we got a dummy null intent in the middle, // then skip it. DO NOT skip a null intent when it is // the only one in the list -- this is to support the // onStartCommand(null) case. continue; &#125; si.deliveredTime = SystemClock.uptimeMillis(); r.deliveredStarts.add(si); si.deliveryCount++; //å¤„ç†Uriæƒé™ if (si.neededGrants != null) &#123; mAm.mUgmInternal.grantUriPermissionUncheckedFromIntent(si.neededGrants, si.getUriPermissionsLocked()); &#125; //æˆæƒè®¿é—®æƒé™ mAm.grantImplicitAccess(r.userId, si.intent, si.callingId, UserHandle.getAppId(r.appInfo.uid) ); //è®°å½•Serviceæ‰§è¡Œæ“ä½œå¹¶è®¾ç½®è¶…æ—¶å›è°ƒ //å‰å°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º20sï¼Œåå°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º200s bumpServiceExecutingLocked(r, execInFg, \"start\"); if (!oomAdjusted) &#123; oomAdjusted = true; mAm.updateOomAdjLocked(r.app, true, OomAdjuster.OOM_ADJ_REASON_START_SERVICE); &#125; //å¦‚æœæ˜¯ä»¥å‰å°æœåŠ¡çš„æ–¹å¼å¯åŠ¨çš„Serviceï¼ˆstartForegroundServiceï¼‰ï¼Œå¹¶ä¸”ä¹‹å‰æ²¡æœ‰è®¾ç½®å¯åŠ¨å‰å°æœåŠ¡è¶…æ—¶å›è°ƒ if (r.fgRequired &amp;&amp; !r.fgWaiting) &#123; //å¦‚æœå½“å‰æœåŠ¡è¿˜æ²¡æˆä¸ºå‰å°æœåŠ¡ï¼Œè®¾ç½®å¯åŠ¨å‰å°æœåŠ¡è¶…æ—¶å›è°ƒ //åœ¨10så†…éœ€è¦è°ƒç”¨Service.startForegroundæˆä¸ºå‰å°æœåŠ¡ï¼Œå¦åˆ™åœæ­¢æœåŠ¡ //æ³¨ï¼šAndroid 11è¿™ä¸ªè¶…æ—¶æ—¶é—´æ˜¯10sï¼Œåœ¨åé¢çš„Androidç‰ˆæœ¬ä¸­è¿™ä¸ªæ—¶é—´æœ‰å˜åŒ– if (!r.isForeground) &#123; scheduleServiceForegroundTransitionTimeoutLocked(r); &#125; else &#123; r.fgRequired = false; &#125; &#125; int flags = 0; if (si.deliveryCount &gt; 1) &#123; flags |= Service.START_FLAG_RETRY; &#125; if (si.doneExecutingCount &gt; 0) &#123; flags |= Service.START_FLAG_REDELIVERY; &#125; //æ·»åŠ å¯åŠ¨é¡¹ args.add(new ServiceStartArgs(si.taskRemoved, si.id, flags, si.intent)); &#125; //æ„å»ºå‡ºä¸€ä¸ªæ”¯æŒBinderè·¨è¿›ç¨‹ä¼ è¾“å¤§é‡æ•°æ®çš„åˆ—è¡¨æ¥ä¼ è¾“å¯åŠ¨å‚æ•°æ•°æ® ParceledListSlice&lt;ServiceStartArgs&gt; slice = new ParceledListSlice&lt;&gt;(args); slice.setInlineCountLimit(4); try &#123; //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦å¯åŠ¨Service r.app.thread.scheduleServiceArgs(r, slice); &#125; catch ...&#125; è¿™ä¸ªæ–¹æ³•ä¸­æœ‰å‡ ä¸ªæ¯”è¾ƒé‡è¦çš„ç‚¹éœ€è¦æ³¨æ„ï¼š pendingStartsä¸­è‡³å°‘è¦æœ‰ä¸€ä¸ªå¯åŠ¨é¡¹æ‰ä¼šæ‰§è¡ŒonStartCommandï¼Œæ‰€ä»¥åœ¨å‰é¢çš„ActiveServices.realStartServiceLockedæ–¹æ³•ä¸­æ‰ä¼šæœ‰è¿™æ ·ä¸€æ®µä»£ç ï¼šå¦‚æœServiceå·²ç»å¯åŠ¨ï¼Œå¹¶ä¸”æ²¡æœ‰å¯åŠ¨é¡¹ï¼Œåˆ™æ„å»ºä¸€ä¸ªå‡çš„å¯åŠ¨å‚æ•°ä¾›onStartCommandä½¿ç”¨ å¦‚æœåœ¨å¤šä¸ªå¯åŠ¨é¡¹ä¸­æœ‰å‡å¯åŠ¨é¡¹ï¼Œåˆ™è·³è¿‡å‡å¯åŠ¨é¡¹ï¼Œä½†å¦‚æœè¿™ä¸ªå‡å¯åŠ¨é¡¹æ˜¯å”¯ä¸€çš„å¯åŠ¨é¡¹åˆ™ä¸è¦è·³è¿‡å®ƒï¼Œè¿™æ˜¯ä¸ºäº†æ”¯æŒonStartCommandæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°Intentæœªnullçš„æƒ…å†µ å¦‚æœæœåŠ¡æ˜¯ä»¥å‰å°æœåŠ¡çš„æ–¹å¼å¯åŠ¨çš„ï¼ˆstartForegroundServiceï¼‰ï¼Œå¦‚æœå½“å‰æœåŠ¡è¿˜æ²¡æˆä¸ºå‰å°æœåŠ¡ï¼Œåˆ™éœ€è¦è®¾ç½®ä¸€ä¸ªå¯åŠ¨å‰å°æœåŠ¡çš„è¶…æ—¶å›è°ƒï¼Œå¦‚æœåœ¨é™åˆ¶çš„æ—¶é—´èŒƒå›´å†…è¿˜æ²¡æœ‰æˆä¸ºå‰å°æœåŠ¡ï¼ˆè°ƒç”¨Service.startForegroundæ–¹æ³•ï¼‰ï¼Œåˆ™ä¼šè§¦å‘è¶…æ—¶é€»è¾‘ï¼Œåœæ­¢æœåŠ¡ï¼Œè¿™ä¸ªæ—¶é—´åœ¨Android 11ä¸Šæ˜¯10sï¼Œåœ¨åé¢çš„Androidç‰ˆæœ¬ä¸­æœ‰å˜åŒ– æœ€åå°†æ‰€æœ‰çš„å¯åŠ¨é¡¹æ”¾åˆ°ä¸€ä¸ªæ”¯æŒBinderè·¨è¿›ç¨‹ä¼ è¾“å¤§é‡æ•°æ®çš„åˆ—è¡¨ä¸­ï¼Œç„¶åè°ƒç”¨Appè¿›ç¨‹ä¸­çš„ActivityThread$ApplicationThread.scheduleServiceArgsæ–¹æ³• 12345678910111213141516//frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleServiceArgs(IBinder token, ParceledListSlice args) &#123; List&lt;ServiceStartArgs&gt; list = args.getList(); for (int i = 0; i &lt; list.size(); i++) &#123; ServiceStartArgs ssa = list.get(i); ServiceArgsData s = new ServiceArgsData(); s.token = token; s.taskRemoved = ssa.taskRemoved; s.startId = ssa.startId; s.flags = ssa.flags; s.args = ssa.args; sendMessage(H.SERVICE_ARGS, s); &#125;&#125; å’Œå‰é¢ä¸€æ ·ï¼Œè¿™é‡Œä¹Ÿæ˜¯å°†å¯åŠ¨Serviceçš„å¿…è¦ä¿¡æ¯åŒ…è£…æˆä¸€ä¸ªä¸ªServiceStartArgså¯¹è±¡åï¼Œé€šè¿‡Handlerä¾æ¬¡å‘é€Messageå¤„ç†æœåŠ¡å¯åŠ¨ï¼Œè¿™é‡Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ActivityThread.handleServiceArgsæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleServiceArgs(ServiceArgsData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; //Intentè·¨è¿›ç¨‹å¤„ç† if (data.args != null) &#123; data.args.setExtrasClassLoader(s.getClassLoader()); data.args.prepareToEnterProcess(); &#125; int res; if (!data.taskRemoved) &#123; //æ­£å¸¸æƒ…å†µè°ƒç”¨ res = s.onStartCommand(data.args, data.flags, data.startId); &#125; else &#123; //ç”¨æˆ·å…³é—­Taskæ ˆæ—¶è°ƒç”¨ s.onTaskRemoved(data.args); res = Service.START_TASK_REMOVED_COMPLETE; &#125; //ç¡®ä¿å…¶ä»–å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆ QueuedWork.waitToFinish(); try &#123; //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¼šæ ¹æ®onStartCommandçš„è¿”å›å€¼ï¼Œè°ƒæ•´Serviceæ­»äº¡é‡å»ºç­–ç•¥ //åŒæ—¶ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_START, data.startId, res); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to start service \" + s + \" with \" + data.args + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; è¿™é‡Œé¦–å…ˆåˆ¤æ–­taskRemovedæ ‡å¿—ï¼Œè¿™ä¸ªæ ‡å¿—ä¸ºtrueåˆ™ä»£è¡¨ç”¨æˆ·ä¹‹å‰ä»æœ€è¿‘ä»»åŠ¡ç•Œé¢é‡Œåˆ’æ‰äº†è¿™ä¸ªä»»åŠ¡æ ˆæˆ–è€…åœ¨æœ€è¿‘ä»»åŠ¡ç•Œé¢é‡Œç‚¹å‡»äº†æ¸…ç†ï¼Œæ­¤æ—¶ä¼šè°ƒç”¨Service.onTaskRemovedæ–¹æ³•ï¼ˆä»æœ€è¿‘ä»»åŠ¡ç•Œé¢å…³é—­åº”ç”¨ï¼Œè¿›ç¨‹ä¸ä¸€å®šä¼šè¢«æ€æ­»ï¼Œè€Œä¸”Serviceå…·æœ‰æ­»äº¡é‡å»ºæœºåˆ¶ï¼‰ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹åˆ™æ˜¯è°ƒç”¨Service.onStartCommandå¤„ç†æœåŠ¡å¯åŠ¨ å½“ä»»åŠ¡æ‰§è¡Œå®Œæˆåï¼Œä¼šè°ƒç”¨AMS.serviceDoneExecutingæ–¹æ³•å‘ŠçŸ¥ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¼šæ ¹æ®onStartCommandçš„è¿”å›å€¼ï¼ˆæˆ–æ‰§è¡Œå®ŒonTaskRemovedè¢«èµ‹å€¼ä¸ºSTART_TASK_REMOVED_COMPLETEï¼‰ï¼Œè°ƒæ•´Serviceçš„æ­»äº¡é‡å»ºç­–ç•¥ï¼Œå¹¶ä¸”ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ onStartCommandå¯ä»¥æœ‰ä»¥ä¸‹å‡ ç§è¿”å›å€¼ï¼š START_STICKY_COMPATIBILITYï¼štargetSdkVersion &lt; 5 (Android 2.0) çš„Appé»˜è®¤ä¼šè¿”å›è¿™ä¸ªï¼ŒServiceè¢«æ€åä¼šè¢«é‡å»ºï¼Œä½†onStartCommandæ–¹æ³•ä¸ä¼šè¢«æ‰§è¡Œ START_STICKYï¼štargetSdkVersion &gt;= 5 (Android 2.0) çš„Appé»˜è®¤ä¼šè¿”å›è¿™ä¸ªï¼ŒServiceè¢«æ€åä¼šè¢«é‡å»ºï¼ŒonStartCommandæ–¹æ³•ä¹Ÿä¼šè¢«æ‰§è¡Œï¼Œä½†æ­¤æ—¶onStartCommandæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°Intentä¸ºnull START_NOT_STICKYï¼šServiceè¢«æ€åä¸ä¼šè¢«é‡å»º START_REDELIVER_INTENTï¼šServiceè¢«æ€åä¼šè¢«é‡å»ºï¼ŒonStartCommandæ–¹æ³•ä¹Ÿä¼šè¢«æ‰§è¡Œï¼Œæ­¤æ—¶onStartCommandæ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°Intentä¸ºServiceè¢«æ€æ­»å‰æœ€åä¸€æ¬¡è°ƒç”¨onStartCommandæ–¹æ³•æ—¶ä¼ é€’çš„Intent åœ¨è¿™é‡Œæˆ‘ä»¬åªæ‘†å‡ºç»“è®ºï¼Œæš‚æ—¶ä¸åˆ†æåŸç†ï¼Œå¦‚æœæ„Ÿå…´è¶£çš„è¯æˆ‘ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­å†å»è¯¦ç»†åˆ†æ Context.bindServiceåˆ°è¿™é‡Œï¼ŒServiceé€šè¿‡startServiceè·¯å¾„çš„å¯åŠ¨æµç¨‹æˆ‘ä»¬å°±åŸºæœ¬åˆ†æå®Œäº†ï¼Œæ¥ç€æˆ‘ä»¬çœ‹å¦ä¸€æ¡è·¯å¾„ï¼ŒbindService 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//frameworks/base/core/java/android/app/ContextImpl.javapublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, String instanceName, Handler handler, Executor executor, UserHandle user) &#123; // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser. //è·å–LoadedApk$ServiceDispatcher$IServiceConnection //è¿™ä¸ªç±»æ˜¯ç”¨æ¥åç»­è¿æ¥å»ºç«‹å®Œæˆåå‘å¸ƒè¿æ¥ï¼Œå›è°ƒServiceConnectionå„ç§æ–¹æ³•çš„ IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException(\"connection is null\"); &#125; if (handler != null &amp;&amp; executor != null) &#123; throw new IllegalArgumentException(\"Handler and Executor both supplied\"); &#125; if (mPackageInfo != null) &#123; if (executor != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags); &#125; else &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; &#125; else &#123; throw new RuntimeException(\"Not supported in system context\"); &#125; //ç¡®ä¿Intentæœ‰æ•ˆ validateServiceIntent(service); try &#123; //è·å–ActivityRecordçš„è¿œç¨‹Binderå¯¹è±¡ IBinder token = getActivityToken(); //targetSdkVersion &lt; 14 (Android 4.0)çš„æƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®BIND_AUTO_CREATE //åˆ™è¯¥Serviceçš„ä¼˜å…ˆçº§å°†ä¼šè¢«è§†ä¸ºç­‰åŒäºåå°ä»»åŠ¡ if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; //è·¨è¿›ç¨‹å‡†å¤‡ service.prepareToLeaveProcess(this); //è·¨è¿›ç¨‹ä½¿ç”¨AMSç»‘å®šService int res = ActivityManager.getService().bindIsolatedService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, instanceName, getOpPackageName(), user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( \"Not allowed to bind to service \" + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦å°±åšäº†ä¸¤ä»¶äº‹ï¼š åˆ›å»ºæˆ–è·å–IServiceConnectionï¼šè¿™é‡Œå®é™…è·å–åˆ°çš„æ˜¯LoadedApkä¸­çš„å†…éƒ¨ç±»ServiceDispatcherä¸­çš„å†…éƒ¨ç±»InnerConnectionï¼Œè¿™ä¸ªç±»ä¸»è¦æ˜¯ç”¨æ¥åé¢å»ºç«‹æˆ–æ–­å¼€è¿æ¥åï¼Œå›è°ƒServiceConnectionæ¥å£çš„å„ä¸ªæ–¹æ³•çš„ è·¨è¿›ç¨‹è°ƒç”¨AMS.bindIsolatedServiceæ–¹æ³•ç»‘å®šService 12345678910111213141516171819202122232425262728293031323334//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic int bindIsolatedService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String instanceName, String callingPackage, int userId) throws TransactionTooLargeException &#123; enforceNotIsolatedCaller(\"bindService\"); // Refuse possible leaked file descriptors //æ ¡éªŒIntentï¼Œä¸å…è®¸å…¶æºå¸¦fd if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; //æ ¡éªŒè°ƒç”¨æ–¹åŒ…å if (callingPackage == null) &#123; throw new IllegalArgumentException(\"callingPackage cannot be null\"); &#125; // Ensure that instanceName, which is caller provided, does not contain // unusual characters. if (instanceName != null) &#123; for (int i = 0; i &lt; instanceName.length(); ++i) &#123; char c = instanceName.charAt(i); if (!((c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '_' || c == '.')) &#123; throw new IllegalArgumentException(\"Illegal instanceName\"); &#125; &#125; &#125; synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, instanceName, callingPackage, userId); &#125;&#125; è¿™é‡Œä»…ä»…åšäº†ä¸€äº›ç®€å•çš„æ ¡éªŒï¼Œç„¶åå°†ç»‘å®šæœåŠ¡çš„ä»»åŠ¡è½¬äº¤ç»™äº†ActiveServices.bindServiceLockedæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaint bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String instanceName, String callingPackage, final int userId) throws TransactionTooLargeException &#123; //è·å–è°ƒç”¨æ–¹è¿›ç¨‹è®°å½• final ProcessRecord callerApp = mAm.getRecordForAppLocked(caller); if (callerApp == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when binding service \" + service); &#125; ActivityServiceConnectionsHolder&lt;ConnectionRecord&gt; activity = null; //tokenä¸ä¸ºç©ºè¡¨ç¤ºæ˜¯ä»Activityå‘èµ·çš„ï¼Œtokenå®é™…ä¸ºActivityRecordçš„è¿œç¨‹Binderå¯¹è±¡ if (token != null) &#123; //è·å–Activityä¸Serviceçš„è¿æ¥è®°å½• activity = mAm.mAtmInternal.getServiceConnectionsHolder(token); //ServiceConnectionsHolderä¸ºnullè¯´æ˜è°ƒç”¨æ–¹Activityä¸åœ¨æ ˆä¸­ï¼Œç›´æ¥å¼‚å¸¸è¿”å› if (activity == null) &#123; return 0; &#125; &#125; int clientLabel = 0; PendingIntent clientIntent = null; final boolean isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID; //å¦‚æœè°ƒç”¨æ–¹ä¸ºç³»ç»Ÿçº§åº”ç”¨ if (isCallerSystem) &#123; // Hacky kind of thing -- allow system stuff to tell us // what they are, so we can report this elsewhere for // others to know why certain services are running. service.setDefusable(true); clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT); if (clientIntent != null) &#123; clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, 0); if (clientLabel != 0) &#123; // There are no useful extras in the intent, trash them. // System code calling with this stuff just needs to know // this will happen. service = service.cloneFilter(); &#125; &#125; &#125; //åƒå¯¹å¾…Activityä¸€æ ·å¯¹å¾…è¯¥Service //éœ€è¦æ ¡éªŒè°ƒç”¨æ–¹åº”ç”¨æ˜¯å¦å…·æœ‰MANAGE_ACTIVITY_STACKSæƒé™ if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, \"BIND_TREAT_LIKE_ACTIVITY\"); &#125; //æ­¤æ ‡å¿—ä»…ç”¨äºç³»ç»Ÿè°ƒæ•´IMEsï¼ˆä»¥åŠä¸é¡¶å±‚Appå¯†åˆ‡åˆä½œçš„å…¶ä»–è·¨è¿›ç¨‹çš„ç”¨æˆ·å¯è§ç»„ä»¶ï¼‰çš„è°ƒåº¦ç­–ç•¥ï¼Œä»…é™ç³»ç»Ÿçº§Appä½¿ç”¨ if ((flags &amp; Context.BIND_SCHEDULE_LIKE_TOP_APP) != 0 &amp;&amp; !isCallerSystem) &#123; throw new SecurityException(\"Non-system caller (pid=\" + Binder.getCallingPid() + \") set BIND_SCHEDULE_LIKE_TOP_APP when binding service \" + service); &#125; //å…è®¸ç»‘å®šServiceçš„åº”ç”¨ç¨‹åºç®¡ç†ç™½åå•ï¼Œä»…é™ç³»ç»Ÿçº§Appä½¿ç”¨ if ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0 &amp;&amp; !isCallerSystem) &#123; throw new SecurityException( \"Non-system caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service \" + service); &#125; //å…è®¸ç»‘å®šåˆ°å…å®‰è£…åº”ç”¨æä¾›çš„æœåŠ¡ï¼Œä»…é™ç³»ç»Ÿçº§Appä½¿ç”¨ if ((flags &amp; Context.BIND_ALLOW_INSTANT) != 0 &amp;&amp; !isCallerSystem) &#123; throw new SecurityException( \"Non-system caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") set BIND_ALLOW_INSTANT when binding service \" + service); &#125; //å…è®¸Serviceåå°å¯åŠ¨Activity //éœ€è¦æ ¡éªŒè°ƒç”¨æ–¹åº”ç”¨æ˜¯å¦å…·æœ‰START_ACTIVITIES_FROM_BACKGROUNDæƒé™ if ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != 0) &#123; mAm.enforceCallingPermission( android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND, \"BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS\"); &#125; //åˆ¤æ–­è°ƒç”¨æ–¹æ˜¯å¦ä¸ºå‰å° final boolean callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND; final boolean isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != 0; final boolean allowInstant = (flags &amp; Context.BIND_ALLOW_INSTANT) != 0; //æŸ¥æ‰¾ç›¸åº”çš„Service ServiceLookupResult res = retrieveServiceLocked(service, instanceName, resolvedType, callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg, isBindExternal, allowInstant); if (res == null) &#123; return 0; &#125; if (res.record == null) &#123; return -1; &#125; ServiceRecord s = res.record; boolean permissionsReviewRequired = false; // If permissions need a review before any of the app components can run, // we schedule binding to the service but do not start its process, then // we launch a review activity to which is passed a callback to invoke // when done to start the bound service's process to completing the binding. //å¦‚æœéœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æˆæƒ if (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired( s.packageName, s.userId)) &#123; permissionsReviewRequired = true; // Show a permission review UI only for binding from a foreground app //åªæœ‰è°ƒç”¨æ–¹è¿›ç¨‹åœ¨å‰å°æ‰å¯ä»¥æ˜¾ç¤ºæˆæƒå¼¹çª— if (!callerFg) &#123; return 0; &#125; final ServiceRecord serviceRecord = s; final Intent serviceIntent = service; //ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æˆæƒåæ‰§è¡Œçš„å›è°ƒ RemoteCallback callback = new RemoteCallback( new RemoteCallback.OnResultListener() &#123; @Override public void onResult(Bundle result) &#123; synchronized(mAm) &#123; final long identity = Binder.clearCallingIdentity(); try &#123; if (!mPendingServices.contains(serviceRecord)) &#123; return; &#125; // If there is still a pending record, then the service // binding request is still valid, so hook them up. We // proceed only if the caller cleared the review requirement // otherwise we unbind because the user didn't approve. //äºŒæ¬¡æ£€æŸ¥æƒé™ if (!mAm.getPackageManagerInternalLocked() .isPermissionsReviewRequired( serviceRecord.packageName, serviceRecord.userId)) &#123; try &#123; //æ‹‰èµ·æœåŠ¡ï¼Œå¦‚æœæœåŠ¡æœªåˆ›å»ºï¼Œåˆ™ä¼šåˆ›å»ºæœåŠ¡å¹¶è°ƒç”¨å…¶onCreateæ–¹æ³• //å¦‚æœæœåŠ¡å·²åˆ›å»ºåˆ™ä»€ä¹ˆéƒ½ä¸ä¼šåš bringUpServiceLocked(serviceRecord, serviceIntent.getFlags(), callerFg, false, false); &#125; catch (RemoteException e) &#123; /* ignore - local call */ &#125; &#125; else &#123; //æ— ç›¸åº”æƒé™åˆ™è§£ç»‘Service unbindServiceLocked(connection); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(identity); &#125; &#125; &#125; &#125;); final Intent intent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName); intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback); //å¼¹å‡ºæˆæƒå¼¹çª— mAm.mHandler.post(new Runnable() &#123; @Override public void run() &#123; mAm.mContext.startActivityAsUser(intent, new UserHandle(userId)); &#125; &#125;); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; //å–æ¶ˆä¹‹å‰çš„Serviceé‡å¯ä»»åŠ¡ï¼ˆå¦‚æœæœ‰ï¼‰ if (unscheduleServiceRestartLocked(s, callerApp.info.uid, false)) &#123; if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, \"BIND SERVICE WHILE RESTART PENDING: \" + s); &#125; if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); //å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ç»‘å®šçš„è¯ï¼Œè®¾ç½®è·Ÿè¸ªå™¨ if (!s.hasAutoCreateConnections()) &#123; // This is the first binding, let the tracker know. ServiceState stracker = s.getTracker(); if (stracker != null) &#123; stracker.setBound(true, mAm.mProcessStats.getMemFactorLocked(), s.lastActivity); &#125; &#125; &#125; //ç»‘å®šçš„æœåŠ¡ä»£è¡¨å—ä¿æŠ¤çš„ç³»ç»Ÿç»„ä»¶ï¼Œå› æ­¤å¿…é¡»å¯¹å…¶åº”ç”¨å…³è”åšé™åˆ¶ if ((flags &amp; Context.BIND_RESTRICT_ASSOCIATIONS) != 0) &#123; mAm.requireAllowedAssociationsLocked(s.appInfo.packageName); &#125; //å»ºç«‹è°ƒç”¨æ–¹ä¸æœåŠ¡æ–¹ä¹‹é—´çš„å…³è” mAm.startAssociationLocked(callerApp.uid, callerApp.processName, callerApp.getCurProcState(), s.appInfo.uid, s.appInfo.longVersionCode, s.instanceName, s.processName); // Once the apps have become associated, if one of them is caller is ephemeral // the target app should now be able to see the calling app mAm.grantImplicitAccess(callerApp.userId, service, callerApp.uid, UserHandle.getAppId(s.appInfo.uid)); //æŸ¥è¯¢Appç»‘å®šä¿¡æ¯ AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); //åˆ›å»ºè¿æ¥ä¿¡æ¯ ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent, callerApp.uid, callerApp.processName, callingPackage); IBinder binder = connection.asBinder(); //æ·»åŠ è¿æ¥ s.addConnection(binder, c); b.connections.add(c); if (activity != null) &#123; activity.addConnection(c); &#125; b.client.connections.add(c); //å»ºç«‹å…³è” c.startAssociationIfNeeded(); //è¡¨ç¤ºæ­¤æœåŠ¡æ¯”å‘èµ·ç»‘å®šçš„åº”ç”¨é‡è¦æ€§æ›´é«˜ if ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != 0) &#123; b.client.hasAboveClient = true; &#125; //å…è®¸ç»‘å®šServiceçš„åº”ç”¨ç¨‹åºç®¡ç†ç™½åå• if ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != 0) &#123; s.whitelistManager = true; &#125; //å…è®¸Serviceåå°å¯åŠ¨Activity if ((flags &amp; Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS) != 0) &#123; s.setHasBindingWhitelistingBgActivityStarts(true); &#125; //æ›´æ–°æ˜¯å¦æœ‰ä¸Serviceå»ºç«‹è¿æ¥çš„Activity if (s.app != null) &#123; updateServiceClientActivitiesLocked(s.app, c, true); &#125; //æ›´æ–°è¿æ¥åˆ—è¡¨ ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder); if (clist == null) &#123; clist = new ArrayList&lt;&gt;(); mServiceConnections.put(binder, clist); &#125; clist.add(c); //ç»‘å®šå­˜åœ¨å°±ä¼šè‡ªåŠ¨åˆ›å»ºæœåŠ¡ if ((flags&amp;Context.BIND_AUTO_CREATE) != 0) &#123; s.lastActivity = SystemClock.uptimeMillis(); //æ‹‰èµ·æœåŠ¡ï¼Œå¦‚æœæœåŠ¡æœªåˆ›å»ºï¼Œåˆ™ä¼šåˆ›å»ºæœåŠ¡å¹¶è°ƒç”¨å…¶onCreateæ–¹æ³• //å¦‚æœæœåŠ¡å·²åˆ›å»ºåˆ™ä»€ä¹ˆéƒ½ä¸ä¼šåš if (bringUpServiceLocked(s, service.getFlags(), callerFg, false, permissionsReviewRequired) != null) &#123; return 0; &#125; &#125; //æ£€æŸ¥æ˜¯å¦å…è®¸å‰å°æœåŠ¡ä½¿ç”¨while-in-useæƒé™ if (!s.mAllowWhileInUsePermissionInFgs) &#123; s.mAllowWhileInUsePermissionInFgs = shouldAllowWhileInUsePermissionInFgsLocked(callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), service, s, false); &#125; //æ›´æ–°flagä»¥åŠè¿›ç¨‹ä¼˜å…ˆçº§ if (s.app != null) &#123; if ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) &#123; s.app.treatLikeActivity = true; &#125; if (s.whitelistManager) &#123; s.app.whitelistManager = true; &#125; // This could have made the service more important. mAm.updateLruProcessLocked(s.app, (callerApp.hasActivitiesOrRecentTasks() &amp;&amp; s.app.hasClientActivities()) || (callerApp.getCurProcState() &lt;= ActivityManager.PROCESS_STATE_TOP &amp;&amp; (flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != 0), b.client); mAm.updateOomAdjLocked(s.app, OomAdjuster.OOM_ADJ_REASON_BIND_SERVICE); &#125; if (s.app != null &amp;&amp; b.intent.received) &#123; // Service is already running, so we can immediately // publish the connection. //å¦‚æœæœåŠ¡ä¹‹å‰å°±å·²ç»åœ¨è¿è¡Œï¼Œå³Service.onBindæ–¹æ³•å·²ç»è¢«æ‰§è¡Œï¼Œè¿”å›çš„IBinderå¯¹è±¡ä¹Ÿå·²ç»è¢«ä¿å­˜ //è°ƒç”¨LoadedApk$ServiceDispatcher$InnerConnection.connectedæ–¹æ³• //å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• c.conn.connected(s.name, b.intent.binder, false); // If this is the first app connected back to this binding, // and the service had previously asked to be told when // rebound, then do so. //å½“æœåŠ¡è§£ç»‘ï¼Œè°ƒç”¨åˆ°Service.onUnbindæ–¹æ³•æ—¶è¿”å›trueï¼Œæ­¤æ—¶doRebindå˜é‡å°±ä¼šè¢«èµ‹å€¼ä¸ºtrue //æ­¤æ—¶ï¼Œå½“å†æ¬¡å»ºç«‹è¿æ¥æ—¶ï¼ŒæœåŠ¡ä¼šå›è°ƒService.onRebindæ–¹æ³• if (b.intent.apps.size() == 1 &amp;&amp; b.intent.doRebind) &#123; requestServiceBindingLocked(s, b.intent, callerFg, true); &#125; &#125; else if (!b.intent.requested) &#123; //å¦‚æœæœåŠ¡æ˜¯å› è¿™æ¬¡ç»‘å®šè€Œåˆ›å»ºçš„ //è¯·æ±‚æ‰§è¡ŒService.onBindæ–¹æ³•ï¼Œè·å–è¿”å›çš„IBinderå¯¹è±¡ //å‘å¸ƒServiceï¼Œå›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• requestServiceBindingLocked(s, b.intent, callerFg, false); &#125; maybeLogBindCrossProfileService(userId, callingPackage, callerApp.info.uid); //å°†æ­¤Serviceä»æ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨å’Œå»¶è¿Ÿå¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­ç§»é™¤ //å¦‚æœæ­£åœ¨åå°å¯åŠ¨æœåŠ¡åˆ—è¡¨ä¸­å­˜åœ¨æ­¤æœåŠ¡çš„è¯ï¼Œå°†ä¹‹å‰è®¾ç½®ä¸ºå»¶è¿Ÿå¯åŠ¨çš„æœåŠ¡è°ƒåº¦å‡ºæ¥åå°å¯åŠ¨ getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; //è¿”å›å€¼å¤§äº0åˆ™è§†ä¸ºæˆåŠŸ return 1;&#125; è¿™ä¸ªæ–¹æ³•åšçš„äº‹å°±æ¯”è¾ƒå¤šäº†ï¼Œæˆ‘ä»¬æŒ‘é‡ç‚¹æ¥è¯´ï¼š è·å–æˆ–åˆ›å»ºå„ç§è¿æ¥è®°å½•ï¼ˆActivityServiceConnectionsHolderã€AppBindRecordã€ConnectionRecordç­‰ï¼‰ æ ¡éªŒå„ç§flags æŸ¥æ‰¾ç›¸åº”çš„Service æ£€æŸ¥æ˜¯å¦éœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æƒé™å¹¶å¼¹å‡ºæƒé™ç¡®è®¤å¼¹çª— å‘å„ä¸ªè¿æ¥è®°å½•ç±»ä¸­æ·»åŠ ConnectionRecordè¿æ¥ä¿¡æ¯ å¦‚æœflagsè®¾ç½®äº†BIND_AUTO_CREATEä¾¿ä¼šè°ƒç”¨bringUpServiceLockedæ–¹æ³•å°è¯•æ‹‰èµ·æœåŠ¡ï¼Œå¦‚æœæœåŠ¡æœªåˆ›å»ºï¼Œåˆ™ä¼šåˆ›å»ºæœåŠ¡å¹¶è°ƒç”¨å…¶onCreateæ–¹æ³•ï¼Œå¦‚æœæœåŠ¡å·²åˆ›å»ºï¼Œåˆ™ä»€ä¹ˆéƒ½ä¸ä¼šåšï¼šè¿™é‡Œå’ŒstartServiceè·¯å¾„ä¸€æ ·éƒ½è°ƒç”¨åˆ°äº†bringUpServiceLockedæ–¹æ³•ï¼Œä½†æœ€ç»ˆè°ƒç”¨çš„ç»“æœå´ä¸å¤ªä¸€æ ·ï¼Œè¿™æ˜¯å› ä¸ºstartServiceè·¯å¾„ä¸­ï¼ŒServiceRecord.startRequestedä¸ºtrueå¹¶ä¸”å‘ServiceRecord.pendingStartsä¸­æ·»åŠ äº†å¯åŠ¨é¡¹ï¼Œè€ŒbindServiceè·¯å¾„ä¸ä¼šå‘ServiceRecord.pendingStartsä¸­æ·»åŠ å¯åŠ¨é¡¹ï¼Œå¹¶ä¸”ç”±äºServiceRecord.startRequestedä¸ºfalseï¼Œå› æ­¤ä¹Ÿä¸ä¼šå»æ·»åŠ å‡çš„å¯åŠ¨é¡¹ï¼Œæ‰€ä»¥å’ŒstartServiceä¸åŒï¼Œæœ€ç»ˆä¸ä¼šå›è°ƒService.onStartCommandæ–¹æ³• å¦‚æœæœåŠ¡ä¹‹å‰å°±å·²ç»åœ¨è¿è¡Œï¼Œåˆ™è¡¨ç¤ºService.onBindæ–¹æ³•å·²ç»è¢«æ‰§è¡Œï¼Œè¿”å›çš„IBinderå¯¹è±¡ä¹Ÿå·²ç»è¢«ä¿å­˜ï¼Œæ­¤æ—¶ç›´æ¥è°ƒç”¨LoadedApk$ServiceDispatcher$InnerConnection.connectedæ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¼šå›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• å¦‚æœæœåŠ¡æ˜¯å› è¿™æ¬¡ç»‘å®šè€Œåˆ›å»ºçš„ï¼Œåˆ™è°ƒç”¨requestServiceBindingLockedæ–¹æ³•è¯·æ±‚æ‰§è¡ŒService.onBindæ–¹æ³•ï¼Œè·å–è¿”å›çš„IBinderå¯¹è±¡ï¼Œç„¶åå‘å¸ƒServiceï¼Œå›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• æœ€åè°ƒç”¨ActiveServices$ServiceMap.ensureNotStartingBackgroundLockedæ–¹æ³•ç»§ç»­è°ƒåº¦åå°Serviceçš„å¯åŠ¨ bringUpServiceLockedæ–¹æ³•æˆ‘ä»¬ä¹‹å‰å·²ç»åˆ†æè¿‡äº†ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹æœåŠ¡åˆ›å»ºåæ‰€è¦è°ƒç”¨çš„requestServiceBindingLockedæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javaprivate final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; //è®°å½•Serviceæ‰§è¡Œæ“ä½œå¹¶è®¾ç½®è¶…æ—¶å›è°ƒ //å‰å°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º20sï¼Œåå°æœåŠ¡è¶…æ—¶æ—¶é—´ä¸º200s bumpServiceExecutingLocked(r, execInFg, \"bind\"); //è®¾ç½®è¿›ç¨‹çŠ¶æ€ r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //å›åˆ°Appè¿›ç¨‹ï¼Œè°ƒåº¦æ‰§è¡ŒServiceçš„bindæ“ä½œ r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.getReportedProcState()); //è¯·æ±‚ç»‘å®šå®Œæˆ if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (TransactionTooLargeException e) &#123; // Keep the executeNesting count accurate. final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); throw e; &#125; catch (RemoteException e) &#123; // Keep the executeNesting count accurate. final boolean inDestroying = mDestroyingServices.contains(r); serviceDoneExecutingLocked(r, inDestroying, inDestroying); return false; &#125; &#125; return true;&#125; å’Œä¹‹å‰ä¸€æ ·ï¼Œè¿™é‡Œä¹Ÿæ˜¯è°ƒç”¨Appè¿›ç¨‹ä¸­çš„ActivityThread$ApplicationThread.scheduleBindServiceæ–¹æ³•è¿›è¡Œç»‘å®šæ“ä½œ 123456789101112//frameworks/base/core/java/android/app/ActivityThread.javapublic final void scheduleBindService(IBinder token, Intent intent, boolean rebind, int processState) &#123; //æ›´æ–°è¿›ç¨‹ä¿¡æ¯ updateProcessState(processState, false); BindServiceData s = new BindServiceData(); s.token = token; s.intent = intent; s.rebind = rebind; sendMessage(H.BIND_SERVICE, s);&#125; å°†ç»‘å®šServiceçš„å¿…è¦ä¿¡æ¯åŒ…è£…æˆBindServiceDataå¯¹è±¡åï¼Œé€šè¿‡Handlerä¾æ¬¡å‘é€Messageå¤„ç†æœåŠ¡å¯åŠ¨ï¼Œè¿™é‡Œæœ€ç»ˆè°ƒç”¨çš„æ˜¯ActivityThread.handleBindServiceæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435//frameworks/base/core/java/android/app/ActivityThread.javaprivate void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; //æ­£å¸¸æƒ…å†µä¸‹å›è°ƒService.onBindæ–¹æ³•ï¼Œè·å¾—æ§åˆ¶Serviceçš„IBinderå¯¹è±¡ IBinder binder = s.onBind(data.intent); //å‘å¸ƒService ActivityManager.getService().publishService( data.token, data.intent, binder); &#125; else &#123; //å½“æœåŠ¡è§£ç»‘ï¼Œè°ƒç”¨åˆ°Service.onUnbindæ–¹æ³•æ—¶è¿”å›trueï¼Œæ­¤æ—¶doRebindå˜é‡å°±ä¼šè¢«èµ‹å€¼ä¸ºtrue //æ­¤æ—¶ï¼Œå½“å†æ¬¡å»ºç«‹è¿æ¥æ—¶ï¼ŒæœåŠ¡ä¼šå›è°ƒService.onRebindæ–¹æ³• s.onRebind(data.intent); //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¸­ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( \"Unable to bind to service \" + s + \" with \" + data.intent + \": \" + e.toString(), e); &#125; &#125; &#125;&#125; åœ¨è¿™ä¸ªæ–¹æ³•é‡Œé¢è°ƒç”¨äº†Service.onBindæ–¹æ³•ï¼Œè·å¾—åˆ°äº†æ§åˆ¶Serviceçš„IBinderå¯¹è±¡ï¼Œç„¶åå†è°ƒç”¨AMS.publishServiceå‘å¸ƒæœåŠ¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javapublic void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException(\"Invalid service token\"); &#125; //è½¬äº¤ç»™ActiveServiceså¤„ç† mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125;//frameworks/base/services/core/java/com/android/server/am/ActiveServices.javavoid publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; if (r != null) &#123; Intent.FilterComparison filter = new Intent.FilterComparison(intent); //è·å–Intentç»‘å®šè®°å½• IntentBindRecord b = r.bindings.get(filter); if (b != null &amp;&amp; !b.received) &#123; //ä¿å­˜æ§åˆ¶Serviceçš„IBinderå¯¹è±¡ b.binder = service; //è¯·æ±‚ç»‘å®šå®Œæˆ b.requested = true; //IBinderå¯¹è±¡è·å–å®Œæˆ b.received = true; //éå†æ‰€æœ‰ä¸æ­¤æœåŠ¡ç»‘å®šçš„å®¢æˆ·ç«¯è¿æ¥ ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections = r.getConnections(); for (int conni = connections.size() - 1; conni &gt;= 0; conni--) &#123; ArrayList&lt;ConnectionRecord&gt; clist = connections.valueAt(conni); for (int i=0; i&lt;clist.size(); i++) &#123; ConnectionRecord c = clist.get(i); if (!filter.equals(c.binding.intent.intent)) &#123; continue; &#125; //è°ƒç”¨LoadedApk$ServiceDispatcher$IServiceConnection.connectedæ–¹æ³• //å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• c.conn.connected(r.name, service, false); &#125; &#125; &#125; //Serviceç›¸å…³ä»»åŠ¡æ‰§è¡Œå®Œæˆ //è¿™ä¸€æ­¥ä¸­ä¼šæŠŠä¹‹å‰çš„å¯åŠ¨è¶…æ—¶å®šæ—¶å™¨å–æ¶ˆ serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), false); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œé¦–å…ˆå°†é€šè¿‡Service.onBindè·å¾—åˆ°çš„æ§åˆ¶Serviceçš„IBinderå¯¹è±¡ä¿å­˜åœ¨IntentBindRecordä¸­ï¼Œè¿™æ ·ä¹‹åå†æœ‰å…¶ä»–clientç»‘å®šæœåŠ¡ï¼Œå°±åªéœ€è¦ç”¨å®ƒä½œä¸ºå‚æ•°å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³•å°±å¯ä»¥äº† æ¥ä¸‹æ¥éå†æ‰€æœ‰ä¸æ­¤æœåŠ¡ç»‘å®šçš„å®¢æˆ·ç«¯è¿æ¥ï¼Œå¯¹ç¬¦åˆæ¡ä»¶çš„è¿æ¥æ‰§è¡ŒLoadedApk$ServiceDispatcher$IServiceConnection.connectedæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//frameworks/base/core/java/android/app/LoadedApk.javapublic void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException &#123; //mDispatcheræ˜¯å¯¹ServiceDispatcherçš„å¼±å¼•ç”¨ LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; //è°ƒç”¨ServiceDispatcher.connectedæ–¹æ³• sd.connected(name, service, dead); &#125;&#125;public void connected(ComponentName name, IBinder service, boolean dead) &#123; //RunConnectioné‡Œä¹Ÿæ˜¯è°ƒç”¨äº†doConnectedæ–¹æ³• if (mActivityExecutor != null) &#123; mActivityExecutor.execute(new RunConnection(name, service, 0, dead)); &#125; else if (mActivityThread != null) &#123; mActivityThread.post(new RunConnection(name, service, 0, dead)); &#125; else &#123; doConnected(name, service, dead); &#125;&#125;public void doConnected(ComponentName name, IBinder service, boolean dead) &#123; ServiceDispatcher.ConnectionInfo old; ServiceDispatcher.ConnectionInfo info; synchronized (this) &#123; if (mForgotten) &#123; // We unbound before receiving the connection; ignore // any connection received. return; &#125; old = mActiveConnections.get(name); //å¦‚æœæ—§çš„è¿æ¥ä¿¡æ¯ä¸­çš„IBinderå¯¹è±¡å’Œæœ¬æ¬¡è°ƒç”¨ä¼ å…¥çš„IBinderå¯¹è±¡æ˜¯åŒä¸€ä¸ªå¯¹è±¡ if (old != null &amp;&amp; old.binder == service) &#123; // Huh, already have this one. Oh well! return; &#125; if (service != null) &#123; // A new service is being connected... set it all up. //å»ºç«‹ä¸€ä¸ªæ–°çš„è¿æ¥ä¿¡æ¯ info = new ConnectionInfo(); info.binder = service; info.deathMonitor = new DeathMonitor(name, service); try &#123; //æ³¨å†ŒBinderæ­»äº¡é€šçŸ¥ service.linkToDeath(info.deathMonitor, 0); //ä¿å­˜æœ¬æ¬¡è¿æ¥ä¿¡æ¯ mActiveConnections.put(name, info); &#125; catch (RemoteException e) &#123; // This service was dead before we got it... just // don't do anything with it. //æœåŠ¡å·²æ­»äº¡ï¼Œç§»é™¤è¿æ¥ä¿¡æ¯ mActiveConnections.remove(name); return; &#125; &#125; else &#123; // The named service is being disconnected... clean up. mActiveConnections.remove(name); &#125; //ç§»é™¤Binderæ­»äº¡é€šçŸ¥ if (old != null) &#123; old.binder.unlinkToDeath(old.deathMonitor, 0); &#125; &#125; // If there was an old service, it is now disconnected. //å›è°ƒServiceConnection.onServiceDisconnected //é€šçŸ¥clientä¹‹å‰çš„è¿æ¥å·²è¢«æ–­å¼€ if (old != null) &#123; mConnection.onServiceDisconnected(name); &#125; //å¦‚æœServiceæ­»äº¡éœ€è¦å›è°ƒServiceConnection.onBindingDiedé€šçŸ¥clientæœåŠ¡æ­»äº¡ if (dead) &#123; mConnection.onBindingDied(name); &#125; // If there is a new viable service, it is now connected. if (service != null) &#123; //å›è°ƒServiceConnection.onServiceConnectedæ–¹æ³• //å‘ŠçŸ¥clientå·²å»ºç«‹è¿æ¥ mConnection.onServiceConnected(name, service); &#125; else &#123; // The binding machinery worked, but the remote returned null from onBind(). //å½“Service.onBindæ–¹æ³•è¿”å›nullæ—¶ï¼Œå›è°ƒServiceConnection.onNullBindingæ–¹æ³• mConnection.onNullBinding(name); &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•é‡Œæœ€ç»ˆæ‰§è¡Œäº†ServiceConnection.onServiceConnectedå›è°ƒï¼Œé€šçŸ¥å®¢æˆ·ç«¯å·²ä¸Serviceå»ºç«‹è¿æ¥ è‡³æ­¤ï¼Œæ•´ä¸ªbindServiceçš„æµç¨‹å°±ç»“æŸäº† æ€»ç»“Serviceçš„æ•´ä¸ªå¯åŠ¨æµç¨‹åˆ°è¿™é‡ŒåŸºæœ¬ä¸Šéƒ½åˆ†æå®Œäº†ï¼Œè‡³äºServiceçš„åœæ­¢ï¼Œé‡å»ºç­‰æµç¨‹ï¼Œæˆ‘å°†ä¼šåœ¨åé¢çš„æ–‡ç« ä¸­å†æ…¢æ…¢åˆ†æ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}]},{"title":"è°ˆè°ˆAndroidå¦‚ä½•å®ç°ä¸åŒå¤§å°çš„åœ†è§’","slug":"android/view/è°ˆè°ˆAndroidå¦‚ä½•å®ç°ä¸åŒå¤§å°çš„åœ†è§’","date":"2023-07-31T07:32:03.000Z","updated":"2023-10-25T04:46:27.809Z","comments":true,"path":"2023/07/31/android/view/è°ˆè°ˆAndroidå¦‚ä½•å®ç°ä¸åŒå¤§å°çš„åœ†è§’/","link":"","permalink":"http://yoursite.com/2023/07/31/android/view/%E8%B0%88%E8%B0%88Android%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%9C%86%E8%A7%92/","excerpt":"","text":"ç®€ä»‹åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œè®¾è®¡å¸¸å¸¸ä¼šæœ‰ä¸€äº›æ¯”è¾ƒç‚«é…·çš„æƒ³æ³•ï¼Œæ¯”å¦‚ä¸¤è¾¹ä¸ä¸€æ ·å¤§å°çš„åœ†è§’å•¦ï¼Œç”šè‡³å››è§’çš„radiuså„ä¸ç›¸åŒï¼Œå¯¹äºè¿™ç§æƒ…å†µæˆ‘ä»¬è¯¥æ€ä¹ˆå®ç°å‘¢ï¼Ÿ èƒŒæ™¯åœ†è§’Shapeå¯¹äºä¸€èˆ¬çš„èƒŒæ™¯ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨shapeï¼Œè¿™ç§æ–¹æ³•å¤©ç”Ÿæ”¯æŒè®¾ç½®å››è§’ä¸åŒçš„radiusï¼Œæ¯”å¦‚ï¼š 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;solid android:color=\"#8358FF\" /&gt; &lt;corners android:bottomLeftRadius=\"10dp\" android:bottomRightRadius=\"20dp\" android:topLeftRadius=\"30dp\" android:topRightRadius=\"40dp\" /&gt;&lt;/shape&gt; å°è´´å£«ï¼šshapeåœ¨ä»£ç å±‚çš„å®ç°ä¸ºGradientDrawableï¼Œå¯ä»¥ç›´æ¥åœ¨ä»£ç å±‚æ„å»ºåœ†è§’èƒŒæ™¯ï¼Œé¡ºä¾¿æ¨èä¸€ä¸‹æˆ‘å†™çš„åº“ï¼šShapeLayoutï¼Œå¯ä»¥æ–¹ä¾¿çš„å®ç°shapeèƒŒæ™¯ï¼Œå‘Šåˆ«xml å†…å®¹åœ†è§’å¾ˆå¤šæƒ…å†µä¸‹ï¼Œè®¾ç½®èƒŒæ™¯çš„å››è¾¹ä¸åŒåœ†è§’å¹¶ä¸èƒ½æ»¡è¶³æˆ‘ä»¬ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è¿ç€é‡Œé¢çš„å†…å®¹ä¸€èµ·åˆ‡åœ†è§’ï¼Œè¿™é‡Œæˆ‘ä»¬éœ€è¦å…ˆæŒ‡æ­£ä¸€ä¸‹ç½‘ä¸Šçš„ä¸€ä¸ªé”™è¯¯å†™æ³• æœ‰äººå‘æ–‡è¯´ï¼Œå¯ä»¥é€šè¿‡outline.setConvexPathæ–¹æ³•ï¼Œå®ç°å››è§’ä¸åŒradiusï¼Œå¦‚ä¸‹ï¼š 123456789101112131415161718outline?.setConvexPath( Path().apply &#123; addRoundRect( 0f, 0f, width.toFloat(), height.toFloat(), floatArrayOf( topLeftRadius, topLeftRadius, topRightRadius, topRightRadius, bottomRightRadius, bottomRightRadius, bottomLeftRadius, bottomLeftRadius ), Path.Direction.CCW ) &#125;) ç»è¿‡å®æµ‹ï¼Œè¿™æ ·å†™æ˜¯ä¸è¡Œçš„ï¼Œå‡†ç¡®çš„æ¥è¯´ï¼Œåœ¨å¤§éƒ¨åˆ†ç³»ç»Ÿä¸Šæ˜¯ä¸è¡Œçš„ï¼ˆMIUIä¸Šå¯ä»¥ï¼Œæˆ‘ä¸çŸ¥é“æ˜¯è¯¥å¤¸å®ƒå…¼å®¹æ€§å¤ªå¥½äº†è¿˜æ˜¯è¯¥åæ§½å®ƒå•¥ï¼Œæˆ‘çš„æµ‹è¯•æœºç”¨çš„å°ç±³ï¼Œè¿™å¯¼è‡´æˆ‘åœ¨æœ€åçš„æµ‹è¯•é˜¶æ®µæ‰å‘ç°è¿™ä¸ªé—®é¢˜ï¼‰ æŒ‡å‡ºé”™è¯¯æ–¹æ³•åï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹æ­£ç¡®è§£æ³•æœ‰å“ªäº› CardViewè¯´åˆ°åˆ‡å†…å®¹åœ†è§’ï¼Œæˆ‘ä»¬è‡ªç„¶è€Œç„¶ä¼šå»æƒ³åˆ°CardViewï¼Œå…¶å®CardViewçš„åœ†è§’ä¹Ÿæ˜¯é€šè¿‡Outlineå®ç°çš„ æœ‰äººå¯èƒ½è¦é—®äº†ï¼ŒCardViewä¸æ˜¯åªæ”¯æŒå››è§’ç›¸åŒradiuså—ï¼Ÿåˆ«æ€¥ï¼Œä¸”çœ‹æˆ‘çµæœºä¸€åŠ¨æƒ³å‡ºæ¥çš„ç¥å¥‡åµŒå¥—å¤§æ³• ç¥å¥‡åµŒå¥—å¤§æ³•æ—¢ç„¶ä¸€ä¸ªCardViewåªèƒ½è®¾ä¸€ä¸ªradiusï¼Œé‚£æˆ‘å¤šç”¨å‡ ä¸ªCardViewåµŒå¥—æ˜¯å¦èƒ½è§£å†³é—®é¢˜å‘¢ï¼Ÿ ä¸¾ä¸ªæœ€ç®€å•çš„ä¾‹å­ï¼Œæ¯”å¦‚è¯´è®¾è®¡æƒ³è¦ä¸ŠåŠéƒ¨åˆ†ä¸º12dpçš„åœ†è§’ï¼Œä¸‹åŠéƒ¨åˆ†æ²¡æœ‰åœ†è§’ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¾…åŠ©Viewï¼Œè®©ä»–çš„é¡¶éƒ¨å’Œçˆ¶å¸ƒå±€çš„åº•éƒ¨å¯¹é½ï¼Œç„¶åè®¾ç½®æˆåœ†è§’å¤§å°çš„é«˜åº¦æˆ–è€…marginï¼Œæ¥ç€ä½¿ç”¨CardViewï¼Œè®©å®ƒçš„åº•éƒ¨å¯¹é½è¿™ä¸ªè¾…åŠ©Viewçš„åº•éƒ¨ï¼Œå†è®¾ç½®ä¸€ä¸ªåœ†è§’å¤§å°çš„paddingï¼Œè¿™æ ·ï¼Œç”±äºCardViewè¶…å‡ºäº†çˆ¶å¸ƒå±€çš„è¾¹ç•Œï¼Œæ‰€ä»¥åº•éƒ¨çš„åœ†è§’ä¸ä¼šæ˜¾ç¤ºå‡ºæ¥ï¼Œå†ç”±äºæˆ‘ä»¬è®¾ç½®äº†æ°å¥½çš„paddingï¼Œæ‰€ä»¥CardViewé‡Œé¢çš„å†…å®¹ä¹Ÿèƒ½å®Œæ•´å±•ç¤ºï¼Œå¯è°“å®Œç¾ï¼Œå®ä¾‹å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829&lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;Space android:id=\"@+id/guideline\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"12dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"12dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"12dp\" app:layout_constraintBottom_toBottomOf=\"@+id/guideline\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:adjustViewBounds=\"true\" android:background=\"#8358FF\" /&gt; &lt;/androidx.cardview.widget.CardView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; ä¸Šé¢çš„ä¾‹å­æ²¡æœ‰åµŒå¥—ï¼Œå› ä¸ºå¦ä¸€è¾¹æ²¡æœ‰åœ†è§’ï¼Œé‚£ä¹ˆå¦‚æœæˆ‘ä»¬éœ€è¦ä¸ŠåŠéƒ¨åˆ†ä¸º12dpçš„åœ†è§’ï¼Œä¸‹åŠéƒ¨åˆ†ä¸º6dpçš„åœ†è§’ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·æ“ä½œ æ‰‹æ³•å’Œä¸Šé¢çš„ä¾‹å­ä¸€æ ·ï¼Œä¸è¿‡æˆ‘ä»¬åœ¨æœ€å¤–å±‚å†åµŒå¥—ä¸€ä¸ªCardViewï¼Œå¹¶ä¸”å°†å…¶åœ†è§’è®¾ä¸ºè¾ƒå°çš„é‚£ä¸ªåœ†è§’å¤§å°6dpï¼Œå°†é‡Œé¢çš„CardViewçš„åœ†è§’è®¾ç½®æˆè¾ƒå¤§çš„é‚£ä¸ªåœ†è§’å¤§å°12dpï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940&lt;androidx.cardview.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"6dp\" app:cardElevation=\"0dp\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"12dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"12dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"12dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:adjustViewBounds=\"true\" android:background=\"#8358FF\" /&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&lt;/androidx.cardview.widget.CardView&gt; æœ¬è´¨ä¸Šå°±æ˜¯å¤§åœ†è§’å¥—å°åœ†è§’ï¼Œå¤§åœ†è§’çš„è£åˆ‡èŒƒå›´æ›´å¤§ï¼Œä¼šè¦†ç›–å°åœ†è§’è£åˆ‡çš„èŒƒå›´ï¼Œä»è§†è§‰ä¸Šçœ‹å°±å®ç°äº†ä¸¤è¾¹çš„ä¸åŒåœ†è§’ é‚£ä¹ˆå¦‚æœæˆ‘ä»¬æƒ³è¿›ä¸€æ­¥å®ç°ä¸‰è¾¹ä¸åŒåœ†è§’æˆ–è€…å››è¾¹ä¸åŒåœ†è§’å‘¢ï¼ŸåŸç†å’Œä¸Šé¢æ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡åµŒå¥—å’Œå ä½ä¼šå˜å¾—æ›´åŠ å¤æ‚ï¼Œè®°ä½ä¸€ä¸ªåŸåˆ™ï¼Œå°åœ†è§’åœ¨å¤–ï¼Œå¤§åœ†è§’åœ¨å†…å³å¯ï¼Œæˆ‘ç›´æ¥æŠŠå…·ä½“å®ç°è´´åœ¨ä¸‹é¢ï¼Œå„ä½è‡ªå–å³å¯ï¼š ä¸‰è¾¹ä¸åŒåœ†è§’ï¼ˆå·¦ä¸‹6dpï¼Œå·¦ä¸Š12dpï¼Œå³ä¸Š24dpï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;Space android:id=\"@+id/guideline\" android:layout_width=\"6dp\" android:layout_height=\"match_parent\" app:layout_constraintStart_toEndOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"6dp\" app:cardElevation=\"0dp\" app:contentPaddingRight=\"6dp\" app:layout_constraintEnd_toEndOf=\"@+id/guideline\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline2\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"12dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"12dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"12dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline3\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_marginEnd=\"24dp\" app:layout_constraintEnd_toStartOf=\"parent\" /&gt; &lt;Space android:id=\"@+id/guideline4\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"24dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"24dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"24dp\" app:contentPaddingLeft=\"24dp\" app:layout_constraintBottom_toBottomOf=\"@+id/guideline4\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline3\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:adjustViewBounds=\"true\" android:background=\"#8358FF\" /&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/androidx.cardview.widget.CardView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; å››è¾¹ä¸åŒåœ†è§’ï¼ˆå·¦ä¸‹6dpï¼Œå·¦ä¸Š12dpï¼Œå³ä¸Š24dpï¼Œå³ä¸‹48dpï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;Space android:id=\"@+id/guideline\" android:layout_width=\"6dp\" android:layout_height=\"match_parent\" app:layout_constraintStart_toEndOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"6dp\" app:cardElevation=\"0dp\" app:contentPaddingRight=\"6dp\" app:layout_constraintEnd_toEndOf=\"@+id/guideline\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline2\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"12dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"12dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"12dp\" app:layout_constraintBottom_toTopOf=\"@+id/guideline2\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline3\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_marginEnd=\"24dp\" app:layout_constraintEnd_toStartOf=\"parent\" /&gt; &lt;Space android:id=\"@+id/guideline4\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginTop=\"24dp\" app:layout_constraintTop_toBottomOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"24dp\" app:cardElevation=\"0dp\" app:contentPaddingBottom=\"24dp\" app:contentPaddingLeft=\"24dp\" app:layout_constraintBottom_toBottomOf=\"@+id/guideline4\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline3\"&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Space android:id=\"@+id/guideline5\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_marginEnd=\"48dp\" app:layout_constraintEnd_toStartOf=\"parent\" /&gt; &lt;Space android:id=\"@+id/guideline6\" android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_marginBottom=\"48dp\" app:layout_constraintBottom_toTopOf=\"parent\" /&gt; &lt;androidx.cardview.widget.CardView android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" app:cardBackgroundColor=\"@android:color/transparent\" app:cardCornerRadius=\"48dp\" app:cardElevation=\"0dp\" app:contentPaddingLeft=\"48dp\" app:contentPaddingTop=\"48dp\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"@+id/guideline5\" app:layout_constraintTop_toTopOf=\"@+id/guideline6\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:adjustViewBounds=\"true\" android:background=\"#8358FF\" /&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/androidx.cardview.widget.CardView&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; &lt;/androidx.cardview.widget.CardView&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; è‡ªå®šä¹‰ImageViewç”±äºå¤§éƒ¨åˆ†è£åˆ‡å†…å®¹çš„éœ€æ±‚ï¼Œå…¶ä¸­çš„å†…å®¹éƒ½æ˜¯å›¾ç‰‡ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥ç›´æ¥å¯¹å›¾ç‰‡è¿›è¡Œè£åˆ‡ï¼Œæ­¤æ—¶æˆ‘ä»¬å°±å¯ä»¥è‡ªå®šä¹‰ImageViewæ¥å°†å›¾ç‰‡è£å‰ªå‡ºä¸åŒå¤§å°çš„åœ†è§’ clipPathå…ˆè¯´è¿™ä¸ªæ–¹æ³•çš„ç¼ºç‚¹ï¼Œé‚£å°±æ˜¯æ— æ³•ä½¿ç”¨æŠ—é”¯é½¿ï¼Œè¿™ä¸€ç‚¹ç¼ºé™·æ³¨å®šäº†å®ƒæ— æ³•è¢«æ­£å¼ä½¿ç”¨ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯æ¥çœ‹çœ‹ä»–æ˜¯å¦‚ä½•å®ç°çš„ é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦é‡å†™ImageViewçš„onSizeChangedæ–¹æ³•ï¼Œä¸ºæˆ‘ä»¬çš„Pathç¡®å®šè·¯çº¿ 123456override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) path.reset() //è¿™é‡Œçš„radiiä¾¿æ˜¯æˆ‘ä»¬è‡ªå®šä¹‰çš„å››è¾¹åœ†è§’å¤§å°çš„æ•°ç»„ï¼ˆsizeä¸º8ï¼Œä»å·¦ä¸Šé¡ºæ—¶é’ˆåˆ°å·¦ä¸‹ï¼‰ path.addRoundRect(0f, 0f, w.toFloat(), h.toFloat(), radii, Path.Direction.CW)&#125; æ¥ç€æˆ‘ä»¬é‡å†™onDrawæ–¹æ³• 1234override fun onDraw(canvas: Canvas) &#123; canvas.clipPath(path) super.onDraw(rawBitmapCanvas)&#125; ç½‘ä¸Šæœ‰çš„æ•™ç¨‹è¯´è¦è®¾ç½®PaintFlagsDrawFilterï¼Œä½†å®é™…ä¸Šå°±ç®—ä¸ºè¿™ä¸ªPaintFlagsDrawFilterè®¾ç½®äº†Paint.ANTI_ALIAS_FLAGæŠ—é”¯é½¿å±æ€§ä¹Ÿæ²¡ç”¨ï¼ŒæŠ—é”¯é½¿åªåœ¨ä½¿ç”¨äº†Paintçš„æƒ…å†µä¸‹æ‰å¯ä»¥ç”Ÿæ•ˆ PorterDuffæ—¢ç„¶clipPathæ— æ³•ä½¿ç”¨æŠ—é”¯é½¿ï¼Œé‚£æˆ‘ä»¬å¯ä»¥æ¢ä¸€æ¡è·¯çº¿æ›²çº¿æ•‘å›½ï¼Œé‚£å°±æ˜¯ä½¿ç”¨PorterDuff å½“ç„¶ï¼Œè¿™ç§æ–¹æ³•ä¹Ÿæœ‰å®ƒçš„ç¼ºç‚¹ï¼Œé‚£å°±æ˜¯ä¸èƒ½ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿï¼Œä½†ç›¸æ¯”æ— æ³•ä½¿ç”¨æŠ—é”¯é½¿è€Œè¨€ï¼Œè¿™ç‚¹ç¼ºç‚¹ä¹Ÿå°±ä¸ç®—ä»€ä¹ˆäº† é¦–å…ˆï¼Œæˆ‘ä»¬è¦åœ¨æ„é€ æ–¹æ³•ä¸­ç¦ç”¨ç¡¬ä»¶åŠ é€Ÿ 123init &#123; setLayerType(LAYER_TYPE_SOFTWARE, null)&#125; ç„¶åé‡å†™onSizeChangedæ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®šPathï¼Œæ„é€ å‡ºç›¸åº”å¤§å°çš„Bitmapå’ŒCanvasï¼Œè¿™ä¿©æ˜¯ç”¨æ¥è·å–åŸå§‹æ— åœ†è§’çš„Bitmapçš„ 12345678override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) path.reset() path.addRoundRect(0f, 0f, w.toFloat(), h.toFloat(), radii, Path.Direction.CW) rawBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) rawBitmapCanvas = Canvas(rawBitmap!!)&#125; æ¥ç€æˆ‘ä»¬é‡å†™onDrawæ–¹æ³• 1234567891011121314private val paint = Paint(Paint.ANTI_ALIAS_FLAG)private val xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_IN)override fun onDraw(canvas: Canvas) &#123; val rawBitmap = rawBitmap ?: return val rawBitmapCanvas = rawBitmapCanvas ?: return super.onDraw(rawBitmapCanvas) canvas.drawPath(path, paint) paint.xfermode = xfermode canvas.drawBitmap(rawBitmap, 0f, 0f, paint) paint.xfermode = null&#125; è¿™é‡Œï¼Œæˆ‘ä»¬è°ƒç”¨çˆ¶ç±»çš„onDrawæ–¹æ³•ï¼Œè·å–åˆ°åŸå§‹æ— åœ†è§’çš„Bitmapï¼Œç„¶åç»˜åˆ¶Pathï¼Œå†é€šè¿‡PorterDuffçš„å åŠ æ•ˆæœç»˜åˆ¶æˆ‘ä»¬åˆšåˆšå¾—åˆ°çš„åŸå§‹Bitmapï¼Œç”±äºPorterDuff.Mode.SRC_INçš„æ•ˆæœæ˜¯å–ä¸¤å±‚ç»˜åˆ¶äº¤é›†ï¼Œæ˜¾ç¤ºä¸Šå±‚ï¼Œæ‰€ä»¥æˆ‘ä»¬æœ€ç»ˆä¾¿è·å¾—äº†ä¸€ä¸ªå¸¦åœ†è§’çš„å›¾ç‰‡ BitmapShaderæœ‰äººæŒ‡å‡ºï¼Œå¯ä»¥ä½¿ç”¨BitmapShaderæ–¹æ¡ˆï¼Œæˆ‘å»å®æµ‹äº†ä¸€ä¸‹ï¼Œç¡®å®å¯ä»¥åœ¨å¼€å¯äº†ç¡¬ä»¶åŠ é€Ÿçš„æƒ…å†µä¸‹ä½¿ç”¨ï¼Œç›®å‰çœ‹ä¸Šå»ä¼¼ä¹æ²¡æœ‰ä»€ä¹ˆç¼ºç‚¹ï¼Œåœ¨æ­¤æ„Ÿè°¢è¯„è®ºåŒºçš„å¤§ç¥ä»¬ï¼Œè¿™ç§æ–¹æ¡ˆå®ç°èµ·æ¥ä¹Ÿå¾ˆç®€å•ï¼Œå’Œä¸Šé¢çš„å·®ä¸å¤š é¦–å…ˆé‡å†™onSizeChangedæ–¹æ³• 123456789101112private var bitmapShader: BitmapShader? = nulloverride fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; super.onSizeChanged(w, h, oldw, oldh) path.reset() path.addRoundRect(0f, 0f, w.toFloat(), h.toFloat(), radii, Path.Direction.CW) rawBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888) rawBitmapCanvas = Canvas(rawBitmap!!) bitmapShader = BitmapShader(rawBitmap!!, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP) paint.shader = bitmapShader&#125; ç„¶åonDrawæ–¹æ³•å°±æ›´ç®€å•äº† 12345override fun onDraw(canvas: Canvas) &#123; val rawBitmapCanvas = rawBitmapCanvas ?: return super.onDraw(rawBitmapCanvas) canvas.drawPath(path, paint)&#125; æˆªå›¾é—®é¢˜å¦‚æœæƒ³è¦å°†Viewæˆªå›¾æˆBitmapï¼Œåœ¨Android 8.0åŠä»¥ä¸Šç³»ç»Ÿä¸­æˆ‘ä»¬å¯ä»¥ä½¿ç”¨PixelCopyï¼Œæ­¤æ—¶ä½¿ç”¨CardViewæˆ–Outlineè£åˆ‡çš„åœ†è§’ä¸ä¼šæœ‰ä»»ä½•é—®é¢˜ï¼Œè€Œåœ¨Android 8.0ä»¥ä¸‹çš„ç³»ç»Ÿä¸­ï¼Œé€šå¸¸æˆ‘ä»¬æ˜¯æ„å»ºä¸€ä¸ªå¸¦Bitmapçš„Canvasï¼Œç„¶åå¯¹è¦æˆªå›¾çš„Viewè°ƒç”¨drawæ–¹æ³•è¾¾æˆæˆªå›¾æ•ˆæœï¼Œè€Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨CardViewæˆ–Outlineè£åˆ‡çš„åœ†è§’ä¾¿ä¼šå‡ºç°æ— æ•ˆçš„æƒ…å†µï¼ˆæˆªå›¾å‡ºæ¥çš„Bitmapä¸­ï¼Œåœ†è§’æ²¡äº†ï¼‰ï¼Œè¿™ç§æƒ…å†µçš„å‡ºç°ä¼¼ä¹ä¹Ÿå’Œç¡¬ä»¶åŠ é€Ÿæœ‰å…³ï¼Œé’ˆå¯¹è¿™ç§é—®é¢˜ï¼Œå¦‚æœæ˜¯å›¾ç‰‡åœ†è§’çš„æƒ…å†µï¼Œå»ºè®®ç›´æ¥ä½¿ç”¨BitmapShaderæ–¹æ¡ˆï¼Œè¿™æ ·æ— è®ºä½¿ç”¨å“ªç§æ–¹å¼æˆªå›¾éƒ½ä¸ä¼šå‡ºç°é—®é¢˜ è¿™é‡Œé¡ºä¾¿æŠŠæˆªå›¾çš„ä»£ç ä¹Ÿè´´ä¸€ä¸‹å§ 1234567891011121314151617181920212223242526272829303132333435fun View.screenshot(activity: Activity?, onSuccess: (Bitmap) -&gt; Unit) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O &amp;&amp; activity != null) &#123; val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888) val locationOfViewInWindow = IntArray(2) this.getLocationInWindow(locationOfViewInWindow) PixelCopy.request( activity.window, Rect( locationOfViewInWindow[0], locationOfViewInWindow[1], locationOfViewInWindow[0] + width, locationOfViewInWindow[1] + height ), bitmap, &#123; copyResult -&gt; if (copyResult == PixelCopy.SUCCESS) &#123; onSuccess(bitmap) &#125; else &#123; screenshotBackup(onSuccess) &#125; &#125;, Handler(Looper.getMainLooper()) ) &#125; else &#123; screenshotBackup(onSuccess) &#125;&#125;private fun View.screenshotBackup(onSuccess: (Bitmap) -&gt; Unit) &#123; val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888) val canvas = Canvas(bitmap) draw(canvas) onSuccess(bitmap)&#125; æ€»ç»“ä»¥ä¸Šå°±æ˜¯æˆ‘æœ¬äººç›®å‰å¯¹Androidå®ç°ä¸åŒå¤§å°çš„åœ†è§’çš„ä¸€äº›æƒ³æ³•å’Œé‡åˆ°çš„é—®é¢˜ï¼Œè‡³äºCardViewåµŒå¥—ä¼šä¸ä¼šå¸¦æ¥ä»€ä¹ˆæ€§èƒ½é—®é¢˜ï¼Œæˆ‘ç”¨BitmapShaderæ–¹æ¡ˆåšäº†ä¸€ä¸‹å¯¹æ¯”ï¼Œä¸ç®¡åŠ è½½é€Ÿåº¦ï¼Œè¿˜æ˜¯å†…å­˜å ç”¨ï¼Œéƒ½æ²¡æœ‰å‘ç°æ˜æ˜¾å·®åˆ«ï¼ˆç”šè‡³ç”¨CardViewåµŒå¥—é€Ÿåº¦è¿˜å¿«ç‚¹ï¼Ÿï¼‰ï¼Œæ‰€ä»¥å„ä½ä¸ç”¨æ‹…å¿ƒæ€§èƒ½é—®é¢˜ï¼Œé€‰é€‚åˆè‡ªå·±çš„æ–¹æ¡ˆå°±è¡Œäº†ï¼Œå„ä½å°ä¼™ä¼´æœ‰ä»€ä¹ˆæ›´å¥½çš„è§£å†³æ–¹æ¡ˆï¼Œæ¬¢è¿åœ¨è¯„è®ºåŒºæŒ‡å‡ºï¼Œå¤§å®¶ä¸€èµ·é›†æ€å¹¿ç›Š","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"åœ†è§’","slug":"åœ†è§’","permalink":"http://yoursite.com/tags/%E5%9C%86%E8%A7%92/"}]},{"title":"Androidæºç åˆ†æ - Frameworkå±‚çš„ContentProviderå…¨è§£æ","slug":"android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„ContentProviderå…¨è§£æ","date":"2023-06-20T09:29:17.000Z","updated":"2023-10-25T04:46:27.805Z","comments":true,"path":"2023/06/20/android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„ContentProviderå…¨è§£æ/","link":"","permalink":"http://yoursite.com/2023/06/20/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84ContentProvider%E5%85%A8%E8%A7%A3%E6%9E%90/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ åœ¨å››å¤§ç»„ä»¶ä¸­ï¼Œå¯èƒ½æˆ‘ä»¬å¹³æ—¶ç”¨åˆ°æœ€å°‘çš„ä¾¿æ˜¯ContentProvideräº†ï¼ŒContentProvideræ˜¯ç”¨æ¥å¸®åŠ©åº”ç”¨ç®¡ç†å…¶è‡ªèº«å’Œå…¶ä»–åº”ç”¨æ‰€å­˜å‚¨æ•°æ®çš„è®¿é—®ï¼Œå¹¶æä¾›ä¸å…¶ä»–åº”ç”¨å…±äº«æ•°æ®çš„æ–¹æ³•ï¼Œä½¿ç”¨ContentProviderå¯ä»¥å®‰å…¨çš„åœ¨åº”ç”¨ä¹‹é—´å…±äº«å’Œä¿®æ”¹æ•°æ®ï¼Œæ¯”å¦‚è¯´è®¿é—®å›¾åº“ï¼Œé€šè®¯å½•ç­‰ åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬æåˆ°äº†ContentProviderçš„å¯åŠ¨æ—¶æœºï¼Œä¸å¦¨é¡ºæ°´æ¨èˆŸï¼Œå¹²è„†æŠŠè¿™ä¸€å—åˆ†æä¸ªæ˜ç™½ï¼Œæœ¬ç¯‡æ–‡ç« å¹¶ä¸ä¼šæ•™å¤§å®¶æ€æ ·ä½¿ç”¨ContentProviderï¼Œåªå°†ç²¾åŠ›é›†ä¸­åœ¨ContentProvideråœ¨ç³»ç»Ÿå±‚é¢çš„å¯åŠ¨ä¸äº¤äº’ä¸Š åŸºç¡€çŸ¥è¯†ContentResolveræƒ³è¦é€šè¿‡ContentProviderè®¿é—®åº”ç”¨æ•°æ®ï¼Œæˆ‘ä»¬é€šå¸¸éœ€è¦å€ŸåŠ©ContentResolverçš„APIï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡Context.getContentResolveræ–¹æ³•è·å–å…¶å®ä¾‹å¯¹è±¡ ContentResolveræ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒçš„æŠ½è±¡æ–¹æ³•ç”±ContextImpl.ApplicationContentResolverç»§æ‰¿å®ç°ï¼Œæˆ‘ä»¬å®é™…ä¸Šè·å–åˆ°çš„ä¹Ÿæ˜¯è¿™ä¸ªå®ä¾‹å¯¹è±¡ Uriæ ¼å¼ContentProviderçš„ä½¿ç”¨éœ€è¦å…ˆè·å¾—æä¾›è€…çš„Uriï¼Œå®ƒçš„æ ¼å¼å¦‚ä¸‹ï¼š Schemeï¼šå›ºå®šä¸ºcontent:// Authorityï¼šä¸ºæä¾›è€…åœ¨AndroidManifesté‡Œè®¾ç½®çš„android:authoritieså±æ€§ èµ„æºç›¸å¯¹è·¯å¾„ èµ„æºID å…¶ä¸­ï¼Œèµ„æºç›¸å¯¹è·¯å¾„å’Œèµ„æºIDä¸æ˜¯å¿…é¡»çš„ï¼Œè¦çœ‹èµ„æºå­˜å‚¨çš„æ•°é‡åŠå½¢å¼ ä¸¾ä¸ªæ —å­ï¼Œå¤–éƒ¨å­˜å‚¨ä¸­æŸå¼ å›¾ç‰‡çš„Uriä¸ºï¼šcontent://media/external/images/media/${id}ï¼Œå…¶ä¸­mediaä¸ºAuthorityï¼Œ/external/images/mediaä¸ºå¤–éƒ¨å­˜å‚¨å›¾ç‰‡çš„ç›¸å¯¹è·¯å¾„ï¼Œidä¸ºè¿™å¼ å›¾ç‰‡èµ„æºåœ¨æ•°æ®åº“ä¸­å­˜å‚¨çš„id è·å–ContentProviderContentProviderä½œä¸ºå…±äº«æ•°æ®çš„æ¡¥æ¢ï¼Œæœ€ä¸»è¦çš„å‡ ä¸ªåŠŸèƒ½æ— éæ˜¯å¢ã€åˆ ã€æ”¹ã€æŸ¥ï¼Œæˆ‘ä»¬å°±ä»¥æŸ¥ä½œä¸ºå…¥å£æ¥åˆ†æContentProviderå¯¹è±¡æ˜¯æ€ä¹ˆè·å–çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//ContentResolver.querypublic final @Nullable Cursor query(final @RequiresPermission.Read @NonNull Uri uri, @Nullable String[] projection, @Nullable Bundle queryArgs, @Nullable CancellationSignal cancellationSignal) &#123; ... //å°è¯•è·å–unstableProvider IContentProvider unstableProvider = acquireUnstableProvider(uri); if (unstableProvider == null) &#123; return null; &#125; IContentProvider stableProvider = null; Cursor qCursor = null; try &#123; ... try &#123; //è°ƒç”¨è¿œç¨‹å¯¹è±¡query qCursor = unstableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal); &#125; catch (DeadObjectException e) &#123; // The remote process has died... but we only hold an unstable // reference though, so we might recover!!! Let's try!!!! // This is exciting!!1!!1!!!!1 unstableProviderDied(unstableProvider); //å°è¯•è·å–stableProvider stableProvider = acquireProvider(uri); if (stableProvider == null) &#123; return null; &#125; //è°ƒç”¨è¿œç¨‹å¯¹è±¡query qCursor = stableProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal); &#125; if (qCursor == null) &#123; return null; &#125; // Force query execution. Might fail and throw a runtime exception here. qCursor.getCount(); ... // Wrap the cursor object into CursorWrapperInner object. //å°†qCursorå’ŒprovideråŒ…è£…æˆCursorWrapperInnerå¯¹è±¡è¿”å› final IContentProvider provider = (stableProvider != null) ? stableProvider : acquireProvider(uri); final CursorWrapperInner wrapper = new CursorWrapperInner(qCursor, provider); stableProvider = null; qCursor = null; return wrapper; &#125; catch (RemoteException e) &#123; // Arbitrary and not worth documenting, as Activity // Manager will kill this process shortly anyway. return null; &#125; finally &#123; //é‡Šæ”¾èµ„æº if (qCursor != null) &#123; qCursor.close(); &#125; if (cancellationSignal != null) &#123; cancellationSignal.setRemote(null); &#125; if (unstableProvider != null) &#123; releaseUnstableProvider(unstableProvider); &#125; if (stableProvider != null) &#123; releaseProvider(stableProvider); &#125; &#125;&#125; æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªæ–¹æ³•å¤§è‡´åˆ†æˆä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š è·å–unstableProviderè¿œç¨‹å¯¹è±¡ è°ƒç”¨unstableProviderå¯¹è±¡çš„queryæ–¹æ³•ï¼Œè·å–qCursor å¦‚æœqueryè¿‡ç¨‹ä¸­è¿œç¨‹å¯¹è±¡æ­»äº¡ï¼Œå°è¯•è·å–stableProviderå¹¶è°ƒç”¨queryæ–¹æ³•è·å–qCursor è·å–stableProviderï¼ˆå¦‚æœä¹‹å‰æ²¡è·å–çš„è¯ï¼‰ å°†qCursorå’ŒstableProvideråŒ…è£…æˆCursorWrapperInnerå¯¹è±¡è¿”å› é‡Šæ”¾èµ„æº æ—¢ç„¶ContentProviderå¯ä»¥åœ¨åº”ç”¨ä¹‹å‰å…±äº«æ•°æ®ï¼Œé‚£å®ƒå¿…ç„¶æ˜¯æ”¯æŒè·¨è¿›ç¨‹çš„ï¼Œæ²¡é”™ï¼Œç”¨çš„è¿˜æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„Binderé€šä¿¡ï¼ŒIContentProviderå¯¹è±¡å³æ˜¯ç»™è°ƒç”¨æ–¹è¿›ç¨‹ä½¿ç”¨çš„è¿œç¨‹Binderå¯¹è±¡ï¼Œå›é¡¾è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬å‘ç°ï¼ŒIContentProviderè¿œç¨‹å¯¹è±¡æ˜¯é€šè¿‡acquireUnstableProvideræˆ–acquireProviderè·å–çš„ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥çœ‹çœ‹è¿™ä¸¤ä¸ªæ–¹æ³•åšäº†ä»€ä¹ˆ è¿™é‡Œæœ‰ä¸€ä¸ªå…³äºunstableå’Œstableçš„æ¦‚å¿µï¼Œå¯¹äºé€šè¿‡è¿™ä¸¤ç§æ–¹å¼è·å–çš„ContentProvideråˆ†åˆ«ä¼šæœ‰unstableCountå’ŒstableCountä¸¤ç§å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœè¿œç¨‹ContentProvideræ‰€åœ¨è¿›ç¨‹æ­»äº¡ï¼Œä¸”å…¶stableCount &gt; 0çš„è¯ï¼Œåˆ™ä¼šå°†å…¶é€šè¿‡stableæ–¹å¼å…³è”çš„è°ƒç”¨æ–¹è¿›ç¨‹ä¸€åŒæ€æ­»ï¼Œå…·ä½“çš„æµç¨‹æˆ‘ä»¬ä¼šåœ¨åé¢åˆ†æ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final IContentProvider acquireUnstableProvider(Uri uri) &#123; if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; return null; &#125; String auth = uri.getAuthority(); if (auth != null) &#123; return acquireUnstableProvider(mContext, uri.getAuthority()); &#125; return null;&#125;public final IContentProvider acquireProvider(Uri uri) &#123; if (!SCHEME_CONTENT.equals(uri.getScheme())) &#123; return null; &#125; final String auth = uri.getAuthority(); if (auth != null) &#123; return acquireProvider(mContext, auth); &#125; return null;&#125;public final IContentProvider acquireUnstableProvider(String name) &#123; if (name == null) &#123; return null; &#125; return acquireUnstableProvider(mContext, name);&#125;public final IContentProvider acquireProvider(String name) &#123; if (name == null) &#123; return null; &#125; return acquireProvider(mContext, name);&#125;// ContextImpl.ApplicationContentResolver å†…å®ç°protected IContentProvider acquireUnstableProvider(Context c, String auth) &#123; return mMainThread.acquireProvider(c, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), false);&#125;// ContextImpl.ApplicationContentResolver å†…å®ç°protected IContentProvider acquireProvider(Context context, String auth) &#123; return mMainThread.acquireProvider(context, ContentProvider.getAuthorityWithoutUserId(auth), resolveUserIdFromAuthority(auth), true);&#125; ActivityThread.acquireProviderAndroidç³»ç»Ÿæ˜¯é€šè¿‡Authorityæ¥åŒºåˆ†ä¸åŒçš„ContentProviderçš„ï¼Œç»è¿‡ä¸€äº›ç®€å•çš„åˆ¤æ–­å¤„ç†åï¼Œæœ€ç»ˆè°ƒç”¨äº†ActivityThread.acquireProvideræ–¹æ³•å»è·å–ContentProviderï¼Œè€ŒacquireUnstableProviderå’ŒacquireProviderçš„åŒºåˆ«åªæ˜¯æœ€åä¸€ä¸ªå¸ƒå°”å€¼å…¥å‚ä¸åŒç½¢äº† 123456789101112131415161718192021222324252627282930313233343536public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; //å°è¯•ä»æœ¬åœ°ç¼“å­˜ä¸­è·å–ContentProviderå¯¹è±¡ final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; // There is a possible race here. Another thread may try to acquire // the same provider at the same time. When this happens, we want to ensure // that the first one wins. // Note that we cannot hold the lock while acquiring and installing the // provider since it might take a long time to run and it could also potentially // be re-entrant in the case where the provider is in the same process. ContentProviderHolder holder = null; try &#123; synchronized (getGetProviderLock(auth, userId)) &#123; //ä½¿ç”¨AMSè·å–ContentProviderå¯¹è±¡ holder = ActivityManager.getService().getContentProvider( getApplicationThread(), c.getOpPackageName(), auth, userId, stable); &#125; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; if (holder == null) &#123; ... return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. //å®‰è£…ContentProvider holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; è¿™ä¸ªæ–¹æ³•å¤§æ¦‚åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š é¦–å…ˆä»ç¼“å­˜ä¸­å°è¯•è·å–IContentProviderå¯¹è±¡ ä½¿ç”¨AMSè·å–ContentProviderHolderå¯¹è±¡ å®‰è£…ContentProvider è¿”å›IContentProviderå¯¹è±¡ ActivityThread.acquireExistingProvideræˆ‘ä»¬é¦–å…ˆçœ‹é€šè¿‡acquireExistingProvideræ–¹æ³•å°è¯•ä»ç¼“å­˜ä¸­è·å–IContentProviderå¯¹è±¡ 12345678910111213141516171819202122232425262728293031public final IContentProvider acquireExistingProvider( Context c, String auth, int userId, boolean stable) &#123; synchronized (mProviderMap) &#123; //ä»ç¼“å­˜Mapä¸­æŸ¥æ‰¾ final ProviderKey key = new ProviderKey(auth, userId); final ProviderClientRecord pr = mProviderMap.get(key); if (pr == null) &#123; return null; &#125; IContentProvider provider = pr.mProvider; IBinder jBinder = provider.asBinder(); //åˆ¤æ–­è¿œç«¯è¿›ç¨‹æ˜¯å¦å·²è¢«æ€æ­» if (!jBinder.isBinderAlive()) &#123; // The hosting process of the provider has died; we can't // use this one. //æ¸…ç†ContentProvider handleUnstableProviderDiedLocked(jBinder, true); return null; &#125; // Only increment the ref count if we have one. If we don't then the // provider is not reference counted and never needs to be released. ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; //æ›´æ–°å¼•ç”¨è®¡æ•° incProviderRefLocked(prc, stable); &#125; return provider; &#125;&#125; é¦–å…ˆé€šè¿‡Authorityå’ŒuserIdæ¥ä»Mapä¸­æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨å¯¹åº”çš„ProviderClientRecordå¯¹è±¡ï¼Œç„¶åä»ä¸­å–å‡ºIContentProviderå¯¹è±¡ï¼Œå†æ£€æŸ¥å…¶ä¸­çš„è¿œç¨‹Binderå¯¹è±¡æ˜¯å¦å·²è¢«æ€æ­»ï¼Œæœ€åä¸€åˆ‡æ— è¯¯ï¼Œå¢åŠ ContentProviderçš„å¼•ç”¨è®¡æ•° AMS.getContentProviderå¦‚æœè¿™ä¸€æ­¥æ²¡æœ‰è·å–åˆ°ï¼Œç¨‹åºä¼šç»§ç»­ä»AMSè·å–ContentProvider 1234567891011121314151617181920public final ContentProviderHolder getContentProvider( IApplicationThread caller, String callingPackage, String name, int userId, boolean stable) &#123; if (caller == null) &#123; String msg = \"null IApplicationThread when getting content provider \" + name; Slog.w(TAG, msg); throw new SecurityException(msg); &#125; // The incoming user check is now handled in checkContentProviderPermissionLocked() to deal // with cross-user grant. final int callingUid = Binder.getCallingUid(); if (callingPackage != null &amp;&amp; mAppOpsService.checkPackage(callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) &#123; throw new SecurityException(\"Given calling package \" + callingPackage + \" does not match caller's uid \" + callingUid); &#125; return getContentProviderImpl(caller, name, null, callingUid, callingPackage, null, stable, userId);&#125; ç»è¿‡ä¸€äº›æ£€æŸ¥åè°ƒç”¨getContentProviderImplæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æœ‰ç‚¹é•¿ï¼Œæˆ‘ä»¬åˆ†æ®µæ¥çœ‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, int callingUid, String callingPackage, String callingTag, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; boolean providerRunning = false; synchronized(this) &#123; //è·å–è°ƒç”¨æ–¹æ‰€åœ¨è¿›ç¨‹è®°å½• ProcessRecord r = null; if (caller != null) &#123; r = getRecordForAppLocked(caller); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when getting content provider \" + name); &#125; &#125; boolean checkCrossUser = true; // First check if this content provider has been published... //æ£€æŸ¥éœ€è¦çš„ContentProvideræ˜¯å¦å·²è¢«å‘å¸ƒ cpr = mProviderMap.getProviderByName(name, userId); // If that didn't work, check if it exists for user 0 and then // verify that it's a singleton provider before using it. //å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°è¯•ä»ç³»ç»Ÿç”¨æˆ·ä¸­æŸ¥æ‰¾å·²å‘å¸ƒçš„ContentProvider //å¹¶ç¡®ä¿å®ƒæ˜¯å¯ç”¨çš„å•ä¾‹ç»„ä»¶ï¼Œæ¡ä»¶å¦‚ä¸‹ï¼š //æ˜¯ç”¨æˆ·çº§åº”ç”¨ç¨‹åºä¸”ç»„ä»¶è®¾ç½®äº†å•ä¾‹flagä¸”æ‹¥æœ‰INTERACT_ACROSS_USERSæƒé™ æˆ– Appè¿è¡Œåœ¨systemè¿›ç¨‹ä¸­ æˆ– ç»„ä»¶è®¾ç½®äº†å•ä¾‹flagä¸”æ˜¯åŒä¸€ä¸ªApp if (cpr == null &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123; cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM); if (cpr != null) &#123; cpi = cpr.info; if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) &amp;&amp; isValidSingletonCall(r == null ? callingUid : r.uid, cpi.applicationInfo.uid)) &#123; userId = UserHandle.USER_SYSTEM; checkCrossUser = false; &#125; else &#123; cpr = null; cpi = null; &#125; &#125; &#125; //åˆ¤æ–­ContentProvideræ‰€åœ¨è¿›ç¨‹æ˜¯å¦å·²æ­»äº¡ ProcessRecord dyingProc = null; if (cpr != null &amp;&amp; cpr.proc != null) &#123; providerRunning = !cpr.proc.killed; // Note if killedByAm is also set, this means the provider process has just been // killed by AM (in ProcessRecord.kill()), but appDiedLocked() hasn't been called // yet. So we need to call appDiedLocked() here and let it clean up. // (See the commit message on I2c4ba1e87c2d47f2013befff10c49b3dc337a9a7 to see // how to test this case.) if (cpr.proc.killed &amp;&amp; cpr.proc.killedByAm) &#123; Slog.wtf(TAG, cpr.proc.toString() + \" was killed by AM but isn't really dead\"); // Now we are going to wait for the death before starting the new process. dyingProc = cpr.proc; &#125; &#125; ... &#125; ...&#125; é¦–å…ˆï¼Œç¬¬ä¸€éƒ¨åˆ†ï¼Œæ£€æŸ¥ç›®æ ‡ContentProvideræ˜¯å¦å·²è¢«å‘å¸ƒå¹¶è®°å½•åœ¨äº†mProviderMapä¸­ï¼Œæ³¨æ„è¿™é‡Œçš„mProviderMapæ˜¯AMSä¸­çš„ä¸€ä¸ªæˆå‘˜å˜é‡ï¼Œä¸€ç³»åˆ—Mapçš„ä¸€ä¸ªé›†åˆï¼Œå’ŒActivityThreadä¸­çš„mProviderMapä¸æ˜¯ä¸€ä¸ªä¸œè¥¿ã€‚å¦‚æœåœ¨å½“å‰ç”¨æˆ·ä¸­æ‰¾ä¸åˆ°ï¼Œä¸”å½“å‰ç”¨æˆ·ä¸æ˜¯ç³»ç»Ÿç”¨æˆ·ï¼ˆUserHandle.USER_SYSTEM == 0ï¼‰ï¼Œåˆ™å°è¯•ä»ç³»ç»Ÿç”¨æˆ·ä¸­æŸ¥æ‰¾åˆæ³•å¯ç”¨çš„å•ä¾‹ContentProviderï¼Œç¬¦åˆä»¥ä¸‹ä»»ä¸€ä¸€ä¸ªæ¡ä»¶çš„ContentProviderå³å¯è¢«è§†ä½œå•ä¾‹ContentProviderï¼š Appæ˜¯ç”¨æˆ·çº§åº”ç”¨ç¨‹åºï¼ˆuid &gt;= 10000ï¼‰ä¸”ContentProviderç»„ä»¶è®¾ç½®äº†å•ä¾‹flagï¼ˆandroid:singleUserï¼‰ä¸”Appæ‹¥æœ‰INTERACT_ACROSS_USERSæƒé™ Appè¿è¡Œåœ¨systemè¿›ç¨‹ä¸­ ContentProviderç»„ä»¶è®¾ç½®äº†å•ä¾‹flagï¼ˆandroid:singleUserï¼‰ä¸”æ˜¯åŒä¸€ä¸ªApp è‡³äºä¸ºä»€ä¹ˆè·¨ç”¨æˆ·è®¿é—®éœ€è¦å•ä¾‹è¿™ä¸ªæ¡ä»¶ï¼Œè¿™ä¸ªå’Œå¤šç”¨æˆ·ç›¸å…³ï¼Œæˆ‘ä¹Ÿä¸æ˜¯å¾ˆæ¸…æ¥šï¼Œä»¥åå¦‚æœåˆ†æåˆ°äº†å¤šç”¨æˆ·è¿™å—å†å›æ¥è¡¥å……ã€‚ç›®å‰å›½å†…å‚å•†çš„åº”ç”¨åˆ†èº«ã€æ‰‹æœºåˆ†èº«åŠŸèƒ½å¤§éƒ¨åˆ†ç”¨çš„å°±æ˜¯å¤šç”¨æˆ·æŠ€æœ¯ æ¥ç€é€šè¿‡ç›®æ ‡ContentProviderRecordæ˜¯å¦å­˜åœ¨å’Œå…¶æ‰€åœ¨è¿›ç¨‹æ˜¯å¦è¿˜å­˜æ´»åˆ¤æ–­ç›®æ ‡ContentProvideræ˜¯å¦åœ¨è¿è¡Œä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, int callingUid, String callingPackage, String callingTag, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; boolean providerRunning = false; synchronized(this) &#123; ... //ContentProvideræ­£åœ¨è¿è¡Œä¸­ if (providerRunning) &#123; cpi = cpr.info; //å¦‚æœæ­¤ContentProviderå¯ä»¥åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­ç›´æ¥è¿è¡Œï¼ˆåŒä¸€ä¸ªAppçš„åŒè¿›ç¨‹ æˆ– åŒä¸€ä¸ªAppä¸”Providerç»„ä»¶æ”¯æŒå¤šè¿›ç¨‹ï¼‰ //ç›´æ¥è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolderè®©è°ƒç”¨è€…è¿›ç¨‹è‡ªå·±å¯åŠ¨ContentProvider if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; ... //æƒé™æ£€æŸ¥ // This provider has been published or is in the process // of being published... but it is also allowed to run // in the caller's process, so don't make a connection // and just let the caller instantiate its own instance. ContentProviderHolder holder = cpr.newHolder(null); // don't give caller the provider object, it needs // to make its own. holder.provider = null; return holder; &#125; // Don't expose providers between normal apps and instant apps try &#123; if (AppGlobals.getPackageManager() .resolveContentProvider(name, 0 /*flags*/, userId) == null) &#123; return null; &#125; &#125; catch (RemoteException e) &#123; &#125; ... //æƒé™æ£€æŸ¥ final long origId = Binder.clearCallingIdentity(); // In this case the provider instance already exists, so we can // return it right away. //è·å–è¿æ¥å¹¶æ›´æ–°å¼•ç”¨è®¡æ•° conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag, stable); if (conn != null &amp;&amp; (conn.stableCount+conn.unstableCount) == 1) &#123; if (cpr.proc != null &amp;&amp; r != null &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_LOW_APP_ADJ) &#123; // If this is a perceptible app accessing the provider, // make sure to count it as being accessed and thus // back up on the LRU list. This is good because // content providers are often expensive to start. //æ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ mProcessList.updateLruProcessLocked(cpr.proc, false, null); &#125; &#125; final int verifiedAdj = cpr.proc.verifiedAdj; //æ›´æ–°è¿›ç¨‹adj boolean success = updateOomAdjLocked(cpr.proc, true, OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER); // XXX things have changed so updateOomAdjLocked doesn't actually tell us // if the process has been successfully adjusted. So to reduce races with // it, we will check whether the process still exists. Note that this doesn't // completely get rid of races with LMK killing the process, but should make // them much smaller. if (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123; success = false; &#125; maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name); // NOTE: there is still a race here where a signal could be // pending on the process even though we managed to update its // adj level. Not sure what to do about this, but at least // the race is now smaller. if (!success) &#123; // Uh oh... it looks like the provider's process // has been killed on us. We need to wait for a new // process to be started, and make sure its death // doesn't kill our process. Slog.wtf(TAG, \"Existing provider \" + cpr.name.flattenToShortString() + \" is crashing; detaching \" + r); //ContentProvideræ‰€åœ¨è¿›ç¨‹è¢«æ€äº†ï¼Œæ›´æ–°å¼•ç”¨è®¡æ•° boolean lastRef = decProviderCountLocked(conn, cpr, token, stable); //ä»æœ‰åˆ«çš„åœ°æ–¹å¯¹è¿™ä¸ªContentProvideræœ‰å¼•ç”¨ï¼Œç›´æ¥è¿”å›nullï¼ˆéœ€è¦ç­‰å¾…è¿›ç¨‹æ¸…ç†å¹²å‡€æ‰èƒ½é‡å¯ï¼‰ if (!lastRef) &#123; // This wasn't the last ref our process had on // the provider... we will be killed during cleaning up, bail. return null; &#125; // We'll just start a new process to host the content provider //å°†è¿è¡ŒçŠ¶æ€æ ‡ä¸ºfalseï¼Œä½¿å¾—é‡æ–°å¯åŠ¨ContentProvideræ‰€åœ¨è¿›ç¨‹ providerRunning = false; conn = null; dyingProc = cpr.proc; &#125; else &#123; cpr.proc.verifiedAdj = cpr.proc.setAdj; &#125; Binder.restoreCallingIdentity(origId); &#125; ... &#125; ...&#125; ç¬¬äºŒéƒ¨åˆ†ï¼Œå¦‚æœç›®æ ‡ContentProvideræ­£åœ¨è¿è¡Œä¸­ï¼Œé¦–å…ˆæ£€æŸ¥ç›®æ ‡ContentProvideræ˜¯å¦å¯ä»¥åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­ç›´æ¥è¿è¡Œï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹ä»»ä¸€ä¸€ä¸ªæ¡ä»¶ï¼š è°ƒç”¨è€…å’Œç›®æ ‡ContentProvideræ˜¯åŒä¸€ä¸ªAppä¸­çš„åŒè¿›ç¨‹ è°ƒç”¨è€…å’Œç›®æ ‡ContentProviderå±åŒä¸€ä¸ªAppä¸”ContentProviderç»„ä»¶æ”¯æŒå¤šè¿›ç¨‹ï¼ˆandroid:multiprocessï¼‰ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç›´æ¥è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolderè®©è°ƒç”¨è€…è¿›ç¨‹è‡ªå·±å¤„ç†è·å¾—ContentProviderå³å¯ï¼Œå…·ä½“é€»è¾‘åœ¨ActivityThread.installProvideræ–¹æ³•ä¸­ï¼Œåé¢ä¼šåˆ†æ å¦‚æœä¸æ»¡è¶³è¿™ç§æƒ…å†µï¼Œå³è°ƒç”¨æ–¹è¿›ç¨‹å’Œç›®æ ‡ContentProviderä¸åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œéœ€è¦è·¨è¿›ç¨‹è°ƒç”¨ï¼Œè·å–ContentProviderConnectionè¿æ¥å¹¶æ›´æ–°å¼•ç”¨è®¡æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, int callingUid, String callingPackage, String callingTag, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; boolean providerRunning = false; synchronized(this) &#123; ... //ContentProvideræœªåœ¨è¿è¡Œ if (!providerRunning) &#123; //é€šè¿‡PMSè·å–ContentProviderä¿¡æ¯ try &#123; cpi = AppGlobals.getPackageManager(). resolveContentProvider(name, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId); &#125; catch (RemoteException ex) &#123; &#125; if (cpi == null) &#123; return null; &#125; // If the provider is a singleton AND // (it's a call within the same user || the provider is a // privileged app) // Then allow connecting to the singleton provider boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) &amp;&amp; isValidSingletonCall(r == null ? callingUid : r.uid, cpi.applicationInfo.uid); if (singleton) &#123; userId = UserHandle.USER_SYSTEM; &#125; cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId); ... //å„é¡¹æ£€æŸ¥ ComponentName comp = new ComponentName(cpi.packageName, cpi.name); //é€šè¿‡Classï¼ˆandroid:nameå±æ€§ï¼‰è·å–ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId); //æ­¤ContentProvideræ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œ boolean firstClass = cpr == null; if (firstClass) &#123; final long ident = Binder.clearCallingIdentity(); ... //æƒé™å¤„ç† try &#123; //è·å–åº”ç”¨ä¿¡æ¯ ApplicationInfo ai = AppGlobals.getPackageManager(). getApplicationInfo( cpi.applicationInfo.packageName, STOCK_PM_FLAGS, userId); if (ai == null) &#123; Slog.w(TAG, \"No package info for content provider \" + cpi.name); return null; &#125; ai = getAppInfoForUser(ai, userId); //æ–°å»ºContentProviderè®°å½• cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton); &#125; catch (RemoteException ex) &#123; // pm is in same process, this will never happen. &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; else if (dyingProc == cpr.proc &amp;&amp; dyingProc != null) &#123; // The old stable connection's client should be killed during proc cleaning up, // so do not re-use the old ContentProviderRecord, otherwise the new clients // could get killed unexpectedly. //æ—§çš„ContentProviderè¿›ç¨‹åœ¨æ­»äº¡è¿‡ç¨‹ä¸­ï¼Œä¸è¦å¤ç”¨æ—§çš„ContentProviderRecordï¼Œé¿å…å‡ºç°é¢„æœŸä¹‹å¤–çš„é—®é¢˜ cpr = new ContentProviderRecord(cpr); // This is sort of \"firstClass\" firstClass = true; &#125; //å¦‚æœæ­¤ContentProviderå¯ä»¥åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­ç›´æ¥è¿è¡Œï¼ˆåŒä¸€ä¸ªAppçš„åŒè¿›ç¨‹ æˆ– åŒä¸€ä¸ªAppä¸”Providerç»„ä»¶æ”¯æŒå¤šè¿›ç¨‹ï¼‰ //ç›´æ¥è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolderè®©è°ƒç”¨è€…è¿›ç¨‹è‡ªå·±å¯åŠ¨ContentProvider if (r != null &amp;&amp; cpr.canRunHere(r)) &#123; // If this is a multiprocess provider, then just return its // info and allow the caller to instantiate it. Only do // this if the provider is the same user as the caller's // process, or can run as root (so can be in any process). return cpr.newHolder(null); &#125; // This is single process, and our app is now connecting to it. // See if we are already in the process of launching this // provider. //æŸ¥æ‰¾æ­£åœ¨å¯åŠ¨ä¸­çš„ContentProvider final int N = mLaunchingProviders.size(); int i; for (i = 0; i &lt; N; i++) &#123; if (mLaunchingProviders.get(i) == cpr) &#123; break; &#125; &#125; // If the provider is not already being launched, then get it // started. //ç›®æ ‡ContentProviderä¸åœ¨å¯åŠ¨ä¸­ if (i &gt;= N) &#123; final long origId = Binder.clearCallingIdentity(); try &#123; // Content provider is now in use, its package can't be stopped. //å°†AppçŠ¶æ€ç½®ä¸ºunstoppedï¼Œè®¾ç½®ä¼‘çœ çŠ¶æ€ä¸ºfalse try &#123; AppGlobals.getPackageManager().setPackageStoppedState( cpr.appInfo.packageName, false, userId); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + cpr.appInfo.packageName + \": \" + e); &#125; // Use existing process if already started //è·å–ç›®æ ‡ContentProvideræ‰€åœ¨è¿›ç¨‹è®°å½• ProcessRecord proc = getProcessRecordLocked( cpi.processName, cpr.appInfo.uid, false); if (proc != null &amp;&amp; proc.thread != null &amp;&amp; !proc.killed) &#123; //è¿›ç¨‹å­˜æ´» if (!proc.pubProviders.containsKey(cpi.name)) &#123; //å°†ContentProviderRecordä¿å­˜åˆ°è¿›ç¨‹å·²å‘å¸ƒContentProvideråˆ—è¡¨ä¸­ proc.pubProviders.put(cpi.name, cpr); try &#123; //è°ƒåº¦ActivityThreadç›´æ¥å®‰è£…ContentProvider proc.thread.scheduleInstallProvider(cpi); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; else &#123; //è¿›ç¨‹æ­»äº¡ //å¯åŠ¨Appï¼ˆAppå¯åŠ¨è¿‡ç¨‹ä¸­ä¼šè‡ªåŠ¨å¯åŠ¨ContentProviderï¼‰ proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, new HostingRecord(\"content provider\", new ComponentName(cpi.applicationInfo.packageName, cpi.name)), ZYGOTE_POLICY_FLAG_EMPTY, false, false, false); if (proc == null) &#123; ... return null; &#125; &#125; cpr.launchingApp = proc; //å°†ç›®æ ‡ContentProvideræ·»åŠ åˆ°å¯åŠ¨ä¸­åˆ—è¡¨ mLaunchingProviders.add(cpr); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; // Make sure the provider is published (the same provider class // may be published under multiple names). if (firstClass) &#123; mProviderMap.putProviderByClass(comp, cpr); &#125; mProviderMap.putProviderByName(name, cpr); //è·å–è¿æ¥å¹¶æ›´æ–°å¼•ç”¨è®¡æ•° conn = incProviderCountLocked(r, cpr, token, callingUid, callingPackage, callingTag, stable); if (conn != null) &#123; conn.waiting = true; &#125; &#125; grantImplicitAccess(userId, null /*intent*/, callingUid, UserHandle.getAppId(cpi.applicationInfo.uid)); &#125; ...&#125; ç¬¬ä¸‰éƒ¨åˆ†ï¼Œå¦‚æœç›®æ ‡ContentProvideræœªåœ¨è¿è¡Œï¼Œå…ˆé€šè¿‡PMSè·å–ContentProviderä¿¡æ¯ï¼Œæ¥ç€å°è¯•é€šè¿‡Classï¼ˆandroid:nameå±æ€§ï¼‰è·å–ContentProviderRecordï¼Œå¦‚æœè·å–ä¸åˆ°ï¼Œè¯´æ˜è¿™ä¸ªContentProvideræ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œï¼ˆå¼€æœºåï¼‰ï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦æ–°å»ºContentProviderRecordï¼Œå¦‚æœè·å–åˆ°äº†ï¼Œä½†æ˜¯å…¶æ‰€åœ¨è¿›ç¨‹è¢«æ ‡è®°ä¸ºæ­£åœ¨æ­»äº¡ï¼Œæ­¤æ—¶åŒæ ·éœ€è¦æ–°å»ºContentProviderRecordï¼Œä¸è¦å¤ç”¨æ—§çš„ContentProviderRecordï¼Œé¿å…å‡ºç°é¢„æœŸä¹‹å¤–çš„é—®é¢˜ æ¥ä¸‹æ¥åŒæ ·æ£€æŸ¥ç›®æ ‡ContentProvideræ˜¯å¦å¯ä»¥åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­ç›´æ¥è¿è¡Œï¼Œå¦‚æœå¯ä»¥ç›´æ¥è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolderè®©è°ƒç”¨è€…è¿›ç¨‹è‡ªå·±å¯åŠ¨è·å–ContentProvider æ¥ç€æ£€æŸ¥æ­£åœ¨å¯åŠ¨ä¸­çš„ContentProvideråˆ—è¡¨ï¼Œå¦‚æœä¸åœ¨åˆ—è¡¨ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ‰‹åŠ¨å¯åŠ¨å®ƒï¼Œæ­¤æ—¶åˆæœ‰ä¸¤ç§æƒ…å†µï¼š ContentProvideræ‰€åœ¨è¿›ç¨‹å·²å¯åŠ¨ï¼šå¦‚æœè¿›ç¨‹å·²å‘å¸ƒContentProvideråˆ—è¡¨ä¸­ä¸åŒ…å«è¿™ä¸ªContentProviderRecordï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œç„¶åè°ƒç”¨ç›®æ ‡è¿›ç¨‹ä¸­çš„ApplicationThread.scheduleInstallProvideræ–¹æ³•å®‰è£…å¯åŠ¨ContentProvider ContentProvideræ‰€åœ¨è¿›ç¨‹æœªå¯åŠ¨ï¼šå¯åŠ¨ç›®æ ‡è¿›ç¨‹ï¼Œç›®æ ‡è¿›ç¨‹å¯åŠ¨è¿‡ç¨‹ä¸­ä¼šè‡ªåŠ¨å®‰è£…å¯åŠ¨ContentProviderï¼ˆActivityThread.handleBindApplicationæ–¹æ³•ä¸­ï¼‰ æœ€åæ›´æ–°mProviderMapï¼Œè·å–ContentProviderConnectionè¿æ¥å¹¶æ›´æ–°å¼•ç”¨è®¡æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, int callingUid, String callingPackage, String callingTag, boolean stable, int userId) &#123; ContentProviderRecord cpr; ContentProviderConnection conn = null; ProviderInfo cpi = null; boolean providerRunning = false; // Wait for the provider to be published... final long timeout = SystemClock.uptimeMillis() + ContentResolver.CONTENT_PROVIDER_READY_TIMEOUT_MILLIS; boolean timedOut = false; synchronized (cpr) &#123; while (cpr.provider == null) &#123; //ContentProviderå¯åŠ¨è¿‡ç¨‹ä¸­è¿›ç¨‹æ­»äº¡ï¼Œè¿”å›null if (cpr.launchingApp == null) &#123; ... return null; &#125; try &#123; //è®¡ç®—æœ€å¤§ç­‰å¾…æ—¶é—´ final long wait = Math.max(0L, timeout - SystemClock.uptimeMillis()); if (conn != null) &#123; conn.waiting = true; &#125; //é‡Šæ”¾é”ï¼Œç­‰å¾…ContentProviderå¯åŠ¨å®Œæˆ cpr.wait(wait); //ç­‰å¾…æ—¶é—´å·²è¿‡ï¼ŒContentProviderè¿˜æ˜¯æ²¡èƒ½å¯åŠ¨å®Œæˆå¹¶å‘å¸ƒï¼Œè¶…æ—¶ if (cpr.provider == null) &#123; timedOut = true; break; &#125; &#125; catch (InterruptedException ex) &#123; &#125; finally &#123; if (conn != null) &#123; conn.waiting = false; &#125; &#125; &#125; &#125; if (timedOut) &#123; ... //è¶…æ—¶å¤„ç† return null; &#125; //è¿”å›æ–°çš„ContentProviderHolder return cpr.newHolder(conn);&#125; ç¬¬å››éƒ¨åˆ†ï¼Œå¦‚æœContentProviderå·²å­˜åœ¨ï¼Œç›´æ¥æ–°å»ºä¸€ä¸ªContentProviderHolderè¿”å›ï¼Œå¦‚æœContentProviderä¹‹å‰ä¸å­˜åœ¨ï¼Œç°åœ¨æ­£åœ¨å¯åŠ¨ä¸­ï¼Œåˆ™ä»¥å½“å‰æ—¶é—´åŠ ä¸ŠCONTENT_PROVIDER_READY_TIMEOUT_MILLISæ¨ç®—å‡ºä¸€ä¸ªè¶…æ—¶æ—¶é—´ï¼Œç»™ç›®æ ‡ContentProviderRecordä¸Šé”åï¼Œè°ƒç”¨waitæ–¹æ³•ç­‰å¾…ï¼Œç›´åˆ°ContentProvideræˆåŠŸå‘å¸ƒånotifyè§£é™¤waitçŠ¶æ€ï¼ˆåœ¨AMS.publishContentProvidersæ–¹æ³•ä¸­ï¼Œä¹‹åä¼šåˆ†æåˆ°ï¼‰ï¼Œæˆ–ä¸€ç›´ç­‰å¾…ç›´åˆ°è¶…æ—¶ã€‚waitçŠ¶æ€è§£é™¤åï¼Œåˆ¤æ–­å†…éƒ¨ContentProvideræ˜¯å¦å·²è¢«èµ‹å€¼ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™å¯ä»¥æ–­å®šè¶…æ—¶ï¼Œæ­¤æ—¶è¿”å›nullï¼Œå¦‚æœ‰ï¼Œåˆ™è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolder ActivityThread.installProviderç”±äºè¿™ä¸ªæ–¹æ³•åŒæ—¶åŒ…å«äº†å¯åŠ¨å®‰è£…æœ¬åœ°ContentProviderå’Œè·å–å®‰è£…è¿œç¨‹ContentProviderçš„é€»è¾‘ï¼Œæ‰€ä»¥æ”¾åˆ°åé¢å¯åŠ¨ContentProviderç« èŠ‚é‡Œä¸€èµ·åˆ†æ å¯åŠ¨ContentProviderä»å‰é¢çš„ç« èŠ‚è·å–ContentProviderä¸­ï¼Œæˆ‘ä»¬å·²ç»å½’çº³å‡ºContentProviderçš„å¯åŠ¨åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œæ¥ç€æˆ‘ä»¬å°±æ¥åˆ†æåœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼ŒContentProviderçš„å¯åŠ¨è·¯å¾„ è¿›ç¨‹å·²å¯åŠ¨åœ¨è¿›ç¨‹å·²å¯åŠ¨çš„æƒ…å†µä¸‹ï¼Œå¦‚æœè¿›ç¨‹å·²å‘å¸ƒContentProvideråˆ—è¡¨ä¸­ä¸åŒ…å«è¿™ä¸ªContentProviderRecordï¼Œåˆ™å°†å…¶æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œç„¶åè°ƒç”¨ç›®æ ‡è¿›ç¨‹ä¸­çš„ApplicationThread.scheduleInstallProvideræ–¹æ³•å®‰è£…å¯åŠ¨ContentProvider ApplicationThread.scheduleInstallProviderä¼šé€šè¿‡Handerå‘é€ä¸€æ¡whatå€¼ä¸ºH.INSTALL_PROVIDERçš„æ¶ˆæ¯ï¼Œæˆ‘ä»¬æ ¹æ®è¿™ä¸ªwhatå€¼æœç´¢ï¼Œå‘ç°ä¼šèµ°åˆ°ActivityThread.handleInstallProvideræ–¹æ³•ä¸­ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•å†…åˆä¼šè°ƒç”¨installContentProvidersæ–¹æ³•å®‰è£…å¯åŠ¨ContentProvider è¿›ç¨‹æœªå¯åŠ¨åœ¨è¿›ç¨‹æœªå¯åŠ¨çš„æƒ…å†µä¸‹ï¼Œç›´æ¥å¯åŠ¨ç›®æ ‡è¿›ç¨‹ï¼Œåœ¨ä¹‹å‰çš„æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ é‡Œï¼Œæˆ‘ä»¬åˆ†æäº†Appçš„å¯åŠ¨æµç¨‹ï¼Œå…¶ä¸­æœ‰ä¸¤ä¸ªåœ°æ–¹å¯¹å¯åŠ¨ContentProviderè‡³å…³é‡è¦ AMS.attachApplicationLockedåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¼šè°ƒç”¨generateApplicationProvidersLockedæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... //normalModeä¸€èˆ¬æƒ…å†µä¸‹å‡ä¸ºtrue List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null; ...&#125;private final List&lt;ProviderInfo&gt; generateApplicationProvidersLocked(ProcessRecord app) &#123; List&lt;ProviderInfo&gt; providers = null; try &#123; //é€šè¿‡PMSè·å–Appä¸­åŒä¸€ä¸ªè¿›ç¨‹å†…çš„æ‰€æœ‰çš„ContentProviderç»„ä»¶ä¿¡æ¯ providers = AppGlobals.getPackageManager() .queryContentProviders(app.processName, app.uid, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS | MATCH_DEBUG_TRIAGED_MISSING, /*metadastaKey=*/ null) .getList(); &#125; catch (RemoteException ex) &#123; &#125; int userId = app.userId; if (providers != null) &#123; int N = providers.size(); //æœ‰å¿…è¦çš„æƒ…å†µä¸‹è¿›è¡ŒMapæ‰©å®¹ app.pubProviders.ensureCapacity(N + app.pubProviders.size()); for (int i=0; i&lt;N; i++) &#123; // TODO: keep logic in sync with installEncryptionUnawareProviders ProviderInfo cpi = (ProviderInfo)providers.get(i); //å¯¹äºå•ä¾‹ContentProviderï¼Œéœ€è¦åœ¨é»˜è®¤ç”¨æˆ·ä¸­å¯åŠ¨ï¼Œå¦‚æœä¸æ˜¯é»˜è®¤ç”¨æˆ·çš„è¯åˆ™ç›´æ¥å°†å…¶ä¸¢å¼ƒæ‰ï¼Œä¸å¯åŠ¨ boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags); if (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123; // This is a singleton provider, but a user besides the // default user is asking to initialize a process it runs // in... well, no, it doesn't actually run in this process, // it runs in the process of the default user. Get rid of it. providers.remove(i); N--; i--; continue; &#125; ComponentName comp = new ComponentName(cpi.packageName, cpi.name); ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId); if (cpr == null) &#123; //æ–°å»ºContentProviderRecordå¹¶å°†å…¶åŠ å…¥åˆ°ç¼“å­˜ä¸­ cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton); mProviderMap.putProviderByClass(comp, cpr); &#125; //å°†ContentProviderRecordä¿å­˜åˆ°è¿›ç¨‹å·²å‘å¸ƒContentProvideråˆ—è¡¨ä¸­ app.pubProviders.put(cpi.name, cpr); if (!cpi.multiprocess || !\"android\".equals(cpi.packageName)) &#123; // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. //å°†Appæ·»åŠ è‡³è¿›ç¨‹ä¸­è¿è¡Œçš„åŒ…åˆ—è¡¨ä¸­ app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.longVersionCode, mProcessStats); &#125; notifyPackageUse(cpi.applicationInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER); &#125; &#125; return providers;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯è·å–éœ€è¦å¯åŠ¨çš„ContentProviderçš„ContentProviderRecordï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡å¯åŠ¨è¿™ä¸ªContentProvideråˆ™éœ€è¦æ–°å»ºä¸€ä¸ªContentProviderRecordå¹¶å°†å…¶å­˜å…¥ç¼“å­˜ï¼Œç„¶åå°†å…¶ä¿å­˜åˆ°è¿›ç¨‹å·²å‘å¸ƒContentProvideråˆ—è¡¨ä¸­ï¼Œä»¥ä¾›åé¢ä½¿ç”¨ã€‚åŒæ—¶è¿™ä¸ªæ–¹æ³•è¿”å›äº†éœ€è¦å¯åŠ¨çš„ProviderInfoåˆ—è¡¨ï¼ŒAMS.attachApplicationLockedæ–¹æ³•å¯ä»¥æ ¹æ®è¿™ä¸ªåˆ—è¡¨åˆ¤æ–­æ˜¯å¦æœ‰éœ€è¦å¯åŠ¨çš„ContentProviderå¹¶è®¾ç½®ContentProviderå¯åŠ¨è¶…æ—¶æ£€æµ‹ ActivityThread.handleBindApplication123456789101112131415161718192021222324252627282930313233343536373839private void handleBindApplication(AppBindData data) &#123; ... try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. //åˆ›å»ºApplication app = data.info.makeApplication(data.restrictedBackupMode, null); ... mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class //åœ¨éå—é™æ¨¡å¼ä¸‹å¯åŠ¨ContentProvider if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); &#125; &#125; ... //æ‰§è¡ŒApplicationçš„onCreateæ–¹æ³• try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; finally &#123; // If the app targets &lt; O-MR1, or doesn't change the thread policy // during startup, clobber the policy to maintain behavior of b/36951662 if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ç›´æ¥è°ƒç”¨äº†installContentProvidersæ–¹æ³•å®‰è£…å¯åŠ¨ContentProvider å¦å¤–æä¸€ç‚¹ï¼Œä¸ºä»€ä¹ˆæˆ‘è¦æŠŠApplicationçš„åˆ›å»ºå’ŒonCreateä¹Ÿæ”¾è¿›æ¥å‘¢ï¼Ÿç°åœ¨å¸‚é¢ä¸Šæœ‰å¾ˆå¤šåº“ï¼ŒåŒ…æ‹¬å¾ˆå¤šæ•™ç¨‹å‘Šè¯‰æˆ‘ä»¬ï¼Œå¯ä»¥é€šè¿‡æ³¨å†ŒContentProviderçš„æ–¹å¼åˆå§‹åŒ–SDKï¼Œè·å–å…¨å±€Contextï¼Œæ¯”å¦‚è¯´è‘—åçš„å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·LeakCanaryçš„æ–°ç‰ˆæœ¬ï¼Œæƒ³è¦ä½¿ç”¨å®ƒï¼Œç›´æ¥æ·»åŠ å®ƒçš„ä¾èµ–å°±è¡Œäº†ï¼Œä¸éœ€è¦å¯¹ä»£ç åšå“ªæ€•ä¸€ç‚¹çš„æ”¹åŠ¨ï¼Œç©¶å…¶åŸç†ï¼Œå°±æ˜¯å› ä¸ºContentProviderçš„å¯åŠ¨æ—¶æœºæ˜¯åœ¨Applicationåˆ›å»ºåï¼ŒApplication.onCreateè°ƒç”¨å‰ï¼Œå¹¶ä¸”ContentProviderå†…çš„Contextæˆå‘˜å˜é‡å¤§æ¦‚ç‡å°±æ˜¯Applicationï¼Œå¤§å®¶ä»¥ååœ¨å¼€å‘è¿‡ç¨‹ä¸­ä¹Ÿå¯ä»¥å¦™ç”¨è¿™ä¸€ç‚¹ ActivityThread.installContentProviderså¥½äº†ï¼Œç°åœ¨è¿™ä¸¤ç§æƒ…å†µæœ€ç»ˆéƒ½èµ°åˆ°äº†ActivityThread.installContentProvidersæ–¹æ³•ä¸­ï¼Œé‚£æˆ‘ä»¬æ¥ä¸‹æ¥å°±å¥½å¥½åˆ†æContentProviderå®é™…çš„å¯åŠ¨å®‰è£…æµç¨‹ 12345678910111213141516171819202122private void installContentProviders( Context context, List&lt;ProviderInfo&gt; providers) &#123; final ArrayList&lt;ContentProviderHolder&gt; results = new ArrayList&lt;&gt;(); for (ProviderInfo cpi : providers) &#123; //é€ä¸ªå¯åŠ¨ ContentProviderHolder cph = installProvider(context, null, cpi, false /*noisy*/, true /*noReleaseNeeded*/, true /*stable*/); if (cph != null) &#123; cph.noReleaseNeeded = true; results.add(cph); &#125; &#125; try &#123; //å‘å¸ƒContentProvider ActivityManager.getService().publishContentProviders( getApplicationThread(), results); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œä¾¿åˆ©æ‰€æœ‰å¾…å¯åŠ¨çš„ContentProviderä¿¡æ¯åˆ—è¡¨ï¼Œé€ä¸ªå¯åŠ¨å®‰è£…ContentProviderï¼Œæœ€åä¸€èµ·å‘å¸ƒ ActivityThread.installProvideræˆ‘ä»¬å…ˆçœ‹installProvideræ–¹æ³•ï¼Œæˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­åˆ†æåˆ°ï¼Œè·å–ContentProviderçš„æ—¶å€™ä¹Ÿä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œè¿™æ¬¡æˆ‘ä»¬å°±ç»“åˆèµ·æ¥ä¸€èµ·åˆ†æ é€šè¿‡ä¸Šæ–‡çš„ä»£ç ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæœ‰ä¸¤å¤„åœ°æ–¹ä¼šè°ƒç”¨installProvideræ–¹æ³•ï¼Œæ–¹æ³•çš„å…¥å‚æœ‰ä¸‰ç§å½¢å¼ï¼Œåˆ†åˆ«ä¸ºï¼š holderä¸ä¸ºnullï¼Œinfoä¸ä¸ºnullï¼Œholder.providerä¸ºnullï¼šåœ¨ActivityThread.acquireProvideræ–¹æ³•ä¸­è¢«è°ƒç”¨ï¼Œè·¯å¾„ä¸º æ²¡æœ‰è·å–åˆ°å·²å­˜åœ¨çš„ContentProvider -&gt; AMS.getContentProvider -&gt; AMS.getContentProviderImpl -&gt; å‘ç°ç›®æ ‡ContentProviderå¯ä»¥åœ¨è°ƒç”¨è€…è¿›ç¨‹ä¸­ç›´æ¥è¿è¡Œ -&gt; ç›´æ¥è¿”å›ä¸€ä¸ªæ–°çš„ContentProviderHolderï¼ˆåŒ…å«ProviderInfoï¼‰ -&gt; ActivityThread.installProviderï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹installProvideræ–¹æ³•ä¼šåœ¨æœ¬åœ°å¯åŠ¨å®‰è£…ContentProvider holderä¸ºnullï¼Œinfoä¸ä¸ºnullï¼šåœ¨ActivityThread.installContentProvidersæ–¹æ³•ä¸­è¢«è°ƒç”¨ï¼Œä¸¤æ¡è·¯å¾„ï¼Œä¸€æ˜¯Appè¿›ç¨‹å¯åŠ¨åè‡ªåŠ¨æ‰§è¡Œï¼ŒäºŒæ˜¯åœ¨AMS.getContentProvideræ–¹æ³•ä¸­å‘ç°ç›®æ ‡è¿›ç¨‹å·²å¯åŠ¨ä½†æ˜¯ContentProvideræœªå¯åŠ¨ï¼Œè°ƒç”¨ActivityThread.scheduleInstallProvideræ–¹æ³•æ‰§è¡Œï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹installProvideræ–¹æ³•ä¼šåœ¨æœ¬åœ°å¯åŠ¨å®‰è£…ContentProvider holderä¸ä¸ºnullï¼Œholder.providerä¸ä¸ºnullï¼šåœ¨ActivityThread.acquireProvideræ–¹æ³•ä¸­è¢«è°ƒç”¨ï¼Œè·¯å¾„ä¸º æ²¡æœ‰è·å–åˆ°å·²å­˜åœ¨çš„ContentProvider -&gt; AMS.getContentProvider -&gt; AMS.getContentProviderImpl -&gt; è·å–åˆ°ç›®æ ‡è¿›ç¨‹çš„è¿œç¨‹ContentProviderå¼•ç”¨ -&gt; åŒ…è£…æˆContentProviderHolderè¿”å› -&gt; ActivityThread.installProviderï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹installProvideræ–¹æ³•ç›´æ¥å¯ä»¥è·å–åˆ°è¿œç¨‹ContentProviderå¼•ç”¨ï¼Œç„¶åè¿›è¡Œå¤„ç† æˆ‘ä»¬å°†è¿™ä¸‰ç§æƒ…å†µåˆ†æˆä¸¤ç§caseåˆ†åˆ«åˆ†æ æœ¬åœ°å¯åŠ¨ContentProvider123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; if (holder == null || holder.provider == null) &#123; //å¯åŠ¨æœ¬åœ°ContentProvider Context c = null; ApplicationInfo ai = info.applicationInfo; //é¦–å…ˆè·å–Contextï¼Œä¸€èˆ¬æƒ…å†µä¸‹å°±æ˜¯Application if (context.getPackageName().equals(ai.packageName)) &#123; c = context; &#125; else if (mInitialApplication != null &amp;&amp; mInitialApplication.getPackageName().equals(ai.packageName)) &#123; c = mInitialApplication; &#125; else &#123; try &#123; c = context.createPackageContext(ai.packageName, Context.CONTEXT_INCLUDE_CODE); &#125; catch (PackageManager.NameNotFoundException e) &#123; // Ignore &#125; &#125; if (c == null) &#123; return null; &#125; //Split ApksåŠ¨æ€åŠ è½½ç›¸å…³ if (info.splitName != null) &#123; try &#123; c = c.createContextForSplit(info.splitName); &#125; catch (NameNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; try &#123; final java.lang.ClassLoader cl = c.getClassLoader(); //è·å–åº”ç”¨ä¿¡æ¯ LoadedApk packageInfo = peekPackageInfo(ai.packageName, true); if (packageInfo == null) &#123; // System startup case. packageInfo = getSystemContext().mPackageInfo; &#125; //é€šè¿‡AppComponentFactoryå®ä¾‹åŒ–ContentProvider localProvider = packageInfo.getAppFactory() .instantiateProvider(cl, info.name); //Transportç±»ï¼Œç»§æ‰¿è‡ªContentProviderNativeï¼ˆBinderæœåŠ¡ç«¯ï¼‰ provider = localProvider.getIContentProvider(); if (provider == null) &#123; return null; &#125; // XXX Need to create the correct context for this provider. //åˆå§‹åŒ–ContentProviderï¼Œè°ƒç”¨å…¶onCreateæ–¹æ³• localProvider.attachInfo(c, info); &#125; catch (java.lang.Exception e) &#123; if (!mInstrumentation.onException(null, e)) &#123; throw new RuntimeException( \"Unable to get provider \" + info.name + \": \" + e.toString(), e); &#125; return null; &#125; &#125; else &#123; //è·å–å¤–éƒ¨ContentProvider ... &#125; ContentProviderHolder retHolder; synchronized (mProviderMap) &#123; //å¯¹äºæœ¬åœ°ContentProvideræ¥è¯´ï¼Œè¿™é‡Œçš„å®é™…ç±»å‹æ˜¯Transportï¼Œç»§æ‰¿è‡ªContentProviderNativeï¼ˆBinderæœåŠ¡ç«¯ï¼‰ IBinder jBinder = provider.asBinder(); if (localProvider != null) &#123; //æœ¬åœ°å¯åŠ¨ContentProviderçš„æƒ…å†µ ComponentName cname = new ComponentName(info.packageName, info.name); ProviderClientRecord pr = mLocalProvidersByName.get(cname); if (pr != null) &#123; //å¦‚æœå·²ç»å­˜åœ¨ç›¸åº”çš„ContentProviderè®°å½•ï¼Œä½¿ç”¨å…¶å†…éƒ¨å·²å­˜åœ¨çš„ContentProvider provider = pr.mProvider; &#125; else &#123; //å¦åˆ™ä½¿ç”¨æ–°åˆ›å»ºçš„ContentProvider holder = new ContentProviderHolder(info); holder.provider = provider; //å¯¹äºæœ¬åœ°ContentProvideræ¥è¯´ï¼Œä¸å­˜åœ¨é‡Šæ”¾å¼•ç”¨è¿™ç§æƒ…å†µ holder.noReleaseNeeded = true; //åˆ›å»ºProviderClientRecordå¹¶å°†å…¶ä¿å­˜åˆ°mProviderMapæœ¬åœ°ç¼“å­˜ä¸­ pr = installProviderAuthoritiesLocked(provider, localProvider, holder); //ä¿å­˜ProviderClientRecordåˆ°æœ¬åœ°ç¼“å­˜ä¸­ mLocalProviders.put(jBinder, pr); mLocalProvidersByName.put(cname, pr); &#125; retHolder = pr.mHolder; &#125; else &#123; //è·å–è¿œç¨‹ContentProviderçš„æƒ…å†µ ... &#125; &#125; return retHolder;&#125; æˆ‘ä»¬åœ¨è¿™é‡Œæ‰¾åˆ°äº†ContentProvideråˆ›å»ºå¹¶å¯åŠ¨çš„å…¥å£ï¼Œé¦–å…ˆé€šè¿‡ä¼ å…¥çš„Contextï¼ˆå®é™…ä¸Šå°±æ˜¯Applicationï¼‰åˆ¤æ–­å¹¶ç¡®å®šåˆ›å»ºå¹¶ç»™ContentProviderä½¿ç”¨çš„çš„Contextæ˜¯ä»€ä¹ˆï¼ˆä¸€èˆ¬æƒ…å†µä¸‹ä¹Ÿæ˜¯Applicationï¼‰ï¼Œç„¶åè·å–åˆ°åº”ç”¨ä¿¡æ¯LoadedApkï¼Œå†é€šè¿‡å®ƒå¾—åˆ°AppComponentFactoryï¼ˆå‰é¢çš„æ–‡ç« ä¸­ä»‹ç»è¿‡ï¼Œå¦‚æœæ²¡æœ‰åœ¨AndroidManifestä¸­è®¾ç½®android:appComponentFactoryå±æ€§ï¼Œä½¿ç”¨çš„ä¾¿æ˜¯é»˜è®¤çš„AppComponentFactoryï¼‰ï¼Œæ¥ç€é€šè¿‡AppComponentFactory.instantiateProvideræ–¹æ³•å®ä¾‹åŒ–ContentProviderå¯¹è±¡ 12345public @NonNull ContentProvider instantiateProvider(@NonNull ClassLoader cl, @NonNull String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (ContentProvider) cl.loadClass(className).newInstance();&#125; é»˜è®¤çš„è¯å°±æ˜¯é€šè¿‡ClassNameåå°„è°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°å®ä¾‹åŒ–ContentProviderå¯¹è±¡ï¼Œæœ€åå†è°ƒç”¨ContentProvider.attachInfoæ–¹æ³•åˆå§‹åŒ– 123456789101112public void attachInfo(Context context, ProviderInfo info) &#123; attachInfo(context, info, false);&#125;private void attachInfo(Context context, ProviderInfo info, boolean testing) &#123; ... if (mContext == null) &#123; mContext = context; ... ContentProvider.this.onCreate(); &#125;&#125; è¯¦ç»†å†…å®¹æˆ‘ä»¬å°±ä¸åˆ†æäº†ï¼Œåªéœ€è¦çŸ¥é“è¿™é‡Œç»™mContextèµ‹äº†å€¼ï¼Œç„¶åè°ƒç”¨äº†ContentProvider.onCreateæ–¹æ³•å°±å¯ä»¥äº† åˆ°äº†è¿™ä¸€æ­¥ï¼ŒContentProviderå°±ç®—æ˜¯å¯åŠ¨å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥éœ€è¦æ‰§è¡Œä¸€äº›å®‰è£…æ­¥éª¤ï¼Œå…¶å®ä¹Ÿå°±æ˜¯å¯¹ç¼“å­˜ç­‰è¿›è¡Œä¸€äº›å¤„ç†ã€‚åœ¨ContentProviderå®ä¾‹åŒ–åï¼Œä¼šè°ƒç”¨å…¶getIContentProvideræ–¹æ³•ç»™providerå˜é‡èµ‹å€¼ï¼Œè¿™é‡Œè·å¾—çš„å¯¹è±¡å…¶å®æ˜¯ä¸€ä¸ªTransportå¯¹è±¡ï¼Œç»§æ‰¿è‡ªContentProviderNativeï¼Œæ˜¯ä¸€ä¸ªBinderæœåŠ¡ç«¯å¯¹è±¡ï¼Œåœ¨ContentProvideråˆå§‹åŒ–åï¼Œä¼šå¯¹Transportå¯¹è±¡è°ƒç”¨asBinderæ–¹æ³•è·å¾—Binderå¯¹è±¡ï¼Œè¿™é‡Œè·å¾—çš„å…¶å®è¿˜æ˜¯è‡ªå·±æœ¬èº«ï¼Œæ¥ç€ä»ç¼“å­˜ä¸­å°è¯•è·å–ProviderClientRecordå¯¹è±¡ï¼Œå¦‚æœè·å–åˆ°äº†ï¼Œè¯´æ˜å·²ç»å­˜åœ¨äº†ç›¸åº”çš„ContentProviderï¼Œä½¿ç”¨ProviderClientRecordå†…éƒ¨çš„ContentProviderï¼Œåˆšåˆšæ–°åˆ›å»ºçš„é‚£ä¸ªå°±å¯ä»¥ä¸¢å¼ƒäº†ï¼Œå¦‚æœæ²¡è·å–åˆ°ï¼Œå°±å»æ–°å»ºContentProviderHolderä»¥åŠProviderClientRecordï¼Œç„¶åå°†ä»–ä»¬æ·»åŠ åˆ°å„ç§ç¼“å­˜ä¸­ï¼Œè‡³æ­¤ï¼ŒContentProviderçš„å®‰è£…è¿‡ç¨‹ä¹Ÿåˆ°æ­¤ç»“æŸ è·å–å¤„ç†è¿œç¨‹ContentProvider12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private ContentProviderHolder installProvider(Context context, ContentProviderHolder holder, ProviderInfo info, boolean noisy, boolean noReleaseNeeded, boolean stable) &#123; ContentProvider localProvider = null; IContentProvider provider; if (holder == null || holder.provider == null) &#123; //å¯åŠ¨æœ¬åœ°ContentProvider ... &#125; else &#123; //è·å–å¤–éƒ¨ContentProvider //å®é™…ç±»å‹ä¸ºContentProviderProxy provider = holder.provider; &#125; ContentProviderHolder retHolder; synchronized (mProviderMap) &#123; //å¯¹äºå¤–éƒ¨ContentProvideræ¥è¯´ï¼Œè¿™é‡Œçš„å®é™…ç±»å‹æ˜¯BinderProxy IBinder jBinder = provider.asBinder(); if (localProvider != null) &#123; //æœ¬åœ°å¯åŠ¨ContentProviderçš„æƒ…å†µ ... &#125; else &#123; //è·å–è¿œç¨‹ContentProviderçš„æƒ…å†µ ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc != null) &#123; //å¦‚æœContentProviderå¼•ç”¨å·²å­˜åœ¨ // We need to transfer our new reference to the existing // ref count, releasing the old one... but only if // release is needed (that is, it is not running in the // system process). //å¯¹äºè¿œç¨‹ContentProvideræ¥è¯´ï¼Œå¦‚æœç›®æ ‡Appä¸ºsystemåº”ç”¨ï¼ˆUIDä¸ºROOT_UIDæˆ–SYSTEM_UIDï¼‰ //å¹¶ä¸”ç›®æ ‡Appä¸ä¸ºè®¾ç½®ï¼ˆåŒ…åä¸ä¸ºcom.android.settingsï¼‰ï¼Œåˆ™noReleaseNeededä¸ºtrue if (!noReleaseNeeded) &#123; //å¢åŠ å·²å­˜åœ¨çš„ContentProviderå¼•ç”¨çš„å¼•ç”¨è®¡æ•° incProviderRefLocked(prc, stable); try &#123; //é‡Šæ”¾ä¼ å…¥çš„å¼•ç”¨ï¼Œç§»é™¤ContentProviderConnectionç›¸å…³ä¿¡æ¯ï¼Œæ›´æ–°å¼•ç”¨è®¡æ•° ActivityManager.getService().removeContentProvider( holder.connection, stable); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125; else &#123; //åˆ›å»ºProviderClientRecordå¹¶å°†å…¶ä¿å­˜åˆ°mProviderMapæœ¬åœ°ç¼“å­˜ä¸­ ProviderClientRecord client = installProviderAuthoritiesLocked( provider, localProvider, holder); if (noReleaseNeeded) &#123; //åŒä¸Šï¼Œç›®æ ‡Appä¸ºsystemåº”ç”¨ï¼Œä¸éœ€è¦é‡Šæ”¾å¼•ç”¨ //æ–°å»ºä¸€ä¸ªProviderRefCountï¼Œä½†å¼•ç”¨è®¡æ•°åˆå§‹åŒ–ä¸ºä¸€ä¸ªè¾ƒå¤§çš„æ•°å€¼ //è¿™æ ·åç»­æ— è®ºè°ƒç”¨æ–¹è¿›ç¨‹çš„ContentProviderå¼•ç”¨è®¡æ•°å¦‚ä½•å˜åŠ¨éƒ½ä¸ä¼šå½±å“åˆ°AMS prc = new ProviderRefCount(holder, client, 1000, 1000); &#125; else &#123; //éœ€è¦é‡Šæ”¾å¼•ç”¨çš„æƒ…å†µä¸‹ //æ­£å¸¸çš„æ–°å»ºåˆå§‹åŒ–ä¸€ä¸ªProviderRefCount prc = stable ? new ProviderRefCount(holder, client, 1, 0) : new ProviderRefCount(holder, client, 0, 1); &#125; //ä¿å­˜è‡³ç¼“å­˜ mProviderRefCountMap.put(jBinder, prc); &#125; retHolder = prc.holder; &#125; &#125; return retHolder;&#125; å¯¹äºholder.providerä¸ä¸ºnullçš„æƒ…å†µï¼Œç›´æ¥è·å–è¿œç¨‹ContentProviderå¼•ç”¨ï¼Œç„¶åè¿›è¡Œå¤„ç†å°±å¯ä»¥äº†ã€‚è¿™é‡Œè·å–åˆ°çš„IContentProviderçš„å®é™…ç±»å‹æ˜¯ContentProviderProxyï¼Œç„¶åå¯¹å…¶è°ƒç”¨asBinderæ–¹æ³•ï¼Œè·å–åˆ°çš„æ˜¯BinderProxyå¯¹è±¡ï¼Œæ¥ç€ä»ç¼“å­˜ä¸­å°è¯•è·å–ProviderRefCountå¯¹è±¡ï¼Œå¦‚æœç¼“å­˜ä¸­å·²ç»æœ‰ç›¸åº”çš„å¼•ç”¨å¯¹è±¡äº†ï¼Œåˆ™åœ¨éœ€è¦é‡Šæ”¾å¼•ç”¨ï¼ˆ!noReleaseNeededï¼‰çš„æƒ…å†µä¸‹ä½¿ç”¨åŸæœ‰çš„å¼•ç”¨ï¼Œé‡Šæ”¾å‚æ•°ä¼ å…¥è¿›æ¥çš„ContentProviderå¼•ç”¨ è¿™é‡ŒnoReleaseNeededæ˜¯åœ¨ContentProviderRecordæ„é€ æ—¶èµ‹å€¼çš„ï¼Œä¸ºtrueçš„æ¡ä»¶æ˜¯ç›®æ ‡Appä¸ºsystemåº”ç”¨ï¼ˆUIDä¸ºROOT_UIDæˆ–SYSTEM_UIDï¼‰å¹¶ä¸”ç›®æ ‡Appä¸ä¸ºè®¾ç½®ï¼ˆåŒ…åä¸ä¸ºcom.android.settingsï¼‰ å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰æŸ¥æ‰¾åˆ°ç›¸åº”çš„ProviderRefCountå¯¹è±¡ï¼Œæ–°å»ºProviderClientRecordå’ŒProviderRefCountå¯¹è±¡ï¼Œå¹¶å°†ä»–ä»¬ä¿å­˜åˆ°ç¼“å­˜ä¸­ï¼Œè‡³äºä¸ºä»€ä¹ˆåœ¨noReleaseNeededçš„æƒ…å†µä¸‹ï¼Œæ–°å»ºçš„ProviderRefCountçš„å¼•ç”¨è®¡æ•°åˆå§‹å€¼ä¸º1000ï¼Œæˆ‘çŒœæµ‹æ˜¯å› ä¸ºnoReleaseNeededä»£è¡¨äº†ä¸éœ€è¦é‡Šæ”¾å¼•ç”¨ï¼Œæ‰€ä»¥è¿™é‡Œå¹²è„†è®¾ç½®ä¸€ä¸ªæ¯”è¾ƒå¤§çš„å€¼ï¼Œè¿™æ ·æ— è®ºè°ƒç”¨æ–¹è¿›ç¨‹çš„ContentProviderå¼•ç”¨è®¡æ•°æ€æ ·å˜åŠ¨ï¼Œéƒ½ä¸ä¼šå†è°ƒç”¨åˆ°AMSçš„æ–¹æ³•ä¸­å»å¤„ç†å¼•ç”¨çš„å˜åŒ–ï¼Œåœ¨éå¸¸æ—©æœŸçš„Androidç‰ˆæœ¬ä¸­ï¼ˆAndroid 4.0.1ï¼‰ï¼Œè¿™ä¸ªå€¼æ›¾è¢«è®¾ç½®ä¸º10000 è‡³æ­¤ï¼Œè¿œç¨‹ContentProviderçš„å®‰è£…ä¹Ÿç»“æŸäº† ActivityThread.installProviderAuthoritiesLockedæ¥ä¸‹æ¥æˆ‘ä»¬å†ç®€å•çš„çœ‹ä¸€ä¸‹ä¸¤ç§caseéƒ½ä¼šèµ°åˆ°çš„installProviderAuthoritiesLockedæ–¹æ³•å§ 12345678910111213141516171819private ProviderClientRecord installProviderAuthoritiesLocked(IContentProvider provider, ContentProvider localProvider, ContentProviderHolder holder) &#123; final String auths[] = holder.info.authority.split(\";\"); final int userId = UserHandle.getUserId(holder.info.applicationInfo.uid); ... final ProviderClientRecord pcr = new ProviderClientRecord( auths, provider, localProvider, holder); for (String auth : auths) &#123; final ProviderKey key = new ProviderKey(auth, userId); final ProviderClientRecord existing = mProviderMap.get(key); if (existing != null) &#123; Slog.w(TAG, \"Content provider \" + pcr.mHolder.info.name + \" already published as \" + auth); &#125; else &#123; mProviderMap.put(key, pcr); &#125; &#125; return pcr;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œæ–°å»ºäº†ä¸€ä¸ªProviderClientRecordå¹¶å°†å…¶æ·»åŠ åˆ°mProviderMapç¼“å­˜ä¸­ï¼Œè¿™é‡Œçš„æ“ä½œå¯¹åº”ç€æœ€å‰é¢çš„acquireExistingProvideræ–¹æ³•ï¼Œæœ‰äº†è¿™ä¸ªç¼“å­˜ï¼Œä»¥åå°±å¯ä»¥ç›´æ¥æ‹¿ï¼Œè€Œä¸ç”¨å†å¤æ‚çš„ç»è¿‡ä¸€ç³»åˆ—çš„AMSè·¨è¿›ç¨‹æ“ä½œäº† AMS.publishContentProvidersContentProviderå…¨éƒ¨å¯åŠ¨å®‰è£…å®Œåï¼Œä¾¿è¦è°ƒç”¨AMS.publishContentProviderså°†ä»–ä»¬å‘å¸ƒå‡ºå»ï¼Œä¾›å¤–éƒ¨ä½¿ç”¨äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final void publishContentProviders(IApplicationThread caller, List&lt;ContentProviderHolder&gt; providers) &#123; if (providers == null) &#123; return; &#125; synchronized (this) &#123; final ProcessRecord r = getRecordForAppLocked(caller); if (r == null) &#123; throw new SecurityException( \"Unable to find app for caller \" + caller + \" (pid=\" + Binder.getCallingPid() + \") when publishing content providers\"); &#125; final long origId = Binder.clearCallingIdentity(); final int N = providers.size(); for (int i = 0; i &lt; N; i++) &#123; ContentProviderHolder src = providers.get(i); if (src == null || src.info == null || src.provider == null) &#123; continue; &#125; //Appè¿›ç¨‹å¯åŠ¨æ—¶æˆ–AMS.getContentProviderä¸­å·²ç»å°†ç›¸åº”ContentProviderRecordæ·»åŠ åˆ°äº†pubProvidersä¸­ ContentProviderRecord dst = r.pubProviders.get(src.info.name); if (dst != null) &#123; //ä¿å­˜è‡³ç¼“å­˜ä¸­ ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name); mProviderMap.putProviderByClass(comp, dst); String names[] = dst.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; mProviderMap.putProviderByName(names[j], dst); &#125; //ContentProviderå·²ç»å¯åŠ¨å®Œæ¯•ï¼Œå°†å…¶ä»æ­£åœ¨å¯åŠ¨çš„ContentProvideråˆ—è¡¨ä¸­ç§»é™¤ int launchingCount = mLaunchingProviders.size(); int j; boolean wasInLaunchingProviders = false; for (j = 0; j &lt; launchingCount; j++) &#123; if (mLaunchingProviders.get(j) == dst) &#123; mLaunchingProviders.remove(j); wasInLaunchingProviders = true; j--; launchingCount--; &#125; &#125; //ç§»é™¤ContentProviderå¯åŠ¨è¶…æ—¶ç›‘å¬ if (wasInLaunchingProviders) &#123; mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r); &#125; // Make sure the package is associated with the process. // XXX We shouldn't need to do this, since we have added the package // when we generated the providers in generateApplicationProvidersLocked(). // But for some reason in some cases we get here with the package no longer // added... for now just patch it in to make things happy. r.addPackage(dst.info.applicationInfo.packageName, dst.info.applicationInfo.longVersionCode, mProcessStats); synchronized (dst) &#123; dst.provider = src.provider; dst.setProcess(r); //è®©å‡ºé”ï¼Œé€šçŸ¥å…¶ä»–waitçš„åœ°æ–¹ //å¯¹åº”ç€AMS.getContentProviderçš„ç¬¬å››éƒ¨åˆ†ï¼šç­‰å¾…ContentProviderå¯åŠ¨å®Œæˆ dst.notifyAll(); &#125; dst.mRestartCount = 0; updateOomAdjLocked(r, true, OomAdjuster.OOM_ADJ_REASON_GET_PROVIDER); maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority); &#125; &#125; Binder.restoreCallingIdentity(origId); &#125;&#125; éå†æ•´ä¸ªå¾…å‘å¸ƒçš„ContentProvideråˆ—è¡¨ï¼Œä»ProcessRecord.pubProvidersä¸­æŸ¥æ‰¾ç›¸å¯¹åº”çš„ContentProviderRecordï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­å·²ç»åˆ†æè¿‡äº†ï¼ŒAppè¿›ç¨‹å¯åŠ¨æ—¶æˆ–AMS.getContentProviderä¸­å·²ç»å°†ç›¸åº”ContentProviderRecordæ·»åŠ åˆ°äº†pubProvidersä¸­ï¼Œç„¶åå°±æ˜¯å°†å…¶ä¿å­˜åˆ°å„ä¸ªç¼“å­˜ä¸­ï¼Œç”±äºContentProviderå·²ç»å¯åŠ¨å®Œæ¯•ï¼Œæ‰€ä»¥éœ€è¦å°†å…¶ä»æ­£åœ¨å¯åŠ¨çš„ContentProvideråˆ—è¡¨ä¸­ç§»é™¤ï¼Œåœ¨ContentProvideræ­£å¸¸å¯åŠ¨çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å°†ContentProviderçš„å¯åŠ¨è¶…æ—¶ç›‘å¬ç§»é™¤ï¼Œæœ€åï¼Œè·å–ContentProviderRecordåŒæ­¥é”ï¼Œå°†å‡†å¤‡å¥½çš„ContentProviderèµ‹å€¼åˆ°ContentProviderRecordä¸­ï¼Œæ¥ç€è°ƒç”¨notifyAllæ–¹æ³•é€šçŸ¥å…¶ä»–è°ƒç”¨è¿‡waitçš„åœ°æ–¹ï¼Œå°†é”è®©å‡ºï¼Œè¿™é‡Œå¯¹åº”çš„å°±æ˜¯AMS.getContentProviderçš„ç¬¬å››éƒ¨åˆ†ï¼šç­‰å¾…ContentProviderå¯åŠ¨å®Œæˆ 123456789101112131415private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, int callingUid, String callingPackage, String callingTag, boolean stable, int userId) &#123; ... //è¿™é‡Œçš„cprå’Œåœ¨publishContentProvidersè·å¾—çš„dstæ˜¯ä¸€ä¸ªå¯¹è±¡ synchronized (cpr) &#123; while (cpr.provider == null) &#123; ... //é‡Šæ”¾é”ï¼Œç­‰å¾…ContentProviderå¯åŠ¨å®Œæˆ cpr.wait(wait); ... &#125; &#125; ...&#125; è¿™æ ·ï¼ŒContentProviderä¸€å‘å¸ƒï¼Œè¿™é‡Œå°±ä¼šæ”¶åˆ°é€šçŸ¥ï¼Œè§£é™¤waitçŠ¶æ€ï¼Œè·å¾—åˆ°ContentProviderï¼Œè¿”å›å‡ºå»ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰ä¸€åˆ‡éƒ½ä¸²èµ·æ¥äº†ï¼Ÿ ContentProviderå¼•ç”¨è®¡æ•°ContentProviderçš„è·å–ä¸å¯åŠ¨åˆ†æå®Œäº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬èŠèŠå®ƒçš„å¼•ç”¨è®¡æ•°ï¼Œä¸ºä¸‹ä¸€å°èŠ‚åˆ†æContentProvideræ­»äº¡æ€æ­»è°ƒç”¨æ–¹è¿›ç¨‹çš„è¿‡ç¨‹åšå‡†å¤‡ ActivityThreadå±‚çš„å¼•ç”¨è®¡æ•°æ˜¯å’ŒAMSå±‚çš„å¼•ç”¨è®¡æ•°åˆ†å¼€çš„ï¼ŒActivityThreadè®°å½•çš„æ˜¯ç›®æ ‡ContentProvideråœ¨æœ¬è¿›ç¨‹ä¸­æœ‰å¤šå°‘å¤„æ­£åœ¨ä½¿ç”¨ï¼Œè€ŒAMSè®°å½•çš„æ˜¯ç›®æ ‡ContentProvideræ­£åœ¨è¢«å¤šå°‘ä¸ªè¿›ç¨‹ä½¿ç”¨ ActivityThreadå±‚çš„å¼•ç”¨è®¡æ•°å¢åŠ å¼•ç”¨è®¡æ•°æˆ‘ä»¬å…ˆä»ActivityThreadå±‚å¢åŠ å¼•ç”¨è®¡æ•°å¼€å§‹è¯´èµ·ï¼Œåœ¨ActivityThreadè·å–ContentProvideræ—¶ï¼Œä¾¿ä¼šè°ƒç”¨incProviderRefLockedæ–¹æ³•æ¥å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå…·ä½“çš„æ—¶æœºä¸ºacquireExistingProvideræˆ–installProvideræ—¶ï¼Œä»£ç æˆ‘å°±ä¸é‡å¤æ”¾äº†ï¼Œå¤§å®¶çœ‹å‰é¢å‡ ä¸ªå°èŠ‚å°±è¡Œï¼ˆååŒï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private final void incProviderRefLocked(ProviderRefCount prc, boolean stable) &#123; if (stable) &#123; //å¢åŠ ActivityThreadçš„stableå¼•ç”¨è®¡æ•° prc.stableCount += 1; //æœ¬è¿›ç¨‹å¯¹ç›®æ ‡ContentProvideräº§ç”Ÿäº†stableå¼•ç”¨å…³ç³» if (prc.stableCount == 1) &#123; // We are acquiring a new stable reference on the provider. int unstableDelta; //æ­£åœ¨ç§»é™¤ContentProviderå¼•ç”¨ä¸­ï¼ˆé‡Šæ”¾ContentProvideråå‘ç°stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0ï¼‰ if (prc.removePending) &#123; // We have a pending remove operation, which is holding the // last unstable reference. At this point we are converting // that unstable reference to our new stable reference. //å½“ActivityThreadé‡Šæ”¾ä¸€ä¸ªstableçš„ContentProvideræ—¶ï¼Œå¦‚æœé‡Šæ”¾å®Œåï¼Œ //å‘ç°stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0ï¼Œåˆ™ä¼šæš‚æ—¶ä¿ç•™ä¸€ä¸ªunstableå¼•ç”¨ //æ‰€ä»¥è¿™é‡Œéœ€è¦ä¸º -1 ï¼Œå°†è¿™ä¸ªunstableå¼•ç”¨ç§»é™¤ unstableDelta = -1; // Cancel the removal of the provider. prc.removePending = false; // There is a race! It fails to remove the message, which // will be handled in completeRemoveProvider(). //å–æ¶ˆç§»é™¤ContentProviderå¼•ç”¨ mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; //å¯¹äºæ­£å¸¸æƒ…å†µï¼Œåªéœ€è¦å¢åŠ stableå¼•ç”¨è®¡æ•°ï¼Œä¸éœ€è¦åŠ¨unstableå¼•ç”¨è®¡æ•° unstableDelta = 0; &#125; try &#123; //AMSå±‚ä¿®æ”¹å¼•ç”¨è®¡æ•° ActivityManager.getService().refContentProvider( prc.holder.connection, 1, unstableDelta); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125; else &#123; //å¢åŠ ActivityThreadçš„unstableå¼•ç”¨è®¡æ•° prc.unstableCount += 1; //æœ¬è¿›ç¨‹å¯¹ç›®æ ‡ContentProvideräº§ç”Ÿäº†unstableå¼•ç”¨å…³ç³» if (prc.unstableCount == 1) &#123; // We are acquiring a new unstable reference on the provider. //æ­£åœ¨ç§»é™¤ContentProviderå¼•ç”¨ä¸­ï¼ˆé‡Šæ”¾ContentProvideråå‘ç°stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0ï¼‰ if (prc.removePending) &#123; // Oh look, we actually have a remove pending for the // provider, which is still holding the last unstable // reference. We just need to cancel that to take new // ownership of the reference. //å–æ¶ˆç§»é™¤ContentProviderå¼•ç”¨ prc.removePending = false; mH.removeMessages(H.REMOVE_PROVIDER, prc); &#125; else &#123; // First unstable ref, increment our count in the // activity manager. try &#123; //å¢åŠ AMSå±‚çš„unstableå¼•ç”¨è®¡æ•° ActivityManager.getService().refContentProvider( prc.holder.connection, 0, 1); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125; &#125;&#125; è¿™é‡Œçš„é€»è¾‘éœ€è¦é…åˆç€ContentProvideré‡Šæ”¾å¼•ç”¨é‚£é‡Œä¸€èµ·çœ‹æ‰å¥½ç†è§£ï¼Œæˆ‘å…ˆæå‰è§£é‡Šä¸€ä¸‹ é¦–å…ˆï¼ŒremovePendingè¿™ä¸ªå˜é‡è¡¨ç¤ºæ­¤ContentProvideræ­£åœ¨ç§»é™¤ä¸­ï¼Œå½“ActivityThreadå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œæ£€æŸ¥åˆ°stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0åè¢«èµ‹å€¼ä¸ºtrueï¼Œå¹¶ä¸”ä¼šå‘Handlerå‘é€ä¸€æ¡whatå€¼ä¸ºREMOVE_PROVIDERçš„å»¶æ—¶æ¶ˆæ¯ï¼Œåœ¨ä¸€å®šæ—¶é—´åä¾¿ä¼šè§¦å‘ContentProviderç§»é™¤æ“ä½œï¼Œæ¸…ç†æœ¬åœ°ç¼“å­˜ï¼Œå†å°†removePendingé‡æ–°ç½®ä¸ºfalseï¼Œæ‰€ä»¥å½“è¿™é‡ŒremovePendingä¸ºtrueåˆ™è¯´æ˜æ­¤ContentProviderè¿˜æ²¡å®Œå…¨è¢«ç§»é™¤ï¼Œæˆ‘ä»¬æŠŠè¿™ä¸ªæ¶ˆæ¯å–æ¶ˆæ‰ç»§ç»­ä½¿ç”¨è¿™ä¸ªContentProvider å¯¹äºstableå¼•ç”¨çš„æƒ…å†µä¸‹ï¼Œå½“ActivityThreadå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œæ£€æŸ¥åˆ°stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0åï¼Œä¼šæš‚æ—¶ä¿ç•™ä¸€ä¸ªunstableå¼•ç”¨ï¼Œç­‰åˆ°åé¢çœŸæ­£è§¦å‘åˆ°äº†ç§»é™¤ContentProviderçš„æ—¶å€™å†å°†è¿™ä¸ªunstableå¼•ç”¨ç§»é™¤ï¼Œæ‰€ä»¥åœ¨å¢åŠ å¼•ç”¨è®¡æ•°çš„æ—¶å€™éœ€è¦è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹è¦å°†AMSå±‚çš„unstableå¼•ç”¨è®¡æ•°å‡ä¸€ å¯¹äºå…¶ä»–çš„æƒ…å†µå°±æ˜¯æ­£å¸¸çš„å¢åŠ ActivityThreadå±‚å¼•ç”¨è®¡æ•°ï¼Œç„¶åè°ƒç”¨AMS.refContentProvideræ–¹æ³•æ“ä½œAMSå±‚çš„å¼•ç”¨è®¡æ•° å‡å°‘å¼•ç”¨è®¡æ•°ContentProviderä½¿ç”¨å®Œåä¼šè°ƒç”¨ActivityThread.releaseProvideræ–¹æ³•ï¼Œä»¥queryæ–¹æ³•ä¸ºä¾‹ï¼Œæœ€åä¼šè°ƒç”¨releaseUnstableProviderå’ŒreleaseProvideræ–¹æ³•ï¼Œæœ€ç»ˆéƒ½ä¼šèµ°åˆ°è¿™é‡Œæ¥ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public final boolean releaseProvider(IContentProvider provider, boolean stable) &#123; if (provider == null) &#123; return false; &#125; IBinder jBinder = provider.asBinder(); synchronized (mProviderMap) &#123; ProviderRefCount prc = mProviderRefCountMap.get(jBinder); if (prc == null) &#123; // The provider has no ref count, no release is needed. return false; &#125; boolean lastRef = false; if (stable) &#123; //å¼•ç”¨è®¡æ•°å·²ç»ä¸º0ï¼Œæ— æ³•å†å‡äº† if (prc.stableCount == 0) &#123; return false; &#125; //å‡å°‘ActivityThreadçš„stableå¼•ç”¨è®¡æ•° prc.stableCount -= 1; if (prc.stableCount == 0) &#123; // What we do at this point depends on whether there are // any unstable refs left: if there are, we just tell the // activity manager to decrement its stable count; if there // aren't, we need to enqueue this provider to be removed, // and convert to holding a single unstable ref while // doing so. lastRef = prc.unstableCount == 0; try &#123; //å¦‚æœæ˜¯æœ€åçš„å¼•ç”¨ï¼Œåˆ™æš‚æ—¶ä¿ç•™ä¸€ä¸ªunstableå¼•ç”¨ ActivityManager.getService().refContentProvider( prc.holder.connection, -1, lastRef ? 1 : 0); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125; else &#123; //å¼•ç”¨è®¡æ•°å·²ç»ä¸º0ï¼Œæ— æ³•å†å‡äº† if (prc.unstableCount == 0) &#123; return false; &#125; //å‡å°‘ActivityThreadçš„unstableå¼•ç”¨è®¡æ•° prc.unstableCount -= 1; if (prc.unstableCount == 0) &#123; // If this is the last reference, we need to enqueue // this provider to be removed instead of telling the // activity manager to remove it at this point. lastRef = prc.stableCount == 0; //å¦‚æœæ˜¯æœ€åçš„å¼•ç”¨ï¼Œåˆ™ä¸è¿›å…¥åˆ°è¿™é‡Œï¼Œæš‚æ—¶ä¿ç•™ä¸€ä¸ªunstableå¼•ç”¨ if (!lastRef) &#123; try &#123; //å‡å°‘AMSå¼•ç”¨è®¡æ•° ActivityManager.getService().refContentProvider( prc.holder.connection, 0, -1); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125; &#125; &#125; &#125; if (lastRef) &#123; if (!prc.removePending) &#123; // Schedule the actual remove asynchronously, since we don't know the context // this will be called in. //è¡¨é¢æ­¤ContentProvideræ­£åœ¨ç§»é™¤ä¸­ prc.removePending = true; //å‘é€å»¶æ—¶æ¶ˆæ¯ï¼Œç­‰å¾…ä¸€å®šæ—¶é—´åç§»é™¤ContentProvider Message msg = mH.obtainMessage(H.REMOVE_PROVIDER, prc); mH.sendMessageDelayed(msg, CONTENT_PROVIDER_RETAIN_TIME); &#125; else &#123; Slog.w(TAG, \"Duplicate remove pending of provider \" + prc.holder.info.name); &#125; &#125; return true; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨å‡å®Œå¼•ç”¨è®¡æ•°åï¼Œå¦‚æœå‘ç°æ˜¯æœ€åä¸€ä¸ªå¼•ç”¨ï¼Œå³stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0ï¼Œæ­¤æ—¶æ— è®ºæ˜¯stableè¿˜æ˜¯unstableéƒ½ä¼šè®©AMSæš‚æ—¶ä¿ç•™ä¸€ä¸ªunstableå¼•ç”¨ï¼Œç„¶åå‘é€ä¸€æ¡whatå€¼ä¸ºREMOVE_PROVIDERçš„å»¶æ—¶æ¶ˆæ¯ï¼Œç­‰å¾…ä¸€å®šæ—¶é—´åç§»é™¤ContentProviderï¼Œå½“æ—¶é—´åˆ°äº†è§¦å‘è¿™æ¡æ¶ˆæ¯æ—¶ï¼Œä¼šè°ƒç”¨åˆ°ActivityThread.completeRemoveProvideræ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839final void completeRemoveProvider(ProviderRefCount prc) &#123; synchronized (mProviderMap) &#123; if (!prc.removePending) &#123; // There was a race! Some other client managed to acquire // the provider before the removal was completed. // Abort the removal. We will do it later. return; &#125; // More complicated race!! Some client managed to acquire the // provider and release it before the removal was completed. // Continue the removal, and abort the next remove message. prc.removePending = false; //ç§»é™¤ç¼“å­˜ final IBinder jBinder = prc.holder.provider.asBinder(); ProviderRefCount existingPrc = mProviderRefCountMap.get(jBinder); if (existingPrc == prc) &#123; mProviderRefCountMap.remove(jBinder); &#125; //ç§»é™¤ç¼“å­˜ for (int i=mProviderMap.size()-1; i&gt;=0; i--) &#123; ProviderClientRecord pr = mProviderMap.valueAt(i); IBinder myBinder = pr.mProvider.asBinder(); if (myBinder == jBinder) &#123; mProviderMap.removeAt(i); &#125; &#125; &#125; try &#123; //å¤„ç†AMSå±‚å¼•ç”¨è®¡æ•° ActivityManager.getService().removeContentProvider( prc.holder.connection, false); &#125; catch (RemoteException e) &#123; //do nothing content provider object is dead any way &#125;&#125; è¿™ä¸ªæ–¹æ³•å°†è¿›ç¨‹å†…æ‰€æŒæœ‰çš„ContentProviderç›¸å…³ç¼“å­˜æ¸…é™¤ï¼Œç„¶åè°ƒç”¨AMS.removeContentProvideræ–¹æ³•é€šçŸ¥AMSç§»é™¤ContentProviderï¼Œå¤„ç†ç›¸åº”çš„å¼•ç”¨è®¡æ•°ã€‚è¿™é‡Œæˆ‘ä»¬å‘ç°ï¼Œè°ƒç”¨AMS.removeContentProvideræ–¹æ³•ä¼ å…¥çš„æœ€åä¸€ä¸ªå‚æ•°stableä¸ºfalseï¼Œå› ä¸ºæˆ‘ä»¬ä¹‹å‰åœ¨stableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0çš„æƒ…å†µä¸‹ï¼Œä¿ç•™äº†ä¸€ä¸ªunstableå¼•ç”¨ï¼Œæ‰€ä»¥è¿™æ—¶ç§»é™¤çš„ContentProviderå¼•ç”¨ä¹Ÿæ˜¯unstableå¼•ç”¨ AMSå±‚çš„å¼•ç”¨è®¡æ•°æ¥ç€æˆ‘ä»¬æ¥çœ‹AMSå±‚çš„å¼•ç”¨è®¡æ•° AMS.refContentProvideræˆ‘ä»¬å°±å…ˆä»æˆ‘ä»¬åˆšåˆšåˆ†æçš„ActivityThreadå±‚çš„å¼•ç”¨è®¡æ•°ä¿®æ”¹åç»­ï¼šrefContentProvider çœ‹èµ· 1234567891011121314151617181920212223242526272829303132public boolean refContentProvider(IBinder connection, int stable, int unstable) &#123; ContentProviderConnection conn; ... conn = (ContentProviderConnection)connection; ... synchronized (this) &#123; if (stable &gt; 0) &#123; conn.numStableIncs += stable; &#125; stable = conn.stableCount + stable; if (stable &lt; 0) &#123; throw new IllegalStateException(\"stableCount &lt; 0: \" + stable); &#125; if (unstable &gt; 0) &#123; conn.numUnstableIncs += unstable; &#125; unstable = conn.unstableCount + unstable; if (unstable &lt; 0) &#123; throw new IllegalStateException(\"unstableCount &lt; 0: \" + unstable); &#125; if ((stable+unstable) &lt;= 0) &#123; throw new IllegalStateException(\"ref counts can't go to zero here: stable=\" + stable + \" unstable=\" + unstable); &#125; conn.stableCount = stable; conn.unstableCount = unstable; return !conn.dead; &#125;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œåº”è¯¥ä¸éœ€è¦å†å¤šåšåˆ†æäº†å§ï¼Ÿå°±æ˜¯ç®€å•çš„ä¿®æ”¹ContentProviderConnectionçš„å¼•ç”¨è®¡æ•°å€¼ AMS.incProviderCountLockedæ¥ä¸‹æ¥æˆ‘ä»¬çœ‹AMSå±‚å¼•ç”¨è®¡æ•°çš„å¢åŠ ï¼ŒAMS.incProviderCountLockedè¿™ä¸ªæ–¹æ³•çš„è§¦å‘æ—¶æœºæ˜¯åœ¨AMS.getContentProviderImplæ–¹æ³•ä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940ContentProviderConnection incProviderCountLocked(ProcessRecord r, final ContentProviderRecord cpr, IBinder externalProcessToken, int callingUid, String callingPackage, String callingTag, boolean stable) &#123; if (r != null) &#123; for (int i=0; i&lt;r.conProviders.size(); i++) &#123; ContentProviderConnection conn = r.conProviders.get(i); //å¦‚æœè¿æ¥å·²å­˜åœ¨ï¼Œåœ¨å…¶åŸºç¡€ä¸Šå¢åŠ å¼•ç”¨è®¡æ•° if (conn.provider == cpr) &#123; if (stable) &#123; conn.stableCount++; conn.numStableIncs++; &#125; else &#123; conn.unstableCount++; conn.numUnstableIncs++; &#125; return conn; &#125; &#125; //æ–°å»ºContentProviderConnectionè¿æ¥ ContentProviderConnection conn = new ContentProviderConnection(cpr, r, callingPackage); //å»ºç«‹å…³è” conn.startAssociationIfNeeded(); if (stable) &#123; conn.stableCount = 1; conn.numStableIncs = 1; &#125; else &#123; conn.unstableCount = 1; conn.numUnstableIncs = 1; &#125; //æ·»åŠ è¿æ¥ cpr.connections.add(conn); r.conProviders.add(conn); //å»ºç«‹å…³è” startAssociationLocked(r.uid, r.processName, r.getCurProcState(), cpr.uid, cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName); return conn; &#125; cpr.addExternalProcessHandleLocked(externalProcessToken, callingUid, callingTag); return null;&#125; å¦‚æœè°ƒç”¨æ–¹è¿›ç¨‹å·²å­˜åœ¨å¯¹åº”ContentProviderConnectionè¿æ¥ï¼Œåˆ™åœ¨å…¶åŸºç¡€ä¸Šå¢åŠ å¼•ç”¨è®¡æ•°ï¼Œå¦åˆ™æ–°å»ºè¿æ¥ï¼Œç„¶ååˆå§‹åŒ–å¼•ç”¨è®¡æ•°å€¼ AMS.decProviderCountLockedç„¶åæ˜¯å‡å°‘å¼•ç”¨è®¡æ•°ï¼Œä¹‹å‰åœ¨ActivityThreadå‡å¼•ç”¨åˆ°0åï¼Œä¼šå»¶æ—¶è°ƒç”¨ActivityThread.completeRemoveProvideræ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¼šè°ƒç”¨åˆ°AMS.removeContentProvideræ–¹æ³• 12345678910111213141516public void removeContentProvider(IBinder connection, boolean stable) &#123; long ident = Binder.clearCallingIdentity(); try &#123; synchronized (this) &#123; ContentProviderConnection conn = (ContentProviderConnection)connection; ... //å‡å°‘å¼•ç”¨è®¡æ•° if (decProviderCountLocked(conn, null, null, stable)) &#123; //æ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_REMOVE_PROVIDER); &#125; &#125; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125;&#125; åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¾¿ä¼šè°ƒç”¨AMS.decProviderCountLockedå‡å°‘å¼•ç”¨è®¡æ•°ï¼Œç„¶åæ›´æ–°è¿›ç¨‹ä¼˜å…ˆçº§ 12345678910111213141516171819202122232425262728293031323334boolean decProviderCountLocked(ContentProviderConnection conn, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) &#123; if (conn != null) &#123; cpr = conn.provider; //å‡å°‘å¼•ç”¨è®¡æ•°å€¼ if (stable) &#123; conn.stableCount--; &#125; else &#123; conn.unstableCount--; &#125; if (conn.stableCount == 0 &amp;&amp; conn.unstableCount == 0) &#123; //åœæ­¢å…³è” conn.stopAssociation(); //ç§»é™¤è¿æ¥ cpr.connections.remove(conn); conn.client.conProviders.remove(conn); if (conn.client.setProcState &lt; PROCESS_STATE_LAST_ACTIVITY) &#123; // The client is more important than last activity -- note the time this // is happening, so we keep the old provider process around a bit as last // activity to avoid thrashing it. if (cpr.proc != null) &#123; cpr.proc.lastProviderTime = SystemClock.uptimeMillis(); &#125; &#125; //åœæ­¢å…³è” stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName); return true; &#125; return false; &#125; cpr.removeExternalProcessHandleLocked(externalProcessToken); return false;&#125; å‡å°‘å¼•ç”¨è®¡æ•°å€¼ï¼Œå¦‚æœstableå’Œunstableå¼•ç”¨è®¡æ•°å‡ä¸º0ï¼Œåˆ™å°†è¿™ä¸ªè¿æ¥ç§»é™¤ ContentProvideræ­»äº¡æ€æ­»è°ƒç”¨æ–¹è¿›ç¨‹çš„è¿‡ç¨‹æˆ‘ä»¬å‰é¢æåˆ°è¿‡ï¼ŒContentProvideræ‰€åœ¨è¿›ç¨‹æ­»äº¡ä¼šå°†ä¸å…¶æ‰€æœ‰æœ‰stableå…³è”çš„è°ƒç”¨æ–¹è¿›ç¨‹æ€æ­»ï¼Œè¿™æ˜¯æ€ä¹ˆåšåˆ°çš„å‘¢ï¼Ÿåœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»è¿‡è¿›ç¨‹å¯åŠ¨æ—¶ï¼Œåœ¨è°ƒç”¨AMS.attachApplicationLockedæ—¶ä¼šæ³¨å†Œä¸€ä¸ªAppè¿›ç¨‹æ­»äº¡å›è°ƒï¼Œæˆ‘ä»¬å°±ä»è¿›ç¨‹æ­»äº¡ï¼Œè§¦å‘æ­»äº¡å›è°ƒå¼€å§‹åˆ†æ 12345678910private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... //æ³¨å†ŒAppè¿›ç¨‹æ­»äº¡å›è°ƒ AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; ...&#125; æ³¨å†Œäº†æ­»äº¡å›è°ƒåï¼Œå¦‚æœå¯¹åº”binderè¿›ç¨‹æ­»äº¡ï¼Œä¾¿ä¼šå›è°ƒIBinder.DeathRecipient.binderDiedæ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹AppDeathRecipientå¯¹è¿™ä¸ªæ–¹æ³•çš„å®ç° 12345678910111213141516171819private final class AppDeathRecipient implements IBinder.DeathRecipient &#123; final ProcessRecord mApp; final int mPid; final IApplicationThread mAppThread; AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) &#123; mApp = app; mPid = pid; mAppThread = thread; &#125; @Override public void binderDied() &#123; synchronized(ActivityManagerService.this) &#123; appDiedLocked(mApp, mPid, mAppThread, true, null); &#125; &#125;&#125; ç›´æ¥è½¬æ‰‹è°ƒç”¨AMS.appDiedLockedæ–¹æ³•ï¼Œç„¶åç»è¿‡handleAppDiedLockedè°ƒç”¨åˆ°cleanUpApplicationRecordLockedæ–¹æ³•ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) &#123; ... boolean restart = false; // Remove published content providers. //æ¸…é™¤å·²å‘å¸ƒçš„ContentProvider for (int i = app.pubProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderRecord cpr = app.pubProviders.valueAt(i); if (cpr.proc != app) &#123; // If the hosting process record isn't really us, bail out continue; &#125; final boolean alwaysRemove = app.bad || !allowRestart; final boolean inLaunching = removeDyingProviderLocked(app, cpr, alwaysRemove); if (!alwaysRemove &amp;&amp; inLaunching &amp;&amp; cpr.hasConnectionOrHandle()) &#123; // We left the provider in the launching list, need to // restart it. restart = true; &#125; cpr.provider = null; cpr.setProcess(null); &#125; app.pubProviders.clear(); // Take care of any launching providers waiting for this process. //æ¸…é™¤æ­£åœ¨å¯åŠ¨ä¸­çš„ContentProvider if (cleanupAppInLaunchingProvidersLocked(app, false)) &#123; mProcessList.noteProcessDiedLocked(app); restart = true; &#125; // Unregister from connected content providers. //æ¸…é™¤å·²è¿æ¥çš„ContentProvider if (!app.conProviders.isEmpty()) &#123; for (int i = app.conProviders.size() - 1; i &gt;= 0; i--) &#123; ContentProviderConnection conn = app.conProviders.get(i); conn.provider.connections.remove(conn); stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.appInfo.longVersionCode, conn.provider.name, conn.provider.info.processName); &#125; app.conProviders.clear(); &#125; ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªæ–¹æ³•ä¸­éå†äº†ProcessRecord.pubProvidersï¼Œé€ä¸ªå¯¹å‘å¸ƒçš„ContentProviderè°ƒç”¨removeDyingProviderLockedæ–¹æ³•æ‰§è¡Œç§»é™¤æ“ä½œ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) &#123; boolean inLaunching = mLaunchingProviders.contains(cpr); if (inLaunching &amp;&amp; !always &amp;&amp; ++cpr.mRestartCount &gt; ContentProviderRecord.MAX_RETRY_COUNT) &#123; // It's being launched but we've reached maximum attempts, force the removal always = true; &#125; if (!inLaunching || always) &#123; synchronized (cpr) &#123; cpr.launchingApp = null; cpr.notifyAll(); &#125; final int userId = UserHandle.getUserId(cpr.uid); // Don't remove from provider map if it doesn't match // could be a new content provider is starting //ç§»é™¤ç¼“å­˜ if (mProviderMap.getProviderByClass(cpr.name, userId) == cpr) &#123; mProviderMap.removeProviderByClass(cpr.name, userId); &#125; String names[] = cpr.info.authority.split(\";\"); for (int j = 0; j &lt; names.length; j++) &#123; // Don't remove from provider map if it doesn't match // could be a new content provider is starting //ç§»é™¤ç¼“å­˜ if (mProviderMap.getProviderByName(names[j], userId) == cpr) &#123; mProviderMap.removeProviderByName(names[j], userId); &#125; &#125; &#125; for (int i = cpr.connections.size() - 1; i &gt;= 0; i--) &#123; ContentProviderConnection conn = cpr.connections.get(i); if (conn.waiting) &#123; // If this connection is waiting for the provider, then we don't // need to mess with its process unless we are always removing // or for some reason the provider is not currently launching. if (inLaunching &amp;&amp; !always) &#123; continue; &#125; &#125; ProcessRecord capp = conn.client; conn.dead = true; if (conn.stableCount &gt; 0) &#123; if (!capp.isPersistent() &amp;&amp; capp.thread != null &amp;&amp; capp.pid != 0 &amp;&amp; capp.pid != MY_PID) &#123; //å½“è°ƒç”¨æ–¹ä¸è¢«æ€æ­»çš„ç›®æ ‡ContentProviderè¿›ç¨‹é—´æœ‰stableè¿æ¥ //å¹¶ä¸”è°ƒç”¨æ–¹Appè¿›ç¨‹épersistentè¿›ç¨‹å¹¶ä¸”ésystem_serverè¿›ç¨‹ä¸­çš„æƒ…å†µä¸‹ //æ€æ­»è°ƒç”¨æ–¹è¿›ç¨‹ capp.kill(\"depends on provider \" + cpr.name.flattenToShortString() + \" in dying proc \" + (proc != null ? proc.processName : \"??\") + \" (adj \" + (proc != null ? proc.setAdj : \"??\") + \")\", ApplicationExitInfo.REASON_DEPENDENCY_DIED, ApplicationExitInfo.SUBREASON_UNKNOWN, true); &#125; &#125; else if (capp.thread != null &amp;&amp; conn.provider.provider != null) &#123; try &#123; //é€šçŸ¥è°ƒç”¨æ–¹ç§»é™¤ContentProvider capp.thread.unstableProviderDied(conn.provider.provider.asBinder()); &#125; catch (RemoteException e) &#123; &#125; // In the protocol here, we don't expect the client to correctly // clean up this connection, we'll just remove it. //ç§»é™¤è¿æ¥ cpr.connections.remove(i); if (conn.client.conProviders.remove(conn)) &#123; stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.appInfo.longVersionCode, cpr.name, cpr.info.processName); &#125; &#125; &#125; if (inLaunching &amp;&amp; always) &#123; mLaunchingProviders.remove(cpr); cpr.mRestartCount = 0; inLaunching = false; &#125; return inLaunching;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­éå†äº†ContentProviderä¸‹çš„æ‰€æœ‰è¿æ¥ï¼Œå½“å‘ç°æœ‰å…¶ä»–è¿›ç¨‹ä¸è‡ªå·±å»ºç«‹äº†stableè¿æ¥ï¼ˆconn.stableCount &gt; 0ï¼‰ï¼Œä¸”è°ƒç”¨æ–¹è¿›ç¨‹ä¸æ˜¯persistentè¿›ç¨‹ï¼ˆå¸¸é©»è¿›ç¨‹ï¼Œåªæœ‰æ‹¥æœ‰ç³»ç»Ÿç­¾åçš„Appè®¾ç½®è¿™ä¸ªå±æ€§æ‰ç”Ÿæ•ˆï¼‰ï¼Œä¹Ÿä¸æ˜¯è¿è¡Œåœ¨system_serverè¿›ç¨‹ï¼Œè°ƒç”¨ProcessRecord.killæ–¹æ³•ç›´æ¥æ€æ­»è¿›ç¨‹ï¼Œå¯¹äºæ²¡æœ‰å»ºç«‹stableè¿æ¥çš„è°ƒç”¨æ–¹è¿›ç¨‹ï¼Œè°ƒç”¨IApplicationThread.unstableProviderDiedæ–¹æ³•é€šçŸ¥è°ƒç”¨æ–¹è¿›ç¨‹ç§»é™¤ç›¸åº”çš„ContentProvider æ‰€ä»¥ï¼Œä½¿ç”¨ContentProvideræ˜¯æœ‰ä¸€å®šé£é™©çš„ï¼Œå¤§å®¶è¦æ³¨æ„è§„é¿ æ€»ç»“åˆ°è¿™é‡Œï¼Œæ•´ä¸ªFrameworkå±‚å…³äºContentProviderçš„å†…å®¹åº”è¯¥éƒ½åˆ†æå®Œäº†ï¼Œå¸Œæœ›å¤§å®¶çœ‹å®Œåèƒ½è·å¾—ä¸€äº›æ”¶è·ï¼Œæ¥ä¸‹æ¥çš„æ–‡ç« åº”è¯¥ä¼šå»åˆ†æServiceç›¸å…³æºç ï¼Œæ•¬è¯·æœŸå¾…~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ContentProvider","slug":"Android/ContentProvider","permalink":"http://yoursite.com/categories/Android/ContentProvider/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://yoursite.com/tags/ContentProvider/"}]},{"title":"æœ‰æ‰‹å°±è¡Œï¼Sovits AIäººå£°æ¨¡å‹è®­ç»ƒ","slug":"AI/AIäººå£°/æœ‰æ‰‹å°±è¡Œï¼Sovits AIäººå£°æ¨¡å‹è®­ç»ƒ","date":"2023-06-06T07:30:34.000Z","updated":"2023-06-19T14:06:38.286Z","comments":true,"path":"2023/06/06/AI/AIäººå£°/æœ‰æ‰‹å°±è¡Œï¼Sovits AIäººå£°æ¨¡å‹è®­ç»ƒ/","link":"","permalink":"http://yoursite.com/2023/06/06/AI/AI%E4%BA%BA%E5%A3%B0/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/","excerpt":"","text":"ç®€ä»‹éšç€AIå­™ç‡•å§¿çš„çˆ†ç«å‡ºåœˆï¼Œå„å¤§è§†é¢‘å¹³å°çš„AIäººå£°æŠ•ç¨¿é‡æ¿€å¢ï¼ŒBç«™é¦–é¡µé¢‘é¢‘ç»™æˆ‘æ¨é€ç›¸å…³è§†é¢‘ï¼Œæ­£å¥½æˆ‘å¯¹AIGCæ–¹é¢ä¹ŸæŒºæ„Ÿå…´è¶£ï¼Œå¿ƒåŠ¨ä¸å¦‚è¡ŒåŠ¨ï¼Œäºæ˜¯æˆ‘ç”¨è‡ªå·±çš„å£°éŸ³è®­ç»ƒäº†ä¸€ä¸ªæ¨¡å‹ï¼Œå‘ç°æ•´ä¸ªè¿‡ç¨‹å¼‚å¸¸çš„ç®€å•ï¼Œå¹¶ä¸”æœ€ç»ˆå‡ºæ¥çš„æ•ˆæœä¹Ÿä¸é”™ï¼ŒçœŸçš„æ˜¯æœ‰æ‰‹å°±è¡Œï¼Œæ‰€ä»¥è¿™æ¬¡å°†æˆ‘è‡ªå·±è®­ç»ƒæ¨ç†çš„è¿‡ç¨‹ç»éªŒåˆ†äº«ç»™å¤§å®¶ Sovitsé¦–å…ˆä»‹ç»ä¸€ä¸‹ä»Šå¤©è¦è®²çš„Sovitsï¼ŒSo-vits-svcï¼ˆä¹Ÿç§°Sovitsï¼‰æ˜¯ç”±æ˜¯ä¸­å›½æ°‘é—´æ­Œå£°åˆæˆçˆ±å¥½è€…RcellåŸºäºVITSã€soft-vcã€VISinger2ç­‰ä¸€ç³»åˆ—é¡¹ç›®å¼€å‘çš„ä¸€æ¬¾å¼€æºå…è´¹AIè¯­éŸ³è½¬æ¢è½¯ä»¶ï¼Œé€šè¿‡SoftVCå†…å®¹ç¼–ç å™¨æå–æºéŸ³é¢‘è¯­éŸ³ç‰¹å¾ï¼Œä¸F0åŒæ—¶è¾“å…¥VITSæ›¿æ¢åŸæœ¬çš„æ–‡æœ¬è¾“å…¥è¾¾åˆ°æ­Œå£°è½¬æ¢çš„æ•ˆæœã€‚ ç”±äºæŸäº›åŸå› ï¼ŒåŸä½œè€…Rcellåˆ é™¤äº†åŸä»£ç ä»“åº“ï¼Œç°ç”±svc-develop-teamæ¥æ‰‹è¿›è¡Œåç»­ç»´æŠ¤ï¼Œç°ä»“åº“åœ°å€ï¼šhttps://github.com/svc-develop-team/so-vits-svc é…ç½®è¦æ±‚ ä¸€å¼ æ”¯æŒ CUDA çš„ï¼Œæ‹¥æœ‰è‡³å°‘ 6G ä»¥ä¸Šæ˜¾å­˜çš„ NVIDIA æ˜¾å¡ æ¨èä½¿ç”¨Windowsç³»ç»Ÿï¼Œæ•™ç¨‹åç»­çš„ç´ æå¤„ç†ã€è®­ç»ƒã€æ¨ç†å‡åœ¨Windowså¹³å°ä¸Šå®Œæˆï¼ŒåŒæ—¶ä½¿ç”¨æ•´åˆåŒ…GUIä¹Ÿå¯ä»¥å¸®åŠ©æ–°æ‰‹å°†æ³¨æ„åŠ›é›†ä¸­åœ¨è®­ç»ƒ/æ¨ç†æœ¬èº«ä¸Šï¼Œé¿å…äº†ç¹æ‚çš„ç¯å¢ƒé…ç½®ç­‰å·¥ä½œ ç¯å¢ƒé…ç½®æœ¬æ¬¡çš„ç¯å¢ƒä½¿ç”¨çš„æ˜¯ bilibili@ç¾½æ¯›å¸ƒå›£ å¤§ä½¬æä¾›çš„æ•´åˆåŒ…ï¼šhttps://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r ï¼Œåœ¨è¿™é‡Œèƒ½æ‰¾åˆ°ä¸‹è½½åœ°å€å’Œä¸€äº›è¯´æ˜ ä¸‹è½½å®Œåï¼Œä½ ä¼šå¾—åˆ°ä¸€ä¸ªSovitsçš„å‹ç¼©åŒ…å’Œä¸€äº›å·¥å…·è½¯ä»¶ï¼Œå°†å…¶ä¸­çš„so-vits-svcè§£å‹ç¼©åï¼Œæ‰“å¼€é‡Œé¢çš„å¯åŠ¨webui.batæ–‡ä»¶ï¼Œå®ƒä¼šè‡ªåŠ¨å‡†å¤‡ç¯å¢ƒï¼Œç„¶åå¼¹å‡ºä¸€ä¸ªç½‘é¡µ åœ¨ç½‘é¡µä¸­å°†Tabé¡µåˆ‡æ¢è‡³è®­ç»ƒé¡µï¼Œå¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„æ˜¾å¡ä¿¡æ¯ ç¡®è®¤æ— è¯¯åæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹è®­ç»ƒäº† å‡†å¤‡æ•°æ®é›†æ•°æ®é›†çš„è´¨é‡åŠå¤šå°‘å†³å®šäº†è®­ç»ƒæ¨¡å‹è´¨é‡çš„ä¸Šä¸‹é™ï¼Œè´¨é‡å·®çš„æ•°æ®é›†æ— è®ºä½ è®­ç»ƒå¤šä¹…ï¼Œè®­ç»ƒäº†å¤šå°‘ä¸‡ä¸ªstepï¼Œéƒ½ä¸å¯èƒ½è¾¾åˆ°ä¸€ä¸ªç†æƒ³çš„æ•ˆæœ å‡†å¤‡å¹²å£°Sovitsçš„è®­ç»ƒæˆ‘ä»¬éœ€è¦æ‰¾ä¸€äº›æƒ³è®­ç»ƒçš„å£°çº¿æ‰€å¯¹åº”çš„å¹²å£°ç´ æï¼Œä¸å¯æ··æ‚å¤šç§å£°çº¿ï¼Œæ—¶é•¿æœ€å¥½åœ¨2ä¸ªå°æ—¶ä»¥ä¸Šï¼Œæœ€ä½ä¸è¦å°‘äº30åˆ†é’Ÿï¼Œå¦åˆ™æ— æ³•ä¿è¯è®­ç»ƒå‡ºæ¥çš„æ¨¡å‹çš„è´¨é‡ï¼Œå¯ä»¥æ˜¯è¯´è¯ã€è¯»ä¹¦æˆ–å”±æ­Œçš„å£°éŸ³ï¼ˆæœ‰çš„äººè¯´åŠ å…¥ä¸€äº›å“­é—¹ã€å¤§ç¬‘ç­‰å„ç§å„æ ·çš„å£°éŸ³æœ‰å¥‡æ•ˆï¼Œæˆ‘æ²¡å°è¯•è¿‡ï¼Œå¤§å®¶å¯ä»¥è¯•è¯•çœ‹ï¼‰ï¼Œå¦‚æœæƒ³è®©ä½ çš„æ¨¡å‹å”±æ­Œçš„è¯ï¼Œå”±æ­Œçš„ç´ æéœ€è¦è¦†ç›–ä½ä¸­é«˜éŸ³å¤šä¸ªé¢‘ç‡ å¹²å£°ç´ æä¸­ä¸èƒ½æœ‰ä¼´å¥ã€æ··å“ã€å’Œå£°ï¼ˆé¿å…è½¬æ¢åçš„å£°éŸ³è‡ªå¸¦BGMï¼‰ï¼Œä¸è¦æœ‰æ¢æ°”å£°ã€é¢¤éŸ³ã€è½¬éŸ³ç­‰ï¼Œå°½é‡å°†èƒŒæ™¯å™ªéŸ³å»é™¤å¹²å‡€ é™å™ªå¦‚æœä½ æœ¬æ¥çš„ç´ æå°±æ˜¯ä¸å¸¦ä¼´å¥æ··å“çš„å¹²å£°æ–‡ä»¶ï¼Œä½†æ˜¯æœ‰ä¸€äº›å˜ˆæ‚çš„èƒŒæ™¯å™ªéŸ³ï¼Œå¯ä»¥ä½¿ç”¨Adobe Auditionï¼ˆä»¥ä¸‹ç®€ç§°AUï¼‰è¿›è¡Œé™å™ªå¤„ç† æ•™ç¨‹ï¼šhttps://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html å»ä¼´å¥æ··å“å¦‚æœä½ çš„ç´ ææ˜¯ä¹‹å‰å½•å¥½çš„æ­Œæ›²ï¼Œé‚£ä¹ˆéœ€è¦å¯¹å®ƒè¿›è¡Œå»ä¼´å¥å»æ··å“å¤„ç†ï¼Œè¿™é‡Œæ¨èä½¿ç”¨ Ultimate Vocal Remover v5ï¼ˆç®€ç§°UVR5ï¼‰ ä¸‹è½½å®ŒUVR5ï¼Œåœ¨å¤„ç†éŸ³é¢‘å‰å»ºè®®å…ˆå»Advanced VR Optionsä¸­å°†Post-Processé€‰é¡¹æ‰“å¼€ï¼Œè¿™æ ·å»æ··å“çš„æ•ˆæœå¯èƒ½æ›´å¥½ï¼ˆç„å­¦ï¼‰ æ¥ç€å¼€å§‹å»ä¼´å¥ï¼Œæ¨èé‡‡ç”¨ä»¥ä¸‹é…ç½®ï¼š Process Method: Demucs Stems: Vocals Demucs Model: v3 | UVR_Model_1 æ³¨ï¼šæ‰¾ä¸åˆ°å¯¹åº”æ¨¡å‹çš„å¯ä»¥åœ¨ä¸‹æ‹‰æ¡†ä¸­é€‰æ‹©Downloadåœ¨è½¯ä»¶å†…ä¸‹è½½ç›¸åº”æ¨¡å‹ å‹¾é€‰GPU Conversion ç„¶åå¯¹å¤„ç†å®Œåçš„äººå£°æ–‡ä»¶å†åšä¸€æ¬¡å»æ··å“å¤„ç†ï¼Œæ¨èé‡‡ç”¨ä»¥ä¸‹é…ç½®ï¼š Process Method: VR Architecture Window Size: 320 Aggression Setting: 10 VR Model: 5_HP-Karaoke_UVR å‹¾é€‰GPU Conversion å‹¾é€‰Voacls Only è¿™æ ·ç®€å•çš„å‡ æ­¥ï¼Œæˆ‘ä»¬å°±å°†å¹²å£°ä»æ­Œæ›²æ–‡ä»¶ä¸­æå–å‡ºæ¥äº†ï¼Œå¦‚æœä½ è§‰å¾—æå–å‡ºæ¥çš„æ•ˆæœå·®å¼ºäººæ„ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ RipX DeepAudio åšä¸€äº›ç²¾ä¿® å°†æ–‡ä»¶å¯¼å…¥RipXä¸­ï¼Œä¼šäº§ç”Ÿå¦‚ä¸‹å›¾ä¸€æ ·çš„ä¸€æ®µæ›²çº¿ ç‚¹å‡»å…¶ä¸­çš„æŸæ®µé»„è‰²æ›²çº¿å¯ä»¥æ’­æ”¾è¿™æ®µéŸ³é¢‘ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€æ®µæ®µå¬è¿‡å»ï¼Œé‡åˆ°æ‚éŸ³éƒ¨åˆ†å¯ä»¥å°†å…¶æ‰‹åŠ¨åˆ é™¤ åŒ¹é…å“åº¦å¦‚æœä½ çš„å¹²å£°ç´ æçš„æ¥æºä¸åŒï¼Œå¾ˆå¯èƒ½ä¼šæœ‰ç´ æå“åº¦å¤§å°ä¸ä¸€çš„æƒ…å†µï¼Œè¿™ç§æƒ…å†µä¸‹éœ€è¦ä½¿ç”¨AUå¯¹æ‰€æœ‰éŸ³é¢‘å»åšåŒ¹é…å“åº¦ï¼Œä½¿æ‰€æœ‰ç´ æçš„åˆ†è´å€¼åœ¨ä¸€ä¸ªç»Ÿä¸€çš„èŒƒå›´å†… æ•™ç¨‹ï¼šhttps://helpx.adobe.com/cn/audition/using/match-loudness.html å‹é™å¹²å£°çš„å“åº¦ä¸å®œè¶…è¿‡-6dbï¼Œå»ºè®®ä½¿ç”¨Adobe Auditionä¸­çš„å‹é™å™¨å°†å£°éŸ³çš„åˆ†è´é™åˆ¶åœ¨-6dbä»¥å†… æ•™ç¨‹ï¼šhttps://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html åˆ‡ç‰‡å¹²å£°ç´ æéƒ½å¤„ç†å®Œåï¼Œä¸‹ä¸€æ­¥å°±æ˜¯å°†è¿™äº›ç´ æåˆ‡æˆä¸€ä¸ªä¸ª2-15sçš„å°ç‰‡æ®µï¼ˆç‰‡æ®µå¤ªé•¿å®¹æ˜“çˆ†æ˜¾å­˜ï¼Œæœ€å¥½ä¸è¦è¶…è¿‡20sï¼‰ï¼Œè¿™é‡Œæ¨èä½¿ç”¨ Audio Slicer ï¼Œå¯ä»¥æ ¹æ®å“åº¦é˜ˆå€¼å’Œé—´éš”æ—¶é—´ç­‰è‡ªåŠ¨å°†éŸ³é¢‘åˆ‡ç‰‡ å°†å¹²å£°æ–‡ä»¶æ‹–è¿›å»åå¯ä»¥å…ˆä½¿ç”¨é»˜è®¤å‚æ•°åˆ‡ä¸€éï¼Œç„¶åå»è¾“å‡ºç›®å½•ï¼Œå°†æ–‡ä»¶æŒ‰æ–‡ä»¶å¤§å°ç”±å¤§åˆ°å°æ’åˆ—ï¼ŒæŸ¥çœ‹æ˜¯å¦è¿˜æœ‰å¤§äº15sçš„éŸ³é¢‘åˆ‡ç‰‡ï¼Œå¦‚æœ‰çš„è¯ï¼Œå°†è¿™äº›éŸ³é¢‘é‡æ–°æ‹–å…¥è½¯ä»¶ä¸­ï¼ŒæŒ‰ç…§ä»¥ä¸‹å‚æ•°é‡æ–°åˆ‡ç‰‡ä¸€æ¬¡ï¼š Thresholdï¼ˆdbï¼‰: -20 Minimum Interval: 100 Maximum Silence Lengthï¼ˆmsï¼‰: 500 ä¸€èˆ¬è¿™æ ·å°±ä¸ä¼šæœ‰å¤§äº15sçš„éŸ³é¢‘äº†ï¼Œå¦‚æœè¿˜æœ‰çš„è¯ï¼Œæˆ‘å°†è¿™äº›å‚æ•°çš„å«ä¹‰åˆ—åœ¨ä¸‹é¢ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±è°ƒæ•´å‚æ•°å°è¯•ï¼Œå¤§å®¶ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–çš„ä¸€äº›éŸ³é¢‘å¤„ç†å·¥å…·ï¼ˆå¦‚ï¼šAUï¼‰æ‰‹åŠ¨åˆ‡ç‰‡ Thresholdï¼ˆé˜ˆå€¼ï¼‰ ä»¥ dB è¡¨ç¤ºçš„ RMS é˜ˆå€¼ã€‚æ‰€æœ‰ RMS å€¼éƒ½ä½äºæ­¤é˜ˆå€¼çš„åŒºåŸŸå°†è¢«è§†ä¸ºé™éŸ³ã€‚å¦‚æœéŸ³é¢‘æœ‰å™ªéŸ³ï¼Œè¯·å¢åŠ æ­¤å€¼ã€‚é»˜è®¤å€¼ä¸º -40ã€‚ Minimum Lengthï¼ˆæœ€å°é•¿åº¦ï¼‰ æ¯ä¸ªåˆ‡ç‰‡éŸ³é¢‘å‰ªè¾‘æ‰€éœ€çš„æœ€å°é•¿åº¦ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚é»˜è®¤å€¼ä¸º 5000ã€‚ Minimum Intervalï¼ˆæœ€å°é—´è·ï¼‰ è¦åˆ‡ç‰‡çš„é™éŸ³éƒ¨åˆ†çš„æœ€å°é•¿åº¦ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚å¦‚æœéŸ³é¢‘ä»…åŒ…å«çŸ­æš‚çš„ä¸­æ–­ï¼Œè¯·å°†æ­¤å€¼è®¾ç½®å¾—æ›´å°ã€‚æ­¤å€¼è¶Šå°ï¼Œæ­¤åº”ç”¨ç¨‹åºå¯èƒ½ç”Ÿæˆçš„åˆ‡ç‰‡éŸ³é¢‘å‰ªè¾‘å°±è¶Šå¤šã€‚è¯·æ³¨æ„ï¼Œæ­¤å€¼å¿…é¡»å°äº min length ä¸”å¤§äº hop sizeã€‚é»˜è®¤å€¼ä¸º 300ã€‚ Hop Sizeï¼ˆè·³è·ƒæ­¥é•¿ï¼‰ æ¯ä¸ª RMS å¸§çš„é•¿åº¦ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚å¢åŠ æ­¤å€¼å°†æé«˜åˆ‡ç‰‡çš„ç²¾åº¦ï¼Œä½†ä¼šé™ä½å¤„ç†é€Ÿåº¦ã€‚é»˜è®¤å€¼ä¸º 10ã€‚ Maximum Silence Lengthï¼ˆæœ€å¤§é™éŸ³é•¿åº¦ï¼‰ åœ¨åˆ‡ç‰‡éŸ³é¢‘å‘¨å›´ä¿æŒçš„æœ€å¤§é™éŸ³é•¿åº¦ï¼Œä»¥æ¯«ç§’ä¸ºå•ä½ã€‚æ ¹æ®éœ€è¦è°ƒæ•´æ­¤å€¼ã€‚è¯·æ³¨æ„ï¼Œè®¾ç½®æ­¤å€¼å¹¶ä¸æ„å‘³ç€åˆ‡ç‰‡éŸ³é¢‘ä¸­çš„é™éŸ³éƒ¨åˆ†å…·æœ‰å®Œå…¨ç»™å®šçš„é•¿åº¦ã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œè¯¥ç®—æ³•å°†æœç´¢è¦åˆ‡ç‰‡çš„æœ€ä½³ä½ç½®ã€‚é»˜è®¤å€¼ä¸º 1000ã€‚ æœ€åï¼Œè®°å¾—æŠŠè¿‡çŸ­çš„éŸ³é¢‘åˆ‡ç‰‡åˆ é™¤æ‰ æ ¼å¼è½¬æ¢æ•°æ®é›†çš„æ ¼å¼å¿…é¡»æ˜¯wavåŸå§‹æ³¢å½¢æ ¼å¼ï¼Œå¤§å®¶æ£€æŸ¥ä¸€ä¸‹ï¼Œå¦‚æœå¦‚æœæœ‰éwavæ ¼å¼çš„æ–‡ä»¶ï¼Œéœ€è¦åšä¸€ä¸‹æ ¼å¼è½¬æ¢ï¼Œæ¨èä½¿ç”¨Foobar2000ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨FFmepgè¿›è¡Œè½¬æ¢ é‡å‘½åæ•°æ®é›†ä¸­ä¸èƒ½å‡ºç°ä¸­æ–‡ç­‰éè‹±æ–‡å­—ç¬¦ï¼Œç‰¹æ®Šå­—ç¬¦æ¨èåªä½¿ç”¨ä¸‹åˆ’çº¿ï¼ŒWindowsä¸‹ç›´æ¥å°†æ–‡ä»¶å…¨é€‰åé‡å‘½åï¼Œæ–‡ä»¶åä¼šå˜æˆä»¥ä¸‹è¿™ç§æ ¼å¼ï¼š xxx (1).wav xxx (2).wav â€¦ æœ¬äººäº²æµ‹è¿™æ ·å‘½åè™½ç„¶ä¼šæŠ¥Warningï¼Œä½†ä¸å½±å“è®­ç»ƒï¼Œæ˜¯å¯è¡Œçš„ é¢„è®­ç»ƒæ¥ç€æˆ‘ä»¬å°±å¼€å§‹å‡†å¤‡è®­ç»ƒäº† æ”¾ç½®æ•°æ®é›†é¦–å…ˆå°†å¤„ç†å¥½çš„å¹²å£°å…¨éƒ¨æ”¾åˆ°ä¸€ä¸ªæ–‡ä»¶å¤¹ä¸‹ï¼Œç„¶åå†å°†è¿™ä¸ªæ–‡ä»¶å¤¹æ”¾åˆ°so-vits-svcç›®å½•ä¸‹çš„dataset_rawæ–‡ä»¶å¤¹ä¸‹ æ•°æ®é¢„å¤„ç†æ‰“å¼€webuiç•Œé¢ï¼Œåˆ‡æ¢åˆ°è®­ç»ƒé€‰é¡¹å¡ï¼Œé¦–å…ˆç‚¹å‡»è¯†åˆ«æ•°æ®é›†ï¼Œä¸Šé¢çš„æ–‡æœ¬æ¡†ä¸­ä¾¿ä¼šæ˜¾ç¤ºå‡ºæˆ‘ä»¬å‡†å¤‡å¥½çš„æ•°æ®é›†åï¼Œç„¶åé€‰æ‹©è®­ç»ƒä½¿ç”¨çš„ç¼–ç å™¨å’Œf0é¢„æµ‹å™¨ï¼Œè¿™é‡Œé€‰æ‹©æˆ‘å›¾ä¸­æ ‡å‡ºçš„ä¸¤ä¸ªé€‰é¡¹ï¼Œæ˜¯ç›®å‰æ•ˆæœæ¯”è¾ƒå¥½çš„é€‰é¡¹ï¼Œæ¥ç€ç‚¹å‡»æ•°æ®é¢„å¤„ç†ï¼Œåœ¨é¢„å¤„ç†è¾“å‡ºä¿¡æ¯é‚£ä¸€æ ä¼šæ‰“å°è¿›åº¦ï¼Œè€å¿ƒç­‰å¾…å®ƒè·‘å®Œ è®­ç»ƒé…ç½®ç­‰å¾…æ•°æ®é¢„å¤„ç†å®Œæˆåï¼Œæˆ‘ä»¬è¦å°†è®­ç»ƒçš„è®¾ç½®å’Œå‚æ•°å†™å…¥åˆ°é…ç½®æ–‡ä»¶ä¸­ ä»‹ç»ä¸€ä¸‹è¿™é‡Œå‚æ•°çš„å«ä¹‰å’Œæ¨èè®¾ç½®ï¼š æ¯éš”å¤šå°‘æ­¥(steps)ç”Ÿæˆä¸€æ¬¡è¯„ä¼°æ—¥å¿—ï¼šæ¯éš”ä¸€å®šæ­¥æ•°è¾“å‡ºä¸€ä¸‹å½“å‰æ­¥æ•°ä¸‹çš„å­¦ä¹ ç‡ï¼Œlosså€¼ç­‰ä¿¡æ¯ï¼Œæ ¹æ®ä¸ªäººåå¥½è‡ªå·±å¡«å†™å³å¯ æ¯éš”å¤šå°‘æ­¥(steps)éªŒè¯å¹¶ä¿å­˜ä¸€æ¬¡æ¨¡å‹ï¼šå­—é¢æ„æ€ï¼Œæ ¹æ®ä¸ªäººåå¥½è‡ªå·±å¡«å†™å³å¯ ä»…ä¿ç•™æœ€æ–°çš„Xä¸ªæ¨¡å‹ï¼šæˆ‘è®­ç»ƒåˆ°11ä¸‡æ­¥æ—¶ä¸€ä¸ªæ¨¡å‹æ¥è¿‘600MBï¼Œå¤§å®¶æ ¹æ®è‡ªå·±çš„ç¡¬ç›˜å¤§å°å’Œä¸ªäººåå¥½å¡«å†™å³å¯ æ‰¹é‡å¤§å°ï¼šå¤§çš„batch sizeå¯ä»¥å‡å°‘è®­ç»ƒæ—¶é—´ï¼Œæé«˜ç¨³å®šæ€§ï¼Œä½†åŒæ—¶ä¹Ÿä¼šå¯¼è‡´æ¨¡å‹æ³›åŒ–èƒ½åŠ›ä¸‹é™ï¼Œæ‰€ä»¥ï¼Œå°±ç®—ä½ çš„æ˜¾å­˜å¾ˆå¤§ä¹Ÿä¸å»ºè®®å°†æœ¬å‚æ•°è®¾ç½®çš„è¿‡å¤§ï¼Œæ¨èä½¿ç”¨4 å­¦ä¹ ç‡ï¼šåˆå§‹å­¦ä¹ ç‡è¿‡å¤§ä¼šå¯¼è‡´æ¨¡å‹æ— æ³•æ”¶æ•›ï¼Œè¿‡å°åˆ™ä¼šå¯¼è‡´æ¨¡å‹æ”¶æ•›ç‰¹åˆ«æ…¢æˆ–æ— æ³•å­¦ä¹ ï¼Œå»ºè®®ä½¿ç”¨é»˜è®¤å€¼0.0001 ä½¿ç”¨fp16æ··åˆç²¾åº¦è®­ç»ƒï¼šæ··åˆç²¾åº¦è®­ç»ƒæ˜¯åœ¨å°½å¯èƒ½å‡å°‘ç²¾åº¦æŸå¤±çš„æƒ…å†µä¸‹åˆ©ç”¨åŠç²¾åº¦æµ®ç‚¹æ•°åŠ é€Ÿè®­ç»ƒï¼Œå®ƒä½¿ç”¨FP16å³åŠç²¾åº¦æµ®ç‚¹æ•°å­˜å‚¨æƒé‡å’Œæ¢¯åº¦ï¼Œåœ¨å‡å°‘å ç”¨å†…å­˜çš„åŒæ—¶èµ·åˆ°äº†åŠ é€Ÿè®­ç»ƒçš„æ•ˆæœï¼Œç†è®ºä¸Šæ¥è¯´ä½¿ç”¨æ··åˆç²¾åº¦å‡ ä¹ä¸ä¼šé€ æˆç²¾åº¦æŸå¤±ï¼Œä½†ç›®å‰æ²¡å¯¹æ¨¡å‹è´¨é‡çš„å½±å“å°šæœªæŸ¥è¯ï¼Œåœ¨æ˜¾å¡æ€§èƒ½è¶³å¤Ÿçš„æƒ…å†µä¸‹å»ºè®®è¿˜æ˜¯å…ˆä¸è¦å‹¾é€‰ åŠ è½½æ•°æ®é›†åˆ°å†…å­˜ä¸­ï¼šåœ¨å†…å­˜è¶³å¤Ÿçš„æƒ…å†µä¸‹å»ºè®®å‹¾é€‰ï¼Œå¯ä»¥åŠ å¿«è®­ç»ƒé€Ÿåº¦ æ‰€æœ‰è®­ç»ƒå‚æ•°è®¾ç½®å¥½åï¼Œç‚¹å‡»ä¸‹é¢çš„å†™å…¥é…ç½®æ–‡ä»¶æŒ‰é’®ï¼Œåœ¨ä¸‹é¢çš„è¾“å‡ºä¿¡æ¯é‚£é‡Œä¼šæ˜¾ç¤ºé…ç½®æ–‡ä»¶å†™å…¥å®Œæˆï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥å¼€å§‹æ­£å¼è®­ç»ƒäº† æ­£å¼è®­ç»ƒç‚¹å‡»ä¸‹é¢çš„ä»å¤´å¼€å§‹è®­ç»ƒï¼Œä¼šå¼¹å‡ºä¸€ä¸ªæ–°çš„ç»ˆç«¯çª—å£ï¼Œåœ¨è¿™ä¸ªç»ˆç«¯çª—å£ä¸­ï¼Œä¼šä¸æ–­çš„è¾“å‡ºå½“å‰è®­ç»ƒçš„æ—¥å¿— æˆ‘çš„è®­ç»ƒå‚æ•°è®¾ç½®çš„æ˜¯æ¯éš”200æ­¥ç”Ÿæˆä¸€æ¬¡è¯„ä¼°æ—¥å¿—ï¼Œæ¯éš”1000æ­¥ä¿å­˜ä¸€æ¬¡æ¨¡å‹ï¼Œæ—¥å¿—ä¸­è¾“å‡ºçš„reference_losså€¼ä»£è¡¨äº†æ¨¡å‹çš„è¾“å‡ºä¸çœŸå®å€¼ä¹‹é—´çš„å·®è·ï¼Œç†è®ºæ¥è¯´ï¼Œè¿™ä¸ªå€¼è¶Šä½è¶Šå¥½ï¼Œè¶Šä½ï¼Œæ¨¡å‹è¾“å‡ºçš„å£°éŸ³å°±å’ŒçœŸäººçš„å£°éŸ³è¶Šåƒï¼Œä½†ä»ç»éªŒæ¥è¯´æœªå¿…å¦‚æ­¤ï¼Œè¿‡ä½çš„losså€¼ä¹Ÿå¯èƒ½ä»£è¡¨äº†æ¨¡å‹è¿‡æ‹Ÿåˆï¼Œæˆ‘ä»¬åªèƒ½å°†è¿™ä¸ªå‚æ•°ä½œä¸ºä¸€ä¸ªå‚è€ƒï¼Œå®é™…æ•ˆæœè¦ä½¿ç”¨æµ‹è¯•äº†è¿™ä¸ªæ¨¡å‹åæ‰èƒ½å¾—çŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥å‚è€ƒè¿™ä¸ªå€¼åˆæ­¥é€‰æ‹©æ¨¡å‹è¿›è¡Œæ¨ç†æµ‹è¯• è®­ç»ƒæ˜¯ä¸ä¼šè‡ªåŠ¨ç»ˆæ­¢çš„ï¼Œå½“æˆ‘ä»¬æ„Ÿè§‰è®­ç»ƒçš„å·®ä¸å¤šäº†ï¼Œæƒ³è¯•ä¸€ä¸‹æ¨¡å‹çš„å®é™…æ•ˆæœæ—¶ï¼Œå¯ä»¥åœ¨è®­ç»ƒç»ˆç«¯çª—å£ä¸­é”®ç›˜é”®å…¥Ctrl + Cåœæ­¢è®­ç»ƒï¼Œå¦‚æœå¯¹æœ¬æ¬¡è®­ç»ƒå‡ºæ¥çš„æ¨¡å‹è¿˜ä¸æ»¡æ„ï¼Œæƒ³è¦ç»§ç»­è®­ç»ƒï¼Œåˆ™å¯ä»¥ç‚¹å‡»ç»§ç»­ä¸Šä¸€æ¬¡çš„è®­ç»ƒè¿›åº¦ï¼Œç¨‹åºä¼šä»ä¸Šä¸€ä¸ªè‡ªåŠ¨ä¿å­˜çš„æ¨¡å‹çš„è¿›åº¦å¼€å§‹ç»§ç»­è®­ç»ƒ æ¨ç†åŠ è½½æ¨¡å‹æ¨¡å‹è®­ç»ƒå®Œåæˆ‘ä»¬å°±å¯ä»¥å°†é€‰é¡¹å¡åˆ‡æ¢åˆ°æ¨ç†æ¥æµ‹è¯•æ¨¡å‹çš„å®é™…æ•ˆæœäº† æˆ‘ä»¬å…ˆç‚¹å‡»åˆ·æ–°é€‰é¡¹ï¼Œæ­¤æ—¶åœ¨æ¨¡å‹é€‰æ‹©å’Œé…ç½®æ–‡ä»¶çš„ä¸‹æ‹‰èœå•ä¸­å°±å‡ºç°äº†æˆ‘ä»¬ä¹‹å‰è®­ç»ƒå¥½çš„æ¨¡å‹ï¼Œå‚è€ƒä¹‹å‰çš„reference_losså€¼æˆ‘ä»¬é€‰å–ä¸€ä¸ªæ¨¡å‹ï¼ˆGå¼€å¤´ï¼‰ï¼Œå¹¶ä¸”é€‰æ‹©è®­ç»ƒæ‰€ä½¿ç”¨çš„é…ç½®æ–‡ä»¶ï¼Œç‚¹å‡»åŠ è½½æ¨¡å‹ï¼Œç­‰å¾…ä¸‹é¢çš„Output Messageæ–‡æœ¬æ¡†å‡ºç°æ¨¡å‹åŠ è½½æˆåŠŸå­—æ ·ï¼Œå°±å¯ä»¥æ­£å¼å¼€å§‹æˆ‘ä»¬çš„æ¨ç†äº† å¼€å§‹æ¨ç†Sovitsæ˜¯ä¸€ä¸ªå£°éŸ³è½¬æ¢å·¥å…·ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ‰¾ä¸€æ®µæƒ³è¦è½¬æ¢çš„åŸå£°éŸ³é¢‘ï¼Œå’Œå‡†å¤‡æ•°æ®é›†é‚£ä¸€ç« çš„è¦æ±‚ä¸€æ ·ï¼Œæˆ‘ä»¬éœ€è¦ä¸€æ®µå¹²å£°ï¼Œä¸èƒ½æœ‰ä¼´å¥ã€æ··å“ã€å’Œå£°ã€‚å¦‚æœæƒ³è®©æ¨¡å‹å”±æ­Œçš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å‰é¢å‡†å¤‡æ•°æ®é›†æ‰€ç”¨çš„æ–¹æ³•ï¼Œç›´æ¥å°†åŸæ›²å»ä¼´å¥æ··å“ï¼Œå¤„ç†å¥½åå°†å…¶æ‹–å…¥éŸ³é¢‘ä¸Šä¼ åŒºåŸŸä¸­ é»˜è®¤çš„ pm f0é¢„æµ‹å™¨æ¨ç†å‡ºæ¥çš„éŸ³è´¨æ•ˆæœæœ€å¥½ï¼Œæ‰€ä»¥å»ºè®®å…ˆä½¿ç”¨é»˜è®¤å‚æ•°æ¨ç†ä¸€éï¼Œå‡ºç°é—®é¢˜å†é’ˆå¯¹æ€§çš„å¯¹å‚æ•°è¿›è¡Œè°ƒæ•´ æˆ‘ä»¬ç‚¹å‡»ä¸‹é¢çš„éŸ³é¢‘è½¬æ¢æŒ‰é’®ï¼Œç¨ç­‰ä¸€ä¼šå„¿ï¼Œåœ¨Output Audioé‚£é‡Œä¾¿ä¼šç”Ÿæˆä¸€æ®µæ¨ç†åçš„éŸ³é¢‘ æˆ‘ä»¬è¯•å¬åæ ¹æ®å…·ä½“çš„é—®é¢˜è®¾ç½®è½¬æ¢å‚æ•°ï¼š å‡ºç°å“‘éŸ³ å“‘éŸ³æ˜¯å› ä¸ºåŸå£°éŸ³é¢‘ä¸­çš„å’Œå£°éƒ¨åˆ†æ²¡æœ‰å»å¤„å¹²å‡€ï¼Œå¯¼è‡´f0é¢„æµ‹å™¨å¯¹éŸ³é«˜çš„é¢„æµ‹å‡ºç°äº†é”™è¯¯ï¼Œé¢„æµ‹æˆäº†ä¸€ä¸ªæé«˜çš„éŸ³é«˜ï¼Œæ¨¡å‹å”±ä¸ä¸Šå»å¯¼è‡´çš„ æœ‰ä¸¤ç§åŠæ³•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä¸€ç§å°±æ˜¯ä»æºå¤´è§£å†³é—®é¢˜ï¼Œæƒ³åŠæ³•å°†åŸå£°éŸ³é¢‘çš„å’Œå£°æ··å“å»é™¤ï¼Œè·å¾—æ›´çº¯å‡€çš„å¹²å£°é‡æ–°æ¨ç†ï¼Œå¦ä¸€ç§æ–¹æ³•å¯ä»¥å°†f0é¢„æµ‹å™¨æ¢æˆcrepeï¼Œé€‚åº¦è°ƒèŠ‚F0è¿‡æ»¤é˜ˆå€¼ï¼ˆä¸€èˆ¬ä½¿ç”¨é»˜è®¤å€¼å°±è¡Œï¼Œæ”¹å¤§æ”¹å°æ²¡ä»€ä¹ˆåŒºåˆ«ï¼‰ï¼Œç„¶åé‡æ–°è¿›è¡Œæ¨ç†åŸºæœ¬å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯éŸ³è´¨ä¸å¦‚f0é¢„æµ‹å™¨pmï¼Œç”µæµéŸ³ç­‰æ‚éŸ³ä¼šå˜å¤šï¼Œä¸¤ç§æ–¹æ³•å¤§å®¶å¯ä»¥è‡ªè¡Œåˆ¤æ–­é€‰å– éŸ³åŸŸå·®è·è¿‡å¤§ å¦‚æœè®­ç»ƒçš„æ¨¡å‹æ˜¯ç”·å£°ï¼Œä½†æ¨ç†ä½¿ç”¨çš„åŸå£°æ˜¯å¥³å£°ï¼Œæˆ–è€…åè¿‡æ¥ï¼Œç¢°åˆ°è¿™ç§éŸ³åŸŸå·®è·è¿‡å¤§çš„æƒ…å†µä¼šå¯¼è‡´æ¨ç†å‡ºæ¥çš„éŸ³é¢‘ä¸å ªå…¥è€³ æˆ‘ä»¬å¯ä»¥æ‰“å¼€f0è‡ªåŠ¨é¢„æµ‹é€‰é¡¹æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ­£å¦‚é€‰é¡¹é‡Œæè¿°çš„é‚£æ ·ï¼Œæ­¤é€‰æ‹©ä»…é™äºè½¬æ¢è¯­éŸ³æ—¶æ‰å¯ç”¨ï¼Œè½¬æ¢æ­Œå£°æ—¶æ‰“å¼€æ­¤é€‰é¡¹ä¼šå¯¼è‡´ç¾éš¾æ€§çš„è·‘è°ƒ å¦‚æœæ˜¯æ­Œå£°å¹¶ä¸”å®åœ¨æ˜¯æƒ³è¦å”±è¿™é¦–æ­Œçš„è¯ï¼Œå»ºè®®å»æ‰¾ä¸€ä¸ªå’Œè‡ªå·±éŸ³åŸŸæ¯”è¾ƒå¥‘åˆçš„ç¿»å”±éŸ³é¢‘ï¼Œç”¨è¿™ä¸ªéŸ³é¢‘å¤„ç†åä½œä¸ºåŸå£°è¿›è¡Œæ¨ç† éƒ¨åˆ†éŸ³è°ƒå”±ä¸ä¸Šï¼ˆä¸‹ï¼‰å» è®­ç»ƒæ—¶å–‚çš„æ•°æ®é›†æ²¡æœ‰è¦†ç›–åˆ°éƒ¨åˆ†éŸ³åŸŸ è¿™é‡Œçš„å˜è°ƒé€‰é¡¹ä¼¼ä¹æ˜¯å…ˆæ¨ç†å†å˜è°ƒï¼Ÿæ‰€ä»¥å¯¹è¿™ç§æƒ…å†µä¸èµ·ä½œç”¨ï¼Œå»ºè®®ä½¿ç”¨AUå…ˆå°†åŸå£°éŸ³é¢‘å‡é™è°ƒåˆ°åˆé€‚çš„éŸ³åŸŸï¼Œå†è¿›è¡Œæ¨ç† çˆ†æ˜¾å­˜ åœ¨æ¨ç†çš„è¿‡ç¨‹ä¸­æœ‰å¯èƒ½ä¼šå‡ºç°çˆ†æ˜¾å­˜çš„æƒ…å†µï¼Œå› ä¸ºæ¨ç†ä¹Ÿæ˜¯å°†åŸéŸ³é¢‘æŒ‰ç…§å“åº¦é˜ˆå€¼åˆ‡æˆä¸€æ®µæ®µå°åˆ‡ç‰‡åˆ†åˆ«è¿›è¡Œæ¨ç†ï¼Œæœ€åå†åˆæˆï¼Œå¦‚æœå…¶ä¸­æœ‰ä¸€æ®µåˆ‡ç‰‡æ—¶å¸¸è¿‡é•¿å°±å¯èƒ½ä¼šå¯¼è‡´çˆ†æ˜¾å­˜ æˆ‘ä»¬å¯ä»¥å°†åˆ‡ç‰‡é˜ˆå€¼è°ƒé«˜ï¼Œä½¿å¾—åŸå£°éŸ³é¢‘å¯ä»¥åˆ‡çš„æ›´åŠ ç»†ç¢ï¼Œç”šè‡³ä½ ä¹Ÿå¯ä»¥ç›´æ¥è°ƒæ•´éŸ³é¢‘è‡ªåŠ¨åˆ‡ç‰‡çš„å€¼å¼€å¯å¼ºåˆ¶åˆ‡ç‰‡ï¼Œæ¯”å¦‚è¾“å…¥10ï¼ŒéŸ³é¢‘å°±ä¼šè¢«åˆ‡æˆæ¯10sä¸€æ®µï¼Œç¡®ä¿éŸ³é¢‘æ—¶å¸¸ä¸ä¼šçˆ†æ˜¾å­˜ åˆæˆå¦‚æœè½¬æ¢çš„æ˜¯æ­Œå£°ï¼Œæœ€åå¯ä»¥å°†è½¬æ¢å‡ºæ¥çš„å¹²å£°å’Œä¼´å¥åˆå¹¶æˆä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨AUç­‰è½¯ä»¶ï¼Œåœ¨åˆæˆä¹‹å‰è¿˜å¯ä»¥å¯¹å¹²å£°è¿›è¡Œä¸€äº›EQã€æ··å“çš„è°ƒæ•´ç­‰ï¼Œå…³äºéŸ³ä¹æ–¹é¢çš„çŸ¥è¯†è¿™é‡Œå°±ä¸å¤šè¯´äº† ç»“å°¾æœ€åè´´ä¸€ä¸‹æˆ‘è‡ªå·±ç»ƒçš„æ¨¡å‹æ‰€æ¨ç†å‡ºæ¥çš„æ­Œå£°ï¼Œä½¿ç”¨äº†30åˆ†é’Ÿè´¨é‡è¾ƒå¥½çš„å¹²å£°ç´ æå’Œ30åˆ†é’Ÿè´¨é‡è¾ƒå·®çš„ç´ æï¼ˆå™ªéŸ³å’Œæ··å“æ¯”è¾ƒå¤šï¼‰ï¼Œè®­ç»ƒäº†11ä¸‡æ­¥ï¼Œä½¿ç”¨crepef0é¢„æµ‹å™¨æ¨ç†å¾—å‡º é“¾æ¥ï¼šhttps://www.bilibili.com/audio/au3907000 è¿™æ˜¯æˆ‘ç¬¬ä¸€æ¬¡å°è¯•è®­ç»ƒSovitsæ¨¡å‹ï¼Œå¦‚æœæœ‰ä»€ä¹ˆç–æ¼æˆ–é”™è¯¯æ¬¢è¿å¤§å®¶æŒ‡å‡º","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"},{"name":"AIäººå£°","slug":"AI/AIäººå£°","permalink":"http://yoursite.com/categories/AI/AI%E4%BA%BA%E5%A3%B0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"AIGC","slug":"AIGC","permalink":"http://yoursite.com/tags/AIGC/"},{"name":"AIäººå£°","slug":"AIäººå£°","permalink":"http://yoursite.com/tags/AI%E4%BA%BA%E5%A3%B0/"},{"name":"Sovits","slug":"Sovits","permalink":"http://yoursite.com/tags/Sovits/"}]},{"title":"å¦‚ä½•å®Œç¾ç›‘å¬å¸§åŠ¨ç”»ï¼ŸAnimationDrawableæ·±åº¦è§£æ","slug":"android/animation/å¦‚ä½•å®Œç¾ç›‘å¬å¸§åŠ¨ç”»ï¼ŸAnimationDrawableæ·±åº¦è§£æ","date":"2023-06-01T07:20:51.000Z","updated":"2023-06-19T14:06:38.286Z","comments":true,"path":"2023/06/01/android/animation/å¦‚ä½•å®Œç¾ç›‘å¬å¸§åŠ¨ç”»ï¼ŸAnimationDrawableæ·±åº¦è§£æ/","link":"","permalink":"http://yoursite.com/2023/06/01/android/animation/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E7%9B%91%E5%90%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%EF%BC%9FAnimationDrawable%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","excerpt":"","text":"ç®€ä»‹ä½œä¸ºè‹¦é€¼çš„ç¨‹åºå‘˜ï¼Œäº§å“å’Œè®¾è®¡æå‡ºæ¥çš„éœ€æ±‚å’±ä¹Ÿæ²¡æ³•æ‹’ç»ï¼Œè¿™ä¸ï¼Œå‰ä¸¤å¤©è®¾è®¡å°±ç»™æäº†ä¸ªéœ€æ±‚ï¼Œè¦æ±‚åœ¨å¸§åŠ¨ç”»ç»“æŸåï¼ŒæŠŠåŸä½ç½®çš„åŠ¨ç”»æ›¿æ¢æˆä¸€æ®µæ–‡å­—ã€‚æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Androidä¸­ï¼Œå¸§åŠ¨ç”»çš„å®ç°ç±»ä¸ºAnimationDrawableï¼Œè€Œè¿™ç©æ„å„¿åˆä¸åƒAnimatorä¸€æ ·å¯ä»¥é€šè¿‡addListenerä¹‹ç±»çš„æ–¹æ³•ç›‘å¬åŠ¨ç”»çš„å¼€å§‹ã€ç»“æŸç­‰äº‹ä»¶ï¼Œé‚£æˆ‘ä»¬è¯¥æ€ä¹ˆç›‘å¬AnimationDrawableçš„ç»“æŸäº‹ä»¶å‘¢ï¼Ÿ ç›®å‰ç½‘ä¸Šå¤§å¤šæ•°çš„åšæ³•éƒ½æ˜¯è·å–å¸§åŠ¨ç”»çš„æ€»æ—¶é•¿ï¼Œç„¶åç”¨Handleråšä¸€ä¸ªpostDelayedæ‰§è¡Œç»“æŸåçš„äº‹æƒ…ã€‚è¿™ç§æ–¹æ³•æ€ä¹ˆè¯´å‘¢ï¼Ÿèƒ½ç”¨ï¼Œä½†æ˜¯ä¸å¤Ÿç²¾å‡†ä¹Ÿä¸å¤Ÿä¼˜é›…ï¼Œæœ¬æ–‡æˆ‘ä»¬å°†ä»æºç å±‚é¢è§£æAnimationDrawableæ˜¯å¦‚ä½•å°†ä¸€å¸§å¸§çš„å›¾ç‰‡ç»„åˆèµ·æ¥å±•ç¤ºæˆè¿ç»­çš„åŠ¨ç”»çš„ï¼Œå†ä»ä¸­å¯»æ±‚åŠ¨ç”»ç›‘å¬çš„åˆ‡å…¥ç‚¹ã€‚ æ³¨ï¼šåªæƒ³çœ‹å®ç°çš„æœ‹å‹ä»¬å¯ä»¥ç›´æ¥è·³åˆ° åŒ…è£…Drawable.Callback è¿™ä¸€èŠ‚çœ‹æœ€ç»ˆå®ç° ImageViewå¦‚ä½•å±•ç¤ºDrawableAnimationDrawableè¯´åˆ°åº•å®ƒä¹Ÿå°±æ˜¯ä¸ªDrawableï¼Œè€Œæˆ‘ä»¬ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ImageViewä½œä¸ºDrawableå±•ç¤ºçš„å¸ƒå±€ï¼Œé‚£æˆ‘ä»¬å°±ä»¥æ­¤ä½œä¸ºå…¥å£å¼€å§‹åˆ†æDrawableåœ¨ImageViewä¸­æ˜¯å¦‚ä½•è¢«å±•ç¤ºçš„ã€‚ å›æƒ³ä¸€ä¸‹ï¼Œæˆ‘ä»¬æƒ³è¦ç»™ä¸€ä¸ªImageViewè®¾ç½®å›¾ç‰‡ä¸€èˆ¬å¯ä»¥ç”¨ä¸‹é¢å‡ ç§æ–¹æ³•ï¼š setImageBitmap setImageResource setImageURI setImageDrawable setImageBitmapä¼šå°†BitmapåŒ…è£…æˆä¸€ä¸ªBitmapDrawableï¼Œç„¶åå†è°ƒç”¨setImageDrawableæ–¹æ³•ã€‚ setImageResourceå’ŒsetImageURIæ–¹æ³•ä¼šé€šè¿‡resolveUriæ–¹æ³•ä»Resourceæˆ–Uriä¸­è§£æå‡ºDrawableï¼Œç„¶åè°ƒç”¨updateDrawableæ–¹æ³• setImageDrawableæ–¹æ³•åˆ™ä¼šç›´æ¥è°ƒç”¨updateDrawableæ–¹æ³• æœ€ç»ˆæ®Šé€”åŒå½’èµ°åˆ°updateDrawableæ–¹æ³•ä¸­ 123456789101112131415161718private void updateDrawable(Drawable d) &#123; ... if (mDrawable != null) &#123; sameDrawable = mDrawable == d; mDrawable.setCallback(null); unscheduleDrawable(mDrawable); ... &#125; mDrawable = d; if (d != null) &#123; d.setCallback(this); ... &#125; else &#123; ... &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå°†æˆ‘ä»¬è®¾ç½®çš„å›¾ç‰‡èµ„æºèµ‹å€¼åˆ°mDrawableä¸Šã€‚æ³¨æ„ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªDrawableåŠ¨èµ·æ¥çš„å…³é”®ç‚¹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯æˆ‘ä»¬åŠ¨ç”»ç›‘å¬çš„æœ€ç»ˆåˆ‡å…¥ç‚¹ï¼šDrawable.setCallback(this)ï¼Œæˆ‘ä»¬åé¢åˆ†æå¸§åˆ‡æ¢çš„æ—¶å€™ä¼šè¯¦ç»†å»èŠå®ƒã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªæ§ä»¶æƒ³è¦ç»˜åˆ¶å†…å®¹å¾—åœ¨onDrawæ–¹æ³•ä¸­æ“ä½œCanvasï¼Œæ‰€ä»¥è®©æˆ‘ä»¬å†æ¥çœ‹çœ‹onDrawæ–¹æ³• 123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mDrawable == null) &#123; return; // couldn't resolve the URI &#125; if (mDrawableWidth == 0 || mDrawableHeight == 0) &#123; return; // nothing to draw (empty bounds) &#125; ... mDrawable.draw(canvas); ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œè°ƒç”¨äº†Drawable.drawæ–¹æ³•å°†Drawableè‡ªèº«ç»˜åˆ¶åˆ°ImageViewçš„Canvasä¸Š DrawableContaineræŸ¥çœ‹AnimationDrawableçš„ç»§æ‰¿å…³ç³»æˆ‘ä»¬å¯ä»¥å¾—çŸ¥å®ƒç»§æ‰¿è‡ªDrawableContainerï¼Œä»å‘½åä¸­æˆ‘ä»¬å°±èƒ½çœ‹å‡ºæ¥ï¼Œå®ƒæ˜¯Drawableçš„å®¹å™¨ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒæ‰€å®ç°çš„drawæ–¹æ³•ï¼š 12345678public void draw(Canvas canvas) &#123; if (mCurrDrawable != null) &#123; mCurrDrawable.draw(canvas); &#125; if (mLastDrawable != null) &#123; mLastDrawable.draw(canvas); &#125;&#125; mLastDrawableæ˜¯ä¸ºäº†å®ŒæˆåŠ¨ç”»çš„åˆ‡æ¢æ•ˆæœï¼ˆå‡ºå…¥åœºåŠ¨ç”»ï¼‰æ‰€å‡†å¤‡çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ç”¨å…³å¿ƒå®ƒã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå®ƒçš„å†…éƒ¨æœ‰ä¸€ä¸ªåä¸ºmCurrDrawableçš„æˆå‘˜å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥åˆç†çŒœæµ‹å®ƒæ˜¯é€šè¿‡åˆ‡æ¢mCurrDrawableæŒ‡å‘çš„ç›®æ ‡Drawableæ¥å®Œæˆå±•ç¤ºä¸åŒå›¾ç‰‡çš„åŠŸèƒ½ï¼Œé‚£ä¹ˆäº‹å®æ˜¯è¿™æ ·å—ï¼Ÿ æ²¡é”™ï¼ŒDrawableContainerç»™æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªselectDrawableæ–¹æ³•ï¼Œç”¨æ¥åˆ‡æ¢ä¸åŒçš„å›¾ç‰‡ï¼š 1234567891011121314151617181920212223public boolean selectDrawable(int index) &#123; if (index == mCurIndex) &#123; return false; &#125; ... if (index &gt;= 0 &amp;&amp; index &lt; mDrawableContainerState.mNumChildren) &#123; final Drawable d = mDrawableContainerState.getChild(index); mCurrDrawable = d; mCurIndex = index; ... &#125; else &#123; mCurrDrawable = null; mCurIndex = -1; &#125; ... invalidateSelf(); return true;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå’Œæˆ‘ä»¬çŒœæƒ³çš„ä¸€æ ·ï¼Œåœ¨DrawableContainerçš„å†…éƒ¨æœ‰ä¸€ä¸ªå­ç±»DrawableContainerStateç”¨äºä¿å­˜æ‰€æœ‰çš„Drawableï¼Œå®ƒç»§æ‰¿è‡ªDrawable.ConstantStateï¼Œæ˜¯ç”¨æ¥å‚¨å­˜Drawableé—´çš„å¸¸é‡çŠ¶æ€å’Œæ•°æ®çš„ã€‚åœ¨DrawableContainerStateä¸­æœ‰ä¸€ä¸ªmDrawablesæ•°ç»„ç”¨äºä¿å­˜æ‰€æœ‰çš„Drawableï¼Œé€šè¿‡addChildæ–¹æ³•å°†DrawableåŠ å…¥åˆ°è¿™ä¸ªæ•°ç»„ä¸­ è€Œåœ¨selectDrawableæ–¹æ³•ä¸­ï¼Œå®ƒé€šè¿‡getChildæ–¹æ³•å»è·å–å½“å‰åº”è¯¥æ˜¾ç¤ºçš„Drawableï¼Œå¹¶å°†å…¶å’Œindexåˆ†åˆ«èµ‹å€¼ç»™å®ƒçš„ä¸¤ä¸ªæˆå‘˜å˜é‡mCurrDrawableå’ŒmCurIndexï¼Œç„¶åè°ƒç”¨invalidateSelfæ–¹æ³•æ‰§è¡Œé‡ç»˜ï¼š 123456public void invalidateSelf() &#123; final Callback callback = getCallback(); if (callback != null) &#123; callback.invalidateDrawable(this); &#125;&#125; invalidateSelfè¢«å®šä¹‰å®ç°åœ¨Drawableç±»ä¸­ï¼Œè¿˜è®°å¾—æˆ‘ä¹‹å‰è®©å¤§å®¶æ³¨æ„çš„Callbackå—ï¼Ÿåœ¨è®¾ç½®å›¾ç‰‡è¿™ä¸€æ­¥æ—¶ï¼Œå®ƒå°±è¢«èµ‹å€¼äº†ï¼Œå®é™…ä¸Šè¿™ä¸ªæ¥å£è¢«Viewæ‰€å®ç°ï¼Œæ‰€ä»¥åœ¨å‰é¢æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è°ƒç”¨setCallbackæ—¶ï¼Œæˆ‘ä»¬ä¼ å…¥çš„å‚æ•°ä¸ºthis ä¸è¿‡ImageViewåœ¨ç»§æ‰¿Viewçš„åŒæ—¶ä¹Ÿé‡å†™äº†è¿™ä¸ªinvalidateDrawableæ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨äº†invalidateæ–¹æ³•æ‰§è¡Œé‡ç»˜ï¼Œæ­¤æ—¶ï¼Œä¸€å¼ æ–°çš„å›¾ç‰‡å°±è¢«å±•ç¤ºåˆ°æˆ‘ä»¬çš„å±å¹•ä¸Šäº† 1234567891011121314151617181920212223242526//ImageView.invalidateDrawablepublic void invalidateDrawable(@NonNull Drawable dr) &#123; if (dr == mDrawable) &#123; if (dr != null) &#123; // update cached drawable dimensions if they've changed final int w = dr.getIntrinsicWidth(); final int h = dr.getIntrinsicHeight(); if (w != mDrawableWidth || h != mDrawableHeight) &#123; mDrawableWidth = w; mDrawableHeight = h; // updates the matrix, which is dependent on the bounds configureBounds(); &#125; &#125; /* we invalidate the whole view in this case because it's very * hard to know where the drawable actually is. This is made * complicated because of the offsets and transformations that * can be applied. In theory we could get the drawable's bounds * and run them through the transformation and offsets, but this * is probably not worth the effort. */ invalidate(); &#125; else &#123; super.invalidateDrawable(dr); &#125;&#125; AnimationDrawableDrawableContaineråˆ†æå®Œåï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆè‡ªç„¶çš„æƒ³åˆ°ï¼ŒAnimationDrawableå°±æ˜¯é€šè¿‡DrawableContainerè¿™ç§å¯ä»¥åˆ‡æ¢å›¾ç‰‡çš„æœºåˆ¶ï¼Œæ¯éš”ä¸€å®šæ—¶é—´æ‰§è¡Œä¸€ä¸‹selectDrawableä¾¿å¯ä»¥è¾¾æˆå¸§åŠ¨ç”»çš„æ•ˆæœäº†ã€‚ æˆ‘ä»¬å…ˆå›æƒ³ä¸€ä¸‹ï¼Œåœ¨ä»£ç ä¸­æ€ä¹ˆæ„é€ å‡ºä¸€ä¸ªå¤šå¸§çš„AnimationDrawableï¼Ÿæ²¡é”™ï¼Œç”¨é»˜è®¤æ„é€ æ–¹æ³•å®ä¾‹åŒ–å‡ºæ¥åï¼Œè°ƒç”¨å®ƒçš„addFrameæ–¹æ³•å¾€é‡Œä¸€å¸§å¸§çš„æ·»åŠ å›¾ç‰‡ï¼š 123456public void addFrame(@NonNull Drawable frame, int duration) &#123; mAnimationState.addFrame(frame, duration); if (!mRunning) &#123; setFrame(0, true, false); &#125;&#125; å¯ä»¥çœ‹åˆ°AnimationDrawableä¹Ÿæœ‰ä¸€ä¸ªå†…éƒ¨ç±»AnimationStateï¼Œç»§æ‰¿è‡ªDrawableContainerStateï¼Œå®ƒçš„addFrameæ–¹æ³•å°±æ˜¯è°ƒç”¨DrawableContainerState.addChildæ–¹æ³•æ·»åŠ å›¾ç‰‡ï¼ŒåŒæ—¶å°†è¿™å¼ å›¾ç‰‡çš„æŒç»­æ—¶é—´ä¿å­˜åœ¨mDurationsæ•°ç»„ä¸­ï¼š 1234public void addFrame(Drawable dr, int dur) &#123; int pos = super.addChild(dr); mDurations[pos] = dur;&#125; æƒ³è®©AnimationDrawableåŠ¨èµ·æ¥çš„è¯ï¼Œæˆ‘ä»¬å¾—è¦è°ƒç”¨å®ƒçš„startæ–¹æ³•ï¼Œé‚£æˆ‘ä»¬å°±ä»è¿™ä¸ªæ–¹æ³•å¼€å§‹åˆ†æï¼š 123456789public void start() &#123; mAnimating = true; if (!isRunning()) &#123; // Start from 0th frame. setFrame(0, false, mAnimationState.getChildCount() &gt; 1 || !mAnimationState.mOneShot); &#125;&#125; è¿™é‡Œå°†mAnimatingçŠ¶æ€ç½®ä¸ºtrueï¼Œç„¶åè°ƒç”¨setFrameæ–¹æ³•ä»ç¬¬0å¸§å¼€å§‹å±•ç¤ºå›¾ç‰‡ 1234567891011121314151617private void setFrame(int frame, boolean unschedule, boolean animate) &#123; if (frame &gt;= mAnimationState.getChildCount()) &#123; return; &#125; mAnimating = animate; mCurFrame = frame; selectDrawable(frame); if (unschedule || animate) &#123; unscheduleSelf(this); &#125; if (animate) &#123; // Unscheduling may have clobbered these values; restore them mCurFrame = frame; mRunning = true; scheduleSelf(this, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]); &#125;&#125; è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå’Œæˆ‘ä»¬æ‰€æƒ³çš„ä¸€æ ·ï¼Œè°ƒç”¨äº†DrawableContainer.selectDrawableåˆ‡æ¢å½“å‰å±•ç¤ºå›¾ç‰‡ï¼Œç”±äºæˆ‘ä»¬ä¹‹å‰å°†mAnimatingèµ‹å€¼ä¸ºäº†trueï¼Œæ‰€ä»¥ä¼šè°ƒç”¨scheduleSelfæ–¹æ³•è°ƒåº¦å±•ç¤ºä¸‹ä¸€å¼ å›¾ç‰‡ï¼Œæ—¶é—´ä¸ºå½“å‰å¸§æŒç»­æ—¶é—´å 123456public void scheduleSelf(@NonNull Runnable what, long when) &#123; final Callback callback = getCallback(); if (callback != null) &#123; callback.scheduleDrawable(this, what, when); &#125;&#125; scheduleSelfæ–¹æ³•è°ƒç”¨äº†Drawable.Callback.scheduleDrawableæ–¹æ³•ï¼Œæˆ‘ä»¬å»Viewé‡Œé¢çœ‹å®ç°ï¼š 1234567891011121314public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) &#123; if (verifyDrawable(who) &amp;&amp; what != null) &#123; final long delay = when - SystemClock.uptimeMillis(); if (mAttachInfo != null) &#123; mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed( Choreographer.CALLBACK_ANIMATION, what, who, Choreographer.subtractFrameDelay(delay)); &#125; else &#123; // Postpone the runnable until we know // on which thread it needs to run. getRunQueue().postDelayed(what, delay); &#125; &#125;&#125; å®é™…ä¸Šä¸¤ä¸ªåˆ†æ”¯æœ€ç»ˆéƒ½æ˜¯é€šè¿‡Handlerå®ç°å»¶æ—¶è°ƒç”¨ï¼Œè€Œè°ƒç”¨çš„Runnableå¯¹è±¡å°±æ˜¯ä¹‹å‰scheduleSelfä¼ å…¥çš„thisã€‚æ²¡é”™ï¼ŒAnimationDrawableå®ç°äº†Runnableæ¥å£ï¼š 12345678910111213141516public void run() &#123; nextFrame(false);&#125;private void nextFrame(boolean unschedule) &#123; int nextFrame = mCurFrame + 1; final int numFrames = mAnimationState.getChildCount(); final boolean isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - 1); // Loop if necessary. One-shot animations should never hit this case. if (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) &#123; nextFrame = 0; &#125; setFrame(nextFrame, unschedule, !isLastFrame);&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ä¸€å¸§æŒç»­æ—¶é—´ç»“æŸåï¼Œä¾¿ä¼šè°ƒç”¨nextFrameæ–¹æ³•ï¼Œè®¡ç®—ä¸‹ä¸€å¸§çš„indexï¼Œç„¶åè°ƒç”¨setFrameæ–¹æ³•åˆ‡æ¢ä¸‹ä¸€å¸§ï¼Œå½¢æˆä¸€ä¸ªå¾ªç¯ï¼Œè¿™æ ·ä¸€å¸§å¸§çš„å›¾ç‰‡ä¾¿åŠ¨äº†èµ·æ¥ï¼Œå½¢æˆäº†å¸§åŠ¨ç”» åŒ…è£…Drawable.Callbackæˆ‘ä»¬ä»æºç å±‚é¢åˆ†æäº†å¸§åŠ¨ç”»æ˜¯å¦‚ä½•è¿ä½œçš„ï¼Œé‚£ä¹ˆæ€ä¹ˆç›‘å¬åŠ¨ç”»äº‹ä»¶ç›¸ä¿¡å„ä½åº”è¯¥éƒ½èƒ½å¾—å‡ºç»“è®ºäº†å§ï¼Ÿæ²¡é”™ï¼Œå°±æ˜¯é‡è®¾Drawableçš„Callback å½“Drawableè¢«è®¾ç½®åˆ°æ§ä»¶ä¸­åï¼Œæ§ä»¶ä¼šå°†è‡ªèº«ä½œä¸ºDrawable.Callbackè®¾ç½®ç»™Drawableï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦é‡æ–°ç»™Drawableè®¾ç½®ä¸€ä¸ªDrawable.Callbackï¼Œåœ¨å…¶ä¸­è°ƒç”¨Viewå›è°ƒæ–¹æ³•çš„åŒæ—¶ï¼ŒåŠ å…¥è‡ªå·±çš„ç›‘å¬é€»è¾‘å³å¯ 123456789101112131415161718192021222324252627val animDrawable = imageView.drawable as AnimationDrawableval callback = object : Drawable.Callback &#123; override fun invalidateDrawable(who: Drawable) &#123; imageView.invalidateDrawable(who) if (animDrawable.getFrame(animDrawable.numberOfFrames - 1) == current &amp;&amp; animDrawable.isOneShot &amp;&amp; animDrawable.isRunning &amp;&amp; animDrawable.isVisible ) &#123; val lastFrameDuration = getDuration(animDrawable.numberOfFrames - 1) postDelayed(&#123; ...//ç»“æŸåéœ€è¦åšçš„äº‹ &#125;, lastFrameDuration.toLong()) &#125; &#125; override fun scheduleDrawable(who: Drawable, what: Runnable, `when`: Long) &#123; imageView.scheduleDrawable(who, what, `when`) &#125; override fun unscheduleDrawable(who: Drawable, what: Runnable) &#123; imageView.unscheduleDrawable(who, what) &#125;&#125;//æ³¨æ„ä¸€å®šéœ€è¦ç”¨ä¸€ä¸ªæˆå‘˜å˜é‡æˆ–å…¶ä»–æ–¹å¼æŒæœ‰è¿™ä¸ªCallback//å› ä¸ºDrawable.Callbackæ˜¯ä»¥å¼±å¼•ç”¨çš„å½¢å¼è¢«ä¿å­˜åœ¨Drawableå†…çš„ï¼Œå¾ˆå®¹æ˜“è¢«å›æ”¶mCallbackHolder = callbackanimDrawable.callback = callbackanimDrawable.start() ä»¥ä¸Šçš„ä»£ç ä¾¿æ˜¯ç¤ºä¾‹ï¼Œå½“æ»¡è¶³åŠ¨ç”»è¿è¡Œåˆ°æœ€åä¸€å¸§ï¼Œä¸”æ»¡è¶³ç»“æŸçŠ¶æ€æ—¶ï¼Œåœ¨æœ€åä¸€å¸§çš„æŒç»­æ—¶é—´åå¤„ç†ç»“æŸåéœ€è¦åšçš„äº‹ å½“AnimationDrawableåˆ‡æ¢VisibleçŠ¶æ€ä¸ºfalseæ—¶ï¼ŒåŠ¨ç”»ä¼šè¢«æš‚åœï¼Œå¦‚æœåœ¨åŠ¨ç”»ç»“æŸåè§¦å‘setVisible(false)äº‹ä»¶ï¼Œä¹Ÿä¼šè§¦å‘invalidateDrawableå›è°ƒï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦é¢å¤–åˆ¤æ–­ä¸€ä¸‹isVisible è‡ªå·±åŒ…è£…çš„Drawable.Callbackä¸€å®šéœ€è¦æ‰¾ä¸ªä¸œè¥¿å°†å®ƒå¼ºå¼•ç”¨èµ·æ¥ï¼Œå› ä¸ºDrawable.Callbackæ˜¯ä»¥å¼±å¼•ç”¨çš„å½¢å¼è¢«ä¿å­˜åœ¨Drawableå†…çš„ï¼Œå¾ˆå®¹æ˜“è¢«å›æ”¶ï¼Œä¸€æ—¦è¢«å›æ”¶ï¼Œæ•´ä¸ªAnimationDrawableåŠ¨ç”»å°±åŠ¨ä¸èµ·æ¥äº† å°¾å£°ä¸ºäº†è¿™ä¹ˆç®€å•ä¸€ä¸ªå°åŠŸèƒ½ï¼Œè¿˜å¾—è·‘åˆ°æºç é‡Œçœ‹æ€ä¹ˆå®ç°ï¼Œå¯¹æ­¤æˆ‘çš„æ„Ÿå—æ˜¯ï¼šä¸€å…¥å®‰å“æ·±ä¼¼æµ·ï¼Œä»æ­¤å¤´å‘æ˜¯è·¯äºº","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"åŠ¨ç”»","slug":"Android/åŠ¨ç”»","permalink":"http://yoursite.com/categories/Android/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"åŠ¨ç”»","slug":"åŠ¨ç”»","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"AnimationDrawable","slug":"AnimationDrawable","permalink":"http://yoursite.com/tags/AnimationDrawable/"}]},{"title":"AndroidåŠ¨æ€æƒé™ç”³è¯·ä»æœªå¦‚æ­¤ç®€å•","slug":"android/common/AndroidåŠ¨æ€æƒé™ç”³è¯·ä»æœªå¦‚æ­¤ç®€å•","date":"2023-04-23T13:55:46.000Z","updated":"2023-04-24T15:17:47.677Z","comments":true,"path":"2023/04/23/android/common/AndroidåŠ¨æ€æƒé™ç”³è¯·ä»æœªå¦‚æ­¤ç®€å•/","link":"","permalink":"http://yoursite.com/2023/04/23/android/common/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/","excerpt":"","text":"å‰è¨€æ³¨ï¼šåªæƒ³çœ‹å®ç°çš„æœ‹å‹ä»¬å¯ä»¥ç›´æ¥è·³åˆ°æœ€åé¢çš„æœ€ç»ˆå®ç° å¤§å®¶æ˜¯å¦è¿˜åœ¨ä¸ºåŠ¨æ€æƒé™ç”³è¯·æ„Ÿåˆ°è‹¦æ¼å‘¢ï¼Ÿä¼ ç»Ÿçš„åŠ¨æ€æƒé™ç”³è¯·éœ€è¦åœ¨Activityä¸­é‡å†™onRequestPermissionsResultæ–¹æ³•æ¥æ¥æ”¶ç”¨æˆ·æƒé™æˆäºˆçš„ç»“æœã€‚è¯•æƒ³ä¸€ä¸‹ï¼Œä½ éœ€è¦åœ¨ä¸€ä¸ªå­æ¨¡å—ä¸­ç”³è¯·æƒé™ï¼Œé‚£å¾—ä»è¿™ä¸ªæ¨¡å—æ‰€åœ¨çš„Activityçš„onRequestPermissionsResultä¸­å°†ç»“æœä¸€å±‚å±‚å†ä¼ å›åˆ°è¿™ä¸ªæ¨¡å—ä¸­ï¼Œç›¸å½“çš„éº»çƒ¦ï¼Œä»£ç ä¹Ÿç›¸å½“å†—ä½™å’Œä¸å¹²å‡€ï¼Œé€¼æ­»å¼ºè¿«ç—‡ã€‚ ä½¿ç”¨ä¸ºäº†è§£å†³è¿™ä¸ªç—›ç‚¹ï¼Œæˆ‘å°è£…å‡ºäº†ä¸¤ä¸ªæ–¹æ³•ï¼Œç”¨äºéšæ—¶éšåœ°å¿«é€Ÿçš„åŠ¨æ€ç”³è¯·æƒé™ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹æˆ‘ä»¬çš„å°è£…æ–¹æ³•æ˜¯å¦‚ä½•è°ƒç”¨çš„ï¼š 12345678activity.requestPermission(Manifest.permission.CAMERA, onPermit = &#123; //ç”³è¯·æƒé™æˆåŠŸ Do something&#125;, onDeny = &#123; shouldShowCustomRequest -&gt; //ç”³è¯·æƒé™å¤±è´¥ Do something if (shouldShowCustomRequest) &#123; //ç”¨æˆ·é€‰æ‹©äº†æ‹’ç»å¹¶ä¸”ä¸åœ¨è¯¢é—®ï¼Œæ­¤æ—¶åº”è¯¥ä½¿ç”¨è‡ªå®šä¹‰å¼¹çª—æé†’ç”¨æˆ·æˆæƒï¼ˆå¯é€‰ï¼‰ &#125;&#125;) è¿™æ ·æ˜¯ä¸æ˜¯éå¸¸çš„ç®€å•ä¾¿æ·ï¼Ÿç”³è¯·å’Œç»“æœå›è°ƒéƒ½åœ¨ä¸€ä¸ªæ–¹æ³•å†…å¤„ç†ï¼Œå¹¶ä¸”æ”¯æŒéšç”¨éšè°ƒã€‚ æ–¹æ¡ˆé‚£ä¹ˆï¼Œè¿™ä¹ˆæ–¹ä¾¿å¥½ç”¨çš„æ–¹æ³•æ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿä¸çŸ¥é“å°ä¼™ä¼´ä»¬åœ¨å¹³æ—¶å¼€å‘ä¸­æœ‰æ²¡æœ‰æ³¨æ„åˆ°è¿‡ï¼Œå½“ä½ è°ƒç”¨startActivityForResultæ—¶ï¼ŒASä¼šæç¤ºä½ è¯¥æ–¹æ³•å·²è¢«å¼ƒç”¨ï¼Œç‚¹è¿›å»çœ‹ä¼šå‘Šè¯‰ä½ åº”è¯¥ä½¿ç”¨registerForActivityResultæ–¹æ³•æ›¿ä»£ã€‚æ²¡é”™ï¼Œè¿™å°±æ˜¯androidxç»™æˆ‘ä»¬æä¾›çš„ActivityResultåŠŸèƒ½ï¼Œå¹¶ä¸”è¿™ä¸ªåŠŸèƒ½ä¸ä»…æ”¯æŒActivityResultå›è°ƒï¼Œè¿˜æ”¯æŒæ‰“å¼€æ–‡æ¡£ï¼Œæ‹æ‘„ç…§ç‰‡ï¼Œé€‰æ‹©æ–‡ä»¶ç­‰å„ç§å„æ ·çš„å›è°ƒï¼ŒåŒæ ·ä¹ŸåŒ…æ‹¬æˆ‘ä»¬ä»Šå¤©è¦è¯´çš„æƒé™ç”³è¯· å…¶å®Androidåœ¨å®˜æ–¹æ–‡æ¡£ è¯·æ±‚è¿è¡Œæ—¶æƒé™ ä¸­å°±å·²ç»å°†å…¶ä½œä¸ºåŠ¨æ€æƒé™ç”³è¯·çš„æ¨èæ–¹æ³•äº†ï¼Œå¦‚ä¸‹ç¤ºä¾‹ä»£ç æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425262728293031323334353637val requestPermissionLauncher = registerForActivityResult(RequestPermission() ) &#123; isGranted: Boolean -&gt; if (isGranted) &#123; // Permission is granted. Continue the action or workflow in your // app. &#125; else &#123; // Explain to the user that the feature is unavailable because the // feature requires a permission that the user has denied. At the // same time, respect the user's decision. Don't link to system // settings in an effort to convince the user to change their // decision. &#125; &#125;when &#123; ContextCompat.checkSelfPermission( CONTEXT, Manifest.permission.REQUESTED_PERMISSION ) == PackageManager.PERMISSION_GRANTED -&gt; &#123; // You can use the API that requires the permission. &#125; shouldShowRequestPermissionRationale(...) -&gt; &#123; // In an educational UI, explain to the user why your app requires this // permission for a specific feature to behave as expected, and what // features are disabled if it's declined. In this UI, include a // \"cancel\" or \"no thanks\" button that lets the user continue // using your app without granting the permission. showInContextUI(...) &#125; else -&gt; &#123; // You can directly ask for the permission. // The registered ActivityResultCallback gets the result of this request. requestPermissionLauncher.launch( Manifest.permission.REQUESTED_PERMISSION) &#125;&#125; è¯´åˆ°è¿™é‡Œï¼Œå¯èƒ½æœ‰å°ä¼™ä¼´è¦è´¨ç–‘æˆ‘äº†ï¼šâ€œå®˜æ–¹æ–‡æ¡£é‡Œéƒ½å†™æ˜äº†çš„ä¸œè¥¿ï¼Œä½ è¿˜ç‰¹åœ°å†™ä¸€éï¼Œè¿˜èµ·äº†è¿™ä¹ˆä¸ªæ ‡é¢˜ï¼Œæ˜¯ä¸æ˜¯åœ¨æ°´æ–‡ç« ï¼Ÿï¼â€ è«æ€¥ï¼Œå¦‚æœä½ éµç…§ä»¥ä¸Šæ–¹æ³•è¿™ä¹ˆå†™çš„è¯ï¼Œåœ¨å®é™…è°ƒç”¨çš„æ—¶å€™ä¼šç›´æ¥å‘ç”Ÿå´©æºƒï¼š 123java.lang.IllegalStateException: LifecycleOwner Activity is attempting to register while current state is RESUMED. LifecycleOwners must call register before they are STARTED. è¿™æ®µæŠ¥é”™å¾ˆæ˜æ˜¾çš„å‘Šè¯‰æˆ‘ä»¬ï¼Œæˆ‘ä»¬çš„æ³¨å†Œå·¥ä½œå¿…é¡»è¦åœ¨Activityå£°æ˜å‘¨æœŸSTARTEDä¹‹å‰è¿›è¡Œï¼ˆä¹Ÿå°±æ˜¯onCreateæ—¶å’ŒonStartå®Œæˆå‰ï¼‰ï¼Œä½†è¿™æ ·æˆ‘ä»¬å°±å¿…é¡»è¦äº‹å…ˆæ³¨å†Œå¥½æ‰€æœ‰å¯èƒ½ä¼šç”¨åˆ°çš„æƒé™ï¼Œæ²¡åŠæ³•åšåˆ°éšæ—¶éšåœ°æœ‰éœ€è¦æ—¶å†ç”³è¯·æƒé™äº†ï¼Œæœ‰åŠæ³•è§£å†³è¿™ä¸ªé—®é¢˜å—ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚ ç»•è¿‡ç”Ÿå‘½å‘¨æœŸæ£€æµ‹æƒ³è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»è¦çŸ¥é“é—®é¢˜çš„æˆå› ï¼Œè®©æˆ‘ä»¬å¸¦ç€é—®é¢˜è¿›åˆ°æºç ä¸­ä¸€æ¢ç©¶ç«Ÿï¼š 12345678910111213141516171819202122232425262728293031323334353637383940public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; registerForActivityResult( @NonNull ActivityResultContract&lt;I, O&gt; contract, @NonNull ActivityResultCallback&lt;O&gt; callback) &#123; return registerForActivityResult(contract, mActivityResultRegistry, callback);&#125;public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; registerForActivityResult( @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultRegistry registry, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; return registry.register( \"activity_rq#\" + mNextLocalRequestCode.getAndIncrement(), this, contract, callback);&#125;public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; register( @NonNull final String key, @NonNull final LifecycleOwner lifecycleOwner, @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; Lifecycle lifecycle = lifecycleOwner.getLifecycle(); if (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123; throw new IllegalStateException(\"LifecycleOwner \" + lifecycleOwner + \" is \" + \"attempting to register while current state is \" + lifecycle.getCurrentState() + \". LifecycleOwners must call register before \" + \"they are STARTED.\"); &#125; registerKey(key); LifecycleContainer lifecycleContainer = mKeyToLifecycleContainers.get(key); if (lifecycleContainer == null) &#123; lifecycleContainer = new LifecycleContainer(lifecycle); &#125; LifecycleEventObserver observer = new LifecycleEventObserver() &#123; ... &#125;; lifecycleContainer.addObserver(observer); mKeyToLifecycleContainers.put(key, lifecycleContainer); return new ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;&#125; æˆ‘ä»¬å¯ä»¥å‘ç°ï¼ŒregisterForActivityResultå®é™…ä¸Šå°±æ˜¯è°ƒç”¨äº†ComponentActivityå†…éƒ¨æˆå‘˜å˜é‡çš„mActivityResultRegistry.registeræ–¹æ³•ï¼Œè€Œåœ¨è¿™ä¸ªæ–¹æ³•çš„ä¸€å¼€å¤´å°±æ£€æŸ¥äº†å½“å‰Activityçš„ç”Ÿå‘½å‘¨æœŸï¼Œå¦‚æœç”Ÿå‘½å‘¨æœŸä½äºSTARTEDååˆ™ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œé‚£æˆ‘ä»¬è¯¥å¦‚ä½•ç»•è¿‡è¿™ä¸ªé™åˆ¶å‘¢ï¼Ÿ å…¶å®åœ¨registeræ–¹æ³•çš„ä¸‹é¢å°±æœ‰ä¸€ä¸ªåŒåé‡è½½æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å¹¶æ²¡æœ‰åšç”Ÿå‘½å‘¨æœŸçš„æ£€æµ‹ï¼š 1234567891011121314151617181920212223public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; register( @NonNull final String key, @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; registerKey(key); mKeyToCallback.put(key, new CallbackAndContract&lt;&gt;(callback, contract)); if (mParsedPendingResults.containsKey(key)) &#123; @SuppressWarnings(\"unchecked\") final O parsedPendingResult = (O) mParsedPendingResults.get(key); mParsedPendingResults.remove(key); callback.onActivityResult(parsedPendingResult); &#125; final ActivityResult pendingResult = mPendingResults.getParcelable(key); if (pendingResult != null) &#123; mPendingResults.remove(key); callback.onActivityResult(contract.parseResult( pendingResult.getResultCode(), pendingResult.getData())); &#125; return new ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;&#125; æ‰¾åˆ°è¿™ä¸ªæ–¹æ³•å°±ç®€å•äº†ï¼Œæˆ‘ä»¬å°†registerForActivityResultæ–¹æ³•è°ƒç”¨æ›¿æ¢æˆactivityResultRegistry.registerè°ƒç”¨å°±å¯ä»¥äº† å½“ç„¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ³¨æ„ä¸€äº›å°ç»†èŠ‚ï¼Œæ£€æŸ¥ç”Ÿå‘½å‘¨æœŸçš„registeræ–¹æ³•åŒæ—¶ä¹Ÿä¼šæ³¨å†Œç”Ÿå‘½å‘¨æœŸå›è°ƒï¼Œå½“Activityè¢«é”€æ¯æ—¶ä¼šå°†æˆ‘ä»¬æ³¨å†Œçš„ActivityResultå›è°ƒç§»é™¤ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ç»™æˆ‘ä»¬å°è£…çš„æ–¹æ³•åŠ ä¸Šè¿™ä¸ªé€»è¾‘ï¼Œæœ€ç»ˆå®ç°å°±å¦‚ä¸‹æ‰€ç¤ºã€‚ æœ€ç»ˆå®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293private val nextLocalRequestCode = AtomicInteger()private val nextKey: String get() = \"activity_rq#$&#123;nextLocalRequestCode.getAndIncrement()&#125;\"fun ComponentActivity.requestPermission( permission: String, onPermit: () -&gt; Unit, onDeny: (shouldShowCustomRequest: Boolean) -&gt; Unit) &#123; if (ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED) &#123; onPermit() return &#125; var launcher by Delegates.notNull&lt;ActivityResultLauncher&lt;String&gt;&gt;() launcher = activityResultRegistry.register( nextKey, ActivityResultContracts.RequestPermission() ) &#123; result -&gt; if (result) &#123; onPermit() &#125; else &#123; onDeny(!ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#125; launcher.unregister() &#125; lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; launcher.unregister() lifecycle.removeObserver(this) &#125; &#125; &#125;) launcher.launch(permission)&#125;fun ComponentActivity.requestPermissions( permissions: Array&lt;String&gt;, onPermit: () -&gt; Unit, onDeny: (shouldShowCustomRequest: Boolean) -&gt; Unit) &#123; var hasPermissions = true for (permission in permissions) &#123; if (ContextCompat.checkSelfPermission( this, permission ) != PackageManager.PERMISSION_GRANTED ) &#123; hasPermissions = false break &#125; &#125; if (hasPermissions) &#123; onPermit() return &#125; var launcher by Delegates.notNull&lt;ActivityResultLauncher&lt;Array&lt;String&gt;&gt;&gt;() launcher = activityResultRegistry.register( nextKey, ActivityResultContracts.RequestMultiplePermissions() ) &#123; result -&gt; var allAllow = true for (allow in result.values) &#123; if (!allow) &#123; allAllow = false break &#125; &#125; if (allAllow) &#123; onPermit() &#125; else &#123; var shouldShowCustomRequest = false for (permission in permissions) &#123; if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#123; shouldShowCustomRequest = true break &#125; &#125; onDeny(shouldShowCustomRequest) &#125; launcher.unregister() &#125; lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; launcher.unregister() lifecycle.removeObserver(this) &#125; &#125; &#125;) launcher.launch(permissions)&#125; æ€»ç»“å…¶å®å¾ˆå¤šå®ç”¨æŠ€å·§æœ¬è´¨ä¸Šéƒ½æ˜¯å¾ˆç®€å•çš„ï¼Œä½†æ²¡æœ‰æ¥è§¦è¿‡å°±å¾ˆéš¾æƒ³åˆ°ï¼Œæˆ‘å°†æˆ‘çš„å¼€å‘ç»éªŒåˆ†äº«ç»™å¤§å®¶ï¼Œå¸Œæœ›èƒ½å¸®åŠ©åˆ°å¤§å®¶ã€‚","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æƒé™","slug":"Android/æƒé™","permalink":"http://yoursite.com/categories/Android/%E6%9D%83%E9%99%90/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"æƒé™","slug":"æƒé™","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"}]},{"title":"Androidæºç åˆ†æ - Activityé”€æ¯æµç¨‹","slug":"android/aosp/Androidæºç åˆ†æ-Activityé”€æ¯æµç¨‹","date":"2023-03-08T07:49:50.000Z","updated":"2023-04-23T13:51:43.890Z","comments":true,"path":"2023/03/08/android/aosp/Androidæºç åˆ†æ-Activityé”€æ¯æµç¨‹/","link":"","permalink":"http://yoursite.com/2023/03/08/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ æˆ‘ä»¬åœ¨ä¹‹å‰çš„å‡ ç¯‡Activityå¯åŠ¨æµç¨‹åˆ†æä¸­å·²ç»äº†è§£äº†Activityä¸€åŠçš„ç”Ÿå‘½å‘¨æœŸï¼Œæ¥ä¸‹æ¥è¿™ç¯‡æ–‡ç« æˆ‘ä»¬å°±æ¥åˆ†æä¸€ä¸‹Activityé”€æ¯ç›¸å…³çš„ç”Ÿå‘½å‘¨æœŸ å‰å‡ æœŸæ–‡ç« å›é¡¾ï¼š Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰ è§¦å‘é”€æ¯æ—¢ç„¶è¦åˆ†æActivityé”€æ¯æµç¨‹ï¼Œé‚£æˆ‘ä»¬å°±ä»æœ€å¸¸è§çš„å…¥å£Activity.finishå…¥æ‰‹ 123public void finish() &#123; finish(DONT_FINISH_TASK_WITH_ACTIVITY);&#125; é»˜è®¤çš„finishæ–¹æ³•è°ƒç”¨äº†å¦ä¸€ä¸ªåŒåé‡è½½æ–¹æ³•ï¼Œæ¥å—ä¸€ä¸ªintç±»å‹çš„å‚æ•°è¡¨æ˜æ˜¯å¦éœ€è¦åœ¨é”€æ¯Activityçš„åŒæ—¶é”€æ¯Taskï¼Œè¯¥å‚æ•°æœ‰ä»¥ä¸‹ä¸‰ç§ï¼š DONT_FINISH_TASK_WITH_ACTIVITYï¼šé»˜è®¤å‚æ•°ï¼Œè¡¨ç¤ºåœ¨é”€æ¯Activityçš„æ—¶å€™ä¸è¦é”€æ¯Task FINISH_TASK_WITH_ROOT_ACTIVITYï¼šå½“Activityä¸ºè·ŸActivityçš„æ—¶å€™ï¼Œé”€æ¯çš„åŒæ—¶é”€æ¯Taskï¼ŒåŒæ—¶è¿™ä¸ªä»»åŠ¡ä¹Ÿä¼šä»æœ€è¿‘ä»»åŠ¡ä¸­ç§»é™¤ FINISH_TASK_WITH_ACTIVITYï¼šé”€æ¯Activityçš„æ—¶å€™åŒæ—¶é”€æ¯Taskï¼Œä½†ä¸ä¼šä»æœ€è¿‘ä»»åŠ¡ä¸­ç§»é™¤ 123456789101112131415161718192021222324252627282930313233private void finish(int finishTask) &#123; if (mParent == null) &#123; //å½“finishåæ‰å¯èƒ½ä¼šè§¦å‘onActivityResultå›è°ƒ //è¿™é‡Œå‡†å¤‡å°†resultè¿”å›ç»™ä¹‹å‰è°ƒç”¨startActivityForResultçš„Activity int resultCode; Intent resultData; synchronized (this) &#123; resultCode = mResultCode; resultData = mResultData; &#125; try &#123; //ä¸¤ä¸ªActivityå¯èƒ½å¤„äºä¸åŒè¿›ç¨‹ä¸­ï¼Œåšè¿›ç¨‹é—´é€šä¿¡çš„å‡†å¤‡ if (resultData != null) &#123; resultData.prepareToLeaveProcess(this); &#125; //è°ƒç”¨ATMSé”€æ¯Activity if (ActivityTaskManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) &#123; mFinished = true; &#125; &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.finishFromChild(this); &#125; // Activity was launched when user tapped a link in the Autofill Save UI - Save UI must // be restored now. if (mIntent != null &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123; restoreAutofillSaveUi(); &#125;&#125; onActivityResultå›è°ƒæ˜¯åœ¨å¯¹åº”Activity resumeæ—¶æ‰å¯èƒ½è§¦å‘ï¼Œå…·ä½“è¿‡ç¨‹åé¢ä¼šåˆ†æï¼Œå°†ActivityRecord.Tokenå’ŒResultä½œä¸ºå‚æ•°è°ƒç”¨ATMS.finishActivityæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) &#123; // Refuse possible leaked file descriptors //å›ä¼ çš„ResultIntentä¸­ä¸å…è®¸åŒ…å«fdï¼Œé˜²æ­¢æ³„æ¼ if (resultData != null &amp;&amp; resultData.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; final ActivityRecord r; synchronized (mGlobalLock) &#123; //è·å–ActivityRecordå¹¶ä¿è¯å…¶åœ¨æ ˆä¸­ r = ActivityRecord.isInStackLocked(token); //ä¸ºnullè¯´æ˜å·²è¢«ç§»å‡ºActivityStackï¼Œè§†ä½œå·²è¢«finish if (r == null) &#123; return true; &#125; &#125; // Carefully collect grants without holding lock //æ£€æŸ¥è°ƒç”¨æ–¹ï¼ˆå³å¾…finishçš„Activityï¼‰æ˜¯å¦èƒ½æˆäºˆresultæ‰€å¯¹åº”Activity packageè®¿é—®uriçš„æƒé™ final NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo); synchronized (mGlobalLock) &#123; // Sanity check in case activity was removed before entering global lock. if (!r.isInHistory()) &#123; return true; &#125; // Keep track of the root activity of the task before we finish it final Task tr = r.getTask(); final ActivityRecord rootR = tr.getRootActivity(); // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can // finish. //LockTaskæ¨¡å¼ä¸‹ï¼Œå¦‚æœæ­¤ä¸ºæœ€åä¸€ä¸ªTaskï¼Œåˆ™ä¸å…è®¸è¢«é”€æ¯ //è¯¦è§ï¼šhttps://developer.android.com/work/dpc/dedicated-devices/lock-task-mode if (getLockTaskController().activityBlockedFromFinish(r)) &#123; return false; &#125; // TODO: There is a dup. of this block of code in ActivityStack.navigateUpToLocked // We should consolidate. //IActivityControlleråˆ†å‘ActivityçŠ¶æ€å˜åŒ– if (mController != null) &#123; // Find the first activity that is not finishing. //å¯»æ‰¾è¯¥Activityé”€æ¯åçš„ä¸‹ä¸€ä¸ªé¡¶å±‚Activity final ActivityRecord next = r.getRootTask().topRunningActivity(token, INVALID_TASK_ID); if (next != null) &#123; // ask watcher if this is allowed boolean resumeOK = true; try &#123; resumeOK = mController.activityResuming(next.packageName); &#125; catch (RemoteException e) &#123; mController = null; Watchdog.getInstance().setActivityController(null); &#125; if (!resumeOK) &#123; return false; &#125; &#125; &#125; // note down that the process has finished an activity and is in background activity // starts grace period //è®¾ç½®Activityé”€æ¯çš„æœ€æ–°æ—¶é—´ if (r.app != null) &#123; r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis()); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; boolean res; final boolean finishWithRootActivity = finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY; if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY || (finishWithRootActivity &amp;&amp; r == rootR)) &#123; //éœ€è¦åŒæ—¶é”€æ¯Task // If requested, remove the task that is associated to this activity only if it // was the root activity in the task. The result code and data is ignored // because we don't support returning them across task boundaries. Also, to // keep backwards compatibility we remove the task from recents when finishing // task with root activity. //ç§»é™¤Task mStackSupervisor.removeTask(tr, false /*killProcess*/, finishWithRootActivity, \"finish-activity\"); res = true; // Explicitly dismissing the activity so reset its relaunch flag. r.mRelaunchReason = RELAUNCH_REASON_NONE; &#125; else &#123; //ä¸éœ€è¦åŒæ—¶é”€æ¯Task r.finishIfPossible(resultCode, resultData, resultGrants, \"app-request\", true /* oomAdj */); res = r.finishing; &#125; return res; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125;&#125; è¿™ä¸ªæ–¹æ³•é‡Œåˆ†äº†ä¸¤ä¸ªcaseï¼Œå½“éœ€è¦åŒæ—¶é”€æ¯Taskçš„æ—¶å€™ï¼Œç›´æ¥è°ƒç”¨ActivityStackSupervisor.removeTaskï¼Œå½“ä¸éœ€è¦åŒæ—¶é”€æ¯Taskçš„æ—¶å€™ï¼Œè°ƒç”¨ActivityRecord.finishIfPossible æˆ‘ä»¬å…ˆçœ‹éœ€è¦åŒæ—¶é”€æ¯Taskçš„case 1234567891011121314151617181920212223void removeTask(Task task, boolean killProcess, boolean removeFromRecents, String reason) &#123; if (task.mInRemoveTask) &#123; // Prevent recursion. return; &#125; task.mInRemoveTask = true; try &#123; //æ‰§è¡ŒTaskç§»é™¤æ“ä½œ task.performClearTask(reason); //å¯¹Taskæ‰§è¡Œæ€è¿›ç¨‹ï¼Œä»æœ€è¿‘ä»»åŠ¡åˆ—è¡¨ç§»é™¤ç­‰æ“ä½œ cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents); //å…³é—­LockTaskæ¨¡å¼ mService.getLockTaskController().clearLockedTask(task); //é€šçŸ¥TaskçŠ¶æ€å‘ç”Ÿå˜åŒ– mService.getTaskChangeNotificationController().notifyTaskStackChanged(); //å°†æœ€è¿‘ä»»åŠ¡æŒä¹…åŒ–ä¿å­˜ if (task.isPersistable) &#123; mService.notifyTaskPersisterLocked(null, true); &#125; &#125; finally &#123; task.mInRemoveTask = false; &#125;&#125; æœ¬ç¯‡æ–‡ç« æˆ‘ä»¬ä¸»è¦å…³æ³¨çš„æ˜¯Activityé”€æ¯æµç¨‹ï¼Œè‡³äºè¿›ç¨‹çš„å…³é—­ï¼Œæœ€è¿‘ä»»åŠ¡åˆ—è¡¨çš„æ›´æ–°æˆ‘ä»¬åœ¨è¿™é‡Œå°±ä¸å…³å¿ƒäº†ï¼Œè€Œè¿™é‡ŒActivityé”€æ¯çš„é‡ç‚¹åœ¨äºTask.performClearTaskæ–¹æ³• 12345678910111213141516171819/** Completely remove all activities associated with an existing task. */void performClearTask(String reason) &#123; // Broken down into to cases to avoid object create due to capturing mStack. if (getStack() == null) &#123; forAllActivities((r) -&gt; &#123; if (r.finishing) return; // Task was restored from persistent storage. r.takeFromHistory(); removeChild(r); &#125;); &#125; else &#123; forAllActivities((r) -&gt; &#123; if (r.finishing) return; // TODO: figure-out how to avoid object creation due to capture of reason variable. r.finishIfPossible(Activity.RESULT_CANCELED, null /* resultData */, null /* resultGrants */, reason, false /* oomAdj */); &#125;); &#125;&#125; æˆ‘ä»¬çœ‹ååŠéƒ¨åˆ†ä»£ç å¯ä»¥å‘ç°ï¼Œè¿™ä¸ªæ–¹æ³•å¯¹Taskä¸­æ‰€æœ‰æœªé”€æ¯çš„Activityéƒ½æ‰§è¡Œäº†ActivityRecord.finishIfPossibleæ–¹æ³•ï¼Œè¿™æ ·è·¯å¾„å°±å’Œä¸Šé¢ATMS.finishActivityæ–¹æ³•ä¸­ç¬¬äºŒä¸ªcaseç»Ÿä¸€äº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * Finish activity if possible. If activity was resumed - we must first pause it to make the * activity below resumed. Otherwise we will try to complete the request immediately by calling * &#123;@link #completeFinishing(String)&#125;. * @return One of &#123;@link FinishRequest&#125; values: * &#123;@link #FINISH_RESULT_REMOVED&#125; if this activity has been removed from the history list. * &#123;@link #FINISH_RESULT_REQUESTED&#125; if removal process was started, but it is still in the list * and will be removed from history later. * &#123;@link #FINISH_RESULT_CANCELLED&#125; if activity is already finishing or in invalid state and the * request to finish it was not ignored. */@FinishRequest int finishIfPossible(int resultCode, Intent resultData, NeededUriGrants resultGrants, String reason, boolean oomAdj) &#123; //é˜²æ­¢é‡å¤é”€æ¯ if (finishing) &#123; return FINISH_RESULT_CANCELLED; &#125; //æ­¤Activityä¸åœ¨ä»»åŠ¡æ ˆä¸­ if (!isInStackLocked()) &#123; return FINISH_RESULT_CANCELLED; &#125; final ActivityStack stack = getRootTask(); //åº”è¯¥è°ƒæ•´é¡¶éƒ¨Activity final boolean mayAdjustTop = (isState(RESUMED) || stack.mResumedActivity == null) &amp;&amp; stack.isFocusedStackOnDisplay(); //åº”è¯¥è°ƒæ•´å…¨å±€ç„¦ç‚¹ final boolean shouldAdjustGlobalFocus = mayAdjustTop // It must be checked before &#123;@link #makeFinishingLocked&#125; is called, because a stack // is not visible if it only contains finishing activities. &amp;&amp; mRootWindowContainer.isTopDisplayFocusedStack(stack); //æš‚åœå¸ƒå±€å·¥ä½œ mAtmService.deferWindowLayout(); try &#123; //è®¾ç½®å½“å‰ActivityçŠ¶æ€ä¸ºfinishing makeFinishingLocked(); // Make a local reference to its task since this.task could be set to null once this // activity is destroyed and detached from task. final Task task = getTask(); //è·å–ä¸Šä¸€ä¸ªActivityRecord ActivityRecord next = task.getActivityAbove(this); //ä¼ é€’FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESETï¼šé‡ç½®è¯¥Taskæ—¶æ¸…é™¤æ­¤Activity if (next != null) &#123; if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) &#123; // If the caller asked that this activity (and all above it) // be cleared when the task is reset, don't lose that information, // but propagate it up to the next activity. next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET); &#125; &#125; //æš‚åœè¾“å…¥äº‹ä»¶åˆ†å‘ pauseKeyDispatchingLocked(); // We are finishing the top focused activity and its task has nothing to be focused so // the next focusable task should be focused. //åº”è¯¥è°ƒæ•´é¡¶éƒ¨Activityï¼Œä½†æ­¤Taskæ²¡æœ‰Activityå¯ä»¥è¢«è¿è¡Œåœ¨é¡¶éƒ¨ï¼Œå°†ç„¦ç‚¹è½¬ç§»è‡³ä¸‹ä¸€ä¸ªå¯èšç„¦çš„Task if (mayAdjustTop &amp;&amp; ((ActivityStack) task).topRunningActivity(true /* focusableOnly */) == null) &#123; task.adjustFocusToNextFocusableTask(\"finish-top\", false /* allowFocusSelf */, shouldAdjustGlobalFocus); &#125; //å°†Resultä¿¡æ¯å†™å…¥åˆ°å¯¹åº”ActivityRecordä¸­ï¼Œå¾…åé¢resumeçš„æ—¶å€™è§¦å‘onActivityResultå›è°ƒ finishActivityResults(resultCode, resultData, resultGrants); //ç»ˆæ­¢Task final boolean endTask = task.getActivityBelow(this) == null &amp;&amp; !task.isClearingToReuseTask(); final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE; if (isState(RESUMED)) &#123; if (endTask) &#123; //é€šçŸ¥Taskç§»é™¤å·²å¼€å§‹ mAtmService.getTaskChangeNotificationController().notifyTaskRemovalStarted( task.getTaskInfo()); &#125; // Prepare app close transition, but don't execute just yet. It is possible that // an activity that will be made resumed in place of this one will immediately // launch another new activity. In this case current closing transition will be // combined with open transition for the new activity. //å‡†å¤‡Activityè½¬åœºåŠ¨ç”» mDisplayContent.prepareAppTransition(transit, false); // When finishing the activity preemptively take the snapshot before the app window // is marked as hidden and any configuration changes take place //æ›´æ–°Taskå¿«ç…§ if (mAtmService.mWindowManager.mTaskSnapshotController != null) &#123; final ArraySet&lt;Task&gt; tasks = Sets.newArraySet(task); mAtmService.mWindowManager.mTaskSnapshotController.snapshotTasks(tasks); mAtmService.mWindowManager.mTaskSnapshotController .addSkipClosingAppSnapshotTasks(tasks); &#125; // Tell window manager to prepare for this one to be removed. //è®¾ç½®å¯è§æ€§ setVisibility(false); if (stack.mPausingActivity == null) &#123; //å¼€å§‹æš‚åœæ­¤Activity stack.startPausingLocked(false /* userLeaving */, false /* uiSleeping */, null /* resuming */); &#125; if (endTask) &#123; //å±å¹•å›ºå®šåŠŸèƒ½ mAtmService.getLockTaskController().clearLockedTask(task); // This activity was in the top focused stack and this is the last activity in // that task, give this activity a higher layer so it can stay on top before the // closing task transition be executed. //æ›´æ–°çª—å£å±‚çº§ if (mayAdjustTop) &#123; mNeedsZBoost = true; mDisplayContent.assignWindowLayers(false /* setLayoutNeeded */); &#125; &#125; &#125; else if (!isState(PAUSING)) &#123; ... //æ­£å¸¸ä¸ä¼šè¿›å…¥æ­¤case &#125; return FINISH_RESULT_REQUESTED; &#125; finally &#123; //æ¢å¤å¸ƒå±€å·¥ä½œ mAtmService.continueWindowLayout(); &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨ä¸€ä¸‹å¯¹äºResultä¿¡æ¯çš„å¤„ç†ï¼Œè¿™é‡Œè°ƒç”¨äº†finishActivityResultsæ–¹æ³•ï¼Œå°†Resultä¿¡æ¯å†™å…¥åˆ°å¯¹åº”ActivityRecordä¸­ï¼Œå¾…åé¢resumeçš„æ—¶å€™è§¦å‘onActivityResultå›è°ƒ 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Sets the result for activity that started this one, clears the references to activities * started for result from this one, and clears new intents. */private void finishActivityResults(int resultCode, Intent resultData, NeededUriGrants resultGrants) &#123; // Send the result if needed if (resultTo != null) &#123; if (resultTo.mUserId != mUserId) &#123; if (resultData != null) &#123; resultData.prepareToLeaveUser(mUserId); &#125; &#125; if (info.applicationInfo.uid &gt; 0) &#123; mAtmService.mUgmInternal.grantUriPermissionUncheckedFromIntent(resultGrants, resultTo.getUriPermissionsLocked()); &#125; resultTo.addResultLocked(this, resultWho, requestCode, resultCode, resultData); resultTo = null; &#125; // Make sure this HistoryRecord is not holding on to other resources, // because clients have remote IPC references to this object so we // can't assume that will go away and want to avoid circular IPC refs. results = null; pendingResults = null; newIntents = null; setSavedState(null /* savedState */);&#125;//å°†Resultç»“æœæ·»åŠ åˆ°resultsåˆ—è¡¨ä¸­void addResultLocked(ActivityRecord from, String resultWho, int requestCode, int resultCode, Intent resultData) &#123; ActivityResult r = new ActivityResult(from, resultWho, requestCode, resultCode, resultData); if (results == null) &#123; results = new ArrayList&lt;ResultInfo&gt;(); &#125; results.add(r);&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯å°†Resultä¿¡æ¯æ·»åŠ åˆ°ActivityRecord.resultsåˆ—è¡¨ä¸­ ç„¶åæˆ‘ä»¬ç»§ç»­æ²¿ç€finishä¸»çº¿é“¾è·¯èµ°ï¼Œåé¢æœ‰ä¸€ä¸ªisStateçš„åˆ¤æ–­ï¼Œæ­£å¸¸æ¥è¯´ï¼ŒActivityRecordçš„stateåº”è¯¥ä¸ºRESUMEDï¼Œå…·ä½“ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥å›é¡¾ä¸€ä¸‹ä¹‹å‰åˆ†æçš„Activityå¯åŠ¨æµç¨‹ï¼Œåœ¨ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•æœ€åï¼Œä¼šè°ƒç”¨ActivityStack.minimalResumeActivityLockedï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œä¼šå°†ActivityRecordçš„stateè®¾ç½®ä¸ºRESUMEDï¼Œç”±äºClientTransactionçš„æ‰§è¡Œæ˜¯é€šè¿‡Handler.sendMessageè¿›è¡Œçš„ï¼Œæ‰€ä»¥æ—©åœ¨Activity onCreateä¹‹å‰ï¼ŒActivityRecordçš„çŠ¶æ€å°±å·²ç»è¢«è®¾ä¸ºäº†RESUMED æ ¹æ®ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬ä¼šèµ°è¿›isState(RESUMED)è¿™ä¸ªcaseä¸­ï¼Œæ¥ç€è°ƒç”¨ActivityStack.startPausingLockedæ–¹æ³•æš‚åœActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * Start pausing the currently resumed activity. It is an error to call this if there * is already an activity being paused or there is no resumed activity. * * @param userLeaving True if this should result in an onUserLeaving to the current activity. * @param uiSleeping True if this is happening with the user interface going to sleep (the * screen turning off). * @param resuming The activity we are currently trying to resume or null if this is not being * called as part of resuming the top activity, so we shouldn't try to instigate * a resume here if not null. * @return Returns true if an activity now is in the PAUSING state, and we are waiting for * it to tell us when it is done. */final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming) &#123; //å·²æœ‰Activityæ­£åœ¨æš‚åœä¸­ if (mPausingActivity != null) &#123; if (!shouldSleepActivities()) &#123; // Avoid recursion among check for sleep and complete pause during sleeping. // Because activity will be paused immediately after resume, just let pause // be completed by the order of activity paused from clients. completePauseLocked(false, resuming); &#125; &#125; //ä¸Šä¸€ä¸ªå·²resumeçš„Activity ActivityRecord prev = mResumedActivity; //æ—¢æ²¡æœ‰å·²resumeçš„Activityï¼Œä¹Ÿæ²¡æœ‰æ­£åœ¨resumeçš„Activity //ä»æ ˆé¡¶æ‰¾ä¸€ä¸ªActivityæ¢å¤ if (prev == null) &#123; if (resuming == null) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return false; &#125; //ä¸èƒ½æš‚åœä¸€ä¸ªæ­£åœ¨resumeçš„Activity if (prev == resuming) &#123; return false; &#125; //è®¾ç½®å„ç§çŠ¶æ€ mPausingActivity = prev; mLastPausedActivity = prev; mLastNoHistoryActivity = prev.isNoHistory() ? prev : null; prev.setState(PAUSING, \"startPausingLocked\"); prev.getTask().touchActiveTime(); clearLaunchTime(prev); //æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ mAtmService.updateCpuStats(); boolean pauseImmediately = false; ... //å½“å‰æµç¨‹ä¸‹pauseImmediatelyå§‹ç»ˆä¸ºfalse if (prev.attachedToProcess()) &#123; try &#123; //è°ƒåº¦Pauseç”Ÿå‘½å‘¨æœŸäº‹åŠ¡ mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(), prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); &#125; catch (Exception e) &#123; // Ignore exception, if process died other code will cleanup. mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; // If we are not going to sleep, we want to ensure the device is // awake until the next activity is started. //è·å–Wakelockï¼Œç¡®ä¿è®¾å¤‡awakeçŠ¶æ€ç›´åˆ°ä¸‹ä¸€ä¸ªActivityå¯åŠ¨ if (!uiSleeping &amp;&amp; !mAtmService.isSleepingOrShuttingDownLocked()) &#123; mStackSupervisor.acquireLaunchWakelock(); &#125; if (mPausingActivity != null) &#123; // Have the window manager pause its key dispatching until the new // activity has started. If we're pausing the activity just because // the screen is being turned off and the UI is sleeping, don't interrupt // key dispatch; the same activity will pick it up again on wakeup. if (!uiSleeping) &#123; //æš‚åœè¾“å…¥äº‹ä»¶åˆ†å‘ prev.pauseKeyDispatchingLocked(); &#125; if (pauseImmediately) &#123; //ä¸ä¼šè¿›å…¥æ­¤case // If the caller said they don't want to wait for the pause, then complete // the pause now. completePauseLocked(false, resuming); return false; &#125; else &#123; //è®¾ç½®è¶…æ—¶ç›‘å¬ï¼ˆ500mså†…æ²¡æœ‰å®Œæˆä¾¿è§†ä¸ºè¶…æ—¶ï¼‰ prev.schedulePauseTimeout(); return true; &#125; &#125; else &#123; // This activity failed to schedule the // pause, so just treat it as being paused now. //æœªèƒ½æˆåŠŸæš‚åœæ­¤Activityï¼Œä»æ ˆé¡¶æ‰¾ä¸€ä¸ªActivityæ¢å¤ if (resuming == null) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return false; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå’ŒActivityå¯åŠ¨æµç¨‹ç±»ä¼¼ï¼Œè¯¥æ–¹æ³•é‡Œé¢è°ƒç”¨äº†ClientLifecycleManager.scheduleTransactionæ–¹æ³•æ¥è°ƒåº¦Activityæš‚åœçš„ç”Ÿå‘½å‘¨æœŸï¼Œå…·ä½“æ˜¯æ€æ ·è°ƒåº¦çš„å¯ä»¥çœ‹æˆ‘ä¹‹å‰çš„æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰ï¼Œé‡Œé¢åˆ†æäº†ClientTransactionäº‹åŠ¡æ˜¯æ€ä¹ˆè¢«è°ƒåº¦æ‰§è¡Œçš„ äº†è§£å®Œåæˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ï¼Œç”Ÿå‘½å‘¨æœŸäº‹åŠ¡çš„æ‰§è¡Œä¹Ÿå°±ç›¸å½“äºåˆ†åˆ«è°ƒç”¨ActivityLifecycleItemçš„preExecuteã€executeã€postExecuteæ–¹æ³•ï¼Œè€ŒPauseActivityItemæ²¡æœ‰é‡å†™preExecuteæ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±ä¾æ¬¡åˆ†æå…¶executeã€postExecuteæ–¹æ³•å°±å¥½äº† 12345public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\");&#125; ClientTransactionHandlerè¿™ä¸ªæˆ‘ä»¬ä¹‹å‰è¯´è¿‡ï¼Œè¿™æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œè¢«ActivityThreadç»§æ‰¿å®ç°ï¼Œæ‰€ä»¥è¿™é‡Œå®é™…ä¸Šå°±æ˜¯è°ƒç”¨ActivityThread.handlePauseActivityæ–¹æ³• handlePauseActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; ... r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(r, finished, reason, pendingActions); // Make sure any pending writes are now committed. //ç¡®ä¿æ‰€æœ‰å…¨å±€ä»»åŠ¡éƒ½è¢«å¤„ç†å®Œæˆ if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; //æ›´æ–°æ ‡è®° mSomeActivitiesChanged = true; &#125;&#125;/** * Pause the activity. * @return Saved instance state for pre-Honeycomb apps if it was saved, &#123;@code null&#125; otherwise. */private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason, PendingTransactionActions pendingActions) &#123; ... //å¼‚å¸¸çŠ¶æ€æ£€æŸ¥ if (finished) &#123; r.activity.mFinished = true; &#125; // Pre-Honeycomb apps always save their state before pausing //æ˜¯å¦éœ€è¦ä¿å­˜çŠ¶æ€ä¿¡æ¯ï¼ˆAndroid 3.0å‰æ— è®ºæ˜¯å¦finishéƒ½ä¼šè§¦å‘ä¿å­˜ï¼‰ final boolean shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb(); if (shouldSaveState) &#123; //å›è°ƒActivityçš„onSaveInstanceStateæ–¹æ³• callActivityOnSaveInstanceState(r); &#125; performPauseActivityIfNeeded(r, reason); ...//å›è°ƒOnActivityPausedListenerï¼Œç›®å‰çœ‹æ¥åªæœ‰NFCéƒ¨åˆ†æœ‰æ³¨å†Œè¿™ä¸ªå›è°ƒ ... //Android 3.0ä¹‹å‰çš„ç‰¹æ®Šå¤„ç† //è¿”å›ä¿å­˜çŠ¶æ€çš„Bundle return shouldSaveState ? r.state : null;&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123; //å·²æš‚åœï¼Œç›´æ¥è¿”å› if (r.paused) &#123; // You are already paused silly... return; &#125; // Always reporting top resumed position loss when pausing an activity. If necessary, it // will be restored in performResumeActivity(). //æŠ¥å‘ŠresumeçŠ¶æ€å˜æ›´ reportTopResumedActivityChanged(r, false /* onTop */, \"pausing\"); try &#123; r.activity.mCalled = false; //å›è°ƒActivityçš„onPauseæ–¹æ³• mInstrumentation.callActivityOnPause(r.activity); if (!r.activity.mCalled) &#123; //å¿…é¡»è¦è°ƒç”¨super.onPauseæ–¹æ³• throw new SuperNotCalledException(\"Activity \" + safeToComponentShortString(r.intent) + \" did not call through to super.onPause()\"); &#125; &#125; catch ... //è®¾ç½®çŠ¶æ€ r.setState(ON_PAUSE);&#125; è¿™ä¸€æ¡è°ƒç”¨é“¾è·¯çœ‹ä¸‹æ¥è¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œå’Œä¹‹å‰æˆ‘ä»¬åˆ†æè¿‡çš„å…¶ä»–ç”Ÿå‘½å‘¨æœŸè°ƒç”¨æ˜¯ä¸€ä¸ªå¥—è·¯ï¼Œè¿™é‡Œæ˜¾ç¤ºè°ƒç”¨äº†callActivityOnSaveInstanceStateæ–¹æ³•ä¿å­˜çŠ¶æ€ä¿¡æ¯ 1234567891011private void callActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; é€šè¿‡Instrumentationè°ƒç”¨Activity.performSaveInstanceStateæ–¹æ³• 1234567891011121314final void performSaveInstanceState(@NonNull Bundle outState) &#123; //åˆ†å‘PreSaveInstanceStateäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPreSaveInstanceStateå›è°ƒ dispatchActivityPreSaveInstanceState(outState); //å›è°ƒonSaveInstanceState onSaveInstanceState(outState); //ä¿å­˜å—ç®¡ç†çš„Dialogçš„çŠ¶æ€ saveManagedDialogs(outState); //å…±äº«å…ƒç´ åŠ¨ç”»ç›¸å…³ mActivityTransitionState.saveState(outState); //ä¿å­˜æƒé™è¯·æ±‚çŠ¶æ€ storeHasCurrentPermissionRequest(outState); //åˆ†å‘PostSaveInstanceStateäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostSaveInstanceStateå›è°ƒ dispatchActivityPostSaveInstanceState(outState);&#125; æœ€ç»ˆå›è°ƒActivity.onSaveInstanceStateæ–¹æ³• 123456789101112131415161718protected void onSaveInstanceState(@NonNull Bundle outState) &#123; //ä¿å­˜çª—å£ä¿¡æ¯ outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); //ä¿å­˜FragmentçŠ¶æ€ Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; //è‡ªåŠ¨å¡«å……ç›¸å…³ if (mAutoFillResetNeeded) &#123; outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); &#125; //åˆ†å‘SaveInstanceStateäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivitySaveInstanceStateå›è°ƒ dispatchActivitySaveInstanceState(outState);&#125; ä¿å­˜çŠ¶æ€çš„æµç¨‹å°±åŸºæœ¬å®Œæˆäº†ï¼Œæˆ‘ä»¬å†å›è¿‡å¤´æ¥çœ‹onPauseçš„è§¦å‘ åœ¨ä¸Šé¢performPauseActivityIfNeededæ–¹æ³•ä¸­æœ‰ä¸€è¡Œä»£ç è°ƒç”¨äº†Instrumentation.callActivityOnPauseæ–¹æ³•ï¼Œé€šè¿‡Instrumentationè°ƒç”¨äº†Activity.performPauseæ–¹æ³• 1234567891011121314151617181920final void performPause() &#123; //åˆ†å‘PrePausedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPrePausedå›è°ƒ dispatchActivityPrePaused(); mDoReportFullyDrawn = false; //FragmentManageråˆ†å‘pauseçŠ¶æ€ mFragments.dispatchPause(); mCalled = false; //å›è°ƒonPause onPause(); mResumed = false; //Target Sdk 9ä»¥ä¸Šï¼ˆAndroid 2.3ï¼‰éœ€è¦ä¿è¯åœ¨onPauseä¸­è°ƒç”¨super.onPauseæ–¹æ³• if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); &#125; //åˆ†å‘PostPausedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostPausedå›è°ƒ dispatchActivityPostPaused();&#125; æ‰§è¡ŒonPauseå›è°ƒ 1234567891011121314151617181920protected void onPause() &#123; //åˆ†å‘Pausedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPausedå›è°ƒ dispatchActivityPaused(); //è‡ªåŠ¨å¡«å……ç›¸å…³ if (mAutoFillResetNeeded) &#123; if (!mAutoFillIgnoreFirstResumePause) &#123; View focus = getCurrentFocus(); if (focus != null &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123; getAutofillManager().notifyViewExited(focus); &#125; &#125; else &#123; // reset after first pause() mAutoFillIgnoreFirstResumePause = false; &#125; &#125; //å†…å®¹æ•è·æœåŠ¡ notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE); //super.onPauseæ ‡æ³¨ä¸ºå·²è¢«æ‰§è¡Œ mCalled = true;&#125; åˆ°æ­¤ä¸ºæ­¢ï¼ŒActivityçš„onPauseç”Ÿå‘½å‘¨æœŸå·²ç»åŸºæœ¬èµ°å®Œäº†ï¼Œæ­¤æ—¶æˆ‘ä»¬å†å›åˆ°PauseActivityItem.postExecuteæ–¹æ³•ä¸­åšä¸€äº›å–„åå¤„ç† 1234567891011121314public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; //mDontReportä¸ºæˆ‘ä»¬ä¹‹å‰obtainæ–¹æ³•ä¸­ä¼ å…¥çš„pauseImmediatelyå‚æ•°ï¼Œå§‹ç»ˆä¸ºfalse if (mDontReport) &#123; return; &#125; try &#123; // TODO(lifecycler): Use interface callback instead of AMS. //è°ƒç”¨ATMS.activityPausedæ–¹æ³• ActivityTaskManager.getService().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; è¿™é‡Œè°ƒç”¨ATMS.activityPausedæ–¹æ³•å›åˆ°system_serverè¿›ç¨‹å¤„ç†Activityæš‚åœåçš„äº‹é¡¹ 1234567891011public final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (mGlobalLock) &#123; //é€šè¿‡ActivityRecord.Tokenè·å–ActivityRecord final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r != null) &#123; r.activityPaused(false); &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; è°ƒç”¨ActivityRecord.activityPausedæ–¹æ³•ç»§ç»­å¤„ç† 123456789101112131415161718192021222324252627282930void activityPaused(boolean timeout) &#123; final ActivityStack stack = getStack(); if (stack != null) &#123; //ç§»é™¤è¶…æ—¶ç›‘å¬ removePauseTimeout(); if (stack.mPausingActivity == this) &#123; //æš‚åœå¸ƒå±€å·¥ä½œ mAtmService.deferWindowLayout(); try &#123; stack.completePauseLocked(true /* resumeNext */, null /* resumingActivity */); &#125; finally &#123; //æ¢å¤å¸ƒå±€å·¥ä½œ mAtmService.continueWindowLayout(); &#125; return; &#125; else &#123; //æš‚åœActivityå¤±è´¥ if (isState(PAUSING)) &#123; setState(PAUSED, \"activityPausedLocked\"); if (finishing) &#123; completeFinishing(\"activityPausedLocked\"); &#125; &#125; &#125; &#125; //æ›´æ–°Activityå¯è§æ€§ mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);&#125; æ­£å¸¸æƒ…å†µä¸‹ä¼šè¿›å…¥åˆ°ActivityStack.completePauseLockedæ–¹æ³•ä¸­ï¼Œä½†åœ¨æš‚åœActivityå¤±è´¥çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå½“å‰çŠ¶æ€ä¸ºPAUSINGï¼Œåˆ™ç›´æ¥å°†å…¶çŠ¶æ€ç½®ä¸ºPAUSEDå·²æš‚åœï¼Œå¦‚æœè¢«æ ‡è®°ä¸ºfinishingï¼Œåˆ™ä¼šè°ƒç”¨ActivityRecord.completeFinishingç»§ç»­finishæµç¨‹ï¼Œè¿™å…¶å®å’Œæ­£å¸¸æƒ…å†µä¸‹çš„è°ƒç”¨é“¾è·¯å·®ä¸å¤šï¼Œå…·ä½“æˆ‘ä»¬å¾€ä¸‹å°±èƒ½çœ‹åˆ° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123; ActivityRecord prev = mPausingActivity; if (prev != null) &#123; prev.setWillCloseOrEnterPip(false); //ä¹‹å‰çš„çŠ¶æ€æ˜¯å¦ä¸ºæ­£åœ¨åœæ­¢ final boolean wasStopping = prev.isState(STOPPING); //è®¾ç½®çŠ¶æ€ä¸ºå·²æš‚åœ prev.setState(PAUSED, \"completePausedLocked\"); if (prev.finishing) &#123; //ç»§ç»­finishæµç¨‹ prev = prev.completeFinishing(\"completePausedLocked\"); &#125; else if (prev.hasProcess()) &#123; //Configurationå‘ç”Ÿå˜åŒ–æ—¶å¯èƒ½ä¼šè®¾ç½®è¿™ä¸ªflag if (prev.deferRelaunchUntilPaused) &#123; // Complete the deferred relaunch that was waiting for pause to complete. //ç­‰å¾…æš‚åœå®Œæˆårelaunch Activity prev.relaunchActivityLocked(prev.preserveWindowOnDeferredRelaunch); &#125; else if (wasStopping) &#123; // We are also stopping, the stop request must have gone soon after the pause. // We can't clobber it, because the stop confirmation will not be handled. // We don't need to schedule another stop, we only need to let it happen. //ä¹‹å‰çš„çŠ¶æ€ä¸ºæ­£åœ¨åœæ­¢ï¼Œå°†çŠ¶æ€ç½®å›å³å¯ prev.setState(STOPPING, \"completePausedLocked\"); &#125; else if (!prev.mVisibleRequested || shouldSleepOrShutDownActivities()) &#123; // Clear out any deferred client hide we might currently have. prev.setDeferHidingClient(false); // If we were visible then resumeTopActivities will release resources before // stopping. //æ·»åŠ åˆ°stopåˆ—è¡¨ä¸­ç­‰å¾…ç©ºé—²æ—¶æ‰§è¡Œstop prev.addToStopping(true /* scheduleIdle */, false /* idleDelayed */, \"completePauseLocked\"); &#125; &#125; else &#123; //Appåœ¨pauseè¿‡ç¨‹ä¸­æ­»äº¡ prev = null; &#125; // It is possible the activity was freezing the screen before it was paused. // In that case go ahead and remove the freeze this activity has on the screen // since it is no longer visible. if (prev != null) &#123; //åœæ­¢å±å¹•å†»ç»“ prev.stopFreezingScreenLocked(true /*force*/); &#125; //Activityæš‚åœå®Œæ¯• mPausingActivity = null; &#125; //æ¢å¤å‰ä¸€ä¸ªé¡¶å±‚Activity if (resumeNext) &#123; final ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack(); if (topStack != null &amp;&amp; !topStack.shouldSleepOrShutDownActivities()) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(topStack, prev, null); &#125; else &#123; checkReadyForSleep(); final ActivityRecord top = topStack != null ? topStack.topRunningActivity() : null; if (top == null || (prev != null &amp;&amp; top != prev)) &#123; // If there are no more activities available to run, do resume anyway to start // something. Also if the top activity on the stack is not the just paused // activity, we need to go ahead and resume it to ensure we complete an // in-flight app switch. mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; &#125; &#125; if (prev != null) &#123; //æ¢å¤æŒ‰é”®åˆ†å‘ prev.resumeKeyDispatchingLocked(); ... //æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ &#125; //æ›´æ–°Activityå¯è§æ€§ mRootWindowContainer.ensureActivitiesVisible(resuming, 0, !PRESERVE_WINDOWS); // Notify when the task stack has changed, but only if visibilities changed (not just // focus). Also if there is an active pinned stack - we always want to notify it about // task stack changes, because its positioning may depend on it. //é€šçŸ¥TaskçŠ¶æ€å‘ç”Ÿå˜åŒ– if (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause || (getDisplayArea() != null &amp;&amp; getDisplayArea().hasPinnedTask())) &#123; mAtmService.getTaskChangeNotificationController().notifyTaskStackChanged(); mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = false; &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œæ— è®ºæš‚åœæˆåŠŸä¸å¦ï¼Œæœ€åéƒ½ä¼šèµ°åˆ°ActivityRecord.completeFinishingæ–¹æ³•ä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Complete activity finish request that was initiated earlier. If the activity is still * pausing we will wait for it to complete its transition. If the activity that should appear in * place of this one is not visible yet - we'll wait for it first. Otherwise - activity can be * destroyed right away. * @param reason Reason for finishing the activity. * @return Flag indicating whether the activity was removed from history. */ActivityRecord completeFinishing(String reason) &#123; ... //çŠ¶æ€æ£€æŸ¥ final boolean isCurrentVisible = mVisibleRequested || isState(PAUSED); if (isCurrentVisible) &#123; ... //æ›´æ–°Activityå¯è§æ€§ &#125; boolean activityRemoved = false; // If this activity is currently visible, and the resumed activity is not yet visible, then // hold off on finishing until the resumed one becomes visible. // The activity that we are finishing may be over the lock screen. In this case, we do not // want to consider activities that cannot be shown on the lock screen as running and should // proceed with finishing the activity if there is no valid next top running activity. // Note that if this finishing activity is floating task, we don't need to wait the // next activity resume and can destroy it directly. // TODO(b/137329632): find the next activity directly underneath this one, not just anywhere final ActivityRecord next = getDisplayArea().topRunningActivity( true /* considerKeyguardState */); // isNextNotYetVisible is to check if the next activity is invisible, or it has been // requested to be invisible but its windows haven't reported as invisible. If so, it // implied that the current finishing activity should be added into stopping list rather // than destroy immediately. final boolean isNextNotYetVisible = next != null &amp;&amp; (!next.nowVisible || !next.mVisibleRequested); //å¦‚æœæ­¤Activityå½“å‰å¯è§ï¼Œè€Œè¦æ¢å¤çš„Activityè¿˜ä¸å¯è§ï¼Œåˆ™æ¨è¿Ÿfinishï¼Œç›´åˆ°è¦æ¢å¤çš„Activityå¯è§ä¸ºæ­¢ if (isCurrentVisible &amp;&amp; isNextNotYetVisible) &#123; // Add this activity to the list of stopping activities. It will be processed and // destroyed when the next activity reports idle. //æ·»åŠ åˆ°stopåˆ—è¡¨ä¸­ç­‰å¾…ç©ºé—²æ—¶æ‰§è¡Œstop addToStopping(false /* scheduleIdle */, false /* idleDelayed */, \"completeFinishing\"); //è®¾ç½®çŠ¶æ€ä¸ºstopä¸­ setState(STOPPING, \"completeFinishing\"); &#125; else if (addToFinishingAndWaitForIdle()) &#123; // We added this activity to the finishing list and something else is becoming resumed. // The activity will complete finishing when the next activity reports idle. No need to // do anything else here. //å°†æ­¤Activityæ·»åŠ åˆ°å¾…finishåˆ—è¡¨ä¸­ï¼Œç­‰å¾…ç©ºé—²æ—¶æ‰§è¡Œfinish &#125; else &#123; // Not waiting for the next one to become visible, and nothing else will be resumed in // place of this activity - requesting destruction right away. //ç«‹åˆ»é”€æ¯æ­¤Activity activityRemoved = destroyIfPossible(reason); &#125; return activityRemoved ? null : this;&#125; å¯¹äºéé”å±çŠ¶æ€ä¸”å½“å‰è¦é”€æ¯çš„Activityåœ¨å‰å°çš„æƒ…å†µä¸‹ï¼Œè¯¥Activityå¯è§è€Œå¾…æ¢å¤çš„Activityå°šä¸å¯è§ï¼Œæ­¤æ—¶ä¼˜å…ˆå®Œæˆå¾…æ¢å¤Activityçš„resumeç”Ÿå‘½å‘¨æœŸï¼Œç­‰åˆ°ä¹‹åç©ºé—²å†å»å¤„ç†å¾…é”€æ¯Activityçš„destroyç”Ÿå‘½å‘¨æœŸ æ‰€ä»¥åœ¨é¢è¯•ä¸­å¸¸é—®çš„Activityä»Bè¿”å›åˆ°Açš„ç”Ÿå‘½å‘¨æœŸé¡ºåºæˆ‘ä»¬ä»è¿™é‡Œå°±å¯ä»¥çœ‹å‡ºæ¥ï¼Œç†è§£åæˆ‘ä»¬å°±ä¸ç”¨å»æ­»è®°ç¡¬èƒŒäº†ï¼š B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory å¯¹äºé”å±çŠ¶æ€æˆ–è€…è¦é”€æ¯çš„Activityä¸åœ¨å‰å°çš„æƒ…å†µä¸‹ï¼Œç”±äºä¸éœ€è¦ç«‹åˆ»æ¢å¤Activityï¼Œæ‰€ä»¥å¯èƒ½ä¼šç›´æ¥å¤„ç†å¾…é”€æ¯Activityçš„destroyç”Ÿå‘½å‘¨æœŸ æˆ‘ä»¬ä»¥ç¬¬ä¸€ç§å½“å‰è¦é”€æ¯çš„Activityåœ¨å‰å°çš„æƒ…å†µåˆ†æï¼Œæ­¤æ—¶ä¼šå°†è¿™ä¸ªActivityæ·»åŠ åˆ°stopåˆ—è¡¨ä¸­ï¼Œå¹¶å°†çŠ¶æ€è®¾ç½®ä¸ºSTOPPINGï¼Œä¹‹åè¿”å›åˆ°ActivityStack.completePauseLockedæ–¹æ³•ä¸­ï¼Œç»§ç»­æ‰§è¡ŒresumeNextå·¥ä½œ åœ¨resumeNextä¸­ä¼šè°ƒç”¨RootWindowContainer.resumeFocusedStacksTopActivitiesæ–¹æ³•æ¢å¤æ ˆé¡¶Activityï¼Œç”±äºè¿™ä¸ªæ–¹æ³•ä¹‹å‰å·²ç»åœ¨Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰ ä¸­åˆ†æè¿‡äº†ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼Œæˆ‘ä»¬è¿˜æ˜¯å°†ç›®å…‰æ”¾åœ¨é”€æ¯æµç¨‹ä¸Š é€šè¿‡ä¹‹å‰çš„æ–‡ç« ï¼Œæˆ‘ä»¬çŸ¥é“æ¢å¤Activityä¼šè°ƒç”¨åˆ°ActivityThread.handleResumeActivityæ–¹æ³•ï¼Œè€Œå½“Activityæ¢å¤å®Œæ¯•åï¼Œæ­¤æ–¹æ³•æœ€åä¸€è¡Œä¼šå‘MessageQueueæ·»åŠ ä¸€ä¸ªIdleHandlerï¼Œå…³äºIdleHandlerè¿™é‡Œå°±ä¸å†ä»‹ç»äº†ï¼Œè¿™æ˜¯æ¯ä½Androidå¼€å‘éƒ½åº”è¯¥äº†è§£çš„ä¸œè¥¿ 1234567public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler());&#125; è¿™é‡Œçš„Idleræ˜¯ActivityThreadçš„ä¸€ä¸ªå†…éƒ¨ç±» 12345678910111213141516171819202122232425262728private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; ... if (a != null) &#123; mNewActivities = null; IActivityTaskManager am = ActivityTaskManager.getService(); ActivityClientRecord prev; //éå†æ•´æ¡ActivityClientRecord.nextIdleé“¾ï¼Œä¾æ¬¡è°ƒç”¨ATMS.activityIdle do &#123; if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; ... return false; &#125;&#125; è¿™é‡Œä¼šéå†æ•´ä¸ªè¿›ç¨‹å†…æ‰€æœ‰çš„ActivityClientRecordï¼Œå¹¶ä¾æ¬¡è°ƒç”¨ATMS.activityIdleæ–¹æ³• 12345678910public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; ... final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r == null) &#123; return; &#125; mStackSupervisor.activityIdleInternal(r, false /* fromTimeout */, false /* processPausingActivities */, config); ...&#125; ä»ActivityRecord.Tokenè·å–åˆ°ActivityRecordï¼Œæ¥ç€è°ƒç”¨ActivityStackSupervisor.activityIdleInternalæ–¹æ³• 1234567void activityIdleInternal(ActivityRecord r, boolean fromTimeout, boolean processPausingActivities, Configuration config) &#123; ... // Atomically retrieve all of the other things to do. processStoppingAndFinishingActivities(r, processPausingActivities, \"idle\"); ...&#125; è¿™é‡Œæˆ‘ä»¬åªéœ€è¦é‡ç‚¹å…³æ³¨processStoppingAndFinishingActivitiesè¿™ä¸€ä¸ªæ–¹æ³•ï¼Œä»æ–¹æ³•åæˆ‘ä»¬ä¹Ÿèƒ½çœ‹å‡ºæ¥ï¼Œå®ƒæ˜¯ç”¨æ¥å¤„ç†Activity stopæˆ–destroyçš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Processes the activities to be stopped or destroyed. This should be called when the resumed * activities are idle or drawn. */private void processStoppingAndFinishingActivities(ActivityRecord launchedActivity, boolean processPausingActivities, String reason) &#123; // Stop any activities that are scheduled to do so but have been waiting for the transition // animation to finish. ArrayList&lt;ActivityRecord&gt; readyToStopActivities = null; for (int i = mStoppingActivities.size() - 1; i &gt;= 0; --i) &#123; final ActivityRecord s = mStoppingActivities.get(i); final boolean animating = s.isAnimating(TRANSITION | PARENTS, ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS); //ä¸åœ¨åŠ¨ç”»ä¸­æˆ–è€…ATMSæœåŠ¡æ­£åœ¨å…³é—­ if (!animating || mService.mShuttingDown) &#123; //è·³è¿‡æ­£åœ¨pauseçš„Activitiy if (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123; // Defer processing pausing activities in this iteration and reschedule // a delayed idle to reprocess it again removeIdleTimeoutForActivity(launchedActivity); scheduleIdleTimeout(launchedActivity); continue; &#125; if (readyToStopActivities == null) &#123; readyToStopActivities = new ArrayList&lt;&gt;(); &#125; //å°†å‡†å¤‡å¥½stopçš„ActivitiyåŠ å…¥åˆ—è¡¨ä¸­ readyToStopActivities.add(s); mStoppingActivities.remove(i); &#125; &#125; final int numReadyStops = readyToStopActivities == null ? 0 : readyToStopActivities.size(); for (int i = 0; i &lt; numReadyStops; i++) &#123; final ActivityRecord r = readyToStopActivities.get(i); //Activityæ˜¯å¦åœ¨ä»»åŠ¡æ ˆä¸­ if (r.isInHistory()) &#123; if (r.finishing) &#123; // TODO(b/137329632): Wait for idle of the right activity, not just any. //è¢«æ ‡è®°ä¸ºfinishingï¼Œå°è¯•é”€æ¯Activity r.destroyIfPossible(reason); &#125; else &#123; //å¦åˆ™ä»…ä»…åªæ˜¯stop Activity r.stopIfPossible(); &#125; &#125; &#125; final int numFinishingActivities = mFinishingActivities.size(); if (numFinishingActivities == 0) &#123; return; &#125; // Finish any activities that are scheduled to do so but have been waiting for the next one // to start. final ArrayList&lt;ActivityRecord&gt; finishingActivities = new ArrayList&lt;&gt;(mFinishingActivities); mFinishingActivities.clear(); for (int i = 0; i &lt; numFinishingActivities; i++) &#123; final ActivityRecord r = finishingActivities.get(i); if (r.isInHistory()) &#123; //ç«‹åˆ»æ‰§è¡ŒActivityçš„é”€æ¯æµç¨‹ r.destroyImmediately(true /* removeFromApp */, \"finish-\" + reason); &#125; &#125;&#125; å¯¹äºè¢«æ ‡è®°ä¸ºfinishingçš„Activityï¼Œè°ƒç”¨destroyIfPossibleæ–¹æ³•é”€æ¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Destroy and cleanup the activity both on client and server if possible. If activity is the * last one left on display with home stack and there is no other running activity - delay * destroying it until the next one starts. */boolean destroyIfPossible(String reason) &#123; //è®¾ç½®çŠ¶æ€ setState(FINISHING, \"destroyIfPossible\"); // Make sure the record is cleaned out of other places. //ç¡®ä¿æ­¤Activityå·²ä»å¾…stopåˆ—è¡¨ä¸­ç§»é™¤ mStackSupervisor.mStoppingActivities.remove(this); final ActivityStack stack = getRootTask(); final TaskDisplayArea taskDisplayArea = getDisplayArea(); final ActivityRecord next = taskDisplayArea.topRunningActivity(); final boolean isLastStackOverEmptyHome = next == null &amp;&amp; stack.isFocusedStackOnDisplay() &amp;&amp; taskDisplayArea.getOrCreateRootHomeTask() != null; if (isLastStackOverEmptyHome) &#123; // Don't destroy activity immediately if this is the last activity on the display and // the display contains home stack. Although there is no next activity at the moment, // another home activity should be started later. Keep this activity alive until next // home activity is resumed. This way the user won't see a temporary black screen. //å¦‚æœHomeæ ˆå­˜åœ¨ä¸”è¿™æ˜¯å½“å‰ç„¦ç‚¹æ ˆä¸­æœ€åä¸€ä¸ªActivityï¼Œåˆ™ä¸è¦ç«‹å³é”€æ¯å®ƒ //å°†æ­¤Activityæ·»åŠ åˆ°å¾…finishåˆ—è¡¨ä¸­ï¼Œç­‰å¾…ç©ºé—²æ—¶æ‰§è¡Œfinish addToFinishingAndWaitForIdle(); return false; &#125; //è®¾ç½®finishingæ ‡è®°ï¼ˆä¹‹å‰è®¾è¿‡äº†ï¼Œè¿™é‡Œæ˜¯é‡å¤è®¾ç½®ï¼‰ makeFinishingLocked(); //ç«‹åˆ»æ‰§è¡ŒActivityçš„é”€æ¯æµç¨‹ final boolean activityRemoved = destroyImmediately(true /* removeFromApp */, \"finish-imm:\" + reason); // If the display does not have running activity, the configuration may need to be // updated for restoring original orientation of the display. //æ›´æ–°å¯è§æ€§å’Œå±å¹•æ˜¾ç¤ºæ–¹å‘ if (next == null) &#123; mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(), false /* markFrozenIfConfigChanged */, true /* deferResume */); &#125; //æ›´æ–°æ¢å¤æ ˆé¡¶Activity if (activityRemoved) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return activityRemoved;&#125; è¿™é‡Œåšäº†æœ€åçš„ä¸€äº›åˆ¤æ–­ï¼Œç„¶åè°ƒç”¨destroyImmediatelyæ–¹æ³•ï¼Œç«‹åˆ»æ‰§è¡ŒActivityçš„é”€æ¯æµç¨‹ï¼ˆè¿™é‡Œå’Œä¸Šä¸€ä¸ªæ–¹æ³•processStoppingAndFinishingActivitiesä¸­ï¼Œå¾…finishåˆ—è¡¨çš„å¤„ç†æ˜¯ä¸€æ ·çš„ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Destroy the current CLIENT SIDE instance of an activity. This may be called both when * actually finishing an activity, or when performing a configuration switch where we destroy * the current client-side object but then create a new client-side object for this same * HistoryRecord. * Normally the server-side record will be removed when the client reports back after * destruction. If, however, at this point there is no client process attached, the record will * be removed immediately. * * @return &#123;@code true&#125; if activity was immediately removed from history, &#123;@code false&#125; * otherwise. */boolean destroyImmediately(boolean removeFromApp, String reason) &#123; //å·²ç»è¢«é”€æ¯æˆ–æ­£åœ¨è¢«é”€æ¯ï¼Œç›´æ¥è¿”å› if (isState(DESTROYING, DESTROYED)) &#123; return false; &#125; boolean removedFromHistory = false; //æ¸…ç†å·¥ä½œ cleanUp(false /* cleanServices */, false /* setState */); if (hasProcess()) &#123; //æ¸…ç†æ›´æ–°å·¥ä½œ if (removeFromApp) &#123; app.removeActivity(this); if (!app.hasActivities()) &#123; mAtmService.clearHeavyWeightProcessIfEquals(app); // Update any services we are bound to that might care about whether // their client may have activities. // No longer have activities, so update LRU list and oom adj. //æ›´æ–°è¿›ç¨‹ä¿¡æ¯ app.updateProcessInfo(true /* updateServiceConnectionActivities */, false /* activityChange */, true /* updateOomAdj */, false /* addPendingTopUid */); &#125; &#125; boolean skipDestroy = false; try &#123; //è°ƒåº¦é”€æ¯ç”Ÿå‘½å‘¨æœŸäº‹åŠ¡ mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken, DestroyActivityItem.obtain(finishing, configChangeFlags)); &#125; catch (Exception e) &#123; // We can just ignore exceptions here... if the process has crashed, our death // notification will clean things up. if (finishing) &#123; //ä»å†å²ä»»åŠ¡ä¸­ç§»é™¤ removeFromHistory(reason + \" exceptionInScheduleDestroy\"); removedFromHistory = true; skipDestroy = true; &#125; &#125; nowVisible = false; // If the activity is finishing, we need to wait on removing it from the list to give it // a chance to do its cleanup. During that time it may make calls back with its token // so we need to be able to find it on the list and so we don't want to remove it from // the list yet. Otherwise, we can just immediately put it in the destroyed state since // we are not removing it from the list. if (finishing &amp;&amp; !skipDestroy) &#123; //è®¾ç½®çŠ¶æ€ setState(DESTROYING, \"destroyActivityLocked. finishing and not skipping destroy\"); //è®¾ç½®é”€æ¯è¶…æ—¶å›è°ƒ mAtmService.mH.postDelayed(mDestroyTimeoutRunnable, DESTROY_TIMEOUT); &#125; else &#123; //è®¾ç½®çŠ¶æ€ setState(DESTROYED, \"destroyActivityLocked. not finishing or skipping destroy\"); app = null; &#125; &#125; else &#123; // Remove this record from the history. if (finishing) &#123; //æ²¡æœ‰ç»‘å®šè¿›ç¨‹ï¼Œä»å†å²ä»»åŠ¡ä¸­ç§»é™¤ removeFromHistory(reason + \" hadNoApp\"); removedFromHistory = true; &#125; else &#123; //æ²¡æœ‰ç»‘å®šè¿›ç¨‹ä¸”ä¸åœ¨finishingä¸­ï¼Œç›´æ¥è®¾ç½®çŠ¶æ€ä¸ºå·²è¢«é”€æ¯ setState(DESTROYED, \"destroyActivityLocked. not finishing and had no app\"); &#125; &#125; configChangeFlags = 0; return removedFromHistory;&#125; scheduleTransactionè¿™ä¸ªæ–¹æ³•åšäº†ä¸€äº›æ¸…ç†å·¥ä½œï¼Œé‡å¤´æˆåœ¨äºè°ƒç”¨äº†ClientLifecycleManager.scheduleTransactionæ–¹æ³•è°ƒåº¦é”€æ¯ç”Ÿå‘½å‘¨æœŸäº‹åŠ¡ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±é‡ç‚¹åˆ†æè¿™ä¸ªäº‹åŠ¡çš„æ‰§è¡Œè·¯å¾„ scheduleTransactionçš„è°ƒç”¨é“¾è·¯æˆ‘ä»¬åœ¨ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰ ä¸­å·²ç»åˆ†æè¿‡äº†ï¼Œè¿™é‡Œæˆ‘å°±ç®€å•çš„æ ‡æ³¨ä¸€ä¸‹æµç¨‹ï¼š ClientLifecycleManager.scheduleTransaction -&gt;ClientTransaction.schedule -&gt;ActivityThread.scheduleTransaction -&gt;ClientTransaction.preExecute -&gt;ActivityLifecycleItem.preExecute-&gt;ActivityThread.sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction) -&gt;TransactionExecutor.execute -&gt;TransactionExecutor.executeCallbacks -&gt;TransactionExecutor.executeLifecycleState -&gt;TransactionExecutor.cycleToPath -&gt;ActivityLifecycleItem.execute -&gt;ActivityLifecycleItem.postExecute è¿™é‡Œçš„é“¾è·¯åŸºæœ¬ä¸Šå’ŒActivityå¯åŠ¨äº‹åŠ¡é“¾è·¯ç›¸å·®æ— å‡ ï¼Œç”šè‡³æ›´çŸ­äº†ï¼ˆActivityé”€æ¯äº‹åŠ¡æ²¡æœ‰æ·»åŠ callbackï¼‰ï¼Œæ‰€ä»¥æ²¡çœ‹è¿‡æˆ‘ä¸Šç¯‡æ–‡ç« çš„å¼ºçƒˆæ¨èå»çœ‹ä¸€ä¸‹ï¼Œè¿™é‡Œæˆ‘å°±ä¸å†åšåˆ†æäº† æˆ‘ä»¬ä»TransactionExecutor.cycleToPathå¼€å§‹ï¼Œä¹‹å‰æˆ‘ä»¬åˆ†æè¿‡ï¼Œæˆ‘ä»¬åœ¨äº‹åŠ¡ä¸­è®¾ç½®çš„ActivityLifecycleItemä»£è¡¨äº†Activityæœ€ç»ˆéœ€è¦åˆ°è¾¾æ‰§è¡Œçš„ç”Ÿå‘½å‘¨æœŸï¼Œè€Œä¸­é—´çš„é‚£äº›è¿‡æ¸¡ç”Ÿå‘½å‘¨æœŸå°±ç”±cycleToPathæ–¹æ³•æ¨è¿›æ‰§è¡Œï¼Œæˆ‘ä»¬ç›®å‰çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ä¸ºON_PAUSEï¼Œè€Œæˆ‘ä»¬çš„ç›®æ ‡ç”Ÿå‘½å‘¨æœŸä¸ºON_DESTROYï¼Œä¸­é—´è¿˜å¤¹ç€ä¸€ä¸ªON_STOPï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•ä¼šå¸®æˆ‘ä»¬æ‰§è¡ŒClientTransactionHandler.handleStopActivityæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯ActivityThread.handleStopActivityæ–¹æ³• handleStopActivity1234567891011121314151617181920212223242526public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest /* false */, String reason) &#123; final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); //æ‰§è¡ŒonStopç”Ÿå‘½å‘¨æœŸ performStopActivityInner(r, stopInfo, true /* saveState */, finalStateRequest, reason); //æ›´æ–°å¯è§æ€§ updateVisibility(r, false); // Make sure any pending writes are now committed. //ç¡®ä¿æ‰€æœ‰å…¨å±€ä»»åŠ¡éƒ½è¢«å¤„ç†å®Œæˆ if (!r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; //è®°å½•Stopä¿¡æ¯ï¼ˆä¸è¿‡åœ¨åç»­é”€æ¯é“¾è·¯ä¸­ä¼¼ä¹å¹¶æ²¡æœ‰è¢«ç”¨åˆ°ï¼‰ stopInfo.setActivity(r); stopInfo.setState(r.state); stopInfo.setPersistentState(r.persistentState); pendingActions.setStopInfo(stopInfo); mSomeActivitiesChanged = true;&#125; æ¥ä¸‹æ¥çš„è·¯å¾„å°±å’Œå…¶ä»–ç”Ÿå‘½å‘¨æœŸå·®ä¸å¤šäº†ï¼Œå¤§éƒ¨åˆ†å†…å®¹æˆ‘éƒ½ç”¨æ³¨é‡Šæ ‡æ³¨äº†ï¼Œå¤§å®¶é¡ºç€å¾€ä¸‹çœ‹å°±è¡Œäº† 123456789101112131415161718192021222324/** * Core implementation of stopping an activity. * @param r Target activity client record. * @param info Action that will report activity stop to server. * @param saveState Flag indicating whether the activity state should be saved. * @param finalStateRequest Flag indicating if this call is handling final lifecycle state * request for a transaction. * @param reason Reason for performing this operation. */private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean saveState, boolean finalStateRequest /* false */, String reason) &#123; if (r != null) &#123; ... //å¼‚å¸¸çŠ¶æ€å¤„ç† // One must first be paused before stopped... //å¦‚æœæ²¡æœ‰è¢«æš‚åœåˆ™å…ˆæ‰§è¡Œpauseç”Ÿå‘½å‘¨æœŸ performPauseActivityIfNeeded(r, reason); ... //è®¾ç½®æè¿°ï¼ˆActivity.onCreateDescriptionï¼‰ //å›è°ƒActivityçš„onStopæ–¹æ³• callActivityOnStop(r, saveState, reason); &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Calls &#123;@link Activity#onStop()&#125; and &#123;@link Activity#onSaveInstanceState(Bundle)&#125;, and updates * the client record's state. * All calls to stop an activity must be done through this method to make sure that * &#123;@link Activity#onSaveInstanceState(Bundle)&#125; is also executed in the same call. */private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) &#123; // Before P onSaveInstanceState was called before onStop, starting with P it's // called after. Before Honeycomb state was always saved before onPause. //è¿™é‡ŒshouldSaveStateä¸ºtrueï¼Œå› ä¸ºactivity.mFinishedæ—©åœ¨performPauseActivityçš„æ—¶å€™å°±è¢«è®¾ä¸ºäº†true final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null &amp;&amp; !r.isPreHoneycomb(); //targetSdkVersionä¸ºAndroid P (Android 9)ä¹‹å‰ final boolean isPreP = r.isPreP(); if (shouldSaveState &amp;&amp; isPreP) &#123; callActivityOnSaveInstanceState(r); &#125; try &#123; //æ‰§è¡Œstopç”Ÿå‘½å‘¨æœŸ r.activity.performStop(r.mPreserveWindow, reason); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; //è®¾ç½®ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ r.setState(ON_STOP); if (shouldSaveState &amp;&amp; !isPreP) &#123; callActivityOnSaveInstanceState(r); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final void performStop(boolean preserveWindow, String reason) &#123; mDoReportFullyDrawn = false; //Loaderç›¸å…³ï¼Œè¯¦è§https://developer.android.com/guide/components/loaders mFragments.doLoaderStop(mChangingConfigurations /*retain*/); // Disallow entering picture-in-picture after the activity has been stopped //stopåç¦ç”¨ç”»ä¸­ç”» mCanEnterPictureInPicture = false; if (!mStopped) &#123; //åˆ†å‘PreStoppedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPreStoppedå›è°ƒ dispatchActivityPreStopped(); //å…³é—­æ‰€æœ‰å­çª—å£ if (mWindow != null) &#123; mWindow.closeAllPanels(); &#125; // If we're preserving the window, don't setStoppedState to true, since we // need the window started immediately again. Stopping the window will // destroys hardware resources and causes flicker. if (!preserveWindow &amp;&amp; mToken != null &amp;&amp; mParent == null) &#123; //è®¾ç½®åœæ­¢çŠ¶æ€ï¼Œé‡Šæ”¾ç¡¬ä»¶èµ„æºï¼Œé”€æ¯Surface WindowManagerGlobal.getInstance().setStoppedState(mToken, true); &#125; //FragmentManageråˆ†å‘stopçŠ¶æ€ mFragments.dispatchStop(); mCalled = false; //æ‰§è¡ŒonStopå›è°ƒ mInstrumentation.callActivityOnStop(this); EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason); if (!mCalled) &#123; //å¿…é¡»è¦è°ƒç”¨super.onStopæ–¹æ³• throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onStop()\"); &#125; //é‡Šæ”¾Cursors synchronized (mManagedCursors) &#123; final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) &#123; ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) &#123; mc.mCursor.deactivate(); mc.mReleased = true; &#125; &#125; &#125; mStopped = true; //åˆ†å‘PostStoppedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostStoppedå›è°ƒ dispatchActivityPostStopped(); &#125; mResumed = false;&#125; é€šè¿‡Instrumentationæ‰§è¡ŒonStopå›è°ƒ 123456789101112131415protected void onStop() &#123; //ActionBaråŠ¨ç”» if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(false); //å…±äº«å…ƒç´ åŠ¨ç”» mActivityTransitionState.onStop(); //åˆ†å‘PostStoppedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostStoppedå›è°ƒ dispatchActivityStopped(); mTranslucentCallback = null; //super.onStopæ ‡æ³¨ä¸ºå·²è¢«æ‰§è¡Œ mCalled = true; ... //è‡ªåŠ¨å¡«å……ç›¸å…³ mEnterAnimationComplete = false;&#125; è¿™æ ·ï¼Œä¸€æ•´ä¸ªonStopç”Ÿå‘½å‘¨æœŸå°±æ‰§è¡Œå®Œæˆäº†ï¼Œæœ€åè¿˜å‰©ä¸‹ä¸ªonDestroyï¼Œæ ¹æ®ä¹‹å‰å†™çš„äº‹åŠ¡è°ƒåº¦é“¾è·¯ï¼Œç°åœ¨åº”è¯¥èµ°åˆ°äº†DestroyActivityItem.executeæ–¹æ³• 12345public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handleDestroyActivity(token, mFinished, mConfigChanges, false /* getNonConfigInstance */, \"DestroyActivityItem\");&#125; å¯ä»¥çœ‹åˆ°ï¼Œå®é™…ä¸Šå°±ç›´æ¥è°ƒç”¨äº†ActivityThread.handleDestroyActivityæ–¹æ³• handleDestroyActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; //æ‰§è¡ŒonDestroyç”Ÿå‘½å‘¨æœŸ ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance, reason); if (r != null) &#123; //æ¸…ç†ä¹‹å‰è®¾ç½®çš„å»¶æ—¶ç§»é™¤çš„window cleanUpPendingRemoveWindows(r, finishing); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) &#123; if (r.activity.mVisibleFromServer) &#123; mNumVisibleActivities--; &#125; IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) &#123; if (r.mPreserveWindow) &#123; // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = r.window; r.mPendingRemoveWindowManager = wm; // We can only keep the part of the view hierarchy that we control, // everything else must be removed, because it might not be able to // behave properly when activity is relaunching. //ä»DecorViewä¸­ç§»é™¤ContentView r.window.clearContentView(); &#125; else &#123; //ç«‹åˆ»æ‰§è¡ŒViewçš„ç§»é™¤æ“ä½œï¼Œé‡Šæ”¾ç¡¬ä»¶èµ„æºï¼Œé”€æ¯Surfaceï¼Œå›è°ƒView.onDetachedFromWindow wm.removeViewImmediate(v); &#125; &#125; if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) &#123; //ç§»é™¤æŒ‡å®šWindowä¸‹çš„æ‰€æœ‰rootView WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), \"Activity\"); &#125; else if (r.mPendingRemoveWindow != null) &#123; // We're preserving only one window, others should be closed so app views // will be detached before the final tear down. It should be done now because // some components (e.g. WebView) rely on detach callbacks to perform receiver // unregister and other cleanup. //ç§»é™¤æŒ‡å®šWindowä¸‹é™¤äº†å½“å‰DecorViewä»¥å¤–çš„æ‰€æœ‰rootView WindowManagerGlobal.getInstance().closeAllExceptView(token, v, r.activity.getClass().getName(), \"Activity\"); &#125; r.activity.mDecor = null; &#125; if (r.mPendingRemoveWindow == null) &#123; // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), \"Activity\"); &#125; // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. //æ¸…ç†Context Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) &#123; ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), \"Activity\"); &#125; &#125; if (finishing) &#123; try &#123; //å¤„ç†ä¸€äº›é”€æ¯åçš„äº‹é¡¹ï¼Œç§»é™¤è¶…æ—¶å›è°ƒç­‰ ActivityTaskManager.getService().activityDestroyed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true;&#125; Windowè¿™å—çš„å¤„ç†æˆ‘ç›®å‰ä¹Ÿä¸å¤ªäº†è§£ï¼Œç­‰ä»¥åæˆ‘å­¦ä¹ äº†WMSé‚£å—å†è¡¥å§ å…¶ä»–çš„å’Œä¹‹å‰çš„å¥—è·¯ä¸€æ ·ï¼Œè°ƒç”¨performDestroyActivityæ–¹æ³•æ‰§è¡Œé”€æ¯Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** Core implementation of activity destroy call. */ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; ActivityClientRecord r = mActivities.get(token); Class&lt;? extends Activity&gt; activityClass = null; if (r != null) &#123; activityClass = r.activity.getClass(); r.activity.mConfigChangeFlags |= configChanges; if (finishing) &#123; r.activity.mFinished = true; &#125; //å¦‚æœæ²¡æœ‰è¢«æš‚åœåˆ™å…ˆæ‰§è¡Œpauseç”Ÿå‘½å‘¨æœŸ performPauseActivityIfNeeded(r, \"destroy\"); //å¦‚æœæ²¡æœ‰è¢«åœèŒåˆ™å…ˆæ‰§è¡Œstopç”Ÿå‘½å‘¨æœŸ if (!r.stopped) &#123; callActivityOnStop(r, false /* saveState */, \"destroy\"); &#125; if (getNonConfigInstance) &#123; ... //getNonConfigInstanceä¸ºfalseï¼Œè¿™é‡Œä¸æ‰§è¡Œ &#125; try &#123; r.activity.mCalled = false; //æ‰§è¡ŒonDestroyå›è°ƒ mInstrumentation.callActivityOnDestroy(r.activity); //å¿…é¡»è¦è°ƒç”¨super.onDestroyæ–¹æ³• if (!r.activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + safeToComponentShortString(r.intent) + \" did not call through to super.onDestroy()\"); &#125; //å…³é—­æ‰€æœ‰å­çª—å£ if (r.window != null) &#123; r.window.closeAllPanels(); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; //è®¾ç½®ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ r.setState(ON_DESTROY); &#125; //ç©ºé—²æ—¶æ¸…ç†èµ„æº schedulePurgeIdler(); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. synchronized (mResourcesManager) &#123; mActivities.remove(token); &#125; //ä¸¥æ ¼æ¨¡å¼æ›´æ–°Activityè®¡æ•°å™¨ï¼Œä¸å®é™…Activityæ•°é‡å¯¹æ¯”ï¼Œåˆ¤æ–­æ˜¯å¦äº§ç”Ÿå†…å­˜æ³„æ¼ StrictMode.decrementExpectedActivityCount(activityClass); return r;&#125; é€šè¿‡Instrumentationè°ƒç”¨Activity.performDestroyæ–¹æ³• 12345678910111213141516final void performDestroy() &#123; //åˆ†å‘PreDestroyedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPreDestroyedå›è°ƒ dispatchActivityPreDestroyed(); mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); EventLogTags.writeWmOnDestroyCalled(mIdent, getComponentName().getClassName(), \"performDestroy\"); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) &#123; mVoiceInteractor.detachActivity(); &#125; //åˆ†å‘PostDestroyedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostDestroyedå›è°ƒ dispatchActivityPostDestroyed();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected void onDestroy() &#123; //super.onDestroyæ ‡æ³¨ä¸ºå·²è¢«æ‰§è¡Œ mCalled = true; ... //è‡ªåŠ¨å¡«å……ç›¸å…³ // dismiss any dialogs we are managing. //å…³é—­æ‰€æœ‰è¢«ç®¡ç†çš„Dialog if (mManagedDialogs != null) &#123; final int numDialogs = mManagedDialogs.size(); for (int i = 0; i &lt; numDialogs; i++) &#123; final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) &#123; md.mDialog.dismiss(); &#125; &#125; mManagedDialogs = null; &#125; // close any cursors we are managing. //å…³é—­æ‰€æœ‰è¢«ç®¡ç†çš„Cursor synchronized (mManagedCursors) &#123; int numCursors = mManagedCursors.size(); for (int i = 0; i &lt; numCursors; i++) &#123; ManagedCursor c = mManagedCursors.get(i); if (c != null) &#123; c.mCursor.close(); &#125; &#125; mManagedCursors.clear(); &#125; // Close any open search dialog //å…³é—­ç³»ç»Ÿæœç´¢æœåŠ¡çš„å¼¹çª— if (mSearchManager != null) &#123; mSearchManager.stopSearch(); &#125; if (mActionBar != null) &#123; mActionBar.onDestroy(); &#125; //åˆ†å‘Destroyedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityDestroyedå›è°ƒ dispatchActivityDestroyed(); //å†…å®¹æ•è·æœåŠ¡ notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);&#125; DestroyActivityItemæ²¡æœ‰é‡å†™postExecuteæ–¹æ³•ï¼Œæ‰€ä»¥åˆ°æ­¤ä¸ºæ­¢ï¼ŒActivityæ•´ä¸ªé”€æ¯æµç¨‹å°±ç»“æŸäº† Tipsæˆ‘ä»¬é€šè¿‡æœ¬ç¯‡æ–‡ç« çš„åˆ†æï¼Œå¯ä»¥å‘ç°ï¼Œè§¦å‘Activityé”€æ¯åï¼ŒonStopå’ŒonDestroyè¿™ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸå›è°ƒçš„è§¦å‘æ—¶æœºæ˜¯ä¸ç¡®å®šçš„ï¼Œå¦‚æœæœ‰éœ€æ±‚éœ€è¦åœ¨ç¡®å®šActivityè¦è¢«é”€æ¯åç«‹åˆ»æ‰§è¡Œï¼Œæˆ‘ä»¬å¯ä»¥åœ¨onPauseå›è°ƒä¸­è°ƒç”¨Activity.isFinishingæ–¹æ³•åˆ¤æ–­mFinishedæ ‡å¿—æ˜¯å¦è¢«ç½®trueï¼Œå¦‚æœä¸ºtrueåˆ™å¯ä»¥åˆ¤å®šè¿™ä¸ªActivityå°†è¢«é”€æ¯ ç»“å°¾è‡³æ­¤ï¼ŒActivityçš„å¯åŠ¨æµç¨‹å’Œé”€æ¯æµç¨‹æˆ‘ä»¬éƒ½åˆ†æå®Œäº†ï¼Œåé¢åº”è¯¥æš‚æ—¶ä¸ä¼šå†å†™Activityç›¸å…³çš„æºç åˆ†æäº† ä¹‹åçš„ä¸€æ®µæ—¶é—´ï¼Œæˆ‘å¯èƒ½ä¼šå°†æˆ‘çš„ç²¾åŠ›æŠ•å…¥åˆ°AIGCçš„æŠ€æœ¯è°ƒç ”ä¸­ï¼ŒAndroidæºç åˆ†æè¿™ä¸€ç³»åˆ—çš„åç»­æ›´æ–°å¯èƒ½ä¼šæ”¾æ…¢ï¼Œå¸Œæœ›å¤§å®¶å¤šå¤šè°…è§£","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityTaskManagerService","slug":"Android/ActivityTaskManagerService","permalink":"http://yoursite.com/categories/Android/ActivityTaskManagerService/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityTaskManagerService","slug":"ActivityTaskManagerService","permalink":"http://yoursite.com/tags/ActivityTaskManagerService/"}]},{"title":"WSLç¼–è¯‘AOSPå¿…è¦çš„å‡ ä¸ªå‰ç½®å·¥ä½œ","slug":"android/aosp/WSLç¼–è¯‘AOSPå¿…è¦çš„å‡ ä¸ªå‰ç½®å·¥ä½œ","date":"2023-02-06T03:13:31.000Z","updated":"2023-06-19T14:07:02.874Z","comments":true,"path":"2023/02/06/android/aosp/WSLç¼–è¯‘AOSPå¿…è¦çš„å‡ ä¸ªå‰ç½®å·¥ä½œ/","link":"","permalink":"http://yoursite.com/2023/02/06/android/aosp/WSL%E7%BC%96%E8%AF%91AOSP%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"å‰è¨€é¦–å…ˆï¼Œå…³äºAOSPçš„ç¼–è¯‘å¯ä»¥æŸ¥çœ‹æˆ‘çš„è¿™ç¯‡æ–‡ç« ï¼šAOSPçš„ç¼–è¯‘åŠåˆ·æœº æˆ‘ä¹‹å‰éƒ½æ˜¯åœ¨MacOSä¸Šæ„å»ºçš„AOSPçš„ï¼Œä½†æ˜¯è‡ª2021å¹´6æœˆ22æ—¥èµ·ï¼ŒAOSPä¸å†æ”¯æŒåœ¨Windowsæˆ–MacOSä¸Šæ„å»ºï¼Œä½†æˆ‘åˆä¸æƒ³ç»™æˆ‘çš„ç”µè„‘å®‰è£…UbuntuåŒç³»ç»Ÿï¼Œåªå¾—å¦å¯»ä»–è·¯ï¼Œåœ¨Windowsä¸Šä½¿ç”¨WSLå°±æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚ å…¶å®ä¹‹å‰æˆ‘å°è¯•è¿‡ç”¨WSLç¼–è¯‘AOSPï¼Œä½†å‡ æ¬¡éƒ½å¤±è´¥äº†ï¼Œè¿™æ¬¡è¿‡å¹´å›å®¶æ½œå¿ƒç ”ç©¶äº†å‡ å¤©ï¼Œæ€»ç®—æ˜¯æˆåŠŸäº†ï¼Œæˆ‘ä¼šå°†æˆ‘ä¹‹å‰å¤±è´¥çš„åŸå› å’Œè¿™æ¬¡æˆåŠŸçš„å¿ƒå¾—æ€»ç»“åˆ†äº«ç»™å¤§å®¶ï¼Œæ•™å¤§å®¶å¦‚ä½•é¿å‘ å…³äºNASæˆ‘æ˜¯å°†æˆ‘çš„AOSPæºç æ”¾åœ¨NASä¸Šè¿›è¡Œç¼–è¯‘çš„ï¼Œæ¯•ç«Ÿç£ç›˜ç©ºé—´å¤Ÿå¤§ï¼Œè€Œä¸”å…±äº«èµ·æ¥ä¹Ÿæ–¹ä¾¿ï¼Œä½†éœ€è¦åƒä¸‡æ³¨æ„ ä¸è¦ä½¿ç”¨SMBåè®®å…±äº«AOSPæºç ç¼–è¯‘ï¼Œè¿™æ ·åšç›´æ¥å°±ä¼šå¡åœ¨æºç syncå®Œåçš„lunché‚£ä¸€æ­¥ï¼Œå¯ä»¥ä½¿ç”¨iSCSIåè®®å°†NASä¸Šçš„ä¸€éƒ¨åˆ†ç£ç›˜ç©ºé—´æ˜ å°„æˆä¸€ä¸ªè™šæ‹Ÿç£ç›˜ï¼Œè¿™æ ·åœ¨Windowsä¸Šå°±å¯ä»¥å°†è¿™å—ç£ç›˜å½“æˆæ™®é€šçš„ç¡¬ç›˜ä½¿ç”¨ï¼Œå‡ ä¹å®Œå…¨æ²¡æœ‰åŒºåˆ« ä¿®æ”¹å¤§å°å†™æ•æ„Ÿåœ¨åŒæ­¥AOSPæºç å‰ä¸€å®šè¦åšçš„å·¥ä½œï¼Œä¸ç„¶ä½ å°±ç­‰ç€æŠŠè¾›è‹¦ä¸‹è½½å¥½çš„æºç åˆ äº†é‡æ–°ä¸‹å§ åœ¨åŒæ­¥AOSPæºç ä¹‹å‰ï¼Œæˆ‘ä»¬ä¼šé¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–°çš„ç›®å½•ç”¨æ¥ä¿å­˜å®ƒï¼Œæˆ‘ä»¬æ–°å»ºå®Œè¿™ä¸ªç›®å½•åï¼Œç”¨ç®¡ç†å‘˜èº«ä»½æ‰“å¼€Windowsçš„Powershellï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 1fsutil.exe file setCaseSensitiveInfo &lt;path&gt; enable å…¶ä¸­çš„pathå°±æ˜¯åˆšæ–°å»ºç”¨æ¥åŒæ­¥AOSPæºç çš„ç›®å½•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªå‘½ä»¤åªå¯¹æŒ‡å®šçš„ç›®å½•æœ‰æ•ˆï¼Œä¸ä¼šæ”¹å˜å·²å­˜åœ¨çš„å­ç›®å½•çš„å¤§å°å†™æ•æ„Ÿï¼Œæ‰€ä»¥åƒä¸‡è¦åœ¨åŒæ­¥ä»£ç ä¹‹å‰åšè¿™ä»¶äº‹ é‡æ–°æŒ‚è½½ç£ç›˜å¦‚æœä½ çš„AOSPæºç æ”¾åœ¨äº†Windowsé©±åŠ¨å™¨ä¸Šï¼Œæ¯”å¦‚è¯´ F:\\aosp ï¼Œåœ¨WSLä¸­çš„è·¯å¾„åº”è¯¥æ˜¯ /mnt/f/aosp è¿™ç§å½¢å¼çš„ï¼Œæ­¤æ—¶éœ€è¦ä»¥drvfsæ–‡ä»¶ç³»ç»Ÿé‡æ–°æŒ‚è½½ç›˜ç¬¦ï¼Œå¦åˆ™ç¼–è¯‘åˆ°ä¸­é€”ä¼šæŠ¥é”™ï¼š 12sudo umount /mnt/fsudo mount -t drvfs F: /mnt/f -o metadata æ³¨æ„ï¼Œæ¯æ¬¡WSLé‡å¯ï¼Œåœ¨ç¼–è¯‘AOSPä¹‹å‰éƒ½éœ€è¦æ‰§è¡Œè¿™æ­¥æ“ä½œï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥å°†å®ƒæ–°å»ºæˆWSLçš„ä¸€ä¸ªå¼€æœºæœåŠ¡ï¼Œç¡®ä¿æ¯æ¬¡æ‰“å¼€WSLéƒ½ä¼šæ‰§è¡Œè¿™ä¸¤æ®µå‘½ä»¤ å°¾å£°å¯ä»¥å‘ç°ï¼Œç”¨WSLç¼–è¯‘å‡ºé”™ä¸»è¦è¿˜æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„é—®é¢˜ï¼Œç»è¿‡ä»¥ä¸Šå‡ æ­¥å‰ç½®å·¥ä½œï¼Œç›¸ä¿¡ä½ ä¸€å®šå¯ä»¥é¡ºåˆ©çš„ç¼–è¯‘AOSP","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"}]},{"title":"å²ä¸Šæœ€å®Œç¾çš„Androidæ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ æ”»ç•¥","slug":"android/common/å²ä¸Šæœ€å®Œç¾çš„Androidæ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ æ”»ç•¥","date":"2023-01-07T12:51:52.000Z","updated":"2023-04-23T13:51:43.890Z","comments":true,"path":"2023/01/07/android/common/å²ä¸Šæœ€å®Œç¾çš„Androidæ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ æ”»ç•¥/","link":"","permalink":"http://yoursite.com/2023/01/07/android/common/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5/","excerpt":"","text":"å‰è¨€æœ€è¿‘æˆ‘åœ¨å°ç ´ç«™å¼€å‘ä¸€æ¬¾æ–°Appï¼Œå«é«˜èƒ½é“¾ã€‚æˆ‘æ˜¯ä¸€ä¸ªå®Œç¾ä¸»ä¹‰è€…ï¼Œæ‰€ä»¥ä¸ç®¡å¯¹æ¶æ„è¿˜æ˜¯UIï¼Œæˆ‘éƒ½æ˜¯æ¯”è¾ƒæŠ ç»†èŠ‚çš„ï¼Œåœ¨çŠ¶æ€æ å’Œå¯¼èˆªæ æ²‰æµ¸å¼è¿™ä¸€å—ï¼Œæˆ‘è¿˜æ˜¯è¸©äº†æŒºå¤šå‘ï¼Œè´¹äº†æŒºå¤šç²¾åŠ›çš„ã€‚è¿™æ¬¡æˆ‘å°†æˆ‘è¸©å‘ï¼Œé€‚é…å„æœºå‹æ€»ç»“å‡ºæ¥çš„å²ä¸Šæœ€å®Œç¾çš„Androidæ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ æ”»ç•¥åˆ†äº«ç»™å¤§å®¶ï¼Œå¤§å®¶ä¹Ÿå¯ä»¥å» é«˜èƒ½é“¾å®˜ç½‘ ä¸‹è½½ä½“éªŒä¸€ä¸‹æˆ‘ä»¬çš„Appï¼Œå®é™…æ„Ÿå—ä¸€ä¸‹æ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ çš„æ•ˆæœï¼ˆç™»å½•ï¼Œå®åç­‰è´¦å·ç›¸å…³é¡µé¢ç”±äºä¸æ˜¯æˆ‘å¼€å‘çš„ï¼Œå°±æ²¡æœ‰é€‚é…æ²‰æµ¸å¼å¯¼èˆªæ å•¦ï¼Œå˜»å˜»ï¼‰ æ³¨ï¼šæ­¤æ”»ç•¥åªé’ˆå¯¹ Android 5.0 åŠä»¥ä¸Šæœºå‹ï¼Œå³ minSdkVersion &gt;= 21 å®é™…æ•ˆæœåœ¨å¼€å§‹æ”»ç•¥ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹å®Œç¾çš„æ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ æ•ˆæœ ä¼ ç»Ÿä¸‰é”®å¼å¯¼èˆªæ  å…¨é¢å±å¯¼èˆªæ¡ ç†è®ºåˆ†æåœ¨ä¸Šå…·ä½“å®ç°ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆåˆ†æä¸€ä¸‹ï¼Œå®ç°æ²‰æµ¸å¼çŠ¶æ€å¯¼èˆªæ éœ€è¦å‡ æ­¥ çŠ¶æ€æ å¯¼èˆªæ åº•è‰²é€æ˜ æ ¹æ®å½“å‰é¡µé¢çš„èƒŒæ™¯è‰²ï¼Œç»™çŠ¶æ€æ å­—ä½“å’Œå¯¼èˆªæ æŒ‰é’®ï¼ˆæˆ–å¯¼èˆªæ¡ï¼‰è®¾ç½®äº®è‰²æˆ–æš—è‰² çŠ¶æ€æ å¯¼èˆªæ è®¾ç½®é€æ˜åï¼Œæˆ‘ä»¬é¡µé¢çš„å¸ƒå±€ä¼šå»¶ä¼¸åˆ°åŸæœ¬çŠ¶æ€æ å¯¼èˆªæ çš„ä½ç½®ï¼Œè¿™æ—¶å€™éœ€è¦ä¸€äº›æ‰‹æ®µå°†æˆ‘ä»¬éœ€è¦æ˜¾ç¤ºçš„æ­£æ–‡å†…å®¹å›ç¼©åˆ°å…¶æ­£ç¡®çš„æ˜¾ç¤ºèŒƒå›´å†… è¿™é‡Œæˆ‘ç»™å¤§å®¶æä¾›ä»¥ä¸‹å‡ ç§æ€è·¯ï¼Œå¤§å®¶å¯ä»¥æ ¹æ®å®é™…æƒ…å†µè‡ªè¡Œé€‰æ‹©ï¼š è®¾ç½®fitsSystemWindowså±æ€§ æ ¹æ®çŠ¶æ€æ å¯¼èˆªæ çš„é«˜åº¦ï¼Œç»™æ ¹å¸ƒå±€è®¾ç½®ç›¸åº”çš„paddingTopå’ŒpaddingBottom æ ¹æ®çŠ¶æ€æ å¯¼èˆªæ çš„é«˜åº¦ï¼Œç»™éœ€è¦ç§»ä½çš„æ§ä»¶è®¾ç½®ç›¸åº”çš„marginTopå’ŒmarginBottom åœ¨é¡¶éƒ¨å’Œåº•éƒ¨å¢åŠ ä¸¤ä¸ªå ä½çš„Viewï¼Œé«˜åº¦åˆ†åˆ«è®¾ç½®æˆçŠ¶æ€æ å’Œå¯¼èˆªæ çš„é«˜åº¦ é’ˆå¯¹æ»‘åŠ¨è§†å›¾ï¼Œå·§ç”¨clipChildrenå’ŒclipToPaddingå±æ€§ï¼ˆå¯å‚ç…§é«˜èƒ½é“¾è—å“è¯¦æƒ…é¡µæ ·å¼ï¼‰ æ²‰æµ¸å¼çŠ¶æ€æ æ€è·¯è¯´å®Œäº†ï¼Œæˆ‘ä»¬ç°åœ¨å¼€å§‹è¿›å…¥å®æˆ˜ï¼Œæ²‰æµ¸å¼çŠ¶æ€æ æ¯”è¾ƒç®€å•ï¼Œæ²¡ä»€ä¹ˆå‘ çŠ¶æ€æ é€æ˜é¦–å…ˆç¬¬ä¸€æ­¥ï¼Œæˆ‘ä»¬éœ€è¦å°†çŠ¶æ€æ çš„èƒŒæ™¯è®¾ç½®ä¸ºé€æ˜ï¼Œè¿™é‡Œæˆ‘ç›´æ¥æ”¾ä»£ç  123456789101112fun transparentStatusBar(window: Window) &#123; window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE window.decorView.systemUiVisibility = systemUiVisibility window.statusBarColor = Color.TRANSPARENT //è®¾ç½®çŠ¶æ€æ æ–‡å­—é¢œè‰² setStatusBarTextColor(window, NightMode.isNightMode(window.context))&#125; é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å°†FLAG_TRANSLUCENT_STATUSè¿™ä¸ªwindowFlagæ¢æˆFLAG_DRAWS_SYSTEM_BAR_BACKGROUNDSï¼Œå¦åˆ™çŠ¶æ€æ ä¸ä¼šå®Œå…¨é€æ˜ï¼Œä¼šæœ‰ä¸€ä¸ªåŠé€æ˜çš„ç°è‰²è’™å±‚ FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDSè¿™ä¸ªflagè¡¨ç¤ºç³»ç»ŸBarçš„èƒŒæ™¯å°†äº¤ç»™å½“å‰windowç»˜åˆ¶ SYSTEM_UI_FLAG_LAYOUT_FULLSCREENè¿™ä¸ªflagè¡¨ç¤ºActivityå…¨å±æ˜¾ç¤ºï¼Œä½†çŠ¶æ€æ ä¸ä¼šè¢«éšè—ï¼Œä¾ç„¶å¯è§ SYSTEM_UI_FLAG_LAYOUT_STABLEè¿™ä¸ªflagè¡¨ç¤ºä¿æŒæ•´ä¸ªViewç¨³å®šï¼Œä½¿Viewä¸ä¼šå› ä¸ºç³»ç»ŸUIçš„å˜åŒ–è€Œé‡æ–°layout SYSTEM_UI_FLAG_LAYOUT_FULLSCREENå’ŒSYSTEM_UI_FLAG_LAYOUT_STABLEè¿™ä¸¤ä¸ªflagé€šå¸¸æ˜¯ä¸€èµ·ä½¿ç”¨çš„ï¼Œæˆ‘ä»¬è®¾ç½®è¿™ä¸¤ä¸ªflagï¼Œç„¶åå†å°†statusBarColorè®¾ç½®ä¸ºé€æ˜ï¼Œå°±è¾¾æˆäº†çŠ¶æ€æ èƒŒæ™¯é€æ˜çš„æ•ˆæœ çŠ¶æ€æ æ–‡å­—é¢œè‰²æ¥ç€æˆ‘ä»¬å°±è¯¥è®¾ç½®çŠ¶æ€æ æ–‡å­—é¢œè‰²äº†ï¼Œç»†å¿ƒçš„å°ä¼™ä¼´ä»¬åº”è¯¥å·²ç»æ³¨æ„åˆ°äº†ï¼Œæˆ‘åœ¨transparentStatusBaræ–¹æ³•çš„æœ«å°¾åŠ äº†ä¸€ä¸ªsetStatusBarTextColorçš„æ–¹æ³•è°ƒç”¨ï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¦‚æœæ˜¯æ—¥é—´æ¨¡å¼ï¼Œé¡µé¢èƒŒæ™¯é€šå¸¸éƒ½æ˜¯äº®è‰²ï¼Œæ‰€ä»¥æ­¤æ—¶çŠ¶æ€æ æ–‡å­—é¢œè‰²è®¾ç½®ä¸ºé»‘è‰²æ¯”è¾ƒåˆç†ï¼Œè€Œåœ¨å¤œé—´æ¨¡å¼ä¸‹ï¼Œé¡µé¢èƒŒæ™¯é€šå¸¸éƒ½æ˜¯æš—è‰²ï¼Œæ­¤æ—¶çŠ¶æ€æ æ–‡å­—é¢œè‰²è®¾ç½®ä¸ºç™½è‰²æ¯”è¾ƒåˆç†ï¼Œå¯¹åº”ä»£ç å¦‚ä¸‹ 1234567891011fun setStatusBarTextColor(window: Window, light: Boolean) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = if (light) &#123; //ç™½è‰²æ–‡å­— systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() &#125; else &#123; //é»‘è‰²æ–‡å­— systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR &#125; window.decorView.systemUiVisibility = systemUiVisibility &#125;&#125; Android 8.0ä»¥ä¸Šæ‰æ”¯æŒå¯¼èˆªæ æ–‡å­—é¢œè‰²çš„ä¿®æ”¹ï¼ŒSYSTEM_UI_FLAG_LIGHT_STATUS_BARè¿™ä¸ªflagè¡¨ç¤ºäº®è‰²çŠ¶æ€æ ï¼Œå³é»‘è‰²çŠ¶æ€æ æ–‡å­—ï¼Œæ‰€ä»¥å¦‚æœå¸Œæœ›çŠ¶æ€æ æ–‡å­—ä¸ºé»‘è‰²ï¼Œå°±è®¾ç½®è¿™ä¸ªflagï¼Œå¦‚æœå¸Œæœ›çŠ¶æ€æ æ–‡å­—ä¸ºç™½è‰²ï¼Œå°±å°†è¿™ä¸ªflagä»systemUiVisibilityä¸­å‰”é™¤ å¯èƒ½æœ‰å°ä¼™ä¼´ä¸å¤ªäº†è§£kotlinä¸­çš„ä½è¿ç®—ï¼Œkotlinä¸­çš„orã€andã€invåˆ†åˆ«å¯¹åº”ç€æˆ–ã€ä¸ã€å–åè¿ç®— æ‰€ä»¥ 1systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() ç¿»è¯‘æˆjavaå³ä¸º 1systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR åœ¨åŸç”Ÿç³»ç»Ÿä¸Šï¼Œè¿™ä¹ˆè®¾ç½®å°±å¯ä»¥æˆåŠŸè®¾ç½®çŠ¶æ€æ æ–‡å­—é¢œè‰²ï¼Œä½†æˆ‘å‘ç°ï¼Œåœ¨æŸäº›ç³»ç»Ÿä¸Šï¼Œè¿™æ ·è®¾ç½®åçš„æ•ˆæœæ˜¯ä¸å¯é¢„æœŸçš„ï¼Œè­¬å¦‚MIUIç³»ç»Ÿçš„çŠ¶æ€æ æ–‡å­—é¢œè‰²ä¼¼ä¹æ˜¯æ ¹æ®çŠ¶æ€æ èƒŒæ™¯é¢œè‰²è‡ªé€‚åº”çš„ï¼Œä¸”æ—¥é—´æ¨¡å¼å’Œé»‘å¤œæ¨¡å¼ä¸‹çš„è‡ªé€‚åº”ç­–ç•¥è¿˜ç•¥æœ‰ä¸åŒã€‚ä¸è¿‡åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œå®ƒè‡ªé€‚åº”çš„é¢œè‰²éƒ½æ˜¯æ­£å¸¸çš„ï¼Œæˆ‘ä»¬å°±æŒ‰ç…§æˆ‘ä»¬å¸Œæœ›çš„ç»“æœè®¾ç½®å°±å¯ä»¥äº†ã€‚ çŸ«æ­£æ˜¾ç¤ºåŒºåŸŸfitsSystemWindowsçŸ«æ­£çŠ¶æ€æ æ˜¾ç¤ºåŒºåŸŸæœ€ç®€å•çš„åŠæ³•å°±æ˜¯è®¾ç½®fitsSystemWindowså±æ€§ï¼Œè®¾ç½®äº†è¯¥å±æ€§çš„Viewçš„æ‰€æœ‰paddingå±æ€§éƒ½å°†å¤±æ•ˆï¼Œå¹¶ä¸”ç³»ç»Ÿä¼šè‡ªåŠ¨ä¸ºå…¶æ·»åŠ paddingTopï¼ˆè®¾ç½®äº†é€æ˜çŠ¶æ€æ çš„æƒ…å†µä¸‹ï¼‰å’ŒpaddingBottomï¼ˆè®¾ç½®äº†é€æ˜å¯¼èˆªæ çš„æƒ…å†µä¸‹ï¼‰ æˆ‘ä¸ªäººæ˜¯ä¸ç”¨è¿™ç§æ–¹å¼çš„ï¼Œé¦–å…ˆå®ƒä¼šè¦†ç›–ä½ è®¾ç½®çš„paddingï¼Œå…¶æ¬¡ï¼Œå¦‚æœä½ åŒæ—¶è®¾ç½®äº†é€æ˜çŠ¶æ€æ å’Œé€æ˜å¯¼èˆªæ ï¼Œè¿™ä¸ªå±æ€§æ²¡æœ‰åŠæ³•åˆ†å¼€æ¥å¤„ç†ï¼Œå¾ˆä¸çµæ´» è·å–çŠ¶æ€æ é«˜åº¦é™¤äº†fitsSystemWindowsè¿™ç§æ–¹æ³•å¤–ï¼Œå…¶ä»–çš„æ–¹æ³•éƒ½å¾—ä¾é è·å–çŠ¶æ€æ é«˜åº¦äº†ï¼Œè¿™é‡Œç›´æ¥ä¸Šä»£ç  123456fun getStatusBarHeight(context: Context): Int &#123; val resId = context.resources.getIdentifier( \"status_bar_height\", \"dimen\", \"android\" ) return context.resources.getDimensionPixelSize(resId)&#125; çŠ¶æ€æ ä¸åƒå¯¼èˆªæ é‚£æ ·å¤šå˜ï¼Œæ‰€ä»¥ç›´æ¥è¿™æ ·è·å–é«˜åº¦å°±å¯ä»¥äº†ï¼Œå¯¼èˆªæ çš„é«˜åº¦é£˜å¿½ä¸å®šæ‰æ˜¯çœŸæ­£çš„å™©æ¢¦ è¿™é‡Œå†ç»™ä¸¤ä¸ªè®¾ç½®View marginæˆ–paddingçš„å·¥å…·æ–¹æ³•å§ï¼Œå¸®åŠ©å¤§å®¶å¿«é€Ÿä½¿ç”¨ 1234567891011121314151617fun fixStatusBarMargin(vararg views: View) &#123; views.forEach &#123; view -&gt; (view.layoutParams as? ViewGroup.MarginLayoutParams)?.let &#123; lp -&gt; lp.topMargin = lp.topMargin + getStatusBarHeight(view.context) view.requestLayout() &#125; &#125;&#125;fun paddingByStatusBar(view: View) &#123; view.setPadding( view.paddingLeft, view.paddingTop + getStatusBarHeight(view.context), view.paddingRight, view.paddingBottom )&#125; æ²‰æµ¸å¼å¯¼èˆªæ æ²‰æµ¸å¼å¯¼èˆªæ ç›¸æ¯”æ²‰æµ¸å¼çŠ¶æ€æ å‘ä¼šå¤šå¾ˆå¤šï¼Œå…·ä½“åŸå› æˆ‘ä»¬åé¢å†è¯´ å¯¼èˆªæ é€æ˜å’Œæ²‰æµ¸å¼çŠ¶æ€æ ä¸€æ ·ï¼Œç¬¬ä¸€æ­¥æˆ‘ä»¬éœ€è¦å°†å¯¼èˆªæ çš„èƒŒæ™¯è®¾ç½®ä¸ºé€æ˜ 123456789101112131415fun transparentNavigationBar(window: Window) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123; window.isNavigationBarContrastEnforced = false &#125; window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION window.decorView.systemUiVisibility = systemUiVisibility window.navigationBarColor = Color.TRANSPARENT //è®¾ç½®å¯¼èˆªæ æŒ‰é’®æˆ–å¯¼èˆªæ¡é¢œè‰² setNavigationBarBtnColor(window, NightMode.isNightMode(window.context))&#125; åœ¨Android 10ä»¥ä¸Šï¼Œå½“è®¾ç½®äº†å¯¼èˆªæ æ èƒŒæ™¯ä¸ºé€æ˜æ—¶ï¼ŒisNavigationBarContrastEnforcedå¦‚æœä¸ºtrueï¼Œåˆ™ç³»ç»Ÿä¼šè‡ªåŠ¨ç»˜åˆ¶ä¸€ä¸ªåŠé€æ˜èƒŒæ™¯æ¥æä¾›å¯¹æ¯”åº¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦å°†è¿™ä¸ªå±æ€§è®¾ä¸ºfalse psï¼šçŠ¶æ€æ å…¶å®ä¹Ÿæœ‰å¯¹åº”çš„å±æ€§isStatusBarContrastEnforcedï¼Œåªä¸è¿‡è¿™ä¸ªå±æ€§é»˜è®¤å³ä¸ºfalseï¼Œæˆ‘ä»¬ä¸éœ€è¦ç‰¹æ„å»è®¾ç½® å¯¼èˆªæ æŒ‰é’®æˆ–å¯¼èˆªæ¡é¢œè‰²å’Œè®¾ç½®çŠ¶æ€æ æ–‡å­—é¢œè‰²ä¸€æ ·ï¼Œæˆ‘è¿™é‡Œå°±ä¸å¤šä»‹ç»äº† 1234567891011fun setNavigationBarBtnColor(window: Window, light: Boolean) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = if (light) &#123; //ç™½è‰²æŒ‰é’® systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR.inv() &#125; else &#123; //é»‘è‰²æŒ‰é’® systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR &#125; window.decorView.systemUiVisibility = systemUiVisibility &#125;&#125; çŸ«æ­£æ˜¾ç¤ºåŒºåŸŸfitsSystemWindowså’ŒçŠ¶æ€æ ä½¿ç”¨ä¸€æ ·ï¼Œæˆ‘å°±ä¸é‡å¤è¯´æ˜äº† è·å–å¯¼èˆªæ é«˜åº¦è‡ªä»å…¨é¢å±æ‰‹åŠ¿å¼€å§‹æµè¡Œï¼Œå¯¼èˆªæ ä¹Ÿä»åŸå…ˆçš„ä¸‰é”®å¼ï¼Œå˜æˆäº†ä¸‰é”®å¼ã€å¯¼èˆªæ¡ã€å…¨éšè—è¿™ä¸‰ç§æƒ…å†µï¼Œè¿™ä¸‰ç§æƒ…å†µä¸‹çš„é«˜åº¦ä¹Ÿæ˜¯äº’ä¸ç›¸åŒçš„ ä¸‰é”®å¼å’Œå¯¼èˆªæ¡è¿™ä¸¤ç§æƒ…å†µæˆ‘ä»¬éƒ½å¯ä»¥é€šè¿‡android.R.dimen.navigation_bar_heightè¿™ä¸ªèµ„æºè·å–åˆ°å‡†ç¡®é«˜åº¦ï¼Œä½†ç°åœ¨å¾ˆå¤šç³»ç»Ÿéƒ½æ”¯æŒéšè—å¯¼èˆªæ çš„åŠŸèƒ½ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè™½ç„¶å®é™…å¯¼èˆªæ çš„é«˜åº¦åº”è¯¥æ˜¯0ï¼Œä½†æ˜¯é€šè¿‡èµ„æºè·å–åˆ°çš„é«˜åº¦å´ä¸ºä¸‰é”®å¼æˆ–å¯¼èˆªæ¡çš„é«˜åº¦ï¼Œè¿™å°±ç»™æˆ‘ä»¬æ²‰æµ¸å¼å¯¼èˆªæ çš„é€‚é…å¸¦æ¥äº†å¾ˆå¤§å›°éš¾ ç»è¿‡æˆ‘çš„å„ç§å°è¯•ï¼Œæˆ‘å‘ç°åªæœ‰ä¸€ç§æ–¹å¼å¯ä»¥å‡†ç¡®çš„è·å–åˆ°å½“å‰å¯¼èˆªæ çš„é«˜åº¦ï¼Œé‚£å°±æ˜¯WindowInsetsï¼Œè‡³äºWindowInsetsæ˜¯ä»€ä¹ˆæˆ‘å°±ä¸å¤šä»‹ç»äº†ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹ä»£ç  123456789/*** ä»…å½“view attach windowåç”Ÿæ•ˆ*/private fun getRealNavigationBarHeight(view: View): Int &#123; val insets = ViewCompat.getRootWindowInsets(view) ?.getInsets(WindowInsetsCompat.Type.navigationBars()) //WindowInsetsä¸ºnullåˆ™é»˜è®¤é€šè¿‡èµ„æºè·å–é«˜åº¦ return insets?.bottom ?: getNavigationBarHeight(view.context)&#125; è¿™é‡Œéœ€è¦æ³¨æ„åˆ°æˆ‘åœ¨æ–¹æ³•ä¸Šå†™çš„æ³¨é‡Šï¼Œåªæœ‰å½“Viewå’ŒWindow attach åï¼Œæ‰èƒ½è·å¾—åˆ°WindowInsetsï¼Œå¦åˆ™ä¸ºnullï¼Œæ‰€ä»¥æˆ‘ä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯å…ˆæ£€æŸ¥Viewæ˜¯å¦ attach äº†Windowï¼Œå¦‚æœæœ‰çš„è¯åˆ™ç›´æ¥è°ƒç”¨getRealNavigationBarHeightæ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰çš„è¯ï¼Œè°ƒç”¨View.addOnAttachStateChangeListeneræ–¹æ³•ï¼Œå½“å‡ºå‘attachå›è°ƒåï¼Œå†è°ƒç”¨getRealNavigationBarHeightæ–¹æ³•è·å–é«˜åº¦ è¿™ç§æ–¹å¼åœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹è¿è¡Œè‰¯å¥½ï¼Œä½†åœ¨æˆ‘ä¸€æ¬¡æ— æ„ä¸­åˆ‡æ¢äº†ç³»ç»Ÿå¤œé—´æ¨¡å¼åå‘ç°ï¼Œè·å–åˆ°çš„å¯¼èˆªæ é«˜åº¦å˜æˆäº†0ï¼Œå¹¶ä¸”è¿™è¿˜æ˜¯ä¸€ä¸ªå¶ç°çš„é—®é¢˜ï¼Œäºæ˜¯æˆ‘å°è¯•ä½¿ç”¨View.setOnApplyWindowInsetsListenerï¼Œç›‘å¬WindowInsetsçš„å˜åŒ–å‘ç°ï¼Œè¿™ä¸ªå›è°ƒæœ‰å¯èƒ½ä¼šè§¦å‘å¤šæ¬¡ï¼Œåœ¨è§¦å‘å¤šæ¬¡çš„æƒ…å†µä¸‹ï¼Œå‰å‡ æ¬¡çš„å€¼éƒ½ä¸º0ï¼Œåªæœ‰æœ€åä¸€æ¬¡çš„å€¼ä¸ºçœŸæ­£çš„å¯¼èˆªæ é«˜åº¦ äºæ˜¯æˆ‘å‡†å¤‡ç”¨View.setOnApplyWindowInsetsListenerä»£æ›¿View.addOnAttachStateChangeListenerï¼Œä½†æ¯•ç«Ÿä¸€ä¸ªæ˜¯setListenerï¼Œä¸€ä¸ªæ˜¯addListenerï¼ŒsetListeneræœ‰å¯èƒ½ä¼šæŠŠä¹‹å‰è®¾ç½®å¥½çš„Listenerè¦†ç›–ï¼Œæˆ–è€…è¢«åˆ«çš„Listenerè¦†ç›–æ‰ï¼Œå†è€ƒè™‘åˆ°ä¹‹åä¼šæåˆ°çš„åº•éƒ¨Dialogæ²‰æµ¸å¼å¯¼èˆªæ é€‚é…çš„é—®é¢˜ï¼Œæˆ‘æŠ˜ä¸­äº†ä¸€ä¸‹ï¼Œå†³å®šåªå¯¹Activityä¸‹çš„rootViewè®¾ç½®å›è°ƒ ä»¥ä¸‹æ˜¯å®Œæ•´ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117private class NavigationViewInfo( val hostRef: WeakReference&lt;View&gt;, val viewRef: WeakReference&lt;View&gt;, val rawBottom: Int, val onNavHeightChangeListener: (View, Int, Int) -&gt; Unit)private val navigationViewInfoList = mutableListOf&lt;NavigationViewInfo&gt;()private val onApplyWindowInsetsListener = View.OnApplyWindowInsetsListener &#123; v, insets -&gt; val windowInsetsCompat = WindowInsetsCompat.toWindowInsetsCompat(insets, v) val navHeight = windowInsetsCompat.getInsets(WindowInsetsCompat.Type.navigationBars()).bottom val it = navigationViewInfoList.iterator() while (it.hasNext()) &#123; val info = it.next() val host = info.hostRef.get() val view = info.viewRef.get() if (host == null || view == null) &#123; it.remove() continue &#125; if (host == v) &#123; info.onNavHeightChangeListener(view, info.rawBottom, navHeight) &#125; &#125; insets&#125;private val actionMarginNavigation: (View, Int, Int) -&gt; Unit = &#123; view, rawBottomMargin, navHeight -&gt; (view.layoutParams as? ViewGroup.MarginLayoutParams)?.let &#123; it.bottomMargin = rawBottomMargin + navHeight view.requestLayout() &#125; &#125;private val actionPaddingNavigation: (View, Int, Int) -&gt; Unit = &#123; view, rawBottomPadding, navHeight -&gt; view.setPadding( view.paddingLeft, view.paddingTop, view.paddingRight, rawBottomPadding + navHeight ) &#125;fun fixNavBarMargin(vararg views: View) &#123; views.forEach &#123; fixSingleNavBarMargin(it) &#125;&#125;private fun fixSingleNavBarMargin(view: View) &#123; val lp = view.layoutParams as? ViewGroup.MarginLayoutParams ?: return val rawBottomMargin = lp.bottomMargin val viewForCalculate = getViewForCalculate(view) if (viewForCalculate.isAttachedToWindow) &#123; val realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate) lp.bottomMargin = rawBottomMargin + realNavigationBarHeight view.requestLayout() &#125; //isAttachedToWindowæ–¹æ³•å¹¶ä¸èƒ½ä¿è¯æ­¤æ—¶çš„WindowInsetsæ˜¯æ­£ç¡®çš„ï¼Œä»ç„¶éœ€è¦æ·»åŠ ç›‘å¬ val hostRef = WeakReference(viewForCalculate) val viewRef = WeakReference(view) val info = NavigationViewInfo(hostRef, viewRef, rawBottomMargin, actionMarginNavigation) navigationViewInfoList.add(info) viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)&#125;fun paddingByNavBar(view: View) &#123; val rawBottomPadding = view.paddingBottom val viewForCalculate = getViewForCalculate(view) if (viewForCalculate.isAttachedToWindow) &#123; val realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate) view.setPadding( view.paddingLeft, view.paddingTop, view.paddingRight, rawBottomPadding + realNavigationBarHeight ) &#125; //isAttachedToWindowæ–¹æ³•å¹¶ä¸èƒ½ä¿è¯æ­¤æ—¶çš„WindowInsetsæ˜¯æ­£ç¡®çš„ï¼Œä»ç„¶éœ€è¦æ·»åŠ ç›‘å¬ val hostRef = WeakReference(viewForCalculate) val viewRef = WeakReference(view) val info = NavigationViewInfo(hostRef, viewRef, rawBottomPadding, actionPaddingNavigation) navigationViewInfoList.add(info) viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)&#125;/*** Dialogä¸‹çš„Viewåœ¨ä½ç‰ˆæœ¬æœºå‹ä¸­è·å–åˆ°çš„WindowInsetså€¼æœ‰è¯¯ï¼Œ* æ‰€ä»¥å°è¯•å»è·å¾—Activityçš„contentViewï¼Œé€šè¿‡Activityçš„contentViewè·å–WindowInsets*/@SuppressLint(\"ContextCast\")private fun getViewForCalculate(view: View): View &#123; return (view.context as? ContextWrapper)?.let &#123; return@let (it.baseContext as? Activity)?.findViewById&lt;View&gt;(android.R.id.content)?.rootView &#125; ?: view.rootView&#125;/*** ä»…å½“view attach windowåç”Ÿæ•ˆ*/private fun getRealNavigationBarHeight(view: View): Int &#123; val insets = ViewCompat.getRootWindowInsets(view) ?.getInsets(WindowInsetsCompat.Type.navigationBars()) return insets?.bottom ?: getNavigationBarHeight(view.context)&#125; æˆ‘ç®€å•è§£é‡Šä¸€ä¸‹è¿™æ®µä»£ç ï¼šä¸ºæ‰€æœ‰éœ€è¦æ²‰æµ¸çš„é¡µé¢çš„æ ¹Viewè®¾ç½®åŒä¸€ä¸ªå›è°ƒï¼Œå¹¶å°†å¾…é€‚é…å¯¼èˆªæ é«˜åº¦çš„Viewæ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œå½“WindowInsetså›è°ƒè§¦å‘åï¼Œéå†è¿™ä¸ªåˆ—è¡¨ï¼Œåˆ¤æ–­è§¦å‘å›è°ƒçš„Viewçš„hostæ˜¯å¦ä¸å¾…é€‚é…å¯¼èˆªæ é«˜åº¦çš„Viewå¯¹åº”ï¼Œå¯¹åº”çš„è¯åˆ™å¤„ç†Viewé€‚é…å¯¼èˆªæ é«˜åº¦ è¿™é‡Œéœ€è¦æ³¨æ„ï¼ŒWindowInsetsçš„åˆ†å‘å…¶å®æ˜¯åœ¨dispatchAttachedToWindowä¹‹åçš„ï¼Œæ‰€ä»¥isAttachedToWindowæ–¹æ³•å¹¶ä¸èƒ½ä¿è¯æ­¤æ—¶çš„WindowInsetsæ˜¯æ­£ç¡®çš„ï¼Œå…·ä½“å¯ä»¥å»çœ‹ViewRootImplä¸­çš„æºç ï¼Œå…³é”®æ–¹æ³•ï¼šdispatchApplyInsetsï¼Œè¿™é‡Œåˆ¤æ–­isAttachedToWindowå¹¶è®¾ç½®é«˜åº¦æ˜¯ä¸ºäº†é˜²æ­¢å‡ºç°Viewå·²ç»å®Œå…¨å¸ƒå±€å®Œæˆï¼Œä¹‹åå†ä¹Ÿä¸ä¼šè§¦å‘OnApplyWindowInsetsçš„æƒ…å†µ è¿™é‡Œæˆ‘ä¹Ÿæµ‹è¯•äº†å†…å­˜æ³„æ¼æƒ…å†µï¼Œç¡®è®¤æ— å†…å­˜æ³„æ¼ï¼Œå¤§å®¶å¯ä»¥æ”¾å¿ƒé£Ÿç”¨ åº•éƒ¨Dialogé€‚é…æ²‰æµ¸å¼åº•éƒ¨Dialogé€‚é…æ²‰æµ¸å¼è¦æ¯”æ­£å¸¸çš„Activityæ›´éº»çƒ¦ä¸€äº›ï¼Œä¸»è¦é—®é¢˜ä¹Ÿæ˜¯é›†ä¸­åœ¨æ²‰æµ¸å¼å¯¼èˆªæ ä¸Š è·å–å¯¼èˆªæ é«˜åº¦ä»”ç»†çš„å°ä¼™ä¼´ä»¬å¯ä»¥å·²ç»æ³¨æ„åˆ°äº†æˆ‘åœ¨æ²‰æµ¸å¼å¯¼èˆªæ è·å–é«˜åº¦é‚£é‡Œä»£ç ä¸­çš„æ³¨é‡Šï¼ŒDialogä¸‹çš„Viewåœ¨ä½ç‰ˆæœ¬æœºå‹ï¼ˆç»æµ‹è¯•ï¼ŒAndroid 9ä¸€ä¸‹å°±ä¼šæœ‰è¿™ä¸ªé—®é¢˜ï¼‰ä¸­è·å–åˆ°çš„WindowInsetså€¼æœ‰è¯¯ï¼Œæ‰€ä»¥å°è¯•å»è·å¾—Activityçš„contentViewï¼Œé€šè¿‡Activityçš„contentViewè·å–WindowInsets LayoutParamså¯¼è‡´çš„å¼‚å¸¸åœ¨æŸäº›ç³»ç»Ÿä¸Šï¼ˆæ¯”å¦‚MIUIï¼‰ï¼Œå½“æˆ‘window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)æ—¶ï¼Œæ²‰æµ¸å¼ä¼šå‡ºç°é—®é¢˜ï¼ŒçŠ¶æ€æ ä¼šè¢«è’™å±‚ç›–ä½ï¼ŒDialogåº•éƒ¨çš„å†…å®¹ä¹Ÿä¼šè¢«ä¸€ä¸ªè«åå…¶å¦™çš„ä¸œè¥¿é®æŒ¡ä½ æˆ‘çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œwindow.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)ï¼Œç„¶åå¸ƒå±€æœ€å¤–å±‚å…¨éƒ¨å æ»¡ï¼Œå†…éƒ¨ç•™ä¸€ä¸ªåº•éƒ¨å®¹å™¨ 123456789101112131415&lt;!-- dialog_pangu_bottom_wrapper --&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/transparent\"&gt; &lt;FrameLayout android:id=\"@+id/pangu_bottom_dialog_container\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:clickable=\"true\" android:focusable=\"true\" /&gt;&lt;/FrameLayout&gt; ç„¶ååœ¨ä»£ç ä¸­é‡å†™setContentViewæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142private var canceledOnTouchOutside = trueoverride fun setContentView(layoutResID: Int) &#123; setContentView( LayoutInflater.from(context).inflate(layoutResID, null, false) )&#125;override fun setContentView(view: View) &#123; setContentView( view, ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT ) )&#125;override fun setContentView(view: View, params: ViewGroup.LayoutParams?) &#123; val root = LayoutInflater.from(context).inflate(R.layout.dialog_pangu_bottom_wrapper, null, false) root.setOnClickListener &#123; if (canceledOnTouchOutside) &#123; dismiss() &#125; &#125; val container = root.findViewById&lt;ViewGroup&gt;(R.id.pangu_bottom_dialog_container) container.addView(view, params) super.setContentView( root, ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) )&#125;override fun setCanceledOnTouchOutside(cancel: Boolean) &#123; super.setCanceledOnTouchOutside(cancel) canceledOnTouchOutside = cancel&#125; è¿™æ ·çš„è¯è§†è§‰æ•ˆæœå°±å’Œæ™®é€šçš„åº•éƒ¨Dialogä¸€æ ·äº†ï¼Œä¸ºäº†è¿›ä¸€æ­¥å‡å°åº•éƒ¨Dialogæ˜¾ç¤ºéšè—åŠ¨ç”»ä¹‹é—´çš„å·®å¼‚ï¼Œæˆ‘å°†åŠ¨ç”»æ’å€¼å™¨ä»linear_interpolatoræ¢æˆäº†decelerate_interpolatorå’Œaccelerate_interpolator 123456&lt;!-- dialog_enter_from_bottom_to_top --&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"100%\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:toYDelta=\"0\" /&gt; 123456&lt;!-- dialog_exit_from_top_to_bottom --&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"0\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:toYDelta=\"100%\" /&gt; å°¾å£°è‡ªæ­¤ï¼Œç›®å‰æ²‰æµ¸å¼é‡åˆ°çš„é—®é¢˜å…¨éƒ¨éƒ½è§£å†³äº†ï¼Œå¦‚æœä»¥åå‘ç°äº†ä»€ä¹ˆæ–°çš„é—®é¢˜ï¼Œæˆ‘ä¼šåœ¨è¿™ç¯‡æ–‡ç« ä¸­è¡¥å……è¯´æ˜ï¼Œå¦‚æœè¿˜æœ‰ä»€ä¹ˆä¸æ˜ç™½çš„åœ°æ–¹å¯ä»¥è¯„è®ºï¼Œæˆ‘è€ƒè™‘è¦ä¸è¦æ‹¿å‡ ä¸ªå…·ä½“çš„åœºæ™¯å®æˆ˜è®²è§£ï¼Œå„ä½çœ‹å®˜è€çˆ·éº»çƒ¦ç‚¹ä¸ªèµæ”¶ä¸ªè—ä¸è¿·è·¯ğŸ˜„","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æ²‰æµ¸å¼","slug":"Android/æ²‰æµ¸å¼","permalink":"http://yoursite.com/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"çŠ¶æ€æ ","slug":"Android/çŠ¶æ€æ ","permalink":"http://yoursite.com/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"å¯¼èˆªæ ","slug":"Android/å¯¼èˆªæ ","permalink":"http://yoursite.com/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"Android/StatusBar","permalink":"http://yoursite.com/categories/Android/StatusBar/"},{"name":"NavigationBar","slug":"Android/NavigationBar","permalink":"http://yoursite.com/categories/Android/NavigationBar/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"æ²‰æµ¸å¼","slug":"æ²‰æµ¸å¼","permalink":"http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"çŠ¶æ€æ ","slug":"çŠ¶æ€æ ","permalink":"http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"å¯¼èˆªæ ","slug":"å¯¼èˆªæ ","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://yoursite.com/tags/StatusBar/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰","date":"2022-12-19T13:49:36.000Z","updated":"2023-02-26T10:34:30.145Z","comments":true,"path":"2022/12/19/android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸‹ï¼‰/","link":"","permalink":"http://yoursite.com/2022/12/19/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ ä¸­ï¼Œæˆ‘ä»¬åˆ†æäº†Appè¿›ç¨‹çš„å¯åŠ¨è¿‡ç¨‹ï¼ŒåŒ…æ‹¬Applicationæ˜¯æ€ä¹ˆåˆ›å»ºå¹¶æ‰§è¡ŒonCreateæ–¹æ³•çš„ï¼Œæœ¬ç¯‡æ–‡ç« æˆ‘ä»¬å°†ä¼šç»§ç»­åˆ†æAppè¿›ç¨‹å¯åŠ¨ã€Applicationåˆ›å»ºå®Œæˆåï¼ŒActivityæ˜¯å¦‚ä½•å¯åŠ¨çš„ ä¸¤ç§è·¯å¾„å¯åŠ¨Activityæˆ‘ä»¬åœ¨ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰ çš„æœ«å°¾åˆ†æè¿‡ï¼ŒActivityçš„å¯åŠ¨å­˜åœ¨ä¸¤æ¡è·¯å¾„ å¯åŠ¨è¿›ç¨‹ï¼Œç„¶åå¯åŠ¨Activityè¿™æ¡è·¯å¾„å°±æ˜¯æˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ ä¸­åˆ†æäº†å‰åŠéƒ¨åˆ†ï¼šå¯åŠ¨è¿›ç¨‹ å½“è¿›ç¨‹å¯åŠ¨åï¼Œä¼šæ‰§è¡Œåˆ°AMS.attachApplicationLockedæ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•çš„æœ€åï¼Œä¼šæœ‰ä¸€æ®µä»£ç æ£€æŸ¥æ˜¯å¦æœ‰Activityç­‰å¾…å¯åŠ¨ 123456789101112131415161718private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... // See if the top visible activity is waiting to run in this process... //æ£€æŸ¥æ˜¯å¦æœ‰Activityç­‰å¾…å¯åŠ¨ if (normalMode) &#123; try &#123; didSomething = mAtmInternal.attachApplication(app.getWindowProcessController()); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ... return true;&#125; ç„¶åè°ƒç”¨ActivityTaskManagerInternal.attachApplicationï¼ŒActivityTaskManagerInternalæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œè¢«ATMSçš„å†…éƒ¨ç±»LocalServiceå®ç° 123456789public boolean attachApplication(WindowProcessController wpc) throws RemoteException &#123; synchronized (mGlobalLockWithoutBoost) &#123; try &#123; return mRootWindowContainer.attachApplication(wpc); &#125; finally &#123; ... &#125; &#125;&#125; æ¥ç€è°ƒç”¨RootWindowContainer.attachApplication 12345678910111213141516171819202122232425262728293031323334boolean attachApplication(WindowProcessController app) throws RemoteException &#123; boolean didSomething = false; for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) &#123; mTmpRemoteException = null; mTmpBoolean = false; // Set to true if an activity was started. final DisplayContent display = getChildAt(displayNdx); for (int areaNdx = display.getTaskDisplayAreaCount() - 1; areaNdx &gt;= 0; --areaNdx) &#123; final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx); for (int taskNdx = taskDisplayArea.getStackCount() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx); if (rootTask.getVisibility(null /*starting*/) == STACK_VISIBILITY_INVISIBLE) &#123; break; &#125; //éå†ActivityStackä¸‹çš„æ‰€æœ‰ActivityRecordï¼Œ //ä»¥å…¶ä¸ºå‚æ•°è°ƒç”¨startActivityForAttachedApplicationIfNeededæ–¹æ³• final PooledFunction c = PooledLambda.obtainFunction( RootWindowContainer::startActivityForAttachedApplicationIfNeeded, this, PooledLambda.__(ActivityRecord.class), app, rootTask.topRunningActivity()); rootTask.forAllActivities(c); c.recycle(); if (mTmpRemoteException != null) &#123; throw mTmpRemoteException; &#125; &#125; &#125; didSomething |= mTmpBoolean; &#125; if (!didSomething) &#123; ensureActivitiesVisible(null, 0, false /* preserve_windows */); &#125; return didSomething;&#125; è¿™é‡Œæœ‰ä¸¤å±‚forå¾ªç¯ï¼Œå¯ä»¥çœ‹å‡ºæ¥ï¼Œè¿™ä¸ªæ–¹æ³•éå†äº†æ‰€æœ‰å¯è§çš„ActivityStackï¼Œç„¶åå†å¯¹æ¯ä¸ªå¯è§çš„ActivityStackè¿›è¡Œæ“ä½œ å…¶ä¸­ï¼ŒPooledLambdaè¿™ä¸ªç±»é‡‡ç”¨äº†æ± åŒ–æŠ€æœ¯ï¼Œç”¨äºæ„é€ å¯å›æ”¶å¤ç”¨çš„åŒ¿åå‡½æ•°ï¼Œè¿™é‡ŒPooledLambda.obtainFunctionæ–¹æ³•å¾—åˆ°çš„ç»“æœæ˜¯ä¸€ä¸ªFunction&lt;ActivityRecord, Boolean&gt;ï¼ŒforAllActivitiesæ–¹æ³•è¢«å®šä¹‰åœ¨çˆ¶ç±»WindowContainerä¸­ï¼Œå°±æ˜¯éå†æ‰§è¡Œæ‰€æœ‰childçš„forAllActivitiesæ–¹æ³•ï¼Œè€ŒActivityRecordä¸­é‡å†™äº†è¿™ä¸ªæ–¹æ³•ï¼Œç›´æ¥ç”¨è‡ªèº«æ‰§è¡Œè¿™ä¸ªFunction ç®€å•æ¥è¯´ï¼Œå¯ä»¥å°†è¿™éƒ¨åˆ†ä»£ç çœ‹ä½œä»¥ä¸‹ä¼ªä»£ç ï¼š 123rootTask.forEachAllActivityRecord((activityRecord) -&gt; &#123; startActivityForAttachedApplicationIfNeeded(activityRecord, app, rootTask.topRunningActivity())&#125;) æ¥ç€æˆ‘ä»¬æ¥è§‚å¯ŸstartActivityForAttachedApplicationIfNeededæ–¹æ³• 123456789101112131415161718192021private boolean startActivityForAttachedApplicationIfNeeded(ActivityRecord r, WindowProcessController app, ActivityRecord top) &#123; //Activityæ˜¯å¦æ­£åœ¨finishï¼Œæ˜¯å¦åº”ä¸ºå½“å‰ç”¨æˆ·æ˜¾ç¤ºActivityï¼Œå¿½ç•¥é”å±æƒ…å†µï¼Œæ­¤Activityæ˜¯å¦å¯è§ //å¯¹æ¯”Activityä¸å‘èµ·è¿›ç¨‹çš„uidå’Œè¿›ç¨‹å if (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != null || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) &#123; return false; &#125; try &#123; //å¯åŠ¨Activity if (mStackSupervisor.realStartActivityLocked(r, app, top == r &amp;&amp; r.isFocusable() /*andResume*/, true /*checkConfig*/)) &#123; mTmpBoolean = true; &#125; &#125; catch (RemoteException e) &#123; ... return true; &#125; return false;&#125; ä¸Šé¢ä¸€ç³»åˆ—çš„åˆ¤æ–­æ£€æŸ¥ä¼ å…¥çš„ActivityRecordæ‰€å¯¹åº”çš„Activityæ˜¯å¦éœ€è¦å¯åŠ¨ï¼Œç„¶åè°ƒç”¨ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•å¯åŠ¨Activity å·²æœ‰è¿›ç¨‹ï¼Œç›´æ¥å¯åŠ¨Activityè¿™æ¡è·¯å¾„æˆ‘åœ¨ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰ ä¸­çš„æœ«å°¾ä¹Ÿåˆ†æè¿‡ï¼Œå¦‚æœAppè¿›ç¨‹å·²ç»å¯åŠ¨ï¼Œåˆ™ä¼šè°ƒç”¨ActivityStackSupervisor.startSpecificActivityæ–¹æ³• 12345678910111213141516171819202122232425262728void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; try &#123; //å¯åŠ¨Activity realStartActivityLocked(r, wpc, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. knownToBeDead = true; &#125; //é”å±çŠ¶æ€ä¸‹å¯åŠ¨Activityé˜²é—ªçƒæœºåˆ¶ r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); //å‡ºç°å¼‚å¸¸ï¼Œé‡å¯è¿›ç¨‹ final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity(); mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? \"top-activity\" : \"activity\");&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œä¹Ÿè°ƒç”¨äº†ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•å¯åŠ¨Activity realStartActivityLockedæœ€ç»ˆä¸¤æ¡è·¯å¾„éƒ½èµ°åˆ°äº†ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•ä¸­ï¼Œé‚£æˆ‘ä»¬å°±æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•åšäº†ä»€ä¹ˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; //ç¡®ä¿æ‰€æœ‰Activityéƒ½å·²æš‚åœ if (!mRootWindowContainer.allPausedActivitiesComplete()) &#123; // While there are activities pausing we skipping starting any new activities until // pauses are complete. NOTE: that we also do this for activities that are starting in // the paused state because they will first be resumed then paused on the client side. return false; &#125; final Task task = r.getTask(); final ActivityStack stack = task.getStack(); //å»¶è¿Ÿresumeä»¥é¿å…é‡å¤resume //é€šè¿‡è®¾ç½®æ ‡è®°ä½mDeferResumeCountï¼Œåªæœ‰å½“å…¶ä¸º0æ—¶æ‰èƒ½æ‰§è¡Œresume beginDeferResume(); try &#123; //å†»ç»“å±å¹•ï¼ˆä¸æ¥æ”¶è¾“å…¥ã€ä¸æ‰§è¡ŒåŠ¨ç”»ï¼Œæˆªå–å±å¹•è¿›è¡Œæ˜¾ç¤ºï¼‰ r.startFreezingScreenLocked(proc, 0); // schedule launch ticks to collect information about slow apps. //æ”¶é›†å¯åŠ¨ç¼“æ…¢ä¿¡æ¯ r.startLaunchTickingLocked(); r.setProcess(proc); // Ensure activity is allowed to be resumed after process has set. //ç¡®ä¿Activityå…è®¸è¢«resume if (andResume &amp;&amp; !r.canResumeByCompat()) &#123; andResume = false; &#125; //é”å±çŠ¶æ€ä¸‹å¯åŠ¨Activityé˜²é—ªçƒæœºåˆ¶ r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); // Have the window manager re-evaluate the orientation of the screen based on the new // activity order. Note that as a result of this, it can call back into the activity // manager with a new orientation. We don't care about that, because the activity is // not currently running so we are just restarting it anyway. if (checkConfig) &#123; // Deferring resume here because we're going to launch new activity shortly. // We don't want to perform a redundant launch of the same record while ensuring // configurations and trying to resume top activity of focused stack. //ç¡®ä¿æ‰€æœ‰Activityçš„å¯è§æ€§ã€æ›´æ–°å±å¹•æ–¹å‘å’Œé…ç½® mRootWindowContainer.ensureVisibilityAndConfig(r, r.getDisplayId(), false /* markFrozenIfConfigChanged */, true /* deferResume */); &#125; //æ£€æŸ¥Activityæ˜¯å¦åœ¨åå°é”å±çŠ¶æ€ä¸‹å¯åŠ¨ if (r.getRootTask().checkKeyguardVisibility(r, true /* shouldBeVisible */, true /* isTop */) &amp;&amp; r.allowMoveToFront()) &#123; // We only set the visibility to true if the activity is not being launched in // background, and is allowed to be visible based on keyguard state. This avoids // setting this into motion in window manager that is later cancelled due to later // calls to ensure visible activities that set visibility back to false. //åªæœ‰Activityä¸æ˜¯åœ¨åå°å¯åŠ¨ï¼Œæ‰å°†å…¶å¯è§æ€§è®¾ç½®ä¸ºtrue r.setVisibility(true); &#125; ... //å¼‚å¸¸æƒ…å†µæ£€æŸ¥ r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); proc.setLastActivityLaunchTime(r.lastLaunchTime); //å±å¹•å›ºå®šåŠŸèƒ½ final LockTaskController lockTaskController = mService.getLockTaskController(); if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED &amp;&amp; lockTaskController.getLockTaskModeState() == LOCK_TASK_MODE_LOCKED)) &#123; lockTaskController.startLockTaskMode(task, false, 0 /* blank UID */); &#125; try &#123; if (!proc.hasThread()) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; // We don't need to deliver new intents and/or set results if activity is going // to pause immediately after launch. results = r.results; newIntents = r.newIntents; &#125; //å¦‚æœæ˜¯ACTIVITY_TYPE_HOMEç±»å‹çš„åº”ç”¨ï¼ˆLauncherï¼‰ if (r.isActivityTypeHome()) &#123; // Home process is the root process of the task. updateHomeProcess(task.getBottomMostActivity().app); &#125; //ä¿¡æ¯è®°å½• mService.getPackageManagerInternalLocked().notifyPackageUse( r.intent.getComponent().getPackageName(), NOTIFY_PACKAGE_USE_ACTIVITY); r.setSleeping(false); r.forceNewConfig = false; //å¦‚æœæœ‰å¿…è¦çš„è¯ï¼Œæ˜¾ç¤ºä¸€äº›Appè­¦å‘Šå¼¹çª—ï¼ˆä¸æ”¯æŒçš„CompileSdkã€ä¸æ”¯æŒçš„TargetSdkã€ä¸æ”¯æŒçš„æ˜¾ç¤ºå¤§å°ï¼‰ mService.getAppWarningsLocked().onStartActivity(r); //å…¼å®¹æ€§ä¿¡æ¯ r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo); // Because we could be starting an Activity in the system process this may not go // across a Binder interface which would create a new Configuration. Consequently // we have to always create a new Configuration here. final MergedConfiguration mergedConfiguration = new MergedConfiguration( proc.getConfiguration(), r.getMergedOverrideConfiguration()); r.setLastReportedConfiguration(mergedConfiguration); // Create activity launch transaction. //åˆ›å»ºæˆ–è·å–ä¸€ä¸ªclientäº‹åŠ¡ final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; //æ·»åŠ ä¸€æ¡Activityå¯åŠ¨æ¶ˆæ¯ clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(), results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken, r.createFixedRotationAdjustmentsIfNeeded())); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; //è®¾ç½®clientæ‰§è¡Œäº‹åŠ¡ååº”å¤„äºçš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. //è°ƒåº¦æ‰§è¡Œæ­¤äº‹åŠ¡ï¼Œå¯åŠ¨Activity mService.getLifecycleManager().scheduleTransaction(clientTransaction); //å¤„ç†é‡é‡çº§è¿›ç¨‹ if ((proc.mInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0 &amp;&amp; mService.mHasHeavyWeightFeature) &#123; // This may be a heavy-weight process! Note that the package manager will ensure // that only activity can run in the main process of the .apk, which is the only // thing that will be considered heavy-weight. if (proc.mName.equals(proc.mInfo.packageName)) &#123; if (mService.mHeavyWeightProcess != null &amp;&amp; mService.mHeavyWeightProcess != proc) &#123; Slog.w(TAG, \"Starting new heavy weight process \" + proc + \" when already running \" + mService.mHeavyWeightProcess); &#125; mService.setHeavyWeightProcess(r); &#125; &#125; &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; // This is the second time we failed -- finish activity and give up. //ç¬¬äºŒæ¬¡å¯åŠ¨å¤±è´¥ï¼Œfinishæ‰Activityå¹¶æ”¾å¼ƒé‡è¯•ï¼Œç›´æ¥è¿”å›false Slog.e(TAG, \"Second failure launching \" + r.intent.getComponent().flattenToShortString() + \", giving up\", e); proc.appDied(\"2nd-crash\"); r.finishIfPossible(\"2nd-crash\", false /* oomAdj */); return false; &#125; // This is the first time we failed -- restart process and // retry. //ç¬¬ä¸€æ¬¡å¯åŠ¨å¤±è´¥ï¼Œå°è¯•é‡å¯è¿›ç¨‹å¹¶é‡è¯•å¯åŠ¨Activity r.launchFailed = true; proc.removeActivity(r); throw e; &#125; &#125; finally &#123; endDeferResume(); &#125; r.launchFailed = false; // TODO(lifecycler): Resume or pause requests are done as part of launch transaction, // so updating the state should be done accordingly. //æ›´æ–°ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ if (andResume &amp;&amp; readyToResume()) &#123; // As part of the process of launching, ActivityThread also performs // a resume. stack.minimalResumeActivityLocked(r); &#125; else &#123; // This activity is not starting in the resumed state... which should look like we asked // it to pause+stop (but remain visible), and it has done so and reported back the // current icicle and other state. r.setState(PAUSED, \"realStartActivityLocked\"); mRootWindowContainer.executeAppTransitionForAllDisplay(); &#125; // Perform OOM scoring after the activity state is set, so the process can be updated with // the latest state. //æ›´æ–°è¿›ç¨‹oom adjï¼Œæ›´æ–°è¿›ç¨‹çŠ¶æ€ proc.onStartActivity(mService.mTopProcessState, r.info); // Launch the new version setup screen if needed. We do this -after- // launching the initial activity (that is, home), so that it can have // a chance to initialize itself while in the background, making the // switch back to it faster and look better. if (mRootWindowContainer.isTopDisplayFocusedStack(stack)) &#123; mService.getActivityStartController().startSetupActivity(); &#125; // Update any services we are bound to that might care about whether // their client may have activities. //æ›´æ–°è¿›ç¨‹ç»‘å®šçš„æ‰€æœ‰æœåŠ¡ if (r.app != null) &#123; r.app.updateServiceConnectionActivities(); &#125; return true;&#125; è¿™ä¸ªæ–¹æ³•ä¸­æœ€å…³é”®çš„éƒ¨åˆ†åœ¨äºåˆ›å»ºäº†ClientTransactionäº‹åŠ¡ï¼Œå¹¶å‘é‡Œæ·»åŠ äº†ä¸€æ¡å¯åŠ¨Activityçš„æ¶ˆæ¯ï¼Œç„¶åè°ƒç”¨ATMS.getLifecycleManager.scheduleTransactionè°ƒåº¦æ‰§è¡Œè¿™ä¸ªäº‹åŠ¡ï¼Œå¯åŠ¨Activity ClientTransactionæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ClientTransactionè¿™ä¸ªå¯¹è±¡æ˜¯æ€ä¹ˆåˆ›å»ºè·å–çš„ï¼Œæˆ‘ä»¬é¦–å…ˆè°ƒç”¨äº†ClientTransaction.obtainæ–¹æ³•ï¼Œå¹¶ä¼ å…¥äº†ä¸€ä¸ªActivityThreadå†…éƒ¨ç±»ApplicationThreadçš„Binderå¯¹è±¡IApplicationThreadå’Œä¸€ä¸ªActivityRecord.Tokenå¯¹è±¡ 12345678910public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123; ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class); if (instance == null) &#123; instance = new ClientTransaction(); &#125; instance.mClient = client; instance.mActivityToken = activityToken; return instance;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œä»æ± å­é‡Œæ‹¿ä¸€ä¸ªå®ä¾‹ï¼Œæˆ–è€…æ–°åˆ›å»ºä¸€ä¸ªå®ä¾‹å¯¹è±¡ï¼Œå°†è¿™ä¸ªå®ä¾‹å¯¹è±¡çš„ä¸¤ä¸ªæˆå‘˜å˜é‡èµ‹å€¼åè¿”å› ç„¶åæˆ‘ä»¬è°ƒç”¨äº†ClientTransaction.addCallbackæ–¹æ³•å°†ClientTransactionItemåŠ å…¥åˆ°å›è°ƒé˜Ÿåˆ—ä¸­ï¼ŒClientTransactionItemæ˜¯ä¸€æ¡èƒ½å¤Ÿè¢«æ‰§è¡Œçš„ç”Ÿå‘½å‘¨æœŸå›è°ƒæ¶ˆæ¯ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå­ç±»éœ€è¦å®ç°å®ƒçš„preExecuteã€executeã€postExecuteæ–¹æ³• æˆ‘ä»¬è¿™é‡Œä¼ å…¥çš„æ˜¯LaunchActivityItemï¼Œè¿™æ¡æ¶ˆæ¯æ˜¯ç”¨æ¥å¯åŠ¨Activityçš„ ç„¶åæˆ‘ä»¬è°ƒç”¨ClientTransaction.setLifecycleStateRequestè®¾ç½®å½“äº‹åŠ¡æ‰§è¡Œç»“æŸåï¼ŒActivityåº”è¯¥å¤„åœ¨ä¸€ä¸ªæ€æ ·çš„ç”Ÿå‘½å‘¨æœŸ æœ€åè°ƒç”¨ATMS.getLifecycleManager.scheduleTransactionè°ƒåº¦æ‰§è¡Œè¿™ä¸ªäº‹åŠ¡ï¼ŒATMS.getLifecycleManagerè·å¾—çš„æ˜¯ä¸€ä¸ªClientLifecycleManagerå¯¹è±¡ï¼Œæˆ‘ä»¬æ²¿ç€è¿™ä¸ªæ–¹æ³•ç»§ç»­å¾€ä¸‹çœ‹ 12345678910void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it's a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125;&#125; é™¤äº†å›æ”¶è°ƒç”¨recycleä¹‹å¤–ï¼Œæˆ‘ä»¬åˆå›åˆ°äº†ClientTransactionä¸­ï¼Œè°ƒç”¨å…¶scheduleæ–¹æ³• 123public void schedule() throws RemoteException &#123; mClient.scheduleTransaction(this);&#125; è¿™é‡Œåˆè·¨è¿›ç¨‹å›åˆ°äº†Appè¿›ç¨‹ä¸­ï¼Œè°ƒç”¨ApplicationThread.scheduleTransaction 123public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125; æœ€åè°ƒç”¨ActivityThread.scheduleTransactionæ‰§è¡Œäº‹åŠ¡ï¼ŒActivityThreadç»§æ‰¿è‡ªClientTransactionHandlerï¼ŒscheduleTransactionæ–¹æ³•æ˜¯åœ¨è¿™é‡Œé¢å®šä¹‰çš„ 1234void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125; é¦–å…ˆï¼Œè°ƒç”¨ClientTransaction.preExecuteæ–¹æ³•ï¼Œç„¶åé€šè¿‡Handlerå‘é€æ‰§è¡Œä¸€æ¡EXECUTE_TRANSACTIONæ¶ˆæ¯ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹preExecute 1234567891011public void preExecute(android.app.ClientTransactionHandler clientTransactionHandler) &#123; if (mActivityCallbacks != null) &#123; final int size = mActivityCallbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; mActivityCallbacks.get(i).preExecute(clientTransactionHandler, mActivityToken); &#125; &#125; if (mLifecycleStateRequest != null) &#123; mLifecycleStateRequest.preExecute(clientTransactionHandler, mActivityToken); &#125;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå°±æ˜¯éå†æ•´ä¸ªcallbackåˆ—è¡¨ï¼Œæ‰§è¡ŒpreExecuteæ–¹æ³•ï¼Œæœ€åå†æ‰§è¡ŒLifecycleStateRequestçš„preExecuteæ–¹æ³•ï¼Œå¯¹åº”åˆ°Activityå¯åŠ¨æµç¨‹ä¸­ï¼Œå°±æ˜¯å…ˆæ‰§è¡ŒLaunchActivityItem.preExecuteï¼Œå†æ‰§è¡ŒResumeActivityItem.preExecute 123456// LaunchActivityItempublic void preExecute(ClientTransactionHandler client, IBinder token) &#123; client.countLaunchingActivities(1); client.updateProcessState(mProcState, false); client.updatePendingConfiguration(mCurConfig);&#125; 1234567// ResumeActivityItempublic void preExecute(ClientTransactionHandler client, IBinder token) &#123; //è¿™é‡ŒmUpdateProcStateä¸ºfalseï¼Œä¸æ‰§è¡Œ if (mUpdateProcState) &#123; client.updateProcessState(mProcState, false); &#125;&#125; éƒ½æ˜¯ä¸€äº›çŠ¶æ€æ›´æ–°ä¹‹ç±»çš„ä¸œè¥¿ï¼Œæˆ‘ä»¬å°±ç›´æ¥è·³è¿‡ï¼Œç„¶åæˆ‘ä»¬çœ‹ActivityThreadåœ¨æ”¶åˆ°EXECUTE_TRANSACTIONæ¶ˆæ¯ååšäº†ä»€ä¹ˆ 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); ... break; ... &#125; ...&#125; è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œè°ƒç”¨äº†TransactionExecutorå¯¹è±¡çš„executeæ–¹æ³•ï¼ŒTransactionExecutorå¯¹è±¡åœ¨ActivityThreadåˆ›å»ºæ—¶ä¾¿åˆ›å»ºäº†ï¼Œå†…éƒ¨æŒæœ‰ä¸€ä¸ªClientTransactionHandlerå¼•ç”¨ï¼Œå³ActivityThreadè‡ªèº« 1234567891011121314151617181920212223242526272829public void execute(ClientTransaction transaction) &#123; final IBinder token = transaction.getActivityToken(); //å¤„ç†éœ€è¦é”€æ¯çš„Activities if (token != null) &#123; final Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed(); final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token); if (destroyItem != null) &#123; if (transaction.getLifecycleStateRequest() == destroyItem) &#123; // It is going to execute the transaction that will destroy activity with the // token, so the corresponding to-be-destroyed record can be removed. activitiesToBeDestroyed.remove(token); &#125; if (mTransactionHandler.getActivityClient(token) == null) &#123; // The activity has not been created but has been requested to destroy, so all // transactions for the token are just like being cancelled. //Activityå°šæœªè¢«åˆ›å»ºå°±è¢«è¯·æ±‚destroyï¼Œç›´æ¥å–æ¶ˆæ•´ä¸ªäº‹åŠ¡ Slog.w(TAG, tId(transaction) + \"Skip pre-destroyed transaction:\\n\" + transactionToString(transaction, mTransactionHandler)); return; &#125; &#125; &#125; executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear();&#125; å¤„ç†éœ€è¦é”€æ¯çš„Activitiesè¿™é‡Œæˆ‘ä»¬ä¸å…³æ³¨ï¼Œå°±ç›´æ¥è·³è¿‡ï¼Œç„¶åå°±æ˜¯åˆ†åˆ«æ‰§è¡Œå„ä¸ªClientTransactionItemå›è°ƒæ¶ˆæ¯ï¼Œæœ€åè®©å…¶è°ƒåº¦æ‰§è¡Œæˆ‘ä»¬è®¾ç½®çš„æœ€ç»ˆçš„ç”Ÿå‘½å‘¨æœŸ 12345678910111213141516171819202122232425262728public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); ... //ç”Ÿå‘½å‘¨æœŸè½¬æ¢ç›¸å…³ final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ... //ç”Ÿå‘½å‘¨æœŸè½¬æ¢ï¼Œåœ¨Activityå¯åŠ¨æ—¶ä¸ä¼šèµ°è¿›è¿™ä¸ªcase item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); if (r == null) &#123; // Launch activity request will create an activity record. //åœ¨æ‰§è¡Œå®Œå¯åŠ¨Activityåä¼šæ–°å»ºä¸€ä¸ªActivityClientRecordï¼Œé‡æ–°èµ‹å€¼ r = mTransactionHandler.getActivityClient(token); &#125; ... //ç”Ÿå‘½å‘¨æœŸè½¬æ¢ï¼Œåœ¨Activityå¯åŠ¨æ—¶ä¸ä¼šèµ°è¿›è¿™ä¸ªcase &#125;&#125; å…³äºç”Ÿå‘½å‘¨æœŸè½¬æ¢ï¼Œç”±äºActivityå¯åŠ¨çš„å½“å‰é˜¶æ®µä¸ä¼šè¿›å…¥è¿™äº›caseï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¸æäº† ç»è¿‡ç®€åŒ–ï¼Œå®é™…ä¸Šä¹Ÿå°±æ‰§è¡Œäº†LaunchActivityItem.executeå’ŒLaunchActivityItem.postExecuteæ–¹æ³• 12345678public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments); client.handleLaunchActivity(r, pendingActions, null /* customIntent */);&#125; è¿™é‡Œä½¿ç”¨ä¹‹å‰åœ¨AMSä¸­åˆ›å»ºLaunchActivityItemæ‰€ä½¿ç”¨åˆ°çš„ä¿¡æ¯ï¼Œåˆ›å»ºäº†ä¸€ä¸ªActivityClientRecordå¯¹è±¡ï¼Œæ¥ç€å›åˆ°ActivityThreadï¼Œè°ƒç”¨å…¶handleLaunchActivityæ–¹æ³• handleLaunchActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. //ç¡®ä¿Configurationä¸ºæœ€æ–° handleConfigurationChanged(null, null); // Initialize before creating the activity //åˆå§‹åŒ–ç¡¬ä»¶åŠ é€Ÿ if (!ThreadedRenderer.sRendererDisabled &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; HardwareRenderer.preload(); &#125; //ç¡®ä¿WMSè¢«åˆå§‹åŒ– WindowManagerGlobal.initialize(); // Hint the GraphicsEnvironment that an activity is launching on the process. //é€šçŸ¥æœ‰Activityå¯åŠ¨ GraphicsEnvironment.hintActivityLaunch(); //æ‰§è¡Œå¯åŠ¨Activity final Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; //è®¾ç½®Configuration r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); //è®¾ç½®ä¸€äº›å»¶è¿Ÿæ‰§è¡Œçš„åŠ¨ä½œï¼ˆä½œç”¨åŸŸåˆ°æ•´ä¸ªClientTransactionç»“æŸï¼‰ if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123; pendingActions.setOldState(r.state); //å½“Activityç”Ÿå‘½å‘¨æœŸèµ°åˆ°onStartå‰ï¼Œä¼šé€šè¿‡è¿™é‡Œè®¾ç½®çš„å€¼ //åˆ¤æ–­æ˜¯å¦éœ€è¦æ‰§è¡ŒonRestoreInstanceStateã€onPostCreate pendingActions.setRestoreInstanceState(true); pendingActions.setCallOnPostCreate(true); &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. //å‡ºç°é”™è¯¯ï¼Œåœæ­¢å¯åŠ¨Activity try &#123; ActivityTaskManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; return a;&#125; è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæœ€é‡è¦çš„è«è¿‡äºperformLaunchActivityäº†ï¼Œå®ƒæ˜¯åˆ›å»ºActivityçš„æ ¸å¿ƒæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** Core implementation of activity launch. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; //è®¾ç½®LoadedApk if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //å¦‚æœå¯åŠ¨çš„Activityæ˜¯ä¸€ä¸ªactivity-aliasï¼Œå°†Componentè®¾ç½®ä¸ºçœŸæ­£çš„Activityç»„ä»¶ //è¯¦è§ï¼šhttps://developer.android.com/guide/topics/manifest/activity-alias-element?hl=zh-cn if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //ä¸ºActivityåˆ›å»ºBaseContext ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); //å®ä¾‹åŒ–Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //åˆ›å»ºæˆ–è·å–Application //å¦‚æœè¯¥ActivityæŒ‡å®šåœ¨å…¶ä»–çš„ä¸€ä¸ªæ–°çš„è¿›ç¨‹ä¸­å¯åŠ¨ï¼ˆè®¾ç½®äº†android:processå±æ€§ï¼‰ï¼Œåˆ™ä¼šæ–°åˆ›å»ºApplication //æ­£å¸¸ä¸æ¶‰åŠå¤šè¿›ç¨‹ï¼Œéƒ½æ˜¯ç›´æ¥è·å–ä¹‹å‰åˆ›å»ºå¥½çš„Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //Manifestä¸­Activityæ ‡ç­¾ä¸‹çš„labelå±æ€§ CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); //å‡†å¤‡Configuration Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; Window window = null; //å½“relaunch Activityçš„æ—¶å€™mPreserveWindowæ‰ä¼šä¸ºtrueï¼ˆæ¯”å¦‚è¯´è°ƒç”¨Activity.recreateæ–¹æ³•ï¼‰ if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; // Activity resources must be initialized with the same loaders as the // application context. //è®¾ç½®Activity Resourceçš„Loadersä¸Application Resourceçš„Loadersä¸€è‡´ appContext.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); appContext.setOuterContext(activity); //é‡è¦ï¼šç»‘å®šBaseContextã€åˆ›å»ºPhoneWindowç­‰ä¸€ç³»åˆ—åˆå§‹åŒ–å·¥ä½œ activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; //æ›´æ–°ç½‘ç»œçŠ¶æ€ checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; //è®¾ç½®ä¸»é¢˜ int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //è°ƒç”¨Activityçš„onCreateæ–¹æ³• if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //åœ¨æ‰§è¡Œå®Œsuper.onCreateæ–¹æ³•åï¼ŒmCalledä¼šè¢«ç½®ä¸ºtrue //å¦‚æœmCalledä¸ºfalseï¼Œè¯´æ˜æ²¡æœ‰æ‰§è¡Œsuper.onCreateæ–¹æ³• throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; mLastReportedWindowingMode.put(activity.getActivityToken(), config.windowConfiguration.getWindowingMode()); &#125; //è®¾ç½®ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ä¸ºonCreate r.setState(ON_CREATE); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. //å°†æ–°å»ºçš„ActivityClientRecordæ·»åŠ åˆ°mActivitiesä¸­ synchronized (mResourcesManager) &#123; mActivities.put(r.token, r); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä¸ªå·¥ä½œï¼š å‡†å¤‡åˆ›å»ºActivityæ‰€å¿…è¦çš„ä¿¡æ¯ï¼Œè­¬å¦‚ç±»åç­‰ ä¸ºActivityåˆ›å»ºBaseContext é€šè¿‡Instrumentationå®ä¾‹åŒ–Activity åˆ›å»ºæˆ–è·å–Activityè¿›ç¨‹æ‰€å¯¹åº”çš„Application åˆå§‹åŒ–Activityï¼Œæ‰§è¡Œå„ç§ç»‘å®šå·¥ä½œï¼Œåˆ›å»ºPhoneWindowç­‰ æ‰§è¡ŒActivityçš„onCreateç”Ÿå‘½å‘¨æœŸæ–¹æ³• å°†ActivityClientRecordç”Ÿå‘½å‘¨æœŸçŠ¶æ€è®¾ç½®ä¸ºonCreate æˆ‘ä»¬é‡ç‚¹çœ‹ä¸€ä¸‹æœ€ä¸»è¦çš„å®ä¾‹åŒ–ã€attachå’ŒonCreateè¿™ä¸‰ç‚¹ Instrumentation.newActivityæˆ‘ä»¬åœ¨ Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰ ä¸­åˆ†æäº†ï¼ŒApplicationæ˜¯æ€ä¹ˆé€šè¿‡Instrumentationåˆ›å»ºçš„ï¼ŒActivityçš„åˆ›å»ºå’Œå®ƒç±»ä¼¼ 12345678public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; String pkg = intent != null &amp;&amp; intent.getComponent() != null ? intent.getComponent().getPackageName() : null; return getFactory(pkg).instantiateActivity(cl, className, intent);&#125; åŒæ ·çš„ä½¿ç”¨äº†AppComponentFactoryåˆ›å»ºï¼Œæˆ‘ä»¬è¿˜æ˜¯å»çœ‹ä¸€ä¸‹å®ƒçš„é»˜è®¤å®ç° 12345public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity) cl.loadClass(className).newInstance();&#125; åŒæ ·çš„ï¼Œä¹Ÿæ˜¯é€šè¿‡ç±»ååå°„åˆ›å»ºä¸€ä¸ªActivityçš„å®ä¾‹ Activity.attachç´§æ¥ç€ï¼Œæˆ‘ä»¬æ¥çœ‹Activity.attachæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123; //ç»‘å®šBaseContext attachBaseContext(context); //åˆå§‹åŒ–Fragmentæ§åˆ¶å™¨ mFragments.attachHost(null /*parent*/); //åˆ›å»ºå¹¶è®¾ç½®Windowç”¨äºæ˜¾ç¤ºç•Œé¢ mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //å„æˆå‘˜å˜é‡åˆå§‹åŒ– mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) &#123; if (lastNonConfigurationInstances != null) &#123; mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; &#125; else &#123; mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); &#125; &#125; //è®¾ç½®WindowManagerã€ActivityRecordTokenä»¥åŠæ˜¯å¦ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿ mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); //è®¾ç½®è‡ªåŠ¨å¡«å……é€‰é¡¹ setAutofillOptions(application.getAutofillOptions()); //è®¾ç½®å†…å®¹æ•è·åŠŸèƒ½ setContentCaptureOptions(application.getContentCaptureOptions());&#125; è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œattachæ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š ç»‘å®šBaseContext åˆå§‹åŒ–Fragmentæ§åˆ¶å™¨ åˆ›å»ºå¹¶è®¾ç½®Window å„ç§æˆå‘˜å˜é‡åŠå…¶ä»–å±æ€§åˆå§‹åŒ– çœ‹å®Œè¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼ŒåŸæ¥Activityçš„Windowæ˜¯åœ¨è¿™ä¸ªæ—¶å€™åˆ›å»ºçš„ï¼Œå¹¶ä¸”Windowçš„å…·ä½“å®ç°ç±»ä¸ºPhoneWindow å†ç„¶åä¾¿æ˜¯é€šè¿‡Instrumentationæ‰§è¡ŒActivityçš„onCreateç”Ÿå‘½å‘¨æœŸæ–¹æ³•äº† 12345public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; å…¶ä¸­prePerformCreateå’ŒpostPerformCreateä¼¼ä¹åªæœ‰åœ¨å•å…ƒæµ‹è¯•å’ŒCTSæµ‹è¯•ä¸‹æ‰ä¼šäº§ç”Ÿå®è´¨æ€§çš„å½±å“ï¼Œåœ¨æ­£å¸¸æƒ…å†µä¸‹æˆ‘ä»¬å°±å½“ä½œå®ƒä»¬ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬æ¥ç€çœ‹performCreateæ–¹æ³• Activity.performCreate1234567891011121314151617181920212223242526272829303132333435final void performCreate(Bundle icicle) &#123; performCreate(icicle, null);&#125;final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; //åˆ†å‘PreCreatedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPreCreatedå›è°ƒ dispatchActivityPreCreated(icicle); mCanEnterPictureInPicture = true; // initialize mIsInMultiWindowMode and mIsInPictureInPictureMode before onCreate final int windowingMode = getResources().getConfiguration().windowConfiguration .getWindowingMode(); //å¤šçª—å£æ¨¡å¼ mIsInMultiWindowMode = inMultiWindowMode(windowingMode); //ç”»ä¸­ç”»æ¨¡å¼ï¼ˆå°çª—æ’­æ”¾è§†é¢‘ç­‰åœºæ™¯ï¼‰ mIsInPictureInPictureMode = windowingMode == WINDOWING_MODE_PINNED; //æ¢å¤è¯·æ±‚æƒé™ä¸­çš„æ ‡å¿—ä½ restoreHasCurrentPermissionRequest(icicle); //æ‰§è¡ŒonCreateç”Ÿå‘½å‘¨æœŸæ–¹æ³• if (persistentState != null) &#123; onCreate(icicle, persistentState); &#125; else &#123; onCreate(icicle); &#125; //å…±äº«å…ƒç´ åŠ¨ç”»ç›¸å…³ mActivityTransitionState.readState(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); //FragmentManageråˆ†å‘ACTIVITY_CREATEDçŠ¶æ€ mFragments.dispatchActivityCreated(); //å…±äº«å…ƒç´ åŠ¨ç”»ç›¸å…³ mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); //åˆ†å‘PostCreatedäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityPostCreatedå›è°ƒ dispatchActivityPostCreated(icicle);&#125; å…¶ä¸­çš„å‚æ•°icicleå°±æ˜¯æˆ‘ä»¬å¹³æ—¶é‡å†™Activity.onCreateæ–¹æ³•æ—¶çš„ç¬¬ä¸€ä¸ªå…¥å‚savedInstanceStateï¼Œå¦‚æœActivityå‘ç”Ÿäº†é‡å»ºä¹‹ç±»çš„æƒ…å†µï¼Œå®ƒä¼šä¿å­˜ä¸€äº›çŠ¶æ€æ•°æ®ï¼Œç¬¬ä¸€æ¬¡å¯åŠ¨Activityæ—¶ä¸ºnull æ— è®ºpersistentStateæ˜¯å¦ä¸ºnullï¼Œæœ€ç»ˆéƒ½ä¼šè¿›å…¥åˆ°å•ä¸ªå‚æ•°çš„onCreateæ–¹æ³•ä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940protected void onCreate(@Nullable Bundle savedInstanceState) &#123; //æ¢å¤LoaderManager if (mLastNonConfigurationInstances != null) &#123; mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); &#125; //ActionBar if (mActivityInfo.parentActivityName != null) &#123; if (mActionBar == null) &#123; mEnableDefaultActionBarUp = true; &#125; else &#123; mActionBar.setDefaultDisplayHomeAsUpEnabled(true); &#125; &#125; if (savedInstanceState != null) &#123; //è‡ªåŠ¨å¡«å……åŠŸèƒ½ mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false); mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID); if (mAutoFillResetNeeded) &#123; getAutofillManager().onCreate(savedInstanceState); &#125; //æ¢å¤FragmentManagerçŠ¶æ€ Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); &#125; //FragmentManageråˆ†å‘CREATEDçŠ¶æ€ï¼Œæ‰§è¡Œå†…éƒ¨Fragmentçš„ç”Ÿå‘½å‘¨æœŸ mFragments.dispatchCreate(); //åˆ†å‘Createdäº‹ä»¶ï¼Œæ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„ActivityLifecycleCallbacksçš„onActivityCreatedå›è°ƒ dispatchActivityCreated(savedInstanceState); //è¯­éŸ³äº¤äº’åŠŸèƒ½ if (mVoiceInteractor != null) &#123; mVoiceInteractor.attachActivity(this); &#125; mRestoredFromBundle = savedInstanceState != null; //è¿™é‡Œè¡¨ç¤ºå·²è°ƒç”¨è¿‡super.onCreateæ–¹æ³• mCalled = true;&#125; åˆ°è¿™é‡Œï¼ŒActivityçš„onCreateç”Ÿå‘½å‘¨æœŸå°±èµ°å®Œäº†ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»è¿™æ•´ä¸ªæµç¨‹ä¸­å¾—åˆ°ä¸€äº›æ–°çš„æ”¶è·ï¼Œæ¯”å¦‚è¯´ï¼ŒåŸæ¥æ³¨å†Œåœ¨Applicationä¸­çš„ActivityLifecycleCallbackså›è°ƒæ˜¯åœ¨è¿™é‡Œè§¦å‘çš„ï¼ŒFragmentManagerçŠ¶æ€åˆ†å‘çš„é¡ºåºæ˜¯è¿™æ ·çš„ï¼Œä¸ºä»€ä¹ˆå¿…é¡»è¦è°ƒç”¨super.onCreateæ–¹æ³•ç­‰ç­‰ æ¥ç€ï¼Œæˆ‘ä»¬å†å›åˆ°TransactionExecutorä¸­ï¼Œå®ƒæ¥ä¸‹æ¥æ‰§è¡Œçš„æ˜¯LaunchActivityItem.postExecute 1234public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.countLaunchingActivities(-1);&#125; è¿™é‡Œå°±éå¸¸ç®€å•äº†ï¼Œè®¡æ•°å™¨å‡ä¸€ postExecuteæ‰§è¡Œå®Œåï¼Œæ•´ä¸ªLaunchActivityItemçš„å·¥ä½œå°±å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥æ‰§è¡Œçš„æ˜¯TransactionExecutor.executeLifecycleStateæ–¹æ³• 12345678910111213141516171819202122232425private void executeLifecycleState(ClientTransaction transaction) &#123; final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); if (lifecycleItem == null) &#123; // No lifecycle request, return early. return; &#125; final IBinder token = transaction.getActivityToken(); final ActivityClientRecord r = mTransactionHandler.getActivityClient(token); if (r == null) &#123; // Ignore requests for non-existent client records for now. return; &#125; // Cycle to the state right before the final requested state. //excludeLastStateä¸ºtrueçš„æƒ…å†µä¸‹ï¼Œæ¨è¿›ç”Ÿå‘½å‘¨æœŸç›´åˆ°æœ€ç»ˆç”Ÿå‘½å‘¨æœŸçš„ä¸Šä¸€ä¸ªç”Ÿå‘½å‘¨æœŸ //excludeLastStateä¸ºfalseçš„æƒ…å†µä¸‹ï¼Œæ¨è¿›ç”Ÿå‘½å‘¨æœŸç›´åˆ°æœ€ç»ˆç”Ÿå‘½å‘¨æœŸ cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */, transaction); // Execute the final transition with proper parameters. //æ‰§è¡Œæœ€ç»ˆçš„ç”Ÿå‘½å‘¨æœŸäº‹åŠ¡ lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);&#125; æˆ‘ä»¬ç›®å‰å¤„åœ¨çš„ç”Ÿå‘½å‘¨æœŸä¸ºON_CREATEæœ€ç»ˆç›®æ ‡è¦åˆ°è¾¾çš„ç”Ÿå‘½å‘¨æœŸä¸ºON_RESUMEï¼ŒcycleToPathæ–¹æ³•ä¼šå¸®åŠ©æˆ‘ä»¬æŠŠç”Ÿå‘½å‘¨æœŸæ¨è¿›åˆ°ON_RESUMEçš„ä¸Šä¸€ä¸ªç”Ÿå‘½å‘¨æœŸä¹Ÿå°±æ˜¯ON_START 123456private void cycleToPath(ActivityClientRecord r, int finish, boolean excludeLastState, ClientTransaction transaction) &#123; final int start = r.getLifecycleState(); final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState); performLifecycleSequence(r, path, transaction);&#125; TransactionExecutorHelper.getLifecyclePathæ–¹æ³•ä¼šå¸®æˆ‘ä»¬è®¡ç®—å‡ºä¸€ä¸ªå‰©ä½™è¦ç»è¿‡çš„ç”Ÿå‘½å‘¨æœŸè·¯çº¿çš„ä¸€ä¸ªæœ‰åºæ•°ç»„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public IntArray getLifecyclePath(int start, int finish, boolean excludeLastState) &#123; ... //é”™è¯¯åˆ¤æ–­ mLifecycleSequence.clear(); if (finish &gt;= start) &#123; if (start == ON_START &amp;&amp; finish == ON_STOP) &#123; // A case when we from start to stop state soon, we don't need to go // through the resumed, paused state. mLifecycleSequence.add(ON_STOP); &#125; else &#123; // just go there //æŒ‰é¡ºåºæ·»åŠ ç”Ÿå‘½å‘¨æœŸ for (int i = start + 1; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; &#125; else &#123; // finish &lt; start, can't just cycle down if (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123; // Special case when we can just directly go to resumed state. mLifecycleSequence.add(ON_RESUME); &#125; else if (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123; // Restart and go to required state. // Go to stopped state first. for (int i = start + 1; i &lt;= ON_STOP; i++) &#123; mLifecycleSequence.add(i); &#125; // Restart mLifecycleSequence.add(ON_RESTART); // Go to required state for (int i = ON_START; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; else &#123; // Relaunch and go to required state // Go to destroyed state first. for (int i = start + 1; i &lt;= ON_DESTROY; i++) &#123; mLifecycleSequence.add(i); &#125; // Go to required state for (int i = ON_CREATE; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; &#125; // Remove last transition in case we want to perform it with some specific params. if (excludeLastState &amp;&amp; mLifecycleSequence.size() != 0) &#123; mLifecycleSequence.remove(mLifecycleSequence.size() - 1); &#125; return mLifecycleSequence;&#125; å…¶å®ä»è¿™ä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬å°±èƒ½çœ‹å‡ºActivityç”Ÿå‘½å‘¨æœŸæ˜¯æ€ä¹ˆè®¾è®¡çš„ï¼Œä»£ç å¾ˆç®€å•ï¼Œæˆ‘å°±ä¸è§£é‡Šäº† 123456789public static final int UNDEFINED = -1;public static final int PRE_ON_CREATE = 0;public static final int ON_CREATE = 1;public static final int ON_START = 2;public static final int ON_RESUME = 3;public static final int ON_PAUSE = 4;public static final int ON_STOP = 5;public static final int ON_DESTROY = 6;public static final int ON_RESTART = 7; æˆ‘ä»¬ç»“åˆè¿™ä¸Šé¢è¿™ä¸ªç”Ÿå‘½å‘¨æœŸå¤§å°æ¥çœ‹ï¼Œstartä¸ºON_CREATEï¼Œfinishä¸ºON_RESUMEï¼ŒexcludeLastStateä¸ºtrueç§»é™¤æœ€åä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå¾—å‡ºçš„ç»“æœä¾¿æ˜¯[ON_START]ï¼Œç„¶åè°ƒç”¨performLifecycleSequenceæ–¹æ³•æ‰§è¡Œç”Ÿå‘½å‘¨æœŸ 123456789101112131415161718192021222324252627282930313233343536373839404142private void performLifecycleSequence(ActivityClientRecord r, IntArray path, ClientTransaction transaction) &#123; final int size = path.size(); for (int i = 0, state; i &lt; size; i++) &#123; state = path.get(i); switch (state) &#123; case ON_CREATE: mTransactionHandler.handleLaunchActivity(r, mPendingActions, null /* customIntent */); break; case ON_START: mTransactionHandler.handleStartActivity(r, mPendingActions, null /* activityOptions */); break; case ON_RESUME: mTransactionHandler.handleResumeActivity(r, false /* finalStateRequest */, r.isForward, \"LIFECYCLER_RESUME_ACTIVITY\"); break; case ON_PAUSE: mTransactionHandler.handlePauseActivity(r, false /* finished */, false /* userLeaving */, 0 /* configChanges */, false /* autoEnteringPip */, mPendingActions, \"LIFECYCLER_PAUSE_ACTIVITY\"); break; case ON_STOP: mTransactionHandler.handleStopActivity(r, 0 /* configChanges */, mPendingActions, false /* finalStateRequest */, \"LIFECYCLER_STOP_ACTIVITY\"); break; case ON_DESTROY: mTransactionHandler.handleDestroyActivity(r, false /* finishing */, 0 /* configChanges */, false /* getNonConfigInstance */, \"performLifecycleSequence. cycling to:\" + path.get(size - 1)); break; case ON_RESTART: mTransactionHandler.performRestartActivity(r, false /* start */); break; default: throw new IllegalArgumentException(\"Unexpected lifecycle state: \" + state); &#125; &#125;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•å•Šï¼Œå°±æ˜¯éå†è¿™ä¸ªæ•°ç»„ï¼Œä¾æ¬¡æ‰§è¡Œç”Ÿå‘½å‘¨æœŸï¼Œç»“åˆæˆ‘ä»¬ä¼ å…¥çš„æ•°ç»„[ON_START]ï¼Œæœ€åä¾¿æ˜¯è°ƒç”¨ActivityThread.handleStartActivityæ–¹æ³• handleStartActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void handleStartActivity(IBinder token, PendingTransactionActions pendingActions) &#123; final ActivityClientRecord r = mActivities.get(token); final Activity activity = r.activity; ... //æ£€æŸ¥ unscheduleGcIdler(); // Start //æ‰§è¡ŒonStartç”Ÿå‘½å‘¨æœŸ activity.performStart(\"handleStartActivity\"); //è®¾ç½®ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ä¸ºonStart r.setState(ON_START); if (pendingActions == null) &#123; // No more work to do. return; &#125; // Restore instance state //ä¹‹å‰åœ¨handleLaunchActivityæ–¹æ³•ä¸­è®¾ç½®äº†pendingActions.setRestoreInstanceState(true) //è¿™é‡Œä¾¿ä¼šåˆ¤æ–­æ˜¯å¦éœ€è¦å¹¶æ‰§è¡ŒActivity.onRestoreInstanceState if (pendingActions.shouldRestoreInstanceState()) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; // Call postOnCreate() //ä¹‹å‰åœ¨handleLaunchActivityæ–¹æ³•ä¸­è®¾ç½®äº†pendingActions.setCallOnPostCreate(true) //è¿™é‡Œä¾¿ä¼šæ‰§è¡ŒActivity.onPostCreateï¼Œå¦‚æœä¸æ˜¯ä»onCreateè½¬åˆ°onStartï¼Œä¸ä¼šè¿›å…¥æ­¤case if (pendingActions.shouldCallOnPostCreate()) &#123; activity.mCalled = false; //è°ƒç”¨Activity.onPostCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //å’ŒonCreateä¸€æ ·ï¼ŒonPostCreateä¹Ÿå¿…é¡»è¦è°ƒç”¨super.onPostCreate throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; //æ›´æ–°å¯è§æ€§ //Activityå¯åŠ¨æ—¶ï¼Œç”±äºæ­¤æ—¶mDecorè¿˜æœªèµ‹å€¼ï¼Œæ‰€ä»¥ä¸ä¼šäº§ç”Ÿå½±å“ updateVisibility(r, true /* show */); mSomeActivitiesChanged = true;&#125; è¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œæˆ‘ä»¬ä¸€èˆ¬é‡å†™Activityçš„onCreateæ–¹æ³•ï¼Œåœ¨å…¶ä¸­è°ƒç”¨setContentViewæ–¹æ³•ï¼Œæ­¤æ—¶DecorViewè™½ç„¶è¢«åˆ›å»ºå‡ºæ¥äº†ï¼Œä½†æ˜¯åªåœ¨PhoneWindowä¸­æŒæœ‰ï¼Œå°šæœªç»™Activity.mDecorèµ‹å€¼ï¼Œæ‰€ä»¥æ­¤æ—¶è°ƒç”¨updateVisibilityæ–¹æ³•å¹¶ä¸ä¼šå°†DecorViewåŠ å…¥åˆ°WindowManagerä¸­ï¼Œä¹Ÿå°±æ˜¯ç›®å‰ç•Œé¢è¿˜å°šæœªå¯è§ å¦å¤–ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼ŒperformStartæ˜¯å…ˆäºcallActivityOnPostCreateï¼Œæ‰€ä»¥Activityä¸­çš„ç”Ÿå‘½å‘¨æœŸå›è°ƒonPostCreateæ˜¯åœ¨onStartä¹‹åè§¦å‘çš„ï¼Œå„ä½åœ¨å¼€å‘Appçš„æ—¶å€™ä¸è¦å¼„é”™äº†è¿™ä¸€ç‚¹ å…¶ä»–çš„åœ°æ–¹æ³¨é‡Šéƒ½å†™çš„éƒ½å¾ˆæ˜ç™½äº†å“ˆï¼Œä¹Ÿæ²¡ä»€ä¹ˆå¿…è¦å†çœ‹performStartäº†ï¼Œæ— éä¹Ÿå°±å’ŒperformCreateä¸€æ ·ï¼Œæ‰§è¡ŒActivityLifecycleCallbackså›è°ƒï¼ŒFragmentManageråˆ†å‘STARTEDçŠ¶æ€ï¼Œè°ƒç”¨onStartæ–¹æ³•ç­‰ æ¥ä¸‹æ¥æˆ‘ä»¬å†å›åˆ°TransactionExecutorä¸­ï¼Œåé¢ä¾¿æ˜¯æ‰§è¡ŒResumeActivityItemçš„executeå’ŒpostExecuteæ–¹æ³•äº† 12345public void execute(ClientTransactionHandler client, ActivityClientRecord r, PendingTransactionActions pendingActions) &#123; client.handleResumeActivity(r, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\");&#125; å¯ä»¥çœ‹åˆ°ï¼Œåˆæ‰§è¡Œäº†ActivityThread.handleResumeActivityæ–¹æ³• handleResumeActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration //æ‰§è¡ŒonResumeç”Ÿå‘½å‘¨æœŸ final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) &#123; // We didn't actually resume the activity, so skipping any follow-up actions. return; &#125; //å¦‚æœActivityå°†è¢«destroyï¼Œé‚£å°±æ²¡å¿…è¦å†æ‰§è¡Œresumeäº†ï¼Œç›´æ¥è¿”å› if (mActivitiesToBeDestroyed.containsKey(token)) &#123; // Although the activity is resumed, it is going to be destroyed. So the following // UI operations are unnecessary and also prevents exception because its token may // be gone that window manager cannot recognize it. All necessary cleanup actions // performed below will be done while handling destruction. return; &#125; final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityTaskManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; //è®¾ç½®Window if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); //DecorViewæš‚æ—¶ä¸å¯è§ decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); //ç»™Activityçš„mDecoræˆå‘˜å˜é‡èµ‹å€¼ a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; //å¦‚æœDecorViewå°šæœªæ·»åŠ åˆ°WindowManagerä¸­ï¼Œå°†å…¶æ·»åŠ è¿›å»ï¼Œå¦åˆ™æ›´æ–°Windowå±æ€§ //Activityå¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œç¬¬ä¸€æ¬¡resumeæ—¶ï¼ŒDecorViewè¿˜å°šæœªæ·»åŠ è‡³WindowManagerï¼Œæ‰€ä»¥ä¼šèµ°è¿›ä¸Šé¢è¿™ä¸ªcase //ç”±äºæˆ‘ä»¬ä¹‹å‰å°†DecorViewçš„Visibilityè®¾ç½®æˆäº†INVISIBLEï¼Œæ‰€ä»¥æ­¤æ—¶ç•Œé¢è¿˜æ˜¯ä¸å¯è§ if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; r.hideForNow = true; &#125; // Get rid of anything left hanging around. //æ¸…é™¤é—ç•™çš„ä¸œè¥¿ cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //åˆ†å‘Configurationæ›´æ–°äº‹ä»¶ if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig); r.newConfig = null; &#125; //å½“DecorView addè¿›WindowManageråï¼ŒViewRootImplè¢«åˆ›å»º ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); ... //è½¯é”®ç›˜ç›¸å…³ r.activity.mVisibleFromServer = true; mNumVisibleActivities++; //ä½¿DecorViewå¯è§ if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; //å½“ç©ºé—²æ—¶ï¼Œæ£€æŸ¥å¤„ç†å…¶ä»–åå°ActivityçŠ¶æ€ //å¯¹å¤„åœ¨stoppingæˆ–finishingçš„Activityæ‰§è¡ŒonStopæˆ–onDestroyç”Ÿå‘½å‘¨æœŸ r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler());&#125; è¿™é‡Œæœ‰ä¸‰ä¸ªé‡è¦çš„åœ°æ–¹éœ€è¦æ³¨æ„ï¼š æ‰§è¡ŒperformResumeActivityï¼Œè¿™é‡Œå’Œä¹‹å‰åˆ†æçš„ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸç±»ä¼¼ï¼Œæˆ‘ä»¬åé¢å†çœ‹ ç»™Activityçš„mDecoræˆå‘˜å˜é‡èµ‹å€¼ï¼Œå°†DecorViewæ·»åŠ åˆ°WindowManagerä¸­ï¼Œä½¿DecorViewå¯è§ å°†ä¸Šä¸€ä¸ªæ´»åŠ¨çš„ActivityClientRecordä»¥é“¾è¡¨çš„å½¢å¼ä¸²åœ¨å½“å‰ActivityClientRecordåé¢ï¼Œå‘MessageQueueæ·»åŠ ä¸€æ¡é—²æ—¶å¤„ç†æ¶ˆæ¯Idlerï¼Œè¿™æ¡æ¶ˆæ¯ä¼šéå†ActivityClientRecordçš„æ•´æ¡nextIdleé“¾ï¼Œä¾æ¬¡æ£€æŸ¥æ˜¯å¦éœ€è¦stopæˆ–destroy Activityï¼Œè¿™ä¸€ç‚¹æˆ‘ä¼šåœ¨åé¢å…³äºActivityå…¶ä»–ç”Ÿå‘½å‘¨æœŸçš„æ–‡ç« ä¸­å†åˆ†æ æ¥ä¸‹æ¥æˆ‘ä»¬ç®€å•è¿‡ä¸€ä¸‹performResumeActivityå§ 1234567891011121314151617181920212223242526272829303132333435363738394041public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest, String reason) &#123; final ActivityClientRecord r = mActivities.get(token); ... //çŠ¶æ€æ£€æŸ¥ //ä¸ºæœ€ç»ˆç”Ÿå‘½å‘¨æœŸçŠ¶æ€ if (finalStateRequest) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; try &#123; r.activity.onStateNotSaved(); //æ ‡è®°FragmentsçŠ¶æ€ä¸ºæœªä¿å­˜ r.activity.mFragments.noteStateNotSaved(); //æ›´æ–°ç½‘ç»œçŠ¶æ€ checkAndBlockForNetworkAccess(); if (r.pendingIntents != null) &#123; deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; &#125; if (r.pendingResults != null) &#123; deliverResults(r, r.pendingResults, reason); r.pendingResults = null; &#125; //æ‰§è¡ŒActivity.onResumeç”Ÿå‘½å‘¨æœŸ r.activity.performResume(r.startsNotResumed, reason); //å°†ä¿å­˜ä¿¡æ¯çš„savedInstanceStateå’ŒpersistentStateé‡ç½®ä¸ºnull r.state = null; r.persistentState = null; //è®¾ç½®ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ r.setState(ON_RESUME); //å›è°ƒActivity.onTopResumedActivityChangedï¼ŒæŠ¥å‘Šæ ˆé¡¶æ´»åŠ¨Activityå‘ç”Ÿå˜åŒ– reportTopResumedActivityChanged(r, r.isTopResumedActivity, \"topWhenResuming\"); &#125; catch (Exception e) &#123; ... &#125; return r;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void performResume(boolean followedByPause, String reason) &#123; //å›è°ƒActivityLifecycleCallbacks.onActivityPreResumed dispatchActivityPreResumed(); //æ‰§è¡ŒonRestartç”Ÿå‘½å‘¨æœŸ //å†…éƒ¨ä¼šåˆ¤æ–­å½“å‰Activityæ˜¯å¦ä¸ºstopçŠ¶æ€ï¼Œæ˜¯çš„è¯æ‰ä¼šçœŸæ­£æ‰§è¡ŒonRestartç”Ÿå‘½å‘¨æœŸ //å¯åŠ¨Activityç¬¬ä¸€æ¬¡resumeæ—¶ä¸ä¼šè¿›å…¥onRestartç”Ÿå‘½å‘¨æœŸ performRestart(true /* start */, reason); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; ... //è‡ªåŠ¨å¡«å……åŠŸèƒ½ mCalled = false; // mResumed is set by the instrumentation //æ‰§è¡ŒActivity.onResumeå›è°ƒ mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; //å¿…é¡»æ‰§è¡Œsuper.onResumeæ–¹æ³• throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onResume()\"); &#125; // invisible activities must be finished before onResume() completes ... //å¼‚å¸¸æ£€æŸ¥ // Now really resume, and install the current status bar and menu. mCalled = false; //FragmentManageråˆ†å‘resumeçŠ¶æ€ mFragments.dispatchResume(); mFragments.execPendingActions(); //æ‰§è¡ŒonPostResumeå›è°ƒ onPostResume(); if (!mCalled) &#123; //å¿…é¡»è¦æ‰§è¡Œsuper.onPostResume throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPostResume()\"); &#125; //å›è°ƒActivityLifecycleCallbacks.onActivityPostResumed dispatchActivityPostResumed();&#125; 12345678910protected void onResume() &#123; //å›è°ƒActivityLifecycleCallbacks.onActivityResumed dispatchActivityResumed(); //å…±äº«å…ƒç´ åŠ¨ç”» mActivityTransitionState.onResume(this); ... //è‡ªåŠ¨å¡«å……åŠŸèƒ½ notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_RESUME); mCalled = true;&#125; å¯ä»¥çœ‹åˆ°ï¼ŒåŸºæœ¬ä¸Šå’Œä¹‹å‰çš„ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸçš„æ‰§è¡Œæ˜¯ä¸€ä¸ªå¥—è·¯ï¼Œå”¯ä¸€éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨æ‰§è¡ŒonResumeç”Ÿå‘½å‘¨æœŸä¹‹å‰ï¼Œä¼šå…ˆæ£€æŸ¥Activityæ˜¯å¦å¤„åœ¨stopçŠ¶æ€ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œåˆ™ä¼šå…ˆæ‰§è¡ŒonRestartç”Ÿå‘½å‘¨æœŸï¼Œå…¶ä»–åœ°æ–¹æˆ‘åœ¨æ³¨é‡Šä¸Šæ ‡æ³¨çš„åº”è¯¥å·²ç»å¾ˆæ˜ç™½äº†ï¼Œè¿™é‡Œå°±ä¸å†å¤šè®²äº† ä¸è¦å¿˜äº†ï¼Œåœ¨TransactionExecutorä¸­è¿˜æœ‰æœ€åä¸€æ­¥ResumeActivityItem.postExecuteæ²¡åš 123456789public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; try &#123; // TODO(lifecycler): Use interface callback instead of AMS. ActivityTaskManager.getService().activityResumed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; è¿™é‡Œé€šè¿‡Binderåˆå›åˆ°äº†ç³»ç»Ÿè¿›ç¨‹è°ƒç”¨äº†ATMS.activityResumedæ–¹æ³• 1234567public final void activityResumed(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (mGlobalLock) &#123; ActivityRecord.activityResumedLocked(token); &#125; Binder.restoreCallingIdentity(origId);&#125; 12345678910111213141516static void activityResumedLocked(IBinder token, boolean handleSplashScreenExit) &#123; final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r == null) &#123; // If an app reports resumed after a long delay, the record on server side might have // been removed (e.g. destroy timeout), so the token could be null. return; &#125; //SplashScreen r.setCustomizeSplashScreenExitAnimation(handleSplashScreenExit); //é‡ç½®savedState Bundle r.setSavedState(null /* savedState */); r.mDisplayContent.handleActivitySizeCompatModeIfNeeded(r); //é˜²é—ªçƒåŠŸèƒ½ r.mDisplayContent.mUnknownAppVisibilityController.notifyAppResumedFinished(r);&#125; å¯ä»¥çœ‹åˆ°ï¼Œæœ€åä¹Ÿå°±åšäº†ä¸€äº›æ”¶å°¾å·¥ä½œï¼Œåˆ°è¿™é‡Œï¼Œæ•´ä¸ªActivityçš„å¯åŠ¨æµç¨‹ä¹Ÿå°±åœ†æ»¡ç»“æŸäº† ç»“å°¾è‡³æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬Activityå¯åŠ¨æµç¨‹ä¸‰éƒ¨è¿ç»­å‰§ç»ˆäºæ˜¯åœ†æ»¡å®Œæˆäº†ï¼Œå†æ—¶æ•´æ•´åŠå¹´çš„æ—¶é—´ï¼Œæˆ‘å¿ƒé‡Œå‹ç€çš„è¿™å—çŸ³å¤´ä¹Ÿç»ˆäºæ˜¯è½åœ°äº†ï¼Œåé¢æˆ‘åº”è¯¥ä¼šå†åšä¸€äº›å…³äºActivityå…¶ä»–ç”Ÿå‘½å‘¨æœŸå˜æ¢çš„åˆ†æï¼Œæ¯”å¦‚è¯´Activityæ˜¯æ€æ ·é”€æ¯çš„ï¼Œæ¬¢è¿æ„Ÿå…´è¶£çš„å°ä¼™ä¼´ç‚¹èµã€æ”¶è—ã€å…³æ³¨æˆ‘","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"}]},{"title":"Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰","date":"2022-10-24T06:49:22.000Z","updated":"2023-02-26T10:34:30.148Z","comments":true,"path":"2022/10/24/android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸­ï¼‰/","link":"","permalink":"http://yoursite.com/2022/10/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç«  Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰ ä¸­ï¼Œæˆ‘ä»¬åˆ†æäº†Activityå¯åŠ¨æµç¨‹ä¸­çš„ä¸€å°éƒ¨åˆ†ï¼ŒåŸºæœ¬ä¸Šå¯ä»¥ç®—æ˜¯Activityå¯åŠ¨çš„å‰ç½®å‡†å¤‡å·¥ä½œï¼Œè¿™ç¯‡æ–‡ç« æˆ‘ä»¬å°†ä¼šåˆ†æAppè¿›ç¨‹å¯åŠ¨çš„ä¸»è¦æµç¨‹ å¯åŠ¨Appè¿›ç¨‹å‡†å¤‡ProcessRecordä¸Šç¯‡æ–‡ç« ä¸­æˆ‘ä»¬è¯´è¿‡äº†ï¼Œå¦‚æœAppå°šæœªå¯åŠ¨ï¼Œåˆ™ä¼šè°ƒç”¨ATMSçš„startProcessAsyncæ–¹æ³•å»å¯åŠ¨Appè¿›ç¨‹ 1234567891011121314void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop, String hostingType) &#123; try &#123; ... // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess, mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead, isTop, hostingType, activity.intent.getComponent()); mH.sendMessage(m); &#125; finally &#123; ... &#125;&#125; è¿™ä¸ªæ–¹æ³•å®é™…ä¸Šæ˜¯é€šè¿‡Handerè°ƒç”¨äº†ActivityManagerInternal (AMS.LocalService)çš„startProcessæ–¹æ³• 123456789101112131415161718@Overridepublic void startProcess(String processName, ApplicationInfo info, boolean knownToBeDead, boolean isTop, String hostingType, ComponentName hostingName) &#123;try &#123; ... synchronized (ActivityManagerService.this) &#123; // If the process is known as top app, set a hint so when the process is // started, the top priority can be applied immediately to avoid cpu being // preempted by other processes before attaching the process of top app. startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */, new HostingRecord(hostingType, hostingName, isTop), ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, false /* allowWhileBooting */, false /* isolated */, true /* keepIfLarge */); &#125;&#125; finally &#123; ...&#125;&#125; è¿™é‡Œå°†è¿›ç¨‹å¯åŠ¨çš„ä¸€äº›ä¿¡æ¯å°è£…åˆ°äº†HostingRecordç±»ä¸­ 123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123;return mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125; AMSå°†å¯åŠ¨è¿›ç¨‹çš„ä»»åŠ¡è½¬äº¤ç»™äº†ProcessListï¼Œè¿™ä¸ªç±»çš„èŒè´£æ˜¯ç®¡ç†è¿›ç¨‹ï¼ŒåŒ…æ‹¬ç®¡ç†è¿›ç¨‹ä¼˜å…ˆçº§(Adj)ã€è¿›ç¨‹OOMç­‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; long startTime = SystemClock.uptimeMillis(); ProcessRecord app; if (!isolated) &#123; //å…ˆé€šè¿‡è¿›ç¨‹åå’ŒuidæŸ¥æ‰¾ç›¸åº”Appçš„ProcessRecord app = getProcessRecordLocked(processName, info.uid, keepIfLarge); //å¦‚æœæ˜¯ç”±åå°è¿›ç¨‹å‘èµ·çš„ startProcess //åˆ¤æ–­å¯åŠ¨è¿›ç¨‹æ˜¯å¦ä¸º bad processï¼Œå¦‚æœæ˜¯ï¼Œç›´æ¥å¯åŠ¨å¤±è´¥è¿”å› //è¿™é‡Œ bad process çš„å®šä¹‰ä¸ºï¼šçŸ­æ—¶é—´å†…è¿ç»­å´©æºƒä¸¤æ¬¡ä»¥ä¸Šçš„è¿›ç¨‹ if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != 0) &#123; // If we are in the background, then check to see if this process // is bad. If so, we will just silently fail. if (mService.mAppErrors.isBadProcessLocked(info)) &#123; return null; &#125; &#125; else &#123; // When the user is explicitly starting a process, then clear its // crash count so that we won't make it bad until they see at // least one crash dialog again, and make the process good again // if it had been bad. //å¦‚æœæ˜¯ç”¨æˆ·æ˜¾å¼çš„è¦æ±‚å¯åŠ¨è¿›ç¨‹ï¼Œåˆ™ä¼šæ¸…ç©ºå¯åŠ¨è¿›ç¨‹çš„å´©æºƒæ¬¡æ•°ï¼Œå°†å¯åŠ¨è¿›ç¨‹ä» bad process åˆ—è¡¨ä¸­ç§»é™¤ mService.mAppErrors.resetProcessCrashTimeLocked(info); if (mService.mAppErrors.isBadProcessLocked(info)) &#123; EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, UserHandle.getUserId(info.uid), info.uid, info.processName); mService.mAppErrors.clearBadProcessLocked(info); if (app != null) &#123; app.bad = false; &#125; &#125; &#125; &#125; else &#123; // If this is an isolated process, it can't re-use an existing process. app = null; &#125; // We don't have to do anything more if: // (1) There is an existing application record; and // (2) The caller doesn't think it is dead, OR there is no thread // object attached to it so we know it couldn't have crashed; and // (3) There is a pid assigned to it, so it is either starting or // already running. ProcessRecord precedence = null; //å¦‚æœå·²ç»å­˜åœ¨äº†å¯¹åº”Appçš„ProcessRecordï¼Œå¹¶ä¸”åˆ†é…äº†pid if (app != null &amp;&amp; app.pid &gt; 0) &#123; //å¦‚æœè¿›ç¨‹æ²¡æœ‰æ­»äº¡æˆ–è€…è¿›ç¨‹è¿˜æœªç»‘å®šbinderçº¿ç¨‹ï¼Œè¯´æ˜è¿›ç¨‹æ˜¯æ­£å¸¸è¿è¡ŒçŠ¶æ€æˆ–æ­£åœ¨å¯åŠ¨ä¸­ if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123; // We already have the app running, or are waiting for it to // come up (we have a pid but not yet its thread), so keep it. // If this is a new package in the process, add the package to the list //å°†è¦å¯åŠ¨çš„åŒ…ä¿¡æ¯è®°å½•åœ¨ProcessRecordä¸­ï¼ˆAndroidå¤šä¸ªAppå¯ä»¥è¿è¡Œåœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­ï¼‰ app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats); return app; &#125; // An application record is attached to a previous process, // clean it up now. //Appç»‘å®šåœ¨ä¹‹å‰çš„ä¸€ä¸ªè¿›ç¨‹ä¸Šäº†ï¼Œæ€æ­»å¹¶æ¸…ç†è¿™ä¸ªè¿›ç¨‹ ProcessList.killProcessGroup(app.uid, app.pid); Slog.wtf(TAG_PROCESSES, app.toString() + \" is attached to a previous process\"); // We are not going to re-use the ProcessRecord, as we haven't dealt with the cleanup // routine of it yet, but we'd set it as the precedence of the new process. precedence = app; app = null; &#125; //æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„ProcessRecord if (app == null) &#123; //æ–°åˆ›å»ºä¸€ä¸ªProcessRecordå¯¹è±¡ app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord); if (app == null) &#123; Slog.w(TAG, \"Failed making new process record for \" + processName + \"/\" + info.uid + \" isolated=\" + isolated); return null; &#125; app.crashHandler = crashHandler; app.isolatedEntryPoint = entryPoint; app.isolatedEntryPointArgs = entryPointArgs; if (precedence != null) &#123; app.mPrecedence = precedence; precedence.mSuccessor = app; &#125; &#125; else &#123; //å­˜åœ¨å¯¹åº”çš„ProcessRecordï¼Œä½†è¿›ç¨‹å°šæœªå¯åŠ¨æˆ–å·²è¢«æ¸…ç† // If this is a new package in the process, add the package to the list //å°†è¦å¯åŠ¨çš„åŒ…ä¿¡æ¯è®°å½•åœ¨ProcessRecordä¸­ app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats); &#125; // If the system is not ready yet, then hold off on starting this // process until it is. //å¦‚æœç³»ç»Ÿå°šæœªå‡†å¤‡å¥½ï¼ˆå¼€æœºä¸­æˆ–system_serverè¿›ç¨‹å´©æºƒé‡å¯ä¸­ï¼‰ï¼Œå°†å…¶å…ˆæ·»åŠ åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ if (!mService.mProcessesReady &amp;&amp; !mService.isAllowedWhileBooting(info) &amp;&amp; !allowWhileBooting) &#123; if (!mService.mProcessesOnHold.contains(app)) &#123; mService.mProcessesOnHold.add(app); &#125; return app; &#125; final boolean success = startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride); return success ? app : null;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯å¤„ç†ProcessRecordå¯¹è±¡ï¼Œå¦‚æœæ‰¾ä¸åˆ°å¯¹åº”çš„ProcessRecordæˆ–å¯¹åº”çš„ProcessRecordé‡Œçš„ä¿¡æ¯è¡¨æ˜Appè¿›ç¨‹å°šæœªå¯åŠ¨ï¼Œåˆ™ä¼šè°ƒç”¨å¦ä¸€ä¸ªstartProcessLockedé‡è½½æ–¹æ³•å¯åŠ¨è¿›ç¨‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159final boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags, String abiOverride) &#123; return startProcessLocked(app, hostingRecord, zygotePolicyFlags, false /* disableHiddenApiChecks */, false /* disableTestApiChecks */, false /* mountExtStorageFull */, abiOverride);&#125;boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks, boolean mountExtStorageFull, String abiOverride) &#123; //è¿›ç¨‹æ­£åœ¨å¯åŠ¨ä¸­ if (app.pendingStart) &#123; return true; &#125; //ä»åˆšæ‰æ–¹æ³•ä¸­çš„åˆ¤æ–­æ¥çœ‹ï¼Œåº”è¯¥ä¸ä¼šè¿›å…¥è¿™ä¸ªcase if (app.pid &gt; 0 &amp;&amp; app.pid != ActivityManagerService.MY_PID) &#123; //å°†ProcessRecordçš„pidä»PidMapä¸­ç§»é™¤ mService.removePidLocked(app); app.bindMountPending = false; //å°†ProcessRecordçš„pidé‡ç½®ä¸º0 app.setPid(0); app.startSeq = 0; &#125; //å°†ProcessRecordä»å¯åŠ¨ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤ mService.mProcessesOnHold.remove(app); mService.updateCpuStats(); try &#123; try &#123; //æ£€æµ‹å½“å‰ç”¨æˆ·æ˜¯å¦å¯ä»¥å¯åŠ¨è¿™ä¸ªApp final int userId = UserHandle.getUserId(app.uid); AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; int uid = app.uid; int[] gids = null; //é»˜è®¤ä¸æŒ‚è½½å¤–ç½®å­˜å‚¨ int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; int[] permGids = null; try &#123; final IPackageManager pm = AppGlobals.getPackageManager(); //è·å–GIDSï¼ˆAppç”³è¯·çš„æƒé™ï¼‰ permGids = pm.getPackageGids(app.info.packageName, MATCH_DIRECT_BOOT_AUTO, app.userId); if (StorageManager.hasIsolatedStorage() &amp;&amp; mountExtStorageFull) &#123; //æŒ‚è½½å¤–ç½®å­˜å‚¨ï¼Œå…è®¸è¯»å†™ mountExternal = Zygote.MOUNT_EXTERNAL_FULL; &#125; else &#123; StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); //è·å–Appå¯¹å¤–ç½®å­˜å‚¨çš„è¯»å†™æƒé™ mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName); &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; // Remove any gids needed if the process has been denied permissions. // NOTE: eventually we should probably have the package manager pre-compute // this for us? //ä»åˆšåˆšè¿‡å»çš„Appç”³è¯·æƒé™ä¸­å‰”é™¤è¿›ç¨‹æ‰€è¢«æ‹’ç»çš„æƒé™ if (app.processInfo != null &amp;&amp; app.processInfo.deniedPermissions != null) &#123; for (int i = app.processInfo.deniedPermissions.size() - 1; i &gt;= 0; i--) &#123; int[] denyGids = mService.mPackageManagerInt.getPermissionGids( app.processInfo.deniedPermissions.valueAt(i), app.userId); if (denyGids != null) &#123; for (int gid : denyGids) &#123; permGids = ArrayUtils.removeInt(permGids, gid); &#125; &#125; &#125; &#125; //è®¡ç®—å¾—å‡ºè¿›ç¨‹æ‰€åº”æ‹¥æœ‰çš„æ‰€æœ‰æƒé™ gids = computeGidsForProcess(mountExternal, uid, permGids); &#125; //è®¾ç½®æŒ‚è½½æ¨¡å¼ app.mountMode = mountExternal; //å·¥å‚æµ‹è¯•è¿›ç¨‹ if (mService.mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) &#123; uid = 0; &#125; //è¿›ç¨‹å¯åŠ¨å‚æ•°ï¼ˆä¼ é€’åˆ°Zygotoï¼‰ int runtimeFlags = 0; //å¦‚æœmanifestä¸­è®¾ç½®äº†android:debuggable if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP; runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE; // Also turn on CheckJNI for debuggable apps. It's quite // awkward to turn on otherwise. runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI; // Check if the developer does not want ART verification if (android.provider.Settings.Global.getInt(mService.mContext.getContentResolver(), android.provider.Settings.Global.ART_VERIFIER_VERIFY_DEBUGGABLE, 1) == 0) &#123; runtimeFlags |= Zygote.DISABLE_VERIFIER; Slog.w(TAG_PROCESSES, app + \": ART verification disabled\"); &#125; &#125; ... //è®¾ç½®å„ç§é«˜è¿›ç¨‹å¯åŠ¨å‚æ•° String invokeWith = null; //å¦‚æœmanifestä¸­è®¾ç½®äº†android:debuggable //ä½¿ç”¨logwrapperå·¥å…·æ•è·stdoutä¿¡æ¯ if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; // Debuggable apps may include a wrapper script with their library directory. String wrapperFileName = app.info.nativeLibraryDir + \"/wrap.sh\"; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); try &#123; if (new File(wrapperFileName).exists()) &#123; invokeWith = \"/system/bin/logwrapper \" + wrapperFileName; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(oldPolicy); &#125; &#125; //ç¡®å®šAppè¿›ç¨‹ä½¿ç”¨çš„abiï¼ˆæœ‰soåº“çš„Appä¼šé€šè¿‡soåº“çš„æ¶æ„å†³å®šï¼Œæ²¡æœ‰soåº“çš„ä½¿ç”¨ç³»ç»Ÿæœ€ä¼˜å…ˆæ”¯æŒçš„abiï¼‰ String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) &#123; requiredAbi = Build.SUPPORTED_ABIS[0]; &#125; //å°†abiè½¬æˆInstructionSet String instructionSet = null; if (app.info.primaryCpuAbi != null) &#123; instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); &#125; app.gids = gids; app.setRequiredAbi(requiredAbi); app.instructionSet = instructionSet; ... final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? \"\" : app.info.seInfoUser); // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. //é‡è¦ï¼šè®¾ç½®è¿›ç¨‹å¯åŠ¨å…¥å£ final String entryPoint = \"android.app.ActivityThread\"; //å¯åŠ¨è¿›ç¨‹ return startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); &#125; catch (RuntimeException e) &#123; ... mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, app.userId, \"start failure\"); return false; &#125;&#125; åˆ°è¿™ä¸€æ­¥ä½ç½®ä»ç„¶æ˜¯åœ¨è¿›è¡Œå‡†å¤‡å·¥ä½œï¼Œä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š æƒé™å¤„ç†ï¼šAppå®‰è£…æ—¶ä¼šæ£€æµ‹manifesté‡Œç”³è¯·çš„æƒé™ï¼Œå¹¶ç”±æ­¤ç”Ÿæˆå‡ºä¸€ä¸ªGIDSæ•°ç»„ è®¾ç½®æŒ‚è½½æ¨¡å¼ è®¾ç½®è¿›ç¨‹çš„å„ç§å¯åŠ¨å‚æ•° è®¾ç½®Appè¿›ç¨‹ä½¿ç”¨çš„abi è®¾ç½®è¿›ç¨‹å¯åŠ¨å…¥å£ ç»§ç»­è°ƒç”¨é‡è½½æ–¹æ³•å¯åŠ¨è¿›ç¨‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; //åˆå§‹åŒ–ä¸€äº›å‚æ•° //æ ‡è¯†Appè¿›ç¨‹æ­£åœ¨å¯åŠ¨ app.pendingStart = true; app.killedByAm = false; app.removed = false; app.killed = false; app.mDisabledCompatChanges = null; if (mPlatformCompat != null) &#123; app.mDisabledCompatChanges = mPlatformCompat.getDisabledChanges(app.info); &#125; final long startSeq = app.startSeq = ++mProcStartSeqCounter; app.setStartParams(uid, hostingRecord, seInfo, startTime); app.setUsingWrapper(invokeWith != null || Zygote.getWrapProperty(app.processName) != null); //å°†ProcessRecordæ·»åŠ åˆ°å¾…å¯åŠ¨åˆ—è¡¨ä¸­ mPendingStarts.put(startSeq, app); if (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123; //å¼‚æ­¥å¯åŠ¨è¿›ç¨‹ if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES, \"Posting procStart msg for \" + app.toShortString()); mService.mProcStartHandler.post(() -&gt; handleProcessStart( app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal, requiredAbi, instructionSet, invokeWith, startSeq)); return true; &#125; else &#123; //åŒæ­¥å¯åŠ¨è¿›ç¨‹ try &#123; final Process.ProcessStartResult startResult = startProcess(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); &#125; catch (RuntimeException e) &#123; //å‡ºé”™ï¼Œå°†pendingStartæ ‡å¿—å¤ä½å¹¶å¼ºè¡Œåœæ­¢è¿›ç¨‹ app.pendingStart = false; mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, app.userId, \"start failure\"); &#125; return app.pid &gt; 0; &#125;&#125; åœ¨å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œç¨‹åºä¼šç­‰å¾…ProcessRecord.mPrecedenceè¿›ç¨‹ç»“æŸæ‰ä¼šå¯åŠ¨è¿›ç¨‹ï¼ˆè¿™é‡Œå¯¹åº”ç€æœ€å¼€å§‹çš„startProcessLockedæ–¹æ³•ä¸­ï¼Œå·²ç»å­˜åœ¨äº†å¯¹åº”Appçš„ProcessRecordï¼Œå¹¶ä¸”åˆ†é…äº†pidï¼Œä½†æ˜¯è¿›ç¨‹è¢«æ ‡è®°ä¸ºæ­»äº¡è¿™ç§æƒ…å†µï¼‰ æœ€ç»ˆéƒ½ä¼šè¿›å…¥åˆ°startProcesså’ŒhandleProcessStartedLockedæ–¹æ³•ä¸­æ¥ startProcess123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; try &#123; final boolean isTopApp = hostingRecord.isTopApp(); if (isTopApp) &#123; // Use has-foreground-activities as a temporary hint so the current scheduling // group won't be lost when the process is attaching. The actual state will be // refreshed when computing oom-adj. app.setHasForegroundActivities(true); &#125; //å¤„ç†åº”ç”¨ç›®å½•éš”ç¦»æœºåˆ¶ Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap; Map&lt;String, Pair&lt;String, Long&gt;&gt; whitelistedAppDataInfoMap; boolean bindMountAppStorageDirs = false; boolean bindMountAppsData = mAppDataIsolationEnabled &amp;&amp; (UserHandle.isApp(app.uid) || UserHandle.isIsolated(app.uid)) &amp;&amp; mPlatformCompat.isChangeEnabled(APP_DATA_DIRECTORY_ISOLATION, app.info); // Get all packages belongs to the same shared uid. sharedPackages is empty array // if it doesn't have shared uid. final PackageManagerInternal pmInt = mService.getPackageManagerInternalLocked(); final String[] sharedPackages = pmInt.getSharedUserPackagesForPackage( app.info.packageName, app.userId); final String[] targetPackagesList = sharedPackages.length == 0 ? new String[]&#123;app.info.packageName&#125; : sharedPackages; pkgDataInfoMap = getPackageAppDataInfoMap(pmInt, targetPackagesList, uid); if (pkgDataInfoMap == null) &#123; // TODO(b/152760674): Handle inode == 0 case properly, now we just give it a // tmp free pass. bindMountAppsData = false; &#125; // Remove all packages in pkgDataInfoMap from mAppDataIsolationWhitelistedApps, so // it won't be mounted twice. final Set&lt;String&gt; whitelistedApps = new ArraySet&lt;&gt;(mAppDataIsolationWhitelistedApps); for (String pkg : targetPackagesList) &#123; whitelistedApps.remove(pkg); &#125; whitelistedAppDataInfoMap = getPackageAppDataInfoMap(pmInt, whitelistedApps.toArray(new String[0]), uid); if (whitelistedAppDataInfoMap == null) &#123; // TODO(b/152760674): Handle inode == 0 case properly, now we just give it a // tmp free pass. bindMountAppsData = false; &#125; int userId = UserHandle.getUserId(uid); StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); if (needsStorageDataIsolation(storageManagerInternal, app)) &#123; bindMountAppStorageDirs = true; if (pkgDataInfoMap == null || !storageManagerInternal.prepareStorageDirs(userId, pkgDataInfoMap.keySet(), app.processName)) &#123; // Cannot prepare Android/app and Android/obb directory or inode == 0, // so we won't mount it in zygote, but resume the mount after unlocking device. app.bindMountPending = true; bindMountAppStorageDirs = false; &#125; &#125; // If it's an isolated process, it should not even mount its own app data directories, // since it has no access to them anyway. if (app.isolated) &#123; pkgDataInfoMap = null; whitelistedAppDataInfoMap = null; &#125; final Process.ProcessStartResult startResult; if (hostingRecord.usesWebviewZygote()) &#123; startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, app.mDisabledCompatChanges, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else if (hostingRecord.usesAppZygote()) &#123; final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app); // We can't isolate app data and storage data as parent zygote already did that. startResult = appZygote.getProcess().start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, /*zygotePolicyFlags=*/ ZYGOTE_POLICY_FLAG_EMPTY, isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap, false, false, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else &#123; //æ²¡æœ‰ç‰¹åˆ«æŒ‡å®šhostingZygoteæ—¶ï¼Œè¿›å…¥æ­¤case startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags, isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; return startResult; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; ä»Android 11å¼€å§‹å¼•å…¥äº†åº”ç”¨ç›®å½•éš”ç¦»æœºåˆ¶ï¼Œä½¿å¾—åº”ç”¨ä»…å¯ä»¥å‘ç°å’Œè®¿é—®è‡ªå·±çš„å‚¨å­˜ç›®å½•ï¼Œä¸å¯ä»¥è®¿é—®å…¶ä»–åº”ç”¨çš„å‚¨å­˜ç›®å½• è¿™é‡Œå¤„ç†å®Œåº”ç”¨ç›®å½•éš”ç¦»æœºåˆ¶åï¼Œè°ƒç”¨äº†Process.startæ–¹æ³•å¯åŠ¨è¿›ç¨‹ï¼Œæœ€ç»ˆèµ°åˆ°ZygoteProcess.startViaZygoteæ–¹æ³• å‘zygotoå‘é€socketè¯·æ±‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap, @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt; allowlistedDataInfoList, boolean bindMountAppsData, boolean bindMountAppStorageDirs, @Nullable String[] extraArgs) throws ZygoteStartFailedEx &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); argsForZygote.add(\"--runtime-flags=\" + runtimeFlags); if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123; argsForZygote.add(\"--mount-external-installer\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123; argsForZygote.add(\"--mount-external-pass-through\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123; argsForZygote.add(\"--mount-external-android-writable\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; final StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); final int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; if (invokeWith != null) &#123; argsForZygote.add(\"--invoke-with\"); argsForZygote.add(invokeWith); &#125; if (startChildZygote) &#123; argsForZygote.add(\"--start-child-zygote\"); &#125; if (packageName != null) &#123; argsForZygote.add(\"--package-name=\" + packageName); &#125; if (isTopApp) &#123; argsForZygote.add(Zygote.START_AS_TOP_APP_ARG); &#125; if (pkgDataInfoMap != null &amp;&amp; pkgDataInfoMap.size() &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(Zygote.PKG_DATA_INFO_MAP); sb.append(\"=\"); boolean started = false; for (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123; if (started) &#123; sb.append(','); &#125; started = true; sb.append(entry.getKey()); sb.append(','); sb.append(entry.getValue().first); sb.append(','); sb.append(entry.getValue().second); &#125; argsForZygote.add(sb.toString()); &#125; if (allowlistedDataInfoList != null &amp;&amp; allowlistedDataInfoList.size() &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(Zygote.ALLOWLISTED_DATA_INFO_MAP); sb.append(\"=\"); boolean started = false; for (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : allowlistedDataInfoList.entrySet()) &#123; if (started) &#123; sb.append(','); &#125; started = true; sb.append(entry.getKey()); sb.append(','); sb.append(entry.getValue().first); sb.append(','); sb.append(entry.getValue().second); &#125; argsForZygote.add(sb.toString()); &#125; if (bindMountAppStorageDirs) &#123; argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS); &#125; if (bindMountAppsData) &#123; argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS); &#125; if (disabledCompatChanges != null &amp;&amp; disabledCompatChanges.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--disabled-compat-changes=\"); int sz = disabledCompatChanges.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(disabledCompatChanges[i]); &#125; argsForZygote.add(sb.toString()); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; Collections.addAll(argsForZygote, extraArgs); &#125; synchronized(mLock) &#123; // The USAP pool can not be used if the application will not use the systems graphics // driver. If that driver is requested use the Zygote application start path. return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote); &#125;&#125; è¿™ä¸ªæ–¹æ³•çš„åŠŸèƒ½å°±å¾ˆç®€å•äº†ï¼Œå°±æ˜¯å°†å„ç§å‚æ•°æ‹¼è£…èµ·æ¥ï¼Œç„¶åè°ƒç”¨zygoteSendArgsAndGetResultæ–¹æ³• æˆ‘ä»¬å…ˆçœ‹openZygoteSocketIfNeededè¿™ä¸ªæ–¹æ³•ï¼Œå®ƒè¿”å›äº†ä¸€ä¸ªZygoteStateå¯¹è±¡ï¼Œè¿™ä¸ªç±»æ˜¯å¯¹ä¸ZygoteServerSocketå»ºç«‹è¿æ¥åçš„å°è£… 1234567891011121314151617181920212223242526private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; try &#123; //å°è¯•è¿æ¥ä¸»ZygoteServerSocket attemptConnectionToPrimaryZygote(); //ä¸»zygoteè¿›ç¨‹æ”¯æŒæ­¤abi if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; if (mZygoteSecondarySocketAddress != null) &#123; // The primary zygote didn't match. Try the secondary. //å°è¯•è¿æ¥è¾…ZygoteServerSocket attemptConnectionToSecondaryZygote(); //è¾…zygoteè¿›ç¨‹æ”¯æŒæ­¤abi if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; &#125; &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to zygote\", ioe); &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; attemptConnectionToxxxZygoteæ–¹æ³•ä½¿ç”¨LocalSocketè¿›è¡Œè¿æ¥ï¼Œå¹¶è¿”å›ä¸€ä¸ªZygoteStateå°è£…å¯¹è±¡ æˆ‘ä»¬ä¹‹å‰åœ¨ Androidæºç åˆ†æ - Zygoteè¿›ç¨‹ ä¸­è¯´è¿‡ï¼Œä¸€èˆ¬ï¼Œ64ä½çš„cpuä¼šå¯åŠ¨ä¸¤ä¸ªzygotoè¿›ç¨‹ï¼Œä¸€ä¸ª64ä½ï¼ˆä¸»zygoteï¼‰ï¼Œä¸€ä¸ª32ä½ï¼ˆè¾…zygoteï¼‰ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹zygoteSendArgsAndGetResultæ–¹æ³• 123456789101112131415161718192021222324252627282930313233private Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, int zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; ... /* * See com.android.internal.os.ZygoteArguments.parseArgs() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ //æ„å»ºå‡ºç¬¦åˆzygoteè§£æè§„åˆ™çš„å‚æ•°ï¼ˆargc + argvï¼‰ String msgStr = args.size() + \"\\n\" + String.join(\"\\n\", args) + \"\\n\"; //USAPæœºåˆ¶ if (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123; try &#123; return attemptUsapSendArgsAndGetResult(zygoteState, msgStr); &#125; catch (IOException ex) &#123; // If there was an IOException using the USAP pool we will log the error and // attempt to start the process through the Zygote. Log.e(LOG_TAG, \"IO Exception while communicating with USAP pool - \" + ex.getMessage()); &#125; &#125; return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);&#125; USAPæœºåˆ¶æˆ‘ä»¬å…ˆè·³è¿‡ï¼Œè¿™ä¸ªæ–¹æ³•å°±åšäº†ä¸€ä»¶äº‹ï¼šæ‹¼è£…å‚æ•°ï¼Œç„¶åè°ƒç”¨attemptZygoteSendArgsAndGetResultæ–¹æ³• 12345678910111213141516171819202122232425262728private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult( ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx &#123; try &#123; final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter; final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream; zygoteWriter.write(msgStr); zygoteWriter.flush(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. Process.ProcessStartResult result = new Process.ProcessStartResult(); result.pid = zygoteInputStream.readInt(); result.usingWrapper = zygoteInputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); Log.e(LOG_TAG, \"IO Exception while communicating with Zygote - \" + ex.toString()); throw new ZygoteStartFailedEx(ex); &#125;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆæ˜æ˜¾å°±èƒ½çœ‹å‡ºæ¥ï¼Œè¿™æ˜¯ä¸€æ¬¡socketé€šä¿¡å‘é€ -&gt; æ¥æ”¶ å…·ä½“zygoteè¿›ç¨‹æ¥æ”¶åˆ°socketååšäº†ä»€ä¹ˆå¯ä»¥å›é¡¾æˆ‘ä¹‹å‰å†™çš„æ–‡ç«  Androidæºç åˆ†æ - Zygoteè¿›ç¨‹ handleProcessStartedLockedå‘zygoteå‘é€å®Œsocketè¯·æ±‚åï¼Œzygoteå¼€å§‹forkAppè¿›ç¨‹ï¼Œforkå®Œåä¼šå°†Appè¿›ç¨‹çš„pidå’ŒusingWrapperä¿¡æ¯å†é€šè¿‡socketä¼ å›system_serverï¼Œæ­¤æ—¶ç¨‹åºä¼šç»§ç»­æ‰§è¡ŒhandleProcessStartedLockedæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper, long expectedStartSeq, boolean procAttached) &#123; //ä»å¾…å¯åŠ¨åˆ—è¡¨ä¸­ç§»é™¤æ­¤ProcessRecord mPendingStarts.remove(expectedStartSeq); final String reason = isProcStartValidLocked(app, expectedStartSeq); //æœªé€šè¿‡è¿›ç¨‹å¯åŠ¨éªŒè¯ï¼Œæ€æ­»è¿›ç¨‹ if (reason != null) &#123; app.pendingStart = false; killProcessQuiet(pid); Process.killProcessGroup(app.uid, app.pid); noteAppKill(app, ApplicationExitInfo.REASON_OTHER, ApplicationExitInfo.SUBREASON_INVALID_START, reason); return false; &#125; ... //è®°å½•è¿›ç¨‹å¯åŠ¨ //é€šçŸ¥çœ‹é—¨ç‹—æœ‰è¿›ç¨‹å¯åŠ¨ Watchdog.getInstance().processStarted(app.processName, pid); ... //è®°å½•è¿›ç¨‹å¯åŠ¨ //è®¾ç½®ProcessRecord app.setPid(pid); app.setUsingWrapper(usingWrapper); app.pendingStart = false; //ä»PidMapä¸­è·å–æœªæ¸…ç†çš„ProcessRecord ProcessRecord oldApp; synchronized (mService.mPidsSelfLocked) &#123; oldApp = mService.mPidsSelfLocked.get(pid); &#125; // If there is already an app occupying that pid that hasn't been cleaned up //æ¸…ç†ProcessRecord if (oldApp != null &amp;&amp; !app.isolated) &#123; mService.cleanUpApplicationRecordLocked(oldApp, false, false, -1, true /*replacingPid*/); &#125; //å°†ProcessRecordæ·»åŠ åˆ°PidMapä¸­ mService.addPidLocked(app); synchronized (mService.mPidsSelfLocked) &#123; //attachè¶…æ—¶æ£€æµ‹ if (!procAttached) &#123; Message msg = mService.mHandler.obtainMessage(PROC_START_TIMEOUT_MSG); msg.obj = app; mService.mHandler.sendMessageDelayed(msg, usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT); &#125; &#125; return true;&#125; è¿™ä¸ªæ–¹æ³•å°†ä»zygote forkåå¾—åˆ°çš„ä¿¡æ¯è®¾ç½®åˆ°ProcessRecordä¸­ï¼Œç„¶åå°†æ­¤ProcessRecordæ·»åŠ åˆ°PidMapä¸­ï¼ˆAMS.mPidsSelfLockedï¼‰ï¼Œåç»­å½“attachApplicationæ—¶ä¼šç”¨åˆ°å®ƒ ActivityThreadzygoteè¿›ç¨‹å°†Appè¿›ç¨‹forkå‡ºæ¥åï¼Œä¾¿é€šè¿‡åå°„è°ƒç”¨æˆ‘ä»¬ä¹‹å‰è®¾ç½®çš„entryPointç±»çš„mainæ–¹æ³•ï¼Œå³android.app.ActivityThread.main(String[] args)æ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) &#123; // Install selective syscall interception //è®¾ç½®æ‹¦æˆªå™¨ï¼Œæ‹¦æˆªéƒ¨åˆ†ç³»ç»Ÿè°ƒç”¨è‡ªè¡Œå¤„ç† AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. //èµ„æºå…³é—­æ£€æµ‹å™¨ CloseGuard.setEnabled(false); //åˆå§‹åŒ–ç”¨æˆ·ç¯å¢ƒ Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates //è®¾ç½®CAè¯ä¹¦æœç´¢ä½ç½® final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); // Call per-process mainline module initialization. //åˆå§‹åŒ–ä¸»æ¨¡å—å„ä¸ªæ³¨å†ŒæœåŠ¡ initializeMainlineModules(); //é¢„è®¾è¿›ç¨‹å Process.setArgV0(\"&lt;pre-initialized&gt;\"); //å‡†å¤‡Looper Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format \"seq=114\" //æŸ¥æ‰¾startSeqå‚æ•° long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; //åˆ›å»ºAppè¿›ç¨‹ActivityThreadå®ä¾‹ ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); //è®¾ç½®å…¨å±€Handler if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; //Looperå¾ªç¯å¤„ç†æ¶ˆæ¯ Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; åœ¨mainæ–¹æ³•ä¸­ä¸»è¦åšäº†ä¸¤ä»¶äº‹ï¼Œä¸€æ˜¯å¯åŠ¨Looperï¼Œå¾ªç¯å¤„ç†æ¶ˆæ¯ï¼Œä¿è¯è¿›ç¨‹ä¸ä¼šé€€å‡ºï¼ŒäºŒæ˜¯å®ä¾‹åŒ–ActivityThreadå¹¶æ‰§è¡Œattachæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) &#123; //éç³»ç»ŸActivityThread //é¢„è®¾è¿›ç¨‹å android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); //å¤„ç†ä¸€äº›é”™è¯¯å¼‚å¸¸éœ€è¦ä½¿ç”¨ActivityThreadï¼Œå°†å…¶ä¼ å…¥ RuntimeInit.setApplicationObject(mAppThread.asBinder()); //AMSä»£ç†binderå¯¹è±¡ final IActivityManager mgr = ActivityManager.getService(); try &#123; //æ‰§è¡ŒAMS.attachApplicationæ–¹æ³• mgr.attachApplication(mAppThread, startSeq); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // Watch for getting close to heap limit. //æ¯æ¬¡GCæ—¶æ£€æµ‹å†…å­˜ï¼Œå¦‚æœå†…å­˜ä¸è¶³åˆ™ä¼šå°è¯•é‡Šæ”¾éƒ¨åˆ†ä¸å¯è§çš„Activity BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; ActivityTaskManager.getService().releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125;); &#125; else &#123; //ç³»ç»ŸActivityThread ... &#125; //å¤„ç†ConfigChangedç›¸å…³é€»è¾‘ï¼ˆå±å¹•æ—‹è½¬ä¹‹ç±»ï¼‰ ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */)) &#123; mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) &#123; sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; &#125; &#125; &#125; &#125;; ViewRootImpl.addConfigCallback(configChangedCallback);&#125; è€Œattachæ–¹æ³•æœ€é‡è¦çš„ä¸€æ­¥åˆæ˜¯è°ƒç”¨äº†AMSçš„attachApplicationæ–¹æ³• AMS.attachApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289public final void attachApplication(IApplicationThread thread, long startSeq) &#123; if (thread == null) &#123; throw new SecurityException(\"Invalid application interface\"); &#125; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); &#125;&#125;private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; long startTime = SystemClock.uptimeMillis(); long bindApplicationTimeMillis; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; //é€šè¿‡pidæŸ¥æ‰¾PidMapä¸­å­˜åœ¨çš„ProcessRecord //å¯¹åº”ç€handleProcessStartedLockedæ–¹æ³•ä¸­æ‰§è¡Œçš„ä¸­çš„mService.addPidLockedæ–¹æ³• //åœ¨è¿›ç¨‹åŒæ­¥å¯åŠ¨æ¨¡å¼ä¸‹ï¼Œè¿™é‡Œåº”è¯¥æ˜¯å¿…èƒ½å–åˆ°çš„ synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; //å¦‚æœæ­¤ProcessRecordå¯¹ä¸ä¸ŠAppçš„ProcessRecordï¼Œåˆ™å°†å…¶æ¸…ç†æ‰ if (app != null &amp;&amp; (app.startUid != callingUid || app.startSeq != startSeq)) &#123; ... // If there is already an app occupying that pid that hasn't been cleaned up cleanUpApplicationRecordLocked(app, false, false, -1, true /*replacingPid*/); removePidLocked(app); app = null; &#125; &#125; else &#123; app = null; &#125; // It's possible that process called attachApplication before we got a chance to // update the internal state. //åœ¨è¿›ç¨‹å¼‚æ­¥å¯åŠ¨æ¨¡å¼ä¸‹ï¼Œæœ‰å¯èƒ½å°šæœªæ‰§è¡Œåˆ°handleProcessStartedLockedæ–¹æ³• //æ‰€ä»¥ä»PidMapä¸­æ— æ³•å–åˆ°ç›¸åº”çš„ProcessRecord //è¿™æ—¶å€™ä»ProcessList.mPendingStartsè¿™ä¸ªå¾…å¯åŠ¨åˆ—è¡¨ä¸­è·å–ProcessRecord if (app == null &amp;&amp; startSeq &gt; 0) &#123; final ProcessRecord pending = mProcessList.mPendingStarts.get(startSeq); if (pending != null &amp;&amp; pending.startUid == callingUid &amp;&amp; pending.startSeq == startSeq &amp;&amp; mProcessList.handleProcessStartedLocked(pending, pid, pending .isUsingWrapper(), startSeq, true)) &#123; app = pending; &#125; &#125; //æ²¡æœ‰æ‰¾åˆ°ç›¸åº”çš„ProcessRecordï¼Œæ€æ­»è¿›ç¨‹ if (app == null) &#123; if (pid &gt; 0 &amp;&amp; pid != MY_PID) &#123; killProcessQuiet(pid); &#125; else &#123; try &#123; thread.scheduleExit(); &#125; catch (Exception e) &#123; // Ignore exceptions. &#125; &#125; return false; &#125; // If this application record is still attached to a previous // process, clean it up now. //å¦‚æœProcessRecordç»‘å®šäº†å…¶ä»–çš„ApplicationThreadï¼Œåˆ™éœ€è¦æ¸…ç†è¿™ä¸ªè¿›ç¨‹ if (app.thread != null) &#123; handleAppDiedLocked(app, true, true); &#125; final String processName = app.processName; try &#123; //æ³¨å†ŒAppè¿›ç¨‹æ­»äº¡å›è°ƒ AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; //å¦‚æœå‡ºç°å¼‚å¸¸åˆ™é‡å¯è¿›ç¨‹ app.resetPackageList(mProcessStats); mProcessList.startProcessLocked(app, new HostingRecord(\"link fail\", processName), ZYGOTE_POLICY_FLAG_EMPTY); return false; &#125; //åˆå§‹åŒ–ProcessRecordå„å‚æ•° app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; mOomAdjuster.setAttachingSchedGroupLocked(app); app.forcingToImportant = null; updateProcessForegroundLocked(app, false, 0, false); app.hasShownUi = false; app.setDebugging(false); app.setCached(false); app.killedByAm = false; app.killed = false; // We carefully use the same state that PackageManager uses for // filtering, since we use this flag to decide if we need to install // providers when user is unlocked later app.unlocked = StorageManager.isUserKeyUnlocked(app.userId); //ç§»é™¤ä¹‹å‰åœ¨handleProcessStartedLockedä¸­è®¾ç½®çš„attachè¶…æ—¶æ£€æµ‹ mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); //æ™®é€šAppå¯åŠ¨è‚¯å®šåœ¨system_serverå‡†å¤‡å®Œæˆåï¼Œæ‰€ä»¥æ­¤å¤„ä¸ºtrue boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null; //è®¾ç½®ContentProviderå¯åŠ¨è¶…æ—¶æ£€æµ‹ if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123; Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG); msg.obj = app; mHandler.sendMessageDelayed(msg, ContentResolver.CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS); &#125; final BackupRecord backupTarget = mBackupTargets.get(app.userId); try &#123; //å¯¹åº”ç€å¼€å‘è€…æ¨¡å¼é‡Œçš„ Select debug app å’Œ Wait for debugger int testMode = ApplicationThreadConstants.DEBUG_OFF; if (mDebugApp != null &amp;&amp; mDebugApp.equals(processName)) &#123; testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON; app.setDebugging(true); if (mDebugTransient) &#123; mDebugApp = mOrigDebugApp; mWaitForDebugger = mOrigWaitForDebugger; &#125; &#125; boolean enableTrackAllocation = false; if (mTrackAllocationApp != null &amp;&amp; mTrackAllocationApp.equals(processName)) &#123; enableTrackAllocation = true; mTrackAllocationApp = null; &#125; // If the app is being launched for restore or full backup, set it up specially boolean isRestrictedBackupMode = false; ... //å¤‡ä»½ç›¸å…³ final ActiveInstrumentation instr; ... //è‡ªåŠ¨åŒ–æµ‹è¯•ç›¸å…³ ApplicationInfo appInfo = instr != null ? instr.mTargetInfo : app.info; app.compat = compatibilityInfoForPackage(appInfo); ProfilerInfo profilerInfo = null; String preBindAgent = null; ... //æ€§èƒ½åˆ†æç›¸å…³ // We deprecated Build.SERIAL and it is not accessible to // Instant Apps and target APIs higher than O MR1. Since access to the serial // is now behind a permission we push down the value. //åºåˆ—å·ï¼ˆAndroid 8.0åä¸å¯å†é€šè¿‡Build.SERIALè·å–åºåˆ—å·ï¼‰ final String buildSerial = (!appInfo.isInstantApp() &amp;&amp; appInfo.targetSdkVersion &lt; Build.VERSION_CODES.P) ? sTheRealBuildSerial : Build.UNKNOWN; ... //è‡ªåŠ¨åŒ–æµ‹è¯•ç›¸å…³ ... //æ€§èƒ½åˆ†æç›¸å…³ //debugæ¨¡å¼ if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; thread.attachStartupAgents(app.info.dataDir); &#125; ... //è‡ªåŠ¨å¡«å……åŠŸèƒ½ï¼ˆè´¦å·å¯†ç ç­‰ï¼‰ ... //å†…å®¹æ•è·ç›¸å…³ï¼ˆContentCaptureManagerï¼‰ //è‡ªåŠ¨åŒ–æµ‹è¯• final ActiveInstrumentation instr2 = app.getActiveInstrumentation(); if (mPlatformCompat != null) &#123; mPlatformCompat.resetReporting(app.info); &#125; final ProviderInfoList providerList = ProviderInfoList.fromList(providers); //è°ƒç”¨ApplicationThread.bindApplicationæ–¹æ³• if (app.isolatedEntryPoint != null) &#123; // This is an isolated process which should just call an entry point instead of // being bound to an application. thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); &#125; else if (instr2 != null) &#123; thread.bindApplication(processName, appInfo, providerList, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.mDisabledCompatChanges); &#125; else &#123; thread.bindApplication(processName, appInfo, providerList, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.mDisabledCompatChanges); &#125; ... // Make app active after binding application or client may be running requests (e.g // starting activities) before it is ready. //ProcessRecordä¿å­˜ApplicationThreadä»£ç†å¯¹è±¡ app.makeActive(thread, mProcessStats); //æ›´æ–°è¿›ç¨‹ä½¿ç”¨æƒ…å†µ mProcessList.updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; //å‡ºç°é”™è¯¯ï¼Œæ€æ­»è¿›ç¨‹ app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); app.kill(\"error during bind\", ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, true); handleAppDiedLocked(app, false, true); return false; &#125; // Remove this record from the list of starting applications. //ä»persistentå¯åŠ¨åˆ—è¡¨ä¸­ç§»é™¤æ­¤ProcessRecord //persistentæ˜¯manifestä¸­applicationæ ‡ç­¾ä¸‹çš„ä¸€ä¸ªå±æ€§ //è®¾ç½®äº†æ­¤å±æ€§ä»£è¡¨æ­¤Appä¼šè·Ÿéšç³»ç»Ÿå¯åŠ¨è€Œå¯åŠ¨ mPersistentStartingProcesses.remove(app); boolean badApp = false; boolean didSomething = false; // See if the top visible activity is waiting to run in this process... //æ£€æŸ¥æ˜¯å¦æœ‰Activityç­‰å¾…å¯åŠ¨ if (normalMode) &#123; try &#123; didSomething = mAtmInternal.attachApplication(app.getWindowProcessController()); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Find any services that should be running in this process... //æ£€æŸ¥æ˜¯å¦æœ‰Servicesç­‰å¾…å¯åŠ¨ if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Check if a next-broadcast receiver is in this process... //æ£€æŸ¥æ˜¯å¦æœ‰å¹¿æ’­æ¥æ”¶å™¨éœ€è¦å¯åŠ¨ if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it 'bad' badApp = true; &#125; &#125; ... //å¤‡ä»½ç›¸å…³ //ä»¥ä¸Šå‡ æ­¥å‘ç”Ÿå¼‚å¸¸ï¼Œæ€æ­»Appè¿›ç¨‹ if (badApp) &#123; app.kill(\"error during init\", ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; //æ›´æ–°è¿›ç¨‹OOMç­‰çº§ updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN); &#125; return true;&#125; æ€»ç»“ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†å“ªäº›äº‹ï¼Œé¦–å…ˆè·å–ProcessRecordï¼Œç„¶åå¯¹å…¶åšä¸€äº›åˆå§‹åŒ–è®¾ç½®ï¼Œç„¶åè°ƒç”¨ApplicaionThread.bindApplicationæ–¹æ³•ï¼Œæœ€ååˆ†åˆ«æ£€æŸ¥å¤„ç†Activityã€Serviceå’ŒBroadcastReceiverçš„å¯åŠ¨ è·å–ProcessRecordæˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•æ˜¯æ€ä¹ˆè·å–ProcessRecordçš„ï¼Œæˆ‘ä»¬å…ˆå›é¡¾ä¸€ä¸‹ä¹‹å‰åœ¨startProcessLockedæ–¹æ³•çš„æœ€åï¼Œä¼šä½¿ç”¨åŒæ­¥æˆ–å¼‚æ­¥çš„æ–¹å¼å¯åŠ¨è¿›ç¨‹ï¼Œæœ€ç»ˆä¸¤è€…éƒ½ä¼šè°ƒç”¨startProcesså’ŒhandleProcessStartedLockedæ–¹æ³• åŒæ­¥å¯åŠ¨è¿›ç¨‹æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ä¹‹å‰è®²åˆ°çš„ActivityManagerInternal.startProcessæ–¹æ³•ï¼Œå¯ä»¥å‘ç°å®ƒå†…éƒ¨ä½¿ç”¨äº†synchronized (ActivityManagerService.this)åŠ é”ï¼Œè€ŒAMS.attachApplicationæ–¹æ³•åŒæ ·ä¹Ÿä½¿ç”¨äº†AMSå®ä¾‹å¯¹è±¡åŠ äº†é”ï¼Œæ‰€ä»¥åœ¨åŒæ­¥å¯åŠ¨è¿›ç¨‹çš„æƒ…å†µä¸‹ï¼Œå¿…ç„¶ä¼šå…ˆæ‰§è¡ŒhandleProcessStartedLockedæ–¹æ³•ï¼Œå†æ‰§è¡ŒattachApplicationæ–¹æ³•ï¼Œæ ¹æ®ä¹‹å‰æ‰€åˆ†æçš„ï¼ŒhandleProcessStartedLockedæ–¹æ³•ä¼šå°†ProcessRecordå­˜åˆ°PidMapä¸­ï¼Œç„¶åattachApplicationæ–¹æ³•åˆä¼šä»PidMapä¸­å»å–ï¼Œæ­¤æ—¶å–å‡ºçš„ProcessRecordå¿…ç„¶ä¸ä¸ºnull å¼‚æ­¥å¯åŠ¨è¿›ç¨‹åœ¨å¼‚æ­¥å¯åŠ¨è¿›ç¨‹çš„æƒ…å†µä¸‹ï¼Œæ˜¯é€šè¿‡Handlerå°†å¯åŠ¨è¿›ç¨‹çš„å·¥ä½œæ’å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªä»»åŠ¡çš„æ‰§è¡Œæ˜¯ä¸åœ¨é”çš„ä½œç”¨åŸŸèŒƒå›´å†…çš„ï¼Œåœ¨è¿™ä¸ªä»»åŠ¡å†…æ²¡æœ‰å¯¹startProcessæ–¹æ³•åŠ é”ï¼Œåªå¯¹handleProcessStartedLockedæ–¹æ³•åŠ äº†é”ï¼Œæ‰€ä»¥è¿™é‡Œä¼šæœ‰ä¸¤ç§æƒ…å†µï¼š å…ˆæ‰§è¡ŒhandleProcessStartedLockedæ–¹æ³•ï¼Œå†æ‰§è¡ŒattachApplicationæ–¹æ³• è¿™ç§æƒ…å†µå’ŒåŒæ­¥å¯åŠ¨è¿›ç¨‹çš„æ‰§è¡Œé¡ºåºæ˜¯ä¸€æ ·çš„ï¼ŒProcessRecordè·å–æ–¹å¼ä¹Ÿç›¸åŒ å…ˆæ‰§è¡ŒattachApplicationæ–¹æ³•ï¼Œå†æ‰§è¡ŒhandleProcessStartedLockedæ–¹æ³• è¿™ç§æƒ…å†µä¸‹ï¼ŒPidMapä¸­å–ä¸åˆ°ç›¸åº”çš„ProcessRecordï¼Œæ­¤æ—¶ProcessList.mPendingStartsä¸­è¿˜æ²¡æœ‰å°†ProcessRecordç§»é™¤ï¼Œæ‰€ä»¥ä¼šä»mPendingStartsè¿™ä¸ªå¯åŠ¨åˆ—è¡¨ä¸­å–å‡ºProcessRecordï¼Œç„¶åå†è°ƒç”¨handleProcessStartedLockedæ–¹æ³•ï¼Œç­‰åˆ°attachApplicationæ–¹æ³•èµ°å®Œï¼Œé”é‡Šæ”¾åï¼Œåœ¨è¿›å…¥åˆ°å¤–éƒ¨çš„handleProcessStartedLockedé‡è½½æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šå…ˆåˆ¤æ–­mPendingStartsä¸­æ˜¯å¦è¿˜å­˜åœ¨å¯¹åº”çš„ProcessRecordï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œä¾¿ä¼šç›´æ¥è¿”å›ï¼Œä¿è¯handleProcessStartedLockedæ–¹æ³•åªæ‰§è¡Œä¸€æ¬¡ ApplicationThread.bindApplicationæ¥ç€ï¼Œæˆ‘ä»¬ç»§ç»­çœ‹é‡ç‚¹æ–¹æ³•ApplicationThread.bindApplication ApplicationThreadæ˜¯ActivityThreadçš„ä¸€ä¸ªå†…éƒ¨ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041public final void bindApplication(String processName, ApplicationInfo appInfo, ProviderInfoList providerList, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, AutofillOptions autofillOptions, ContentCaptureOptions contentCaptureOptions, long[] disabledCompatChanges) &#123; if (services != null) &#123; ... // Setup the service cache in the ServiceManager //åˆå§‹åŒ–é€šç”¨ç³»ç»ŸæœåŠ¡ç¼“å­˜ ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providerList.getList(); data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; data.disabledCompatChanges = disabledCompatChanges; sendMessage(H.BIND_APPLICATION, data);&#125; è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œåªæ˜¯å°†å‚æ•°åŒ…è£…æˆä¸€ä¸ªAppBindDataï¼Œç„¶åé€šè¿‡Handlerå‘é€æ¶ˆæ¯å¤„ç†ï¼Œæ ¹æ®æ¶ˆæ¯çš„ç±»å‹ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ActivityThread.handleBindApplicationæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379private void handleBindApplication(AppBindData data) &#123; // Register the UI Thread as a sensitive thread to the runtime. //å°†UIçº¿ç¨‹æ³¨å†ŒæˆJITæ•æ„Ÿçº¿ç¨‹ VMRuntime.registerSensitiveThread(); ... mProfiler = new Profiler(); ... //æ€§èƒ½åˆ†æç›¸å…³ // send up app name; do this *before* waiting for debugger //è®¾ç½®è¿›ç¨‹å Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName, data.appInfo.packageName, UserHandle.myUserId()); VMRuntime.setProcessPackageName(data.appInfo.packageName); // Pass data directory path to ART. This is used for caching information and // should be set before any application code is loaded. //è®¾ç½®è¿›ç¨‹æ•°æ®ç›®å½• VMRuntime.setProcessDataDirectory(data.appInfo.dataDir); //æ€§èƒ½åˆ†æç›¸å…³ if (mProfiler.profileFd != null) &#123; mProfiler.startProfiling(); &#125; // If the app is Honeycomb MR1 or earlier, switch its AsyncTask // implementation to use the pool executor. Normally, we use the // serialized executor as the default. This has to happen in the // main thread so the main looper is set right. //å½“Appçš„targetSdkVersionå°äºç­‰äº 3.1 (12) æ—¶ï¼ŒAsyncTaskä½¿ç”¨çº¿ç¨‹æ± å®ç° if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123; AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR); &#125; // Let the util.*Array classes maintain \"undefined\" for apps targeting Pie or earlier. //å½“Appçš„targetSdkVersionå¤§äºç­‰äº 10 (29) æ—¶ï¼Œé’ˆå¯¹Android SDKæä¾›çš„å®¹å™¨ï¼ˆSparseArrayç­‰ï¼‰ //å¦‚æœindexè¶Šç•Œï¼Œä¼šä¸»åŠ¨æŠ›ArrayIndexOutOfBoundsExceptionå¼‚å¸¸ //ï¼ˆä¹‹å‰æ•°ç»„è¶Šç•Œçš„è¡Œä¸ºæœªè¢«å®šä¹‰ï¼‰ UtilConfig.setThrowExceptionForUpperArrayOutOfBounds( data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.Q); //å½“Appçš„targetSdkVersionå¤§äºç­‰äº 5.0 (21) æ—¶ï¼Œå›æ”¶æ­£åœ¨ä½¿ç”¨çš„Messageä¼šæŠ›å‡ºå¼‚å¸¸ Message.updateCheckRecycle(data.appInfo.targetSdkVersion); // Prior to P, internal calls to decode Bitmaps used BitmapFactory, // which may scale up to account for density. In P, we switched to // ImageDecoder, which skips the upscale to save memory. ImageDecoder // needs to still scale up in older apps, in case they rely on the // size of the Bitmap without considering its density. ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion; /* * Before spawning a new process, reset the time zone to be the system time zone. * This needs to be done because the system time zone could have changed after the * the spawning of this process. Without doing this this process would have the incorrect * system time zone. */ //è®¾ç½®æ—¶åŒº TimeZone.setDefault(null); /* * Set the LocaleList. This may change once we create the App Context. */ LocaleList.setDefault(data.config.getLocales()); //æ›´æ–°Configuration synchronized (mResourcesManager) &#123; /* * Update the system configuration since its preloaded and might not * reflect configuration changes. The configuration object passed * in AppBindData can be safely assumed to be up to date */ mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo); mCurDefaultDisplayDpi = data.config.densityDpi; // This calls mResourcesManager so keep it within the synchronized block. applyCompatConfiguration(mCurDefaultDisplayDpi); &#125; //è·å–LoadedApk data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); //æ€§èƒ½åˆ†æå™¨ä»£ç†JVMï¼ˆJVMTIï¼‰ if (agent != null) &#123; handleAttachAgent(agent, data.info); &#125; /** * Switch this process to density compatibility mode if needed. */ //åœ¨manifestï¼Œsupports-screensæ ‡ç­¾ä¸­è®¾ç½®äº†android:anyDensity //è¯¦è§ï¼šhttps://developer.android.com/guide/topics/manifest/supports-screens-element#any if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) &#123; //æŒ‡ç¤ºAppåŒ…å«ç”¨äºé€‚åº”ä»»ä½•å±å¹•å¯†åº¦çš„èµ„æº mDensityCompatMode = true; Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT); &#125; //è®¾ç½®é»˜è®¤å¯†åº¦ updateDefaultDensity(); /* è®¾ç½® 12/24 å°æ—¶æ—¶é—´åˆ¶ */ final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24); Boolean is24Hr = null; if (use24HourSetting != null) &#123; is24Hr = \"24\".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE; &#125; // null : use locale default for 12/24 hour formatting, // false : use 12 hour format, // true : use 24 hour format. DateFormat.set24HourTimePref(is24Hr); //æ›´æ–°view debugå±æ€§sDebugViewAttributes //è®¾ç½®äº†è¿™ä¸ªå±æ€§ï¼ŒViewå°†ä¼šä¿å­˜å®ƒæœ¬èº«çš„å±æ€§ //å’ŒLayout Inspectorç›¸å…³ updateDebugViewAttributeState(); //åˆå§‹åŒ–é»˜è®¤çº¿ç¨‹ç­–ç•¥ StrictMode.initThreadDefaults(data.appInfo); //åˆå§‹åŒ–é»˜è®¤VMç­–ç•¥ StrictMode.initVmDefaults(data.appInfo); //debugæ¨¡å¼ if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) &#123; // XXX should have option to change the port. Debug.changeDebugPort(8100); if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" is waiting for the debugger on port 8100...\"); IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.showWaitingForDebugger(mAppThread, true); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; Debug.waitForDebugger(); try &#123; mgr.showWaitingForDebugger(mAppThread, false); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" can be debugged on port 8100...\"); &#125; &#125; // Allow binder tracing, and application-generated systrace messages if we're profileable. //æ€§èƒ½åˆ†ææ¨¡å¼ boolean isAppProfileable = data.appInfo.isProfileableByShell(); //å…è®¸åº”ç”¨ç¨‹åºè·Ÿè¸ª Trace.setAppTracingAllowed(isAppProfileable); if ((isAppProfileable || Build.IS_DEBUGGABLE) &amp;&amp; data.enableBinderTracking) &#123; Binder.enableTracing(); &#125; // Initialize heap profiling. //åˆå§‹åŒ–å †åˆ†æ if (isAppProfileable || Build.IS_DEBUGGABLE) &#123; nInitZygoteChildHeapProfiling(); &#125; // Allow renderer debugging features if we're debuggable. boolean isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; //å¼€å¯ç¡¬ä»¶åŠ é€Ÿè°ƒè¯•åŠŸèƒ½ HardwareRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE); HardwareRenderer.setPackageName(data.appInfo.packageName); /** * Initialize the default http proxy in this process for the reasons we set the time zone. */ //è®¾ç½®é»˜è®¤HTTPä»£ç† final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); if (b != null) &#123; // In pre-boot mode (doing initial launch to collect password), not // all system is up. This includes the connectivity service, so don't // crash if we can't get it. final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); try &#123; Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(null)); &#125; catch (RemoteException e) &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); throw e.rethrowFromSystemServer(); &#125; &#125; // Instrumentation info affects the class loader, so load it before // setting up the app context. //å‡†å¤‡è‡ªåŠ¨åŒ–æµ‹è¯•ä¿¡æ¯ final InstrumentationInfo ii; if (data.instrumentationName != null) &#123; try &#123; ii = new ApplicationPackageManager( null, getPackageManager(), getPermissionManager()) .getInstrumentationInfo(data.instrumentationName, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException( \"Unable to find instrumentation info for: \" + data.instrumentationName); &#125; // Warn of potential ABI mismatches. ... mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii); mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); &#125; else &#123; ii = null; &#125; //åˆ›å»ºContext final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); //æ›´æ–°åŒºåŸŸåˆ—è¡¨ updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); if (!Process.isIsolated()) &#123; final int oldMask = StrictMode.allowThreadDiskWritesMask(); try &#123; setupGraphicsSupport(appContext); &#125; finally &#123; StrictMode.setThreadPolicyMask(oldMask); &#125; &#125; else &#123; HardwareRenderer.setIsolatedProcess(true); &#125; // Install the Network Security Config Provider. This must happen before the application // code is loaded to prevent issues with instances of TLS objects being created before // the provider is installed. //ç½‘ç»œå®‰å…¨è®¾ç½® NetworkSecurityConfigProvider.install(appContext); // Continue loading instrumentation. if (ii != null) &#123; //å¦‚æœè®¾ç½®äº†è‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œå®ä¾‹åŒ–æŒ‡å®šçš„è‡ªåŠ¨åŒ–æµ‹è¯•ç±» ApplicationInfo instrApp; try &#123; instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0, UserHandle.myUserId()); &#125; catch (RemoteException e) &#123; instrApp = null; &#125; if (instrApp == null) &#123; instrApp = new ApplicationInfo(); &#125; ii.copyTo(instrApp); instrApp.initForUser(UserHandle.myUserId()); final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); // The test context's op package name == the target app's op package name, because // the app ops manager checks the op package name against the real calling UID, // which is what the target package name is associated with. final ContextImpl instrContext = ContextImpl.createAppContext(this, pi, appContext.getOpPackageName()); try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate instrumentation \" + data.instrumentationName + \": \" + e.toString(), e); &#125; final ComponentName component = new ComponentName(ii.packageName, ii.name); mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) &#123; mProfiler.handlingProfiling = true; final File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); &#125; &#125; else &#123; //ç›´æ¥å®ä¾‹åŒ–Instrumentation mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); &#125; //è°ƒæ•´åº”ç”¨å¯ç”¨å†…å­˜ä¸Šé™ if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != 0) &#123; dalvik.system.VMRuntime.getRuntime().clearGrowthLimit(); &#125; else &#123; // Small heap, clamp to the current growth limit and let the heap release // pages after the growth limit to the non growth limit capacity. b/18387825 dalvik.system.VMRuntime.getRuntime().clampGrowthLimit(); &#125; // Allow disk access during application and provider setup. This could // block processing ordered broadcasts, but later processing would // probably end up doing the same disk access. Application app; final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy(); try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. //åˆ›å»ºApplication app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state //è®¾ç½®è‡ªåŠ¨å¡«å……åŠŸèƒ½ app.setAutofillOptions(data.autofillOptions); // Propagate Content Capture options //è®¾ç½®å†…å®¹æ•è·åŠŸèƒ½ app.setContentCaptureOptions(data.contentCaptureOptions); mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class //åœ¨éå—é™æ¨¡å¼ä¸‹å¯åŠ¨ContentProvider if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); &#125; &#125; // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. //æ‰§è¡ŒonCreateæ–¹æ³•ï¼ˆé»˜è®¤Instrumentationå®ç°ä¸ºç©ºæ–¹æ³•ï¼‰ try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; ... &#125; //æ‰§è¡ŒApplicationçš„onCreateæ–¹æ³• try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; finally &#123; // If the app targets &lt; O-MR1, or doesn't change the thread policy // during startup, clobber the policy to maintain behavior of b/36951662 if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; // Preload fonts resources //é¢„åŠ è½½å­—ä½“èµ„æº FontsContract.setApplicationContextForResources(appContext); if (!Process.isIsolated()) &#123; try &#123; final ApplicationInfo info = getPackageManager().getApplicationInfo( data.appInfo.packageName, PackageManager.GET_META_DATA /*flags*/, UserHandle.myUserId()); if (info.metaData != null) &#123; final int preloadedFontsResource = info.metaData.getInt( ApplicationInfo.METADATA_PRELOADED_FONTS, 0); if (preloadedFontsResource != 0) &#123; data.info.getResources().preloadFonts(preloadedFontsResource); &#125; &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;&#125; è¿™ä¸ªæ–¹æ³•å¾ˆé‡è¦ï¼Œæˆ‘ä»¬å…ˆè¿‡ä¸€ä¸‹å‡ ä¸ªé‡ç‚¹éƒ¨åˆ†ï¼Œç„¶åå†æŒ‰ç€ä¸»çº¿ç»§ç»­å¾€ä¸‹ç ”ç©¶ï¼š Debugã€Profilerã€Layout Inspector Androidåº”ç”¨å¼€å‘çš„åŒå­¦å¯¹è¿™ä¸‰æ ·è‚¯å®šä¸é™Œç”Ÿï¼Œåœ¨Android Studioä¸­æˆ‘ä»¬å¯ä»¥å¯¹Appè¿›è¡Œè°ƒè¯•ï¼Œæ€§èƒ½åˆ†æå’Œå¸ƒå±€æ£€æŸ¥ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°ä¸è¿™ä¸‰æ ·ç›¸å…³çš„ä¸€äº›ä»£ç  è·å–LoadedApk LoadedApkæ˜¯Apkæ–‡ä»¶åœ¨å†…å­˜ä¸­çš„è¡¨ç¤ºï¼ŒåŒ…å«äº†Apkæ–‡ä»¶ä¸­çš„ä»£ç ã€èµ„æºã€ç»„ä»¶ã€manifestç­‰ä¿¡æ¯ åˆ›å»ºContext è¿™é‡Œé€šè¿‡ActivityThreadå’ŒLoadedApkåˆ›å»ºå‡ºäº†ä¸€ä¸ªContextImpl å®ä¾‹åŒ–Instrumentation è¿™é‡Œå’Œè‡ªåŠ¨åŒ–æµ‹è¯•ç›¸å…³ï¼Œå¦‚æœè®¾ç½®äº†è‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œå®ä¾‹åŒ–æŒ‡å®šçš„è‡ªåŠ¨åŒ–æµ‹è¯•ç±»ï¼Œå¦åˆ™å®ä¾‹åŒ–é»˜è®¤çš„Instrumentation åˆ›å»ºApplication è¿™é‡Œæ ¹æ®LoadedApkåˆ›å»ºå‡ºç›¸åº”çš„Applicationï¼Œéœ€è¦æ³¨æ„ï¼Œè¿™é‡Œåˆ›å»ºçš„Applicationå¹¶ä¸ä¸ä¸Šé¢åˆ›å»ºå‡ºçš„ContextImplç»‘å®šï¼Œè€Œæ˜¯åœ¨åˆ›å»ºApplicationçš„è¿‡ç¨‹ä¸­ï¼Œä»¥åŒæ ·çš„å‚æ•°é‡æ–°åˆ›å»ºäº†ä¸€ä¸ªContextImplï¼Œç„¶åè°ƒç”¨attachBaseContextæ–¹æ³•ç»‘å®šå®ƒ è®¾ç½®HTTPä»£ç† Appåœ¨å¯åŠ¨è¿‡ç¨‹ä¸­è®¾ç½®HTTPä»£ç†ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨å¼€å‘è¿‡ç¨‹ä¸­ä½¿ç”¨ä»£ç†æŠ“åŒ…ç­‰æ—¶å€™éœ€è¦æ³¨æ„ï¼Œè®¾ç½®äº†ä»£ç†åéœ€è¦é‡å¯Appæ‰ä¼šç”Ÿæ•ˆ å¯åŠ¨ContentProvider ContentProviderçš„å¯åŠ¨è¿‡ç¨‹ä»¥åä¼šæ–°å¼€æ–‡ç« è¿›è¡Œåˆ†æï¼Œè¿™é‡Œåªéœ€è¦çŸ¥é“ContentProviderå¯åŠ¨çš„å…¥å£åœ¨è¿™å°±è¡Œäº† æ‰§è¡ŒApplicationçš„onCreateæ–¹æ³• å½“åˆ›å»ºå®ŒApplicationï¼Œæ‰§è¡ŒattachBaseContextæ–¹æ³•åï¼Œä¾¿ä¼šè°ƒç”¨onCreateæ–¹æ³• æˆ‘ä»¬æ‹£é‡ç‚¹æ¥çœ‹ï¼Œé¦–å…ˆæ˜¯Applicationçš„åˆ›å»ºè¿‡ç¨‹ LoadedApk.makeApplicationåœ¨ä¸Šæ–‡çš„æ–¹æ³•ä¸­ï¼Œè°ƒç”¨äº†data.info.makeApplicationæ–¹æ³•åˆ›å»ºApplicationï¼Œå…¶ä¸­data.infoä¸ºLoadedApkç±»å‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; //å¦‚æœä¹‹å‰åˆ›å»ºè¿‡äº†å°±å¯ä»¥ç›´æ¥è¿”å› if (mApplication != null) &#123; return mApplication; &#125; Application app = null; //è·å–Applicationç±»åï¼ˆAppå¯ä»¥è‡ªå®šä¹‰Applicationè¿™ä¸ªåº”è¯¥æ‰€æœ‰å¼€å‘éƒ½çŸ¥é“å§ï¼‰ //å¯¹åº”AndroidManifestä¸­applicationæ ‡ç­¾ä¸‹çš„android:nameå±æ€§ String appClass = mApplicationInfo.className; //æ²¡æœ‰è®¾ç½®è‡ªå®šä¹‰Applicationæˆ–å¼ºåˆ¶ä½¿ç”¨é»˜è®¤Applicationçš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨é»˜è®¤Application if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; //åˆå§‹åŒ–ContextClassLoader final java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; initializeJavaContextClassLoader(); &#125; // Rewrite the R 'constants' for all library apks. //Androidå…±äº«åº“èµ„æºIDåŠ¨æ€æ˜ å°„ SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers( false, false); for (int i = 0, n = packageIdentifiers.size(); i &lt; n; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(cl, packageIdentifiers.valueAt(i), id); &#125; //åˆ›å»ºContext ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // The network security config needs to be aware of multiple // applications in the same process to handle discrepancies //ç½‘ç»œå®‰å…¨è®¾ç½® NetworkSecurityConfigProvider.handleNewApplication(appContext); //åˆ›å»ºApplication app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; ... &#125; //åŠ å…¥Applicationåˆ—è¡¨ä¸­ï¼ˆå¤šä¸ªAppå¯ä»¥è¿è¡Œåœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­ï¼‰ mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; //è°ƒç”¨Applicationçš„OnCreateæ–¹æ³• try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; return app;&#125; è¿™ä¸ªæ–¹æ³•é¦–å…ˆå°è¯•å–æˆå‘˜å˜é‡mApplicationï¼Œå¦‚æœä¸ä¸ºnullï¼Œè¯´æ˜æ›¾åˆ›å»ºè¿‡ï¼Œç›´æ¥è¿”å›å°±å¯ä»¥äº† ç„¶åå†å»è·å–Applicationç±»åï¼Œé»˜è®¤ä¸ºandroid.app.Applicationï¼Œå¼€å‘å¯ä»¥é€šè¿‡è®¾ç½®AndroidManifestä¸­applicationæ ‡ç­¾ä¸‹çš„android:nameå±æ€§æ¥é€‰æ‹©åˆ›å»ºè‡ªå®šä¹‰çš„Application ç„¶åå¯¹å…±äº«åº“èµ„æºIDåšåŠ¨æ€æ˜ å°„ï¼Œå…³äºè¿™éƒ¨åˆ†æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥å»æœç´¢Android Dynamic Reference æ¥ç€åˆ›å»ºå‡ºContextImplä½œä¸ºApplicationçš„BaseContextï¼ŒApplicationç»§æ‰¿è‡ªContextWrapperï¼Œè€ŒContextWrapperåˆç»§æ‰¿è‡ªContextï¼ŒContextWrapperæ˜¯å¯¹Contextçš„åŒ…è£…ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªmBaseæˆå‘˜å˜é‡ï¼Œè°ƒç”¨ä»»ä½•æ–¹æ³•å®é™…ä¸Šéƒ½æ˜¯è°ƒç”¨mBaseè¿™ä¸ªå®ä¾‹çš„æ–¹æ³•ï¼Œåœ¨Applicationåˆ›å»ºåä¼šè°ƒç”¨attachBaseContextå°†åˆšåˆšåˆ›å»ºå‡ºæ¥çš„ContextImplèµ‹å€¼ç»™mBaseæˆå‘˜å˜é‡ï¼Œæ‰€ä»¥è°ƒç”¨Applicationä¸­çš„ä»»ä½•Contextæ–¹æ³•ï¼Œå®é™…ä¸Šæœ€ç»ˆéƒ½æ˜¯è°ƒç”¨ContextImplçš„æ–¹æ³• ç„¶ååˆ›å»ºApplicationï¼Œå¹¶å°†å…¶è®¾ç½®æˆContextImplçš„OuterContext æœ€åå°†åˆ›å»ºå¥½çš„Applicationè®¾ç½®ç»™æˆå‘˜å˜é‡mApplicationï¼Œæ–¹ä¾¿ä»¥åè·å–ï¼Œç„¶åå°†å…¶å†æ·»åŠ åˆ°mActivityThread.mAllApplicationsåˆ—è¡¨ä¸­ï¼Œè¿”å› ContextImpl.createAppContextæˆ‘ä»¬ç®€å•çœ‹ä¸€ä¸‹ContextImplçš„åˆ›å»ºï¼Œå¯¹äºä¸åŒçš„ç»„ä»¶ï¼Œåˆ›å»ºContextImplå¯¹è±¡çš„æ–¹æ³•ä¸åŒï¼Œæ¯”å¦‚è¯´Activityçš„Contextæ˜¯é€šè¿‡createActivityContextæ–¹æ³•åˆ›å»ºçš„ï¼Œæˆ‘ä»¬è¿™é‡Œæ˜¯é€šè¿‡createAppContextåˆ›å»ºApplicationçš„Contextçš„ 123456789101112131415static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123; return createAppContext(mainThread, packageInfo, null);&#125;static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo, String opPackageName) &#123; if (packageInfo == null) throw new IllegalArgumentException(\"packageInfo\"); ContextImpl context = new ContextImpl(null, mainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName); context.setResources(packageInfo.getResources()); //æ£€æŸ¥android.permission.STATUS_BAR_SERVICEæƒé™ context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI : CONTEXT_TYPE_NON_UI; return context;&#125; ç®€å•çœ‹çœ‹å°±å¥½ï¼Œæˆ‘ä»¬çš„é‡ç‚¹ä¸åœ¨è¿™é‡Œï¼Œè¿™ä¸ªæ–¹æ³•å®ä¾‹åŒ–äº†ä¸€ä¸ªContextImplå¯¹è±¡ï¼Œç„¶åé€šè¿‡ResourcesManagerè·å¾—Apkçš„Resourceï¼Œå°†å…¶è®¾ç½®åˆ°ContextImplä¸­ Instrumentation.newApplicationæ¥ç€æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹Applicationæ˜¯æ€ä¹ˆåˆ›å»ºçš„ 12345678public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = getFactory(context.getPackageName()) .instantiateApplication(cl, className); app.attach(context); return app;&#125; è¿™é‡Œï¼ŒgetFactoryæ–¹æ³•è¿”å›çš„æ˜¯ä¸€ä¸ªAppComponentFactoryå¯¹è±¡ï¼Œè¿™ä¸ªç±»æ˜¯åœ¨Android 9ä¹‹ååŠ å…¥çš„ï¼Œå®ƒåŒ…æ‹¬ä¸€ä¸ªå®ä¾‹åŒ–ClassLoaderçš„æ–¹æ³•ï¼Œä¸€ä¸ªå®ä¾‹åŒ–Applicationçš„æ–¹æ³•å’Œå››ä¸ªå®ä¾‹åŒ–å››å¤§ç»„ä»¶çš„æ–¹æ³• æˆ‘ä»¬å¯ä»¥åœ¨AndroidManifestä¸­è®¾ç½®applicationæ ‡ç­¾çš„android:appComponentFactoryå±æ€§ï¼Œå°†å…¶è®¾ç½®æˆæˆ‘ä»¬è‡ªå®šä¹‰çš„AppComponentFactoryï¼Œä»è€Œè¿›è¡Œä¸€äº›ç›‘æ§æˆ–åˆ«çš„æ“ä½œ æˆ‘ä»¬çœ‹ä¸€ä¸‹AppComponentFactoryçš„é»˜è®¤å®ç°æ˜¯æ€æ ·çš„ 12345public @NonNull Application instantiateApplication(@NonNull ClassLoader cl, @NonNull String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Application) cl.loadClass(className).newInstance();&#125; å¯ä»¥çœ‹åˆ°éå¸¸ç®€å•ï¼Œå°±æ˜¯é€šè¿‡classNameåå°„å®ä¾‹åŒ–å‡ºä¸€ä¸ªApplication æ¥ç€æˆ‘ä»¬å›åˆ°newApplicationæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯¹æ–°åˆ›å»ºçš„Applicationè°ƒç”¨äº†attachæ–¹æ³•å»ç»‘å®šContextImpl 1234/* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; è¿™é‡Œçš„attachBaseContextè°ƒç”¨çš„æ˜¯çˆ¶ç±»ContextWrapperä¸­çš„æ–¹æ³• 123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå°±æ˜¯å°†ContextImplèµ‹å€¼ç»™ContextWrapperä¸­çš„mBaseèµ‹å€¼ï¼Œè¿™æ ·åé¢å¯¹Applicationè°ƒç”¨Contextçš„æ–¹æ³•ï¼Œå®é™…ä¸Šå°±æ˜¯ä»£ç†ç»™è¿™ä¸ªmBaseå»æ‰§è¡Œäº† åˆ°è¿™ä¸€æ­¥ä½ç½®ï¼ŒApplicationå°±åˆ›å»ºå®Œæˆäº†ï¼Œæ¥ä¸‹æ¥åœ¨ActivityThread.handleBindApplicationæ–¹æ³•ä¸­ï¼Œè¿˜æœ‰ä¸€æ­¥é‡è¦æ“ä½œï¼Œå°±æ˜¯è°ƒç”¨Applicationçš„onCreateæ–¹æ³• è¿™é‡Œæ˜¯å€ŸåŠ©äº†Instrumentation.callApplicationOnCreateæ–¹æ³• 123public void callApplicationOnCreate(Application app) &#123; app.onCreate();&#125; å°±æ˜¯ç®€ç®€å•å•ç›´æ¥è°ƒç”¨äº†Applicationçš„onCreateæ–¹æ³• ç»“æŸåˆ°è¿™é‡Œä¸ºæ­¢ï¼Œæ•´ä¸ªApplicationçš„å·¥ä½œéƒ½åšå®Œäº†ï¼Œæ¥ä¸‹æ¥è¿˜å‰©æ£€æŸ¥å¹¶å¯åŠ¨Activityã€Serviceå’ŒBroadcastReceiverï¼Œè¿™äº›å†…å®¹å°±æ”¾åˆ°ä¸‹ä¸€ç¯‡å†è®²å§ è¯è¯´å›æ¥æœ‰ç‚¹æƒ­æ„§ï¼Œè¿™ç¯‡æ–‡ç« è·ç¦»ä¸Šä¸€ç¯‡é—´éš”äº†ä¸‰ä¸ªæœˆï¼Œæœ€è¿‘åœ¨å¿™ä¸€äº›åˆ«çš„é¡¹ç›®ï¼Œè¿™ç¯‡æ–‡ç« æ–­æ–­ç»­ç»­å†™äº†ä¸€ä¸ªå¤šæœˆæ‰æ†‹å‡ºæ¥ï¼Œæ„Ÿè°¢å¤§å®¶çš„æ”¯æŒï¼Œåœ¨è¿™é‡Œæˆ‘åšç€è„¸çš®æ±‚ç‚¹èµæ±‚æ”¶è—ï¼Œå¤§å®¶çš„æ”¯æŒå°±æ˜¯æˆ‘åˆ›ä½œçš„åŠ¨åŠ›","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"}]},{"title":"Androidäº¤å‰ç¼–è¯‘OpenCV+FFmpeg+x264çš„è‰°éš¾å†ç¨‹","slug":"android/compile/Androidäº¤å‰ç¼–è¯‘OpenCV+FFmpeg+x264çš„è‰°éš¾å†ç¨‹","date":"2022-09-14T06:55:13.000Z","updated":"2022-11-13T09:55:54.358Z","comments":true,"path":"2022/09/14/android/compile/Androidäº¤å‰ç¼–è¯‘OpenCV+FFmpeg+x264çš„è‰°éš¾å†ç¨‹/","link":"","permalink":"http://yoursite.com/2022/09/14/android/compile/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV+FFmpeg+x264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/","excerpt":"","text":"å‰è¨€å¦‚æœä½ æ²¡æœ‰å…´è¶£çœ‹å®Œæœ¬æ–‡ï¼Œåªæƒ³è·å¾—å¯ç¼–è¯‘çš„ä»£ç æˆ–ç¼–è¯‘åçš„äº§ç‰©ï¼Œå¯ä»¥ç›´æ¥ç‚¹å‡»ä¸‹é¢çš„é“¾æ¥ï¼Œè·Ÿéšæ­¥éª¤ç¼–è¯‘ä»£ç æˆ–ç›´æ¥ä¸‹è½½æˆ‘ç¼–è¯‘å¥½çš„äº§ç‰© æ³¨ï¼šç¼–è¯‘é¡ºåºè¦æŒ‰ç…§ x264 -&gt; FFmpeg -&gt; OpenCV è¿™æ ·æ¥ x264 FFmpeg OpenCV èµ·å› æœ€è¿‘åœ¨åšä¸€ä¸ªè§†é¢‘ç”Ÿæˆçš„appï¼Œä½¿ç”¨OpenCVåº“å®ç°ï¼Œç”¨çš„æ˜¯Cè¯­è¨€ï¼Œä¸€å¼€å§‹æˆ‘æ˜¯åœ¨mac_x86ä¸Šä¹¦å†™ä»£ç ï¼Œfourccè§†é¢‘ç¼–ç å™¨é€‰æ‹©çš„æ˜¯mp4vï¼Œè§†é¢‘è¾“å‡ºä¸€åˆ‡æ­£å¸¸ï¼Œç„¶åå½“æˆ‘å°†ä»£ç ç§»æ¤åˆ°Androidä¸Šæ—¶å‘ç°ï¼Œä»OpenCVå®˜ç½‘ä¸‹è½½çš„soåº“å®ƒä¸æ”¯æŒç¼–ç mp4væ ¼å¼ï¼Œåªèƒ½ç¼–ç æˆmjpgæ ¼å¼ï¼Œåç¼€åä¸ºaviï¼Œå°´å°¬çš„æ˜¯AndroidåŸç”Ÿåˆä¸æ”¯æŒæ’­æ”¾è¿™ç§æ ¼å¼çš„è§†é¢‘ï¼Œæ‰€ä»¥è¦æƒ³åŠæ³•è®©OpenCVæ”¯æŒç¼–ç mp4væˆ–h264ç­‰æ ¼å¼ æˆ‘åœ¨ç½‘ä¸Šæœç´¢äº†ä¸€ä¸‹ä¸ºä»€ä¹ˆOpenCVé»˜è®¤ä¸æ”¯æŒh264æ ¼å¼ï¼Œå¾—çŸ¥OpenCVé»˜è®¤ä½¿ç”¨FFmpegåšè§†é¢‘å¤„ç†ï¼ŒFFmpegä½¿ç”¨çš„æ˜¯LGPLåè®®ï¼Œè€Œx264ä½¿ç”¨çš„æ˜¯GPLåè®®ï¼ŒGPLåè®®å…·æœ‰ä¼ æŸ“æ€§ï¼Œå¦‚æœä»£ç ä¸­ä½¿ç”¨äº†GPLåè®®çš„è½¯ä»¶ï¼Œåˆ™è¦æ±‚ä½ çš„ä»£ç ä¹Ÿå¿…é¡»å¼€æºã€‚æˆ‘çŒœæµ‹æ˜¯å› ä¸ºè¿™ä¸ªåŸå› ï¼ŒFFmpegé»˜è®¤ä¸ä½¿ç”¨GPLåè®®çš„è½¯ä»¶ï¼Œé¿å…äº§ç”Ÿä¸€äº›ä¸å¿…è¦çš„é—®é¢˜å’Œçº çº·ï¼Œå¦‚æœæƒ³è¦ä½¿ç”¨GPLåè®®çš„è½¯ä»¶ï¼Œåˆ™éœ€è¦åœ¨ç¼–è¯‘çš„æ—¶å€™åŠ ä¸Š--enable-gplé€‰é¡¹ åŸºäºæ­¤ä¸ŠåŸå› ï¼Œæˆ‘å¼€å¯äº†æˆ‘è‰°éš¾çš„ç¼–è¯‘ä¹‹è·¯ å£°æ˜æœ¬ç¯‡æ–‡ç« åªé’ˆå¯¹Linuxç³»ç»Ÿç¼–è¯‘ï¼Œå…¶ä»–ç³»ç»Ÿä¸ä¿è¯å¯ä»¥ç¼–è¯‘é€šè¿‡ æœ¬ç¯‡æ–‡ç« ä½¿ç”¨çš„NDKç‰ˆæœ¬ä¸º21.4.7075529ï¼Œä¸åŒçš„ç‰ˆæœ¬å¯èƒ½ä¼šæœ‰äº›å·®åˆ«ï¼Œéœ€è¦è‡ªè¡Œè°ƒæ•´ æœ¬äººå¯¹c/c++ç¼–è¯‘è¿™å—å¹¶ä¸æ˜¯å¾ˆäº†è§£ï¼Œå¾ˆå¤šä¸œè¥¿ä¹Ÿæ˜¯è¾¹å­¦ä¹ è¾¹å°è¯•çš„ï¼Œå¦‚æœæœ‰ä»€ä¹ˆé”™è¯¯çš„è¯ä¹Ÿæ³è¯·å¤§ä½¬ä»¬æŒ‡æ­£ï¼Œè°¢è°¢ å‡†å¤‡å‡†å¤‡ä¸€å°Linuxç³»ç»Ÿçš„ç”µè„‘æˆ–ä½¿ç”¨è™šæ‹Ÿæœºï¼Œå®‰è£…ä¸€äº›æœ€åŸºæœ¬çš„ç¼–è¯‘å·¥å…·ï¼ˆmakeã€cmakeç­‰ï¼‰ï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯Ubuntuç³»ç»Ÿï¼Œå¼ºçƒˆå»ºè®®åœ¨å®‰è£…çš„æ—¶å€™é€‰æ‹©å®Œæ•´å®‰è£…ï¼Œè¿™æ ·è¿™äº›ç¼–è¯‘å·¥å…·åº”è¯¥éƒ½ä¼šè·Ÿéšç³»ç»Ÿè‡ªåŠ¨å®‰è£…å¥½ Androidäº¤å‰ç¼–è¯‘è‚¯å®šæ˜¯éœ€è¦NDKçš„ï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯21.4.7075529ç‰ˆæœ¬ï¼Œr19ä»¥ä¸Šç‰ˆæœ¬çš„NDKéƒ½æ˜¯ç›´æ¥è‡ªå¸¦äº†å·¥å…·é“¾ï¼Œè€Œr19ä¹‹å‰çš„ç‰ˆæœ¬åˆ™éœ€è¦å…ˆç”Ÿæˆå·¥å…·é“¾ï¼Œå…·ä½“å¯ä»¥å‚è€ƒç‹¬ç«‹å·¥å…·é“¾ï¼ˆå·²å¼ƒç”¨ï¼‰è¿™ç¯‡æ–‡æ¡£ x264æ—¢ç„¶éœ€è¦ä¾èµ–x264ï¼Œé‚£æˆ‘ä»¬è‚¯å®šæ˜¯å…ˆè¦ç¼–è¯‘x264åº“ï¼Œå„ä½å¯ä»¥cloneæˆ‘å‡†å¤‡å¥½çš„tag 1git clone -b v0.164_compilable https://github.com/dreamgyf/x264.git è¿™ä¸ªç‰ˆæœ¬æ˜¯ä»åŸx264é•œåƒä»“åº“çš„stableåˆ†æ”¯åˆ‡å‡ºçš„ï¼Œç‰ˆæœ¬ä¸º0.164ã€‚æƒ³çŸ¥é“x264ç‰ˆæœ¬çš„è¯ï¼Œå¯ä»¥è¿è¡Œå…¶ç›®å½•ä¸‹çš„version.shè„šæœ¬ï¼Œå®ƒä¼šè¾“å‡ºä¸‰ä¸²æ•°å­—ï¼Œå‰é¢çš„164æ˜¯åœ¨x264.hä¸­å®šä¹‰çš„X264_BUILDï¼Œç¬¬äºŒä¸ª3095+4è¡¨ç¤ºmasteråˆ†æ”¯çš„æäº¤æ•° + masteråˆ†æ”¯åˆ°HEADçš„æäº¤æ•°ï¼Œæœ€åçš„ä¸€ä¸²æ•°å­—è¡¨ç¤ºå½“å‰åˆ†æ”¯æœ€æ–°çš„commit id åœ¨æ„å»ºç¼–è¯‘è„šæœ¬ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆè¦çœ‹çœ‹è¿™ä¸ªåº“æä¾›äº†å“ªäº›ç¼–è¯‘é€‰é¡¹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨x264æ ¹ç›®å½•ä¸‹æœ‰ä¸€ä¸ªconfigureæ–‡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªè„šæœ¬æ–‡ä»¶ï¼Œå¤§å¤šæ•°åº“éƒ½æä¾›äº†è¿™ä¸ªè„šæœ¬ï¼Œç”¨æ¥è´Ÿè´£ç”ŸæˆMakefileï¼Œå‡†å¤‡å¥½æ„å»ºç¯å¢ƒï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹é¢è¿™ä¸ªå‘½ä»¤è·å–å¸®åŠ©æ–‡ä»¶ 1./configure --help &gt; help.txt å¯ä»¥çœ‹åˆ°ï¼Œé‡Œé¢æä¾›äº†ä¸€äº›ç¼–è¯‘é€‰é¡¹åŠå…¶æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®è¿™äº›é€‰é¡¹å’Œæè¿°æ„å»ºç¼–è¯‘è„šæœ¬ å…ˆçœ‹ä¸€ä¸‹æˆ‘å†™å¥½çš„è„šæœ¬å§ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Linux äº¤å‰ç¼–è¯‘ Android åº“è„šæœ¬if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang export CFLAGS=\"-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security -O0 -DNDEBUG -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;\" ../../configure \\ --host=$&#123;TRIPLE&#125; \\ --prefix=$PREFIX \\ --enable-static \\ --enable-shared \\ --enable-pic \\ --disable-lavf \\ --sysroot=$TOOLCHAIN/sysroot make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd ..&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do build $arch breakdone è¿™ä¹Ÿæ˜¯æˆ‘å…¶ä»–åº“ç¼–è¯‘è„šæœ¬çš„åŸºæœ¬ç»“æ„ï¼Œé¦–å…ˆéœ€è¦ANDROID_NDKç¯å¢ƒå˜é‡ç”¨æ¥ç¡®å®šNDKçš„ä½ç½® OUTPUT_DIRä¸ºç¼–è¯‘çš„è¾“å‡ºè·¯å¾„ï¼Œæˆ‘è¿™é‡Œå‘½åä¸º_output_ï¼Œé˜²æ­¢å’Œæºç æœ¬èº«çš„ç›®å½•é‡å APIä¸ºæœ€ä½æ”¯æŒçš„Android APIç‰ˆæœ¬ï¼Œæˆ‘è¿™é‡Œå†™çš„21ï¼Œä¹Ÿå°±æ˜¯Android 5.0 TOOLCHAINä¸ºäº¤å‰ç¼–è¯‘å·¥å…·é“¾çš„è·¯å¾„ï¼Œå¯¹äºr19ä¹‹å‰çš„NDKï¼Œéœ€è¦å°†å…¶æ”¹ä¸ºä½ ç”Ÿæˆå‡ºæ¥çš„å·¥å…·é“¾çš„è·¯å¾„ï¼Œr19ä¹‹åä¸éœ€è¦æ”¹åŠ¨ æˆ‘è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªbuildå‡½æ•°ï¼Œé€šè¿‡è¾“å…¥çš„ABIç¼–è¯‘å‡ºå¯¹åº”æ¶æ„çš„äº§ç‰©ã€‚ABIæ€»å…±æœ‰å››ç§ï¼šarmeabi-v7aï¼Œarm64-v8aï¼Œx86ï¼Œx86-64ï¼Œè¿™ä¸ªå†³å®šä½ çš„Appèƒ½åœ¨å“ªäº›å¹³å°æ¶æ„ä¸Šè¿è¡Œ è¿™é‡Œï¼Œæˆ‘é€šè¿‡ä¸åŒçš„ABIå®šä¹‰äº†ä¸åŒçš„TRIPLEå˜é‡ï¼Œè¿™æ˜¯éµå¾ªäº†NDKå·¥å…·é“¾çš„å‘½åè§„åˆ™ï¼Œå¯ä»¥åœ¨ å°† NDK ä¸å…¶ä»–æ„å»ºç³»ç»Ÿé…åˆä½¿ç”¨ è¿™ç¯‡æ–‡æ¡£ä¸­æ‰¾åˆ° åœ¨$TOOLCHAIN/binç›®å½•ä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿèƒ½å‘ç°è¿™ç§å‘½åæ–¹å¼ æˆ‘ä»¬éœ€è¦æ ¹æ®å…¶å‘½åè§„åˆ™ï¼ŒæŒ‡å®šç›¸åº”çš„ç¼–è¯‘å™¨ï¼Œè®¾ç½®ç›¸åº”çš„hostï¼Œtarget å…³äºbuildã€hostå’Œtargetçš„å«ä¹‰å¯ä»¥å‚é˜… Cross-Compilation è¿™ç¯‡æ–‡æ¡£ build: ç¼–è¯‘è¯¥åº“æ‰€ä½¿ç”¨çš„å¹³å°ï¼Œä¸è®¾ç½®çš„è¯ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨æµ‹æ‰€åœ¨å¹³å° host: ç¼–è¯‘å‡ºçš„åº“è¦è¿è¡Œåœ¨å“ªä¸ªå¹³å°ä¸Šï¼Œä¸è®¾ç½®çš„è¯ï¼Œé»˜è®¤ä¸ºbuildå€¼ï¼Œä½†è¿™æ ·ä¹Ÿå°±ä¸å†æ˜¯äº¤å‰ç¼–è¯‘äº† target: è¯¥åº“æ‰€å¤„ç†çš„ç›®æ ‡å¹³å°ï¼Œä¸è®¾ç½®çš„è¯ï¼Œé»˜è®¤ä¸ºhostå€¼ å¤šæ•°UNIXå¹³å°ä¼šé€šè¿‡CCè°ƒç”¨Cè¯­è¨€ç¼–è¯‘å™¨ï¼Œè€ŒCFLAGSåˆ™æ˜¯Cè¯­è¨€ç¼–è¯‘å™¨çš„ç¼–è¯‘é€‰é¡¹ï¼Œæ ¹æ®æˆ‘ä»¬ä¸Šæ–‡æ‰€è¯´çš„å‘½åè§„åˆ™å¯ä»¥å‘ç°ï¼Œå·¥å…·é“¾ä¸­Cè¯­è¨€ç¼–è¯‘å™¨çš„å‘½åè§„åˆ™ä¸º${TRIPLE}${API}-clangï¼Œå‡è®¾æˆ‘ä»¬è¦ç¼–è¯‘arm64-v8a ABIï¼ŒAPI 21çš„åº“ï¼Œåˆ™éœ€è¦æŒ‡å®šCCä¸ºaarch64-linux-android21-clang è‡³äºCFLAGSè¿™é‡Œå°±ä¸å¤šè¯´äº†ï¼Œå¯ä»¥è‡ªè¡ŒæŸ¥é˜… Clangç¼–è¯‘å™¨å‚æ•°æ‰‹å†Œ ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¿…é¡»è¦æŒ‡å®š--gcc-toolchainå’Œ--targetï¼Œå¦åˆ™ç¼–è¯‘ä¼šæŠ¥é”™ ç„¶åå°±æ˜¯configureçš„é€‰é¡¹äº†ï¼Œè¿™é‡Œå¿…é¡»æŒ‡å®š--hostå’Œ--sysrootï¼Œsysrootè¡¨ç¤ºä½¿ç”¨è¿™ä¸ªå€¼ä½œä¸ºç¼–è¯‘çš„å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶çš„æŸ¥æ‰¾ç›®å½•ï¼Œè¯¥ç›®å½•ç»“æ„å¦‚ä¸‹ 12345678sysrootâ””â”€â”€ usr â”œâ”€â”€ include â””â”€â”€ lib â”œâ”€â”€ aarch64-linux-android â”œâ”€â”€ arm-linux-androideabi â”œâ”€â”€ i686-linux-android â””â”€â”€ x86_64-linux-android --prefixä¸ºç¼–è¯‘åçš„å®‰è£…è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘äº§ç‰©çš„è¾“å‡ºè·¯å¾„ --enable-staticå’Œ--enable-sharedé€‰é¡¹è¡¨ç¤ºç”Ÿæˆé™æ€åº“å’ŒåŠ¨æ€åº“ï¼Œå¤§å®¶å¯ä»¥æ ¹æ®æƒ…å†µè‡ªè¡Œé€‰æ‹© nprocæ˜¯Linuxä¸‹çš„ä¸€ä¸ªå‘½ä»¤ï¼Œè¡¨ç¤ºå½“å‰è¿›ç¨‹å¯ç”¨çš„CPUæ ¸æ•°ï¼Œä¸€èˆ¬makeä½¿ç”¨çº¿ç¨‹æ•°ä¸ºCPUæ ¸æ•°å°±å¯ä»¥äº†ï¼Œå¦‚æœç¼–è¯‘äº§ç”Ÿé—®é¢˜ï¼Œå¯ä»¥å°è¯•è°ƒå°è¿™ä¸ªå€¼ åˆ°è¿™é‡ŒåŸºæœ¬ä¸Šæ•´ä¸ªæ„å»ºè„šæœ¬å°±åˆ†æå®Œäº†ï¼Œå¤§å®¶è°ƒæ•´å®Œç¼–è¯‘é€‰é¡¹åä¿å­˜ï¼Œå°±å¯ä»¥æ‰§è¡Œå‘½ä»¤./build.shå¼€å§‹ç¼–è¯‘äº† FFmpegç„¶åæˆ‘ä»¬å¼€å§‹ç¼–è¯‘FFmpeg 1git clone -b v5.0_compilable https://github.com/dreamgyf/FFmpeg.git è¿™ä¸ªç‰ˆæœ¬æ˜¯ä»åŸFFmpegé•œåƒä»“åº“çš„n5.0åˆ†æ”¯åˆ‡å‡ºçš„ï¼Œç‰ˆæœ¬ä¸º5.0ã€‚å…¶å®æˆ‘ä¸€å¼€å§‹ç”¨çš„æ˜¯5.1ç‰ˆæœ¬ï¼Œä½†å½“æˆ‘è§£å†³äº†å„ç§é—®é¢˜ç¼–è¯‘OpenCVåˆ°ä¸€åŠæ—¶ï¼Œæç¤ºæˆ‘FFmpegçš„ä¸€äº›ç¬¦å·æ‰¾ä¸åˆ°ï¼Œç„¶åæˆ‘å»æŸ¥äº†ä¸€ä¸‹OpenCVçš„ Change Log ï¼Œå‘ç°å®ƒçš„æœ€æ–°ç‰ˆæœ¬4.6.0åˆšåˆšæ”¯æŒFFmpeg 5.0ç‰ˆæœ¬ï¼Œæ— å¥ˆåˆ‡åˆ°5.0é‡æ–°ç¼–è¯‘ è¿˜æ˜¯ä¸€æ ·ï¼Œå…ˆçœ‹ç¼–è¯‘è„šæœ¬ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Linux äº¤å‰ç¼–è¯‘ Android åº“è„šæœ¬if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"ROOT_PATH=`pwd`OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64# ç¼–è¯‘å‡ºçš„x264åº“åœ°å€X264_ANDROID_DIR=/home/dreamgyf/compile/x264/_output_/productEXTRA_CONFIGURATIONS=\"--disable-stripping \\ --disable-ffmpeg \\ --disable-doc \\ --disable-appkit \\ --disable-avfoundation \\ --disable-coreimage \\ --disable-amf \\ --disable-audiotoolbox \\ --disable-cuda-llvm \\ --disable-cuvid \\ --disable-d3d11va \\ --disable-dxva2 \\ --disable-ffnvcodec \\ --disable-nvdec \\ --disable-nvenc \\ --disable-vdpau \\ --disable-videotoolbox\"function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang export CFLAGS=\"-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security -O0 -DNDEBUG -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;\" ../../configure \\ --prefix=$PREFIX \\ --enable-cross-compile \\ --sysroot=$TOOLCHAIN/sysroot \\ --cc=$CC \\ --enable-static \\ --enable-shared \\ --disable-asm \\ --enable-gpl \\ --enable-libx264 \\ --extra-cflags=\"-I$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/include\" \\ --extra-ldflags=\"-L$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib\" \\ $EXTRA_CONFIGURATIONS make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd $PREFIX `$ROOT_PATH/ffmpeg-config-gen.sh $&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib/libx264.a` cd $OUTPUT_PATH&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do build $arch breakdone è¿™ä¸ªè„šæœ¬å’Œx264çš„ç¼–è¯‘è„šæœ¬åŸºæœ¬ç›¸åŒï¼Œç”±äºæˆ‘ä»¬éœ€è¦ä¾èµ–x264åº“ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä½¿åˆšåˆšç¼–è¯‘å‡ºæ¥çš„x264äº§ç‰©å‚ä¸FFmpegçš„ç¼–è¯‘ï¼Œä¸ºæ­¤ï¼Œéœ€è¦å°†X264_ANDROID_DIRæ”¹æˆè‡ªå·±ç¼–è¯‘å‡ºæ¥çš„x264äº§ç‰©è·¯å¾„ åœ¨configureé€‰é¡¹ä¸­ï¼Œæˆ‘ä»¬éœ€è¦--enable-cross-compileé€‰é¡¹è¡¨ç¤ºå¼€å¯äº¤å‰ç¼–è¯‘ï¼Œæˆ‘ä»¬è¿™é‡Œéœ€è¦è®¾ç½®--ccé€‰æ‹©Cè¯­è¨€ç¼–è¯‘å™¨ï¼Œå¦åˆ™ç¼–è¯‘æ—¶ä¼šä½¿ç”¨ç³»ç»Ÿé»˜è®¤çš„ç¼–è¯‘å™¨ï¼Œ--disable-asmé€‰é¡¹æˆ‘æµ‹è¯•æ˜¯å¿…é¡»è¦å¸¦ä¸Šçš„ï¼Œå¦åˆ™ç¼–è¯‘ä¼šæŠ¥é”™ï¼Œç„¶åå°±æ˜¯--enable-libx264å¼€å¯x264ä¾èµ–äº†ï¼Œæ ¹æ®æˆ‘åœ¨èµ·å› ä¸­è¯´åˆ°çš„å¼€æºåè®®é—®é¢˜ï¼Œæ‰€ä»¥--enable-gplé€‰é¡¹ä¹Ÿè¦å¼€å¯ï¼Œæœ€åéœ€è¦æŒ‡å®šx264çš„å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶ç›®å½•ï¼Œåˆ†åˆ«ä½¿ç”¨--extra-cflagså’Œ--extra-ldflagsåŠ ä¸Šå¯¹åº”çš„å‚æ•° è¿™é‡Œæä¸€ä¸‹ï¼Œç¼–è¯‘å™¨ä¼šä¼˜å…ˆä»-I -Lä¸¤ä¸ªå‚æ•°æŒ‡å®šçš„ç›®å½•ä¸­å»æŸ¥æ‰¾å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶ï¼Œå¦‚æœæ²¡æ‰¾åˆ°çš„è¯å†ä¼šä»sysrootç›®å½•ä¸­æŸ¥æ‰¾ æœ€åï¼Œæˆ‘è¿˜å†™äº†ä¸€ä¸ªffmpeg-config-gen.shè„šæœ¬ï¼Œå®ƒçš„ä½œç”¨æ˜¯ç”Ÿæˆffmpeg-config.cmakeæ–‡ä»¶ï¼Œç”¨æ¥ç»™OpenCVç¼–è¯‘æä¾›FFmpegä¾èµ–æŸ¥æ‰¾ï¼Œè¿™ä¸ªç­‰æˆ‘ä»¬åé¢è®²åˆ°OpenCVä¾èµ–FFmpegçš„å¤„ç†æ—¶å†è¯´ å’Œx264ä¸€æ ·ï¼Œå¤§å®¶è°ƒæ•´å®Œç¼–è¯‘é€‰é¡¹åä¿å­˜ï¼Œå°±å¯ä»¥æ‰§è¡Œå‘½ä»¤./build.shå¼€å§‹ç¼–è¯‘äº† OpenCVæœ€åï¼Œæˆ‘ä»¬å¼€å§‹ç¼–è¯‘OpenCV 1git clone -b v4.6.0_compilable https://github.com/dreamgyf/opencv.git è¿™ä¸ªç‰ˆæœ¬æ˜¯ä»åŸOpenCVä»“åº“çš„4.6.0åˆ†æ”¯åˆ‡å‡ºçš„ï¼Œç‰ˆæœ¬ä¸º4.6.0ï¼Œæ˜¯ç›®å‰çš„æœ€æ–°ç‰ˆæœ¬ã€‚å…¶å®å‰é¢ä¸¤ä¸ªåº“çš„ç¼–è¯‘éƒ½æŒºé¡ºåˆ©çš„ï¼Œæœ€éº»çƒ¦çš„é—®é¢˜éƒ½å‡ºåœ¨OpenCVè¿™é‡Œ æˆ‘ä»¬è¿˜æ˜¯å…ˆçœ‹ç¼–è¯‘è„šæœ¬ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Linux äº¤å‰ç¼–è¯‘ Android åº“è„šæœ¬if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64# ç¼–è¯‘å‡ºçš„ffmpegåº“åœ°å€FFMPEG_ANDROID_DIR=/home/dreamgyf/compile/FFmpeg/_output_/productEXTRA_ATTRS=\"-DWITH_CUDA=OFF \\ -DWITH_GTK=OFF \\ -DWITH_1394=OFF \\ -DWITH_GSTREAMER=OFF \\ -DWITH_LIBV4L=OFF \\ -DWITH_TIFF=OFF \\ -DBUILD_OPENEXR=OFF \\ -DWITH_OPENEXR=OFF \\ -DBUILD_opencv_ocl=OFF \\ -DWITH_OPENCL=OFF\"function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" TOOLCHAIN_NAME=\"arm-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" TOOLCHAIN_NAME=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" TOOLCHAIN_NAME=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" TOOLCHAIN_NAME=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI cmake ../.. \\ -DCMAKE_INSTALL_PREFIX=$PREFIX \\ -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=$ABI \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=\"android-$&#123;API&#125;\" \\ -DANDROID_LINKER_FLAGS=\"-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API\" \\ -DBUILD_ANDROID_PROJECTS=OFF \\ -DBUILD_ANDROID_EXAMPLES=OFF \\ -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS \\ -DWITH_FFMPEG=ON \\ -DOPENCV_GENERATE_PKGCONFIG=ON \\ -DOPENCV_FFMPEG_USE_FIND_PACKAGE=ON \\ -DFFMPEG_DIR=$&#123;FFMPEG_ANDROID_DIR&#125;/$&#123;ABI&#125; \\ $EXTRA_ATTRS make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd ..&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do echo \"Select build static or shared libs:\" select type in \"static\" \"shared\" do if [[ $type == \"static\" ]]; then BUILD_SHARED_LIBS=OFF elif [[ $type == \"shared\" ]]; then BUILD_SHARED_LIBS=ON else BUILD_SHARED_LIBS=OFF fi break done build $arch breakdone ä¸Šé¢çš„å‡†å¤‡å·¥ä½œå’Œå‰é¢çš„å‡ ä¸ªè„šæœ¬ä¸€æ ·ï¼Œä¸åŒçš„æ˜¯ï¼ŒOpenCVå¹¶æ²¡æœ‰ä¸ºæˆ‘ä»¬å‡†å¤‡configureè„šæœ¬ï¼Œæ‰€ä»¥è¿™æ¬¡æˆ‘ä»¬ä½¿ç”¨cmakeç”ŸæˆMakefileï¼Œå†è¿›è¡Œç¼–è¯‘ æ—¢ç„¶ä½¿ç”¨cmakeäº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸å†åƒä¹‹å‰ä¸€æ ·ï¼Œè‡ªå·±æŒ‡å®šç¼–è¯‘å™¨ç­‰å·¥å…·é“¾äº†ï¼ŒNDKä¸ºæˆ‘ä»¬æä¾›äº†äº¤å‰ç¼–è¯‘å·¥å…·é“¾cmakeè„šæœ¬$ANDROID_NDK/build/cmake/android.toolchain.cmakeï¼Œæˆ‘ä»¬åªéœ€è¦æŒ‡å®šå…¶ä¸ºCMAKE_TOOLCHAIN_FILEï¼Œç„¶åä¸ºå…¶æä¾›ç›¸å…³å‚æ•°å³å¯ï¼Œå…·ä½“çš„ä½¿ç”¨æ–¹å¼å¯ä»¥å‚è€ƒ CMake è¿™ç¯‡æ–‡æ¡£ã€‚æˆ‘ä»¬è¿™é‡Œåªéœ€è¦æä¾›æœ€ä½é™åº¦çš„å‡ ä¸ªå‚æ•°ANDROID_ABIã€ANDROID_NDKã€ANDROID_PLATFORMå³å¯ å¦‚æœéœ€è¦ç¼–è¯‘Androidç¤ºä¾‹å·¥ç¨‹çš„è¯ï¼Œè¿˜éœ€è¦åœ¨ç¯å¢ƒå˜é‡ä¸­è®¾ç½®ANDROID_HOMEå’ŒANDROID_SDKï¼Œæˆ‘è¿™é‡Œå°±ç›´æ¥ä½¿ç”¨-DBUILD_ANDROID_PROJECTS=OFFå’Œ-DBUILD_ANDROID_EXAMPLES=OFFå°†å…¶å…³é—­äº† ç„¶åå°±æ˜¯å¦‚ä½•è®©OpenCVä¾èµ–æˆ‘ä»¬ç¼–è¯‘çš„FFmpegçš„é—®é¢˜äº†ï¼Œåˆ°è¿™ä¸€æ­¥æˆ‘ä»¬å°±éœ€è¦å»å®ƒçš„CMakeLists.txtä¸­çœ‹çœ‹å®ƒæ˜¯æ€æ ·å£°æ˜FFmpegçš„äº† æ‰“å¼€CMakeLists.txtæ–‡ä»¶ï¼Œæœç´¢FFMPEGå…³é”®å­—ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è¿™ä¸€æ®µä»£ç  1234567891011121314if(WITH_FFMPEG OR HAVE_FFMPEG) if(OPENCV_FFMPEG_USE_FIND_PACKAGE) status(\" FFMPEG:\" HAVE_FFMPEG THEN \"YES (find_package)\" ELSE \"NO (find_package)\") elseif(WIN32) status(\" FFMPEG:\" HAVE_FFMPEG THEN \"YES (prebuilt binaries)\" ELSE NO) else() status(\" FFMPEG:\" HAVE_FFMPEG THEN YES ELSE NO) endif() status(\" avcodec:\" FFMPEG_libavcodec_VERSION THEN \"YES ($&#123;FFMPEG_libavcodec_VERSION&#125;)\" ELSE NO) status(\" avformat:\" FFMPEG_libavformat_VERSION THEN \"YES ($&#123;FFMPEG_libavformat_VERSION&#125;)\" ELSE NO) status(\" avutil:\" FFMPEG_libavutil_VERSION THEN \"YES ($&#123;FFMPEG_libavutil_VERSION&#125;)\" ELSE NO) status(\" swscale:\" FFMPEG_libswscale_VERSION THEN \"YES ($&#123;FFMPEG_libswscale_VERSION&#125;)\" ELSE NO) status(\" avresample:\" FFMPEG_libavresample_VERSION THEN \"YES ($&#123;FFMPEG_libavresample_VERSION&#125;)\" ELSE NO)endif() æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œè¦æƒ³ä¾èµ–FFmpegï¼Œæˆ‘ä»¬éœ€è¦å°†HAVE_FFMPEGçš„å€¼è®¾ä¸ºtrueï¼Œå¹¶ä¸”è¦æŒ‡å®šFFmpeg libsçš„ç‰ˆæœ¬ æˆ‘ä»¬å†çœ‹åˆ°OPENCV_FFMPEG_USE_FIND_PACKAGEè¿™ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºé€šè¿‡find_packageçš„æ–¹å¼å¯»æ‰¾FFmpegåº“ è¿™é‡Œï¼Œæˆ‘ä»¬å…¶å®æœ‰ä¸¤ç§åŠæ³•ä¾èµ–FFmpegåº“ï¼Œä¸€æ˜¯é€šè¿‡find_packageï¼ŒäºŒæ˜¯é€šè¿‡pkg-configï¼Œæˆ‘ä¸¤ç§æ–¹å¼éƒ½å°è¯•äº†åï¼Œè§‰å¾—è¿˜æ˜¯ä½¿ç”¨find_packageè¿™ç§æ–¹å¼æ¯”è¾ƒå®¹æ˜“ï¼Œä¾µå…¥æ€§è¾ƒå°ï¼Œä½¿ç”¨pkg-configéœ€è¦æ‰‹åŠ¨ä¿®æ”¹OpenCVæ£€æµ‹FFmpegçš„cmakeæ–‡ä»¶æºç ï¼Œä¸ä¼˜é›… æ¥ç€æˆ‘ä»¬å»çœ‹OpenCVæ˜¯å¦‚ä½•æ£€æµ‹FFmpegæ˜¯å¦å­˜åœ¨çš„ï¼Œè¿™é‡Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°$OPENCV/modules/videoio/cmake/detect_ffmpeg.cmakeè¿™ä¸ªæ–‡ä»¶ï¼Œåœ¨å¼€å¤´ç¬¬ä¸€æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬å°±å¯ä»¥å‘ç° 123456789if(NOT HAVE_FFMPEG AND OPENCV_FFMPEG_USE_FIND_PACKAGE) if(OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"1\" OR OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"ON\") set(OPENCV_FFMPEG_USE_FIND_PACKAGE \"FFMPEG\") endif() find_package($&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;) # Required components: AVCODEC AVFORMAT AVUTIL SWSCALE if(FFMPEG_FOUND OR FFmpeg_FOUND) set(HAVE_FFMPEG TRUE) endif()endif() å¦‚æœOPENCV_FFMPEG_USE_FIND_PACKAGEé€‰é¡¹è¢«æ‰“å¼€ï¼Œåˆ™ä¼šä½¿ç”¨find_package(FFMPEG)å»æŸ¥æ‰¾è¿™ä¸ªåº“ find_package(&lt;PackageName&gt;)æœ‰ä¸¤ç§æ¨¡å¼ï¼Œä¸€ç§æ˜¯Moduleæ¨¡å¼ï¼Œä¸€ç§æ˜¯Configæ¨¡å¼ åœ¨Moduleæ¨¡å¼ä¸­ï¼Œcmakeéœ€è¦æ‰¾åˆ°ä¸€ä¸ªåä¸ºFind&lt;PackageName&gt;.cmakeçš„æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶è´Ÿè´£æ‰¾åˆ°åº“æ‰€åœ¨è·¯å¾„ï¼Œå¼•å…¥å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶ã€‚cmakeä¼šåœ¨ä¸¤ä¸ªåœ°æ–¹æŸ¥æ‰¾è¿™ä¸ªæ–‡ä»¶ï¼Œå…ˆæ˜¯æˆ‘ä»¬æ‰‹åŠ¨æŒ‡å®šçš„CMAKE_MODULE_PATHç›®å½•ï¼Œæœç´¢ä¸åˆ°å†æœç´¢$CMAKE/share/cmake-&lt;version&gt;/Modulesç›®å½• å¦‚æœModuleæ¨¡å¼æ²¡æ‰¾åˆ°ç›¸åº”æ–‡ä»¶ï¼Œåˆ™ä¼šè½¬ä¸ºConfigæ¨¡å¼ï¼Œåœ¨è¿™ä¸ªæ¨¡å¼ä¸‹ï¼Œcmakeéœ€è¦æ‰¾åˆ°&lt;lowercasePackageName&gt;-config.cmakeæˆ–&lt;PackageName&gt;Config.cmakeæ–‡ä»¶ï¼Œé€šè¿‡è¿™ä¸ªæ–‡ä»¶æ‰¾åˆ°åº“æ‰€åœ¨è·¯å¾„ï¼Œå¼•å…¥å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶ã€‚cmakeä¼šä¼˜å…ˆåœ¨&lt;PackageName&gt;_DIRç›®å½•ä¸‹æœç´¢ç›¸åº”æ–‡ä»¶ å…³äºfind_packageæ›´è¯¦ç»†çš„è§£é‡Šï¼Œå¯ä»¥å»æŸ¥çœ‹ å®˜æ–¹æ–‡æ¡£ æˆ‘è¿™é‡Œé€‰ç”¨äº†Configæ¨¡å¼ï¼Œå†ç»“åˆä¹‹å‰åœ¨CMakeLists.txtå’Œdetect_ffmpeg.cmakeä¸­çš„å†…å®¹ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºç»“è®ºï¼š æˆ‘ä»¬éœ€è¦åœ¨æ„å»ºè„šæœ¬ä¸­è®¾ç½®WITH_FFMPEG=ONï¼ŒOPENCV_FFMPEG_USE_FIND_PACKAGE=ONï¼ŒFFMPEG_DIRå¹¶ä¸”FFMPEG_DIRç›®å½•ä¸‹éœ€è¦æœ‰ffmpeg-config.cmakeæˆ–FFMPEGConfig.cmakeæ–‡ä»¶ è¿™é‡Œå°±è¡”æ¥äº†ä¸Šæ–‡ï¼Œæˆ‘ä¸ºä»€ä¹ˆè¦å†™ä¸€ä¸ªffmpeg-config-gen.shè„šæœ¬ï¼Œè„šæœ¬çš„å†…å®¹å¾ˆç®€å•ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹å®ƒç”Ÿæˆå‡ºæ¥çš„ffmpeg-config.cmakeæ–‡ä»¶ 123456789101112131415161718192021222324252627282930313233343536373839set(FFMPEG_PATH \"$&#123;CMAKE_CURRENT_LIST_DIR&#125;\")set(FFMPEG_EXEC_DIR \"$&#123;FFMPEG_PATH&#125;/bin\")set(FFMPEG_LIBDIR \"$&#123;FFMPEG_PATH&#125;/lib\")set(FFMPEG_INCLUDE_DIRS \"$&#123;FFMPEG_PATH&#125;/include\")set(FFMPEG_LIBRARIES $&#123;FFMPEG_LIBDIR&#125;/libavformat.a $&#123;FFMPEG_LIBDIR&#125;/libavdevice.a $&#123;FFMPEG_LIBDIR&#125;/libavcodec.a $&#123;FFMPEG_LIBDIR&#125;/libavutil.a $&#123;FFMPEG_LIBDIR&#125;/libswscale.a $&#123;FFMPEG_LIBDIR&#125;/libswresample.a $&#123;FFMPEG_LIBDIR&#125;/libavfilter.a $&#123;FFMPEG_LIBDIR&#125;/libpostproc.a /home/dreamgyf/compile/x264/_output_/product/arm64-v8a/lib/libx264.a z)set(FFMPEG_libavformat_FOUND TRUE)set(FFMPEG_libavdevice_FOUND TRUE)set(FFMPEG_libavcodec_FOUND TRUE)set(FFMPEG_libavutil_FOUND TRUE)set(FFMPEG_libswscale_FOUND TRUE)set(FFMPEG_libswresample_FOUND TRUE)set(FFMPEG_libavfilter_FOUND TRUE)set(FFMPEG_libpostproc_FOUND TRUE)set(FFMPEG_libavcodec_VERSION 59.18.100)set(FFMPEG_libavdevice_VERSION 59.4.100)set(FFMPEG_libavfilter_VERSION 8.24.100)set(FFMPEG_libavformat_VERSION 59.16.100)set(FFMPEG_libavutil_VERSION 57.17.100)set(FFMPEG_libpostproc_VERSION 56.3.100)set(FFMPEG_libswresample_VERSION 4.3.100)set(FFMPEG_libswscale_VERSION 6.4.100)set(FFMPEG_FOUND TRUE)set(FFMPEG_LIBS $&#123;FFMPEG_LIBRARIES&#125;) è¿™é‡Œä¸»è¦ä¸ºcmakeæä¾›äº†ä¸‰ä¸ªå˜é‡ FFMPEG_INCLUDE_DIRSï¼šæä¾›å¤´æ–‡ä»¶ç›®å½• FFMPEG_LIBRARIESï¼šæä¾›åº“æ–‡ä»¶é“¾æ¥ FFMPEG_FOUNDï¼šå‘Šè¯‰cmakeæ‰¾åˆ°äº†FFmpegåº“ è¿™é‡Œè¿˜æœ‰å‡ ä¸ªç‚¹è¦è¯´ï¼Œé¦–å…ˆï¼Œcmakeä¸­çš„åº“æ–‡ä»¶é“¾æ¥é¡ºåºç¬¦åˆgccé“¾æ¥é¡ºåºè§„åˆ™ï¼Œæ‰€ä»¥è¯´åº“çš„ä¹¦å†™é¡ºåºä¹Ÿæ˜¯æœ‰ä¸¥æ ¼è¦æ±‚çš„ï¼Œè¢«ä¾èµ–çš„åº“è¦æ”¾åœ¨ä¾èµ–å®ƒçš„åº“çš„åé¢ï¼Œæ­£å¦‚è¿™ä¸ªæ–‡ä»¶ï¼ŒFFmpegéœ€è¦ä¾èµ–x264ï¼Œæ‰€ä»¥æˆ‘éœ€è¦å°†x264æ”¾åœ¨æ‰€æœ‰FFmpegåº“çš„æœ€åé¢ FFmpegéœ€è¦ä¾èµ–zlibåº“ï¼Œæ‰€ä»¥æˆ‘åœ¨åé¢å¢åŠ äº†ä¸€ä¸ªzè¡¨ç¤ºä¾èµ–zlibåº“ FFmpegè¿™äº›åº“çš„ç‰ˆæœ¬å®šä¹‰æ˜¯ä»$FFMPEG_PRODUCT/$ABI/lib/pkgconfigç›®å½•ä¸‹å„ä¸ªæ–‡ä»¶è¯»å‡ºæ¥çš„ ffmpeg-config.cmakeæ–‡ä»¶å†™å®Œï¼Œæˆ‘ä»¬å†å›è¿‡å¤´æ¥çœ‹ä¸€ä¸‹detect_ffmpeg.cmake 123456789if(NOT HAVE_FFMPEG AND OPENCV_FFMPEG_USE_FIND_PACKAGE) if(OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"1\" OR OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"ON\") set(OPENCV_FFMPEG_USE_FIND_PACKAGE \"FFMPEG\") endif() find_package($&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;) # Required components: AVCODEC AVFORMAT AVUTIL SWSCALE if(FFMPEG_FOUND OR FFmpeg_FOUND) set(HAVE_FFMPEG TRUE) endif()endif() å¯ä»¥çœ‹åˆ°æœ€åçš„ if ä¸­ï¼Œå¦‚æœFFMPEG_FOUNDä¸ºtrueï¼Œåˆ™è®¾ç½®HAVE_FFMPEGä¸ºtrueï¼Œæ­£å¥½å¯¹åº”äº†æˆ‘ä»¬åœ¨ffmpeg-config.cmakeä¸­çš„è¡Œä¸ºï¼Œè¿™ä¸‹ï¼ŒCMakeLists.txtå°±å¯ä»¥æ‰¾åˆ°æˆ‘ä»¬çš„FFmpegåº“äº† è¿™é‡Œè¿˜æœ‰ä¸€ç‚¹ï¼Œdetect_ffmpeg.cmakeä¸­æœ‰ä¸€æ®µç”¨æ¥æµ‹è¯•çš„ä»£ç  1234567891011121314if(HAVE_FFMPEG AND NOT HAVE_FFMPEG_WRAPPER AND NOT OPENCV_FFMPEG_SKIP_BUILD_CHECK) try_compile(__VALID_FFMPEG \"$&#123;OpenCV_BINARY_DIR&#125;\" \"$&#123;OpenCV_SOURCE_DIR&#125;/cmake/checks/ffmpeg_test.cpp\" CMAKE_FLAGS \"-DINCLUDE_DIRECTORIES:STRING=$&#123;FFMPEG_INCLUDE_DIRS&#125;\" \"-DLINK_LIBRARIES:STRING=$&#123;FFMPEG_LIBRARIES&#125;\" OUTPUT_VARIABLE TRY_OUT ) if(NOT __VALID_FFMPEG) message(FATAL_ERROR \"FFMPEG: test check build log:\\n$&#123;TRY_OUT&#125;\") message(STATUS \"WARNING: Can't build ffmpeg test code\") set(HAVE_FFMPEG FALSE) endif()endif() å…¶ä¸­çš„message(FATAL_ERROR &quot;FFMPEG: test check build log:\\n${TRY_OUT}&quot;)åŸæœ¬æ˜¯è¢«æ³¨é‡Šäº†çš„ï¼Œæˆ‘å¼ºçƒˆå»ºè®®å„ä½å°†å…¶æ‰“å¼€ï¼Œè¿™æ ·å¦‚æœå“ªé‡Œæœ‰è¯¯ï¼Œä¸€å¼€å§‹å°±å¯ä»¥æŠ¥é”™å¹¶é™„å¸¦è¯¦ç»†ä¿¡æ¯ï¼Œå…å¾—åˆ°æ—¶å€™ç¼–åˆ°ä¸€åŠæ‰æŠ¥é”™ï¼Œæµªè´¹æ—¶é—´ åˆ°è¿™é‡Œï¼Œæˆ‘æœ¬ä»¥ä¸ºä¸‡äº‹å¤§å‰äº†ï¼Œäºæ˜¯å¼€å§‹ç¼–è¯‘ï¼Œè¿™é‡Œæˆ‘ä½¿ç”¨äº†BUILD_SHARED_LIBS=ONé€‰é¡¹ç¼–è¯‘åŠ¨æ€åº“ï¼Œarmeabi-v7aé¡ºåˆ©ç¼–è¯‘é€šè¿‡ï¼Œä½†å½“arm64-v8aç¼–è¯‘åˆ°ä¸€åŠæ—¶çªç„¶æŠ¥é”™ï¼Œæç¤ºlibz.so, needed by ../../lib/arm64-v8a/libopencv_core.so, not found (try using -rpath or -rpath-link) æˆ‘è§‚å¯Ÿäº†ä¸€ä¸‹NDKç›®å½•ç»“æ„ï¼Œå‘ç°libz.soåŠ¨æ€åº“æ–‡ä»¶å¯ä»¥åœ¨$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$APIä¸‹æ‰¾åˆ°ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„TOOLCHAIN_NAMEå’ŒTRIPLEå¾ˆç›¸ä¼¼ï¼Œä½†åœ¨armeabi-v7aæƒ…å†µä¸‹åˆæœ‰äº›ç»†å¾®çš„ä¸åŒï¼Œæ‰€ä»¥æˆ‘åˆæ–°å®šä¹‰äº†è¿™ä¸ªå˜é‡ ç„¶åæˆ‘å¼€å§‹å°è¯•åŠ å…¥-rpath-linké€‰é¡¹ï¼Œé¦–å…ˆï¼Œæˆ‘å°è¯•æ·»åŠ äº†ä¸€é¡¹cmakeé€‰é¡¹CMAKE_SHARED_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;ï¼Œå‘ç°ï¼Œè™½ç„¶åœ¨ç¼–è¯‘å¼€å¤´çš„è¾“å‡ºä¸­å¯ä»¥çœ‹å‡ºï¼Œè¿™ä¸ªå‚æ•°ç¡®å®è¢«åŠ ä¸Šç”Ÿæ•ˆäº†ï¼Œä½†åœ¨ç¼–è¯‘åˆ°åŒæ ·çš„åœ°æ–¹æ—¶ï¼Œä»ç„¶ä¼šæŠ¥ç›¸åŒçš„é”™è¯¯ï¼Œè¿™é‡Œæˆ‘ä¸å¤ªæ¸…æ¥šï¼Œéš¾é“å‚æ•°çš„é¡ºåºä¹Ÿä¼šå¯¹ç¼–è¯‘é€ æˆå½±å“å—ï¼Ÿ äºæ˜¯æˆ‘å»æŸ¥çœ‹äº†android.toolchain.cmakeæ–‡ä»¶ï¼Œçœ‹ä»–æ˜¯æ€ä¹ˆæ·»åŠ è¿™äº›é€‰é¡¹çš„ï¼Œå‘ç°äº†è¿™ä¹ˆä¸€è¡Œ 1set(CMAKE_SHARED_LINKER_FLAGS \"$&#123;ANDROID_LINKER_FLAGS&#125; $&#123;CMAKE_SHARED_LINKER_FLAGS&#125;\") äºæ˜¯æˆ‘åœ¨è¿™è¡Œä»£ç å‰åŠ äº†è¿™ä¹ˆä¸€è¡Œ 1list(APPEND ANDROID_LINKER_FLAGS -Wl,-rpath-link=$&#123;ANDROID_TOOLCHAIN_ROOT&#125;/sysroot/usr/lib/$&#123;ANDROID_TOOLCHAIN_NAME&#125;/$&#123;ANDROID_PLATFORM_LEVEL&#125;) è®©-rpath-linkè¿™ä¸ªé€‰é¡¹æå‰ä¸€ç‚¹ï¼Œæœä¸å…¶ç„¶ï¼Œç¼–è¯‘é¡ºåˆ©é€šè¿‡äº†ï¼Œä½†è¿™æ ·åšæœ‰ç‚¹éº»çƒ¦ï¼Œè¿˜å¾—æ”¹NDKé‡Œçš„é…ç½®ï¼Œäºæ˜¯æˆ‘åœ¨æ„å»ºè„šæœ¬é‡ŒåŠ äº†ä¸€ä¸ªå‚æ•°ANDROID_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;ï¼Œè¿™æ ·çš„è¯ï¼Œ-rpath-linké€‰é¡¹ä¼šè¢«æåˆ°Linker flagsçš„æœ€å‰é¢ï¼Œç»è¿‡æµ‹è¯•ï¼Œè¿™æ ·ä¹Ÿå¯ä»¥ç¼–è¯‘é€šè¿‡ï¼Œäºæ˜¯OpenCVçš„ç¼–è¯‘è„šæœ¬ä¹Ÿå°±è¿™ä¹ˆå®Œæˆäº† å½“ç„¶è¿™é‡Œè¿˜å‰©ä¸€ä¸ªç–‘ç‚¹ï¼Œä¸ºä»€ä¹ˆä¸åŠ -rpath-linkçš„æ—¶å€™ï¼Œarm64-v8aç¼–è¯‘æŠ¥é”™ä½†armeabi-v7aå´ç¼–è¯‘é€šè¿‡ï¼Œå¸Œæœ›æœ‰å¤§ä½¬å¯ä»¥æŒ‡ç‚¹ä¸€ä¸‹ FreeTypeæˆ‘çš„Appä¸­è¿˜ç”¨åˆ°äº†FreeTypeåº“æ¸²æŸ“å­—ä½“ï¼Œåœ¨è¿™é‡Œé¡ºä¾¿ä¹ŸæŠŠå®ƒçš„ç¼–è¯‘æ–¹å¼æ”¾å‡ºæ¥å§ ç›´æ¥å» FreeType è¿™é‡Œä¸‹è½½æˆ‘ç¼–è¯‘å¥½çš„ç‰ˆæœ¬æˆ–è€…æºç ï¼Œæ ¹æ®æˆ‘å†™çš„æ­¥éª¤è¿›è¡Œç¼–è¯‘å°±å¯ä»¥äº† åœ¨Androidä¸­ä½¿ç”¨åœ¨Androidä¸­ä½¿ç”¨æ—¶éœ€è¦æ³¨æ„ï¼Œå¦‚æœä½ ä½¿ç”¨é™æ€åº“çš„æ–¹å¼çš„è¯ï¼Œéœ€è¦å°†OpenCVç¼–è¯‘å‡ºæ¥çš„ç¬¬ä¸‰æ–¹åº“ä¹ŸåŠ å…¥åˆ°é“¾æ¥ä¸­ï¼Œæ”¾åœ¨OpenCVçš„åé¢ï¼Œå¦å¤–FFmpegè¿˜éœ€è¦mediandkå’Œzlibè¿™ä¸¤ä¸ªä¾èµ–ï¼Œå…·ä½“å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç  12345678910111213141516171819202122232425262728293031323334353637383940414243444546target_link_libraries( textvideo freetype # opencv opencv_videoio opencv_photo opencv_highgui opencv_imgproc opencv_imgcodecs opencv_dnn opencv_core # ffmpeg ffmpeg_avformat ffmpeg_avdevice ffmpeg_avcodec ffmpeg_avutil ffmpeg_swscale ffmpeg_swresample ffmpeg_avfilter # ffmpegä¾èµ– mediandk z # x264 x264 # opencvç¬¬ä¸‰æ–¹æ”¯æŒåº“ ade cpufeatures ittnotify libjpeg-turbo libopenjp2 libpng libprotobuf libwebp quirc tegra_hal # android jniåº“ jnigraphics android log) æ€»ç»“è™½ç„¶æˆ‘è¿™ç¯‡æ–‡ç« å†™çš„çœ‹èµ·æ¥ç¼–è¯‘çš„è¿‡ç¨‹å¾ˆç®€å•ï¼Œæ ¹æœ¬ä¸åƒæ ‡é¢˜æ‰€è¯´çš„é‚£ä¹ˆè‰°éš¾ï¼Œä½†å®é™…ä¸Šæˆ‘å‰å‰ååå¼„äº†å¤§æ¦‚æœ‰ä¸€ä¸ªå¤šæ˜ŸæœŸæ‰çœŸæ­£å®Œæ•´ç¼–å‡ºå¯ç”¨ç‰ˆæœ¬ï¼Œå‰å‰ååç¼–è¯‘å¤±è´¥äº†ä¸è¯´ä¸€ç™¾æ¬¡ä¹Ÿæœ‰å‡ åæ¬¡ï¼Œå¯¹æˆ‘è¿™ç§ä¸æ‡‚cè¯­è¨€ç¼–è¯‘çš„ç®€ç›´æ˜¯æŠ˜ç£¨ã€‚å› ä¸ºæˆ‘æ˜¯åœ¨å…¨éƒ¨å¼„å®Œåæ‰å¼€å§‹å†™çš„æ–‡ç« ï¼Œæ‰€ä»¥åŸºæœ¬ä¸Šå‘éƒ½è¸©çš„å·®ä¸å¤šäº†ï¼Œå…¶ä¸­æœ‰äº›å‘å°è±¡ä¹Ÿæ²¡é‚£ä¹ˆæ¸…æ¥šäº†ï¼Œæˆ‘ä¹Ÿæ²¡é‚£ä¹ˆå¤šç²¾åŠ›å†å»å¤ç°å‡ºé‚£äº›å‘äº†ï¼Œæ€ä¹ˆè¯´å‘¢ï¼Œèƒ½æˆåŠŸå°±ä¸‡äº‹å¤§å‰å§ ğŸ˜­","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"äº¤å‰ç¼–è¯‘","slug":"Android/äº¤å‰ç¼–è¯‘","permalink":"http://yoursite.com/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"ç¼–è¯‘","slug":"ç¼–è¯‘","permalink":"http://yoursite.com/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Androidäº¤å‰ç¼–è¯‘","slug":"Androidäº¤å‰ç¼–è¯‘","permalink":"http://yoursite.com/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"x264","slug":"x264","permalink":"http://yoursite.com/tags/x264/"}]},{"title":"Androidæºç åˆ†æ - Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰","date":"2022-08-01T07:19:35.000Z","updated":"2022-11-13T09:55:54.352Z","comments":true,"path":"2022/08/01/android/aosp/Androidæºç åˆ†æ-Activityå¯åŠ¨æµç¨‹ï¼ˆä¸Šï¼‰/","link":"","permalink":"http://yoursite.com/2022/08/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä½œä¸ºä¸€åAndroidå¼€å‘ï¼Œæˆ‘ä»¬æœ€ç†Ÿæ‚‰å¹¶ä¸”æœ€å¸¸æ‰“äº¤é“çš„å½“ç„¶éå››å¤§ç»„ä»¶ä¸­çš„Activityè«å±ï¼Œè¿™æ¬¡æˆ‘ä»¬å°±æ¥è®²è®²ä¸€ä¸ªActivityæ˜¯æ€æ ·å¯åŠ¨èµ·æ¥çš„ æœ¬æ¥æœ¬ç¯‡æƒ³è¦è®²ActivityManagerServiceçš„ï¼Œä½†AMSä¸­çš„å†…å®¹è¿‡å¤šè¿‡äºç¹æ‚ï¼Œä¸å¦‚ç”¨è¿™ç§ä»¥çº¿åŠé¢çš„æ–¹å¼ï¼Œé€šè¿‡Activityçš„å¯åŠ¨æµç¨‹è¿™ä¸€æ¡çº¿ï¼Œå»äº†è§£ActivityThreadï¼ŒAMSç­‰æ˜¯æ€ä¹ˆå·¥ä½œçš„ Androidçª—å£ç»“æ„å…³ç³»åœ¨å¼€å§‹æ­£å¼æ·±å…¥ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç†ä¸€ä¸‹Androidçš„çª—å£ç»“æ„å…³ç³»ï¼Œä»¥å…åé¢çœ‹åˆ°æºç é‡Œå„ç§parentã€childå¤´æ™•ï¼Œæˆ‘ç”»äº†ä¸€å¼ æ ‘çŠ¶å…³ç³»å›¾æ¥æè¿°å®ƒ ä¸Šå›¾ä¸­çš„æ‰€æœ‰ç±»éƒ½æ˜¯WindowContainerçš„å­ç±»ï¼ŒWindowContaineræ˜¯ä¸€ä¸ªçª—å£å®¹å™¨ï¼Œå®ƒçš„childä¹Ÿæ˜¯WindowContainerï¼Œå®ƒæ˜¯ç”¨æ¥ç®¡ç†çª—å£å­å®¹å™¨çš„ å¯ä»¥å…ˆä¸ç”¨çº ç»“ç†è§£è¿™å¼ å›¾ä¸­çš„å…³ç³»ï¼Œé¡ºç€æºç å¾€ä¸‹çœ‹ï¼Œç¢°åˆ°ä¸ç†è§£çš„åœ°æ–¹å›å¤´çœ‹ä¸€ä¸‹å°±å¯ä»¥äº† startActivityä½œä¸ºAndroidå¼€å‘ï¼ŒstartActivityè¿™ä¸ªæ–¹æ³•ä¸€å®šéå¸¸ç†Ÿæ‚‰ï¼Œæˆ‘ä»¬ä»¥è¿™ä¸ªå‡½æ•°ä½œä¸ºå…¥å£æ¥åˆ†æActivityçš„å¯åŠ¨æµç¨‹ Activityå’ŒContextImplçš„startActivityæ–¹æ³•å®ç°ä¸å¤ªä¸€æ ·ï¼Œä½†æœ€ç»ˆéƒ½è°ƒç”¨äº†Instrumentation.execStartActivityæ–¹æ³• Instrumentationè·¯å¾„ï¼šframeworks/base/core/java/android/app/Instrumentation.java ä»¥ä¸‹æ˜¯Googleå®˜æ–¹å¯¹è¿™ä¸ªç±»åŠŸèƒ½çš„æ³¨é‡Š Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xmlâ€™s &lt;instrumentation&gt; tag. ç®€å•ç¿»è¯‘ä¸€ä¸‹ï¼Œå°±æ˜¯è¿™ä¸ªç±»æ˜¯ç”¨äºç›‘æ§ç³»ç»Ÿä¸åº”ç”¨çš„äº¤äº’çš„ï¼ˆonCreateç­‰ç”Ÿå‘½å‘¨æœŸä¼šç»å†Instrumentationè¿™ä¹ˆä¸€ç¯ï¼‰ï¼Œå®ƒä¼šåœ¨ä»»ä½•Appä»£ç æ‰§è¡Œå‰è¢«åˆå§‹åŒ–ã€‚ æœ¬äººçŒœæµ‹ï¼Œè¿™ä¸ªç±»ä¸»è¦å­˜åœ¨çš„æ„ä¹‰æ˜¯ä¸ºäº†ç»™è‡ªåŠ¨åŒ–æµ‹è¯•æä¾›ä¸€ä¸ªåˆ‡å…¥ç‚¹ 1234567891011121314151617181920212223242526272829public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; //è®°å½•è°ƒç”¨è€… Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; ... //è‡ªåŠ¨åŒ–æµ‹è¯•ç›¸å…³ try &#123; //è¿ç§»é¢å¤–çš„URIæ•°æ®æµåˆ°å‰ªè´´æ¿ï¼ˆå¤„ç†Intentä½¿ç”¨ACTION_SENDæˆ–ACTION_SEND_MULTIPLEå…±äº«æ•°æ®çš„æƒ…å†µï¼‰ intent.migrateExtraStreamToClipData(who); //å¤„ç†ç¦»å¼€å½“å‰Appè¿›ç¨‹çš„æƒ…å†µ intent.prepareToLeaveProcess(who); //è¯·æ±‚ATMSå¯åŠ¨Activity int result = ActivityTaskManager.getService().startActivity(whoThread, who.getBasePackageName(), who.getAttributionTag(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //æ£€æŸ¥å¼‚å¸¸æƒ…å†µï¼ŒæŠ›å‡ºå¯¹åº”å¼‚å¸¸ checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; è¿™ä¸ªå‡½æ•°è°ƒç”¨äº†ActivityTaskManager.getService.startActivityæ–¹æ³• 123456789101112public static IActivityTaskManager getService() &#123; return IActivityTaskManagerSingleton.get();&#125;private static final Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton = new Singleton&lt;IActivityTaskManager&gt;() &#123; @Override protected IActivityTaskManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE); return IActivityTaskManager.Stub.asInterface(b); &#125; &#125;; è¿™é‡ŒgetServiceå‡ºæ¥çš„å¾ˆæ˜æ˜¾çš„æ˜¯ä¸€ä¸ªè¿œç¨‹binderå¯¹è±¡ï¼Œæˆ‘ä»¬ä¹‹å‰å·²ç»åˆ†æè¿‡é‚£ä¹ˆå¤šbinderçŸ¥è¯†äº†ï¼Œä»¥åå°±ä¸å†è¿‡å¤šå•°å—¦äº†ï¼Œè¿™é‡Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯ActivityTaskManagerSerivceï¼ˆä»¥ä¸‹ç®€ç§°ATMSï¼‰çš„startActivityæ–¹æ³• ActivityTaskManagerSerivceATMSæ˜¯Android 10ä»¥åæ–°åŠ çš„ä¸€ä¸ªæœåŠ¡ï¼Œç”¨æ¥ä¸“é—¨å¤„ç†Activityç›¸å…³å·¥ä½œï¼Œåˆ†æ‹…AMSçš„å·¥ä½œ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage, String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;private int startActivityAsUser(IApplicationThread caller, String callingPackage, @Nullable String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; //æ–­è¨€å‘èµ·startActivityè¯·æ±‚æ–¹çš„UIDå’ŒcallingPackageæŒ‡å‘çš„æ˜¯åŒä¸€ä¸ªApp assertPackageMatchesCallingUid(callingPackage); //ç¡®è®¤è¯·æ±‚æ–¹æ²¡æœ‰è¢«éš”ç¦» enforceNotIsolatedCaller(\"startActivityAsUser\"); //æ£€æŸ¥å¹¶è·å–å½“å‰ç”¨æˆ·IDï¼ˆå¤šç”¨æˆ·æ¨¡å¼ï¼‰ userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\"); //ä½¿ç”¨ActivityStarterå¯åŠ¨Activity return getActivityStartController().obtainStarter(intent, \"startActivityAsUser\") .setCaller(caller) //è°ƒç”¨æ–¹ApplicationThread .setCallingPackage(callingPackage) //è°ƒç”¨æ–¹åŒ…å .setCallingFeatureId(callingFeatureId) // Context.getAttributionTag() .setResolvedType(resolvedType) //è®¾ç½®Intentè§£æç±»å‹ .setResultTo(resultTo) //è®¾ç½®ç›®æ ‡Activity Tokenï¼ˆContextImpl.startActivityä¼ å…¥å‚æ•°ä¸ºnullï¼‰ .setResultWho(resultWho) //è®¾ç½®ç›®æ ‡Activityï¼ˆContextImpl.startActivityä¼ å…¥å‚æ•°ä¸ºnullï¼‰ .setRequestCode(requestCode) //è®¾ç½®requestCode .setStartFlags(startFlags) // startFlags == 0 .setProfilerInfo(profilerInfo) // null .setActivityOptions(bOptions) //è®¾ç½®Activity Options Bundle .setUserId(userId) //è®¾ç½®ç”¨æˆ·ID .execute();&#125; è¿™ä¸ªå‡½æ•°å¤§éƒ¨åˆ†å†…å®¹éƒ½æ˜¯æ£€æŸ¥ï¼Œæœ€é‡è¦çš„æ˜¯æœ€åä¸€æ®µä½¿ç”¨ActivityStarterå¯åŠ¨Activityï¼Œé¦–å…ˆé€šè¿‡ActivityStartControllerçš„obtainStarteræ–¹æ³•è·å–ä¸€ä¸ªActivityStarterå®ä¾‹ï¼Œç„¶åè°ƒç”¨å„ç§setæ–¹æ³•è®¾ç½®å‚æ•°ï¼Œæœ€åæ‰§è¡Œexecuteæ–¹æ³•æ‰§è¡Œ ActivityStarterè¿™ä¸ªç±»ä»åå­—å°±èƒ½çœ‹å‡ºæ¥ï¼Œå°±æ˜¯ä¸€ä¸ªä¸“é—¨å¤„ç†Activityå¯åŠ¨çš„ç±» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int execute() &#123; try &#123; // Refuse possible leaked file descriptors //æ ¡éªŒIntentï¼Œä¸å…è®¸å…¶æºå¸¦fd if (mRequest.intent != null &amp;&amp; mRequest.intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; final LaunchingState launchingState; synchronized (mService.mGlobalLock) &#123; //é€šè¿‡Tokenè·å–è°ƒç”¨æ–¹ActivityRecord final ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo); //è®°å½•å¯åŠ¨çŠ¶æ€ launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching( mRequest.intent, caller); &#125; // If the caller hasn't already resolved the activity, we're willing // to do so here. If the caller is already holding the WM lock here, // and we need to check dynamic Uri permissions, then we're forced // to assume those permissions are denied to avoid deadlocking. //é€šè¿‡Intentè§£æActivityä¿¡æ¯ if (mRequest.activityInfo == null) &#123; mRequest.resolveActivity(mSupervisor); &#125; int res; synchronized (mService.mGlobalLock) &#123; ... //å¤„ç†Configuration //æ¸…é™¤Binderè°ƒç”¨æ–¹UIDå’ŒPIDï¼Œç”¨å½“å‰è¿›ç¨‹çš„UIDå’ŒPIDæ›¿ä»£ï¼Œå¹¶è¿”å›ä¹‹å‰çš„UIDå’ŒPIDï¼ˆUIDï¼šå‰32ä½ï¼ŒPIDï¼šå32ä½ï¼‰ final long origId = Binder.clearCallingIdentity(); //è§£ææˆä¸ºé‡é‡çº§è¿›ç¨‹ï¼ˆå¦‚æœè®¾ç½®äº†ç›¸å…³flagçš„è¯ï¼‰ //è¿™é‡Œçš„é‡é‡çº§è¿›ç¨‹æŒ‡çš„æ˜¯ä¸èƒ½ä¿å­˜çŠ¶æ€çš„åº”ç”¨è¿›ç¨‹ res = resolveToHeavyWeightSwitcherIfNeeded(); if (res != START_SUCCESS) &#123; return res; &#125; //æ‰§è¡Œè¯·æ±‚ res = executeRequest(mRequest); //æ¢å¤ä¹‹å‰çš„Binderè°ƒç”¨æ–¹UIDå’ŒPID Binder.restoreCallingIdentity(origId); ... //æ›´æ–°Configuration // Notify ActivityMetricsLogger that the activity has launched. // ActivityMetricsLogger will then wait for the windows to be drawn and populate // WaitResult. //è®°å½•å¯åŠ¨çŠ¶æ€ mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res, mLastStartActivityRecord); //è¿”å›å¯åŠ¨ç»“æœ return getExternalResult(mRequest.waitResult == null ? res : waitForResult(res, mLastStartActivityRecord)); &#125; &#125; finally &#123; //æ¸…ç†å›æ”¶å·¥ä½œ onExecutionComplete(); &#125;&#125; è¿™ä¸ªå‡½æ•°æ¯ä¸€æ­¥åšäº†ä»€ä¹ˆæˆ‘éƒ½ç”¨æ³¨é‡Šæ ‡å‡ºæ¥äº†ï¼Œå¤§å®¶çœ‹çœ‹å°±å¥½ï¼Œé‡ç‚¹åœ¨äºå…¶ä¸­çš„executeRequest(mRequest) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319/** * Executing activity start request and starts the journey of starting an activity. Here * begins with performing several preliminary checks. The normally activity launch flow will * go through &#123;@link #startActivityUnchecked&#125; to &#123;@link #startActivityInner&#125;. */private int executeRequest(Request request) &#123; if (TextUtils.isEmpty(request.reason)) &#123; throw new IllegalArgumentException(\"Need to specify a reason.\"); &#125; mLastStartReason = request.reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord = null; final IApplicationThread caller = request.caller; Intent intent = request.intent; NeededUriGrants intentGrants = request.intentGrants; String resolvedType = request.resolvedType; ActivityInfo aInfo = request.activityInfo; ResolveInfo rInfo = request.resolveInfo; final IVoiceInteractionSession voiceSession = request.voiceSession; final IBinder resultTo = request.resultTo; String resultWho = request.resultWho; int requestCode = request.requestCode; int callingPid = request.callingPid; int callingUid = request.callingUid; String callingPackage = request.callingPackage; String callingFeatureId = request.callingFeatureId; final int realCallingPid = request.realCallingPid; final int realCallingUid = request.realCallingUid; final int startFlags = request.startFlags; final SafeActivityOptions options = request.activityOptions; Task inTask = request.inTask; int err = ActivityManager.START_SUCCESS; // Pull the optional Ephemeral Installer-only bundle out of the options early. final Bundle verificationBundle = options != null ? options.popAppVerificationBundle() : null; WindowProcessController callerApp = null; if (caller != null) &#123; //è·å–è°ƒç”¨æ–¹åº”ç”¨è¿›ç¨‹å¯¹åº”çš„WindowProcessController //è¿™ä¸ªç±»æ˜¯ç”¨äºå’ŒProcessRecordè¿›è¡Œé€šè®¯çš„ callerApp = mService.getProcessController(caller); if (callerApp != null) &#123; callingPid = callerApp.getPid(); callingUid = callerApp.mInfo.uid; &#125; else &#123; //å¼‚å¸¸æƒ…å†µï¼ŒstartActivityçš„è°ƒç”¨æ–¹è¿›ç¨‹ä¸å­˜åœ¨æˆ–æœªå¯åŠ¨ Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //è·å–å½“å‰ç”¨æˆ·ID final int userId = aInfo != null &amp;&amp; aInfo.applicationInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; if (err == ActivityManager.START_SUCCESS) &#123; Slog.i(TAG, \"START u\" + userId + \" &#123;\" + intent.toShortString(true, true, true, false) + \"&#125; from uid \" + callingUid); &#125; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; //è°ƒç”¨æ–¹Activity Token != null if (resultTo != null) &#123; //è·å–è°ƒç”¨æ–¹ActivityRecordï¼ˆè¦æ±‚å­˜åœ¨ä»»æ„ä¸€ä¸ªWindowæ ˆä¸­ï¼Œå³æ˜¯RootWindowçš„å­å—£ï¼‰ sourceRecord = mRootWindowContainer.isInAnyStack(resultTo); if (DEBUG_RESULTS) &#123; Slog.v(TAG_RESULTS, \"Will send result to \" + resultTo + \" \" + sourceRecord); &#125; if (sourceRecord != null) &#123; //è°ƒç”¨æ–¹éœ€è¦response if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); //å¤šActivityä¼ å€¼åœºæ™¯ if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; ... &#125; //æ‰¾ä¸åˆ°å¯ä»¥å¤„ç†æ­¤Intentçš„ç»„ä»¶ if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; // We couldn't find a class that can handle the given Intent. // That's the end of that! err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; //Intentä¸­è§£æä¸å‡ºç›¸åº”çš„Activityä¿¡æ¯ if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; // We couldn't find the specific class specified in the Intent. // Also the end of the line. err = ActivityManager.START_CLASS_NOT_FOUND; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123; ... //è¯­è¨€äº¤äº’ç›¸å…³ &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; ... //è¯­è¨€äº¤äº’ç›¸å…³ &#125; final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getRootTask(); if (err != START_SUCCESS) &#123; //å›è°ƒç»™è°ƒç”¨æ–¹Activityç»“æœ if (resultRecord != null) &#123; resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED, null /* data */, null /* dataGrants */); &#125; SafeActivityOptions.abort(options); return err; &#125; //æ£€æŸ¥å¯åŠ¨Activityçš„æƒé™ boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, callingFeatureId, request.ignoreTargetSecurity, inTask != null, callerApp, resultRecord, resultStack); abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid, callingPackage); boolean restrictedBgActivity = false; if (!abort) &#123; try &#123; Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, \"shouldAbortBackgroundActivityStart\"); //æ£€æŸ¥æ˜¯å¦è¦é™åˆ¶åå°å¯åŠ¨Activity restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, realCallingUid, realCallingPid, callerApp, request.originatingPendingIntent, request.allowBackgroundActivityStart, intent); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER); &#125; &#125; // Merge the two options bundles, while realCallerOptions takes precedence. //è¿‡æ¸¡åŠ¨ç”»ç›¸å…³ ActivityOptions checkedOptions = options != null ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null; if (request.allowPendingRemoteAnimationRegistryLookup) &#123; checkedOptions = mService.getActivityStartController() .getPendingRemoteAnimationRegistry() .overrideOptionsIfNeeded(callingPackage, checkedOptions); &#125; if (mService.mController != null) &#123; try &#123; // The Intent we give to the watcher has the extra data stripped off, since it // can contain private information. Intent watchIntent = intent.cloneFilter(); //è¿™ä¸ªæ–¹æ³•ä¼¼ä¹åªæ‰“å°äº†ä¸€äº›æ—¥å¿—ï¼Œæ’è¿”å›trueï¼Œå³abort |= false abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; catch (RemoteException e) &#123; mService.mController = null; &#125; &#125; //åˆå§‹åŒ–ActivityStartInterceptor mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage, callingFeatureId); if (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid, checkedOptions)) &#123; // activity start was intercepted, e.g. because the target user is currently in quiet // mode (turn off work) or the target application is suspended //æ‹¦æˆªå¹¶è½¬åŒ–æˆå…¶ä»–çš„å¯åŠ¨æ¨¡å¼ intent = mInterceptor.mIntent; rInfo = mInterceptor.mRInfo; aInfo = mInterceptor.mAInfo; resolvedType = mInterceptor.mResolvedType; inTask = mInterceptor.mInTask; callingPid = mInterceptor.mCallingPid; callingUid = mInterceptor.mCallingUid; checkedOptions = mInterceptor.mActivityOptions; // The interception target shouldn't get any permission grants // intended for the original destination intentGrants = null; &#125; if (abort) &#123; //å›è°ƒç»™è°ƒç”¨æ–¹Activityç»“æœ if (resultRecord != null) &#123; resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED, null /* data */, null /* dataGrants */); &#125; // We pretend to the caller that it was really started, but they will just get a // cancel result. ActivityOptions.abort(checkedOptions); return START_ABORTED; &#125; // If permissions need a review before any of the app components can run, we // launch the review activity and pass a pending intent to start the activity // we are to launching now after the review is completed. if (aInfo != null) &#123; //å¦‚æœå¯åŠ¨çš„Activityæ²¡æœ‰ç›¸åº”æƒé™ï¼Œåˆ™éœ€è¦ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤å…è®¸æƒé™åï¼Œå†è¿›è¡Œå¯åŠ¨å·¥ä½œ if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired( aInfo.packageName, userId)) &#123; //å°†åŸæ¥çš„IntentåŒ…è£…åœ¨æ–°çš„Intentä¸­ï¼Œç”¨è¿™ä¸ªç¡®è®¤æƒé™çš„æ–°Intentç»§ç»­åé¢çš„å¯åŠ¨å·¥ä½œ final IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingFeatureId, callingUid, userId, null, null, 0, new Intent[]&#123;intent&#125;, new String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); int flags = intent.getFlags(); flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS; /* * Prevent reuse of review activity: Each app needs their own review activity. By * default activities launched with NEW_TASK or NEW_DOCUMENT try to reuse activities * with the same launch parameters (extras are ignored). Hence to avoid possible * reuse force a new activity via the MULTIPLE_TASK flag. * * Activities that are not launched with NEW_TASK or NEW_DOCUMENT are not re-used, * hence no need to add the flag in this case. */ if ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != 0) &#123; flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK; &#125; newIntent.setFlags(flags); newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName); newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target)); if (resultRecord != null) &#123; newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true); &#125; intent = newIntent; // The permissions review target shouldn't get any permission // grants intended for the original destination intentGrants = null; resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, 0, computeResolveFilterUid( callingUid, realCallingUid, request.filterCallingUid)); aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); &#125; &#125; // If we have an ephemeral app, abort the process of launching the resolved intent. // Instead, launch the ephemeral installer. Once the installer is finished, it // starts either the intent we resolved here [on install error] or the ephemeral // app [on install success]. if (rInfo != null &amp;&amp; rInfo.auxiliaryInfo != null) &#123; ... //Instant Appç›¸å…³ &#125; //åˆ›å»ºå¯åŠ¨Activityçš„ActivityRecord final ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, callingFeatureId, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, request.componentSpecified, voiceSession != null, mSupervisor, checkedOptions, sourceRecord); mLastStartActivityRecord = r; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; // If the caller didn't specify an explicit time tracker, we want to continue // tracking under any it has. r.appTimeTracker = sourceRecord.appTimeTracker; &#125; //è·å–é¡¶å±‚ç„¦ç‚¹çš„Acticityæ ˆ final ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack(); // If we are starting an activity that is not from the same uid as the currently resumed // one, check whether app switches are allowed. //å½“æ­¤æ—¶æ ˆé¡¶Activity UID != è°ƒç”¨æ–¹ UIDçš„æ—¶å€™ï¼ˆæ¯”å¦‚æ‚¬æµ®çª—ï¼‰ if (voiceSession == null &amp;&amp; stack != null &amp;&amp; (stack.getResumedActivity() == null || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123; //æ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥åˆ‡æ¢åº”ç”¨ // 1. è®¾ç½®çš„ mAppSwitchesAllowedTime &lt; å½“å‰ç³»ç»Ÿæ—¶é—´ï¼ˆstopAppSwitchesï¼‰ // 2. è°ƒç”¨æ–¹åœ¨æœ€è¿‘ä»»åŠ¡ä¸­ // 3. è°ƒç”¨æ–¹å…·æœ‰ STOP_APP_SWITCHES æƒé™ // ... if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, \"Activity start\")) &#123; //åŠ å…¥åˆ°å»¶æ—¶å¯åŠ¨åˆ—è¡¨ä¸­ if (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123; mController.addPendingActivityLaunch(new PendingActivityLaunch(r, sourceRecord, startFlags, stack, callerApp, intentGrants)); &#125; ActivityOptions.abort(checkedOptions); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; //å›è°ƒå¤„ç†å»¶è¿Ÿåº”ç”¨åˆ‡æ¢ mService.onStartActivitySetDidAppSwitch(); mController.doPendingActivityLaunches(false); //æ ¸å¿ƒï¼šè¿›å…¥Activityå¯åŠ¨çš„ä¸‹ä¸€é˜¶æ®µ mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession, request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, restrictedBgActivity, intentGrants); if (request.outActivity != null) &#123; request.outActivity[0] = mLastStartActivityRecord; &#125; return mLastStartActivityResult;&#125; è¿™ä¸ªå‡½æ•°å¤§éƒ¨åˆ†éƒ½æ˜¯æ£€æŸ¥å·¥ä½œï¼Œè¿™äº›å¯ä»¥çœ‹æˆ‘æ ‡çš„æ³¨é‡Šï¼ŒåŸºæœ¬ä¸Šä»‹ç»çš„æ¯”è¾ƒè¯¦ç»†äº†ï¼Œç„¶åè¿›å…¥åˆ°Activityå¯åŠ¨çš„ä¸‹ä¸€æ­¥ï¼ŒstartActivityUnchecked 123456789101112131415161718192021222324252627282930/** * Start an activity while most of preliminary checks has been done and caller has been * confirmed that holds necessary permissions to do so. * Here also ensures that the starting activity is removed if the start wasn't successful. */private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; //æš‚åœå¸ƒå±€å·¥ä½œï¼Œé¿å…é‡å¤åˆ·æ–° mService.deferWindowLayout(); Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, \"startActivityInner\"); //æ¥ç€æŠŠå¯åŠ¨Activityå·¥ä½œäº¤ç»™è¿™ä¸ªæ–¹æ³• result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER); //è¿›è¡Œä¸€äº›æ›´æ–°Configurationï¼Œæ¸…ç†æ ˆç­‰æ”¶å°¾å·¥ä½œ startedActivityStack = handleStartResult(r, result); //æ¢å¤å¸ƒå±€å·¥ä½œ mService.continueWindowLayout(); &#125; postStartActivityProcessing(r, result, startedActivityStack); return result;&#125; è¿™ä¸ªæ–¹æ³•ä¹Ÿä¸æ˜¯ä¸»è¦é€»è¾‘æ‰€åœ¨ï¼Œæˆ‘ä»¬å¾€ä¸‹æ¥ç€çœ‹startActivityInneræ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * Start an activity and determine if the activity should be adding to the top of an existing * task or delivered new intent to an existing activity. Also manipulating the activity task * onto requested or valid stack/display. * * Note: This method should only be called from &#123;@link #startActivityUnchecked&#125;. */// TODO(b/152429287): Make it easier to exercise code paths through startActivityInner@VisibleForTestingint startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; //è®¾ç½®åˆå§‹åŒ–å‚æ•° setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor, restrictedBgActivity); //è®¡ç®—å¤„ç†Activityå¯åŠ¨æ¨¡å¼ computeLaunchingTaskFlags(); //è®¡ç®—è°ƒç”¨æ–¹Activityä»»åŠ¡æ ˆ computeSourceStack(); //å°†flagsè®¾ç½®ä¸ºè°ƒæ•´åçš„LaunchFlags mIntent.setFlags(mLaunchFlags); //æŸ¥æ‰¾æ˜¯å¦æœ‰å¯å¤ç”¨çš„Task final Task reusedTask = getReusableTask(); // If requested, freeze the task list if (mOptions != null &amp;&amp; mOptions.freezeRecentTasksReordering() &amp;&amp; mSupervisor.mRecentTasks.isCallerRecents(r.launchedFromUid) &amp;&amp; !mSupervisor.mRecentTasks.isFreezeTaskListReorderingSet()) &#123; mFrozeTaskList = true; mSupervisor.mRecentTasks.setFreezeTaskListReordering(); &#125; // Compute if there is an existing task that should be used for. //è®¡ç®—æ˜¯å¦å­˜åœ¨å¯ä½¿ç”¨çš„ç°æœ‰Task final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask(); final boolean newTask = targetTask == null; mTargetTask = targetTask; //è®¡ç®—å¯åŠ¨å‚æ•° computeLaunchParams(r, sourceRecord, targetTask); // Check if starting activity on given task or on a new task is allowed. //æ£€æŸ¥æ˜¯å¦å…è®¸åœ¨targetTaskä¸Šæˆ–è€…æ–°å»ºTaskå¯åŠ¨ int startResult = isAllowedToStart(r, newTask, targetTask); if (startResult != START_SUCCESS) &#123; return startResult; &#125; //è·å¾—æ ˆé¡¶æœªfinishçš„ActivityRecord final ActivityRecord targetTaskTop = newTask ? null : targetTask.getTopNonFinishingActivity(); if (targetTaskTop != null) &#123; // Recycle the target task for this launch. //å›æ”¶ï¼Œå‡†å¤‡å¤ç”¨è¿™ä¸ªTask startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; else &#123; mAddingToTask = true; &#125; // If the activity being launched is the same as the one currently at the top, then // we need to check if it should only be launched once. //å¤„ç†singleTopå¯åŠ¨æ¨¡å¼ final ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack(); if (topStack != null) &#123; startResult = deliverToCurrentTopIfNeeded(topStack, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; //å¤ç”¨æˆ–åˆ›å»ºActivityæ ˆ if (mTargetStack == null) &#123; mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions); &#125; if (newTask) &#123; //å¼€å¯æ–°Task final Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; //å¤ç”¨æˆ–æ–°å»ºä¸€ä¸ªTaskï¼Œå¹¶å»ºç«‹Taskä¸ActivityRecordä¹‹é—´çš„å…³è” setNewTask(taskToAffiliate); if (mService.getLockTaskController().isLockTaskModeViolation( mStartActivity.getTask())) &#123; Slog.e(TAG, \"Attempted Lock Task Mode violation mStartActivity=\" + mStartActivity); return START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; &#125; else if (mAddingToTask) &#123; //å¤ç”¨Task //å°†å¯åŠ¨Activityæ·»åŠ åˆ°targetTaskå®¹å™¨é¡¶éƒ¨æˆ–å°†å…¶çˆ¶å®¹å™¨æ›¿æ¢æˆtargetTaskï¼ˆä¹Ÿä¼šå°†å¯åŠ¨Activityæ·»åŠ åˆ°targetTaskå®¹å™¨é¡¶éƒ¨ï¼‰ addOrReparentStartingActivity(targetTask, \"adding to task\"); &#125; if (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123; mTargetStack.getStack().moveToFront(\"reuseOrNewTask\", targetTask); if (mOptions != null) &#123; if (mOptions.getTaskAlwaysOnTop()) &#123; mTargetStack.setAlwaysOnTop(true); &#125; &#125; if (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123; // Launching underneath dream activity (fullscreen, always-on-top). Run the launch- // -behind transition so the Activity gets created and starts in visible state. mLaunchTaskBehind = true; r.mLaunchTaskBehind = true; &#125; &#125; ... mTargetStack.mLastPausedActivity = null; mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded( false /* forceSend */, mStartActivity); //å°†Taskç§»åˆ°ActivityStackå®¹å™¨é¡¶éƒ¨ mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(), newTask, mKeepCurTransition, mOptions); if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); //å¯åŠ¨çš„Activityä¸å¯è·å¾—ç„¦ç‚¹ï¼Œæ— æ³•æ¢å¤å®ƒ if (!mTargetStack.isTopActivityFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.isTaskOverlay() &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can't resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don't want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. // Passing &#123;@code null&#125; as the start parameter ensures all activities are made // visible. mTargetStack.ensureActivitiesVisible(null /* starting */, 0 /* configChanges */, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isTopActivityFocusable() &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(\"startActivityInner\"); &#125; //é‡ç‚¹ï¼šæ¢å¤æ ˆé¡¶Activities mRootWindowContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions); &#125; &#125; mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack); // Update the recent tasks list immediately when the activity starts //å½“Activityå¯åŠ¨åç«‹åˆ»æ›´æ–°æœ€è¿‘ä»»åŠ¡åˆ—è¡¨ mSupervisor.mRecentTasks.add(mStartActivity.getTask()); mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack); return START_SUCCESS;&#125; è¿™é‡Œä¸»è¦åšäº†ä¸€äº›Taskå’Œæ ˆçš„æ“ä½œï¼Œæ˜¯å¦å¯ä»¥å¤ç”¨æ ˆï¼Œæ˜¯å¦éœ€è¦æ–°æ ˆï¼Œå¤„ç†æ ˆé¡¶å¤ç”¨ç­‰ç›¸å…³æ“ä½œã€‚æˆ‘ä»¬éœ€è¦æ³¨æ„ä¸€ä¸‹è¿™é‡Œå…³äºTaskçš„æ“ä½œï¼Œä¸ç®¡æ˜¯æ–°å»ºTaskï¼ˆnewTaskï¼‰è¿˜æ˜¯å¤ç”¨Taskï¼ˆmAddingToTaskï¼‰ï¼Œéƒ½ä¼šè°ƒç”¨åˆ°addOrReparentStartingActivityæ–¹æ³•å°†å¯åŠ¨ActivityRecordæ·»åŠ åˆ°targetTaskå®¹å™¨é¡¶éƒ¨ï¼ˆnewTaskçš„æƒ…å†µä¸‹ä¼šè°ƒç”¨setNewTaskæ–¹æ³•å…ˆå¤ç”¨æˆ–åˆ›å»ºTaskï¼Œç„¶åå†ç”¨è¿™ä¸ªTaskè°ƒç”¨addOrReparentStartingActivityæ–¹æ³•ï¼‰ï¼Œä¹‹åè°ƒç”¨mTargetStack.startActivityLockedæ–¹æ³•å°†Taskç§»åˆ°mTargetStackå®¹å™¨é¡¶éƒ¨ï¼Œæ­¤æ—¶è°ƒç”¨mTargetStack.topRunningActivityä¾¿ä¼šå¾—åˆ°æˆ‘ä»¬å°†è¦å¯åŠ¨çš„è¿™ä¸ªActivityRecord æœ€ååˆ¤æ–­ç›®æ ‡Activityæ˜¯å¦å¯è·å¾—ç„¦ç‚¹ï¼Œå½“å¯è·å¾—ç„¦ç‚¹çš„æ—¶å€™ï¼Œè°ƒç”¨RootWindowContainer.resumeFocusedStacksTopActivitiesæ–¹æ³•æ¢å¤Activity è¦æ³¨æ„ï¼Œä»è¿™ä¸ªæ–¹æ³•å¼€å§‹çš„ä»¥åçš„æ–¹æ³•ä¸å†åªæ˜¯é’ˆå¯¹Activityå¯åŠ¨çš„æ–¹æ³•ï¼Œå®ƒä»¬æœ‰å¯èƒ½è¢«å¤šæ–¹è°ƒç”¨ï¼Œæ‰€ä»¥å…¶ä¸­çš„ä¸€äº›æ­¥éª¤caseæˆ‘ä»¬æ˜¯ä¸ä¼šç»å†çš„ï¼Œå¯ä»¥å¿½ç•¥æ‰è¿™éƒ¨åˆ† RootWindowContainerRootWindowContaineræ˜¯æ˜¾ç¤ºçª—å£çš„æ ¹çª—å£å®¹å™¨ï¼Œå®ƒä¸»è¦æ˜¯ç”¨æ¥ç®¡ç†æ˜¾ç¤ºå±å¹•çš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061boolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (!mStackSupervisor.readyToResume()) &#123; return false; &#125; boolean result = false; //ç›®æ ‡æ ˆåœ¨æ ˆé¡¶æ˜¾ç¤ºåŒºåŸŸ if (targetStack != null &amp;&amp; (targetStack.isTopStackInDisplayArea() || getTopDisplayFocusedStack() == targetStack)) &#123; //ä½¿ç”¨ç›®æ ‡æ ˆè¿›è¡Œæ¢å¤ result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; //å¯èƒ½å­˜åœ¨å¤šæ˜¾ç¤ºè®¾å¤‡ï¼ˆæŠ•å±ç­‰ï¼‰ for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) &#123; boolean resumedOnDisplay = false; final DisplayContent display = getChildAt(displayNdx); for (int tdaNdx = display.getTaskDisplayAreaCount() - 1; tdaNdx &gt;= 0; --tdaNdx) &#123; final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx); for (int sNdx = taskDisplayArea.getStackCount() - 1; sNdx &gt;= 0; --sNdx) &#123; final ActivityStack stack = taskDisplayArea.getStackAt(sNdx); final ActivityRecord topRunningActivity = stack.topRunningActivity(); if (!stack.isFocusableAndVisible() || topRunningActivity == null) &#123; continue; &#125; if (stack == targetStack) &#123; //å¦‚æœè¿›å…¥åˆ°è¿™é‡Œï¼Œä»£è¡¨ç€targetStackåœ¨ä¸Šé¢å·²ç»æ¢å¤è¿‡äº†ï¼Œæ­¤æ—¶åªéœ€è¦è®°å½•ç»“æœå³å¯ resumedOnDisplay |= result; continue; &#125; if (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123; //æ‰§è¡Œåˆ‡æ¢æ•ˆæœ stack.executeAppTransition(targetOptions); &#125; else &#123; //ä½¿é¡¶éƒ¨æ˜¾ç¤ºçš„Activityæ‰§è¡ŒResumeã€Pauseæˆ–Startç”Ÿå‘½å‘¨æœŸ resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target); &#125; &#125; &#125; if (!resumedOnDisplay) &#123; // In cases when there are no valid activities (e.g. device just booted or launcher // crashed) it's possible that nothing was resumed on a display. Requesting resume // of top activity in focused stack explicitly will make sure that at least home // activity is started and resumed, and no recursion occurs. //å½“æ²¡æœ‰ä»»ä½•æœ‰æ•ˆçš„Activityçš„æ—¶å€™ï¼ˆè®¾å¤‡åˆšå¯åŠ¨æˆ–Launcherå´©æºƒï¼‰ï¼Œå¯èƒ½æ²¡æœ‰ä»»ä½•ä¸œè¥¿å¯è¢«æ¢å¤ //è¿™æ—¶å€™ä½¿ç”¨DisplayContentä¸­çš„ç„¦ç‚¹æ ˆè¿›è¡Œæ¢å¤ //å¦‚æœè¿å­˜åœ¨ç„¦ç‚¹çš„æ ˆéƒ½æ²¡æœ‰ï¼Œåˆ™æ¢å¤Launcherçš„Activity final ActivityStack focusedStack = display.getFocusedStack(); if (focusedStack != null) &#123; result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; else if (targetStack == null) &#123; result |= resumeHomeActivity(null /* prev */, \"no-focusable-task\", display.getDefaultTaskDisplayArea()); &#125; &#125; &#125; return result;&#125; è¿™ä¸ªæ–¹æ³•ä¸»è¦åšäº†å‡ ä»¶äº‹ï¼š å¦‚æœç›®æ ‡æ ˆåœ¨æ ˆé¡¶æ˜¾ç¤ºåŒºåŸŸï¼Œæ‰§è¡ŒResume éå†æ˜¾ç¤ºè®¾å¤‡ï¼Œä»ä¸­éå†æ‰€æœ‰æœ‰ç„¦ç‚¹å¹¶ä¸”å¯è§çš„æ ˆï¼Œå¯¹å…¶æ ˆé¡¶Activityæ‰§è¡Œç›¸åº”çš„åˆ‡æ¢æ•ˆæœåŠç”Ÿå‘½å‘¨æœŸ å¯¹æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡ï¼Œå¦‚æœå­˜åœ¨ç„¦ç‚¹æ ˆï¼Œåˆ™ä½¿ç”¨å…¶æ‰§è¡ŒResumeï¼Œå¦åˆ™å¯åŠ¨Launcher åœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¼šèµ°è¿›ActivityStack.resumeTopActivityUncheckedLockedè¿™ä¸ªæ–¹æ³• ActivityStackActivityæ ˆï¼Œç”¨äºç®¡ç†æ ˆä¸­çš„Activity 1234567891011121314151617181920212223242526272829303132boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don't even start recursing. //é˜²æ­¢é€’å½’ return false; &#125; boolean result = false; try &#123; // Protect against recursion. //é˜²æ­¢é€’å½’ mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // When resuming the top activity, it may be necessary to pause the top activity (for // example, returning to the lock screen. We suppress the normal pause logic in // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here // to ensure any necessary pause logic occurs. In the case where the Activity will be // shown regardless of the lock screen, the call to // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped. final ActivityRecord next = topRunningActivity(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) &#123; //å‡†å¤‡ä¼‘çœ  checkReadyForSleep(); &#125; &#125; finally &#123; mInResumeTopActivity = false; &#125; return result;&#125; è¿™é‡Œåšäº†ä¸€ä¸ªé˜²æ­¢é€’å½’è°ƒç”¨çš„æªæ–½ï¼Œæ¥ä¸‹æ¥è°ƒç”¨äº†resumeTopActivityInnerLockedæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; if (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123; // Not ready yet! //ATMSæœåŠ¡å°šæœªå‡†å¤‡å¥½ return false; &#125; // Find the next top-most activity to resume in this stack that is not finishing and is // focusable. If it is not focusable, we will fall into the case below to resume the // top activity in the next focusable task. //åœ¨ä¹‹å‰æˆ‘ä»¬å·²ç»æŠŠè¦å¯åŠ¨çš„ActivityRecordåŠ åˆ°äº†æ ˆé¡¶ ActivityRecord next = topRunningActivity(true /* focusableOnly */); final boolean hasRunningActivity = next != null; ... if (!hasRunningActivity) &#123; // There are no activities left in the stack, let's look somewhere else. return resumeNextFocusableActivityWhenStackIsEmpty(prev, options); &#125; next.delayedResume = false; final TaskDisplayArea taskDisplayArea = getDisplayArea(); // If the top activity is the resumed one, nothing to do. //å¦‚æœéœ€è¦Resumeçš„å·²åœ¨é¡¶éƒ¨ä¸”çŠ¶æ€ä¸ºResumeï¼Œä¸éœ€è¦åšä»»ä½•äº‹ //å¯åŠ¨Activityä¸ä¼šç¢°åˆ°è¿™ç§case if (mResumedActivity == next &amp;&amp; next.isState(RESUMED) &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123; ... return false; &#125; if (!next.canResumeByCompat()) &#123; return false; &#125; // If we are currently pausing an activity, then don't do anything until that is done. //å¦‚æœæœ‰æ­£åœ¨Pauseçš„Activityï¼Œåœ¨å®ƒPauseå®Œæˆå‰ä¸è¦åšä»»ä½•äº‹ final boolean allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete(); if (!allPausedComplete) &#123; return false; &#125; ... // Make sure that the user who owns this activity is started. If not, // we will just leave it as is because someone should be bringing // another user's activities to the top of the stack. //ç¡®ä¿æ‹¥æœ‰æ­¤Activityçš„ç”¨æˆ·å·²å¯åŠ¨ if (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) &#123; return false; &#125; // The activity may be waiting for stop, but that is no longer // appropriate for it. mStackSupervisor.mStoppingActivities.remove(next); next.setSleeping(false); //è¿™é‡Œä¼¼ä¹é‡å¤æ£€æŸ¥äº†ï¼Œæˆ‘å»æŸ¥çœ‹äº†ä¸€ä¸‹masteråˆ†æ”¯çš„ä»£ç ï¼Œå·²ç»æ²¡æœ‰è¿™ä¸€æ®µäº† if (!mRootWindowContainer.allPausedActivitiesComplete()) &#123; return false; &#125; //è®¾ç½®å¯åŠ¨Activity UIDï¼Œè·å–WakeLockï¼Œä¿è¯åœ¨æ˜¾ç¤ºActivityçš„è¿‡ç¨‹ä¸­ï¼Œç³»ç»Ÿä¸ä¼šè¿›è¡Œä¼‘çœ çŠ¶æ€ mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid); ActivityRecord lastResumed = null; //ä¸Šä¸€ä¸ªå…·æœ‰ç„¦ç‚¹çš„ActivityStackï¼ˆç›®å‰ä»æ˜¯å±å¹•ä¸Šæ­£åœ¨æ˜¾ç¤ºçš„é‚£ä¸ªActivityçš„æ ˆï¼‰ final ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack(); if (lastFocusedStack != null &amp;&amp; lastFocusedStack != this) &#123; lastResumed = lastFocusedStack.mResumedActivity; ... &#125; //Pauseæ‰å…¶ä»–ActivityStackä¸­çš„æ ˆé¡¶çŠ¶æ€ä¸ºResumeçš„Activity boolean pausing = taskDisplayArea.pauseBackStacks(userLeaving, next); //Pauseæ‰å½“å‰ActivityStackä¸­çš„æ ˆé¡¶çŠ¶æ€ä¸ºResumeçš„Activity if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false /* uiSleeping */, next); &#125; if (pausing) &#123; //æœ‰Activityæ‰§è¡Œäº†Pause // At this point we want to put the upcoming activity's process // at the top of the LRU list, since we know we will be needing it // very soon and it would be a waste to let it get killed if it // happens to be sitting towards the end. if (next.attachedToProcess()) &#123; //å°†å¯åŠ¨çš„Activityè¿›ç¨‹ä¿¡æ¯ç§»è‡³lruåˆ—è¡¨çš„å¤´éƒ¨ //å› ä¸ºå¾ˆå¿«å°±ä¼šä½¿ç”¨å®ƒå¯åŠ¨Activity next.app.updateProcessInfo(false /* updateServiceConnectionActivities */, true /* activityChange */, false /* updateOomAdj */, false /* addPendingTopUid */); &#125; else if (!next.isProcessRunning()) &#123; //Appè¿›ç¨‹æœªå¯åŠ¨ // Since the start-process is asynchronous, if we already know the process of next // activity isn't running, we can start the process earlier to save the time to wait // for the current activity to be paused. final boolean isTop = this == taskDisplayArea.getFocusedStack(); //å¯åŠ¨Appè¿›ç¨‹ mAtmService.startProcessAsync(next, false /* knownToBeDead */, isTop, isTop ? \"pre-top-activity\" : \"pre-activity\"); &#125; ... //è¿™é‡Œä¼šå…ˆç»“æŸæ‰å¯åŠ¨Activityçš„æµç¨‹ï¼Œç­‰å¾…onPauseç”Ÿå‘½å‘¨æœŸèµ°å®Œå //å†é‡æ–°è°ƒç”¨è¿™ä¸ªæ–¹æ³•æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œï¼Œé¿å…Activityç”Ÿå‘½å‘¨æœŸç´Šä¹± return true; &#125; else if (mResumedActivity == next &amp;&amp; next.isState(RESUMED) &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123; // It is possible for the activity to be resumed when we paused back stacks above if the // next activity doesn't have to wait for pause to complete. // So, nothing else to-do except: // Make sure we have executed any pending transitions, since there // should be nothing left to do at this point. //ä¸éœ€è¦ç­‰å¾…å…¶ä»–çš„Activity onPauseå®Œæˆ //æ‰§è¡Œå®Œåˆ‡æ¢æ•ˆæœåå°±æ²¡æœ‰ä»€ä¹ˆå…¶ä»–éœ€è¦åšçš„äº† executeAppTransition(options); return true; &#125; ... //å¯åŠ¨Activityæµç¨‹ä¸ä¼šè¿›å…¥è¿™ä¸ªcase if (prev != null &amp;&amp; prev != next &amp;&amp; next.nowVisible) &#123; if (prev.finishing) &#123; prev.setVisibility(false); &#125; &#125; //ä¿®æ”¹å¯åŠ¨Activityçš„packageçš„çŠ¶æ€ mAtmService.getPackageManager().setPackageStoppedState( next.packageName, false, next.mUserId); ... //Activityè½¬åœºåŠ¨ç”»å‡†å¤‡ if (next.attachedToProcess()) &#123; //å¯¹äºå°†è¦å¯åŠ¨çš„ActivityRecordæ¥è¯´ï¼Œæ­¤æ—¶å°šæœªå®Œæˆå’ŒProcessçš„ç»‘å®šï¼Œè¿”å›false ... ActivityRecord lastResumedActivity = lastFocusedStack == null ? null : lastFocusedStack.mResumedActivity; //ä¿å­˜çŠ¶æ€ä»¥åšåé¢æ¢å¤ä½¿ç”¨ final ActivityState lastState = next.getState(); mAtmService.updateCpuStats(); //æ›´æ–°ActivityRecordçŠ¶æ€ next.setState(RESUMED, \"resumeTopActivityInnerLocked\"); //æ›´æ–°å¯åŠ¨Activityçš„è¿›ç¨‹ä¿¡æ¯å¹¶å°†å…¶ç§»è‡³lruåˆ—è¡¨çš„å¤´éƒ¨ next.app.updateProcessInfo(false /* updateServiceConnectionActivities */, true /* activityChange */, true /* updateOomAdj */, true /* addPendingTopUid */); ... //æ›´æ–°Activityæ˜¾ç¤ºã€æ–¹å‘å’ŒConfiguration try &#123; final ClientTransaction transaction = ClientTransaction.obtain(next.app.getThread(), next.appToken); // Deliver all pending results. ArrayList&lt;ResultInfo&gt; a = next.results; if (a != null) &#123; final int N = a.size(); if (!next.finishing &amp;&amp; N &gt; 0) &#123; if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, \"Delivering results to \" + next + \": \" + a); transaction.addCallback(ActivityResultItem.obtain(a)); &#125; &#125; if (next.newIntents != null) &#123; transaction.addCallback( NewIntentItem.obtain(next.newIntents, true /* resume */)); &#125; // Well the app will no longer be stopped. // Clear app token stopped state in window manager if needed. next.notifyAppResumed(next.stopped); EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next), next.getTask().mTaskId, next.shortComponentName); next.setSleeping(false); mAtmService.getAppWarningsLocked().onResumeActivity(next); next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState); next.clearOptionsLocked(); //è®¾ç½®onResumeç”Ÿå‘½å‘¨æœŸè¯·æ±‚ transaction.setLifecycleStateRequest( ResumeActivityItem.obtain(next.app.getReportedProcState(), dc.isNextTransitionForward())); //è°ƒåº¦æ‰§è¡ŒActivity onResumeç”Ÿå‘½å‘¨æœŸ mAtmService.getLifecycleManager().scheduleTransaction(transaction); if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Resumed \" + next); &#125; catch (Exception e) &#123; //resumeå¤±è´¥éœ€è¦å°è¯•restart //æ¢å¤åˆå§‹çŠ¶æ€ next.setState(lastState, \"resumeTopActivityInnerLocked\"); if (lastResumedActivity != null) &#123; lastResumedActivity.setState(RESUMED, \"resumeTopActivityInnerLocked\"); &#125; ... //é‡æ–°å¯åŠ¨Activity mStackSupervisor.startSpecificActivity(next, true, false); return true; &#125; // From this point on, if something goes wrong there is no way // to recover the activity. try &#123; //æ›´æ–°ä¿¡æ¯ next.completeResumeLocked(); &#125; catch (Exception e) &#123; // If any exception gets thrown, toss away this // activity and try the next one. Slog.w(TAG, \"Exception thrown during resume of \" + next, e); next.finishIfPossible(\"resume-exception\", true /* oomAdj */); return true; &#125; &#125; else &#123; //å°šæœªç»‘å®šProcess // Whoops, need to restart this activity! if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; next.showStartingWindow(null /* prev */, false /* newTask */, false /* taskSwich */); &#125; &#125; //å¯åŠ¨Activity mStackSupervisor.startSpecificActivity(next, true, true); &#125; return true;&#125; è¿™é‡Œçš„ä»£ç å¾ˆé•¿ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦å…³æ³¨ä¸‰ä¸ªç‚¹ï¼š Pauseæ‰å…¶ä»–Activity å¦‚æœå¯¹åº”Appå°šæœªå¯åŠ¨ï¼Œå¯åŠ¨Appè¿›ç¨‹ å¯åŠ¨Activity ç¬¬ä¸€æ­¥ï¼Œåœ¨å¯åŠ¨Activityå‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆPauseæ‰å…¶ä»–Activityï¼Œè¿™ä¸€ç‚¹å¾ˆå¥½ç†è§£ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹ç…§ç€çœ‹Activityç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯è¿™æ ·çš„ï¼Œè¿™é‡Œä¼šé€šè¿‡ATMSè·¨è¿›ç¨‹è°ƒç”¨ç›¸åº”Activityçš„onPauseç”Ÿå‘½å‘¨æœŸï¼Œç­‰å¾…onPauseæ‰§è¡Œå®Œæˆåï¼Œå†è·¨è¿›ç¨‹è°ƒç”¨å›ATMSï¼Œç»è¿‡ä¸€ç³»åˆ—æ–¹æ³•è°ƒç”¨ï¼Œåˆé‡æ–°è°ƒç”¨resumeTopActivityInnerLockedæ–¹æ³•ï¼Œç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥æ“ä½œ ç¬¬äºŒæ­¥ï¼Œå¦‚æœAppå°šæœªå¯åŠ¨ï¼Œåˆ™å…ˆå»å¯åŠ¨Appè¿›ç¨‹ï¼Œè¿™ä¸»è¦ä½“ç°åœ¨è¿™é‡Œ 12345if (!next.isProcessRunning()) &#123; //Appè¿›ç¨‹æœªå¯åŠ¨ //å¯åŠ¨Appè¿›ç¨‹ mAtmService.startProcessAsync(next, false /* knownToBeDead */, isTop, isTop ? \"pre-top-activity\" : \"pre-activity\");&#125; åœ¨å¯åŠ¨å®ŒAppè¿›ç¨‹åï¼Œä¼šè°ƒç”¨ATMSçš„attachApplicationæ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨åˆ°ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•å¯åŠ¨Activityï¼Œè¿™ä¸ªæ–¹æ³•åé¢ä¼šè®² ç¬¬ä¸‰æ­¥ï¼Œå¦‚æœAppè¿›ç¨‹å·²ç»å¯åŠ¨ï¼Œè¿™æ—¶å€™ä¼šè°ƒç”¨ActivityStackSupervisor.startSpecificActivityæ–¹æ³•ï¼Œæœ€ç»ˆæ®Šé€”åŒå½’è°ƒç”¨ActivityStackSupervisor.realStartActivityLockedæ–¹æ³•å¯åŠ¨Activity ç»“æŸè¿™é‡Œç¯‡å¹…æœ‰ç‚¹è¿‡é•¿äº†ï¼Œæ‰€ä»¥æˆ‘è§‰å¾—è¿˜æ˜¯åˆ†ç¯‡æ¯”è¾ƒå¥½ï¼Œè¿™ä¸€ç« å…¶å®é‡è¦å†…å®¹ä¸æ˜¯å¾ˆå¤šï¼Œæœ€ä¸»è¦çš„å†…å®¹ï¼ŒåƒActivityçš„ç”Ÿå‘½å‘¨æœŸæ§åˆ¶ï¼ŒAppè¿›ç¨‹çš„å¯åŠ¨ï¼ŒActivityå…·ä½“çš„å¯åŠ¨åŠå…¶åç»­ç”Ÿå‘½å‘¨æœŸæ‰§è¡Œéƒ½ä¼šæ”¾åœ¨ä¸‹ä¸€ç« æ¥è®²","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"}]},{"title":"Androidæºç åˆ†æ - Frameworkå±‚çš„Binderï¼ˆæœåŠ¡ç«¯ç¯‡ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„Binderï¼ˆæœåŠ¡ç«¯ç¯‡ï¼‰","date":"2022-07-05T10:48:28.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/07/05/android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„Binderï¼ˆæœåŠ¡ç«¯ç¯‡ï¼‰/","link":"","permalink":"http://yoursite.com/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥aospåˆ†æ”¯android-11.0.0_r25ï¼Œkernelåˆ†æ”¯android-msm-wahoo-4.4-android11ä½œä¸ºåŸºç¡€è§£æ æˆ‘ä»¬åœ¨ä¸Šä¸€ç‰‡æ–‡ç« Androidæºç åˆ†æ - Frameworkå±‚çš„Binderï¼ˆå®¢æˆ·ç«¯ç¯‡ï¼‰ä¸­ï¼Œåˆ†æäº†å®¢æˆ·ç«¯æ˜¯æ€ä¹ˆå‘æœåŠ¡ç«¯é€šè¿‡binderé©±åŠ¨å‘èµ·è¯·æ±‚ï¼Œç„¶åå†æ¥æ”¶æœåŠ¡ç«¯çš„è¿”å›çš„ã€‚æœ¬ç¯‡æ–‡ç« ï¼Œæˆ‘ä»¬å°†ä¼šä»¥æœåŠ¡ç«¯çš„è§†è§’ï¼Œåˆ†ææœåŠ¡ç«¯æ˜¯æ€ä¹ˆé€šè¿‡binderé©±åŠ¨æ¥æ”¶å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå¤„ç†ï¼Œç„¶åå†è¿”å›ç»™å®¢æˆ·ç«¯çš„ã€‚ ServiceManagerä¸Šç¯‡æ–‡ç« æˆ‘ä»¬æ˜¯ä»¥ServiceManagerä½œä¸ºæœåŠ¡ç«¯åˆ†æçš„ï¼Œæœ¬ç¯‡æ–‡ç« æˆ‘ä»¬è¿˜æ˜¯å›´ç»•ç€å®ƒæ¥åšåˆ†æï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„æœåŠ¡ç«¯ï¼Œæˆ‘ä»¬æ­£å¥½å¯ä»¥é¡ºä¾¿åˆ†æä¸€ä¸‹å®ƒæ˜¯æ€ä¹ˆæˆä¸ºbinderé©±åŠ¨çš„context_managerçš„ è¿›ç¨‹å¯åŠ¨ServiceManageræ˜¯åœ¨ç‹¬ç«‹çš„è¿›ç¨‹ä¸­è¿è¡Œçš„ï¼Œå®ƒæ˜¯ç”±initè¿›ç¨‹ä»rcæ–‡ä»¶ä¸­è§£æå¹¶å¯åŠ¨çš„ï¼Œè·¯å¾„ä¸ºframeworks/native/cmds/servicemanager/servicemanager.rc 123456789101112131415161718service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager class core animation user system group system readproc critical onrestart restart healthd onrestart restart zygote onrestart restart audioserver onrestart restart media onrestart restart surfaceflinger onrestart restart inputflinger onrestart restart drm onrestart restart cameraserver onrestart restart keystore onrestart restart gatekeeperd onrestart restart thermalservice writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks shutdown critical è¿™ä¸ªæœåŠ¡çš„å…¥å£å‡½æ•°ä½äºframeworks/native/cmds/servicemanager/main.cppçš„mainå‡½æ•°ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839int main(int argc, char** argv) &#123; //æ ¹æ®ä¸Šé¢çš„rcæ–‡ä»¶ï¼Œargc == 1, argv[0] == \"/system/bin/servicemanager\" if (argc &gt; 2) &#123; LOG(FATAL) &lt;&lt; \"usage: \" &lt;&lt; argv[0] &lt;&lt; \" [binder driver]\"; &#125; //æ­¤æ—¶ï¼Œè¦ä½¿ç”¨çš„binderé©±åŠ¨ä¸º/dev/binder const char* driver = argc == 2 ? argv[1] : \"/dev/binder\"; //åˆå§‹åŒ–binderé©±åŠ¨ sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver); ps-&gt;setThreadPoolMaxThreadCount(0); ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); //å®ä¾‹åŒ–ServiceManager sp&lt;ServiceManager&gt; manager = new ServiceManager(std::make_unique&lt;Access&gt;()); //å°†è‡ªèº«ä½œä¸ºæœåŠ¡æ·»åŠ  if (!manager-&gt;addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123; LOG(ERROR) &lt;&lt; \"Could not self register servicemanager\"; &#125; //è®¾ç½®æœåŠ¡ç«¯Bbinderå¯¹è±¡ IPCThreadState::self()-&gt;setTheContextObject(manager); //è®¾ç½®æˆä¸ºbinderé©±åŠ¨çš„context manager ps-&gt;becomeContextManager(nullptr, nullptr); //é€šè¿‡Looper epollæœºåˆ¶å¤„ç†binderäº‹åŠ¡ sp&lt;Looper&gt; looper = Looper::prepare(false /*allowNonCallbacks*/); BinderCallback::setupTo(looper); ClientCallbackCallback::setupTo(looper, manager); while(true) &#123; looper-&gt;pollAll(-1); &#125; //æ­£å¸¸èµ°ä¸åˆ°è¿™é‡Œ return EXIT_FAILURE;&#125; åˆå§‹åŒ–Binderé¦–å…ˆè¯»å–å‚æ•°ï¼ŒæŒ‰ç…§ä¹‹å‰çš„rcæ–‡ä»¶æ¥çœ‹ï¼Œè¿™é‡Œçš„driverä¸º/dev/binderï¼Œç„¶åæ ¹æ®æ­¤driveråˆå§‹åŒ–æ­¤è¿›ç¨‹çš„ProcessStateå•ä¾‹ï¼Œæ ¹æ®æˆ‘ä»¬ä¸Šä¸€ç« çš„åˆ†ææˆ‘ä»¬çŸ¥é“æ­¤æ—¶ä¼šæ‰§è¡Œbinder_openå’Œbinder_mmapï¼Œæ¥ç€å¯¹è¿™ä¸ªå•ä¾‹åšä¸€äº›é…ç½® 123456789101112131415161718192021222324sp&lt;ProcessState&gt; ProcessState::initWithDriver(const char* driver)&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != nullptr) &#123; // Allow for initWithDriver to be called repeatedly with the same // driver. //å¦‚æœå·²ç»è¢«åˆå§‹åŒ–è¿‡äº†ï¼Œå¹¶ä¸”ä¼ å…¥çš„driverå‚æ•°å’Œå·²åˆå§‹åŒ–çš„é©±åŠ¨åä¸€æ ·ï¼Œç›´æ¥è¿”å›ä¹‹å‰åˆå§‹åŒ–çš„å•ä¾‹ if (!strcmp(gProcess-&gt;getDriverName().c_str(), driver)) &#123; return gProcess; &#125; //å¦åˆ™å¼‚å¸¸é€€å‡º LOG_ALWAYS_FATAL(\"ProcessState was already initialized.\"); &#125; //åˆ¤æ–­æŒ‡å®šçš„driveræ˜¯å¦å­˜åœ¨å¹¶å¯è¯» if (access(driver, R_OK) == -1) &#123; ALOGE(\"Binder driver %s is unavailable. Using /dev/binder instead.\", driver); //å›æ»šé»˜è®¤binderé©±åŠ¨ driver = \"/dev/binder\"; &#125; gProcess = new ProcessState(driver); return gProcess;&#125; accessæ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/access.2.html åŸå‹ï¼šint access(const char *pathname, int mode); è¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ£€æŸ¥è°ƒç”¨è¿›ç¨‹æ˜¯å¦å¯ä»¥å¯¹æŒ‡å®šæ–‡ä»¶æ‰§è¡ŒæŸç§æ“ä½œçš„ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1å¹¶è®¾ç½®error modeå‚æ•°å¯ä»¥ä¸ºä»¥ä¸‹å‡ ä¸ªå€¼ï¼š F_OKï¼šæ–‡ä»¶å­˜åœ¨ R_OKï¼šæ–‡ä»¶å¯è¯» W_OKï¼šæ–‡ä»¶å¯å†™ X_OKï¼šæ–‡ä»¶å¯æ‰§è¡Œ æ³¨å†Œæˆä¸ºBinderé©±åŠ¨çš„context manageræ¥ç€è°ƒç”¨äº†ProcessStateçš„becomeContextManagerå‡½æ•°æ³¨å†Œæˆä¸ºBinderé©±åŠ¨çš„context manager 123456789101112131415161718192021222324bool ProcessState::becomeContextManager()&#123; AutoMutex _l(mLock); flat_binder_object obj &#123; .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX, &#125;; int result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj); // fallback to original method if (result != 0) &#123; android_errorWriteLog(0x534e4554, \"121035042\"); int unused = 0; result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused); &#125; if (result == -1) &#123; ALOGE(\"Binder ioctl to become context manager failed: %s\\n\", strerror(errno)); &#125; return result == 0;&#125; è¿™é‡Œé€šè¿‡binder_ioctlï¼Œä»¥BINDER_SET_CONTEXT_MGR_EXTä¸ºå‘½ä»¤ç è¯·æ±‚binderé©±åŠ¨ 123456789101112131415161718static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; ... switch (cmd) &#123; ... case BINDER_SET_CONTEXT_MGR_EXT: &#123; struct flat_binder_object fbo; if (copy_from_user(&amp;fbo, ubuf, sizeof(fbo))) &#123; ret = -EINVAL; goto err; &#125; ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo); if (ret) goto err; break; &#125; ... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int binder_ioctl_set_ctx_mgr(struct file *filp, struct flat_binder_object *fbo)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; struct binder_context *context = proc-&gt;context; struct binder_node *new_node; kuid_t curr_euid = current_euid(); mutex_lock(&amp;context-&gt;context_mgr_node_lock); //binderçš„context manageråªèƒ½è®¾ç½®ä¸€æ¬¡ if (context-&gt;binder_context_mgr_node) &#123; pr_err(\"BINDER_SET_CONTEXT_MGR already set\\n\"); ret = -EBUSY; goto out; &#125; //åˆ¤æ–­è°ƒç”¨è¿›ç¨‹æ˜¯å¦æœ‰æƒé™è®¾ç½®context manager ret = security_binder_set_context_mgr(proc-&gt;tsk); if (ret &lt; 0) goto out; //context-&gt;binder_context_mgr_uid != -1 if (uid_valid(context-&gt;binder_context_mgr_uid)) &#123; if (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123; pr_err(\"BINDER_SET_CONTEXT_MGR bad uid %d != %d\\n\", from_kuid(&amp;init_user_ns, curr_euid), from_kuid(&amp;init_user_ns, context-&gt;binder_context_mgr_uid)); ret = -EPERM; goto out; &#125; &#125; else &#123; //è®¾ç½®Binderé©±åŠ¨context manageræ‰€åœ¨è¿›ç¨‹çš„ç”¨æˆ·ID context-&gt;binder_context_mgr_uid = curr_euid; &#125; //æ–°å»ºbinderèŠ‚ç‚¹ new_node = binder_new_node(proc, fbo); if (!new_node) &#123; ret = -ENOMEM; goto out; &#125; binder_node_lock(new_node); new_node-&gt;local_weak_refs++; new_node-&gt;local_strong_refs++; new_node-&gt;has_strong_ref = 1; new_node-&gt;has_weak_ref = 1; //è®¾ç½®binderé©±åŠ¨context managerèŠ‚ç‚¹ context-&gt;binder_context_mgr_node = new_node; binder_node_unlock(new_node); binder_put_node(new_node);out: mutex_unlock(&amp;context-&gt;context_mgr_node_lock); return ret;&#125; è¿™é‡Œçš„è¿‡ç¨‹ä¹Ÿå¾ˆç®€å•ï¼Œé¦–å…ˆæ£€æŸ¥ä¹‹å‰æ˜¯å¦è®¾ç½®è¿‡context managerï¼Œç„¶ååšæƒé™æ ¡éªŒï¼Œé€šè¿‡åé€šè¿‡binder_new_nodeåˆ›å»ºå‡ºä¸€ä¸ªæ–°çš„binderèŠ‚ç‚¹ï¼Œå¹¶å°†å®ƒä½œä¸ºcontext managerèŠ‚ç‚¹ Looperå¾ªç¯å¤„ç†Binderäº‹åŠ¡è¿™é‡Œçš„Looperå’Œæˆ‘ä»¬å¹³å¸¸åº”ç”¨å¼€å‘æ‰€è¯´çš„Looperæ˜¯ä¸€ä¸ªä¸œè¥¿ï¼Œæœ¬ç¯‡å°±ä¸åšè¿‡å¤šè¯¦è§£äº†ï¼Œåªéœ€è¦çŸ¥é“ï¼Œå¯ä»¥é€šè¿‡Looper::addFdå‡½æ•°ç›‘å¬æ–‡ä»¶æè¿°ç¬¦ï¼Œé€šè¿‡Looper::pollAllæˆ–Looper::pollOnceå‡½æ•°æ¥æ”¶æ¶ˆæ¯ï¼Œæ¶ˆæ¯æŠµè¾¾åä¼šå›è°ƒLooperCallback::handleEventå‡½æ•° äº†è§£äº†è¿™äº›åæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹BinderCallbackè¿™ä¸ªç±» 12345678910111213141516171819202122232425262728293031class BinderCallback : public LooperCallback &#123;public: static sp&lt;BinderCallback&gt; setupTo(const sp&lt;Looper&gt;&amp; looper) &#123; sp&lt;BinderCallback&gt; cb = new BinderCallback; int binder_fd = -1; //å‘binderé©±åŠ¨å‘é€BC_ENTER_LOOPERäº‹åŠ¡è¯·æ±‚ï¼Œå¹¶è·å¾—binderè®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦ IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); LOG_ALWAYS_FATAL_IF(binder_fd &lt; 0, \"Failed to setupPolling: %d\", binder_fd); // Flush after setupPolling(), to make sure the binder driver // knows about this thread handling commands. IPCThreadState::self()-&gt;flushCommands(); //ç›‘å¬binderæ–‡ä»¶æè¿°ç¬¦ int ret = looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb, nullptr /*data*/); LOG_ALWAYS_FATAL_IF(ret != 1, \"Failed to add binder FD to Looper\"); return cb; &#125; int handleEvent(int /* fd */, int /* events */, void* /* data */) override &#123; //ä»binderé©±åŠ¨æ¥æ”¶åˆ°æ¶ˆæ¯å¹¶å¤„ç† IPCThreadState::self()-&gt;handlePolledCommands(); return 1; // Continue receiving callbacks. &#125;&#125;; åœ¨servicemanagerè¿›ç¨‹å¯åŠ¨çš„è¿‡ç¨‹ä¸­è°ƒç”¨äº†BinderCallback::setupToå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°é¦–å…ˆæƒ³binderé©±åŠ¨å‘èµ·äº†ä¸€ä¸ªBC_ENTER_LOOPERäº‹åŠ¡è¯·æ±‚ï¼Œè·å¾—binderè®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶åè°ƒç”¨Looper::addFdå‡½æ•°ç›‘å¬binderè®¾å¤‡æ–‡ä»¶æè¿°ç¬¦ï¼Œè¿™æ ·å½“binderé©±åŠ¨å‘æ¥æ¶ˆæ¯åï¼Œå°±å¯ä»¥é€šè¿‡Looper::handleEventå‡½æ•°æ¥æ”¶å¹¶å¤„ç†äº† 1234567891011121314151617status_t IPCThreadState::setupPolling(int* fd)&#123; if (mProcess-&gt;mDriverFD &lt; 0) &#123; return -EBADF; &#125; //è®¾ç½®binderè¯·æ±‚ç  mOut.writeInt32(BC_ENTER_LOOPER); //æ£€æŸ¥å†™ç¼“å­˜æ˜¯å¦æœ‰å¯å†™æ•°æ®ï¼Œæœ‰çš„è¯å‘é€ç»™binderé©±åŠ¨ flushCommands(); //èµ‹å€¼binderé©±åŠ¨çš„æ–‡ä»¶æè¿°ç¬¦ *fd = mProcess-&gt;mDriverFD; pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); mProcess-&gt;mCurrentThreads++; pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); return 0;&#125; Binderäº‹åŠ¡å¤„ç†BinderCallbackç±»é‡å†™äº†handleEventå‡½æ•°ï¼Œé‡Œé¢è°ƒç”¨äº†IPCThreadState::handlePolledCommandså‡½æ•°æ¥æ¥æ”¶å¤„ç†binderäº‹åŠ¡ 1234567891011121314status_t IPCThreadState::handlePolledCommands()&#123; status_t result; //å½“è¯»ç¼“å­˜ä¸­æ•°æ®æœªæ¶ˆè´¹å®Œæ—¶ï¼ŒæŒç»­å¾ªç¯ do &#123; result = getAndExecuteCommand(); &#125; while (mIn.dataPosition() &lt; mIn.dataSize()); //å½“æˆ‘ä»¬æ¸…ç©ºæ‰§è¡Œå®Œæ‰€æœ‰çš„å‘½ä»¤åï¼Œæœ€åå¤„ç†BR_DECREFSå’ŒBR_RELEASE processPendingDerefs(); flushCommands(); return result;&#125; è¯»å–å¹¶å¤„ç†å“åº”è¿™ä¸ªå‡½æ•°çš„é‡ç‚¹åœ¨getAndExecuteCommandï¼Œé¦–å…ˆæ— è®ºå¦‚ä½•ä»binderé©±åŠ¨é‚£é‡Œè¯»å–å¹¶å¤„ç†ä¸€æ¬¡å“åº”ï¼Œå¦‚æœå¤„ç†å®Œåå‘ç°è¯»ç¼“å­˜ä¸­è¿˜æœ‰æ•°æ®å°šæœªæ¶ˆè´¹å®Œï¼Œç»§ç»­å¾ªç¯è¿™ä¸ªå¤„ç†è¿‡ç¨‹ï¼ˆç†è®ºæ¥è¯´æ­¤æ—¶ä¸ä¼šå†ä»binderé©±åŠ¨é‚£é‡Œè¯»å†™æ•°æ®ï¼Œåªä¼šå¤„ç†å‰©ä½™è¯»ç¼“å­˜ï¼‰ 12345678910111213141516171819status_t IPCThreadState::getAndExecuteCommand()&#123; status_t result; int32_t cmd; //ä»binderé©±åŠ¨ä¸­è¯»å†™æ•°æ®ï¼ˆç†è®ºæ¥è¯´æ­¤æ—¶å†™ç¼“å­˜dataSizeä¸º0ï¼Œä¹Ÿå°±æ˜¯åªè¯»æ•°æ®ï¼‰ result = talkWithDriver(/* true */); if (result &gt;= NO_ERROR) &#123; size_t IN = mIn.dataAvail(); if (IN &lt; sizeof(int32_t)) return result; //è¯»å–BRå“åº”ç  cmd = mIn.readInt32(); ... result = executeCommand(cmd); ... &#125; return result;&#125; å¤„ç†å“åº”è¿™é‡Œæœ‰å¾ˆå¤šçº¿ç¨‹ç­‰å…¶ä»–æ“ä½œï¼Œæˆ‘ä»¬ä¸éœ€è¦å…³å¿ƒï¼Œæˆ‘åœ¨è¿™é‡ŒæŠŠä»–ä»¬ç®€åŒ–æ‰äº†ï¼Œå‰©ä½™çš„ä»£ç å¾ˆæ¸…æ™°ï¼Œé¦–å…ˆä»binderé©±åŠ¨ä¸­è¯»å–æ•°æ®ï¼Œç„¶åä»æ•°æ®ä¸­è¯»å–å‡ºBRå“åº”ç ï¼Œæ¥ç€è°ƒç”¨executeCommandå‡½æ•°ç»§ç»­å¾€ä¸‹å¤„ç† 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION_SEC_CTX: case BR_TRANSACTION: &#123; binder_transaction_data_secctx tr_secctx; binder_transaction_data&amp; tr = tr_secctx.transaction_data; if (cmd == (int) BR_TRANSACTION_SEC_CTX) &#123; result = mIn.read(&amp;tr_secctx, sizeof(tr_secctx)); &#125; else &#123; result = mIn.read(&amp;tr, sizeof(tr)); tr_secctx.secctx = 0; &#125; ALOG_ASSERT(result == NO_ERROR, \"Not enough command data for brTRANSACTION\"); if (result != NO_ERROR) break; //è¯»å–æ•°æ®åˆ°ç¼“å†²åŒº Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); ... Parcel reply; status_t error; //å¯¹äºServiceManagerçš„binderèŠ‚ç‚¹æ¥è¯´ï¼Œæ˜¯æ²¡æœ‰ptrçš„ if (tr.target.ptr) &#123; // We only have a weak reference on the target object, so we must first try to // safely acquire a strong reference before doing anything else with it. //å¯¹äºå…¶ä»–binderæœåŠ¡ç«¯æ¥è¯´ï¼Œtr.cookieä¸ºæœ¬åœ°BBinderå¯¹è±¡æŒ‡é’ˆ if (reinterpret_cast&lt;RefBase::weakref_type*&gt;( tr.target.ptr)-&gt;attemptIncStrong(this)) &#123; error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this); &#125; else &#123; error = UNKNOWN_TRANSACTION; &#125; &#125; else &#123; //å¯¹äºServiceManageræ¥è¯´ï¼Œä½¿ç”¨the_context_objectè¿™ä¸ªBBinderå¯¹è±¡ error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123; LOG_ONEWAY(\"Sending reply to %d!\", mCallingPid); if (error &lt; NO_ERROR) reply.setError(error); //éTF_ONE_WAYæ¨¡å¼ä¸‹éœ€è¦Reply sendReply(reply, 0); &#125; else &#123; ... //TF_ONE_WAYæ¨¡å¼ä¸‹ä¸éœ€è¦Replyï¼Œè¿™é‡Œåªæ‰“äº†äº›æ—¥å¿— &#125; ... &#125; break; ... &#125; if (result != NO_ERROR) &#123; mLastError = result; &#125; return result;&#125; æˆ‘ä»¬é‡ç‚¹åˆ†æè¿™ä¸ªå‡½æ•°åœ¨BR_TRANSACTIONä¸‹çš„caseï¼Œå…¶ä½™çš„éƒ½åˆ å‡æ‰ é¦–å…ˆï¼Œè¿™ä¸ªå‡½æ•°ä»è¯»ç¼“å­˜ä¸­è¯»å–äº†binder_transaction_dataï¼Œæˆ‘ä»¬çŸ¥é“è¿™ä¸ªç»“æ„ä½“è®°å½•äº†å®é™…æ•°æ®çš„åœ°å€ã€å¤§å°ç­‰ä¿¡æ¯ï¼Œç„¶åå®ä¾‹åŒ–äº†ä¸€ä¸ªParcelå¯¹è±¡ä½œä¸ºç¼“å†²åŒºï¼Œä»binder_transaction_dataä¸­å°†å®é™…æ•°æ®è¯»å–å‡ºæ¥ æ¥ç€æ‰¾åˆ°æœ¬åœ°BBinderå¯¹è±¡ï¼Œå¯¹äºServiceManageræ¥è¯´å°±æ˜¯ä¹‹å‰åœ¨mainå‡½æ•°ä¸­setTheContextObjectçš„ServiceManagerå¯¹è±¡ï¼Œè€Œå¯¹äºå…¶ä»–binderæœåŠ¡ç«¯æ¥è¯´ï¼Œåˆ™æ˜¯é€šè¿‡tr.cookieè·å–ï¼Œç„¶åè°ƒç”¨BBinderçš„transactå‡½æ•° 12345678910111213141516171819202122232425262728293031323334status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; //ç¡®ä¿ä»å¤´å¼€å§‹è¯»å–æ•°æ® data.setDataPosition(0); if (reply != nullptr &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123; //æ ‡è®°è¿™ä¸ªParcelåœ¨é‡Šæ”¾æ—¶éœ€è¦å°†å†…å­˜ä¸­æ•°æ®ç”¨0è¦†ç›–ï¼ˆæ¶‰åŠå®‰å…¨ï¼‰ reply-&gt;markSensitive(); &#125; status_t err = NO_ERROR; //è¿™é‡Œçš„codeæ˜¯ç”±binderå®¢æˆ·ç«¯è¯·æ±‚ä¼ é€’è¿‡æ¥çš„ //æ˜¯å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„ä¸€ä¸ªçº¦å®š //å®ƒæ ‡è¯†äº†å®¢æˆ·ç«¯åƒæœåŠ¡ç«¯å‘èµ·çš„æ˜¯å“ªç§è¯·æ±‚ switch (code) &#123; ... default: err = onTransact(code, data, reply, flags); break; &#125; // In case this is being transacted on in the same process. if (reply != nullptr) &#123; //è®¾ç½®æ•°æ®æŒ‡é’ˆåç§»ä¸º0ï¼Œè¿™æ ·åç»­è¯»å–æ•°æ®ä¾¿ä¼šä»å¤´å¼€å§‹ reply-&gt;setDataPosition(0); if (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123; ALOGW(\"Large reply transaction of %zu bytes, interface descriptor %s, code %d\", reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code); &#125; &#125; return err;&#125; onTransactè¿™ä¸ªå‡½æ•°ä¸»è¦è°ƒç”¨äº†onTransactå‡½æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼Œå¯ä»¥è¢«å­ç±»é‡å†™ã€‚æˆ‘ä»¬è§‚å¯ŸServiceManagerè¿™ä¸ªç±»ï¼Œå®ƒç»§æ‰¿äº†BnServiceManagerï¼Œåœ¨BnServiceManagerä¸­é‡å†™äº†è¿™ä¸ªonTransactå‡½æ•°ï¼Œå®ƒä»¬çš„ç»§æ‰¿å…³ç³»å¦‚ä¸‹ï¼š ServiceManager -&gt; BnServiceManager -&gt; BnInterface&lt;IServiceManager&gt; -&gt; IServiceManager &amp; BBinder è¿™é‡Œçš„BnServiceManageræ˜¯é€šè¿‡AIDLå·¥å…·ç”Ÿæˆå‡ºæ¥çš„ï¼ˆAIDLæ—¢å¯ä»¥ç”ŸæˆJavaä»£ç ï¼Œä¹Ÿå¯ä»¥ç”ŸæˆC++ä»£ç ï¼‰ï¼Œæˆ‘ä»¬æ‰¾åˆ°ä¸€ä»½ç”Ÿæˆåçš„ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123; ::android::status_t _aidl_ret_status = ::android::OK; switch (_aidl_code) &#123; case BnServiceManager::TRANSACTION_getService: &#123; //å‚æ•°name ::std::string in_name; ::android::sp&lt;::android::IBinder&gt; _aidl_return; //ç±»å‹æ£€æŸ¥ if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; //è¯»å–å‚æ•°name _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; //ç¡®è®¤æ•°æ®å·²è¯»å®Œ if (auto st = _aidl_data.enforceNoDataAvail(); !st.isOk()) &#123; _aidl_ret_status = st.writeToParcel(_aidl_reply); break; &#125; //æ‰§è¡ŒçœŸæ­£çš„getServiceå‡½æ•° ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return)); //å°†çŠ¶æ€å€¼å†™å…¥reply _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; //å°†è¿”å›å€¼å†™å…¥reply _aidl_ret_status = _aidl_reply-&gt;writeStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; ... &#125; if (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123; _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeOverParcel(_aidl_reply); &#125; return _aidl_ret_status;&#125; ç”Ÿæˆå‡ºçš„ä»£ç æ ¼å¼æ¯”è¾ƒä¸‘ï¼Œä¸æ˜“é˜…è¯»ï¼Œæˆ‘æŠŠå®ƒæ ¼å¼åŒ–äº†ä¸€ä¸‹ï¼Œæå–å‡ºæˆ‘ä»¬éœ€è¦çš„éƒ¨åˆ†ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦æµç¨‹å°±æ˜¯å…ˆä»dataä¸­è¯»å–æ‰€éœ€è¦çš„å‚æ•°ï¼Œç„¶åæ ¹æ®å‚æ•°æ‰§è¡Œç›¸å¯¹åº”çš„å‡½æ•°ï¼Œç„¶åå°†çŠ¶æ€å€¼å†™å…¥replyï¼Œæœ€åå†å°†è¿”å›å€¼å†™å…¥replyã€‚è¿™é‡Œæˆ‘ä»¬å°†ä¸Šä¸€ç« èŠ‚AIDLç”Ÿæˆå‡ºçš„javaæ–‡ä»¶é‚£éƒ¨åˆ†æ‹¿è¿‡æ¥åšå¯¹æ¯”ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œè¿™é‡ŒParcelçš„å†™å…¥å’Œé‚£é‡ŒParcelçš„è¯»å–é¡ºåºæ˜¯ä¸¥æ ¼ä¸€ä¸€å¯¹åº”çš„ 1234567891011121314151617181920@Override public android.os.IBinder getService(java.lang.String name) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); android.os.IBinder _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); boolean _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, 0); //å…ˆè¯»å–çŠ¶æ€å€¼ _reply.readException(); //å†è¯»å–è¿”å›å€¼ _result = _reply.readStrongBinder(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; å®é™…åŠŸèƒ½å®ç°ç„¶åæˆ‘ä»¬æ¥çœ‹çœŸæ­£åŠŸèƒ½å®ç°çš„åœ°æ–¹ï¼šgetServiceå‡½æ•°ï¼Œæ ¹æ®ä¹‹å‰æ‰€è¯´çš„ç»§æ‰¿å…³ç³»ï¼ŒServiceManagerç»§æ‰¿è‡ªIServiceManagerï¼Œå®ç°äº†å…¶ä¸­çš„çº¯è™šå‡½æ•°ï¼Œå…¶ä¸­å°±åŒ…æ‹¬äº†getService 12345Status ServiceManager::getService(const std::string&amp; name, sp&lt;IBinder&gt;* outBinder) &#123; *outBinder = tryGetService(name, true); // returns ok regardless of result for legacy reasons return Status::ok();&#125; 1234567891011121314151617181920212223242526272829303132333435363738sp&lt;IBinder&gt; ServiceManager::tryGetService(const std::string&amp; name, bool startIfNotFound) &#123; auto ctx = mAccess-&gt;getCallingContext(); //è¿”å›å€¼ sp&lt;IBinder&gt; out; Service* service = nullptr; //ä»mapä¸­å¯»æ‰¾ç›¸åº”çš„æœåŠ¡ if (auto it = mNameToService.find(name); it != mNameToService.end()) &#123; service = &amp;(it-&gt;second); if (!service-&gt;allowIsolated) &#123; uid_t appid = multiuser_get_app_id(ctx.uid); bool isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END; if (isIsolated) &#123; return nullptr; &#125; &#125; //è¿”å›å€¼æŒ‡å‘å¯¹åº”serviceçš„binderå¯¹è±¡ out = service-&gt;binder; &#125; if (!mAccess-&gt;canFind(ctx, name)) &#123; return nullptr; &#125; if (!out &amp;&amp; startIfNotFound) &#123; tryStartService(name); &#125; if (out) &#123; // Setting this guarantee each time we hand out a binder ensures that the client-checking // loop knows about the event even if the client immediately drops the service service-&gt;guaranteeClient = true; &#125; return out;&#125; è¿™é‡Œé¢çš„å®ç°æˆ‘ä»¬å°±æ²¡å¿…è¦ç»†çœ‹äº†ï¼Œåªéœ€è¦æ³¨æ„å®ƒè¿”å›äº†ç›¸åº”serviceçš„binderå¯¹è±¡ï¼Œæ ¹æ®ä¸Šé¢çš„ä»£ç æ¥çœ‹ï¼Œä¼šå°†å…¶å†™å…¥åˆ°replyä¸­ Replyå®é™…çš„åŠŸèƒ½å¤„ç†å®Œæˆåï¼Œæˆ‘ä»¬å›åˆ°IPCThreadState::executeCommandä¸­æ¥ã€‚å¯¹äºéTF_ONE_WAYæ¨¡å¼ï¼Œæˆ‘ä»¬è¦å°†replyå‘é€ç»™è¯·æ±‚æ–¹å®¢æˆ·ç«¯ 12345678910status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)&#123; status_t err; status_t statusBuffer; //å°†binder replyè¯·æ±‚æ‰“åŒ…å¥½å†™å…¥å†™ç¼“å†²åŒº err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer); if (err &lt; NO_ERROR) return err; return waitForResponse(nullptr, nullptr);&#125; writeTransactionDataåœ¨ä¸Šä¸€ç« ä¸­å·²ç»åˆ†æè¿‡äº†ï¼Œè¿™é‡Œå°±ä¸å¤šåšæè¿°äº†ï¼ŒwaitForResponseæˆ‘ä»¬ä¸Šä¸€ç« ä¹Ÿåˆ†æè¿‡äº†ï¼Œæ ¹æ®æˆ‘ä»¬åœ¨ä¸Šä¸€ç« æ‰€æè¿°çš„éTF_ONE_WAYçš„é€šä¿¡è¿‡ç¨‹ï¼Œåœ¨å‘binderé©±åŠ¨å‘é€BC_REPLYè¯·æ±‚åæˆ‘ä»¬ä¼šæ”¶åˆ°BR_TRANSACTION_COMPLETEå“åº”ï¼Œæ ¹æ®æˆ‘ä»¬ä¼ å…¥waitForResponseçš„ä¸¤ä¸ªå‚æ•°å€¼ï¼Œä¼šç›´æ¥è·³å‡ºå‡½æ•°ä¸­çš„å¾ªç¯ï¼Œç»“æŸæ­¤æ¬¡binderé€šä¿¡ 1234567891011121314151617181920212223242526272829303132status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; ... case BR_TRANSACTION_COMPLETE: //å‚æ•°ä¸ºä¸¤ä¸ªnullptrï¼Œç›´æ¥è·³è½¬åˆ°finishç»“æŸ if (!reply &amp;&amp; !acquireResult) goto finish; break; ... &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; logExtendedError(); &#125; return err;&#125; è‡³æ­¤ï¼ŒbinderæœåŠ¡ç«¯çš„ä¸€æ¬¡æ¶ˆæ¯å¤„ç†åˆ°è¿™å°±ç»“æŸäº†ï¼ŒLooperä¼šæŒç»­ç›‘å¬ç€binderé©±åŠ¨fdï¼Œç­‰å¾…ä¸‹ä¸€æ¡binderæ¶ˆæ¯çš„åˆ°æ¥ ç»“æŸç»è¿‡è¿™ä¹ˆå¤šç¯‡æ–‡ç« çš„åˆ†æï¼Œæ•´ä¸ªBinderæ¶æ„çš„å¤§è‡´é€šä¿¡åŸç†ã€è¿‡ç¨‹ï¼Œæˆ‘ä»¬åº”è¯¥éƒ½äº†è§£çš„å·®ä¸å¤šäº†ï¼Œè‡³äºä¸€äº›è¾¹è¾¹è§’è§’çš„ç»†èŠ‚ï¼Œä»¥åæœ‰æœºä¼šçš„è¯æˆ‘ä¼šæ…¢æ…¢å†è¡¥å……","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Androidæºç åˆ†æ - Frameworkå±‚çš„Binderï¼ˆå®¢æˆ·ç«¯ç¯‡ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„Binderï¼ˆå®¢æˆ·ç«¯ç¯‡ï¼‰","date":"2022-06-27T03:45:00.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/06/27/android/aosp/Androidæºç åˆ†æ-Frameworkå±‚çš„Binderï¼ˆå®¢æˆ·ç«¯ç¯‡ï¼‰/","link":"","permalink":"http://yoursite.com/2022/06/27/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥aospåˆ†æ”¯android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ æˆ‘ä»¬åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­ï¼Œä»é©±åŠ¨å±‚é¢åˆ†æäº†Binderæ˜¯æ€æ ·å·¥ä½œçš„ï¼Œä½†Binderé©±åŠ¨åªæ¶‰åŠä¼ è¾“éƒ¨åˆ†ï¼Œå¾…ä¼ è¾“å¯¹è±¡æ˜¯æ€ä¹ˆäº§ç”Ÿçš„å‘¢ï¼Œè¿™å°±æ˜¯frameworkå±‚çš„å·¥ä½œäº†ã€‚æˆ‘ä»¬è¦å½»åº•äº†è§£Binderçš„å·¥ä½œåŸç†ï¼Œä¸ä»…è¦å»çœ‹é©±åŠ¨å±‚ï¼Œè¿˜å¾—å»çœ‹frameworkå±‚ä»¥åŠåº”ç”¨å±‚ï¼ˆAIDLï¼‰ ServiceManagergetIServiceManageræˆ‘ä»¬è¿˜æ˜¯ä»¥ç¬¬ä¸€æ¬¡è§åˆ°Binderçš„åœ°æ–¹ServiceManagerå¼€å§‹åˆ†æï¼Œæˆ‘ä»¬é€‰å–getServiceæ–¹æ³•æ¥åˆ†æï¼ˆè¿™ä¸ªæ–¹æ³•æ—¢æœ‰å…¥å‚ä¹Ÿæœ‰è¿”å›ï¼‰ï¼ŒæŠ›é™¤æ‰å®ƒç¼“å­˜å’Œlogçš„éƒ¨åˆ†ï¼Œæœ€æ ¸å¿ƒçš„ä»£ç å°±ä¸€å¥getIServiceManager().getService(name) 12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager;&#125; BinderInternal.getContextObjectæˆ‘ä»¬ä»BinderInternal.getContextObject()å¼€å§‹çœ‹èµ·ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªnativeå‡½æ•°ï¼Œä»–è¢«å®ç°åœ¨frameworks/base/core/jni/android_util_Binder.cppä¸­ 12345static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125; ProcessStateæˆ‘ä»¬åœ¨è¿™é‡Œå¯ä»¥å‘ç°ä¸€ä¸ªæ¯”è¾ƒå…³é”®çš„ç±»ProcessStateï¼Œå®ƒæ˜¯ä¸€ä¸ªè´Ÿè´£æ‰“å¼€binderé©±åŠ¨å¹¶è¿›è¡Œmmapæ˜ å°„çš„å•ä¾‹å¯¹è±¡ï¼Œè¿™ä»å®ƒçš„selfå‡½æ•°å°±å¯ä»¥çœ‹å‡ºæ¥ï¼Œæ¯ä¸ªè¿›ç¨‹åªå­˜åœ¨ä¸€ä¸ªProcessStateå®ä¾‹ ä½ç½®ï¼šframeworks/native/libs/binder/ProcessState.cpp 123456789sp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != nullptr) &#123; return gProcess; &#125; gProcess = new ProcessState(kDefaultDriver); return gProcess;&#125; æˆ‘ä»¬æ¥çœ‹çœ‹å®ƒçš„æ„é€ å‡½æ•° 123456789101112131415161718192021ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver)) //æ‰“å¼€binderé©±åŠ¨ , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE)&#123; if (mDriverFD &gt;= 0) &#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); ... &#125;&#125; è¿™é‡Œçš„:åæ˜¯c++æ„é€ å‡½æ•°åˆå§‹åŒ–èµ‹å€¼çš„ä¸€ç§è¯­æ³•ï¼Œå¯ä»¥çœ‹åˆ°å…¶ä¸­è°ƒç”¨äº†open_driverå‡½æ•°æ‰“å¼€binderé©±åŠ¨ 123456789101112131415static int open_driver(const char *driver)&#123; //æ‰“å¼€binderé©±åŠ¨ int fd = open(driver, O_RDWR | O_CLOEXEC); int vers = 0; //éªŒè¯binderç‰ˆæœ¬ status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ... &#125; //è®¾ç½®binderæœ€å¤§çº¿ç¨‹æ•° size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); return fd;&#125; è¿™é‡Œåšäº†ä¸‰ä»¶äº‹ï¼Œæ‰“å¼€binderé©±åŠ¨ã€éªŒè¯binderç‰ˆæœ¬ã€è®¾ç½®binderæœ€å¤§çº¿ç¨‹æ•°ï¼Œæ¥ç€æ„é€ å‡½æ•°è°ƒç”¨mmapå»ºç«‹binderæ˜ å°„ï¼Œè¿™é‡Œé¢çš„å®ç°æˆ‘ä»¬å·²ç»åœ¨Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸Šï¼‰ã€ï¼ˆä¸­ï¼‰ã€ï¼ˆä¸‹ï¼‰ä¸­åˆ†æè¿‡äº†ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥å›è¿‡å¤´å»çœ‹ä¸€çœ‹ ProcessState::selfå‡½æ•°æ‰§è¡Œå®Œåï¼Œå½“å‰è¿›ç¨‹çš„binderåˆå§‹åŒ–å·¥ä½œå·²ç»æ‰§è¡Œå®Œæ¯•ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å›è¿‡å¤´æ¥çœ‹å®ƒçš„getContextObjectå‡½æ•° 1234567891011121314sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; sp&lt;IBinder&gt; context = getStrongProxyForHandle(0); if (context == nullptr) &#123; ALOGW(\"Not able to get context object on %s.\", mDriverName.c_str()); &#125; // The root object is special since we get it directly from the driver, it is never // written by Parcell::writeStrongBinder. internal::Stability::tryMarkCompilationUnit(context.get()); return context;&#125; æˆ‘ä»¬åœ¨binderé©±åŠ¨ç¯‡å°±æåˆ°äº†ï¼Œhandleå¥æŸ„0ä»£è¡¨çš„å°±æ˜¯ServiceManagerï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨getStrongProxyForHandleå‡½æ•°çš„å‚æ•°ä¸º0 12345678910111213141516171819202122232425262728293031323334sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); //æŸ¥æ‰¾æˆ–å»ºç«‹handleå¯¹åº”çš„handle_entry handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) &#123; IBinder* b = e-&gt;binder; if (b == nullptr || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; //å½“handleä¸ºServiceManagerçš„ç‰¹æ®Šæƒ…å†µ //éœ€è¦ç¡®ä¿åœ¨åˆ›å»ºBinderå¼•ç”¨ä¹‹å‰ï¼Œcontext managerå·²ç»è¢«binderæ³¨å†Œ Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; &#125; //åˆ›å»ºBpBinderå¹¶ä¿å­˜ä¸‹æ¥ä»¥ä¾¿åé¢å†æ¬¡æŸ¥æ‰¾ b = BpBinder::create(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; 12345678910111213ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)&#123; const size_t N=mHandleToObject.size(); //æ–°å»ºä¸€ä¸ªhandle_entryå¹¶æ’å…¥åˆ°vectorä¸­ if (N &lt;= (size_t)handle) &#123; handle_entry e; e.binder = nullptr; e.refs = nullptr; status_t err = mHandleToObject.insertAt(e, N, handle+1-N); if (err &lt; NO_ERROR) return nullptr; &#125; return &amp;mHandleToObject.editItemAt(handle);&#125; æ•´æ¡é“¾è·¯ä¸‹æ¥è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ï¼Œæœ€ç»ˆè·å¾—äº†ä¸€ä¸ªBpBinderå¯¹è±¡ï¼Œè¿™æ˜¯nativeä¸­çš„ç±»å‹ï¼Œéœ€è¦å°†å®ƒè½¬æ¢æˆjavaä¸­çš„ç±»å‹ï¼Œè¿™é‡Œè°ƒç”¨äº†javaObjectForIBinderå‡½æ•°ï¼Œä½äºframeworks/base/core/jni/android_util_Binder.cppä¸­ javaObjectForIBinder1234567891011121314151617181920212223242526272829303132333435// If the argument is a JavaBBinder, return the Java object that was used to create it.// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; if (val == NULL) return NULL; //JavaBBinderè¿”å›trueï¼Œå…¶ä»–ç±»å‡è¿”å›flase if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); return object; &#125; BinderProxyNativeData* nativeData = new BinderProxyNativeData(); nativeData-&gt;mOrgue = new DeathRecipientList; nativeData-&gt;mObject = val; jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); if (env-&gt;ExceptionCheck()) &#123; // In the exception case, getInstance still took ownership of nativeData. return NULL; &#125; BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); //å¦‚æœobjectæ˜¯åˆšåˆšæ–°å»ºå‡ºæ¥çš„BinderProxy if (actualNativeData == nativeData) &#123; //å¤„ç†proxyè®¡æ•° ... &#125; else &#123; delete nativeData; &#125; return object;&#125; æˆ‘ä»¬å…ˆçœ‹ä¸€çœ‹è¿™ä¸ªgBinderProxyOffsetsæ˜¯ä»€ä¹ˆ 123456789101112131415161718192021222324252627static struct binderproxy_offsets_t&#123; // Class state. jclass mClass; jmethodID mGetInstance; jmethodID mSendDeathNotice; // Object state. //æŒ‡å‘BinderProxyNativeDataçš„æŒ‡é’ˆ jfieldID mNativeData; // Field holds native pointer to BinderProxyNativeData.&#125; gBinderProxyOffsets;const char* const kBinderProxyPathName = \"android/os/BinderProxy\";static int int_register_android_os_BinderProxy(JNIEnv* env)&#123; ... jclass clazz = FindClassOrDie(env, kBinderProxyPathName); gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz); gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, \"getInstance\", \"(JJ)Landroid/os/BinderProxy;\"); gBinderProxyOffsets.mSendDeathNotice = GetStaticMethodIDOrDie(env, clazz, \"sendDeathNotice\", \"(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V\"); gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, \"mNativeData\", \"J\"); ...&#125; å¯ä»¥çœ‹åˆ°ï¼ŒgBinderProxyOffsetså®é™…ä¸Šæ˜¯ä¸€ä¸ªç”¨æ¥è®°å½•ä¸€äº›javaä¸­å¯¹åº”ç±»ã€æ–¹æ³•ä»¥åŠå­—æ®µçš„ç»“æ„ä½“ï¼Œç”¨äºä»nativeå±‚è°ƒç”¨javaå±‚ä»£ç  æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹javaObjectForIBinderå‡½æ•°çš„å…·ä½“å†…å®¹ 123456789101112jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; if (val == NULL) return NULL; //JavaBBinderè¿”å›trueï¼Œå…¶ä»–ç±»å‡è¿”å›flase if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); return object; &#125; ...&#125; é¦–å…ˆæœ‰ä¸€ä¸ªIBinderç±»å‹æ£€æŸ¥çš„åˆ¤æ–­ï¼Œæˆ‘çœ‹äº†ä¸€åœˆå‘ç°ç›®å‰åªæœ‰å½“IBinderçš„å®é™…ç±»å‹ä¸ºJavaBBinderçš„æ—¶å€™ä¼šè¿”å›trueï¼Œå…¶ä»–å­ç±»å‡è¿”å›falseã€‚JavaBBinderç±»ç»§æ‰¿è‡ªBBinderï¼Œé‡Œé¢ä¿å­˜äº†å¯¹javaå±‚Binderå¯¹è±¡çš„å¼•ç”¨ï¼Œæ‰€ä»¥åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç›´æ¥è¿”å›é‡Œé¢çš„objectå°±å¥½äº†ã€‚ ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºï¼Œnativeå±‚çš„javaBBinderä¸javaå±‚çš„Binderæ˜¯å¯¹åº”å…³ç³» æˆ‘ä»¬è¿™é‡Œä¼ è¿›æ¥çš„æ˜¯BpBinderï¼Œä¼šæ¥ç€å¾€ä¸‹èµ° 1234567891011jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... BinderProxyNativeData* nativeData = new BinderProxyNativeData(); nativeData-&gt;mOrgue = new DeathRecipientList; nativeData-&gt;mObject = val; jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); ...&#125; æ¥ç€å®ä¾‹åŒ–ä¸€ä¸ªBinderProxyNativeDataï¼Œå°†Binderæ­»äº¡å›è°ƒDeathRecipientListå’ŒBinderå¯¹è±¡ï¼ˆè¿™é‡Œä¸ºBpBinderï¼‰èµ‹å€¼ç»™å®ƒï¼Œç„¶åè°ƒç”¨javaå±‚æ–¹æ³•ã€‚gBinderProxyOffsetsä¹‹å‰è¯´è¿‡äº†ï¼Œç±»ä¸ºandroid.os.BinderProxyï¼Œæ–¹æ³•ä¸ºgetInstanceï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨çš„å³ä¸ºandroid.os.BinderProxy.getInstance(nativeData, iBinder)ï¼ŒBinderProxyçš„è·¯å¾„ä¸ºframeworks/base/core/java/android/os/BinderProxy.java 123456789101112131415161718192021private static BinderProxy getInstance(long nativeData, long iBinder) &#123; BinderProxy result; synchronized (sProxyMap) &#123; try &#123; result = sProxyMap.get(iBinder); if (result != null) &#123; return result; &#125; result = new BinderProxy(nativeData); &#125; catch (Throwable e) &#123; // We're throwing an exception (probably OOME); don't drop nativeData. NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer, nativeData); throw e; &#125; NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData); // The registry now owns nativeData, even if registration threw an exception. sProxyMap.set(iBinder, result); &#125; return result;&#125; è¿™é‡Œçš„é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œä»¥iBinderä¸º key å°è¯•ä»sProxyMapå–å‡ºBinderProxyï¼Œå¦‚æœå–åˆ°å€¼äº†å°±ç›´æ¥å°†å®ƒè¿”å›å‡ºå»ï¼Œå¦‚æœæ²¡å–åˆ°ï¼Œç”¨ä¹‹å‰ä¼ è¿›æ¥çš„BinderProxyNativeDataæŒ‡é’ˆä¸ºå‚æ•°å®ä¾‹åŒ–ä¸€ä¸ªBinderProxyï¼Œå¹¶å°†å…¶è®¾ç½®åˆ°sProxyMapä¸­ ä»è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¯ä¸€ä¸ªæœåŠ¡çš„BinderProxyéƒ½æ˜¯ä»¥å•ä¾‹å½¢å¼å­˜åœ¨çš„ï¼Œå¹¶ä¸”nativeå±‚çš„BinderProxyNativeDataä¸javaå±‚çš„BinderProxyæ˜¯å¯¹åº”å…³ç³» 123456789101112131415161718BinderProxyNativeData* getBPNativeData(JNIEnv* env, jobject obj) &#123; return (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);&#125;jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); //å¦‚æœobjectæ˜¯åˆšåˆšæ–°å»ºå‡ºæ¥çš„BinderProxy if (actualNativeData == nativeData) &#123; //å¤„ç†proxyè®¡æ•° ... &#125; else &#123; delete nativeData; &#125; return object;&#125; æ¥ä¸‹æ¥åˆ¤æ–­æˆ‘ä»¬é€šè¿‡BinderProxy.getInstanceæ–¹æ³•è·å¾—çš„BinderProxyæ˜¯ä¸æ˜¯åˆšåˆšåˆ›å»ºå‡ºæ¥çš„ï¼Œå¦‚æœæ˜¯æ–°å»ºçš„åˆ™éœ€è¦å¤„ç†ä¸€ä¸‹proxyè®¡æ•°ï¼Œè¿™é‡Œæ˜¯é€šè¿‡å¯¹æ¯”BinderProxyä¸­çš„mNativeDataå’Œæˆ‘ä»¬æ–°å»ºå‡ºæ¥çš„nativeDataåœ°å€åˆ¤æ–­çš„ ServiceManagerNative.asInterfaceæˆ‘ä»¬å°†ç›®å…‰æ”¾å›getIServiceManageræ–¹æ³•ï¼Œç°åœ¨æˆ‘ä»¬çŸ¥é“BinderInternal.getContextObject()æ–¹æ³•è¿”å›äº†ServiceManagerå¯¹åº”çš„BinderProxyï¼Œæ¥ç€ä¼šè°ƒç”¨Binder.allowBlockingæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•åªæ˜¯æ”¹å˜äº†BinderProxyä¸­çš„ä¸€ä¸ªå‚æ•°ï¼Œä½¿å…¶å…è®¸é˜»å¡è°ƒç”¨ï¼Œè¿™æ ·çš„è¯getIServiceManagerå°±å¯ä»¥è¢«ç®€åŒ–æˆå¦‚ä¸‹ä»£ç  12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(/* BinderProxy */); return sServiceManager;&#125; æˆ‘ä»¬çœ‹åˆ°asInterfaceæ–¹æ³•å®é™…ä¸Šæ˜¯ç›´æ¥å®ä¾‹åŒ–äº†ä¸€ä¸ªServiceManagerProxyå¯¹è±¡ 12345678public static IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // ServiceManager is never local return new ServiceManagerProxy(obj);&#125; ServiceManagerProxyä»åå­—å°±èƒ½å¬å‡ºæ¥ï¼ŒServiceManagerProxyå…¶å®æ˜¯ä¸€ä¸ªä»£ç†ç±»ï¼Œå®ƒå…¶å®æ˜¯IServiceManager.Stub.Proxyçš„ä»£ç†ï¼Œå®é™…ä¸Šæ˜¯æ²¡æœ‰ä»€ä¹ˆå¿…è¦çš„ï¼Œå¯ä»¥å‘ç°ä½œè€…ä¹Ÿåœ¨æ³¨é‡Šä¸­æ ‡æ³¨äº†This class should be deleted and replaced with IServiceManager.Stub whenever mRemote is no longer usedï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒçš„æ„é€ æ–¹æ³• 1234public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; mServiceManager = IServiceManager.Stub.asInterface(remote);&#125; ServiceManagerProxyå®ç°äº†IServiceManageræ¥å£ï¼Œä½†è¿™ä¸ªæ–¹æ³•çš„å®ç°éƒ½æ˜¯ç›´æ¥è°ƒç”¨mServiceManagerï¼Œä»¥addServiceä¸¾ä¾‹ 1234public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException &#123; mServiceManager.addService(name, service, allowIsolated, dumpPriority);&#125; è¿™ä¸ç›´æ¥ä½¿ç”¨IServiceManager.Stub.asInterface(remote)å¾—åˆ°IServiceManagerå¹¶æ²¡æœ‰ä»€ä¹ˆåŒºåˆ« IServiceManageræˆ‘ä»¬å°†é‡ç‚¹è½¬åˆ°IServiceManagerä¸Šï¼Œæˆ‘ä»¬åœ¨æºç ä¸­æœç´¢ä¸åˆ°IServiceManager.javaæ–‡ä»¶ï¼Œå› ä¸ºå®é™…ä¸Šè¿™ä¸ªæ–‡ä»¶æ˜¯é€šè¿‡aidlç”Ÿæˆçš„ å…³äºaidlæˆ‘ä»¬åˆ°åé¢å†è¯¦ç»†åˆ†æï¼Œç°åœ¨æˆ‘ä»¬åªéœ€è¦çŸ¥é“å®ƒå…¶å®æ˜¯è¾…åŠ©æˆ‘ä»¬è¿›è¡Œbinderé€šä¿¡çš„ä¸€ç§å·¥å…·ï¼Œaidlæ–‡ä»¶ä¼šåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ç”Ÿæˆå‡ºä¸ä¹‹å¯¹åº”çš„javaæ–‡ä»¶ IServiceManagerçš„aidlæ–‡ä»¶è·¯å¾„ä¸ºframeworks/native/libs/binder/aidl/android/os/IServiceManager.aidl æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒç”Ÿæˆå‡ºçš„IServiceManager.Stub.asInterfaceæ–¹æ³• 1234567891011public static android.os.IServiceManager asInterface(android.os.IBinder obj)&#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof android.os.IServiceManager))) &#123; return ((android.os.IServiceManager) iin); &#125; return new android.os.IServiceManager.Stub.Proxy(obj);&#125; è¿™é‡Œæˆ‘ä»¬ä¼ å…¥çš„IBinderæ˜¯BinderProxyï¼Œå®ƒçš„queryLocalInterfaceæ°¸è¿œè¿”å›nullï¼Œæ‰€ä»¥è¿™é‡Œè¿”å›çš„æ˜¯IServiceManager.Stub.Proxyå¯¹è±¡ï¼Œæˆ‘ä»¬æ¥ç€çœ‹ä¹‹å‰è°ƒç”¨çš„getServiceæ–¹æ³• 123456789101112131415161718@Override public android.os.IBinder getService(java.lang.String name) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); android.os.IBinder _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); boolean _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, 0); _reply.readException(); _result = _reply.readStrongBinder(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; ParcelParcelæ˜¯ä¸€ä¸ªå­˜æ”¾è¯»å–æ•°æ®çš„å®¹å™¨ï¼Œå®ƒçš„åŸºæœ¬åŠŸèƒ½å’Œä½¿ç”¨ç›¸ä¿¡è¿›é˜¶Androidå¼€å‘åº”è¯¥éƒ½æ‡‚ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œåªä»‹ç»ä¸€äº›å…³é”®æ€§å‡½æ•°çš„å«ä¹‰ï¼Œå…¶ä»–å°±ä¸å¤šèµ˜è¿°äº†ï¼Œæœ‰æœºä¼šçš„è¯ä»¥åå•ç‹¬å¼€ä¸€ç« åˆ†æå®ƒ å‡½æ•° ä½œç”¨ obtain è·å–ä¸€ä¸ªæ–°çš„Parcelå¯¹è±¡ ipcDataã€data æ•°æ®åŒºé¦–åœ°å€ ipcDataSizeã€dataSize æ•°æ®å¤§å° ipcObjects åç§»æ•°ç»„é¦–åœ°å€ ipcObjectsCount IPCå¯¹è±¡æ•°é‡ dataPosition æ•°æ®æŒ‡é’ˆå½“å‰çš„ä½ç½® dataCapacity æ•°æ®åŒºçš„æ€»å®¹é‡ï¼ˆå§‹ç»ˆ &gt;= dataSizeï¼‰ è¿™é‡Œè·å–äº†ä¸¤ä¸ªParcelï¼Œä¸€ä¸ª_dataç”¨æ¥ä¼ é€’å‚æ•°æ•°æ®ï¼Œä¸€ä¸ª_replyç”¨æ¥æ¥æ”¶å›åº”ã€‚æ¥ç€ï¼Œ_dataé¦–å…ˆè°ƒç”¨writeInterfaceTokenæ–¹æ³•ï¼Œè¿™é‡Œçš„tokenæ˜¯å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„ä¸€ä¸ªåå®šï¼ŒæœåŠ¡ç«¯ä¼šæ ¡éªŒæˆ‘ä»¬å†™å…¥çš„è¿™ä¸ªtokenï¼Œç„¶åæŒ‰ç…§é¡ºåºå°†å‚æ•°ä¾æ¬¡å†™å…¥åˆ°_dataä¸­ï¼ˆåºåˆ—åŒ–ï¼‰ï¼Œç„¶åé€šè¿‡binderè°ƒç”¨è¿œç¨‹æœåŠ¡çœŸæ­£çš„æ–¹æ³•ï¼Œç„¶åæ£€æŸ¥å¼‚å¸¸ã€‚ å¯¹äºæ— è¿”å›å€¼çš„æ–¹æ³•æ¥è¯´ï¼Œåˆ°è¿™ä¸€æ­¥å·²ç»ç»“æŸäº†ï¼Œä½†æˆ‘ä»¬è¿™ä¸ªæ–¹æ³•æ˜¯æœ‰è¿”å›å€¼çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ª_resultï¼Œä»_replyä¸­è¯»å–å‡ºæ•°æ®ï¼ˆååºåˆ—åŒ–ï¼‰ï¼Œèµ‹ç»™_resultï¼Œç„¶åè¿”å›å‡ºå» BinderProxy.transactæˆ‘ä»¬é‡ç‚¹çœ‹transactè¿™ä¸€éƒ¨åˆ†ï¼Œé€šè¿‡æˆ‘ä»¬ä¹‹å‰çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“mRemoteæ˜¯ä¸€ä¸ªBinderProxyç±»å‹çš„å¯¹è±¡ï¼Œæˆ‘ä»¬æ¥çœ‹ä»–çš„transactæ–¹æ³• 123456789101112131415161718192021222324252627public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; //æ£€æŸ¥Parcelå¤§å° Binder.checkParcel(this, code, data, \"Unreasonably large binder buffer\"); ... //trace ... //Binderäº‹åŠ¡å¤„ç†å›è°ƒ ... //AppOpsManagerä¿¡æ¯è®°å½• ... try &#123; final boolean result = transactNative(code, data, reply, flags); if (reply != null &amp;&amp; !warnOnBlocking) &#123; reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT); &#125; return result; &#125; finally &#123; ... &#125;&#125; æˆ‘è¿™é‡Œç®€åŒ–äº†ä¸€ä¸‹ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œé¦–å…ˆå°±æ˜¯å¯¹Parcelå¤§å°çš„æ£€æŸ¥ 12345678910111213141516171819202122static void checkParcel(IBinder obj, int code, Parcel parcel, String msg) &#123; if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= 800*1024) &#123; // Trying to send &gt; 800k, this is way too much. StringBuilder sb = new StringBuilder(); sb.append(msg); sb.append(\": on \"); sb.append(obj); sb.append(\" calling \"); sb.append(code); sb.append(\" size \"); sb.append(parcel.dataSize()); sb.append(\" (data: \"); parcel.setDataPosition(0); sb.append(parcel.readInt()); sb.append(\", \"); sb.append(parcel.readInt()); sb.append(\", \"); sb.append(parcel.readInt()); sb.append(\")\"); Slog.wtfStack(TAG, sb.toString()); &#125;&#125; Androidé»˜è®¤è®¾ç½®äº†Parcelæ•°æ®ä¼ è¾“ä¸èƒ½è¶…è¿‡800kï¼Œå½“ç„¶ï¼Œå„ä¸ªå‚å•†æ˜¯å¯ä»¥éšæ„æ”¹åŠ¨è¿™é‡Œçš„ä»£ç çš„ï¼Œå¦‚æœè¶…è¿‡äº†çš„è¯ï¼Œä¾¿ä¼šè°ƒç”¨Slog.wtfStackæ‰“å°æ—¥å¿—ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨å½“å‰è¿›ç¨‹ä¸æ˜¯ç³»ç»Ÿè¿›ç¨‹å¹¶ä¸”ç³»ç»Ÿä¹Ÿä¸æ˜¯å·¥ç¨‹ç‰ˆæœ¬çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯ä¼šç»“æŸè¿›ç¨‹çš„ï¼Œæ‰€ä»¥åœ¨åº”ç”¨å¼€å‘çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦æ³¨æ„è·¨è¿›ç¨‹æ•°æ®ä¼ è¾“çš„å¤§å°ï¼Œé¿å…å› æ­¤å¼•å‘crash çœå»ä¸­é—´çš„ä¸€äº›logã€å›è°ƒï¼Œæ¥ä¸‹æ¥ä¾¿æ˜¯è°ƒç”¨transactNativeæ–¹æ³•ï¼Œè¿™æ˜¯ä¸€ä¸ªnativeæ–¹æ³•ï¼Œå®ç°åœ¨frameworks/base/core/jni/android_util_Binder.cppä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; if (dataObj == NULL) &#123; jniThrowNullPointerException(env, NULL); return JNI_FALSE; &#125; Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) &#123; return JNI_FALSE; &#125; Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL &amp;&amp; replyObj != NULL) &#123; return JNI_FALSE; &#125; IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); if (target == NULL) &#123; jniThrowException(env, \"java/lang/IllegalStateException\", \"Binder has been finalized!\"); return JNI_FALSE; &#125; //log ... status_t err = target-&gt;transact(code, *data, reply, flags); //log ... if (err == NO_ERROR) &#123; return JNI_TRUE; &#125; else if (err == UNKNOWN_TRANSACTION) &#123; return JNI_FALSE; &#125; signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize()); return JNI_FALSE;&#125; è¿™é‡Œé¦–å…ˆæ˜¯è·å¾—nativeå±‚å¯¹åº”çš„Parcelå¹¶æ‰§è¡Œåˆ¤æ–­ï¼ŒParcelå®é™…ä¸ŠåŠŸèƒ½æ˜¯åœ¨nativeä¸­å®ç°çš„ï¼Œjavaä¸­çš„Parcelç±»ä½¿ç”¨mNativePtræˆå‘˜å˜é‡ä¿å­˜äº†å…¶å¯¹åº”nativeä¸­çš„Parcelçš„æŒ‡é’ˆ ç„¶åè°ƒç”¨getBPNativeDataå‡½æ•°è·å¾—BinderProxyåœ¨nativeä¸­å¯¹åº”çš„BinderProxyNativeDataï¼Œå†é€šè¿‡é‡Œé¢çš„mObjectåŸŸæˆå‘˜å˜é‡å¾—åˆ°å…¶å¯¹åº”çš„BpBinderï¼Œè¿™ä¸ªå‡½æ•°åœ¨ä¹‹å‰åˆ†æjavaObjectForIBinderçš„æ—¶å€™å·²ç»å‡ºç°è¿‡äº† BpBinder.transactä¹‹åä¾¿æ˜¯è°ƒç”¨BpBinderçš„transactå‡½æ•°äº† 12345678910111213141516status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // Once a binder has died, it will never come back to life. //åˆ¤æ–­binderæœåŠ¡æ˜¯å¦å­˜æ´» if (mAlive) &#123; ... status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; è¿™é‡Œæœ‰ä¸€ä¸ªAliveåˆ¤æ–­ï¼Œå¯ä»¥é¿å…å¯¹ä¸€ä¸ªå·²ç»æ­»äº¡çš„binderæœåŠ¡å†å‘èµ·äº‹åŠ¡ï¼Œæµªè´¹èµ„æºï¼Œé™¤æ­¤ä¹‹å¤–ä¾¿æ˜¯è°ƒç”¨IPCThreadStateçš„transactå‡½æ•°äº† IPCThreadStateè·¯å¾„ï¼šframeworks/native/libs/binder/IPCThreadState.cpp è¿˜è®°å¾—æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ProcessStateå—ï¼ŸIPCThreadStateå’Œå®ƒå¾ˆåƒï¼ŒProcessStateè´Ÿè´£æ‰“å¼€binderé©±åŠ¨å¹¶è¿›è¡Œmmapæ˜ å°„ï¼Œè€ŒIPCThreadStateåˆ™æ˜¯è´Ÿè´£ä¸binderé©±åŠ¨è¿›è¡Œå…·ä½“çš„äº¤äº’ IPCThreadStateä¹Ÿæœ‰ä¸€ä¸ªselfå‡½æ•°ï¼Œä¸ProcessStateçš„selfä¸åŒçš„æ˜¯ï¼ŒProcessStateæ˜¯è¿›ç¨‹å•ä¾‹ï¼Œè€ŒIPCThreadStateæ˜¯çº¿ç¨‹å•ä¾‹ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å®ƒæ˜¯æ€ä¹ˆå®ç°çš„ 1234567891011121314151617181920212223242526272829303132333435363738IPCThreadState* IPCThreadState::self()&#123; //ä¸æ˜¯åˆæ¬¡è°ƒç”¨çš„æƒ…å†µ if (gHaveTLS.load(std::memory_order_acquire)) &#123;restart: //åˆæ¬¡è°ƒç”¨ï¼Œç”Ÿæˆçº¿ç¨‹ç§æœ‰å˜é‡keyå const pthread_key_t k = gTLS; //å…ˆä»çº¿ç¨‹æœ¬åœ°å‚¨å­˜ç©ºé—´ä¸­å°è¯•è·å–å€¼ IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; //æ²¡æœ‰çš„è¯å°±å®ä¾‹åŒ–ä¸€ä¸ª return new IPCThreadState; &#125; //IPCThreadState shutdownåä¸èƒ½å†è·å– if (gShutdown.load(std::memory_order_relaxed)) &#123; ALOGW(\"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\\n\"); return nullptr; &#125; //é¦–æ¬¡è·å–æ—¶gHaveTLSä¸ºfalseï¼Œä¼šå…ˆèµ°è¿™é‡Œ pthread_mutex_lock(&amp;gTLSMutex); if (!gHaveTLS.load(std::memory_order_relaxed)) &#123; //åˆ›å»ºä¸€ä¸ªkeyï¼Œä½œä¸ºå­˜æ”¾çº¿ç¨‹æœ¬åœ°å˜é‡çš„key int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor); if (key_create_value != 0) &#123; pthread_mutex_unlock(&amp;gTLSMutex); ALOGW(\"IPCThreadState::self() unable to create TLS key, expect a crash: %s\\n\", strerror(key_create_value)); return nullptr; &#125; //åˆ›å»ºå®Œæ¯•ï¼ŒgHaveTLSç½®ä¸ºtrue gHaveTLS.store(true, std::memory_order_release); &#125; pthread_mutex_unlock(&amp;gTLSMutex); //å›åˆ°gHaveTLSä¸ºtrueçš„case goto restart;&#125; gHaveTLSæ˜¯ä¸€ä¸ªåŸå­ç±»å‹çš„boolå€¼ï¼Œå®ƒåœ¨å­˜å–è¿‡ç¨‹ä¸­éœ€è¦æŒ‡å®šå†…å­˜åºstd::memory_order_xxxï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ç›´æ¥å¿½ç•¥æ‰ï¼ŒæŠŠå®ƒå½“æˆä¸€ä¸ªçº¯ç²¹çš„boolå€¼å°±å¥½äº† åœ¨è¿™é‡Œï¼ŒTLSçš„å…¨ç§°ä¸ºThread Local Storageï¼Œè¡¨ç¤ºçº¿ç¨‹æœ¬åœ°å‚¨å­˜ç©ºé—´ï¼Œå’Œjavaä¸­çš„ThreadLocalå…¶å®æ˜¯ä¸€ä¸ªä½œç”¨ å½“ä¸€ä¸ªçº¿ç¨‹åˆæ¬¡è·å–IPCThreadStateçš„æ—¶å€™ï¼Œä¼šå…ˆèµ°åˆ°gHaveTLSä¸ºfalseçš„caseï¼Œæ­¤æ—¶ç¨‹åºä¼šåˆ›å»ºä¸€ä¸ªkeyï¼Œä½œä¸ºå­˜æ”¾çº¿ç¨‹æœ¬åœ°å˜é‡çš„keyï¼Œåˆ›å»ºæˆåŠŸåå°†gHaveTLSç½®ä¸ºtrueï¼Œç„¶ågotoåˆ°gHaveTLSä¸ºtrueçš„caseï¼Œæ­¤æ—¶çº¿ç¨‹æœ¬åœ°å‚¨å­˜ç©ºé—´ä¸­æš‚æ—¶è¿˜æ˜¯æ²¡æœ‰æ•°æ®çš„ï¼Œæ‰€ä»¥ä¼šnewä¸€ä¸ªIPCThreadStateå‡ºæ¥ï¼Œåœ¨IPCThreadStateçš„æ„é€ å‡½æ•°ä¸­ï¼Œä¼šå°†è‡ªå·±ä¿å­˜åˆ°çº¿ç¨‹æœ¬åœ°å‚¨å­˜ç©ºé—´ä¸­ï¼Œè¿™æ ·ï¼Œå½“çº¿ç¨‹ç¬¬äºŒæ¬¡å†è·å–IPCThreadStateçš„æ—¶å€™ï¼Œä¾¿ä¼šç›´æ¥èµ°åˆ°pthread_getspecificè¿™é‡Œè·å–å¹¶è¿”å› 12345678910111213141516IPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mServingStackPointer(nullptr), mServingStackPointerGuard(nullptr), mWorkSource(kUnsetWorkSource), mPropagateWorkSource(false), mIsLooper(false), mIsFlushing(false), mStrictModePolicy(0), mLastTransactionBinderFlags(0), mCallRestriction(mProcess-&gt;mCallRestriction) &#123; pthread_setspecific(gTLS, this); clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256);&#125; æˆ‘ä»¬é€šè¿‡æ„é€ å‡½æ•°å¯ä»¥å‘ç°ï¼Œå®ƒè°ƒç”¨äº†pthread_setspecificå‡½æ•°å°†è‡ªèº«ä¿å­˜åœ¨äº†çº¿ç¨‹æœ¬åœ°å‚¨å­˜ç©ºé—´ä¸­ IPCThreadStateä¸­ï¼Œæˆå‘˜å˜é‡mInç”¨äºæ¥æ”¶æ¥è‡ªbinderè®¾å¤‡çš„æ•°æ®ï¼ŒmOutç”¨äºå‚¨å­˜å‘å¾€binderè®¾å¤‡çš„æ•°æ®ï¼Œä»–ä»¬çš„é»˜è®¤å®¹é‡éƒ½ä¸º256å­—èŠ‚ transactæˆ‘ä»¬æ¥ç€çœ‹å®ƒçš„transactå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; LOG_ALWAYS_FATAL_IF(data.isForRpc(), \"Parcel constructed for RPC, but being used with binder.\"); status_t err; flags |= TF_ACCEPT_FDS; //log ... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; //binderäº‹åŠ¡ä¸ä¸ºTF_ONE_WAY //å½“çº¿ç¨‹é™åˆ¶binderäº‹åŠ¡ä¸ä¸ºTF_ONE_WAYæ—¶ if (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123; if (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123; //è¿™ä¸ªé™åˆ¶åªæ˜¯logè®°å½• ALOGE(\"Process making non-oneway call (code: %u) but is restricted.\", code); CallStack::logStack(\"non-oneway call\", CallStack::getCurrent(10).get(), ANDROID_LOG_ERROR); &#125; else /* FATAL_IF_NOT_ONEWAY */ &#123; //è¿™ä¸ªé™åˆ¶ä¼šç»ˆæ­¢çº¿ç¨‹ LOG_ALWAYS_FATAL(\"Process may not make non-oneway calls (code: %u).\", code); &#125; &#125; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; //log ... &#125; else &#123; err = waitForResponse(nullptr, nullptr); &#125; return err;&#125; è¿™ä¸ªå‡½æ•°çš„é‡ç‚¹åœ¨äºwriteTransactionDataå’ŒwaitForResponseï¼Œæˆ‘ä»¬ä¾æ¬¡åˆ†æ writeTransactionData1234567891011121314151617181920212223242526272829303132333435363738394041status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ //ç›®æ ‡binderå¥æŸ„å€¼ï¼ŒServiceManagerä¸º0 tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; //æ•°æ®å¤§å° tr.data_size = data.ipcDataSize(); //æ•°æ®åŒºèµ·å§‹åœ°å€ tr.data.ptr.buffer = data.ipcData(); //ä¼ é€’çš„åç§»æ•°ç»„å¤§å° tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); //åç§»æ•°ç»„çš„èµ·å§‹åœ°å€ tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; //è¿™é‡Œä¸ºBC_TRANSACTION mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; åœ¨åˆ†æè¿™ä¸ªå‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå›å¿†ä¸€ä¸‹åœ¨å‰é¢binderé©±åŠ¨ç« èŠ‚æˆ‘ä»¬æ‰€å­¦ä¹ çš„binderç»“æ„å’Œé€šä¿¡è¿‡ç¨‹ï¼šAndroidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰ binder_tansactioné¦–å…ˆä¼šè¯»å–ä¸€ä¸ªè¯·æ±‚ç cmdï¼Œå½“binderè¯·æ±‚ç ä¸ºBC_TRANSACTION/BC_REPLYçš„æ—¶å€™ï¼Œbinderé©±åŠ¨æ‰€æ¥æ”¶çš„å‚æ•°ä¸ºbinder_transaction_dataç»“æ„ä½“ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å°†binderè¯·æ±‚ç ï¼ˆè¿™é‡Œä¸ºBC_TRANSACTIONï¼‰å’Œbinder_transaction_dataç»“æ„ä½“ä¾æ¬¡å†™å…¥åˆ°mOutä¸­ï¼Œä¸ºä¹‹åbinder_tansactionåšå‡†å¤‡ waitForResponseæ•°æ®å‡†å¤‡å¥½åï¼Œæ¥ç€ä¾¿æ¥åˆ°äº†waitForResponseå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; \"Processing waitForResponse Command: \" &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; switch (cmd) &#123; case BR_ONEWAY_SPAM_SUSPECT: ... case BR_TRANSACTION_COMPLETE: //å½“TF_ONE_WAYæ¨¡å¼ä¸‹æ”¶åˆ°BR_TRANSACTION_COMPLETEç›´æ¥è¿”å›ï¼Œæœ¬æ¬¡binderé€šä¿¡ç»“æŸ if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: ... case BR_FAILED_REPLY: ... case BR_FROZEN_REPLY: ... case BR_ACQUIRE_RESULT: ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); //å¤±è´¥ç›´æ¥è¿”å› if (err != NO_ERROR) goto finish; if (reply) &#123; //å®¢æˆ·ç«¯éœ€è¦æ¥æ”¶replay if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //æ­£å¸¸replyå†…å®¹ reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer /*é‡Šæ”¾ç¼“å†²åŒº*/); &#125; else &#123; //å†…å®¹åªæ˜¯ä¸€ä¸ª32ä½çš„çŠ¶æ€ç  //æ¥æ”¶çŠ¶æ€ç  err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); //é‡Šæ”¾ç¼“å†²åŒº freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; //å®¢æˆ·ç«¯ä¸éœ€è¦æ¥æ”¶replay //é‡Šæ”¾ç¼“å†²åŒº freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; default: //è¿™é‡Œæ˜¯binderæœåŠ¡ç«¯éƒ¨åˆ†çš„å¤„ç†ï¼Œç°åœ¨ä¸éœ€è¦å…³æ³¨ err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; logExtendedError(); &#125; return err;&#125; è¿™é‡Œæœ‰ä¸€ä¸ªå¾ªç¯ï¼Œæ­£å¦‚å‡½æ•°åæ‰€æè¿°ï¼Œä¼šä¸€ç›´ç­‰å¾…åˆ°ä¸€æ•´æ¡binderäº‹åŠ¡é“¾ç»“æŸè¿”å›åæ‰ä¼šé€€å‡ºè¿™ä¸ªå¾ªç¯ï¼Œåœ¨è¿™ä¸ªå¾ªç¯çš„å¼€å¤´ï¼Œä¾¿æ˜¯talkWithDriveræ–¹æ³• talkWithDriver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; //æ£€æŸ¥æ‰“å¼€çš„binderè®¾å¤‡çš„fd if (mProcess-&gt;mDriverFD &lt; 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? //dataPosition &gt;= dataSizeè¯´æ˜ä¸Šä¸€æ¬¡è¯»å–åˆ°çš„æ•°æ®å·²ç»æ¶ˆè´¹å®Œ const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don't want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. //éœ€è¦å†™çš„æ•°æ®å¤§å°ï¼Œè¿™é‡Œçš„doReceiveé»˜è®¤ä¸ºtrueï¼Œå¦‚æœä¸Šä¸€æ¬¡çš„æ•°æ®è¿˜æ²¡è¯»å®Œï¼Œåˆ™ä¸ä¼šå†™å…¥ä»»ä½•å†…å®¹ const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; //å°†read_sizeè®¾ç½®ä¸ºè¯»ç¼“å­˜å¯ç”¨å®¹é‡ bwr.read_size = mIn.dataCapacity(); //è®¾ç½®è¯»ç¼“å­˜èµ·å§‹åœ°å€ bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // Return immediately if there is nothing to do. //æ²¡æœ‰è¦è¯»å†™çš„æ•°æ®å°±ç›´æ¥è¿”å› if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; //è°ƒç”¨binderé©±åŠ¨çš„ioctl if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno; if (mProcess-&gt;mDriverFD &lt; 0) &#123; err = -EBADF; &#125; &#125; while (err == -EINTR); if (err &gt;= NO_ERROR) &#123; //å†™æ•°æ®è¢«æ¶ˆè´¹äº† if (bwr.write_consumed &gt; 0) &#123; //å†™æ•°æ®æ²¡æœ‰è¢«æ¶ˆè´¹å®Œ if (bwr.write_consumed &lt; mOut.dataSize()) LOG_ALWAYS_FATAL(\"Driver did not consume write buffer. \" \"err: %s consumed: %zu of %zu\", statusToString(err).c_str(), (size_t)bwr.write_consumed, mOut.dataSize()); else &#123; //å†™æ•°æ®æ¶ˆè´¹å®Œäº†ï¼Œå°†æ•°æ®å¤§å°è®¾ç½®ä¸º0ï¼Œè¿™æ ·ä¸‹æ¬¡å°±ä¸ä¼šå†å†™æ•°æ®äº† mOut.setDataSize(0); processPostWriteDerefs(); &#125; &#125; //è¯»åˆ°äº†æ•°æ® if (bwr.read_consumed &gt; 0) &#123; //è®¾ç½®æ•°æ®å¤§å°åŠæ•°æ®æŒ‡é’ˆåç§»ï¼Œè¿™æ ·åé¢å°±å¯ä»¥ä»ä¸­è¯»å–å‡ºæ¥æ•°æ®äº† mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; return NO_ERROR; &#125; return err;&#125; è¿™é‡Œçš„binder_write_readä¹Ÿæ˜¯ä¸€ä¸ªæˆ‘ä»¬ç†Ÿæ‚‰çš„ç»“æ„ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰ä¸­äº†è§£è¿‡ï¼Œå…³äºbinderé€šä¿¡çš„ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦ç»“åˆç€binderé©±åŠ¨ä¸€èµ·çœ‹æ‰èƒ½ç†è§£ åœ¨binderé©±åŠ¨å±‚ä¸­ï¼Œbinder_ioctl_write_readå‡½æ•°ä¼šä»ç”¨æˆ·ç©ºé—´è¯»å–ä¸€ä¸ªbinder_write_readç»“æ„ï¼Œè¿™ä¸ªç»“æ„ä½“ä¸»è¦æè¿°äº†æ•°æ®ä¼ è¾“çš„å¤§å°å’Œä½ç½®ä»¥åŠæ¶ˆè´¹æƒ…å†µï¼ˆå·²è¯»/å†™æ•°æ®å¤§å°ï¼‰ï¼Œè¿™ä¹ˆçœ‹æ¥ï¼ŒtalkWithDriverå‡½æ•°çš„ç»“æ„å°±å¾ˆæ¸…æ™°äº†ï¼š åˆ›å»ºå‡ºbinder_write_readç»“æ„ï¼Œæ ¹æ®ä¹‹å‰çš„è¯»å–æƒ…å†µï¼Œå†³å®šæ˜¯å¦è¯»å†™æ•°æ®ï¼Œè®¾ç½®å†™æ•°æ®å†…å®¹å’Œå¤§å°ï¼Œè®¾ç½®è¯»æ•°æ®çš„ç©ºé—´å’Œå®¹é‡ è°ƒç”¨binderé©±åŠ¨çš„ioctl é‡ç½®å†™ç¼“å­˜ï¼Œæ ¹æ®ioctlçš„ç»“æœè®¾ç½®è¯»ç¼“å­˜ è¿™ä¹‹åï¼ŒwaitForResponseå‡½æ•°å°±å¯ä»¥ä»è¯»ç¼“å­˜mInä¸­è¯»åˆ°æ•°æ®äº†ï¼Œæˆ‘ä»¬å›åˆ°è¿™ä¸ªå‡½æ•°ä¸­ï¼Œå‘ç°å®ƒé¦–å…ˆä»è¯»ç¼“å­˜ä¸­è¯»å–äº†ä¸€ä¸ªbinderå“åº”ç ï¼Œç„¶åæ ¹æ®è¿™ä¸ªå“åº”ç å†å¤„ç†æ¥ä¸‹æ¥çš„å·¥ä½œ å¤„ç†Replyåœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå›é¡¾ä¸€ä¸‹ä¸€æ¬¡binder_tansactionçš„æ•´ä¸ªè¿‡ç¨‹ï¼Œæ ¹æ®äº‹åŠ¡ç±»å‹ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š TF_ONE_WAY é TF_ONE_WAY æˆ‘ä»¬å…ˆå¯¹ç…§ç€çœ‹TF_ONE_WAYçš„æƒ…å†µ 123456789101112status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; switch (cmd) &#123; ... case BR_TRANSACTION_COMPLETE: //å½“TF_ONE_WAYæ¨¡å¼ä¸‹æ”¶åˆ°BR_TRANSACTION_COMPLETEç›´æ¥è¿”å›ï¼Œæœ¬æ¬¡binderé€šä¿¡ç»“æŸ if (!reply &amp;&amp; !acquireResult) goto finish; break; ... &#125; &#125;&#125; å¯¹äºTF_ONE_WAYæ¨¡å¼æ¥è¯´ï¼Œå®¢æˆ·ç«¯åœ¨æ”¶åˆ°BR_TRANSACTION_COMPLETEå“åº”ç ååˆ™è¿”å›ï¼Œä¸ä¼šå†ç­‰å¾…BR_REPLY è€Œå¯¹äºéTF_ONE_WAYæ¨¡å¼æ¥è¯´ï¼Œå®¢æˆ·ç«¯ä¸ä»…ä¼šæ”¶åˆ°BR_TRANSACTION_COMPLETEå“åº”ç ï¼Œä¹‹åè¿˜ä¼šé˜»å¡ç­‰å¾…binderé©±åŠ¨ç»™å®ƒå‘æ¥BR_REPLYå“åº”ç ï¼Œè¿™ä¹‹åä¸€æ¬¡binder_transactionæ‰ç®—å®Œæˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; switch (cmd) &#123; ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); //å¤±è´¥ç›´æ¥è¿”å› if (err != NO_ERROR) goto finish; if (reply) &#123; //å®¢æˆ·ç«¯éœ€è¦æ¥æ”¶replay if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //æ­£å¸¸replyå†…å®¹ reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer /*é‡Šæ”¾ç¼“å†²åŒº*/); &#125; else &#123; //å†…å®¹åªæ˜¯ä¸€ä¸ª32ä½çš„çŠ¶æ€ç  //æ¥æ”¶çŠ¶æ€ç  err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); //é‡Šæ”¾ç¼“å†²åŒº freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; //å®¢æˆ·ç«¯ä¸éœ€è¦æ¥æ”¶replay //é‡Šæ”¾ç¼“å†²åŒº freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; ... &#125; &#125;&#125; ä¸€èˆ¬æ¥è¯´ï¼ŒéTF_ONE_WAYæ¨¡å¼è‚¯å®šæ˜¯éœ€è¦ä¸€ä¸ªreplyæ¥æ¥æ”¶çš„ï¼Œå³reply != nullï¼Œæ­¤æ—¶æˆ‘ä»¬æ¥çœ‹çœ‹æ¥æ”¶æ­£å¸¸replyçš„è¿‡ç¨‹ï¼ˆæ¥æ”¶32ä½çŠ¶æ€ç æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç›´æ¥ä»è¯»ç¼“å†²åŒºä¸­å¼ºåˆ¶ç±»å‹è½¬æ¢å‡ºä¸€ä¸ª32ä½çš„codeå°±å®Œäº‹äº†ï¼‰ è¿™é‡Œæˆ‘ä»¬å°±éœ€è¦çœ‹ä¸€ä¸‹Parcelçš„ipcSetDataReferenceå‡½æ•°äº† 12345678910111213141516171819202122232425262728293031323334353637383940void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc) &#123; // this code uses 'mOwner == nullptr' to understand whether it owns memory LOG_ALWAYS_FATAL_IF(relFunc == nullptr, \"must provide cleanup function\"); //å…ˆæ¸…ç†é‡ç½®ä¸€ä¸‹æ•°æ®å’ŒçŠ¶æ€ freeData(); auto* kernelFields = maybeKernelFields(); LOG_ALWAYS_FATAL_IF(kernelFields == nullptr); // guaranteed by freeData. mData = const_cast&lt;uint8_t*&gt;(data); mDataSize = mDataCapacity = dataSize; kernelFields-&gt;mObjects = const_cast&lt;binder_size_t*&gt;(objects); kernelFields-&gt;mObjectsSize = kernelFields-&gt;mObjectsCapacity = objectsCount; mOwner = relFunc; //æ£€æŸ¥æ•°æ® binder_size_t minOffset = 0; for (size_t i = 0; i &lt; kernelFields-&gt;mObjectsSize; i++) &#123; binder_size_t offset = kernelFields-&gt;mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(\"%s: bad object offset %\" PRIu64 \" &lt; %\" PRIu64 \"\\n\", __func__, (uint64_t)offset, (uint64_t)minOffset); kernelFields-&gt;mObjectsSize = 0; break; &#125; const flat_binder_object* flat = reinterpret_cast&lt;const flat_binder_object*&gt;(mData + offset); uint32_t type = flat-&gt;hdr.type; //binderç±»å‹å‡ºç°å¼‚å¸¸ if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE || type == BINDER_TYPE_FD)) &#123; ... kernelFields-&gt;mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; å…¶å®è¿™ä¸ªå‡½æ•°ä¹Ÿä¸å¤æ‚ï¼Œæˆ‘ä»¬çŸ¥é“binder_mmapåšåˆ°äº†ä¸€æ¬¡æ‹·è´ï¼Œå°†æ•°æ®æ‹·è´åˆ°äº†å†…æ ¸ç‰©ç†å†…å­˜ä¸­ï¼Œç„¶åå°†å…¶ä¸ç”¨æˆ·ç©ºé—´è™šæ‹Ÿå†…å­˜åšäº†æ˜ å°„ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°æ­¤æ—¶åªéœ€è¦å°†æ•°æ®çš„åœ°å€ï¼Œå¤§å°ç­‰ç­‰æ— è„‘èµ‹å€¼è¿›å»ï¼Œå®¢æˆ·ç«¯åç»­ä¾¿å¯ä»¥ç”¨Parcelæä¾›çš„å‡½æ•°æ–¹ä¾¿çš„ä»ä¸­è¯»å–æ•°æ®äº† freeBufferæœ€åæˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸‹freeBufferè¿™ä¸ªé‡Šæ”¾ç¼“å†²åŒºçš„æ–¹æ³•ï¼Œ 123456789101112void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data, size_t /*dataSize*/, const binder_size_t* /*objects*/, size_t /*objectsSize*/)&#123; ... if (parcel != nullptr) parcel-&gt;closeFileDescriptors(); IPCThreadState* state = self(); state-&gt;mOut.writeInt32(BC_FREE_BUFFER); state-&gt;mOut.writePointer((uintptr_t)data); state-&gt;flushIfNeeded();&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå‘binderé©±åŠ¨å‘é€äº†ä¸€ä¸ªBC_FREE_BUFFERè¯·æ±‚ï¼Œç„¶åbinderé©±åŠ¨ä¼šè´Ÿè´£å›æ”¶è¿™å—ç¼“å†²åŒºå†…å­˜ æˆ‘ä»¬åœ¨Parcel::ipcSetDataReferenceå‡½æ•°ä¸­å¯ä»¥å‘ç°ï¼Œå®ƒå°†freeBufferå‡½æ•°æŒ‡é’ˆèµ‹å€¼ç»™äº†mOwnerï¼Œç­‰åˆ°ä»€ä¹ˆæ—¶å€™ä¸éœ€è¦è¿™ä¸ªParceläº†ï¼Œä¾¿ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°è¿›è¡Œç¼“å†²åŒºå†…å­˜å›æ”¶ ç»“æŸåˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å®¢æˆ·ç«¯ä¸binderé©±åŠ¨æ²Ÿé€šäº¤äº’çš„åˆ†æå°±ç»“æŸäº†ï¼Œç›¸æ¯”binderé©±åŠ¨è€Œè¨€ï¼Œframeworkå±‚çš„binderå°±å¥½ç†è§£å¤šäº†ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬ä¼šä»æœåŠ¡ç«¯çš„è§’åº¦æ¥çœ‹ï¼Œå®ƒæ˜¯æ€ä¹ˆä»binderé©±åŠ¨æ¥æ”¶å¹¶å¤„ç†å®¢æˆ·ç«¯çš„è¯·æ±‚çš„","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Jetpack Composeå…¥é—¨","slug":"android/jetpack/compose/JetpackComposeå…¥é—¨","date":"2022-04-07T08:54:00.000Z","updated":"2022-11-13T09:55:54.359Z","comments":true,"path":"2022/04/07/android/jetpack/compose/JetpackComposeå…¥é—¨/","link":"","permalink":"http://yoursite.com/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/","excerpt":"","text":"ç®€ä»‹Jetpack Composeæ˜¯ç”¨äºæ„å»ºåŸç”ŸAndroidç•Œé¢çš„æ–°å·¥å…·åŒ…ã€‚å®ƒæ˜¯ä¸€ç§å£°æ˜å¼çš„UIå¸ƒå±€ï¼Œå…¶å®˜æ–¹å£°ç§°å¯ç®€åŒ–å¹¶åŠ å¿«Androidä¸Šçš„ç•Œé¢å¼€å‘ï¼Œä½¿ç”¨æ›´å°‘çš„ä»£ç ã€å¼ºå¤§çš„å·¥å…·å’Œç›´è§‚çš„Kotlin APIï¼Œå¿«é€Ÿè®©åº”ç”¨ç”ŸåŠ¨è€Œç²¾å½©ã€‚ å®˜ç½‘ï¼šhttps://developer.android.com/jetpack/compose?hl=zh-cn æˆ‘è¿™é‡Œä¹Ÿå†™äº†ä¸€ä¸ªComposeçš„Demoï¼Œå¯ä»¥å¯¹ç…§ç€çœ‹ï¼šhttps://github.com/dreamgyf/ComposeDemo è¿™ä¸ªDemoå®ç°äº†ï¼š Composeæ›¿ä»£ä¼ ç»Ÿå¸ƒå±€ ç½‘æ ¼åˆ—è¡¨æ•ˆæœï¼Œç±»ä¼¼äºä¼ ç»Ÿå¸ƒå±€ä¸­çš„RecyclerViewé…åˆGridLayoutManager åœ¨ä¼ ç»ŸViewä¸­ä½¿ç”¨Compose åœ¨Composeä¸­ä½¿ç”¨ä¼ ç»ŸView è‡ªå®šä¹‰å¸ƒå±€ å‰ç½®å·¥ä½œä½¿ç”¨Jetpack Composeéœ€è¦å…ˆå¼•å…¥ä¸€äº›ä¾èµ–ï¼š 1234567891011dependencies &#123; implementation 'androidx.core:core-ktx:1.7.0' implementation \"androidx.compose.ui:ui:$compose_version\" implementation \"androidx.compose.material:material:$compose_version\" implementation \"androidx.compose.ui:ui-tooling-preview:$compose_version\" implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1' implementation 'androidx.activity:activity-compose:1.3.1' debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\" //ç½‘ç»œå›¾ç‰‡åŠ è½½ä¸‰æ–¹åº“ implementation \"io.coil-kt:coil-compose:1.4.0\"&#125; å¯ç»„åˆå‡½æ•°Jetpack Composeæ˜¯å›´ç»•ç€å¯ç»„åˆå‡½æ•°æ„å»ºèµ·æ¥çš„ï¼Œè¿™äº›å‡½æ•°ä»¥ç¨‹åºåŒ–æ–¹å¼å®šä¹‰åº”ç”¨çš„ç•Œé¢ï¼Œåªéœ€æè¿°åº”ç”¨ç•Œé¢çš„å¤–è§‚å¹¶æä¾›æ•°æ®ä¾èµ–é¡¹ï¼Œè€Œä¸å¿…å…³æ³¨ç•Œé¢çš„æ„å»ºè¿‡ç¨‹ã€‚æ­¤ç±»å‡½æ•°æœ‰å‡ ä¸ªè¦ç‚¹ï¼š æ‰€æœ‰å¯ç»„åˆå‡½æ•°å¿…é¡»ä½¿ç”¨@Composableæ³¨è§£ä¿®é¥° å¯ç»„åˆå‡½æ•°å¯ä»¥åƒæ­£å¸¸å‡½æ•°ä¸€æ ·æ¥å—å‚æ•° 1234@Composablefun Demo(name: String) &#123; Text(text = \"Hello, $&#123;name&#125;!\")&#125; å¯ç»„åˆå‡½æ•°å†…éƒ¨å¯ä»¥ä¹¦å†™æ­£å¸¸ä»£ç ï¼ˆè­¬å¦‚å¯ä»¥é€šè¿‡if elseæ§åˆ¶æ˜¾ç¤ºçš„æ§ä»¶ï¼‰ 12345678910@Composablefun Demo(showPic: Boolean) &#123; if (showPic) &#123; Image( painter = painterResource(id = R.drawable.demo), contentDescription = null ) &#125; Text(text = \"Hello, compose!\")&#125; å•ä½Androidå¸¸ç”¨çš„å•ä½dpï¼Œspç­‰ï¼Œåœ¨Composeä¸­ä»¥ç±»çš„å½¢å¼è¢«å®šä¹‰ï¼Œä½¿ç”¨çš„æ–¹å¼ä¹Ÿå¾ˆç®€å•ï¼ŒComposeå€ŸåŠ©äº†kotlinçš„æ‰©å±•å±æ€§ï¼Œæ‰©å±•äº†Intï¼ŒDoubleï¼ŒFloatä¸‰ä¸ªåŸºç¡€ç±»ï¼Œä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š 1234//dp1.dp; 2.3f.dp; 4.5.dp//sp1.sp; 2.3f.sp; 4.5.sp èµ„æºå¦‚ä½•åœ¨Composeä¸­ä½¿ç”¨èµ„æºå‘¢ï¼Œå¯ä»¥é€šè¿‡xxxResourceæ–¹æ³• 12345678910//å›¾ç‰‡èµ„æºfun painterResource(@DrawableRes id: Int): Painter//å°ºå¯¸èµ„æºfun dimensionResource(@DimenRes id: Int): Dp//é¢œè‰²èµ„æºfun colorResource(@ColorRes id: Int): Color//å­—ç¬¦ä¸²èµ„æºfun stringResource(@StringRes id: Int): String//å­—ä½“èµ„æºfun fontResource(fontFamily: FontFamily): Typeface ModifierModifieræ˜¯Composeä¸­çš„å¸ƒå±€ä¿®é¥°ç¬¦ï¼Œå®ƒæ§åˆ¶äº†å¸ƒå±€çš„å¤§å°ï¼Œpaddingï¼Œå¯¹é½ï¼ŒèƒŒæ™¯ï¼Œè¾¹æ¡†ï¼Œè£åˆ‡ï¼Œç‚¹å‡»ç­‰å±æ€§ï¼Œå‡ ä¹æ‰€æœ‰çš„Composeå¸ƒå±€éƒ½éœ€æ±‚è¿™é¡¹å‚æ•°ï¼Œæ˜¯Composeå¸ƒå±€ä¸­çš„é‡ä¸­ä¹‹é‡ è¿™é‡Œä»‹ç»ä¸€äº›å¸¸ç”¨çš„åŸºæœ¬å±æ€§ï¼Œæ–‡ä¸­æ²¡åˆ—åˆ°çš„å±æ€§å¯ä»¥å»å®˜ç½‘æŸ¥çœ‹ï¼šhttps://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn å°ºå¯¸ fillMaxWidthå’ŒfillMaxHeightç›¸å½“äºxmlå¸ƒå±€ä¸­çš„match_parent fillMaxSizeç›¸å½“äºåŒæ—¶è®¾ç½®äº†fillMaxWidthå’ŒfillMaxHeight wrapContentWidthå’ŒwrapContentHeightç›¸å½“äºxmlå¸ƒå±€ä¸­çš„wrapContent wrapContentSizeç›¸å½“äºåŒæ—¶è®¾ç½®äº†wrapContentWidthå’ŒwrapContentHeight widthå’Œheightåˆ™æ˜¯è®¾ç½®å›ºå®šå®½é«˜ï¼Œå•ä½ä¸ºDp sizeç›¸å½“äºåŒæ—¶è®¾ç½®äº†widthå’Œheight weightå±æ€§ä»…åœ¨Rowæˆ–Columnçš„å†…éƒ¨ä½œç”¨åŸŸä¸­å¯ä»¥ä½¿ç”¨ï¼Œç›¸å½“äºä¼ ç»ŸLinearLayoutå¸ƒå±€ä¸­çš„weightå±æ€§ paddingpaddingæ–¹æ³•æœ‰å‡ ä¸ªé‡è½½ï¼Œè¿™äº›APIå¾ˆç®€å•ï¼Œçœ‹å‚æ•°å°±å¾ˆå®¹æ˜“èƒ½æ˜ç™½æ„æ€ å¯¹é½alignå±æ€§ï¼Œä½¿æ§ä»¶å¯ä»¥åœ¨çˆ¶å¸ƒå±€ä¸­ä»¥ä¸€ç§æ–¹å¼å¯¹é½ï¼Œç›¸å½“äºxmlå¸ƒå±€ä¸­çš„layout_gravityå±æ€§ã€‚å¦å¤–è¿˜æœ‰alignByä»¥åŠalignByBaselineå±æ€§å¯ä»¥è‡ªè¡Œç ”ç©¶ ç»˜å›¾ backgroundè®¾ç½®èƒŒæ™¯ï¼Œä¸è¿‡ä¸èƒ½è®¾ç½®å›¾ç‰‡ï¼Œå¦‚æœæƒ³ä»¥å›¾ç‰‡ä½œä¸ºèƒŒæ™¯å¯ä»¥ä½¿ç”¨Boxå¸ƒå±€ï¼Œåœ¨åº•éƒ¨å«ä¸€ä¸ªImageæ§ä»¶ alphaè®¾ç½®é€æ˜åº¦ clipè£å‰ªå†…å®¹ï¼Œè¿™ä¸ªåŠŸèƒ½å¾ˆå¼ºå¤§ï¼Œå¯ä»¥ç›´æ¥å°†è§†å›¾è£å‡ºåœ†è§’ï¼Œåœ†å½¢ç­‰å½¢çŠ¶ æ“ä½œ clickableæ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®æ§ä»¶çš„ç‚¹å‡»äº‹ä»¶å›è°ƒ combinedClickableæ–¹æ³•ï¼Œå¯ä»¥è®¾ç½®æ§ä»¶çš„ç‚¹å‡»ã€åŒå‡»ã€é•¿æŒ‰äº‹ä»¶å›è°ƒ selectableæ–¹æ³•ï¼Œå°†æ§ä»¶é…ç½®ä¸ºå¯ç‚¹å‡»ï¼ŒåŒæ—¶å¯ä»¥è®¾ç½®ç‚¹å‡»äº‹ä»¶ æ»šåŠ¨ horizontalScrollï¼šä½¿æ§ä»¶æ”¯æŒæ°´å¹³æ»šåŠ¨ verticalScrollï¼šä½¿æ§ä»¶æ”¯æŒå‚ç›´æ»šåŠ¨ æ³¨æ„äº‹é¡¹åœ¨Modifierä¸­è®¾ç½®å±æ€§çš„å‰åé¡ºåºæ˜¯å¾ˆé‡è¦çš„ï¼Œè­¬å¦‚æƒ³è¦ä¸€ä¸ªèƒŒæ™¯ä¸ºè“è‰²çš„åœ†è§’å¸ƒå±€ï¼Œéœ€è¦å…ˆè®¾ç½®clipï¼Œå†è®¾ç½®backgroundï¼Œåè¿‡æ¥backgroundä¼šè¶…å‡ºåœ†è§’èŒƒå›´ SpacerComposeä¸­æ²¡æœ‰äº†marginçš„æ¦‚å¿µï¼Œå¯ä»¥ç”¨Spaceræ›¿ä»£ï¼ŒSpacerä¸ºç•™ç™½çš„æ„æ€ï¼Œä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆç®€å• 12//æ°´å¹³é—´éš”8dpSpacer(modifier = Modifier.width(8.dp)) åŸºç¡€å¸ƒå±€Row &amp; Columnè¿™æ˜¯ä¸¤ä¸ªåŸºæœ¬å¸ƒå±€ç»„ä»¶ï¼Œå…¶ä¸­Rowä¸ºæ°´å¹³å¸ƒå±€ï¼ŒColumnä¸ºå‚ç›´å¸ƒå±€ï¼Œä»–ä»¬ä¿©æ¥å—çš„å‚æ•°ç›¸ä¼¼ï¼Œå…¶ä¸­ä¸¤ä¸ªå‚æ•°ä¸ºhorizontalArrangementå’ŒverticalAlignmentï¼Œä»–ä»¬ä¸€ä¸ªè¡¨ç¤ºæ°´å¹³å¸ƒå±€æ–¹å¼ï¼Œä¸€ä¸ªè¡¨ç¤ºå‚ç›´å¸ƒå±€æ–¹å¼ï¼Œä»–ä»¬é»˜è®¤å€¼ä¸ºSTARTå’ŒTOPï¼Œè¿™ä¸¤ä¸ªå‚æ•°ç”¨èµ·æ¥å°±å’Œä¼ ç»Ÿå¸ƒå±€çš„gravityå‚æ•°ä¸€æ · BoxBoxä¹Ÿæ˜¯ä¸€ç§åŸºæœ¬å¸ƒå±€ç»„ä»¶ï¼ŒBoxå¸ƒå±€ä¸­çš„ç»„ä»¶æ˜¯å¯ä»¥å åŠ çš„ï¼Œç±»ä¼¼ä¼ ç»Ÿå¸ƒå±€ä¸­çš„FrameLayoutï¼Œå¯ä»¥é€šè¿‡contentAlignmentå‚æ•°è°ƒæ•´å åŠ çš„æ–¹å¼ï¼Œå…¶é»˜è®¤å€¼ä¸ºTopStartï¼Œå åŠ åˆ°å·¦ä¸Šè§’ï¼Œè¿™ä¸ªå‚æ•°ä¹Ÿå’ŒFrameLayoutçš„gravityå‚æ•°ä¸€æ · åŸºç¡€æ§ä»¶Textæ–‡æœ¬æ§ä»¶ï¼Œå¯¹åº”ä¼ ç»Ÿæ§ä»¶TextViewï¼Œå®ƒæœ‰ä»¥ä¸‹ä¸€äº›å±æ€§ å±æ€§ è¯´æ˜ text æ–‡æœ¬å†…å®¹ color æ–‡å­—é¢œè‰² fontSize æ–‡å­—å¤§å° fontStyle æ–‡æœ¬æ ·å¼ï¼ˆå¯ä»¥è®¾ç½®æ–œä½“ï¼‰ fontWeight å­—é‡ï¼ˆç²—ä½“ç­‰ï¼‰ fontFamily å­—ä½“ letterSpacing æ–‡å­—é—´è· textAlign æ–‡æœ¬å¯¹é½æ–¹å¼ lineHeight è¡Œé«˜ maxLines æœ€å¤§è¡Œæ•° â€¦ â€¦ Imageå›¾ç‰‡æ§ä»¶ï¼Œå¯¹åº”ä¼ ç»Ÿæ§ä»¶ImageViewï¼Œå®ƒæœ‰ä»¥ä¸‹ä¸€äº›å±æ€§ å±æ€§ è¯´æ˜ painter å›¾ç‰‡å†…å®¹ contentDescription æ— éšœç¢æè¿°ï¼ˆå¯ä¸ºnullï¼‰ alignment å¯¹é½æ–¹å¼ contentScale ç¼©æ”¾æ–¹å¼ï¼ˆå’ŒscaleTypeå±æ€§ç±»ä¼¼ï¼‰ alpha é€æ˜åº¦ â€¦ â€¦ åœ¨å¼€å‘ä¸­ç»å¸¸ä¼šé¢å¯¹ä»ç½‘ç»œä»·å€¼å›¾ç‰‡çš„æƒ…å†µï¼Œè¿™æ—¶å€™å¯ä»¥å€ŸåŠ©ä¸€äº›ç¬¬ä¸‰æ–¹åº“æ¥è§£å†³ï¼Œè¿™é‡Œä»¥coilåº“ä¸ºä¾‹ï¼š å…ˆæ·»åŠ ä¾èµ– 1implementation \"io.coil-kt:coil-compose:1.4.0\" ä½¿ç”¨ 12345678Image( modifier = Modifier .size(68.dp, 68.dp) .clip(RoundedCornerShape(6.dp)), contentScale = ContentScale.Crop, painter = rememberImagePainter(picUrl), //ä½¿ç”¨rememberImagePainteræ–¹æ³•å¡«å…¥å›¾ç‰‡url contentDescription = null) åˆ—è¡¨Composeæœ‰ä¸¤ç§ç»„ä»¶LazyRowå’ŒLazyColumnï¼Œä¸€ç§æ°´å¹³ï¼Œä¸€ç§å‚ç›´ï¼Œå¯¹åº”ç€ä¼ ç»ŸUIä¸­çš„RecyclerViewï¼Œç”¨è¿™äº›ç»„ä»¶å¯ä»¥æ–¹ä¾¿çš„æ„å»ºåˆ—è¡¨è§†å›¾ï¼Œå®ƒä»¬éœ€è¦æä¾›ä¸€ä¸ªLazyListScope.()å—æè¿°åˆ—è¡¨é¡¹å†…å®¹ LazyListScopeçš„DSLæä¾›äº†å¤šç§å‡½æ•°æ¥æè¿°åˆ—è¡¨é¡¹ï¼š 1234567891011121314//ç”¨äºæ·»åŠ å•ä¸ªåˆ—è¡¨é¡¹fun item(key: Any? = null, content: @Composable LazyItemScope.() -&gt; Unit)//ç”¨äºæ·»åŠ å¤šä¸ªåˆ—è¡¨é¡¹fun items( count: Int, key: ((index: Int) -&gt; Any)? = null, itemContent: @Composable LazyItemScope.(index: Int) -&gt; Unit )//ç”¨äºæ·»åŠ å¤šä¸ªåˆ—è¡¨é¡¹fun &lt;T&gt; LazyListScope.items( items: List&lt;T&gt;, noinline key: ((item: T) -&gt; Any)? = null, crossinline itemContent: @Composable LazyItemScope.(item: T) -&gt; Unit) ç¤ºä¾‹ï¼š 1234567891011121314151617181920212223val list = mutableListOf(0, 1, 2, 3, 4)LazyColumn &#123; //å¢åŠ å•ä¸ªåˆ—è¡¨é¡¹ item &#123; Text(text = \"First item\") &#125; //å¢åŠ 5ä¸ªåˆ—è¡¨é¡¹ items(5) &#123; index -&gt; Text(text = \"Item: $index\") &#125; //å¢åŠ 5ä¸ªåˆ—è¡¨é¡¹ items(list) &#123; listItem -&gt; Text(text = \"Item: $listItem\") &#125; //å¢åŠ å•ä¸ªåˆ—è¡¨é¡¹ item &#123; Text(text = \"Last item\") &#125;&#125; å¯ä»¥ä½¿ç”¨contentPaddingä¸ºå†…å®¹æ·»åŠ å†…è¾¹è·ï¼Œä½¿ç”¨verticalArrangementæˆ–horizontalArrangementï¼Œä»¥Arrangement.spacedBy()ä¸ºåˆ—è¡¨é¡¹ä¹‹é—´æ·»åŠ é—´è· çŠ¶æ€åœ¨Composeä¸­ï¼Œæ•°æ®çš„æ›´æ–°å’Œä¼ ç»Ÿå‘½ä»¤å¼UIä¸åŒï¼Œæ˜¯é€šè¿‡ä¸€ç§å¯è§‚å¯Ÿç±»å‹å¯¹è±¡ï¼Œå½“ä¸€ä¸ªå¯è§‚å¯Ÿç±»å‹å¯¹è±¡å‘ç”Ÿæ”¹å˜æ—¶ï¼Œè¿™ä¸ªå¯¹è±¡å¯¹åº”è§‚å¯Ÿçš„éƒ¨åˆ†ä¼šå‘ç”Ÿé‡ç»„ï¼Œä»è€Œè‡ªåŠ¨æ›´æ–°UI å¯è§‚å¯Ÿç±»å‹MutableState&lt;T&gt;é€šå¸¸æ˜¯é€šè¿‡mutableStateOf()å‡½æ•°åˆ›å»ºçš„ï¼Œè¿™ä¸ªå¯¹è±¡çš„valueå‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¯¹åº”UIä¹Ÿä¼šè·Ÿç€éšä¹‹å˜åŒ– 123456789101112131415161718192021222324252627//è¿™é‡Œä½¿ç”¨äº†kotlinçš„byå…³é”®å­—ï¼Œæ˜¯ä¸€ç§ä»£ç†æ¨¡å¼//å¦‚æœä½¿ç”¨ = çš„è¯ï¼Œè¿™ä¸ªå¯¹è±¡çš„ç±»å‹ä¼šå‘ç”Ÿå˜åŒ–ï¼Œéœ€è¦count.valueè¿™æ ·ä½¿ç”¨å®ƒçš„å€¼//var count = mutableStateOf(0)var count by mutableStateOf(0)@Composablefun Demo(count: Int) &#123; Column &#123; Text(text = \"count: $&#123;count&#125;\") Button(onClick = &#123; addCount() &#125;) &#123; Text(text = \"add count\") &#125; &#125;&#125;fun addCount() &#123; //++count.value ++count&#125;@Preview@Composablefun Preview() &#123; //å½“ç‚¹å‡»Buttonæ—¶ï¼Œè§¦å‘ç‚¹å‡»äº‹ä»¶ï¼Œæ›´æ–°å¯è§‚å¯Ÿå¯¹è±¡countï¼Œè§¦å‘UIé‡ç»„ //Demo(count.value) Demo(count)&#125; å…³äºContextåœ¨Composeä¸­å¯ä»¥é€šè¿‡LocalContext.currentè·å¾—å½“å‰Context åœ¨ä¼ ç»ŸViewä¸­ä½¿ç”¨Composeå¯ä»¥åœ¨ä¸€ä¸ªä¼ ç»Ÿå¸ƒå±€xmlä¸­æ’å…¥ä¸€ä¸ªComposeView 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/hello_world\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Hello from XML layout\" /&gt; &lt;!-- æ’å…¥ComposeView --&gt; &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/compose_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; ç„¶ååœ¨ä»£ç ä¸­è®¾ç½®è¿™ä¸ªComposeView 123findViewById&lt;ComposeView&gt;(R.id.compose_view).setContent &#123; Text(\"Hello Compose!\")&#125; åœ¨Composeä¸­ä½¿ç”¨ä¼ ç»ŸViewå¯ä»¥ä½¿ç”¨AndroidViewè¿™ä¸ªcomposableå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªfactoryå‚æ•°ï¼Œè¿™ä¸ªå‚æ•°æ¥å—ä¸€ä¸ªContextï¼Œç”¨äºæ„å»ºä¼ ç»ŸViewï¼Œè¦æ±‚è¿”å›ä¸€ä¸ªç»§æ‰¿è‡ªViewçš„å¯¹è±¡ 123456789101112@Composablefun Demo() &#123; Column &#123; Text(text = \"Compose Text\") AndroidView(factory = &#123; context -&gt; //è¿™é‡Œä¹Ÿå¯ä»¥ä½¿ç”¨LayoutInflaterä»xmlä¸­è§£æå‡ºä¸€ä¸ªView TextView(context).apply &#123; text = \"ä¼ ç»ŸTextView\" &#125; &#125;) &#125;&#125; è‡ªå®šä¹‰UIåœ¨Composeä¸­ï¼Œå¦‚æœæƒ³è¦è‡ªå®šä¹‰ä¸€äº›ç®€å•çš„UIæ˜¯å¾ˆç®€å•çš„ï¼Œåªéœ€è¦å†™ä¸€ä¸ªComposableå‡½æ•°å°±å¯ä»¥äº†ï¼Œæˆ‘ä»¬ä¸»è¦å­¦ä¹ ä¸€ä¸‹æ€ä¹ˆè‡ªå®šä¹‰ä¸€äº›å¤æ‚çš„UI æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹æ€ä¹ˆè‡ªå®šä¹‰ä¸€ä¸ªå¸ƒå±€ï¼Œå¯¹åº”ç€ä¼ ç»ŸUIä¸­çš„ViewGroupï¼Œä»¥ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´ï¼Œæˆ‘ä»¬è‡ªå®šä¹‰ä¸€ä¸ªå¸ƒå±€ï¼Œè®©å…¶ä¸­çš„å­å¸ƒå±€å‘ˆå·¦ä¸Šåˆ°å³ä¸‹ä¾æ¬¡æ’åˆ—ï¼š 123456789101112131415161718192021222324@Composablefun MyLayout(modifier: Modifier = Modifier, content: @Composable () -&gt; Unit) &#123; Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt; //æµ‹é‡æ¯ä¸ªå­å¸ƒå±€ val placeables = measurables.map &#123; measurable -&gt; measurable.measure(constraints) &#125; //è®¾ç½®å¸ƒå±€å¤§å°ä¸ºæœ€å¤§å¯å®¹çº³å¤§å° layout(constraints.maxWidth, constraints.maxHeight) &#123; var xPosition = 0 var yPosition = 0 //æ”¾ç½®æ¯ä¸ªå­View placeables.forEach &#123; placeable -&gt; placeable.placeRelative(x = xPosition, y = yPosition) //ä¸‹ä¸€ä¸ªå­Viewçš„åæ ‡ä¸ºä¸Šä¸€ä¸ªå­Viewçš„å³ä¸‹è§’ xPosition += placeable.width yPosition += placeable.height &#125; &#125; &#125;&#125; æˆ‘ä»¬å†çœ‹ä¸€ä¸ªä½¿ç”¨Canvasè‡ªå®šä¹‰Viewçš„æ–¹å¼ï¼Œè¿™ä¸ªæ›´ç®€å•ï¼Œå°±æ˜¯ç”»ä¸€æ¡æ°´å¹³çº¿ï¼š 12345678@SuppressLint(\"ModifierParameter\")@Composablefun HorizontalLine(modifier: Modifier = Modifier.fillMaxWidth()) &#123; Canvas(modifier = Modifier .then(modifier), onDraw = &#123; drawLine(color = Color.Black, Offset(0f, 0f), Offset(size.width, 0f), 2f) &#125;)&#125; æˆ‘ä»¬å°†ä¸¤è€…ä¸€èµ·ç”¨ä¸€ä¸‹çœ‹çœ‹æ•ˆæœ 123456789@Preview(showBackground = true)@Composablefun Preview() &#123; MyLayout &#123; Text(text = \"Text1\") HorizontalLine(Modifier.width(50.dp)) Text(text = \"Text2\") &#125;&#125; å…¶å®Composeä¸­çš„è‡ªå®šä¹‰UIçš„æ€è·¯å’Œä¼ ç»Ÿè‡ªå®šä¹‰Viewæ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡éœ€è¦ç†Ÿæ‚‰Composeä¸­çš„å„ç§Apiæ‰èƒ½çµæ´»è¿ç”¨å®ƒ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Jetpack Compose","slug":"Android/Jetpack-Compose","permalink":"http://yoursite.com/categories/Android/Jetpack-Compose/"}],"tags":[{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"http://yoursite.com/tags/Jetpack-Compose/"}]},{"title":"Linuxä¿¡å·æœºåˆ¶åŠå…¶åŸç†åˆ†æ","slug":"linux/Linuxä¿¡å·æœºåˆ¶åŠå…¶åŸç†åˆ†æ","date":"2022-03-31T09:11:00.000Z","updated":"2022-11-13T09:55:54.362Z","comments":true,"path":"2022/03/31/linux/Linuxä¿¡å·æœºåˆ¶åŠå…¶åŸç†åˆ†æ/","link":"","permalink":"http://yoursite.com/2022/03/31/linux/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"å‰è¨€åœ¨æœ€è¿‘åœ¨å·¥ä½œä¸­ï¼Œä½¿ç”¨åˆ°äº†ä¿¡å·çš„ç›¸å…³çŸ¥è¯†ï¼Œä¹‹å‰æˆ‘ä»¬åœ¨åˆ†æAndroidç³»ç»Ÿinitè¿›ç¨‹çš„æ—¶å€™ä¹Ÿæåˆ°äº†ä¿¡å·ï¼Œä½†å¹¶æ²¡æœ‰å¯¹ä¿¡å·è¿™ä¸ªæœºåˆ¶åšå‡ºæ·±å…¥çš„ç†è§£ï¼Œå€Ÿæ­¤æœºä¼šï¼Œæˆ‘ä»¬æ·±å…¥åˆ†æä¸€ä¸‹Linuxä¿¡å·æœºåˆ¶æ˜¯æ€æ ·å®ç°çš„ ç®€ä»‹ä¿¡å·ï¼ˆsignalï¼‰ï¼Œæ˜¯Unixç³»ç»Ÿä¸­çš„ä¸€ç§å¤è€çš„è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ï¼Œè€ŒLinuxä½œä¸ºç±»Unixç³»ç»Ÿï¼Œæ—©æœŸä¹Ÿæ˜¯æ¨¡ä»¿äº†Unixç³»ç»Ÿï¼Œè‡ªç„¶ä¹Ÿä¿ç•™ä¸‹äº†è¿™ä¸ªæœºåˆ¶ã€‚ä¿¡å·æ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡æœºåˆ¶ï¼Œå®ƒæ˜¯åœ¨è½¯ä»¶å±‚é¢ä¸Šå¯¹ä¸­æ–­æœºåˆ¶çš„ä¸€ç§æ¨¡æ‹Ÿ æ³¨ï¼šæœ¬ç¯‡æ–‡ç« åŸºäºglibcç‰ˆæœ¬2.35ï¼ŒLinuxå†…æ ¸ç‰ˆæœ¬5.17ï¼Œx86_64æ¶æ„ ä¿¡å·çš„äº§ç”Ÿä¿¡å·å¯ä»¥ç”±å†…æ ¸äº§ç”Ÿï¼Œä¹Ÿå¯ä»¥ç”±ç”¨æˆ·äº§ç”Ÿï¼Œè¿™è¾¹ä¸¾å‡ ä¸ªä¾‹å­ï¼š ç”¨æˆ·åœ¨ç»ˆç«¯è¾“å…¥ctrl + cæ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªSIGINTä¿¡å· åœ¨ç¨‹åºä¸­å¯¹ä¸€ä¸ªæ•°é™¤0ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªå¼‚å¸¸ï¼Œæœ€ç»ˆç”±å†…æ ¸äº§ç”Ÿä¸€ä¸ªSIGFPEä¿¡å· åœ¨ç¨‹åºä¸­éæ³•è®¿é—®ä¸€æ®µå†…å­˜ï¼Œä¼šç”±å†…æ ¸äº§ç”Ÿä¸€ä¸ªSIGBUSä¿¡å· åœ¨ç»ˆç«¯æˆ–ç¨‹åºä¸­æ‰‹åŠ¨å‘é€ä¸€ä¸ªä¿¡å· ç»ˆç«¯ï¼šæ¯”å¦‚è¯´kill -9 [pid] ç¨‹åºï¼šè°ƒç”¨killå‡½æ•°ï¼Œraiseå‡½æ•°ç­‰ ä¿¡å·ç§ç±»åœ¨Linuxä¸­ï¼Œä¿¡å·è¢«åˆ†ä¸ºä¸å¯é ä¿¡å·å’Œå¯é ä¿¡å·ï¼Œä¸€å…±64ç§ï¼Œå¯ä»¥é€šè¿‡kill -lå‘½ä»¤æ¥æŸ¥çœ‹ ä¸å¯é ä¿¡å·ï¼šä¹Ÿç§°ä¸ºéå®æ—¶ä¿¡å·ï¼Œä¸æ”¯æŒæ’é˜Ÿï¼Œä¿¡å·å¯èƒ½ä¼šä¸¢å¤±ï¼Œæ¯”å¦‚å‘é€å¤šæ¬¡ç›¸åŒçš„ä¿¡å·ï¼Œè¿›ç¨‹åªèƒ½æ”¶åˆ°ä¸€æ¬¡ï¼Œä¿¡å·å€¼å–å€¼åŒºé—´ä¸º1~31 å¯é ä¿¡å·ï¼šä¹Ÿç§°ä¸ºå®æ—¶ä¿¡å·ï¼Œæ”¯æŒæ’é˜Ÿï¼Œä¿¡å·ä¸ä¼šä¸¢å¤±ï¼Œå‘å¤šå°‘æ¬¡ï¼Œå°±å¯ä»¥æ”¶åˆ°å¤šå°‘æ¬¡ï¼Œä¿¡å·å€¼å–å€¼åŒºé—´ä¸º32~64 åœ¨æ—©æœŸçš„Linuxä¸­ï¼Œåªå®šä¹‰äº†å‰é¢çš„ä¸å¯é ä¿¡å·ï¼Œéšç€æ—¶é—´çš„å‘å±•ï¼Œå‘ç°æœ‰å¿…è¦å¯¹ä¿¡å·æœºåˆ¶åŠ ä»¥æ”¹è¿›å’Œæ‰©å……ï¼Œåˆç”±äºåŸå…ˆå®šä¹‰çš„ä¿¡å·å·²æœ‰åº”ç”¨ï¼Œå‡ºäºå…¼å®¹æ€§è€ƒè™‘ï¼Œä¸èƒ½å†åšæ”¹åŠ¨ï¼Œäºæ˜¯åˆæ–°å¢äº†ä¸€éƒ¨åˆ†ä¿¡å·ï¼Œè¿™äº›ä¿¡å·è¢«å®šä¹‰ä¸ºå¯é ä¿¡å·ã€‚ åœ¨arch/x86/include/uapi/asm/signal.hä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è¿™äº›ä¿¡å·çš„å®šä¹‰ï¼Œåœ¨æ–‡æœ«çš„é™„å½•ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿè¯¦ç»†ä»‹ç»äº†æ¯ä¸ªä¿¡å·çš„å«ä¹‰å’Œé»˜è®¤åŠ¨ä½œ å¦‚ä½•ä½¿ç”¨æˆ‘ä¸€å‘è®¤ä¸ºï¼Œå¦‚æœæƒ³è¦ç†è§£ä¸€ä¸ªæŠ€æœ¯åŸç†ï¼Œé¦–å…ˆæˆ‘ä»¬å¿…é¡»è¦ä¼šä½¿ç”¨è¿™ä¸ªæŠ€æœ¯ å‘é€ä¿¡å·ä¹‹å‰æè¿‡ï¼Œç”¨æˆ·æ˜¯å¯ä»¥æ‰‹åŠ¨å‘ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å·çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸€äº›å‡½æ•°ï¼š killåŸå‹ï¼š 123#include &lt;signal.h&gt;int kill(pid_t pid, int sig); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/kill.2.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å‘æŒ‡å®šè¿›ç¨‹ï¼ˆæˆ–è¿›ç¨‹ç»„ï¼‰å‘é€ä¸€ä¸ªä¿¡å·ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 å…¶ä¸­çš„pidå‚æ•°ï¼š å½“pid &gt; 0æ—¶ï¼Œå‘é€ä¿¡å·ç»™pidå¯¹åº”çš„è¿›ç¨‹ å½“pid = 0æ—¶ï¼Œå‘é€ä¿¡å·ç»™æœ¬è¿›ç¨‹ç»„ä¸­çš„æ‰€æœ‰è¿›ç¨‹ å½“pid = -1æ—¶ï¼Œå‘é€ä¿¡å·ç»™æ‰€æœ‰è°ƒç”¨è¿›ç¨‹æœ‰æƒç»™å…¶å‘é€ä¿¡å·çš„è¿›ç¨‹ï¼Œé™¤äº†initè¿›ç¨‹ å½“pid &lt; -1æ—¶ï¼Œå‘é€ä¿¡å·ç»™è¿›ç¨‹ç»„idä¸º-pidçš„æ‰€æœ‰è¿›ç¨‹ å½“sigå‚æ•°ä¸º0æ—¶ï¼Œä¸ä¼šå‘é€ä»»ä½•ä¿¡å·ï¼Œä½†ä»ç„¶ä¼šè¿›è¡Œå‚æ•°æ£€æµ‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ç§æ–¹æ³•æ£€æŸ¥pidå¯¹åº”è¿›ç¨‹æ˜¯å¦å­˜åœ¨æˆ–å…è®¸å‘é€ä¿¡å· raiseåŸå‹ï¼š 123#include &lt;signal.h&gt;int raise(int sig); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/raise.3.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å‘æœ¬è¿›ç¨‹æˆ–çº¿ç¨‹å‘é€ä¿¡å·ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 è¿™ä¸ªå‡½æ•°å¯¹äºä¸»çº¿ç¨‹æ¥è¯´ï¼Œç›¸å½“äºkill(getpid(), sig)ï¼Œå¯¹äºå­çº¿ç¨‹æ¥è¯´ï¼Œç›¸å½“äºpthread_kill(pthread_self(), sig) sigqueueåŸå‹ï¼š 123#include &lt;signal.h&gt;int sigqueue(pid_t pid, int sig, const union sigval value); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigqueue.3.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å‘ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å·ï¼ŒåŒæ—¶å¯ä»¥ä¼ é€’ä¸€äº›é¢å¤–æ•°æ®ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 è¿™ä¸ªå‡½æ•°å’Œkillä¸åŒçš„åœ°æ–¹æ˜¯ï¼Œå®ƒåªèƒ½å‘ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å·ï¼Œä¸èƒ½å‘é€ç»™ä¿¡å·ç»„ï¼Œå½“sigä¸º0æ—¶ï¼Œè¡Œä¸ºå’Œkillä¸€è‡´ abortåŸå‹ï¼š 123#include &lt;stdlib.h&gt;noreturn void abort(void); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/abort.3.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯å‘æœ¬è¿›ç¨‹å‘é€SIGABRTä¿¡å· éœ€è¦æ³¨æ„çš„æœ‰ä¸¤ç‚¹ï¼š abortå‡½æ•°ä¼šé¦–å…ˆè§£é™¤è¿›ç¨‹å¯¹SIGABRTä¿¡å·çš„é˜»å¡ æ— è®ºSIGABRTä¿¡å·æ˜¯å¦æ³¨å†Œäº†è‡ªå®šä¹‰å¤„ç†å™¨ï¼Œæœ€åéƒ½ä¼šç»ˆæ­¢è¿›ç¨‹ï¼Œå› ä¸ºabortå‡½æ•°ä¼šåœ¨SIGABRTä¿¡å·å¤„ç†å®Œåæ¢å¤é»˜è®¤ä¿¡å·å¤„ç†æ–¹å¼ï¼Œç„¶åé‡å‘è¿™ä¸ªä¿¡å· alarmåŸå‹ï¼š 123#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/alarm.2.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯åœ¨secondsç§’åå‘æœ¬è¿›ç¨‹å‘é€SIGALRMä¿¡å· å‚æ•°secondsä¸ºæ—¶é—´ï¼Œå•ä½ä¸ºç§’ è¿”å›å€¼ï¼Œå¦‚æœä»¥å‰æ²¡æœ‰è®¾ç½®è¿‡alarmæˆ–è¶…æ—¶ï¼Œåˆ™è¿”å›0ï¼Œå¦‚æœä»¥å‰æ²¡æœ‰è®¾ç½®è¿‡alarmï¼Œåˆ™è¿”å›å‰©ä½™çš„æ—¶é—´ å¤„ç†ä¿¡å·æˆ‘ä»¬æ˜¯å¯ä»¥è‡ªå®šä¹‰ä¸€äº›ä¿¡å·çš„å¤„ç†æ–¹å¼ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒSIGKILLå’ŒSIGSTOPæ˜¯ä¸¤ä¸ªç‰¹æ®Šçš„ä¿¡å·ï¼Œå®ƒä»¬ä¸å…è®¸è¢«å¿½ç•¥ã€å¤„ç†å’Œé˜»å¡ sigactionåŸå‹ï¼š 1234#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/sigaction.2.html è¿™æ˜¯è¾ƒæ–°çš„ä¸€ä¸ªä¿¡å·å¤„ç†å‡½æ•°ï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼Œå¯¹ä¸€ä¸ªä¿¡å·æ³¨å†Œä¸€ä¸ªæ–°çš„ä¿¡å·å¤„ç†æ–¹å¼ï¼Œå¹¶è·å–ä»¥å‰çš„ä¿¡å·å¤„ç†æ–¹å¼ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ç¬¬ä¸€ä¸ªå‚æ•°signumï¼Œç”¨æ¥æŒ‡å®šä¿¡å·çš„ç¼–å·ï¼ˆéœ€è¦è®¾ç½®å“ªä¸ªä¿¡å·ï¼‰ ç¬¬äºŒä¸ªå‚æ•°actç”¨æ¥æŒ‡å®šæ³¨å†Œçš„æ–°çš„ä¿¡å·å¤„ç†æ–¹å¼ ç¬¬ä¸‰ä¸ªå‚æ•°oldactä¸ä¸ºnullæ—¶ï¼Œå¯ä»¥ç”¨æ¥è·å–è¯¥ä¿¡å·åŸæ¥çš„å¤„ç†æ–¹å¼ å½“å‚æ•°actä¸ºnullï¼Œoldactä¸ä¸ºnullæ—¶ï¼Œè¿™ä¸ªå‡½æ•°å¯ä»¥ç”¨æ¥åªè·å–ä¿¡å·å½“å‰çš„å¤„ç†æ–¹å¼ sigactionç»“æ„ä½“123456789101112131415struct sigaction &#123; union &#123; __sighandler_t _sa_handler; void (*_sa_sigaction)(int, struct siginfo *, void *); &#125; _u; sigset_t sa_mask; unsigned long sa_flags; void (*sa_restorer)(void);&#125;;typedef void __signalfn_t(int);typedef __signalfn_t __user *__sighandler_t;#define sa_handler _u._sa_handler#define sa_sigaction _u._sa_sigaction å¯ä»¥çœ‹åˆ°ï¼Œå…¶ä¸­æœ‰ä¸€ä¸ªè”åˆï¼Œå®ƒæ˜¯ç”¨æ¥å…¼å®¹æ—§ç‰ˆæœ¬å‡½æ•°çš„ï¼Œå½“å‚æ•°sa_maskä¸­å«æœ‰SA_SIGINFOçš„æ—¶å€™ï¼Œå›è°ƒçš„æ˜¯_sa_sigactionå‡½æ•°ï¼Œå½“æ²¡æœ‰è¿™ä¸ªå‚æ•°æ—¶ï¼Œå›è°ƒçš„æ˜¯_sa_handlerè¿™ä¸ªæ—§ç‰ˆæœ¬å‡½æ•° _sa_sigactionå‡½æ•°ç›¸å¯¹äº_sa_handlerå‡½æ•°è€Œè¨€ï¼Œå¤šæºå¸¦äº†ä¸€äº›ä¿¡å·ä¿¡æ¯ï¼Œè­¬å¦‚è¯´å‘é€ä¿¡å·çš„è¿›ç¨‹pid _sa_handlerå¯ä»¥è¢«èµ‹å€¼æˆSIG_DFLæˆ–SIG_IGNï¼Œå®ƒä»¬åˆ†åˆ«å¯¹åº”ç€é»˜è®¤å¤„ç†å’Œå¿½ç•¥ä¿¡å·ï¼Œéœ€è¦æ³¨æ„çš„æ—¶ï¼Œå®ƒä»¬åªæ˜¯ä¸€ä¸ªintå€¼ï¼Œæ˜¯ä¸èƒ½è¢«ç›´æ¥è°ƒç”¨çš„ 12#define SIG_DFL ((__force __sighandler_t)0) /* default signal handling */#define SIG_IGN ((__force __sighandler_t)1) /* ignore signal */ è¿™ä¸ªç»“æ„ä½“ä¸­çš„sa_maskåŸŸä¸ºä¸€ä¸ªä¿¡å·é›†ï¼Œè¡¨ç¤ºå½“æ­£åœ¨æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°çš„æ—¶å€™ï¼Œé˜»å¡ä¸€äº›ä¿¡å·ï¼Œåªæœ‰è¿™ä¸ªä¿¡å·å¤„ç†å®Œäº†ï¼Œè¿™äº›ä¿¡å·æ‰ä¼šè¢«å¤„ç† è¿™ä¸ªç»“æ„ä½“ä¸­çš„sa_flagsåŸŸï¼Œæœ‰å¦‚ä¸‹ä¸€äº›æ ‡å¿—ï¼š SA_NOCLDSTOPï¼šå½“signumä¸ºSIGCHLDçš„æ—¶å€™æ‰ç”Ÿæ•ˆï¼Œå½“å­è¿›ç¨‹æš‚åœæˆ–æ¢å¤æ—¶ï¼Œçˆ¶è¿›ç¨‹ä¸ä¼šæ”¶åˆ°SIGCHLDä¿¡å· SA_NOCLDWAITï¼šå½“signumä¸ºSIGCHLDçš„æ—¶å€™æ‰ç”Ÿæ•ˆï¼Œå½“å­è¿›ç¨‹é€€å‡ºæ—¶ï¼Œçˆ¶è¿›ç¨‹ä¸ä¼šæ”¶åˆ°SIGCHLDä¿¡å·ï¼Œå­è¿›ç¨‹ä¹Ÿä¸ä¼šæˆä¸ºåƒµå°¸è¿›ç¨‹ SA_NODEFERï¼šä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå½“ä¿¡å·å¤„ç†å‡½æ•°è¿è¡Œæ—¶ï¼Œå†…æ ¸å°†é˜»å¡å¯¹åº”çš„ä¿¡å·ã€‚ä½†æ˜¯å¦‚æœè®¾ç½®äº†SA_NODEFERæ ‡è®°ï¼Œé‚£ä¹ˆåœ¨è¯¥ä¿¡å·å¤„ç†å‡½æ•°è¿è¡Œæ—¶ï¼Œå†…æ ¸å°†ä¸ä¼šé˜»å¡è¯¥ä¿¡å· SA_ONSTACKï¼šè¡¨ç¤ºä½¿ç”¨ä¸€ä¸ªå¤‡ç”¨æ ˆï¼Œå½“å‘ç”Ÿæ ˆæº¢å‡ºæ—¶ï¼Œå†…æ ¸ä¼šå‘å‡ºSIGILLä¿¡å·ï¼Œå¦‚æœæ­¤æ—¶åœ¨åŸæ¥çš„æ ˆä¸Šè°ƒç”¨ä¿¡å·å¤„ç†å‡½æ•°ï¼Œä¹Ÿä¼šå‘ç”Ÿæ ˆæº¢å‡ºï¼Œå¯¼è‡´æ­»å¾ªç¯ï¼Œæ­¤æ—¶å°±éœ€è¦å‡†å¤‡ä¸€ä¸ªå¤‡ç”¨æ ˆï¼Œåœ¨å¤‡ç”¨æ ˆä¸Šå¤„ç†ä¿¡å· SA_RESETHANDï¼šè¡¨ç¤ºè®¾ç½®çš„ä¿¡å·å¤„ç†è¡Œä¸ºåªç”Ÿæ•ˆä¸€æ¬¡ï¼Œå½“è§¦å‘æˆ‘ä»¬è®¾ç½®çš„ä¿¡å·å¤„ç†å‡½æ•°åï¼Œå†…æ ¸ä¼šå°†ä¿¡å·å¤„ç†è¡Œä¸ºé‡ç½®ï¼ˆSA_ONESHOTä½œç”¨ç›¸åŒï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªè¿‡æ—¶çš„ï¼Œéæ ‡å‡†çš„flagï¼‰ SA_RESTARTï¼šå½“æ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå¦‚æœæ”¶åˆ°ä¸€ä¸ªä¿¡å·ï¼Œç³»ç»Ÿé»˜è®¤å°†ä¸­æ–­è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œè½¬è€Œæ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œç»“æŸåè®©è¿™ä¸ªè¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨å¤±è´¥ï¼Œè®¾ç½®äº†SA_RESTARTæ ‡å¿—åï¼Œå½“ä¿¡å·å¤„ç†å‡½æ•°æ‰§è¡Œå®Œåï¼Œä¼šè‡ªåŠ¨æ¢å¤æ‰§è¡Œè¿™ä¸ªè¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨ SA_SIGINFOï¼šè®¾ç½®è¿™ä¸ªæ ‡å¿—åï¼Œä¼šå›è°ƒ_sa_sigactionä½œä¸ºä¿¡å·å¤„ç†å‡½æ•°ï¼Œä¼šæºå¸¦æ›´å¤šçš„ä¿¡å·ä¿¡æ¯ signalåŸå‹ï¼š 123#include &lt;signal.h&gt;sighandler_t signal(int signum, sighandler_t handler); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/signal.2.html è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯ï¼Œè®¾ç½®ä¸‹ä¸€æ¬¡çš„ä¿¡å·å¤„ç†å‡½æ•°ï¼ˆåªç”Ÿæ•ˆä¸€æ¬¡ï¼‰ï¼ŒæˆåŠŸè¿”å›ä¸Šä¸€æ¬¡è®¾ç½®çš„ä¿¡å·å¤„ç†å‡½æ•°ï¼Œå¤±è´¥è¿”å›SIG_ERR è¿™ä¸ªå‡½æ•°åœ¨æ–°ç‰ˆæœ¬ä¸­å®é™…ä¸Šæ˜¯é€šè¿‡sigactionå‡½æ•°å®ç°çš„ï¼Œæ¨èä½¿ç”¨æ›´åŠ å¼ºå¤§çš„sigactionå‡½æ•° é˜»å¡ä¿¡å·ä¿¡å·æœ‰å‡ ç§çŠ¶æ€ï¼Œé¦–å…ˆæ˜¯ä¿¡å·çš„äº§ç”Ÿ (Genertion)ï¼Œè€Œå®é™…æ‰§è¡Œä¿¡å·å¤„ç†åŠ¨ä½œæ—¶ï¼ŒçŠ¶æ€ä¸ºé€’è¾¾ (Delivery)ï¼Œä¿¡å·åœ¨äº§ç”Ÿåˆ°é€’è¾¾ä¸­çš„çŠ¶æ€è¢«ç§°ä¸ºæœªå†³ (Pending) è¿›ç¨‹å¯ä»¥é€‰æ‹©é˜»å¡ (Blocking)æŸäº›ä¿¡å·ï¼Œè¢«é˜»å¡çš„ä¿¡å·åœ¨äº§ç”Ÿåå°†ä¿æŒåœ¨æœªå†³çŠ¶æ€ï¼Œç›´åˆ°è¿›ç¨‹è§£é™¤å¯¹è¯¥ä¿¡å·çš„é˜»å¡ï¼Œæ‰æ‰§è¡Œé€’è¾¾çš„åŠ¨ä½œ ä¿¡å·é›†å‡½æ•°æˆ‘ä»¬å¯ä»¥ç”¨ä¿¡å·é›†å‡½æ•°æ”¹å˜å½“å‰è¿›ç¨‹çš„ä¿¡å·å±è”½å­—ï¼ˆSignal Maskï¼‰ï¼Œæ§åˆ¶ä¿¡å·çš„é˜»å¡ä¸å¦ ä¿¡å·é›†è®¾ç½®å‡½æ•°12345678910111213141516171819#include &lt;signal.h&gt;//ä¿¡å·é›†æ•°æ®ç±»å‹typedef unsigned long sigset_t;//æ¸…ç©ºä¸€ä¸ªä¿¡å·é›†ï¼ˆå°†è¿™ä¸ªsigset_tç½®0ï¼‰//æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigemptyset.3p.htmlvoid sigemptyset(sigset_t *set);//å¡«å……æ»¡ä¸€ä¸ªä¿¡å·é›†ï¼ˆå°†è¿™ä¸ªsigset_tçš„æ¯ä¸€ä½éƒ½ç½®1ï¼‰//æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigfillset.3p.htmlvoid sigfillset(sigset_t *set);//å°†æŒ‡å®šçš„ä¿¡å·æ·»åŠ åˆ°ä¿¡å·é›†ä¸­ï¼ˆå°†è¿™ä¸ªsigset_tçš„å¯¹åº”ä¿¡å·ä½ç½®1ï¼‰//æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigaddset.3p.htmlint sigaddset(sigset_t *set, int signo);//å°†æŒ‡å®šçš„ä¿¡å·ä»ä¿¡å·é›†ä¸­ç§»é™¤ï¼ˆå°†è¿™ä¸ªsigset_tçš„å¯¹åº”ä¿¡å·ä½ç½®0ï¼‰//æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigdelset.3p.htmlint sigdelset(sigset_t *set, int signo);//åˆ¤æ–­ä¸€ä¸ªä¿¡å·æ˜¯å¦åœ¨è¿™ä¸ªä¿¡å·é›†ä¸­ï¼ˆåˆ¤æ–­è¿™ä¸ªsigset_tçš„å¯¹åº”ä¿¡å·ä½æ˜¯å¦ä¸º1ï¼‰//æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigismember.3p.htmlint sigismember(const sigset_t *set, int signo); sigpromaskåŸå‹ï¼š 123#include &lt;signal.h&gt; int sigpromask(int how, const sigset_t *set, sigset_t *oldset); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/sigprocmask.2.html è¿™ä¸ªå‡½æ•°é€šè¿‡æŒ‡å®šçš„æ–¹æ³•å’Œä¿¡å·é›†ä¿®æ”¹è¿›ç¨‹çš„ä¿¡å·å±è”½å­—ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ç¬¬ä¸€ä¸ªå‚æ•°howæœ‰3ç§å–å€¼ï¼š SIG_BLOCKï¼šå°†setä¸­çš„ä¿¡å·æ·»åŠ åˆ°ä¿¡å·å±è”½å­—ä¸­ï¼ˆä¸æ”¹å˜åŸæœ‰å·²å­˜åœ¨ä¿¡å·å±è”½å­—ï¼Œç›¸å½“äºç”¨setä¸­çš„ä¿¡å·ä¸åŸæœ‰ä¿¡å·å–å¹¶é›†è®¾ç½®ï¼‰ SIG_UNBLOCKï¼šå°†setä¸­çš„ä¿¡å·ç§»é™¤ä¿¡å·å±è”½å­—ï¼ˆç›¸å½“äºç”¨setä¸­çš„ä¿¡å·çš„è¡¥é›†ä¸åŸæœ‰ä¿¡å·å–äº¤é›†è®¾ç½®ï¼‰ SIG_SETMASKï¼šä½¿ç”¨setä¸­çš„ä¿¡å·ç›´æ¥ä»£æ›¿åŸæœ‰ä¿¡å·å±è”½å­—ä¸­çš„ä¿¡å· ç¬¬äºŒä¸ªå‚æ•°setæ˜¯ä¸€ä¸ªä¿¡å·é›†ï¼Œæ€ä¹ˆä½¿ç”¨å’Œå‚æ•°howç›¸å…³ ç¬¬ä¸‰ä¸ªå‚æ•°oldsetï¼Œå¦‚æœä¸ä¸ºnullï¼Œä¼šå°†åŸæœ‰ä¿¡å·å±è”½å­—çš„ä¿¡å·é›†ä¿å­˜è¿›å» sigpendingåŸå‹ï¼š 123#include &lt;signal.h&gt;int sigpending(sigset_t *set); è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯è·å¾—å½“å‰è¿›ç¨‹çš„ä¿¡å·å±è”½å­—ï¼Œå°†ç»“æœä¿å­˜åˆ°ä¼ å…¥çš„setä¸­ï¼ŒæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ä¿¡å·åŸç†æˆ‘ä»¬å·²ç»äº†è§£äº†ä¿¡å·çš„äº§ç”Ÿå’Œå¤„ç†ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥å…·ä½“çš„çœ‹çœ‹ä¸€ä¸ªä¿¡å·ä»äº§ç”Ÿåˆ°å“åº”å¤„ç†ï¼Œå®ƒç»å†äº†ä»€ä¹ˆï¼Œå®ƒçš„åŸç†æ˜¯ä»€ä¹ˆ æˆ‘ä»¬åœ¨ç®€ä»‹ä¸­è¯´è¿‡ï¼šä¿¡å·æ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡æœºåˆ¶ï¼Œå®ƒæ˜¯åœ¨è½¯ä»¶å±‚é¢ä¸Šå¯¹ä¸­æ–­æœºåˆ¶çš„ä¸€ç§æ¨¡æ‹Ÿï¼Œè¯¥æ€ä¹ˆç†è§£è¿™å¥è¯å‘¢ï¼Ÿ å½“æˆ‘ä»¬å¯¹ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å·åï¼Œä¼šå°†è¿™ä¸ªä¿¡å·æš‚æ—¶å­˜æ”¾åˆ°è¿™ä¸ªè¿›ç¨‹æ‰€å¯¹åº”çš„task_structçš„pendingé˜Ÿåˆ—ä¸­ï¼Œæ­¤æ—¶ï¼Œè¿›ç¨‹å¹¶ä¸çŸ¥é“æœ‰æ–°çš„ä¿¡å·è¿‡æ¥äº†ï¼Œè¿™ä¹Ÿå°±æ˜¯å¼‚æ­¥çš„æ„æ€ã€‚é‚£ä¹ˆè¿›ç¨‹ä»€ä¹ˆæ—¶å€™æ‰èƒ½å¾—çŸ¥å¹¶å¤„ç†è¿™ä¸ªä¿¡å·å‘¢ï¼Ÿæœ‰ä¸¤ä¸ªæ—¶æœºï¼Œä¸€ä¸ªæ˜¯è¿›ç¨‹ä»å†…æ ¸æ€è¿”å›åˆ°ç”¨æˆ·æ€æ—¶ï¼Œä¸€ä¸ªæ˜¯è¿›ç¨‹ä»ç¡çœ çŠ¶æ€è¢«å”¤é†’ã€‚è®©ä¿¡å·çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªå¼‚æ­¥ä¸­æ–­çš„å…³é”®å°±æ˜¯ï¼Œæ­£å¸¸çš„ç”¨æˆ·è¿›ç¨‹æ˜¯ä¼šé¢‘ç¹çš„åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´åˆ‡æ¢çš„ï¼Œæ‰€ä»¥ä¿¡å·èƒ½å¾ˆå¿«çš„å¾—åˆ°æ‰§è¡Œ ä¸‹å›¾ä¸ºä¿¡å·ç›¸å…³çš„ä¸€äº›ç»“æ„ ä¿¡å·çš„å‘é€æˆ‘ä»¬ä»¥killå‡½æ•°ä¸ºä¾‹ï¼Œçœ‹çœ‹ä¿¡å·æ˜¯å¦‚ä½•å‘é€çš„ï¼Œå®ƒè¢«å®šä¹‰åœ¨tools/include/nolibc/nolibc.hä¸­ 1234567891011121314151617static __attribute__((unused))int kill(pid_t pid, int signal)&#123; int ret = sys_kill(pid, signal); if (ret &lt; 0) &#123; SET_ERRNO(-ret); ret = -1; &#125; return ret;&#125;static __attribute__((unused))int sys_kill(pid_t pid, int signal)&#123; return my_syscall2(__NR_kill, pid, signal);&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œä½¿ç”¨äº†ç³»ç»Ÿè°ƒç”¨ï¼Œåœ¨Linuxå†…æ ¸ä¸­ï¼Œæ¯ä¸ªsyscalléƒ½å¯¹åº”ç€å”¯ä¸€çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œkillå‡½æ•°çš„ç³»ç»Ÿè°ƒç”¨å·ä¸º__NR_killï¼Œå®ƒè¢«å®šä¹‰åœ¨tools/include/uapi/asm-generic/unistd.hä¸­ 123/* kernel/signal.c */#define __NR_kill 129__SYSCALL(__NR_kill, sys_kill) åœ¨x86_64æ¶æ„çš„æœºå™¨ä¸Šï¼Œmy_syscall2æ˜¯è¿™æ ·è¢«å®šä¹‰çš„ 12345678910111213141516#define my_syscall2(num, arg1, arg2) \\(&#123; \\ long _ret; \\ register long _num asm(\"rax\") = (num); \\ register long _arg1 asm(\"rdi\") = (long)(arg1); \\ register long _arg2 asm(\"rsi\") = (long)(arg2); \\ \\ asm volatile ( \\ \"syscall\\n\" \\ : \"=a\"(_ret) \\ : \"r\"(_arg1), \"r\"(_arg2), \\ \"0\"(_num) \\ : \"rcx\", \"r11\", \"memory\", \"cc\" \\ ); \\ _ret; \\&#125;) è¿™é‡Œæ¶‰åŠåˆ°äº†æ‰©å±•å†…è”æ±‡ç¼–ï¼ŒsyscallæŒ‡ä»¤éœ€è¦ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å·å’Œä¸€äº›å‚æ•°ï¼Œåœ¨x86_64æ¶æ„ä¸­ï¼Œç³»ç»Ÿè°ƒç”¨å·éœ€è¦å­˜æ”¾åœ¨raxå¯„å­˜å™¨ä¸­ï¼Œå‚æ•°ä¾æ¬¡å­˜æ”¾åœ¨rdi, rsi, rdx, r10, r8, r9å¯„å­˜å™¨ä¸­ï¼Œæ‰§è¡ŒsyscallæŒ‡ä»¤åï¼Œå†…æ ¸ä¼šé€šè¿‡ç³»ç»Ÿè°ƒç”¨å·å»ä»ç³»ç»Ÿè°ƒç”¨è¡¨æ‰¾åˆ°å¯¹åº”å‡½æ•°çš„å…¥å£ æˆ‘ä»¬ä¹‹å‰åœ¨æ‰¾ç³»ç»Ÿè°ƒç”¨å·__NR_killçš„æ—¶å€™å¯ä»¥å‘ç°ï¼Œä¸Šé¢æ ‡äº†æ³¨é‡Šï¼Œè¡¨æ˜è¿™ä¸ªå‡½æ•°çš„å®ç°åœ¨kernel/signal.cä¸­ï¼Œä½†æˆ‘ä»¬åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­å¹¶æ²¡æœ‰æ‰¾åˆ°sys_killè¿™ä¸ªå‡½æ•°ï¼Œå®é™…ä¸Šè¿™é‡Œéšè—äº†ä¸€ä¸ªå®å®šä¹‰ åœ¨include/linux/syscalls.hä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è¿™æ ·ä¸€äº›å®å®šä¹‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef SYSCALL_DEFINE0#define SYSCALL_DEFINE0(sname) \\ SYSCALL_METADATA(_##sname, 0); \\ asmlinkage long sys_##sname(void); \\ ALLOW_ERROR_INJECTION(sys_##sname, ERRNO); \\ asmlinkage long sys_##sname(void)#endif /* SYSCALL_DEFINE0 */#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)#define SYSCALL_DEFINE_MAXARGS 6#define SYSCALL_DEFINEx(x, sname, ...) \\ SYSCALL_METADATA(sname, x, __VA_ARGS__) \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)/* * The asmlinkage stub is aliased to a function named __se_sys_*() which * sign-extends 32-bit ints to longs whenever needed. The actual work is * done within __do_sys_*(). */#ifndef __SYSCALL_DEFINEx#define __SYSCALL_DEFINEx(x, name, ...) \\ __diag_push(); \\ __diag_ignore(GCC, 8, \"-Wattribute-alias\", \\ \"Type aliasing is used to sanitize syscall arguments\");\\ asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \\ __attribute__((alias(__stringify(__se_sys##name)))); \\ ALLOW_ERROR_INJECTION(sys##name, ERRNO); \\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\ asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)); \\ asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \\ &#123; \\ long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\\ __MAP(x,__SC_TEST,__VA_ARGS__); \\ __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); \\ return ret; \\ &#125; \\ __diag_pop(); \\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))#endif /* __SYSCALL_DEFINEx */ SYSCALL_DEFINExä¸­çš„xè¡¨ç¤ºæ¥å—xä¸ªå‚æ•°ï¼Œè¿™ä¸ªå®å®šä¹‰æ ¹æ®ä¼ å…¥çš„nameå‚æ•°ï¼Œä»¥sys_nameä¸ºåå®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´SYSCALL_DEFINE2(kill, ...)è¿™ä¸ªå®å±•å¼€ååŸºæœ¬ç›¸å½“äºsys_killå‡½æ•°ï¼Œåœ¨kernel/signal.cä¸­æˆ‘ä»¬å¯ä»¥æ‰¾åˆ°è¿™æ®µä»£ç  1234567891011/** * sys_kill - send a signal to a process * @pid: the PID of the process * @sig: signal to be sent */SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)&#123; struct kernel_siginfo info; prepare_kill_siginfo(sig, &amp;info); return kill_something_info(sig, &amp;info, pid);&#125; è¿™é‡Œå°±æ˜¯killå‡½æ•°çš„çœŸæ­£å®ç°ï¼Œæˆ‘ä»¬è¿™é‡Œä¸»è¦å…³æ³¨ä¿¡å·çš„å‘é€ï¼Œå°±å±è”½ä¸€äº›ç»†èŠ‚ï¼Œåªçœ‹å‘é€éƒ¨åˆ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)&#123; int ret; //è¿™é‡Œæˆ‘ä»¬å°±åªçœ‹å¯¹ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å· if (pid &gt; 0) return kill_proc_info(sig, info, pid); ...&#125;static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)&#123; ... kill_pid_info(sig, info, find_vpid(pid)); ...&#125;int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)&#123; struct task_struct *p; for (;;) &#123; ... //è·å–pidå¯¹åº”è¿›ç¨‹çš„task_struct p = pid_task(pid, PIDTYPE_PID); if (p) //PIDTYPE_TGIDè¡¨ç¤ºç±»å‹æ˜¯çº¿ç¨‹ç»„idï¼Œå¯¹äºåŒä¸€è¿›ç¨‹ä¸­çš„æ‰€æœ‰çº¿ç¨‹ï¼Œtgidéƒ½æ˜¯ä¸€è‡´çš„ï¼Œä¸ºè¯¥è¿›ç¨‹çš„è¿›ç¨‹id group_send_sig_info(sig, info, p, PIDTYPE_TGID); ... &#125;&#125;int group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p, enum pid_type type)&#123; int ret; ... if (!ret &amp;&amp; sig) ret = do_send_sig_info(sig, info, p, type); return ret;&#125;int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p, enum pid_type type)&#123; ... send_signal(sig, info, p, type); ...&#125;static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t, enum pid_type type)&#123; /* Should SIGKILL or SIGSTOP be received by a pid namespace init? */ ... return __send_signal(sig, info, t, type, force);&#125;static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t, enum pid_type type, bool force)&#123; struct sigpending *pending; struct sigqueue *q; int override_rlimit; int ret = 0, result; result = TRACE_SIGNAL_IGNORED; //åˆ¤æ–­æ˜¯å¦å¯ä»¥å¿½ç•¥ä¿¡å· if (!prepare_signal(sig, t, force)) goto ret; //é€‰æ‹©ä¿¡å·pendingé˜Ÿåˆ— //çº¿ç¨‹ç»„å…±äº«é˜Ÿåˆ—(t-&gt;signal-&gt;shared_pending) æˆ– è¿›ç¨‹ç§æœ‰é˜Ÿåˆ—(t-&gt;pending) pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending; result = TRACE_SIGNAL_ALREADY_PENDING; //å¦‚æœè¯¥ä¿¡å·æ˜¯ä¸å¯é ä¿¡å·ï¼Œä¸”å·²ç»åœ¨paddingé˜Ÿåˆ—ä¸­ï¼Œåˆ™å¿½ç•¥è¿™ä¸ªä¿¡å· if (legacy_queue(pending, sig)) goto ret; result = TRACE_SIGNAL_DELIVERED; //å¯¹SIGKILLä¿¡å·å’Œå†…æ ¸è¿›ç¨‹è·³è¿‡ä¿¡å·çš„pending if ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD)) goto out_set; //å®æ—¶ä¿¡å·å¯ä»¥çªç ´é˜Ÿåˆ—å¤§å°é™åˆ¶ï¼Œå¦åˆ™ä¸¢å¼ƒä¿¡å· if (sig &lt; SIGRTMIN) override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0); else override_rlimit = 0; //æ–°åˆ†é…ä¸€ä¸ªsigqueueï¼Œå¹¶å°†å…¶åŠ å…¥pendingé˜Ÿå°¾ q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0); if (q) &#123; list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list); switch ((unsigned long) info) &#123; case (unsigned long) SEND_SIG_NOINFO: clear_siginfo(&amp;q-&gt;info); q-&gt;info.si_signo = sig; q-&gt;info.si_errno = 0; q-&gt;info.si_code = SI_USER; q-&gt;info.si_pid = task_tgid_nr_ns(current, task_active_pid_ns(t)); rcu_read_lock(); q-&gt;info.si_uid = from_kuid_munged(task_cred_xxx(t, user_ns), current_uid()); rcu_read_unlock(); break; case (unsigned long) SEND_SIG_PRIV: clear_siginfo(&amp;q-&gt;info); q-&gt;info.si_signo = sig; q-&gt;info.si_errno = 0; q-&gt;info.si_code = SI_KERNEL; q-&gt;info.si_pid = 0; q-&gt;info.si_uid = 0; break; default: copy_siginfo(&amp;q-&gt;info, info); break; &#125; &#125; else if (!is_si_special(info) &amp;&amp; sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123; ... &#125; else &#123; ... &#125;out_set: signalfd_notify(t, sig); sigaddset(&amp;pending-&gt;signal, sig); ... //å”¤é†’è¿›ç¨‹ complete_signal(sig, t, type);ret: return ret;&#125; ä»ä»£ç é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼Œå’Œæˆ‘ä»¬ä¹‹å‰è¯´çš„åŸç†æ˜¯ä¸€æ ·çš„ï¼Œæ–°åˆ†é…äº†ä¸€ä¸ªsigqueueï¼Œå¹¶å°†å…¶åŠ å…¥åˆ°å¯¹åº”è¿›ç¨‹task_structçš„pendingé˜Ÿåˆ—é˜Ÿå°¾ è®¾ç½®ä¿¡å·å¤„ç†ä¹‹å‰æˆ‘ä»¬ä»‹ç»äº†æ€ä¹ˆè‡ªå®šä¹‰ä¿¡å·å¤„ç†è¡Œä¸ºï¼Œå¦‚ä½•è®¾ç½®ä¿¡å·å±è”½å­—ï¼Œå®é™…ä¸Šéƒ½èƒ½åœ¨è¿›ç¨‹çš„task_structä¸­ä½“ç°å‡ºæ¥ï¼Œä¿¡å·å¤„ç†è¡Œä¸ºä¿å­˜åœ¨å…¶ä¸­çš„sighandåŸŸä¸­ï¼Œè€Œä¿¡å·å±è”½å­—ä¿å­˜åœ¨å…¶ä¸­çš„blockedåŸŸä¸­ ä¿¡å·çš„å“åº”x86_64æ¶æ„ç³»ç»Ÿè°ƒç”¨ä¼šç»å†do_syscall_64è¿™ä¹ˆä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè¢«å®ç°åœ¨arch/x86/entry/common.cä¸­ 123456789101112131415__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)&#123; add_random_kstack_offset(); nr = syscall_enter_from_user_mode(regs, nr); instrumentation_begin(); if (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != -1) &#123; /* Invalid system call, but still a system call. */ regs-&gt;ax = __x64_sys_ni_syscall(regs); &#125; instrumentation_end(); syscall_exit_to_user_mode(regs);&#125; ä»ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼Œå½“è¿›ç¨‹ä»å†…æ ¸ç©ºé—´è¿”å›ç”¨æˆ·ç©ºé—´æ—¶ï¼Œä¼šè°ƒç”¨syscall_exit_to_user_modeå‡½æ•° æœ€ç»ˆç»å†ä¸€ç³»åˆ—è°ƒç”¨ï¼Œä¼šèµ°åˆ°exit_to_user_mode_loopå‡½æ•°ä¸­ï¼Œå®ƒä»¬è¢«å®šä¹‰åœ¨kernel/entry/common.cä¸­ 1234567891011static unsigned long exit_to_user_mode_loop(struct pt_regs *regs, unsigned long ti_work)&#123; while (ti_work &amp; EXIT_TO_USER_MODE_WORK) &#123; ... if (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) handle_signal_work(regs, ti_work); ... &#125; return ti_work;&#125; å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœå½“å‰çº¿ç¨‹åŒ…å«_TIF_SIGPENDINGæˆ–_TIF_NOTIFY_SIGNALï¼Œè¡¨æ˜è¯¥çº¿ç¨‹å¯èƒ½æœ‰ä¿¡å·éœ€è¦å¤„ç†ï¼Œä¼šè°ƒç”¨åˆ°handle_signal_workå‡½æ•°å¤„ç†ï¼Œæ¥ç€è°ƒç”¨åˆ°arch_do_signal_or_restartå‡½æ•°ä¸­ï¼Œå®ƒè¢«å®ç°åœ¨arch/x86/kernel/signal.cä¸­ 12345678910111213141516171819202122232425262728293031//has_signalçš„å€¼ä¸º (ti_work &amp; _TIF_SIGPENDING)void arch_do_signal_or_restart(struct pt_regs *regs, bool has_signal)&#123; struct ksignal ksig; if (has_signal &amp;&amp; get_signal(&amp;ksig)) &#123; handle_signal(&amp;ksig, regs); return; &#125; //å¦‚æœè¯¥è¿›ç¨‹æ²¡æœ‰å¯¹è¿™ä¸ªä¿¡å·è®¾ç½®å¤„ç†ç¨‹åºï¼Œè¿™é‡Œä¼šè‡ªåŠ¨é‡å¯è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ /* Did we come from a system call? */ if (syscall_get_nr(current, regs) != -1) &#123; /* Restart the system call - no handlers present */ switch (syscall_get_error(current, regs)) &#123; case -ERESTARTNOHAND: case -ERESTARTSYS: case -ERESTARTNOINTR: regs-&gt;ax = regs-&gt;orig_ax; regs-&gt;ip -= 2; break; case -ERESTART_RESTARTBLOCK: regs-&gt;ax = get_nr_restart_syscall(regs); regs-&gt;ip -= 2; break; &#125; &#125; restore_saved_sigmask();&#125; è¿™ä¸ªå‡½æ•°ä¸­çš„ifè¯­å¥ä½“ï¼Œçœ‹ä¸Šå»æ˜¯å¦‚æœæœ‰ä¿¡å·ï¼Œåˆ™å¤„ç†è¿™ä¸ªä¿¡å·ï¼Œå…¶å®ä¸å®Œå…¨æ˜¯è¿™æ ·çš„ã€‚å¦‚æœè¯¥è¿›ç¨‹æ²¡æœ‰å¯¹è¿™ä¸ªä¿¡å·è®¾ç½®å¤„ç†ç¨‹åºï¼Œåˆ™ä¼šæ‰§è¡Œé»˜è®¤çš„ä¿¡å·å¤„ç†ï¼Œè¿™é‡Œçš„å¤„ç†è¿‡ç¨‹æ˜¯åœ¨get_signalä¸­å®Œæˆçš„ï¼Œæˆ‘å½“æ—¶åœ¨çœ‹è¿™å—æºç çš„æ—¶å€™è¿˜åœ¨ç–‘æƒ‘ä¸ºä»€ä¹ˆæ‰¾ä¸åˆ°ä¿¡å·é»˜è®¤å¤„ç†çš„åœ°æ–¹ï¼Œç»“æœæ˜¯è¿™ä¸ªå‡½æ•°çš„åå­—è¯¯å¯¼äº†æˆ‘ã€‚å¦‚æœè¯¥è¿›ç¨‹æ²¡æœ‰å¯¹è¿™ä¸ªä¿¡å·è®¾ç½®å¤„ç†ç¨‹åºï¼Œåˆ™ä¼šè‡ªåŠ¨é‡å¯è¿™ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œè¿™é‡Œå°±ä¸å±•å¼€è¯´äº†ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹get_signalå‡½æ•°æ˜¯æ€ä¹ˆå®ç°çš„ï¼Œå®ƒè¢«å®ç°åœ¨kernel/signal.cä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122bool get_signal(struct ksignal *ksig)&#123; struct sighand_struct *sighand = current-&gt;sighand; struct signal_struct *signal = current-&gt;signal; int signr; ...relock: spin_lock_irq(&amp;sighand-&gt;siglock); //å¦‚æœå­è¿›ç¨‹çš„çŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œå‘é€SIGCHLDä¿¡å·ç»™çˆ¶è¿›ç¨‹ if (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123; int why; if (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED) why = CLD_CONTINUED; else why = CLD_STOPPED; signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK; spin_unlock_irq(&amp;sighand-&gt;siglock); read_lock(&amp;tasklist_lock); do_notify_parent_cldstop(current, false, why); if (ptrace_reparented(current-&gt;group_leader)) do_notify_parent_cldstop(current-&gt;group_leader, true, why); read_unlock(&amp;tasklist_lock); goto relock; &#125; for (;;) &#123; struct k_sigaction *ka; enum pid_type type; ... //ä»è¿›ç¨‹task_structçš„pendingé˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªä¿¡å· type = PIDTYPE_PID; signr = dequeue_synchronous_signal(&amp;ksig-&gt;info); if (!signr) signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info, &amp;type); if (!signr) break; /* will return 0 */ ... //ä»ä¿¡å·å¤„ç†æ•°ç»„ä¸­ï¼Œå–å‡ºå¯¹åº”ä¿¡å·çš„å¤„ç†åŠ¨ä½œ ka = &amp;sighand-&gt;action[signr-1]; if (ka-&gt;sa.sa_handler == SIG_IGN) /* Do nothing. */ continue; if (ka-&gt;sa.sa_handler != SIG_DFL) &#123; /* Run the handler. */ ksig-&gt;ka = *ka; //å¦‚æœè®¾ç½®äº†SA_RESETHANDæˆ–è€…SA_ONESHOTæ ‡å¿—ï¼ˆè¿™ä¿©æ ‡å¿—çš„å€¼æ˜¯ä¸€æ ·çš„ï¼‰ï¼Œå°†å…¶ä¿¡å·å¤„ç†å‡½æ•°é‡è®¾ä¸ºé»˜è®¤ if (ka-&gt;sa.sa_flags &amp; SA_ONESHOT) ka-&gt;sa.sa_handler = SIG_DFL; break; /* will return non-zero \"signr\" value */ &#125; //ä¸‹é¢ä¸ºé»˜è®¤ä¿¡å·å¤„ç† //éƒ¨åˆ†ä¿¡å·çš„é»˜è®¤åŠ¨ä½œä¸ºå¿½ç•¥ï¼ˆå…·ä½“å¯ä»¥æŸ¥çœ‹SIG_KERNEL_IGNORE_MASKè¿™ä¸ªå®å®šä¹‰ï¼‰ if (sig_kernel_ignore(signr)) /* Default is nothing. */ continue; ... //éƒ¨åˆ†ä¿¡å·çš„é»˜è®¤åŠ¨ä½œä¸ºåœæ­¢è¿›ç¨‹ï¼ˆå…·ä½“å¯ä»¥æŸ¥çœ‹SIG_KERNEL_STOP_MASKè¿™ä¸ªå®å®šä¹‰ï¼‰ if (sig_kernel_stop(signr)) &#123; if (signr != SIGSTOP) &#123; spin_unlock_irq(&amp;sighand-&gt;siglock); //å½“å‰ä¸ºå­¤å„¿è¿›ç¨‹ç»„ if (is_current_pgrp_orphaned()) goto relock; spin_lock_irq(&amp;sighand-&gt;siglock); &#125; //é»˜è®¤åŠ¨ä½œä¸ºåœæ­¢å½“å‰çº¿ç¨‹ç»„é‡Œçš„æ‰€æœ‰çº¿ç¨‹ if (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123; goto relock; &#125; continue; &#125; fatal: spin_unlock_irq(&amp;sighand-&gt;siglock); ... current-&gt;flags |= PF_SIGNALED; //éƒ¨åˆ†ä¿¡å·çš„é»˜è®¤åŠ¨ä½œä¸ºdump coreï¼Œç„¶åç»ˆæ­¢è¿›ç¨‹ï¼ˆå…·ä½“å¯ä»¥æŸ¥çœ‹SIG_KERNEL_COREDUMP_MASKè¿™ä¸ªå®å®šä¹‰ï¼‰ if (sig_kernel_coredump(signr)) &#123; if (print_fatal_signals) print_fatal_signal(ksig-&gt;info.si_signo); proc_coredump_connector(current); do_coredump(&amp;ksig-&gt;info); &#125; if (current-&gt;flags &amp; PF_IO_WORKER) goto out; //å‰©ä¸‹æ¥çš„ä¿¡å·çš„é»˜è®¤æ“ä½œä¸ºç»ˆæ­¢è¿›ç¨‹ do_group_exit(ksig-&gt;info.si_signo); &#125; spin_unlock_irq(&amp;sighand-&gt;siglock);out: ksig-&gt;sig = signr; if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_EXPOSE_TAGBITS)) hide_si_addr_tag_bits(ksig); //å½“å½“å‰è¿›ç¨‹å¯¹æ­¤ä¿¡å·è®¾ç½®äº†è‡ªå®šä¹‰ä¿¡å·å¤„ç†åŠ¨ä½œåï¼Œè¿”å›true return ksig-&gt;sig &gt; 0;&#125; likely &amp; unlikelyè¿™é‡Œçš„likelyå’Œunlikelyä¸ºä¸¤ä¸ªå®ï¼ŒæŒ‡å‘__builtin_expectå‡½æ•°ï¼Œæ˜¯gccç¼–è¯‘å™¨æä¾›ç»™ç¨‹åºå‘˜ä¼˜åŒ–çš„ä¸€ç§æ–¹å¼ï¼Œlikelyè¡¨ç¤ºè¡¨è¾¾å¼ä¸ºçœŸçš„å¯èƒ½æ€§æ›´å¤§ï¼Œunlikelyè¡¨ç¤ºè¡¨è¾¾å¼ä¸ºå‡çš„å¯èƒ½æ€§æ›´å¤§ï¼Œè¿™æ ·gccç¼–è¯‘å™¨å¯ä»¥åœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œå°†å¯èƒ½æ€§æ›´å¤§çš„ä»£ç ç´§è·Ÿå‰é¢çš„ä»£ç ï¼Œå‡å°‘æŒ‡ä»¤è·³è½¬å¸¦æ¥çš„æ€§èƒ½å¼€é”€ æˆ‘ä»¬æ¥ç€çœ‹ï¼Œå½“ç”¨æˆ·è‡ªå®šä¹‰äº†ä¿¡å·å¤„ç†å‡½æ•°åï¼Œå†…æ ¸æ˜¯æ€ä¹ˆå¤„ç†çš„ã€‚ä»ä¸Šé¢çš„ä»£ç çœ‹æ¥ï¼Œå½“ç”¨æˆ·è‡ªå®šä¹‰äº†ä¿¡å·å¤„ç†å‡½æ•°ï¼Œget_signalå‡½æ•°ä¼šè¿”å›trueï¼Œç´§æ¥ç€å°±ä¼šè¿›å…¥åˆ°handle_signalå‡½æ•°ä¸­ï¼Œè¿™é‡Œçš„å¤„ç†æ¯”è¾ƒç‰¹æ®Šï¼Œæˆ‘ä»¬è¦å…ˆäº†è§£ä¿¡å·å¤„ç†çš„ä¸€äº›è¿‡ç¨‹ ç”¨æˆ·è‡ªå®šä¹‰ä¿¡å·å¤„ç†å‡½æ•°å®é™…ä¸Šæ˜¯åœ¨ç”¨æˆ·ç©ºé—´æ‰§è¡Œçš„ï¼Œç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢ç”¨æˆ·åˆ©ç”¨å†…æ ¸ç©ºé—´çš„ring 0ç‰¹æƒç­‰çº§åšä¸€äº›æ„æƒ³ä¸åˆ°çš„äº‹ï¼Œå¤„ç†è¿‡ç¨‹å¦‚ä¸‹ä¸¤å›¾æ‰€ç¤ºï¼š æ•´ä¸ªè¿‡ç¨‹å¦‚å›¾ä¸­æ‰€è§ï¼Œè¿›ç¨‹ç”±äºç³»ç»Ÿè°ƒç”¨æˆ–ä¸­æ–­è¿›å…¥å†…æ ¸ç©ºé—´ï¼Œåœ¨å†…æ ¸ç©ºé—´å®Œæˆå·¥ä½œåè¿”å›ç”¨æˆ·ç©ºé—´çš„å‰å¤•ï¼Œæ£€æŸ¥ä¿¡å·é˜Ÿåˆ—ï¼Œå¦‚æœæ£€æŸ¥æœ‰ä¿¡å·å¹¶ä¸”æœ‰è‡ªå®šä¹‰çš„ä¿¡å·å¤„ç†å‡½æ•°ï¼Œè¿”å›åˆ°ç”¨æˆ·ç©ºé—´æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œå¤„ç†å®Œåå†è¿”å›å†…æ ¸ç©ºé—´ï¼Œæœ€åå†å›åˆ°ç”¨æˆ·ç©ºé—´ä¹‹å‰ä»£ç æ‰§è¡Œåˆ°çš„åœ°æ–¹ç»§ç»­è¿è¡Œ å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸€å¥—æµç¨‹ç»å†äº†4æ¬¡ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢ï¼Œæ¯”è¾ƒå¤æ‚ï¼Œé‚£ä¹ˆå†…æ ¸æ˜¯å¦‚ä½•åšåˆ°çš„å‘¢ï¼Ÿä¸ºä»€ä¹ˆä¿¡å·å¤„ç†å‡½æ•°æ‰§è¡Œå®Œåè¿˜è¦è¿”å›å†…æ ¸ç©ºé—´å‘¢ï¼Ÿ ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢åœ¨Linuxä¸­ï¼Œåœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€è¿è¡Œçš„è¿›ç¨‹ä½¿ç”¨çš„æ˜¯ä¸åŒçš„æ ˆï¼Œåˆ†åˆ«ä¸ºç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆï¼Œå½“ä¸€ä¸ªè¿›ç¨‹é™·å…¥å†…æ ¸æ€æ—¶ï¼Œéœ€è¦å°†ç”¨æˆ·æ ˆçš„ä¿¡æ¯ä¿å­˜åˆ°å†…æ ¸æ ˆä¸­ï¼Œå…·ä½“çš„ï¼Œä¼šå°†ss, sp, flags, cs, ipç­‰å€¼ä¾æ¬¡å‹å…¥æ ˆä¸­ï¼Œä¿å­˜ä¸ºpt_regsç»“æ„ï¼Œç„¶åè®¾ç½®CPUå †æ ˆå¯„å­˜å™¨çš„åœ°å€ä¸ºå†…æ ¸æ ˆé¡¶ï¼Œè¿™æ ·ï¼Œåç»­ä½¿ç”¨çš„æ ˆä¾¿å˜æˆäº†å†…æ ¸æ ˆï¼Œå½“ç³»ç»Ÿè°ƒç”¨ç»“æŸï¼Œéœ€è¦ä»å†…æ ¸æ€åˆ‡æ¢åˆ°ç”¨æˆ·æ€æ—¶ï¼Œå†å°†ä¹‹å‰å‹å…¥æ ˆä¸­çš„å¯„å­˜å™¨å€¼å¼¹å‡ºï¼Œå°†pt_regsä¸­ä¿å­˜çš„å€¼æ¢å¤åˆ°ç›¸åº”çš„å¯„å­˜å™¨ä¸­ï¼Œè¿™é‡Œæ”¹å˜äº†spå¯„å­˜å™¨çš„å€¼ï¼Œå³å®Œæˆäº†æ¢æ ˆï¼Œcs:ipè¿™ä¸¤ä¸ªå¯„å­˜å™¨åˆ†åˆ«æŒ‡å‘ç”¨æˆ·æ€ä»£ç æ®µä»¥åŠç”¨æˆ·æ€æŒ‡ä»¤æŒ‡é’ˆï¼Œåç»­CPUä¾¿ä¼šæ‰§è¡Œä¹‹å‰ç”¨æˆ·æ€çš„ä»£ç äº† pt_regsç»“æ„ä½“pt_regsç»“æ„ä½“ä½äºarch/x86/include/asm/ptrace.hä¸­ 12345678910111213141516171819202122232425262728293031323334struct pt_regs &#123;/* * C ABI says these regs are callee-preserved. They aren't saved on kernel entry * unless syscall needs a complete, fully filled \"struct pt_regs\". */ unsigned long r15; unsigned long r14; unsigned long r13; unsigned long r12; unsigned long bp; unsigned long bx;/* These regs are callee-clobbered. Always saved on kernel entry. */ unsigned long r11; unsigned long r10; unsigned long r9; unsigned long r8; unsigned long ax; unsigned long cx; unsigned long dx; unsigned long si; unsigned long di;/* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it's IRQ number: */ unsigned long orig_ax;/* Return frame for iretq */ unsigned long ip; unsigned long cs; unsigned long flags; unsigned long sp; unsigned long ss;/* top of stack page */&#125;; æˆ‘ä»¬ä»ç†è®ºè§’åº¦ä¸Šå¤§æ¦‚ç†è§£äº†å†…æ ¸æ˜¯æ€ä¹ˆåœ¨ç”¨æˆ·æ€ä¸å†…æ ¸æ€ä¹‹é—´åˆ‡æ¢çš„ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å»æºç é‡ŒéªŒè¯ä¸€ä¸‹æ˜¯ä¸æ˜¯æˆ‘ä»¬æ‰€æƒ³çš„è¿™æ ·ï¼Œsyscallçš„å…¥å£å‡½æ•°ä¸ºentry_SYSCALL_64ï¼Œä½äºarch/x86/entry/entry_64.Sä¸­ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980SYM_CODE_START(entry_SYSCALL_64) UNWIND_HINT_EMPTY /* åˆ‡æ¢gså¯„å­˜å™¨è‡³å†…æ ¸æ€ */ swapgs /* tss.sp2ä¸ºç”¨æˆ·æ ˆ */ movq %rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2) /* åˆ‡æ¢é¡µè¡¨ */ SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp /* åˆ‡æ¢è‡³å†…æ ¸æ ˆ */ movq PER_CPU_VAR(cpu_current_top_of_stack), %rspSYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL) /* ä¿å­˜ç”¨æˆ·æ ˆå¯„å­˜å™¨å€¼è‡³pt_regsç»“æ„ä¸­ */ pushq $__USER_DS /* pt_regs-&gt;ss */ pushq PER_CPU_VAR(cpu_tss_rw + TSS_sp2) /* pt_regs-&gt;sp */ /* å½“æ‰§è¡ŒsyscallæŒ‡ä»¤æ—¶ï¼Œcpuä¼šå°†rflagsçš„å€¼ä¿å­˜åœ¨r11å¯„å­˜å™¨ä¸­ */ pushq %r11 /* pt_regs-&gt;flags */ pushq $__USER_CS /* pt_regs-&gt;cs */ /* å½“æ‰§è¡ŒsyscallæŒ‡ä»¤æ—¶ï¼Œcpuä¼šå°†syscallæŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ä¼ ç»™rcxå¯„å­˜å™¨ */ pushq %rcx /* pt_regs-&gt;ip */SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL) pushq %rax /* pt_regs-&gt;orig_ax */ /* ä¿å­˜å¹¶æ¸…é™¤å¯„å­˜å™¨ */ PUSH_AND_CLEAR_REGS rax=$-ENOSYS /* æ­¤æ—¶ï¼ŒrspæŒ‡å‘çš„æ ˆé¡¶åœ°å€å³ä¸ºpt_regsçš„åœ°å€ */ movq %rsp, %rdi /* è®¾ç½®ç³»ç»Ÿè°ƒç”¨å· */ movslq %eax, %rsi /* ä»¥rdi, rsiä½œä¸ºå‚æ•°ï¼Œè°ƒç”¨do_syscall_64å‡½æ•° */ call do_syscall_64 /* returns with IRQs disabled */ ... cmpq %rcx, %r11 jne swapgs_restore_regs_and_return_to_usermode cmpq $__USER_CS, CS(%rsp) /* CS must match SYSRET */ jne swapgs_restore_regs_and_return_to_usermode movq R11(%rsp), %r11 cmpq %r11, EFLAGS(%rsp) /* R11 == RFLAGS */ jne swapgs_restore_regs_and_return_to_usermode testq $(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11 jnz swapgs_restore_regs_and_return_to_usermode cmpq $__USER_DS, SS(%rsp) /* SS must match SYSRET */ jne swapgs_restore_regs_and_return_to_usermode /* * è¿™ä¸ªæ ‡ç­¾å®é™…ä¸Šåªæ˜¯ä¸ºäº†ä¾¿äºç†è§£ï¼Œå¹¶æ²¡æœ‰åœ°æ–¹è·³è½¬å®ƒ * å®é™…å·¥ä½œæ˜¯åœ¨swapgs_restore_regs_and_return_to_usermodeä¸­å®Œæˆçš„ */syscall_return_via_sysret: /* æ¢å¤å¯„å­˜å™¨ */ POP_REGS pop_rdi=0 skip_r11rcx=1 movq %rsp, %rdi /* ä¿å­˜å†…æ ¸æ ˆ */ movq PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp UNWIND_HINT_EMPTY pushq RSP-RDI(%rdi) /* RSP */ pushq (%rdi) /* RDI */ STACKLEAK_ERASE_NOCLOBBER /* åˆ‡æ¢é¡µè¡¨ */ SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi popq %rdi popq %rsp /* åˆ‡æ¢gså¯„å­˜å™¨è‡³ç”¨æˆ·æ€ */ swapgs /* æ¢å¤rip, rflagsç­‰å¯„å­˜å™¨ï¼Œä½¿cpuæ¥ä¸‹æ¥è¦æ‰§è¡ŒæŒ‡ä»¤æŒ‡å‘syscallçš„ä¸‹ä¸€æ¡æŒ‡ä»¤ */ sysretqSYM_CODE_END(entry_SYSCALL_64) ä¿¡å·å¤„ç†å‡½æ•°çš„è·³è½¬æ–¹å¼ä½†æ˜¯åœ¨ç³»ç»Ÿè°ƒç”¨å®Œåï¼Œå›åˆ°çš„å°†æ˜¯syscallåçš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œé‚£ä¹ˆå¦‚ä½•æ‰èƒ½è®©ç¨‹åºå»æ‰§è¡Œä¿¡å·å¤„ç†å‡½æ•°å‘¢ï¼Ÿä¿¡å·å¤„ç†å‡½æ•°æ‰§è¡Œå®Œåï¼Œåˆå¦‚ä½•å›åˆ°ä¹‹å‰æ‰€æ‰§è¡Œåˆ°çš„ä»£ç å‘¢ï¼Ÿæˆ‘ä»¬å¾ˆå®¹æ˜“å°±èƒ½æƒ³åˆ°ï¼Œå…ˆå°†pt_regsä¸­çš„å€¼å¤‡ä»½ä¸€ä¸‹ï¼Œç„¶åæ”¹å˜pt_regsä¸­ä¸€äº›å¯„å­˜å™¨å€¼ï¼Œæ¯”å¦‚è¯´å°†cs:ipä¿®æ”¹æˆä¿¡å·å¤„ç†å‡½æ•°å¯¹åº”åœ°å€ï¼Œè¿™æ ·ä»å†…æ ¸æ€è¿”å›åï¼Œå°±ä¼šè‡ªåŠ¨è·³è½¬åˆ°ä¿¡å·å¤„ç†å‡½æ•°äº†ï¼Œç­‰åˆ°ä¿¡å·å¤„ç†å‡½æ•°æ‰§è¡Œå®Œï¼Œå†è¿›å…¥å†…æ ¸æ€ï¼Œæ¢å¤pt_regsä¸­çš„å€¼åå›åˆ°ç”¨æˆ·æ€ï¼Œè¿™æ ·cpuåˆä¼šä»ç”¨æˆ·è°ƒç”¨syscallåçš„æŒ‡ä»¤å¼€å§‹æ­£å¸¸æ‰§è¡Œäº† æˆ‘ä»¬å…·ä½“çš„çœ‹ä¸€ä¸‹å†…æ ¸ä»£ç æ˜¯æ€ä¹ˆåšçš„ï¼Œè¿™é‡Œçš„é€»è¾‘åœ¨arch/x86/kernel/signal.cä¸­çš„handle_signalå‡½æ•°é‡Œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147static voidhandle_signal(struct ksignal *ksig, struct pt_regs *regs)&#123; ... failed = (setup_rt_frame(ksig, regs) &lt; 0); ... signal_setup_done(failed, ksig, stepping);&#125;static intsetup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)&#123; int usig = ksig-&gt;sig; sigset_t *set = sigmask_to_save(); compat_sigset_t *cset = (compat_sigset_t *) set; /* Perform fixup for the pre-signal frame. */ rseq_signal_deliver(ksig, regs); //è®¾ç½®æ ˆå¸§ if (is_ia32_frame(ksig)) &#123; if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) return ia32_setup_rt_frame(usig, ksig, cset, regs); else return ia32_setup_frame(usig, ksig, cset, regs); &#125; else if (is_x32_frame(ksig)) &#123; return x32_setup_rt_frame(ksig, cset, regs); &#125; else &#123; return __setup_rt_frame(ksig-&gt;sig, ksig, set, regs); &#125;&#125;//x86_64æ‰§è¡Œçš„åº”è¯¥æ˜¯è¿™ä¸ªå‡½æ•°static int __setup_rt_frame(int sig, struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)&#123; struct rt_sigframe __user *frame; void __user *fp = NULL; unsigned long uc_flags; /* x86-64 should always use SA_RESTORER. */ if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER)) return -EFAULT; //è·å–ä¸€ä¸ªæ ˆå¸§ frame = get_sigframe(&amp;ksig-&gt;ka, regs, sizeof(struct rt_sigframe), &amp;fp); uc_flags = frame_uc_flags(regs); if (!user_access_begin(frame, sizeof(*frame))) return -EFAULT; /* Create the ucontext. */ unsafe_put_user(uc_flags, &amp;frame-&gt;uc.uc_flags, Efault); unsafe_put_user(0, &amp;frame-&gt;uc.uc_link, Efault); unsafe_save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp, Efault); /* Set up to return from userspace. If provided, use a stub already in userspace. */ //è®¾ç½®æ‰§è¡Œå®Œä¿¡å·å¤„ç†å‡½æ•°åï¼Œè¦è·³å›çš„åœ°å€ï¼Œå³sa_restorer unsafe_put_user(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode, Efault); //å°†åŸæœ¬çš„pt_regså¤‡ä»½ä¿å­˜è‡³frame.uc.uc_mcontextä¸­ unsafe_put_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, set, Efault); unsafe_put_sigmask(set, frame, Efault); user_access_end(); if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) &#123; if (copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info)) return -EFAULT; &#125; //ä¿¡å·å¤„ç†å‡½æ•°çš„ç¬¬1ä¸ªå‚æ•° regs-&gt;di = sig; /* In case the signal handler was declared without prototypes */ regs-&gt;ax = 0; /* è®¾ç½®äº†SA_SIGINFOæ ‡å¿—ä½ï¼Œéœ€è¦å¸¦ä¸€äº›é¢å¤–çš„ä¿¡å·ä¿¡æ¯ */ //ä¿¡å·å¤„ç†å‡½æ•°çš„ç¬¬2ä¸ªå‚æ•° regs-&gt;si = (unsigned long)&amp;frame-&gt;info; //ä¿¡å·å¤„ç†å‡½æ•°çš„ç¬¬3ä¸ªå‚æ•° regs-&gt;dx = (unsigned long)&amp;frame-&gt;uc; //è®¾ç½®æŒ‡ä»¤æŒ‡é’ˆæŒ‡å‘ä¿¡å·å¤„ç†å‡½æ•° //sigactionç»“æ„ä½“ä¸­çš„ç¬¬ä¸€ä¸ªåŸŸæ˜¯ä¸€ä¸ªè”åˆï¼Œæ‰€ä»¥è¿™é‡Œ //sa_handlerå’Œsa_sigactionçš„åœ°å€æ˜¯ç›¸åŒçš„ regs-&gt;ip = (unsigned long) ksig-&gt;ka.sa.sa_handler; //è®¾ç½®æ ˆé¡¶åœ°å€ regs-&gt;sp = (unsigned long)frame; //è®¾ç½®ç”¨æˆ·ä»£ç æ®µ regs-&gt;cs = __USER_CS; if (unlikely(regs-&gt;ss != __USER_DS)) force_valid_ss(regs); return 0;Efault: user_access_end(); return -EFAULT;&#125;#define unsafe_put_sigcontext(sc, fp, regs, set, label) \\do &#123; \\ if (__unsafe_setup_sigcontext(sc, fp, regs, set-&gt;sig[0])) \\ goto label; \\&#125; while(0);static __always_inline int__unsafe_setup_sigcontext(struct sigcontext __user *sc, void __user *fpstate, struct pt_regs *regs, unsigned long mask)&#123; unsafe_put_user(regs-&gt;di, &amp;sc-&gt;di, Efault); unsafe_put_user(regs-&gt;si, &amp;sc-&gt;si, Efault); unsafe_put_user(regs-&gt;bp, &amp;sc-&gt;bp, Efault); unsafe_put_user(regs-&gt;sp, &amp;sc-&gt;sp, Efault); unsafe_put_user(regs-&gt;bx, &amp;sc-&gt;bx, Efault); unsafe_put_user(regs-&gt;dx, &amp;sc-&gt;dx, Efault); unsafe_put_user(regs-&gt;cx, &amp;sc-&gt;cx, Efault); unsafe_put_user(regs-&gt;ax, &amp;sc-&gt;ax, Efault); unsafe_put_user(regs-&gt;r8, &amp;sc-&gt;r8, Efault); unsafe_put_user(regs-&gt;r9, &amp;sc-&gt;r9, Efault); unsafe_put_user(regs-&gt;r10, &amp;sc-&gt;r10, Efault); unsafe_put_user(regs-&gt;r11, &amp;sc-&gt;r11, Efault); unsafe_put_user(regs-&gt;r12, &amp;sc-&gt;r12, Efault); unsafe_put_user(regs-&gt;r13, &amp;sc-&gt;r13, Efault); unsafe_put_user(regs-&gt;r14, &amp;sc-&gt;r14, Efault); unsafe_put_user(regs-&gt;r15, &amp;sc-&gt;r15, Efault); unsafe_put_user(current-&gt;thread.trap_nr, &amp;sc-&gt;trapno, Efault); unsafe_put_user(current-&gt;thread.error_code, &amp;sc-&gt;err, Efault); unsafe_put_user(regs-&gt;ip, &amp;sc-&gt;ip, Efault); unsafe_put_user(regs-&gt;flags, &amp;sc-&gt;flags, Efault); unsafe_put_user(regs-&gt;cs, &amp;sc-&gt;cs, Efault); unsafe_put_user(0, &amp;sc-&gt;gs, Efault); unsafe_put_user(0, &amp;sc-&gt;fs, Efault); unsafe_put_user(regs-&gt;ss, &amp;sc-&gt;ss, Efault); unsafe_put_user(fpstate, (unsigned long __user *)&amp;sc-&gt;fpstate, Efault); /* non-iBCS2 extensions.. */ unsafe_put_user(mask, &amp;sc-&gt;oldmask, Efault); unsafe_put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2, Efault); return 0;Efault: return -EFAULT;&#125; è¿™é‡Œå®é™…ä¸Šæ˜¯è¿™ä¹ˆåšçš„ï¼Œé¦–å…ˆï¼Œå†…æ ¸é»˜è®¤åœ¨ç”¨æˆ·æ ˆä¸Šåˆ†é…äº†ä¸€ä¸ªæ ˆå¸§ï¼ˆå¦‚æœè®¾ç½®äº†å¤‡ç”¨æ ˆçš„è¯ï¼Œåˆ™ä¼šåœ¨å¤‡ç”¨æ ˆä¸Šåˆ†é…ï¼‰ï¼Œå°†pt_regså¤‡ä»½åˆ°è¿™ä¸ªæ ˆå¸§ä¸Šï¼Œç”¨äºåç»­æ¢å¤ï¼Œç„¶åè®¾ç½®pt_regsï¼Œæ”¹å˜å…¶sp, cs, ipç­‰å€¼ï¼Œä½¿ç¨‹åºä»å†…æ ¸æ€è¿”å›æ—¶ï¼Œå¯ä»¥è·³è½¬åˆ°ä¿¡å·å¤„ç†å‡½æ•°å¯¹åº”çš„æ ˆå’Œä»£ç æŒ‡ä»¤åœ°å€ï¼Œå½“ä¿¡å·å¤„ç†å‡½æ•°è¿”å›æ—¶ä¼šæ‰§è¡Œsigreturnç³»ç»Ÿè°ƒç”¨å†è¿›å…¥å†…æ ¸æ€ï¼Œå°†ä¹‹å‰å¤‡ä»½åˆ°æ ˆå¸§ä¸­çš„å¯„å­˜å™¨å€¼é‡æ–°æ¢å¤åˆ°pt_regsä¸­ï¼Œç„¶åå†ä»å†…æ ¸æ€å›åˆ°ç”¨æˆ·æ€å°±å¯ä»¥æ­£å¸¸ç»§ç»­æ‰§è¡Œsyscallåé¢çš„ä»£ç äº† å…¶ä¸­sa_restoreræ˜¯åœ¨glibcé‡Œçš„__libc_sigactionå‡½æ•°ä¸­è¢«è®¾ç½®çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041int__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)&#123; int result; struct kernel_sigaction kact, koact; if (act) &#123; kact.k_sa_handler = act-&gt;sa_handler; memcpy (&amp;kact.sa_mask, &amp;act-&gt;sa_mask, sizeof (sigset_t)); kact.sa_flags = act-&gt;sa_flags; //è®¾ç½®sa_restorer SET_SA_RESTORER (&amp;kact, act); &#125; ... return result;&#125;extern void restore_rt (void) asm (\"__restore_rt\") attribute_hidden;#define SET_SA_RESTORER(kact, act) \\ (kact)-&gt;sa_flags = (act)-&gt;sa_flags | SA_RESTORER; \\ (kact)-&gt;sa_restorer = &amp;restore_rt RESTORE (restore_rt, __NR_rt_sigreturn)#define RESTORE(name, syscall) RESTORE2 (name, syscall)#define RESTORE2(name, syscall) \\asm \\ ( \\ /* `nop' for debuggers assuming `call' should not disalign the code. */ \\ \" nop\\n\" \\ \".align 16\\n\" \\ \".LSTART_\" #name \":\\n\" \\ \" .type __\" #name \",@function\\n\" \\ \"__\" #name \":\\n\" \\ \" movq $\" #syscall \", %rax\\n\" \\ \" syscall\\n\" \\ ... ); å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œä¹Ÿæ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå’Œä¸Šé¢æ‰€è¯´çš„è§„åˆ™ä¸€æ ·ï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨sys_rt_sigreturnå‡½æ•°ï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SYSCALL_DEFINE0(rt_sigreturn)&#123; struct pt_regs *regs = current_pt_regs(); struct rt_sigframe __user *frame; sigset_t set; unsigned long uc_flags; frame = (struct rt_sigframe __user *)(regs-&gt;sp - sizeof(long)); if (!access_ok(frame, sizeof(*frame))) goto badframe; if (__get_user(*(__u64 *)&amp;set, (__u64 __user *)&amp;frame-&gt;uc.uc_sigmask)) goto badframe; if (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags)) goto badframe; set_current_blocked(&amp;set); //frame.uc.uc_mcontextä¸­æ¢å¤pt_regs if (!restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags)) goto badframe; if (restore_altstack(&amp;frame-&gt;uc.uc_stack)) goto badframe; return regs-&gt;ax;badframe: signal_fault(regs, frame, \"rt_sigreturn\"); return 0;&#125;static bool restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *usc, unsigned long uc_flags)&#123; struct sigcontext sc; /* Always make any pending restarted system calls return -EINTR */ current-&gt;restart_block.fn = do_no_restart_syscall; if (copy_from_user(&amp;sc, usc, CONTEXT_COPY_SIZE)) return false; regs-&gt;bx = sc.bx; regs-&gt;cx = sc.cx; regs-&gt;dx = sc.dx; regs-&gt;si = sc.si; regs-&gt;di = sc.di; regs-&gt;bp = sc.bp; regs-&gt;ax = sc.ax; regs-&gt;sp = sc.sp; regs-&gt;ip = sc.ip; regs-&gt;r8 = sc.r8; regs-&gt;r9 = sc.r9; regs-&gt;r10 = sc.r10; regs-&gt;r11 = sc.r11; regs-&gt;r12 = sc.r12; regs-&gt;r13 = sc.r13; regs-&gt;r14 = sc.r14; regs-&gt;r15 = sc.r15; /* Get CS/SS and force CPL3 */ regs-&gt;cs = sc.cs | 0x03; regs-&gt;ss = sc.ss | 0x03; regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (sc.flags &amp; FIX_EFLAGS); /* disable syscall checks */ regs-&gt;orig_ax = -1; ... return fpu__restore_sig((void __user *)sc.fpstate, IS_ENABLED(CONFIG_X86_32));&#125; ä»ä¸Šé¢ä»£ç è¿˜æ˜¯å¯ä»¥æ¯”è¾ƒæ¸…æ¥šçš„çœ‹å‡ºæ¥ï¼Œå’Œæˆ‘ä»¬ä¹‹å‰æè¿°çš„åŸç†åŸºæœ¬ä¸€è‡´ï¼Œåˆ°è¿™ä¸€æ­¥æ—¶ï¼Œæ¢å¤pt_regsä¸­çš„å€¼ï¼Œè¿™æ ·åç»­è¿”å›ç”¨æˆ·æ€åä¾¿å¯ä»¥æ­£å¸¸ç»§ç»­è¿è¡Œåé¢çš„ç”¨æˆ·ä»£ç äº† æ€»ç»“Linuxä¿¡å·çš„åŸç†åˆ†æåˆ°è¿™åŸºæœ¬ä¸Šä¹Ÿå°±ç»“æŸäº†ï¼Œå…¶å®æ•´ä¸ªä¿¡å·åŸç†åˆ†æå¯¹ç°é˜¶æ®µçš„æˆ‘æ¥è¯´ï¼Œè¿˜æ˜¯ä¸€ä»¶ç›¸å½“å…·æœ‰æŒ‘æˆ˜æ€§çš„äº‹æƒ…ï¼Œä¸è¿‡åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œè¿˜æ˜¯æ”¶è·äº†å¾ˆå¤šçŸ¥è¯†ï¼Œä¹Ÿå‘ç°äº†ä¸€äº›ä¹‹å‰æ–‡ç« é‡Œé”™æ¼çš„åœ°æ–¹ï¼Œç”±äºæˆ‘å¯¹Linuxå†…æ ¸ä»¥åŠæ±‡ç¼–å¹¶ä¸ç†Ÿæ‚‰ï¼Œæ‰€ä»¥éš¾å…ä¼šæœ‰ä¸€äº›åˆ†æé”™è¯¯æˆ–è€…ä¸åˆ°ä½çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æŒ‡æ­£ é™„å½•ä¿¡å·è¡¨å–å€¼ | åç§° | è§£é‡Š | é»˜è®¤åŠ¨ä½œ || â€“ | â€”â€”â€” | â€”â€”â€”â€”â€”- | â€”â€”â€”â€“ || 1 | SIGHUP | æŒ‚èµ· | ç»ˆæ­¢è¿›ç¨‹ || 2 | SIGINT | ä¸­æ–­ | ç»ˆæ­¢è¿›ç¨‹ || 4 | SIGILL | éæ³•æŒ‡ä»¤ | coredumpåç»ˆæ­¢è¿›ç¨‹ || 5 | SIGTRAP | æ–­ç‚¹æˆ–é™·é˜±æŒ‡ä»¤ | coredumpåç»ˆæ­¢è¿›ç¨‹ || 6 | SIGABRT/SIGIOT | abortå‘å‡ºçš„ä¿¡å· | coredumpåç»ˆæ­¢è¿›ç¨‹ || 7 | SIGBUS | éæ³•å†…å­˜è®¿é—® | coredumpåç»ˆæ­¢è¿›ç¨‹ || 8 | SIGFPE | æµ®ç‚¹å¼‚å¸¸ | coredumpåç»ˆæ­¢è¿›ç¨‹ || 9 | SIGKILL | killä¿¡å· | ä¸èƒ½è¢«å¿½ç•¥ã€å¤„ç†å’Œé˜»å¡ || 10 | SIGUSR1 | ç”¨æˆ·è‡ªå®šä¹‰ä¿¡å·1 | ç»ˆæ­¢è¿›ç¨‹ || 11 | SIGSEGV | æ— æ•ˆå†…å­˜è®¿é—® | coredumpåç»ˆæ­¢è¿›ç¨‹ || 12 | SIGUSR2 | ç”¨æˆ·è‡ªå®šä¹‰ä¿¡å·2 | ç»ˆæ­¢è¿›ç¨‹ || 13 | SIGPIPE | ç®¡é“ç ´æŸï¼Œæ²¡æœ‰è¯»ç«¯çš„ç®¡é“å†™æ•°æ® | ç»ˆæ­¢è¿›ç¨‹ || 14 | SIGALRM | alarmå‘å‡ºçš„ä¿¡å· | ç»ˆæ­¢è¿›ç¨‹ || 15 | SIGTERM | ç»ˆæ­¢ä¿¡å· | ç»ˆæ­¢è¿›ç¨‹ || 16 | SIGSTKFLT | æ ˆæº¢å‡º | ç»ˆæ­¢è¿›ç¨‹ || 17 | SIGCHLD | å­è¿›ç¨‹é€€å‡º | å¿½ç•¥ä¿¡å· || 18 | SIGCONT | è¿›ç¨‹ç»§ç»­ | å¿½ç•¥ä¿¡å· || 19 | SIGSTOP | è¿›ç¨‹åœæ­¢ | ä¸èƒ½è¢«å¿½ç•¥ã€å¤„ç†å’Œé˜»å¡ || 20 | SIGTSTP | è¿›ç¨‹åœæ­¢ | åœæ­¢è¿›ç¨‹ || 21 | SIGTTIN | è¿›ç¨‹åœæ­¢ï¼Œåå°è¿›ç¨‹ä»ç»ˆç«¯è¯»æ•°æ®æ—¶ | åœæ­¢è¿›ç¨‹ || 22 | SIGTTOU | è¿›ç¨‹åœæ­¢ï¼Œåå°è¿›ç¨‹æƒ³ç»ˆç«¯å†™æ•°æ®æ—¶ | åœæ­¢è¿›ç¨‹ || 23 | SIGURG | I/Oæœ‰ç´§æ€¥æ•°æ®åˆ°è¾¾å½“å‰è¿›ç¨‹ | å¿½ç•¥ä¿¡å· || 24 | SIGXCPU | è¿›ç¨‹çš„CPUæ—¶é—´ç‰‡åˆ°æœŸ | coredumpåç»ˆæ­¢è¿›ç¨‹ || 25 | SIGXFSZ | æ–‡ä»¶å¤§å°çš„è¶…å‡ºä¸Šé™ | coredumpåç»ˆæ­¢è¿›ç¨‹ || 26 | SIGVTALRM | è™šæ‹Ÿæ—¶é’Ÿè¶…æ—¶ | ç»ˆæ­¢è¿›ç¨‹ || 27 | SIGPROF | profileæ—¶é’Ÿè¶…æ—¶ | ç»ˆæ­¢è¿›ç¨‹ || 28 | SIGWINCH | çª—å£å¤§å°æ”¹å˜ | å¿½ç•¥ä¿¡å· || 29 | SIGPOLL/SIGIO | I/Oç›¸å…³ | ç»ˆæ­¢è¿›ç¨‹ || 30 | SIGPWR | å…³æœº | é»˜è®¤å¿½ç•¥ || 31 | SIGSYS/SIGUNUSED | ç³»ç»Ÿè°ƒç”¨å¼‚å¸¸ | coredumpåç»ˆæ­¢è¿›ç¨‹ | å‚è€ƒæ–‡çŒ® Linuxä¿¡å· é˜»å¡ä¿¡å· Linux Signal Linuxä¿¡å·(signal)æœºåˆ¶ linux ä¿¡å·å¤„ç†æœºåˆ¶ç®€ä»‹ [å†…æ ¸æºç ] Linux ç³»ç»Ÿè°ƒç”¨ï¼ˆx86_64ï¼‰ Linuxæ“ä½œç³»ç»Ÿå­¦ä¹ ç¬”è®°ï¼ˆåå…­ï¼‰è¿›ç¨‹é—´é€šä¿¡ä¹‹ä¿¡å· X86_64å¤„ç†å™¨ç³»ç»Ÿè°ƒç”¨æœºåˆ¶åœ¨linuxä¸Šçš„å®ç° linux kernel signalæœºåˆ¶ï¼ˆX86_64ï¼‰","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"ä¿¡å·","slug":"ä¿¡å·","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"}]},{"title":"Bç«™Androidé¢è¯•å°è®°","slug":"interview/Bç«™Androidé¢è¯•å°è®°","date":"2022-03-22T11:09:00.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2022/03/22/interview/Bç«™Androidé¢è¯•å°è®°/","link":"","permalink":"http://yoursite.com/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"èµ·å› çœ‹ç€æˆ‘åŒå­¦æœ€è¿‘ä¹Ÿåœ¨åˆ°å¤„æŠ•ç®€å†ï¼Œæˆ‘æƒ³ç€æˆ‘ä¹ŸæŠ•ä¸€ä¸‹çœ‹çœ‹è¡Œæƒ…ï¼Œäºæ˜¯åœ¨2022-02-28å·ï¼Œæˆ‘å‘Bç«™æŠ•å‡ºäº†ç¬¬ä¸€å°ç®€å†ï¼Œè¯´å®è¯å½“åˆåªæ˜¯æƒ³ç»ƒç»ƒæ‰‹ï¼Œæ²¡æƒ³åˆ°æœ€åæ¥äº†Bç«™çš„offerï¼Œä¹Ÿæ˜¯é€ åŒ–å¼„äººäº† ä¸€é¢æŠ€æœ¯é¢ï¼Œ45minå·¦å³ï¼ŒåŸºæœ¬å›´ç»•ä½ ç®€å†ä¸Šå†™çš„äº®ç‚¹å’Œä½ çš„å·¥ä½œç»å†å±•å¼€ è‡ªæˆ‘ä»‹ç» ä½ åœ¨é¡¹ç›®ä¸­è´Ÿè´£ä»€ä¹ˆ ç”¨è¿‡ä»€ä¹ˆè®¾è®¡æ¨¡å¼ï¼Œæˆ–åœ¨Androidä¸­å¸¸å¸¸ä¼šç¢°è§çš„è®¾è®¡æ¨¡å¼ å•ä¾‹æ¨¡å¼ï¼Œç­–ç•¥æ¨¡å¼ï¼Œè´£ä»»é“¾æ¨¡å¼ï¼ˆé—®äº†ä¸€ä¸‹ä½¿ç”¨åœºæ™¯ï¼‰ï¼Œå·¥å‚æ¨¡å¼ç­‰ Androidä¸­çš„è§‚å¯Ÿè€…æ¨¡å¼ï¼Œé€‚é…å™¨æ¨¡å¼ç­‰ æœ‰æ²¡æœ‰åšè¿‡ä»€ä¹ˆæ¯”è¾ƒæœ‰éš¾åº¦çš„æ¨¡å— camera2ï¼Œè‡ªå®šä¹‰ç…§ç‰‡è£å‰ªView ä½ å¯¹è‡ªå®šä¹‰Viewæœ‰ä»€ä¹ˆäº†è§£ å›ç­”äº†ä¸€äº›Pathç»˜åˆ¶ä»¥åŠè§¦æ‘¸äº‹ä»¶çš„å¤„ç† AndroidåŠ¨ç”» å±æ€§åŠ¨ç”»ï¼ŒObjectAnimator å¤šçº¿ç¨‹å¹¶å‘ï¼ˆé”ã€ä¿¡å·é‡ã€syncnorizedï¼‰ï¼Œsyncnorizedå¯¹è±¡å’Œclassæœ‰ä»€ä¹ˆåŒºåˆ« ConcurrentHashMapçº¿ç¨‹å®‰å…¨çš„åŸç† 1.8ä¹‹å‰ç”¨çš„åˆ†æ®µå¼é”ï¼Œ1.8ä¹‹åç”¨çš„synchronizedï¼Œè‡³äºå…·ä½“çš„ç»†èŠ‚æ²¡æœ‰ç­”ä¸Šæ¥ï¼Œå› ä¸ºç¡®å®ä¹Ÿæ²¡çœ‹è¿‡è¿™è¾¹æºç  jniï¼Œå¦‚ä½•å®šä½jniå´©æºƒ è¿™ä¸ªæˆ‘å½“æ—¶å›ç­”çš„æ˜¯æ‰“logï¼Œå› ä¸ºé¡¹ç›®ä¸­ç”¨åˆ°jniçš„åœ°æ–¹ç¡®å®ä¸å¤šï¼Œå½“ç„¶jniä¹Ÿæ˜¯å¯ä»¥æ–­ç‚¹è°ƒè¯•çš„ ä½ æ‰€å¼€å‘çš„åº”ç”¨æœ‰å¤šè¿›ç¨‹å—ï¼Ÿè¿›ç¨‹é—´æ˜¯æ€ä¹ˆé€šä¿¡çš„ è¿™ä¸ªæˆ‘å½“æ—¶åªå›ç­”äº†mmapï¼Œç¨å¾®èŠäº†ä¸€ä¸‹mmapåŸç†å’Œbinderæ€§èƒ½å¯¹æ¯”ï¼Œåæ¥å¤ç›˜æƒ³èµ·æ¥é¡¹ç›®ä¸­ç”¨åˆ°çš„Broadcastå’Œaidl binderé€šä¿¡éƒ½æ²¡æœ‰å›ç­” Webviewå’Œnativeæ€ä¹ˆäº¤äº’çš„ onUrlLoadingæ‹¦æˆªSchema æ³¨å†Œjsæ–¹æ³•ï¼ˆaddJavascriptInterfaceï¼‰ Androidç¼–è¯‘æ‰“åŒ…è¿‡ç¨‹ aapt -&gt; class -&gt; dex -&gt; ç­¾å æ’æ¡© ASMæ’æ¡©ï¼Œå­—èŠ‚ç æ“ä½œ æ€§èƒ½ç›‘æ§ å› ä¸ºæˆ‘ä¹‹å‰åšè¿‡ä¸€ä¸ªæ€§èƒ½ç›‘æ§åº“ï¼Œcpuå’Œmemä½¿ç”¨TOPå‘½ä»¤è§£æï¼ŒAnré€šè¿‡ç»™MainLooperè®¾ç½®Printer LeakCanaryåŸç† WeakReference + ReferenceQueueï¼ŒåŠ äº†ä¸€äº›æ”¹è¿›ç‚¹ï¼šnewä¸€ä¸ªå¼±å¼•ç”¨çš„Objectï¼Œç­‰è¿™ä¸ªObjectç¡®è®¤è¢«å›æ”¶åå†ç¡®è®¤Activityæ˜¯å¦æ­£å¸¸è¢«å›æ”¶ Jetpack Compose ç¨å¾®è°ˆäº†ä¸€ä¸‹çœ‹æ³•ï¼Œæ˜¯å¦åœ¨é¡¹ç›®ä¸­ç”¨è¿‡ ç®—æ³•é¢˜ï¼šæœ€é•¿å…¬å…±å‰ç¼€ LeetCode 14é¢˜ï¼Œeasyéš¾åº¦ï¼šhttps://leetcode-cn.com/problems/longest-common-prefix/ äºŒé¢ä¸€é¢ç»“æŸå5minå·¦å³ï¼ŒBç«™HRå°±ç»™æˆ‘æ‰“ç”µè¯è¿‡æ¥çº¦äº†äºŒé¢ äºŒé¢ä¹Ÿæ˜¯æŠ€æœ¯é¢ï¼Œ20minå·¦å³ï¼Œå› ä¸ºæ˜¯æ™šä¸Š8ç‚¹é¢çš„ï¼Œä¼°è®¡äººå®¶æ€¥ç€æƒ³ä¸‹ç­ï¼ˆç¬‘ï¼‰ è‡ªæˆ‘ä»‹ç» å·¥ä½œèŒè´£ å·¥ä½œä¸­æœ‰ä»€ä¹ˆäº®ç‚¹ æ‹ç…§è£å‰ªä¸šåŠ¡ å•å…ƒæµ‹è¯•åº“ æ€§èƒ½ç›‘æ§ å†…å­˜æ³„æ¼æ£€æµ‹ å•å…ƒæµ‹è¯•çš„åº“æ˜¯æ€ä¹ˆåšçš„ åŸºäºMockitoå’ŒRobolectric: å°è£…äº†ä¸€ä¸ªåå°„åº“ç”¨æ¥æ–¹ä¾¿æµ‹è¯• åšäº†ä¸€ä¸ªAutoCloserç±»ç”¨æ¥è‡ªåŠ¨å…³é—­é‡Šæ”¾mockçš„èµ„æºï¼Œè¿™é‡Œæåˆ°äº†ä½¿ç”¨MockedStaticï¼Œå¦‚æœåœ¨ä½¿ç”¨å®Œåæ²¡æœ‰é‡Šæ”¾ï¼Œé‚£åœ¨ä¸‹ä¸€æ¬¡ä½¿ç”¨åˆ°åŒä¸€ä¸ªç±»çš„MockedStaticçš„æ—¶å€™ä¼šæŠ¥é”™ï¼Œè¿™é‡Œæˆ‘è‡ªå®šä¹‰äº†ä¸€ä¸ªæ³¨è§£@MockedStaticç”¨æ¥è‡ªåŠ¨mockå’Œé‡Šæ”¾èµ„æº é’ˆå¯¹kotlinåšäº†ä¸€äº›mockå·¥å…·ï¼Œæ¯”å¦‚è¯´é¡¶å±‚å‡½æ•°çš„mockï¼ˆè¿™ä¸ªåœ¨æˆ‘ä»¥å‰çš„æ–‡ç« Android-Kotlinå•å…ƒæµ‹è¯•ä¹‹ å¦‚ä½•é…åˆMockitoæ¨¡æ‹Ÿé¡¶å±‚å‡½æ•°ä¸­ä»‹ç»è¿‡ï¼‰ å¼€å‘æ¨¡å¼ï¼ˆæµç¨‹è§„èŒƒï¼‰ï¼š å¼€å‘è§„èŒƒå‚è€ƒäº†é˜¿é‡Œçš„Javaè§„èŒƒå’ŒAndroidè§„èŒƒï¼Œé€‰å–äº†ä¸€äº›æ¯”è¾ƒé‡è¦çš„æ¡ä¾‹å’Œä¸€äº›è‡ªå·±é•¿æ—¶é—´å¼€å‘çš„ç»éªŒåšæˆäº†ä¸€ç¯‡æ–‡æ¡£ å´©æºƒç‡çš„ä¼˜åŒ–ï¼Œåšäº†å“ªäº›äº‹æƒ… æ„Ÿè§‰è¿™é‡Œæ²¡ç­”å¥½ï¼Œæœ‰ç‚¹ç­”éæ‰€é—®çš„æ„æ€ï¼Œæˆ‘å°±è¯´äº†è¯´ç›®å‰å¤„ç†bugçš„ä¸€ä¸ªæµç¨‹ï¼Œæ²¡æœ‰è°ˆåˆ°æ€ä¹ˆè§£å†³ä¸€ä¸ªbug æ•°æ®æ‰“ç‚¹æ˜¯æ€ä¹ˆåšçš„ æˆ‘ä»¬ç”¨çš„æ˜¯ç¥ç­–ç¬¬ä¸‰æ–¹æœåŠ¡ å†…å­˜æ³„æ¼å·¥å…·æ˜¯æ€ä¹ˆåšçš„ è¿™éƒ¨åˆ†åŒä¸€é¢LeakCanaryåŸç† çœ‹ä½ ä¹‹å‰åšè¿‡ä¸€ä¸ªMQTTåè®®çš„å®¢æˆ·ç«¯ï¼Œæ˜¯å‡ºäºä¸ªäººå…´è¶£å— æ˜¯çš„ï¼Œå½“æ—¶æ˜¯æƒ³è¦åšä¸€ä¸ªIMåº”ç”¨ åœ¨é¡¹ç›®ä¸­æœ‰é‡åˆ°éœ€è¦3Dæ¸²æŸ“å±•ç¤ºçš„å†…å®¹å— ç›®å‰æ²¡æœ‰ ä¸¤ä¸ªActivityè·³è½¬æ—¶æ–¹æ³•æ‰§è¡Œçš„é¡ºåº ä¸€ä¸ªActivityåˆ›å»ºæ˜¯ï¼šonCreate -&gt; onStart -&gt; onResumeï¼ˆä¹‹åä¾¿åœ¨å±å¹•ä¸Šæ˜¾ç¤ºäº†ï¼‰ å‡è®¾ä»A Activityè·³è½¬åˆ°B Activityï¼šA.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop ä»Bè¿”å›åˆ°Aï¼šB.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory ä¸¤ä¸ªActivityä¼ é€’æ•°æ®å¯ä»¥é€šè¿‡ä»€ä¹ˆæ–¹å¼ Intent å¦‚æœæ˜¯åŒä¸€ä¸ªè¿›ç¨‹çš„è¯ï¼Œå¯ä»¥ç”¨å…¨å±€å˜é‡æˆ–è€…å•ä¾‹ç­‰ SharedPreference æ–‡ä»¶ ä»€ä¹ˆæ—¶å€™ä½¿ç”¨Service åå°ä»»åŠ¡ï¼Œæ¯”å¦‚è¯´åå°æ’­æ”¾éŸ³ä¹ç­‰ï¼Œè¿™é‡Œæäº†ä¸€ä¸‹IntentServiceæ˜¯å¼€äº†ä¸€ä¸ªå­çº¿ç¨‹çš„ Serviceæ€ä¹ˆå¯åŠ¨ï¼Œæ€ä¹ˆåœæ­¢ startService &lt;â€”&gt; stopService bindService &lt;â€”&gt; unbindService åŒ…ä½“ç§¯ä¼˜åŒ– æ¸…ç†èµ„æºï¼ˆå­—ä½“ã€å›¾ç‰‡ã€ä»£ç ç­‰ï¼‰ HRé¢äºŒé¢ç»“æŸåè¿‡äº†2-3å¤©ï¼ŒHRå‘å¾®ä¿¡è¿‡æ¥æ­å–œæˆ‘è¿›å…¥ä¸‹ä¸€è½®é¢è¯•ï¼Œæˆ‘é—®å¥¹æ¥ä¸‹æ¥æ˜¯è¿˜æœ‰ä¸‰é¢å’ŒHRé¢å—ï¼Œå¥¹å›ç­”æˆ‘è¯´åé¢å°±ç›´æ¥æ˜¯HRé¢äº†ï¼Œè¯´å®è¯æˆ‘è¿˜æ˜¯æŒºæƒŠè®¶çš„ HRé¢15minå·¦å³ï¼Œå¤§æ¦‚å°±é—®äº†ä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆè¦ä»ä¸Šå®¶å…¬å¸ç¦»èŒï¼Œæˆ‘ä»¬æ˜¯ä¸€ä¸ªæ–°éƒ¨é—¨ï¼Œå¤„äºé¡¹ç›®åˆæœŸï¼Œæœ‰ä»€ä¹ˆçœ‹æ³•ä¹‹ç±»çš„ï¼Œç„¶åé—®äº†ä¸€ä¸‹ç›®å‰çš„è–ªèµ„å’ŒæœŸæœ›è–ªèµ„ï¼Œover~ æ€»ç»“è¯´å®è¯æ„Ÿè§‰è¿™æ¬¡é¢è¯•å¤ªç®€å•äº†ï¼Œæœ‰ç‚¹ç™½çäº†æˆ‘å‡†å¤‡äº†é‚£ä¹ˆå¤šï¼Œè¿˜åšäº†æŸ¥æ¼è¡¥ç¼º ã„Ÿ( â–”, â–” )ã„ ï¼Œæœ€åç¥å¤§å®¶éƒ½èƒ½æ‰¾åˆ°å¿ƒä»ªçš„å·¥ä½œ (à¹‘â€¢Ì€ã…‚â€¢Ì)Ùˆâœ§","categories":[{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"é¢è¯•","slug":"Android/é¢è¯•","permalink":"http://yoursite.com/categories/Android/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸‹ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸‹ï¼‰","date":"2022-03-11T10:13:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/03/11/android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸‹ï¼‰/","link":"","permalink":"http://yoursite.com/2022/03/11/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥aospåˆ†æ”¯android-11.0.0_r25ï¼Œkernelåˆ†æ”¯android-msm-wahoo-4.4-android11ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰ï¼Œæˆ‘ä»¬åˆ†æäº†binder_ioctlä¸­çš„å†™æ“ä½œbinder_thread_writeéƒ¨åˆ†ï¼Œäº†è§£äº†binderè¯·æ±‚çš„å‘èµ·ä¸è°ƒåº¦ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±è¿›è¡Œbinderé©±åŠ¨çš„æœ€åä¸€éƒ¨åˆ†åˆ†æï¼Œbinder_thread_read binder_ioctl_write_readæˆ‘ä»¬è¿˜æ˜¯å…ˆä»binder_ioctlåçš„BINDER_WRITE_READå‘½ä»¤ç å¼€å§‹ 1234567891011121314151617181920212223242526272829303132333435363738static int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; ... //å°†ç”¨æˆ·ç©ºé—´ubufæ‹·è´è‡³å†…æ ¸ç©ºé—´bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125; ... //å½“è¯»ç¼“å­˜ä¸­æœ‰æ•°æ®ï¼Œæ‰§è¡Œbinderè¯»æ“ä½œ if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); trace_binder_read_done(ret); //å¦‚æœtodoé˜Ÿåˆ—ä¸­æœ‰æœªå¤„ç†çš„ä»»åŠ¡ï¼Œå”¤é†’ç­‰å¾…çŠ¶æ€ä¸‹çš„çº¿ç¨‹ binder_inner_proc_lock(proc); if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; ...out: return ret;&#125; binder_thread_readè¿™æ˜¯è¿›è¡Œbinderè¯»æ“ä½œçš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬åŒæ ·å°†å®ƒåˆ†æˆå‡ ä¸ªéƒ¨åˆ†ï¼š ç­‰å¾…å¯ç”¨çš„binder_work å¾ªç¯è·å–todoé˜Ÿåˆ—ä¸­çš„binder_workï¼Œå¹¶æ ¹æ®binder_workçš„typeï¼Œæ‰§è¡Œä¸€å®šçš„å¤„ç† å¤„ç†binder_transactionä»¥åŠbinder_transaction_dataï¼Œå¹¶å°†binder_transaction_dataæ‹·è´å›ç”¨æˆ·ç©ºé—´ ç¬¬ä¸€éƒ¨åˆ†ï¼šç­‰å¾…å·¥ä½œbinder_thread.looperåœ¨æ­¤ä¹‹å‰æˆ‘ä»¬éœ€è¦å…ˆçœ‹ä¸€ä¸‹ä¹‹å‰æåˆ°çš„ï¼Œåœ¨binder_threadä¸­çš„åŸŸæˆå‘˜looperï¼Œå‰é¢æˆ‘ä»¬åªæ˜¯æ³¨é‡Šäº†è¿™ä¸ªåŸŸè¡¨ç¤ºçº¿ç¨‹çŠ¶æ€ï¼Œè¿™é‡Œæˆ‘ä»¬ä»‹ç»ä¸€ä¸‹å®ƒæœ‰å“ªäº›å–å€¼ï¼š BINDER_LOOPER_STATE_REGISTEREDï¼šè¡¨ç¤ºè¯¥binderçº¿ç¨‹æ˜¯éä¸»binderçº¿ç¨‹ BINDER_LOOPER_STATE_ENTEREDï¼šè¡¨ç¤ºè¯¥binderçº¿ç¨‹æ˜¯ä¸»binderçº¿ç¨‹ BINDER_LOOPER_STATE_EXITEDï¼šè¡¨ç¤ºè¯¥binderçº¿ç¨‹é©¬ä¸Šå°±è¦é€€å‡ºäº† BINDER_LOOPER_STATE_INVALIDï¼šè¡¨ç¤ºè¯¥binderçº¿ç¨‹æ˜¯æ— æ•ˆçš„ï¼ˆæ¯”å¦‚åŸæ¥æ˜¯binderä¸»çº¿ç¨‹ï¼Œåç»­ç”¨æˆ·åˆå‘é€äº†ä¸€ä¸ªBC_REGISTER_LOOPERè¯·æ±‚ï¼‰ BINDER_LOOPER_STATE_WAITINGï¼šè¡¨ç¤ºå½“å‰binderçº¿ç¨‹æ­£åœ¨ç­‰å¾…è¯·æ±‚ BINDER_LOOPER_STATE_NEED_RETURNï¼šè¡¨ç¤ºè¯¥binderçº¿ç¨‹åœ¨å¤„ç†å®Œtransactionåéœ€è¦è¿”å›åˆ°ç”¨æˆ·æ€ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //ç”¨æˆ·ç©ºé—´ä¼ è¿›æ¥çš„éœ€è¦å°†æ•°æ®è¯»åˆ°çš„åœ°å€ //å®é™…ä¸Šåªæ˜¯ä¼ è¾“ä¸€äº›å‘½ä»¤ç å’Œä¸€ä¸ªbinder_transaction_data_secctxç»“æ„ä½“ //çœŸæ­£çš„æ•°æ®å·²ç»æ˜ å°„åˆ°ç”¨æˆ·è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸­äº†ï¼Œæ ¹æ®binder_transaction_dataä¸­æ‰€ç»™çš„åœ°å€ç›´æ¥è¯»å°±å¯ä»¥äº† void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //èµ·å§‹åœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + å·²è¯»æ•°æ®å¤§å° void __user *ptr = buffer + *consumed; //ç»“æŸåœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + è¯»æ•°æ®çš„æ€»å¤§å° void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; if (*consumed == 0) &#123; //å‘ç”¨æˆ·ç©ºé—´å†™ä¸€ä¸ªbinderå“åº”ç ï¼Œè¯¥å“åº”ç ä¸åšä»»ä½•æ“ä½œ if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: binder_inner_proc_lock(proc); //æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„å·¥ä½œéœ€è¦å¤„ç† wait_for_proc_work = binder_available_for_proc_work_ilocked(thread); binder_inner_proc_unlock(proc); //å°†çº¿ç¨‹çš„çŠ¶æ€ç½®ä¸ºç­‰å¾…ä¸­ thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING; //å¦‚æœæ²¡æœ‰å¯ç”¨çš„å·¥ä½œï¼Œå¯ä»¥ç­‰å¾…è¿›ç¨‹todoé˜Ÿåˆ—ä¸­çš„å·¥ä½œ if (wait_for_proc_work) &#123; //è¿™ä¸ªbinderçº¿ç¨‹æ—¢ä¸æ˜¯ä¸»çº¿ç¨‹ï¼Œä¹Ÿæ²¡æœ‰è¢«æ³¨å†Œæˆbinderå­çº¿ç¨‹ //è¿™é‡Œæ¡ä»¶åœ¨binder_available_for_proc_work_ilockedä¸­å·²ç»åšäº†åˆ¤æ–­ //ä¼¼ä¹æ°¸è¿œä¸ä¼šè¿›å…¥åˆ°è¿™ä¸ªcaseä¸­ï¼Ÿ if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; binder_user_error(\"%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\\n\", proc-&gt;pid, thread-&gt;pid, thread-&gt;looper); //è¿›ç¨‹è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…å”¤é†’ wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); &#125; //æ¢å¤ä¼˜å…ˆçº§ binder_restore_priority(current, proc-&gt;default_priority); &#125; if (non_block) &#123; //å¦‚æœæ˜¯éé˜»å¡æ¨¡å¼ï¼ˆè¿™é‡Œä¼¼ä¹ä¸ä¼šæ‰§è¡Œåˆ°ï¼‰ //çº¿ç¨‹å’Œè¿›ç¨‹çš„todoé˜Ÿåˆ—ä¸­éƒ½æ²¡æœ‰å·¥ä½œ if (!binder_has_work(thread, wait_for_proc_work)) ret = -EAGAIN; &#125; else &#123; //å¦‚æœæ˜¯é˜»å¡æ¨¡å¼ //ç­‰å¾…binderå·¥ä½œåˆ°æ¥ ret = binder_wait_for_work(thread, wait_for_proc_work); &#125; //å°†çº¿ç¨‹çš„ç­‰å¾…ä¸­çŠ¶æ€è§£é™¤ thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; if (ret) return ret; ...&#125; è¿™ä¸€éƒ¨åˆ†å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨çš„binder_workå¾…å¤„ç†ï¼Œå¦‚æœæœ‰çš„è¯è¿›å…¥åˆ°ä¸‹ä¸€éƒ¨åˆ†ï¼Œå¦‚æœæ²¡æœ‰çš„è¯åˆ™éœ€è¦ç­‰å¾… å…·ä½“çš„ï¼Œæˆ‘ä»¬å…ˆçœ‹è¿™ä¸ªå‡½æ•°ä¸­çš„wait_for_proc_workå˜é‡ï¼Œè¿™ä¸ªå˜é‡è¡¨ç¤ºæ˜¯å¦éœ€è¦ç­‰å¾…binder_procä¸­çš„å·¥ä½œï¼Œå½“åœ¨binder_threadä¸­æ‰¾ä¸åˆ°äº‹åŠ¡æ ˆå¹¶ä¸”todoé˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œæ­¤å˜é‡å€¼ä¸ºtrue 1234567static bool binder_available_for_proc_work_ilocked(struct binder_thread *thread)&#123; return !thread-&gt;transaction_stack &amp;&amp; binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp; (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED | BINDER_LOOPER_STATE_REGISTERED)); //è¿™ä¸ªbinderçº¿ç¨‹æ—¢ä¸æ˜¯ä¸»çº¿ç¨‹ï¼Œä¹Ÿæ²¡æœ‰è¢«æ³¨å†Œæˆbinderå­çº¿ç¨‹&#125; åœ¨ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰ï¼Œæˆ‘ä»¬åˆ†æè¿‡æ˜¯æœ‰åˆ†æ”¯ä¼šå°†binder_workç›´æ¥æ·»åŠ åˆ°binder_procçš„todoé˜Ÿåˆ—ä¸­çš„ï¼Œå½“binder_threadä¸­æ‰¾ä¸åˆ°å·¥ä½œçš„è¯ï¼Œå¯èƒ½å°±éœ€è¦ä»binder_procä¸­æ‰¾äº† ç„¶åä¼šå°†å½“å‰çº¿ç¨‹çš„çŠ¶æ€ç½®ä¸ºç­‰å¾…ä¸­ï¼Œç­‰åˆ°æœ‰å¯å¤„ç†çš„binder_workåå†è§£é™¤è¿™ä¸ªçŠ¶æ€ ä¹‹åä¼šåˆ¤æ–­ä¼ å…¥çš„å‚æ•°æ˜¯å¦ä¸ºé˜»å¡æ¨¡å¼ï¼Œè¿™ä¸ªæ˜¯ç”±frameworkå±‚æ‰§è¡Œioctlæ—¶ä¼ å…¥çš„flagsæ‰€å†³å®šçš„ï¼Œæ ¹æ®frameworkä¸­çš„binderä»£ç ï¼Œè¿™é‡Œåº”è¯¥æ’ä¸ºé˜»å¡æ¨¡å¼ï¼Œåœ¨é˜»å¡æ¨¡å¼ä¸‹ï¼Œä¼šè°ƒç”¨binder_wait_for_workå‡½æ•°ï¼Œç­‰å¾…å­˜åœ¨å¯ç”¨çš„binder_work 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int binder_wait_for_work(struct binder_thread *thread, bool do_proc_work)&#123; //å®šä¹‰ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—é¡¹ DEFINE_WAIT(wait); struct binder_proc *proc = thread-&gt;proc; int ret = 0; freezer_do_not_count(); binder_inner_proc_lock(proc); for (;;) &#123; //å‡†å¤‡ç¡çœ ç­‰å¾… prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE); //æ£€æŸ¥ç¡®è®¤æ˜¯å¦æœ‰binder_workå¯ä»¥å¤„ç† if (binder_has_work_ilocked(thread, do_proc_work)) break; //å¯ä»¥å¤„ç†binder_proc.todoä¸­çš„å·¥ä½œçš„è¯ if (do_proc_work) //å°†è¯¥binderçº¿ç¨‹åŠ å…¥åˆ°binder_procä¸­çš„ç­‰å¾…çº¿ç¨‹ä¸­ list_add(&amp;thread-&gt;waiting_thread_node, &amp;proc-&gt;waiting_threads); binder_inner_proc_unlock(proc); //ç¡çœ  schedule(); binder_inner_proc_lock(proc); //å°†è¯¥binderçº¿ç¨‹ä»binder_procä¸­çš„ç­‰å¾…çº¿ç¨‹ä¸­ç§»é™¤ list_del_init(&amp;thread-&gt;waiting_thread_node); //æ£€æŸ¥å½“å‰ç³»ç»Ÿè°ƒç”¨è¿›ç¨‹æ˜¯å¦æœ‰ä¿¡å·å¤„ç† if (signal_pending(current)) &#123; ret = -ERESTARTSYS; break; &#125; &#125; //ç»“æŸç­‰å¾… finish_wait(&amp;thread-&gt;wait, &amp;wait); binder_inner_proc_unlock(proc); freezer_count(); return ret;&#125;static bool binder_has_work_ilocked(struct binder_thread *thread, bool do_proc_work)&#123; //thread-&gt;process_todoä¸ºfalseæ—¶ä¼šå»¶æ—¶æ‰§è¡Œ return thread-&gt;process_todo || thread-&gt;looper_need_return || (do_proc_work &amp;&amp; !binder_worklist_empty_ilocked(&amp;thread-&gt;proc-&gt;todo));&#125; è¿™ä¸ªå‡½æ•°çš„ç»“æ„å’ŒLinuxå‡½æ•°wait_event_interruptibleéå¸¸ç›¸ä¼¼ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å®ƒæ˜¯æ€ä¹ˆåšåˆ°é˜»å¡ç­‰å¾…çš„ Linuxè¿›ç¨‹è°ƒåº¦DEFINE_WAITè¿™æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªwait_queue_tç»“æ„ä½“ 12345678#define DEFINE_WAIT_FUNC(name, function) \\ wait_queue_t name = &#123; \\ .private = current, \\ .func = function, \\ .task_list = LIST_HEAD_INIT((name).task_list), \\ &#125;#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function) è¿™ä¸ªç»“æ„ä½“ä¸­çš„privateåŸŸæŒ‡å‘çš„å³æ˜¯å½“å‰æ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ‰€åœ¨è¿›ç¨‹çš„æè¿°ç»“æ„ä½“ï¼ŒfuncåŸŸæŒ‡å‘å”¤é†’è¿™ä¸ªé˜Ÿåˆ—é¡¹è¿›ç¨‹æ‰€æ‰§è¡Œçš„å‡½æ•° prepare_to_waitè¿™ä¸ªå‡½æ•°å°†æˆ‘ä»¬åˆšåˆšå®šä¹‰çš„waité˜Ÿåˆ—é¡¹åŠ å…¥åˆ°ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­ï¼ˆåœ¨binderä¸­å³æ˜¯åŠ å…¥åˆ°thread-&gt;waitä¸­ï¼‰ï¼Œç„¶åå°†è¿›ç¨‹çš„çŠ¶æ€è®¾ç½®ä¸ºæˆ‘ä»¬æŒ‡å®šçš„çŠ¶æ€ï¼Œåœ¨è¿™é‡Œä¸ºTASK_INTERRUPTIBLEï¼ˆå¯ä¸­æ–­çš„ç¡çœ çŠ¶æ€ï¼‰ schedulescheduleæ˜¯çœŸæ­£æ‰§è¡Œè¿›ç¨‹è°ƒåº¦çš„åœ°æ–¹ï¼Œç”±äºä¹‹å‰è¿›ç¨‹çŠ¶æ€å·²ç»è¢«è®¾ç½®æˆTASK_INTERRUPTIBLEçŠ¶æ€ï¼Œåœ¨è°ƒç”¨scheduleåï¼Œè¯¥è¿›ç¨‹å°±ä¼šè®©å‡ºCPUï¼Œä¸å†è°ƒåº¦è¿è¡Œï¼Œç›´åˆ°è¯¥è¿›ç¨‹æ¢å¤TASK_RUNNINGçŠ¶æ€ wake_up_interruptibleæˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰ä¸­æåˆ°è¿‡ï¼Œå½“binder_transactionå·¥ä½œå¤„ç†å®Œåï¼Œä¼šè°ƒç”¨wake_up_interruptibleå‡½æ•°å”¤é†’ç›®æ ‡binderçº¿ç¨‹çš„ç­‰å¾…é˜Ÿåˆ— è¿™ä¸ªå‡½æ•°ä¼šå”¤é†’TASK_INTERRUPTIBLEçŠ¶æ€ä¸‹çš„è¿›ç¨‹ï¼Œå®ƒä¼šå¾ªç¯éå†ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´ ï¼Œåˆ†åˆ«æ‰§è¡Œå…¶å”¤é†’å‡½æ•°ï¼Œä¹Ÿå°±å¯¹åº”ç€æˆ‘ä»¬DEFINE_WAITå®šä¹‰å‡ºæ¥çš„ç»“æ„ä½“ä¸­çš„funcåŸŸï¼Œå³autoremove_wake_functionï¼Œå®ƒæœ€ç»ˆä¼šè°ƒç”¨try_to_wake_upå‡½æ•°å°†è¿›ç¨‹ç½®ä¸ºTASK_RUNNINGçŠ¶æ€ï¼Œè¿™æ ·åé¢çš„è¿›ç¨‹è°ƒåº¦ä¾¿ä¼šè°ƒåº¦åˆ°è¯¥è¿›ç¨‹ï¼Œä»è€Œå”¤é†’è¯¥è¿›ç¨‹ç»§ç»­æ‰§è¡Œ signal_pendingè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ£€æŸ¥å½“å‰ç³»ç»Ÿè°ƒç”¨è¿›ç¨‹æ˜¯å¦æœ‰ä¿¡å·éœ€è¦å¤„ç†çš„ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹é™·å…¥ç³»ç»Ÿè°ƒç”¨å¹¶å¤„äºç­‰å¾…çŠ¶æ€æ—¶ï¼Œå¦‚æœæ­¤æ—¶äº§ç”Ÿäº†ä¸€ä¸ªä¿¡å·ï¼Œä»…ä»…æ˜¯åœ¨è¯¥è¿›ç¨‹çš„thread_infoä¸­æ ‡è¯†äº†ä¸€ä¸‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å”¤é†’è¿›ç¨‹åéœ€è¦æ£€æŸ¥ä¸€ä¸‹æ˜¯å¦æœ‰ä¿¡å·éœ€è¦å¤„ç†ï¼Œå¦‚æœæœ‰çš„è¯ï¼Œè¿”å›-ERESTARTSYSï¼Œå…ˆå¤„ç†ä¿¡å·ï¼Œåç»­Linuxä¸Šå±‚åº“å‡½æ•°ä¼šæ ¹æ®-ERESTARTSYSæ­¤è¿”å›å€¼é‡æ–°æ‰§è¡Œè¿™ä¸ªç³»ç»Ÿè°ƒç”¨ finish_waitæœ€åä¸€æ­¥ï¼Œå½“è¿›ç¨‹è¢«å”¤é†’åï¼Œè°ƒç”¨finish_waitå‡½æ•°æ‰§è¡Œæ¸…ç†å·¥ä½œï¼Œå°†å½“å‰è¿›ç¨‹ç½®ä¸ºTASK_RUNNINGçŠ¶æ€ï¼Œå¹¶æŠŠå½“å‰waité˜Ÿåˆ—é¡¹ä»ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤ äº†è§£äº†ä¸Šé¢è¿™äº›çŸ¥è¯†ï¼Œæˆ‘ä»¬å†çœ‹binder_wait_for_workå‡½æ•°åº”è¯¥æ¯”è¾ƒæ¸…æ™°äº†ï¼Œè¿™é‡Œæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰æåˆ°ï¼Œåœ¨æ²¡æœ‰TF_ONE_WAYæ ‡å¿—çš„æƒ…å†µä¸‹ï¼Œä¼šä½¿ç”¨binder_enqueue_deferred_thread_work_ilockedå‡½æ•°å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªå‡½æ•°åŒºåˆ«äºbinder_enqueue_thread_work_ilockedå‡½æ•°ï¼Œå®ƒæ²¡æœ‰å°†thread-&gt;process_todoè®¾ä¸ºtrueï¼Œæ‰€ä»¥ç»“åˆç€binder_has_work_ilockedå‡½æ•°çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œå½“thread-&gt;process_todoä¸ºfalseæ—¶ï¼Œæ•´ä¸ªbinder_has_work_ilockedè¿”å›falseï¼Œå³ä¼šè¿›å…¥åˆ°ç¡çœ çŠ¶æ€ï¼Œå»¶è¿Ÿæ‰§è¡ŒBINDER_WORK_TRANSACTION_COMPLETEï¼Œè¿™ä¹ˆè®¾è®¡å¯ä»¥è®©binderæ¥æ”¶ç«¯ä¼˜å…ˆå¤„ç†äº‹åŠ¡ï¼Œæé«˜äº†æ€§èƒ½ ç¬¬äºŒéƒ¨åˆ†ï¼šè·å–å·¥ä½œï¼Œæ ¹æ®typeåšä¸€å®šçš„å¤„ç†12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //ç”¨æˆ·ç©ºé—´ä¼ è¿›æ¥çš„éœ€è¦å°†æ•°æ®è¯»åˆ°çš„åœ°å€ //å®é™…ä¸Šåªæ˜¯ä¼ è¾“ä¸€äº›å‘½ä»¤ç å’Œä¸€ä¸ªbinder_transaction_data_secctxç»“æ„ä½“ //çœŸæ­£çš„æ•°æ®å·²ç»æ˜ å°„åˆ°ç”¨æˆ·è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸­äº†ï¼Œæ ¹æ®binder_transaction_dataä¸­æ‰€ç»™çš„åœ°å€ç›´æ¥è¯»å°±å¯ä»¥äº† void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //èµ·å§‹åœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + å·²è¯»æ•°æ®å¤§å° void __user *ptr = buffer + *consumed; //ç»“æŸåœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + è¯»æ•°æ®çš„æ€»å¤§å° void __user *end = buffer + size; ...retry: ... //å¾ªç¯å¤„ç†todoé˜Ÿåˆ—ä¸­çš„å·¥ä½œ while (1) &#123; uint32_t cmd; struct binder_transaction_data_secctx tr; struct binder_transaction_data *trd = &amp;tr.transaction_data; struct binder_work *w = NULL; struct list_head *list = NULL; struct binder_transaction *t = NULL; struct binder_thread *t_from; size_t trsize = sizeof(*trd); binder_inner_proc_lock(proc); //æ‰¾åˆ°éœ€è¦å¤„ç†çš„todoé˜Ÿåˆ— if (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo)) list = &amp;thread-&gt;todo; else if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) list = &amp;proc-&gt;todo; else &#123; binder_inner_proc_unlock(proc); /* no data added */ //åªè·³è¿‡äº†æ•°æ®å¤´éƒ¨çš„å‘½ä»¤ç ï¼Œæ²¡æœ‰è¯»å–ä»»ä½•æ•°æ® if (ptr - buffer == 4 &amp;&amp; !thread-&gt;looper_need_return) goto retry; break; &#125; //ä¼ è¾“è¿‡æ¥çš„æ•°æ®å¤§å°ä¸ç¬¦åˆ if (end - ptr &lt; sizeof(tr) + 4) &#123; binder_inner_proc_unlock(proc); break; &#125; //ä»todoé˜Ÿåˆ—ä¸­å‡ºé˜Ÿä¸€é¡¹binder_work w = binder_dequeue_work_head_ilocked(list); if (binder_worklist_empty_ilocked(&amp;thread-&gt;todo)) thread-&gt;process_todo = false; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; binder_inner_proc_unlock(proc); //æ ¹æ®binder_workæ‰¾åˆ°binder_transactionç»“æ„ t = container_of(w, struct binder_transaction, work); &#125; break; case BINDER_WORK_RETURN_ERROR: &#123; ... &#125; break; case BINDER_WORK_TRANSACTION_COMPLETE: &#123; binder_inner_proc_unlock(proc); cmd = BR_TRANSACTION_COMPLETE; //å›å¤ç»™ç”¨æˆ·è¿›ç¨‹BR_TRANSACTION_COMPLETEå“åº”ç  if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); //æ›´æ–°ç»Ÿè®¡æ•°æ® binder_stat_br(proc, thread, cmd); //é‡Šæ”¾ kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; case BINDER_WORK_NODE: &#123; ... &#125; break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; ... &#125; break; &#125; ... &#125;done: ...&#125; è¿™é‡Œå…ˆåˆ›å»ºäº†ä¸€ä¸ªbinder_transaction_data_secctxç»“æ„ä½“ï¼Œåç»­ä¼šå°†å®ƒæ‹·è´åˆ°ç”¨æˆ·ç©ºé—´å»ï¼Œç„¶ååˆ›å»ºäº†ä¸€ä¸ªæŒ‡é’ˆtrdæŒ‡å‘tr.transaction_dataçš„åœ°å€ï¼Œè¿™æ ·åç»­æ“ä½œtrdå°±ç›¸å½“äºæ“ä½œtr.transaction_dataäº† å½“è¿›ç¨‹ä»ç¡çœ ä¸­å”¤é†’ï¼Œæ„å‘³ç€æœ‰å¯ç”¨çš„binder_workäº†ï¼Œè¿™æ—¶å€™ç†è®ºä¸Šæ¥è¯´ï¼Œbinder_threadå’Œbinder_procå…¶ä¸­æ€»æœ‰ä¸€ä¸ªtodoé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œè¿™é‡Œä¼˜å…ˆå¤„ç†binder_threadçš„todoé˜Ÿåˆ—ï¼Œå¦‚æœä¸¤è€…éƒ½ä¸ºç©ºï¼Œä¸”è¿˜æœªè¯»å–è¿‡ä»»ä½•æ•°æ®ï¼Œé‡æ–°gotoåˆ°retryå¤„ç­‰å¾… æ¥ç€å°±æ˜¯å°†binder_workä»ç›¸åº”çš„todoé˜Ÿåˆ—ä¸­å‡ºé˜Ÿï¼Œå†æ ¹æ®å…¶ç±»å‹æ‰§è¡Œä¸åŒçš„å¤„ç†æ“ä½œï¼Œè¿™é‡Œæˆ‘ä»¬åªé’ˆå¯¹BINDER_WORK_TRANSACTIONå’ŒBINDER_WORK_TRANSACTION_COMPLETEè¿™ä¸¤ç§æœ€é‡è¦çš„ç±»å‹åˆ†æ å½“ç±»å‹ä¸ºBINDER_WORK_TRANSACTIONæ—¶ï¼Œè¡¨ç¤ºæ˜¯åˆ«çš„è¿›ç¨‹å‘è‡ªå·±å‘èµ·binderè¯·æ±‚ï¼Œæ­¤æ—¶ï¼Œæˆ‘ä»¬æ ¹æ®binder_workæ‰¾åˆ°å¯¹åº”çš„binder_transactionç»“æ„ å½“ç±»å‹ä¸ºBINDER_WORK_TRANSACTION_COMPLETEæ—¶ï¼Œè¡¨ç¤ºå‘èµ·çš„è¯·æ±‚BC_TRANSACTIONå·²ç»å®Œæˆäº†ï¼Œæ­¤æ—¶å°†å›å¤ç»™ç”¨æˆ·ç©ºé—´BR_TRANSACTION_COMPLETEå“åº”ç ï¼Œç„¶åæ›´æ–°ç»Ÿè®¡æ•°æ®ï¼Œé‡Šæ”¾èµ„æº ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¤„ç†binder_transactionï¼Œæ‹·è´å›ç”¨æˆ·ç©ºé—´123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //ç”¨æˆ·ç©ºé—´ä¼ è¿›æ¥çš„éœ€è¦å°†æ•°æ®è¯»åˆ°çš„åœ°å€ //å®é™…ä¸Šåªæ˜¯ä¼ è¾“ä¸€äº›å‘½ä»¤ç å’Œä¸€ä¸ªbinder_transaction_data_secctxç»“æ„ä½“ //çœŸæ­£çš„æ•°æ®å·²ç»æ˜ å°„åˆ°ç”¨æˆ·è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸­äº†ï¼Œæ ¹æ®binder_transaction_dataä¸­æ‰€ç»™çš„åœ°å€ç›´æ¥è¯»å°±å¯ä»¥äº† void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //èµ·å§‹åœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + å·²è¯»æ•°æ®å¤§å° void __user *ptr = buffer + *consumed; //ç»“æŸåœ°å€ = è¯»æ•°æ®çš„é¦–åœ°å€ + è¯»æ•°æ®çš„æ€»å¤§å° void __user *end = buffer + size; ...retry: ... //å¾ªç¯å¤„ç†todoé˜Ÿåˆ—ä¸­çš„å·¥ä½œ while (1) &#123; uint32_t cmd; struct binder_transaction_data_secctx tr; struct binder_transaction_data *trd = &amp;tr.transaction_data; struct binder_work *w = NULL; struct list_head *list = NULL; struct binder_transaction *t = NULL; struct binder_thread *t_from; size_t trsize = sizeof(*trd); ... //åªæœ‰åœ¨type == BINDER_WORK_TRANSACTIONçš„æƒ…å†µä¸‹ï¼Œtæ‰ä¼šè¢«èµ‹å€¼ if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; //binderå®ä½“ä¸ä¸ºNULLï¼Œå¯¹åº”ç€BC_TRANSACTIONè¯·æ±‚ struct binder_node *target_node = t-&gt;buffer-&gt;target_node; struct binder_priority node_prio; //binderå®ä½“åœ¨ç”¨æˆ·ç©ºé—´ä¸­çš„åœ°å€ trd-&gt;target.ptr = target_node-&gt;ptr; //æºå¸¦çš„é¢å¤–æ•°æ® trd-&gt;cookie = target_node-&gt;cookie; //ä¼˜å…ˆçº§ node_prio.sched_policy = target_node-&gt;sched_policy; node_prio.prio = target_node-&gt;min_priority; binder_transaction_priority(current, t, node_prio, target_node-&gt;inherit_rt); //è®¾ç½®å“åº”ç  cmd = BR_TRANSACTION; &#125; else &#123; //binderå®ä½“ä¸ºNULLï¼Œå¯¹åº”ç€BC_REPLYè¯·æ±‚ trd-&gt;target.ptr = 0; trd-&gt;cookie = 0; //è®¾ç½®å“åº”ç  cmd = BR_REPLY; &#125; //è¡¨ç¤ºè¦å¯¹ç›®æ ‡å¯¹è±¡è¯·æ±‚çš„å‘½ä»¤ä»£ç  trd-&gt;code = t-&gt;code; //äº‹åŠ¡æ ‡å¿—ï¼Œè¯¦è§enum transaction_flags trd-&gt;flags = t-&gt;flags; //è¯·æ±‚å‘èµ·è¿›ç¨‹çš„uid trd-&gt;sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid); //è·å–å‘èµ·è¯·æ±‚çš„binderçº¿ç¨‹ t_from = binder_get_txn_from(t); if (t_from) &#123; struct task_struct *sender = t_from-&gt;proc-&gt;tsk; //è®¾ç½®å‘èµ·è¯·æ±‚çš„è¿›ç¨‹pid trd-&gt;sender_pid = task_tgid_nr_ns(sender, task_active_pid_ns(current)); &#125; else &#123; trd-&gt;sender_pid = 0; &#125; //æ•°æ®å¤§å° trd-&gt;data_size = t-&gt;buffer-&gt;data_size; //åç§»æ•°ç»„å¤§å° trd-&gt;offsets_size = t-&gt;buffer-&gt;offsets_size; //è®¾ç½®æ•°æ®åŒºé¦–åœ°å€ï¼ˆè¿™é‡Œé€šè¿‡å†…æ ¸ç©ºé—´åœ°å€å’Œuser_buffer_offsetè®¡ç®—å¾—å‡ºç”¨æˆ·ç©ºé—´åœ°å€ï¼‰ trd-&gt;data.ptr.buffer = (binder_uintptr_t) ((uintptr_t)t-&gt;buffer-&gt;data + binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc)); //åç§»æ•°ç»„ç´§æŒ¨ç€æ•°æ®åŒºï¼Œæ‰€ä»¥å®ƒçš„é¦–åœ°å€å°±ä¸ºæ•°æ®åŒºåœ°å€åŠ ä¸Šæ•°æ®å¤§å° trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); tr.secctx = t-&gt;security_ctx; if (t-&gt;security_ctx) &#123; cmd = BR_TRANSACTION_SEC_CTX; trsize = sizeof(tr); &#125; //å›å¤ç»™ç”¨æˆ·è¿›ç¨‹å¯¹åº”çš„å“åº”ç  if (put_user(cmd, (uint32_t __user *)ptr)) &#123; ... //Error &#125; ptr += sizeof(uint32_t); //å°†binder_transaction_dataæ‹·è´è‡³ç”¨æˆ·ç©ºé—´ if (copy_to_user(ptr, &amp;tr, trsize)) &#123; ... //Error &#125; ptr += trsize; //æ›´æ–°æ•°æ®ç»Ÿè®¡ binder_stat_br(proc, thread, cmd); //ä¸´æ—¶å¼•ç”¨è®¡æ•°å‡1 if (t_from) binder_thread_dec_tmpref(t_from); //å…è®¸é‡Šæ”¾è¿™ä¸ªbuffer t-&gt;buffer-&gt;allow_user_free = 1; if (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; //éå¼‚æ­¥å¤„ç† binder_inner_proc_lock(thread-&gt;proc); //å°†è¿™ä¸ªäº‹åŠ¡æ’å…¥åˆ°äº‹åŠ¡æ ˆä¸­ t-&gt;to_parent = thread-&gt;transaction_stack; //è®¾ç½®ç›®æ ‡å¤„ç†çº¿ç¨‹ t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; binder_inner_proc_unlock(thread-&gt;proc); &#125; else &#123; binder_free_transaction(t); &#125; break; &#125;done: //æ›´æ–°å·²è¯»æ•°æ®å¤§å° *consumed = ptr - buffer; binder_inner_proc_lock(proc); //è¯·æ±‚çº¿ç¨‹æ•°ä¸º0ä¸”æ²¡æœ‰ç­‰å¾…çº¿ç¨‹ï¼Œå·²å¯åŠ¨çº¿ç¨‹æ•°å°äºæœ€å¤§çº¿ç¨‹æ•° //ä¸”è¿™ä¸ªbinderçº¿ç¨‹æ—¢ä¸æ˜¯ä¸»çº¿ç¨‹ï¼Œä¹Ÿæ²¡æœ‰è¢«æ³¨å†Œæˆbinderå­çº¿ç¨‹ if (proc-&gt;requested_threads == 0 &amp;&amp; list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp; proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp; (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */ /*spawn a new thread if we leave this out */) &#123; //å‘ç”¨æˆ·ç©ºé—´å‘é€BR_SPAWN_LOOPERå“åº”ç ï¼Œåˆ›å»ºæ–°binderçº¿ç¨‹ proc-&gt;requested_threads++; binder_inner_proc_unlock(proc); if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)) return -EFAULT; //æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ binder_stat_br(proc, thread, BR_SPAWN_LOOPER); &#125; else binder_inner_proc_unlock(proc); return 0;&#125; åªæœ‰å½“type == BINDER_WORK_TRANSACTIONçš„æƒ…å†µä¸‹ï¼Œæ‰ä¼šèµ°åé¢çš„è¿™äº›é€»è¾‘ï¼Œè¿™ä¸€éƒ¨åˆ†ä¸»è¦åšçš„å·¥ä½œæ˜¯ï¼Œå°†å¤„ç†äº‹åŠ¡æ‰€éœ€è¦çš„ä¿¡æ¯ï¼ˆå‘½ä»¤ç ã€PIDç­‰ï¼‰å’Œæ•°æ®ï¼ˆæ•°æ®åŒºé¦–åœ°å€å’Œåç§»æ•°ç»„åœ°å€ï¼‰å‡†å¤‡å¥½ï¼Œæ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ï¼Œäº¤ç»™ç”¨æˆ·ç©ºé—´å¤„ç†è¿™ä¸ªäº‹åŠ¡ï¼Œè¿˜æœ‰ä¸€äº›ç»†èŠ‚éƒ½åœ¨ä¸Šé¢ä»£ç æ³¨é‡Šä¸­æ ‡å‡ºæ¥äº†ï¼Œåº”è¯¥è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ ç»“æŸåˆ°è¿™é‡Œï¼Œä»clientå‘binderé©±åŠ¨å‘èµ·è¯·æ±‚ï¼Œåˆ°binderé©±åŠ¨æ‰¾åˆ°serverå¹¶å°†è¯·æ±‚ä¼ é€’ç»™serverè¿™ä¸€æ•´ä¸ªæµç¨‹æˆ‘ä»¬åŸºæœ¬ä¸Šæ˜¯çœ‹å®Œäº†ï¼Œå¯¹äºè¢«TF_ONE_WAYæ ‡è®°çš„äº‹åŠ¡ï¼ˆæ— éœ€è¿”å›ï¼‰ï¼Œåœ¨serverä¸­å¤„ç†å®Œï¼Œè¿™ä¸€æ•´æ¡binderè¿›ç¨‹é€šä¿¡æµç¨‹ä¹Ÿå°±ç»“æŸäº†ï¼Œè€Œå¯¹äºéœ€è¦è¿”å›çš„äº‹åŠ¡ï¼Œåˆ™è¿˜éœ€è¦serverå‘binderé©±åŠ¨å‘èµ·BC_REPLYäº‹åŠ¡è¯·æ±‚ï¼Œè¿›è¡Œä¸€æ¬¡è¿›ç¨‹é—´é€šä¿¡ï¼Œå°†å¤„ç†åçš„è¿”å›å€¼ä¼ ç»™clientè¿›ç¨‹ æ€»ç»“æˆ‘ä»¬å·²ç»å°†binderé©±åŠ¨æ‰€æ‰¿æ‹…çš„å·¥ä½œåˆ†æçš„ä¸ƒä¸ƒå…«å…«äº†ï¼Œä½†è‚¯å®šè¿˜æœ‰å¾ˆå¤šåœ°æ–¹å¤§å®¶äº‘é‡Œé›¾é‡Œï¼ˆå®é™…ä¸Šæˆ‘ä¹Ÿæ˜¯è¿™æ ·çš„ï¼‰ï¼Œè¿™æ˜¯å› ä¸ºbinderè¿›ç¨‹é—´é€šä¿¡ä¸ä»…éœ€è¦binderé©±åŠ¨çš„å¤„ç†ï¼Œè¿˜éœ€è¦frameworkå±‚çš„ååŠ©ï¼Œå¾ˆå¤šäº‹æƒ…ï¼Œæ¯”å¦‚è¯´binderå¯¹è±¡çš„å‹æ‰æ‰“åŒ…å°±æ˜¯åœ¨frameworkå±‚åšçš„ï¼Œæˆ‘ä»¬åœ¨binderé©±åŠ¨å±‚åªå…³æ³¨äº†ä¼ è¾“ï¼Œä½†å´ä¸çŸ¥é“ä¼ è¾“çš„æ˜¯ä»€ä¹ˆï¼Œç»“æ„æ˜¯æ€æ ·çš„ï¼Œå½“ç„¶ä¼šäº§ç”Ÿå„ç§å„æ ·çš„ç–‘æƒ‘ï¼Œåé¢æˆ‘ä»¬å°±å°†ä¼šå¯¹frameworkå±‚å¯¹binderæä¾›çš„æ”¯æŒæ¥ç€åšåˆ†æ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android ASMæ’æ¡©","slug":"android/stub/AndroidASMæ’æ¡©","date":"2022-03-01T07:32:00.000Z","updated":"2022-11-13T09:55:54.359Z","comments":true,"path":"2022/03/01/android/stub/AndroidASMæ’æ¡©/","link":"","permalink":"http://yoursite.com/2022/03/01/android/stub/AndroidASM%E6%8F%92%E6%A1%A9/","excerpt":"","text":"ç®€ä»‹ASMæ’æ¡©åœ¨ç½‘ä¸Šå…¶å®å·²ç»æœ‰å¾ˆå¤šèµ„æ–™äº†ï¼Œæˆ‘ä¹‹æ‰€ä»¥å†å†™è¿™ç¯‡æ–‡ç« å‘¢ï¼Œä¸€æ˜¯å› ä¸ºå¥½ä¹…å‰å­¦ä¹ çš„ASMï¼Œç°åœ¨å·²ç»å¿˜çš„å·®ä¸å¤šäº†ï¼Œéœ€è¦å†å›é¡¾ä¸€ä¸‹ï¼ŒäºŒæ¥æ˜¯è®°å½•ä¸€ä¸‹å­¦ä¹ è¿‡ç¨‹ï¼Œä»¥åå¦‚æœå†æœ‰ç»†èŠ‚è®°ä¸æ¸…æ¥šå¯ä»¥å¾ˆæ–¹ä¾¿çš„å°±èƒ½æŸ¥åˆ°ï¼Œä¸‰æ¥å†å­¦ä¹ çš„è¿‡ç¨‹ä¸­ä¹Ÿè¸©äº†ä¸€äº›å‘ï¼Œæ”¶è·äº†ä¸€äº›å¿ƒå¾—ï¼Œè¿™äº›ä¹Ÿéœ€è¦ä¸€ä¸ªåœ°æ–¹è®°å½•ä¸€ä¸‹ã€‚ å¥½äº†ï¼ŒåºŸè¯å°±è¯´åˆ°è¿™é‡Œï¼Œæ¥ä¸‹æ¥å¼€å§‹æ­£æ–‡ã€‚ æ’æ¡©æŠ€æœ¯æŒ‡åœ¨ä¿è¯åŸæœ‰ç¨‹åºé€»è¾‘å®Œæ•´æ€§çš„åŸºç¡€ä¸Šï¼Œåœ¨ç¨‹åºä¸­æ’å…¥æ¢é’ˆï¼Œé€šè¿‡æ¢é’ˆé‡‡é›†ä»£ç ä¸­çš„ä¿¡æ¯ï¼ˆæ–¹æ³•æœ¬èº«ã€æ–¹æ³•å‚æ•°å€¼ã€è¿”å›å€¼ç­‰ï¼‰åœ¨ç‰¹å®šçš„ä½ç½®æ’å…¥ä»£ç æ®µï¼Œä»è€Œæ”¶é›†ç¨‹åºè¿è¡Œæ—¶çš„åŠ¨æ€ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚ æ’æ¡©æŠ€æœ¯å¤§ä½“å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š APTï¼ˆAnnotation Process Toolsï¼‰ï¼Œåœ¨ç¼–è¯‘çš„æ—¶å€™ï¼ŒåŠ¨æ€ç”Ÿæˆ Java æ–‡ä»¶ï¼Œä¹‹åç¼–è¯‘å™¨å°†ç”Ÿæˆçš„ Java æ–‡ä»¶ç¼–è¯‘æˆ class æ–‡ä»¶ï¼Œåƒ ButterKnifeã€Dagger å°±æ˜¯é€šè¿‡ APT çš„æ–¹å¼ç”Ÿæˆä»£ç çš„ã€‚ ä»£è¡¨å·¥å…·ï¼šButterKnife AOPï¼ˆAspect Oriented Programmingï¼‰ï¼Œç”Ÿæˆ class æ–‡ä»¶åï¼Œä¿®æ”¹ class æ–‡ä»¶çš„å­—èŠ‚ç ï¼Œè¾¾åˆ°ä¿®æ”¹ä»£ç çš„ç›®çš„ã€‚ ä»£è¡¨å·¥å…·ï¼šå¬äº‘ å·¥å…·æˆ‘ä»¬è¿™æ¬¡é€‰ç”¨AOPæŠ€æœ¯ï¼Œæˆ‘ä»¬çœ‹çœ‹æœ‰å“ªäº›å·¥å…·å¯ä»¥å¸®åŠ©æˆ‘ä»¬å®Œæˆæ’æ¡©å·¥ä½œï¼š AspectJï¼Œæˆç†Ÿç¨³å®šï¼Œä½¿ç”¨è€…ä¸éœ€è¦å¯¹å­—èŠ‚ç æ–‡ä»¶æœ‰æ·±å…¥çš„ç†è§£ï¼Œä½¿ç”¨ç®€å•ã€‚ä½†æ˜¯å…¶åˆ‡å…¥ç‚¹ç›¸å¯¹å›ºå®šï¼Œå¯¹äºå­—èŠ‚ç æ–‡ä»¶çš„æ“ä½œè‡ªç”±åº¦ä»¥åŠå¼€å‘çš„æŒæ§åº¦å°±å¤§æ‰“æŠ˜æ‰£ã€‚å¹¶ä¸”ï¼Œä»–ä¼šé¢å¤–ç”Ÿæˆä¸€äº›åŒ…è£…ä»£ç ï¼Œå¯¹æ€§èƒ½ä»¥åŠåŒ…å¤§å°æœ‰ä¸€å®šå½±å“ã€‚ ASMï¼Œå¯ä»¥ä¿®æ”¹ç°æœ‰çš„å­—èŠ‚ç æ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥åŠ¨æ€ç”Ÿæˆå­—èŠ‚ç æ–‡ä»¶ï¼Œå®Œå…¨ä»å­—èŠ‚ç å»æ“ä½œå­—èŠ‚ç çš„æ¡†æ¶ï¼Œæ›´åŠ çµæ´»ï¼ŒåŠŸèƒ½æ›´åŠ å¼ºå¤§ï¼Œå¯ä»¥æ ¹æ®éœ€æ±‚è‡ªå®šä¹‰ä¿®æ”¹ã€æ’å…¥ã€åˆ é™¤ï¼Œæ€§èƒ½ä¹Ÿååˆ†å‡ºè‰²ï¼Œä½†æ˜¯è¦å¯¹å­—èŠ‚ç æ–‡ä»¶æœ‰æ¯”è¾ƒæ·±å…¥çš„äº†è§£ï¼Œä¸Šæ‰‹ä¹Ÿæ›´éš¾ã€‚ æˆ‘ä»¬ä½¿ç”¨ASMæ¥å®Œæˆæ’æ¡©ï¼Œåœ¨ä»‹ç»Androidå­—èŠ‚ç æ’æ¡©ä¹‹å‰ï¼Œéœ€è¦å…ˆäº†è§£ä¸€ä¸‹Javaå­—èŠ‚ç çš„æ¦‚å¿µå’ŒAndroidç¨‹åºæ‰“åŒ…è¿‡ç¨‹ã€‚ å­—èŠ‚ç æˆ‘ä»¬çŸ¥é“ï¼ŒJavaç¨‹åºæ˜¯è¿è¡Œåœ¨JVMï¼ˆJavaè™šæ‹Ÿæœºï¼‰ä¸Šçš„ï¼ŒJavaæºä»£ç é¦–å…ˆä¼šç”±ç¼–è¯‘å™¨ï¼ˆJava Compilerï¼‰ç¼–è¯‘æˆåŒ…å«äº†Bytecodeï¼ˆå­—èŠ‚ç ï¼‰çš„.classæ–‡ä»¶ï¼Œç¨‹åºæ‰§è¡Œæ—¶ï¼Œç”±ç±»åŠ è½½å™¨(class loader)å°†è¯¥ç±»çš„å­—èŠ‚ç åŠ è½½åˆ°JVMä¸­ï¼ŒJVMä¼šè§£é‡Šæ‰§è¡Œç›¸åº”çš„Bytecodeã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸ºä»€ä¹ˆä¸ç›´æ¥å½»åº•ç¼–è¯‘æˆæœºå™¨ç ï¼Œè€Œéœ€è¦å­—èŠ‚ç è¿™ä¸ªä¸­é—´äº§ç‰©å‘¢ï¼ŸJavaæ˜¯ä¸€é—¨è·¨å¹³å°çš„è¯­è¨€ï¼Œä¸ºäº†å®ç°ä¸€ä»½æºç ï¼Œå¤„å¤„è¿è¡Œçš„æ•ˆæœï¼Œæ¯ä¸ªå¹³å°éƒ½æœ‰å¯¹åº”ä¸åŒçš„JVMï¼Œå®ƒä¼šå°†æºç å¯¹åº”çš„æŒ‡ä»¤ç¿»è¯‘æˆå¯¹åº”å¹³å°èƒ½å¤Ÿç†è§£çš„æœºå™¨æŒ‡ä»¤ã€‚é‚£ä¸ºä»€ä¹ˆä¸ä»æºç ç›´æ¥è§£é‡Šæ‰§è¡Œå‘¢ï¼Œæˆ‘ä¸ªäººè®¤ä¸ºè¿™æ˜¯å› ä¸ºç›´æ¥ä»æºç å¼€å§‹çš„ç¼–è¯‘ï¼Œé€Ÿåº¦éå¸¸æ…¢ï¼Œå‡ºäºæ€§èƒ½çš„è€ƒè™‘ï¼Œå…ˆå°†æºç åšä¸€äº›é¢„å¤„ç†ï¼Œå¤„ç†ä¸ºå­—èŠ‚ç ï¼Œæ¥å‡è½»è¿è¡Œå‰çš„ç¼–è¯‘çš„æ€§èƒ½å¼€é”€ã€‚ åœ¨åšæ’æ¡©ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆè¦è®°ä½ä¸€ç‚¹ï¼šJava å­—èŠ‚ç æŒ‡ä»¤æ˜¯åŸºäºå †æ ˆæ“ä½œçš„ï¼Œå› ä¸ºå¤§éƒ¨åˆ†çš„Javaè™šæ‹Ÿæœºå¯¹å­—èŠ‚ç çš„æ‰§è¡Œæ˜¯åŸºäºå †æ ˆçš„ï¼ˆAndroidçš„Dalvikè™šæ‹Ÿæœºæ˜¯åŸºäºå¯„å­˜å™¨çš„ï¼Œä¸è¿‡ä¸å½±å“æˆ‘ä»¬çš„æ’æ¡©ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬å¯¹javaå­—èŠ‚ç æ’å®Œæ¡©åï¼Œæ‰ä¼šæ‰§è¡Œä»javaå­—èŠ‚ç è½¬æ¢åˆ°dexæ–‡ä»¶çš„è¿‡ç¨‹ï¼‰ Androidæ‰“åŒ…è¿‡ç¨‹ Androidæ’æ¡©è¿‡ç¨‹ å®æˆ˜è¿™æ¬¡ï¼Œæˆ‘ä»¬æ¨¡ä»¿å¬äº‘ï¼Œåšä¸€ä¸ªActivityç”Ÿå‘½å‘¨æœŸæ‰§è¡Œæ—¶é—´æ£€æµ‹çš„æ’ä»¶ã€‚ æˆ‘ä»¬å…ˆæ¢³ç†ä¸€ä¸‹åŠŸèƒ½ç‚¹ï¼š é’ˆå¯¹Activityç±» é’ˆå¯¹ç”Ÿå‘½å‘¨æœŸæ–¹æ³• æ”¯æŒæ’ä»¶è‡ªå®šä¹‰é…ç½® æˆ‘ä»¬ç”¨Javaä»£ç æŠŠæˆ‘ä»¬æƒ³è¦æ’å…¥çš„é€»è¾‘å†™ä¸€éï¼š 1234567891011121314151617181920public class Test &#123; //è¿™é‡Œå–è¿™ä¸ªåå­—æ˜¯ä¸ºäº†é˜²æ­¢å’Œä»£ç æœ¬èº«çš„æˆå‘˜å˜é‡äº§ç”Ÿå†²çª private long _$_timeRecorder; public void onCreate(Bundle savedInstanceState) &#123; //å‘å®é™…ä»£ç å‰æ’å…¥ä»£ç  _$_timeRecorder = -System.currentTimeMillis(); ... //è¿™é‡Œæ˜¯å®é™…ä»£ç  //å‘å®é™…ä»£ç åæ’å…¥ä»£ç  _$_timeRecorder += System.currentTimeMillis(); System.err.println(\"Time spent: \" + _$_timeRecorder + \"ms, when \" + className + \".onCreate\"); StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace(); for (StackTraceElement element : stackTraceElements) &#123; System.err.println(element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber()); &#125; &#125;&#125; æ¥ä¸‹æ¥æ­£å¼å¼€å§‹ç¼–å†™æ’ä»¶ æ–°å»ºæ’ä»¶å·¥ç¨‹ç”±äºAndroid Studioæ²¡æœ‰æ–°å»ºgradleè„šæœ¬çš„é€‰é¡¹ï¼Œæˆ‘ä»¬å…ˆæ–°å»ºä¸€ä¸ªEmpty Activity Projectï¼Œåœ¨æ­¤åŸºç¡€ä¸Šè¿›è¡Œæ”¹é€ ã€‚ æ–°å»ºmodule æ›´æ”¹moduleçš„build.gradleæ–‡ä»¶ æ–°å»ºgroovyæºä»£ç ç›®å½• æ–°å»ºgroovyç±»å®ç°Plugin&lt;Project&gt;æ¥å£ æ–°å»ºresource/META_INF/xxx.properitesæ–‡ä»¶ï¼ˆxxxä¸ºæ’ä»¶çš„idåï¼‰ åœ¨properitesæ–‡ä»¶ä¸­å£°æ˜æ’ä»¶çš„å®ç°ç±» ä¸ºæ’ä»¶æä¾›å¯é…ç½®çš„åŠŸèƒ½ æ–°å»ºä¸€ä¸ªå®ä½“ç±»ç”¨æ¥ä¿å­˜é…ç½®ä¿¡æ¯ 12345678910111213141516public class AsmConfigModel &#123; /** * ä»¥æ­¤å‚æ•°ä¸ºå¼€å¤´çš„ç±»ï¼ˆå…¨é™å®šç±»åï¼‰æ‰æ’æ¡© * å¦‚æœä¸é…æ­¤å‚æ•°åˆ™ä»£è¡¨æ‰€æœ‰ç±»éƒ½å¯æ’æ¡© */ public List&lt;String&gt; startWithPatterns; /** * æ’é™¤åˆ—è¡¨ï¼ˆå…¨é™å®šç±»åï¼‰ */ public List&lt;String&gt; excludes; /** * æ’é™¤åˆ—è¡¨ï¼ˆå…¨é™å®šç±»åï¼‰ * ä»¥æ–‡ä»¶å½¢å¼ */ public File excludesByFile;&#125; åœ¨æ’ä»¶applyçš„æ—¶å€™åˆ›å»ºè¿™ä¸ªé…ç½®ç±»ï¼Œä»¥æä¾›ç»™ä½¿ç”¨è€…é…ç½® 12345@Overridevoid apply(Project project) &#123; println 'apply AsmPlugin' mConfig = project.extensions.create(\"asmConfig\", AsmConfigModel.class)&#125; åœ¨ä½¿ç”¨è¯¥æ’ä»¶çš„moduleä¸‹çš„build.gradleæ–‡ä»¶ä¸­é…ç½® 1234asmConfig &#123; startWithPatterns = ['com.shanbay'] excludesByFile = new File(projectDir, \"asm-excludes.txt\")&#125; æ–°å»ºasm-excludes.txtæ–‡ä»¶ï¼Œé…ç½®excludeä¿¡æ¯ 1com&#x2F;xxx&#x2F;xxx&#x2F;BaseActivity è¿™é‡Œæ˜¯ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨å·¥ç¨‹ä¸­å¾ˆæœ‰å¯èƒ½æœ‰çš„Activityç»§æ‰¿è‡ªä¸€äº›åŸºç±»Activityï¼Œå¯¹è¿™äº›ç±»æ’æ¡©å°±é‡å¤äº† ä½¿ç”¨Transform Apiæ ¹æ®å®˜ç½‘ä»‹ç»ï¼ŒTransform Apiå…è®¸ç¬¬ä¸‰æ–¹ Plugin åœ¨æ‰“åŒ… dex æ–‡ä»¶ä¹‹å‰çš„ç¼–è¯‘è¿‡ç¨‹ä¸­æ“ä½œ.class æ–‡ä»¶ï¼Œä¸‹å›¾æ˜¯Transform Apiçš„å·¥ä½œæµç¨‹ å¯ä»¥çœ‹åˆ°ï¼Œä¸€æ¬¡Appçš„ç¼–è¯‘æ‰“åŒ…å¯èƒ½ä¼šç»å†å¤šæ¬¡Transformï¼ŒTransformå°†è¾“å…¥è¿›è¡Œå¤„ç†ï¼Œç„¶åå†™å…¥åˆ°æŒ‡å®šçš„ç›®å½•ä¸‹ä½œä¸ºä¸‹ä¸€ä¸ª Transform çš„è¾“å…¥æºã€‚ ä½¿ç”¨æ’æ¡©å·¥å…·ï¼Œæˆ‘ä»¬éœ€è¦å€ŸåŠ©äºTransform Apiå®ç° é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦è®©æˆ‘ä»¬çš„æ’ä»¶ç»§æ‰¿è‡ªTransform ç„¶åï¼Œæˆ‘ä»¬è¦åœ¨æ’ä»¶applyæ—¶æ³¨å†ŒTransform 1234567@Overridevoid apply(Project project) &#123; println 'apply AsmPlugin' def android = project.extensions.getByType(AppExtension.class) android.registerTransform(this) mConfig = project.extensions.create(\"asmConfig\", AsmConfigModel.class)&#125; æœ€åï¼Œéœ€è¦å®ç°Transformç±»ä¸­çš„æŠ½è±¡æ–¹æ³• getName è¿™ä¸ªæ–¹æ³•æ˜¯æŒ‡å®šè¿™ä¸ªTransformçš„åç§° 1234@OverrideString getName() &#123; return 'AsmPlugin'&#125; getInputTypes è¿™ä¸ªæ–¹æ³•æ˜¯æŒ‡å®šè¾“å…¥ç±»å‹ è¿™é‡Œï¼Œæˆ‘ä»¬é€‰ç”¨TransformManager.CONTENT_CLASSå°±å¯ä»¥äº† getScopes è¿™ä¸ªæ–¹æ³•æ˜¯æŒ‡å®šæ’æ¡©çš„ä½œç”¨åŸŸ è¿™é‡Œæˆ‘ä»¬é€‰æ‹©TransformManager.SCOPE_FULL_PROJECTï¼Œä»£è¡¨æ’æ¡©èŒƒå›´åŒ…æ‹¬æ­¤å·¥ç¨‹å’Œå®ƒä¾èµ–çš„æ‰€æœ‰åŒ… isIncremental è¿™ä¸ªæ–¹æ³•ä»£è¡¨æ˜¯å¦å¼€å¯å¢é‡ç¼–è¯‘ å¦‚æœå¼€å¯çš„è¯å¯ä»¥å‡å°‘ç¼–è¯‘æ—¶é—´ï¼Œä½†éœ€è¦å¢åŠ é¢å¤–çš„åˆ¤æ–­æ¡ä»¶ï¼Œæ‰€ä»¥è¿™é‡Œå°±å…ˆä¸å¼€å¯äº† transform è¿™ä¸ªæ–¹æ³•æ˜¯æ ¸å¿ƒæ–¹æ³•ï¼Œæˆ‘ä»¬è¦å¯¹è¾“å…¥å†…å®¹è¿›è¡Œå¤„ç†ç„¶åè¾“å‡º transform()æ–¹æ³•çš„å‚æ•° TransformInvocation æ˜¯ä¸€ä¸ªæ¥å£ï¼Œæä¾›äº†ä¸€äº›å…³äºè¾“å…¥è¾“å‡ºçš„ä¸€äº›åŸºæœ¬ä¿¡æ¯ã€‚ä¸‹å›¾æ˜¯transformä¸­æˆ‘ä»¬éœ€è¦èµ°çš„æµç¨‹ è¿™é‡Œä»¥directoryInputsä¸¾ä¾‹ï¼ŒdirectoryInputså°±æ˜¯æœ¬åœ°æºç ç¼–è¯‘åäº§ç”Ÿçš„classæ–‡ä»¶ 12345678910111213141516171819202122232425262728293031323334353637private void handleDirectory(DirectoryInput input, TransformOutputProvider outputProvider) &#123; File file = input.file if (file.isDirectory()) &#123; //é€’å½’éå†è¯¥æ–‡ä»¶å¤¹ä¸‹é¢æ‰€æœ‰çš„å­æ–‡ä»¶å¤¹ä»¥åŠå­æ–‡ä»¶ file.eachFileRecurse &#123; subFile -&gt; def fileName = subFile.name //åˆæ­¥åˆ¤æ–­è¿™ä¸ªæ–‡ä»¶ï¼ˆæˆ–æ–‡ä»¶å¤¹ï¼‰æ˜¯å¦å¯æ’æ¡© if (fileName.endsWith(\".class\") &amp;&amp; !fileName.startsWith(\"R$\") &amp;&amp; \"R.class\" != fileName &amp;&amp; \"BuildConfig.class\" != fileName) &#123; //ClassReader: å­—èŠ‚ç çš„è¯»å–ä¸åˆ†æå¼•æ“ ClassReader classReader = new ClassReader(subFile.bytes) //ClassWriter: å®ƒå®ç°äº†ClassVisitoræ¥å£ï¼Œç”¨äºæ‹¼æ¥å­—èŠ‚ç  //COMPUTE_MAXS: è‡ªåŠ¨è®¡ç®—æ ˆçš„æœ€å¤§å€¼ä»¥åŠæœ¬åœ°å˜é‡çš„æœ€å¤§æ•°é‡ //COMPUTE_FRAMES: åŒ…å«COMPUTE_MAXSï¼Œä¸”ä¼šè‡ªåŠ¨è®¡ç®—æ–¹æ³•çš„æ ˆæ¡¢ ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) //ClassVisitor: å®šä¹‰åœ¨è¯»å–Classå­—èŠ‚ç æ—¶ä¼šè§¦å‘çš„äº‹ä»¶ï¼Œå¦‚ç±»å¤´è§£æå®Œæˆã€æ³¨è§£è§£æã€å­—æ®µè§£æã€æ–¹æ³•è§£æç­‰ ClassVisitor cv = new AsmClassVisitor(api, classWriter, mConfig) //ä½¿ç»™å®šçš„ClassVisitorè®¿é—®ä¼ é€’ç»™æ­¤æ„é€ å‡½æ•°çš„jvmç±»æ–‡ä»¶ç»“æ„ //EXPAND_FRAMES: å±•å¼€æ ˆå¸§çš„æ ‡å¿—ä½ classReader.accept(cv, ClassReader.EXPAND_FRAMES) FileOutputStream fos = new FileOutputStream( subFile.parentFile.absolutePath + File.separator + fileName) fos.write(classWriter.toByteArray()) fos.close() &#125; &#125; &#125; def dest = outputProvider.getContentLocation( input.name, input.contentTypes, input.scopes, Format.DIRECTORY ) FileUtils.copyDirectoryToDirectory(file, dest)&#125; å¯ä»¥ç”¨ä»¥ä¸‹æµç¨‹å›¾å¤§æ¦‚æè¿°ä¸€ä¸‹ä¸€ä¸ªclassæ–‡ä»¶çš„ä¿®æ”¹è¿‡ç¨‹ è‡ªå®šä¹‰ClassVisitoræˆ‘ä»¬å¼€å§‹ç»§æ‰¿ClassVisitoræ¥å®ç°æˆ‘ä»¬å¯¹ç±»çš„ä¿®æ”¹ è¯»å–é…ç½® è®¿é—®ç±» é€šè¿‡è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬å¯ä»¥è·å¾—è¿™ä¸ªç±»çš„è®¿é—®æ§åˆ¶ï¼Œå…¨é™å®šç±»åï¼Œçˆ¶ç±»åï¼Œå®ç°çš„æ¥å£åç­‰ä¿¡æ¯ è¿™é‡Œï¼Œæˆ‘ä»¬é€šè¿‡å…¨é™å®šç±»åå’Œè¯»å–å‡ºçš„é…ç½®åšæ¯”å¯¹ï¼Œè¿›ä¸€æ­¥éªŒè¯æ˜¯å¦éœ€è¦å¯¹æ­¤ç±»è¿›è¡Œæ’æ¡© è®¿é—®ç±»å†…æ–¹æ³• é€šè¿‡è¿™ä¸ªæ–¹æ³•æˆ‘ä»¬å¯ä»¥è·å¾—è¿™ä¸ªç±»çš„æ‰€æœ‰æ–¹æ³•çš„åç§°å’Œæè¿°ç¬¦ï¼Œæˆ‘ä»¬é€šè¿‡å®ƒä»¬æ¥åˆ¤æ–­è¯¥æ–¹æ³•æ˜¯å¦éœ€è¦æ’æ¡© å¦‚æœæœ‰éœ€è¦æ’æ¡©çš„æ–¹æ³•ï¼Œå°±å°†mNeedStubClassæ ‡å¿—ä½ç½®ä¸ºtrueï¼Œè¿™ä¸ªæ ‡è¯†æ˜¯ä¸ºäº†æˆ‘ä»¬åç»­åˆ¤æ–­æ˜¯å¦è¦åœ¨è¯¥ç±»ä¸­æ’å…¥æˆå‘˜å˜é‡ï¼Œç„¶åä½¿ç”¨æˆ‘ä»¬è‡ªå®šä¹‰çš„MethodVisitoræ›¿æ¢åŸå§‹çš„MethodVisitorã€‚ æ’å…¥æˆå‘˜å˜é‡ åœ¨æœ€åï¼Œå¦‚æœæœ‰éœ€è¦æ’æ¡©çš„æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦å°†private long _$_timeRecorderè¿™ä¸ªæˆå‘˜å˜é‡æ’å…¥åˆ°ç±»ä¸­å» è‡ªå®šä¹‰MethodVisitorä¹‹å‰è¯´äº†ï¼ŒJava å­—èŠ‚ç æŒ‡ä»¤æ˜¯åŸºäºæ ˆæ“ä½œçš„ï¼ŒåŸºæœ¬ä¸Šä»»ä½•æ“ä½œéƒ½ä¼šæ”¹å˜æ ˆçŠ¶æ€ åœ¨æ–¹æ³•æ‰§è¡Œä¹‹å‰æ’å…¥ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** ä»¥ä¸‹ä»£ç ä¼šä»¥æ ˆçš„å½¢å¼æ³¨é‡Šå‡ºæ¥ï¼Œä»¥å·¦è¾¹ä¸ºæ ˆé¡¶ï¼Œå³è¾¹ä¸ºæ ˆåº•* ç¤ºä¾‹ï¼š[æ ˆé¡¶ &lt;------------------&gt; æ ˆåº•]* [this, StringBuilder, System.out]* æ­¤æ—¶ï¼Œthisä¸ºæ ˆé¡¶ï¼ŒSystem.outä¸ºæ ˆåº•*/@Overridepublic void visitCode() &#123; /* å‡è®¾æ­¤æ—¶æ ˆä¸ºç©º */ //aload_0: å°†thiså‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ALOAD, 0); /* æ­¤æ—¶æ ˆå†…å®¹: [this] */ //invokestatic: è°ƒç”¨é™æ€æ–¹æ³•System.currentTimeMillis()ï¼Œè¿”å›å€¼ä¸ºåŸºç¡€ç±»å‹long //ç¬¬äºŒä¸ªå‚æ•°ä»£è¡¨ç±»çš„å…¨é™å®šåï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä»£è¡¨æ–¹æ³•åï¼Œç¬¬å››ä¸ªå‚æ•°ä»£è¡¨å‡½æ•°ç­¾åï¼Œ()Jçš„æ„æ€æ˜¯ä¸æ¥å—å‚æ•°ï¼Œè¿”å›å€¼ä¸ºJ (Jåœ¨å­—èŠ‚ç é‡Œä»£è¡¨åŸºç¡€ç±»å‹long) mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [System.currentTimeMillis()çš„ç»“æœå€¼, this] */ //lneg: å°†æ ˆé¡¶çš„longç±»å‹å–è´Ÿå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶ mv.visitInsn(Opcodes.LNEG); /* æ­¤æ—¶æ ˆå†…å®¹: [System.currentTimeMillis()çš„ç»“æœå€¼å–è´Ÿ, this] */ //putfield: ä¸ºè¯¥ç±»çš„æ­¤å®ä¾‹å˜é‡èµ‹å€¼ //ä»¥(æ ˆé¡¶ - 1)ä¸ºæ‰§è¡Œå¯¹è±¡ï¼Œä¸ºå…¶èµ‹å€¼ä¸ºæ ˆé¡¶å€¼ (this._$_timeRecorder = -System.currentTimeMillis()) mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, \"J\"); super.visitCode();&#125; åœ¨æ–¹æ³•returnä¹‹å‰æ’å…¥ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453/*** ä»¥ä¸‹ä»£ç ä¼šä»¥æ ˆçš„å½¢å¼æ³¨é‡Šå‡ºæ¥ï¼Œä»¥å·¦è¾¹ä¸ºæ ˆé¡¶ï¼Œå³è¾¹ä¸ºæ ˆåº•* ç¤ºä¾‹ï¼š[æ ˆé¡¶ &lt;------------------&gt; æ ˆåº•]* [this, StringBuilder, System.out]* thisä¸ºæ ˆé¡¶ï¼ŒSystem.outä¸ºæ ˆåº•*/@Overridepublic void visitInsn(int opcode) &#123; if (opcode == Opcodes.RETURN) &#123; Label labelEnd = new Label(); /* å‡è®¾æ­¤æ—¶æ ˆä¸ºç©º */ //aload_0: å°†thiså‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ALOAD, 0); //dup: å°†æ ˆé¡¶çš„å€¼å¤åˆ¶ä¸€ä»½å‹å…¥æ ˆé¡¶ mv.visitInsn(Opcodes.DUP); /* æ­¤æ—¶æ ˆå†…å®¹: [this, this] */ //ä»¥å½“å‰æ ˆé¡¶çš„å€¼ä¸ºä¸»ä½“ï¼Œè·å–å½“å‰ç±»çš„æˆå‘˜å˜é‡_$_timeRecorderï¼Œç±»å‹ä¸ºlong //ç›¸å½“äºthis._$_timeRecorder mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, \"J\"); /* æ­¤æ—¶æ ˆå†…å®¹: [this._$_timeRecorder, this] */ //æ‰§è¡ŒSystem.currentTimeMillis()ï¼Œå¹¶å°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [System.currentTimeMillis()æ‰§è¡Œåçš„ç»“æœå€¼, this._$_timeRecorder, this] */ //å°†æ ˆé¡¶ä¸¤longå€¼ç›¸åŠ ï¼Œå¹¶å°†ç»“æœå‹å…¥æ ˆé¡¶ //å³this._$_timeRecorder + System.currentTimeMillis mv.visitInsn(Opcodes.LADD); /* æ­¤æ—¶æ ˆå†…å®¹: [System.currentTimeMillis() + this._$_timeRecorder, this] */ //å°†æ ˆé¡¶çš„å€¼å­˜å…¥(æ ˆé¡¶ - 1)._$_timeRecorderä¸­ //å³this._$_timeRecorder = this._$_timeRecorder + System.currentTimeMillis mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, \"J\"); /* æ­¤æ—¶æ ˆä¸ºç©º */ //L: å¯¹è±¡ç±»å‹ï¼Œä»¥åˆ†å·ç»“å°¾ï¼Œå¦‚Ljava/lang/Object; mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\"); /* æ­¤æ—¶æ ˆå†…å®¹: [System.out] */ //æ„å»ºå­—ç¬¦ä¸² //åˆ›å»ºä¸€ä¸ªStringBuilderå¯¹è±¡ï¼Œæ­¤æ—¶è¿˜å¹¶æ²¡æœ‰æ‰§è¡Œæ„é€ æ–¹æ³• mv.visitTypeInsn(Opcodes.NEW, \"java/lang/StringBuilder\"); //å› ä¸ºæ‰§è¡Œæ„é€ å‡½æ•°ä¼šå°†æ ˆé¡¶çš„StringBuilderå¯¹è±¡å¼¹å‡ºï¼Œä¸ºäº†åç»­èƒ½ç»§ç»­ä½¿ç”¨è¿™ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦å…ˆå¤åˆ¶ä¸€ä»½ mv.visitInsn(Opcodes.DUP); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, StringBuilder, System.out] */ //ä»¥æ ˆé¡¶çš„StringBuilderè°ƒç”¨æ„é€ æ–¹æ³• mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] */ //å°†å¸¸é‡å‹å…¥æ ˆé¡¶ mv.visitLdcInsn(\"Time spent: \"); /* æ­¤æ—¶æ ˆå†…å®¹: [\"Time spent: \", StringBuilder, System.out] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºå‚æ•°ï¼Œ(æ ˆé¡¶ - 1)çš„å¼•ç”¨ä¸ºä¸»ä½“æ‰§è¡ŒStringBuilder.append()æ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] */ //å°†thiså‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ALOAD, 0); /* æ­¤æ—¶æ ˆå†…å®¹: [this, StringBuilder, System.out] */ //ä»¥å½“å‰æ ˆé¡¶çš„å€¼ä¸ºä¸»ä½“ï¼Œè·å–å½“å‰ç±»çš„æˆå‘˜å˜é‡_$_timeRecorderï¼Œç±»å‹ä¸ºlong //ç›¸å½“äºthis._$_timeRecorder mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, \"J\"); /* æ­¤æ—¶æ ˆå†…å®¹: [this._$_timeRecorder, StringBuilder, System.out] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºå‚æ•°ï¼Œ(æ ˆé¡¶ - 1)çš„å¼•ç”¨ä¸ºä¸»ä½“æ‰§è¡ŒStringBuilder.append()æ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(J)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] */ //å°†å¸¸é‡å‹å…¥æ ˆé¡¶ mv.visitLdcInsn(\"ms, when \" + mFormatClassName + \".\" + mMethodName + \":\" + mMethodDescriptor); /* æ­¤æ—¶æ ˆå†…å®¹: [å­—ç¬¦ä¸²å¸¸é‡, StringBuilder, System.out] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºå‚æ•°ï¼Œ(æ ˆé¡¶ - 1)çš„å¼•ç”¨ä¸ºä¸»ä½“æ‰§è¡ŒStringBuilder.append()æ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºä¸»ä½“ï¼Œæ‰§è¡ŒStringBuilder.toString()æ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [String, System.out] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºå‚æ•°ï¼Œ(æ ˆé¡¶ - 1)çš„å¼•ç”¨ä¸ºä¸»ä½“æ‰§è¡ŒPrintStream.println()æ–¹æ³• //ç›¸å½“äºSystem.out.println(String) mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false); /* æ­¤æ—¶æ ˆä¸ºç©º */ //æ‰§è¡ŒThread.currentThread()ï¼Œå¹¶å°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/Thread\", \"currentThread\", \"()Ljava/lang/Thread;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [Thread.currentThread()æ‰§è¡Œçš„ç»“æœ] */ //ä»¥æ ˆé¡¶çš„å€¼ä¸ºä¸»ä½“ï¼Œæ‰§è¡ŒgetStackTrace()æ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ //ç›¸å½“äºThread.currentThread().getStackTrace() mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/Thread\", \"getStackTrace\", \"()[Ljava/lang/StackTraceElement;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„] */ //astore: å°†ä¸€ä¸ªå¼•ç”¨ç±»å‹å¯¹è±¡ä¿å­˜åˆ°å±€éƒ¨å˜é‡è¡¨indexä¸º2çš„ä½ç½®ï¼ˆindex1: this, index2: onCreateæ–¹æ³•çš„å‚æ•°ï¼‰ //ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶å˜é‡ä¿å­˜StackTraceElementæ•°ç»„ mv.visitVarInsn(Opcodes.ASTORE, 2); //å°†å±€éƒ¨å˜é‡è¡¨index2å¤„çš„å¼•ç”¨å¯¹è±¡å‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ALOAD, 2); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 ] [this | Bundle | StackTraceElementæ•°ç»„] */ //StackTraceElementæ•°ç»„å¤‡ä»½ mv.visitVarInsn(Opcodes.ASTORE, 3); mv.visitVarInsn(Opcodes.ALOAD, 3); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„] */ //è·å¾—æ ˆé¡¶ä½ç½®æ•°ç»„çš„é•¿åº¦ mv.visitInsn(Opcodes.ARRAYLENGTH); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„é•¿åº¦] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„] */ //å°†æ•°ç»„lengthä¿å­˜è‡³å±€éƒ¨å˜é‡è¡¨index4çš„ä½ç½® mv.visitVarInsn(Opcodes.ISTORE, 4); /* æ­¤æ—¶æ ˆä¸ºç©º æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦] */ //å°†intå¸¸é‡0å‹å…¥æ ˆé¡¶ mv.visitInsn(Opcodes.ICONST_0); //å°†æ ˆé¡¶çš„0å–å‡ºä¿å­˜ï¼ˆç”¨ä½œå¾ªç¯ä¸‹æ ‡indexï¼‰ mv.visitVarInsn(Opcodes.ISTORE, 5); /* æ­¤æ—¶æ ˆä¸ºç©º æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index] */ //å¾ªç¯å¼€å§‹å¤„ //æ’å…¥ä¸€ä¸ªlabelç”¨æ¥åšåç»­å¾ªç¯è·³è½¬çš„æ ‡å¿— Label labelLoop = new Label(); mv.visitLabel(labelLoop); //å°†å¾ªç¯æ ‡å¿—ä½çš„å€¼å‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ILOAD, 5); //å°†æ•°ç»„é•¿åº¦å€¼å‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ILOAD, 4); /* æ­¤æ—¶æ ˆå†…å®¹: [å¾ªç¯æ ‡å¿—ä½, æ•°ç»„é•¿åº¦] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index] */ //if_icmpge: æ¯”è¾ƒæ ˆé¡¶ä¸¤intå‹æ•°å€¼å¤§å°, å½“ç»“æœå¤§äºç­‰äº0æ—¶è·³è½¬ mv.visitJumpInsn(Opcodes.IF_ICMPGE, labelEnd); /* æ­¤æ—¶æ ˆä¸ºç©º æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index] */ //å°†StackTraceElementæ•°ç»„å‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ALOAD, 3); //å°†å¾ªç¯indexçš„å€¼å‹å…¥æ ˆé¡¶ mv.visitVarInsn(Opcodes.ILOAD, 5); /* æ­¤æ—¶æ ˆå†…å®¹: [å¾ªç¯index, StackTraceElementæ•°ç»„] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index] */ //å°†å¼•ç”¨ç±»å‹æ•°ç»„æŒ‡å®šç´¢å¼•çš„å€¼æ¨é€è‡³æ ˆé¡¶ï¼ˆvar3[var5]ï¼‰ mv.visitInsn(Opcodes.AALOAD); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index] */ //å°†è¯¥ç´¢å¼•ä¸‹çš„å€¼ä¿å­˜ mv.visitVarInsn(Opcodes.ASTORE, 6); /* æ­¤æ—¶æ ˆä¸ºç©º æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å°†System.outå…¥æ ˆ mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\"); /* æ­¤æ—¶æ ˆå†…å®¹: [System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //new StringBuilder() mv.visitTypeInsn(Opcodes.NEW, \"java/lang/StringBuilder\"); mv.visitInsn(Opcodes.DUP); mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å–å‡ºStackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡) mv.visitVarInsn(Opcodes.ALOAD, 6); /* æ­¤æ—¶æ ˆå†…å®¹: [StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡), StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //ä½¿ç”¨æ ˆé¡¶å¯¹è±¡ï¼Œæ‰§è¡ŒgetClassNameæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getClassName\", \"()Ljava/lang/String;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [ClassName, StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //ä»¥ClassNameä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡çš„appendæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ //å³StringBuilder.append(ClassName) mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å°†å¸¸é‡å…¥æ ˆ mv.visitLdcInsn(\".\"); //ä»¥å¸¸é‡ä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡çš„appendæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å°†StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)å…¥æ ˆ mv.visitVarInsn(Opcodes.ALOAD, 6); //è°ƒç”¨å®ƒçš„getMethodNameæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getMethodName\", \"()Ljava/lang/String;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [MethodName, StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //ä»¥MethodNameä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡çš„appendæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å°†å¸¸é‡å…¥æ ˆ mv.visitLdcInsn(\":\"); //ä»¥å¸¸é‡ä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡çš„appendæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //å°†StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)å…¥æ ˆ mv.visitVarInsn(Opcodes.ALOAD, 6); //è°ƒç”¨å®ƒçš„getLineNumberæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getLineNumber\", \"()I\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [LineNumber, StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //ä»¥LineNumberä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡çš„appendæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(I)Ljava/lang/StringBuilder;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [StringBuilder, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //è°ƒç”¨æ ˆé¡¶å¯¹è±¡çš„toStringæ–¹æ³•ï¼Œå°†è¿”å›å€¼å‹å…¥æ ˆé¡¶ mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); /* æ­¤æ—¶æ ˆå†…å®¹: [String, System.out] æ­¤æ—¶å±€éƒ¨å˜é‡è¡¨ä¸­: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElementæ•°ç»„ | StackTraceElementæ•°ç»„ | æ•°ç»„é•¿åº¦ | å¾ªç¯index | StackTraceElementæ•°ç»„ä¸­çš„æŸä¸ªå€¼(ä»¥å¾ªç¯indexä½œä¸ºä¸‹æ ‡)] */ //ä»¥Stringä½œä¸ºå‚æ•°ï¼Œæ‰§è¡Œ(æ ˆé¡¶ - 1)å¯¹è±¡System.outçš„printlnæ–¹æ³• mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false); //iinc: å°†æŒ‡å®šintå‹å˜é‡å¢åŠ æŒ‡å®šå€¼(index++) mv.visitIincInsn(5, 1); //è·³è½¬åˆ°labelLoopæ’å…¥çš„ä½ç½® mv.visitJumpInsn(Opcodes.GOTO, labelLoop); //æ’å…¥ç»“æŸLabelï¼Œä½œä¸ºå¾ªç¯ç»ˆæ­¢çš„è·³è½¬æ ‡å¿— mv.visitLabel(labelEnd); &#125; super.visitInsn(opcode);&#125; è¿™æ ·æˆ‘ä»¬çš„æ–¹æ³•æ’æ¡©å·¥ä½œå°±å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¿è¡Œä¸€ä¸‹çœ‹çœ‹ è¿è¡Œå…ˆclean buildï¼Œå†buildï¼ŒæŸ¥çœ‹æ§åˆ¶å°ä¿¡æ¯ï¼Œbuildå®ŒæˆåæŸ¥çœ‹classæ–‡ä»¶ è¿è¡ŒAppï¼ŒæŸ¥çœ‹Logcatä¿¡æ¯ï¼Œå¯ä»¥çœ‹åˆ°æ‰“å°å‡ºæ¥äº†æˆ‘ä»¬æƒ³è¦çš„ä¿¡æ¯ã€‚ ç»“è¯­è¿™æ ·æˆ‘ä»¬å°±é€šè¿‡æ’æ¡©çš„æ–¹å¼ï¼Œå®ç°äº†ä¸€ä¸ªç®€å•çš„æ— ä»»ä½•ä»£ç ä¾µå…¥çš„æ€§èƒ½æ£€æµ‹å·¥å…· é€šè¿‡è¿™ä¸€æ¬¡å®è·µï¼Œæˆ‘å¯¹javaçš„ç¼–è¯‘è¿è¡Œå­—èŠ‚ç ï¼ŒAndroidçš„æ‰“åŒ…æµç¨‹æœ‰äº†æ›´æ·±çš„ç†è§£ å®Œæ•´é¡¹ç›®åœ°å€ï¼šhttps://github.com/dreamgyf/AsmPluginDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æ’æ¡©","slug":"Android/æ’æ¡©","permalink":"http://yoursite.com/categories/Android/%E6%8F%92%E6%A1%A9/"}],"tags":[{"name":"æ’æ¡©","slug":"æ’æ¡©","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A1%A9/"}]},{"title":"Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸­ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸­ï¼‰","date":"2022-02-28T08:33:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/02/28/android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸­ï¼‰/","link":"","permalink":"http://yoursite.com/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥aospåˆ†æ”¯android-11.0.0_r25ï¼Œkernelåˆ†æ”¯android-msm-wahoo-4.4-android11ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸Šï¼‰ï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº†binderé©±åŠ¨è®¾å¤‡æ˜¯å¦‚ä½•æ³¨å†Œçš„ï¼Œå¹¶ä¸”åˆ†æäº†binder_openå’Œbinder_mmapæ“ä½œå‡½æ•°ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æbinderé©±åŠ¨ä¸­æœ€é‡è¦çš„éƒ¨åˆ†binder_ioctl ioctlæˆ‘ä»¬å…ˆç®€å•ä»‹ç»ä¸€ä¸‹ioctlå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥æ§åˆ¶è®¾å¤‡çš„ï¼Œå‡½æ•°åŸå‹å¦‚ä¸‹ï¼š 1int ioctl(int fd , unsigned long cmd , .../* args */); ç¬¬ä¸€ä¸ªå‚æ•°fdä¸ºè®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦ ç¬¬äºŒä¸ªå‚æ•°cmdä¸ºå‘½ä»¤ç ï¼Œå®ƒç”±é©±åŠ¨æ–¹è‡ªå®šä¹‰ï¼Œç”¨æˆ·é€šè¿‡å‘½ä»¤ç å‘Šè¯‰è®¾å¤‡é©±åŠ¨æƒ³è¦å®ƒåšä»€ä¹ˆ åé¢ä¸ºå¯é€‰å‚æ•°ï¼Œå…·ä½“å†…å®¹å’Œcmdæœ‰å…³ï¼Œæ˜¯ä¼ å…¥é©±åŠ¨å±‚çš„å‚æ•° å‘½ä»¤ç Linuxå†…æ ¸æ˜¯è¿™ä¹ˆå®šä¹‰ä¸€ä¸ªå‘½ä»¤ç çš„ è®¾å¤‡ç±»å‹ åºåˆ—å· æ–¹å‘ æ•°æ®å°ºå¯¸ 8 bit 8 bit 2 bit 8~14 bit è¿™æ ·ï¼Œä¸€ä¸ªå‘½ä»¤å°±å˜æˆäº†ä¸€ä¸ªæ•´æ•°å½¢å¼çš„å‘½ä»¤ç äº†ï¼Œä¸ºäº†ä½¿ç”¨èµ·æ¥æ–¹ä¾¿ï¼ŒLinuxå®šä¹‰äº†ä¸€äº›ç”Ÿæˆå‘½ä»¤ç çš„å®ï¼š 1234_IO(type,nr) //æ²¡æœ‰å‚æ•°çš„å‘½ä»¤_IOR(type,nr,size) //ä»é©±åŠ¨ä¸­è¯»æ•°æ®_IOW(type,nr,size) //å†™æ•°æ®åˆ°é©±åŠ¨ä¸­_IOWR(type,nr,size) //åŒå‘è¯»å†™ binderé©±åŠ¨å‘½ä»¤ç äº†è§£äº†ioctlå’Œå®ƒçš„å‘½ä»¤ç åï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹binderé©±åŠ¨å®šä¹‰äº†å“ªäº›å‘½ä»¤ç ï¼Œä»¥åŠå®ƒä»¬åˆ†åˆ«æœ‰ä»€ä¹ˆä½œç”¨ binderé©±åŠ¨å‘½ä»¤ç è¢«å®šä¹‰åœ¨include/uapi/linux/android/binder.hä¸­ï¼Œå…¶ä¸­æœ‰å‡ ä¸ªè²Œä¼¼æœªä½¿ç”¨ï¼Œæˆ‘å°±ä¸åˆ—å‡ºæ¥äº† 12345678#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_MAX_THREADS _IOW('b', 5, __u32)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, __s32)#define BINDER_THREAD_EXIT _IOW('b', 8, __s32)#define BINDER_VERSION _IOWR('b', 9, struct binder_version)#define BINDER_GET_NODE_DEBUG_INFO _IOWR('b', 11, struct binder_node_debug_info)#define BINDER_GET_NODE_INFO_FOR_REF _IOWR('b', 12, struct binder_node_info_for_ref)#define BINDER_SET_CONTEXT_MGR_EXT _IOW('b', 13, struct flat_binder_object) BINDER_WRITE_READï¼šè¯»å†™å‘½ä»¤ï¼Œç”¨äºæ•°æ®ä¼ è¾“ï¼Œbinder IPCé€šä¿¡ä¸­çš„æ ¸å¿ƒ BINDER_SET_MAX_THREADSï¼šè®¾ç½®æœ€å¤§çº¿ç¨‹æ•° BINDER_SET_CONTEXT_MGRï¼šè®¾ç½®æˆä¸ºbinderä¸Šä¸‹æ–‡ç®¡ç†è€… BINDER_THREAD_EXITï¼šbinderçº¿ç¨‹é€€å‡ºå‘½ä»¤ï¼Œé‡Šæ”¾ç›¸å…³èµ„æº BINDER_VERSIONï¼šè·å–binderé©±åŠ¨ç‰ˆæœ¬å· BINDER_GET_NODE_DEBUG_INFOï¼šè·å¾—binderèŠ‚ç‚¹çš„debugä¿¡æ¯ BINDER_GET_NODE_INFO_FOR_REFï¼šä»binderå¼•ç”¨è·å¾—binderèŠ‚ç‚¹ä¿¡æ¯ BINDER_SET_CONTEXT_MGR_EXTï¼šå’ŒBINDER_SET_CONTEXT_MGRä½œç”¨ç›¸åŒï¼Œæºå¸¦é¢å¤–å‚æ•° äº†è§£äº†è¿™äº›binderé©±åŠ¨å‘½ä»¤ç ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹æ­£å¼åˆ†æbinder_ioctl binder_ioctlè¿™ä¸ªå‡½æ•°ä½äºdrivers/android/binder.cæ–‡ä»¶ä¸­ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; //ä»å‘½ä»¤å‚æ•°ä¸­è§£æå‡ºç”¨æˆ·æ•°æ®å¤§å° unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; ... //è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…è¢«å”¤é†’ ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; //æ ¹æ®è¯·æ±‚ç³»ç»Ÿè°ƒç”¨çš„çº¿ç¨‹çš„pidï¼ŒæŸ¥æ‰¾å¯¹åº”çš„binder_threadï¼Œæ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ª thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; case BINDER_WRITE_READ: ... break; case BINDER_SET_MAX_THREADS: &#123; ... break; &#125; case BINDER_SET_CONTEXT_MGR_EXT: &#123; ... break; &#125; case BINDER_SET_CONTEXT_MGR: ... break; case BINDER_VERSION: &#123; ... break; &#125; case BINDER_GET_NODE_INFO_FOR_REF: &#123; ... break; &#125; case BINDER_GET_NODE_DEBUG_INFO: &#123; ... break; &#125; default: ret = -EINVAL; goto err; &#125; ret = 0;err: ... return ret;&#125; ä»æ•´ä½“ä¸Šæ¥çœ‹è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ï¼Œæˆ‘ä»¬å¯¹ä¸€äº›ç‚¹åšä¸€ä¸‹è¯¦è§£ __user__useræ˜¯ä¸€ä¸ªå®ï¼Œå®ƒå‘Šè¯‰ç¼–è¯‘å™¨ä¸åº”è¯¥è§£é™¤è¿™ä¸ªæŒ‡é’ˆçš„å¼•ç”¨ï¼ˆå› ä¸ºåœ¨å½“å‰åœ°å€ç©ºé—´ä¸­å®ƒæ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼‰ï¼Œ(void __user *)argè¡¨ç¤ºargæ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„åœ°å€ï¼Œä¸èƒ½ç›´æ¥è¿›è¡Œæ‹·è´ç­‰ï¼Œè¦ä½¿ç”¨copy_from_userï¼Œcopy_to_userç­‰å‡½æ•°ã€‚ wait_event_interruptiblewait_event_interruptible(wq, condition)æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒæ˜¯ç”¨æ¥æŒ‚èµ·è¿›ç¨‹ç›´åˆ°æ»¡è¶³åˆ¤æ–­æ¡ä»¶çš„ binder_stop_on_user_erroræ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå®ƒçš„åˆå§‹å€¼ä¸º0ï¼Œbinder_user_error_waitæ˜¯ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ— åœ¨æ­£å¸¸æƒ…å†µä¸‹ï¼Œbinder_stop_on_user_error &lt; 2è¿™ä¸ªæ¡ä»¶æ˜¯æˆç«‹çš„ï¼Œæ‰€ä»¥ä¸ä¼šè¿›å…¥æŒ‚èµ·çŠ¶æ€ï¼Œè€Œå½“binderå› ä¸ºé”™è¯¯è€Œåœæ­¢åï¼Œè°ƒç”¨binder_ioctlï¼Œåˆ™ä¼šæŒ‚èµ·è¿›ç¨‹ï¼Œç›´åˆ°å…¶ä»–è¿›ç¨‹é€šè¿‡wake_up_interruptibleæ¥å”¤é†’binder_user_error_waité˜Ÿåˆ—ï¼Œå¹¶ä¸”æ»¡è¶³binder_stop_on_user_error &lt; 2è¿™ä¸ªæ¡ä»¶ï¼Œbinder_ioctlæ‰ä¼šç»§ç»­å¾€åè¿è¡Œ binder_threadç»“æ„ä½“æˆ‘ä»¬éœ€è¦å…³æ³¨ä¸€ä¸ªé‡è¦çš„ç»“æ„ä½“binder_threadï¼Œå®ƒåœ¨åç»­çš„ä»£ç ä¸­ä¼šé¢‘ç¹çš„å‡ºç°ï¼Œè¿™ä¸ªç»“æ„ä½“æè¿°äº†è¿›ç¨‹ä¸­çš„å·¥ä½œçº¿ç¨‹ 123456789101112131415161718192021222324252627282930313233struct binder_thread &#123; //binderçº¿ç¨‹æ‰€å±çš„è¿›ç¨‹ struct binder_proc *proc; //çº¢é»‘æ ‘èŠ‚ç‚¹ struct rb_node rb_node; //é“¾è¡¨èŠ‚ç‚¹ struct list_head waiting_thread_node; //è¿›ç¨‹pid int pid; //æè¿°äº†çº¿ç¨‹å½“å‰çš„çŠ¶æ€ int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ //binderäº‹åŠ¡æ ˆï¼ˆé“¾è¡¨å½¢å¼ï¼Œå†…éƒ¨å­˜åœ¨å‰åèŠ‚ç‚¹ï¼‰ struct binder_transaction *transaction_stack; //todoé˜Ÿåˆ—ï¼Œä¸ºéœ€è¦å¤„ç†çš„å·¥ä½œçš„é“¾è¡¨ struct list_head todo; //binder_thread_writeåæ˜¯å¦ç«‹å³æ‰§è¡Œå®Œæˆbinder_thread_read //falseçš„æƒ…å†µä¸‹ä¼šåœ¨binder_thread_readä¸­ä¼‘çœ ï¼Œå»¶è¿Ÿæ‰§è¡ŒBINDER_WORK_TRANSACTION_COMPLETE bool process_todo; struct binder_error return_error; struct binder_error reply_error; //ç­‰å¾…é˜Ÿåˆ—ï¼Œå½“å¤„ç†binderäº‹åŠ¡éœ€è¦ä¾èµ–åˆ«çš„binderäº‹åŠ¡çš„æ—¶å€™ï¼Œåˆ™ä¼šä»¥æ­¤ç­‰å¾…é˜Ÿåˆ—ç¡çœ  //ç›´åˆ°å®ƒæ‰€ä¾èµ–çš„binderäº‹åŠ¡å®Œæˆåå”¤é†’ wait_queue_head_t wait; //ç»Ÿè®¡ä¿¡æ¯ struct binder_stats stats; //ä¸´æ—¶å¼•ç”¨è®¡æ•° atomic_t tmp_ref; //æ˜¯å¦æ­»äº¡ bool is_dead; //çº¿ç¨‹ä¿¡æ¯ç»“æ„ä½“ struct task_struct *task;&#125;; binder_get_threadæ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹binder_ioctlæ˜¯æ€ä¹ˆè·å¾—binder_threadçš„ 1234567891011121314151617181920static struct binder_thread *binder_get_thread(struct binder_proc *proc)&#123; struct binder_thread *thread; struct binder_thread *new_thread; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, NULL); binder_inner_proc_unlock(proc); if (!thread) &#123; new_thread = kzalloc(sizeof(*thread), GFP_KERNEL); if (new_thread == NULL) return NULL; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, new_thread); binder_inner_proc_unlock(proc); if (thread != new_thread) kfree(new_thread); &#125; return thread;&#125; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°é‡Œé¢æœ‰é”æ“ä½œï¼Œä½¿ç”¨çš„å°±æ˜¯ä¸Šä¸€ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸Šï¼‰ä¸­æ‰€ä»‹ç»è¿‡çš„spinlockï¼Œä½¿ç”¨çš„æ˜¯binder_procç»“æ„ä½“ä¸­çš„inner_lock ç®€å•æµè§ˆä¸€ä¸‹ä»£ç æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ï¼Œbinder_get_threadé¦–å…ˆè¯•ç€ä»binder_procè·å¾—binder_threadï¼Œå¦‚æœæ²¡èƒ½è·å¾—ï¼Œå°±æ–°å»ºä¸€ä¸ªï¼Œè¿™ä¸¤ç§æƒ…å†µéƒ½è°ƒç”¨äº†binder_get_thread_ilockedå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243static struct binder_thread *binder_get_thread_ilocked( struct binder_proc *proc, struct binder_thread *new_thread)&#123; struct binder_thread *thread = NULL; struct rb_node *parent = NULL; struct rb_node **p = &amp;proc-&gt;threads.rb_node; while (*p) &#123; parent = *p; thread = rb_entry(parent, struct binder_thread, rb_node); if (current-&gt;pid &lt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_left; else if (current-&gt;pid &gt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_right; else return thread; &#125; if (!new_thread) return NULL; thread = new_thread; //binder_threadå¯¹è±¡åˆ›å»ºè®¡æ•°åŠ 1 binder_stats_created(BINDER_STAT_THREAD); thread-&gt;proc = proc; thread-&gt;pid = current-&gt;pid; //å¼•ç”¨è®¡æ•°åŠ 1 get_task_struct(current); thread-&gt;task = current; atomic_set(&amp;thread-&gt;tmp_ref, 0); init_waitqueue_head(&amp;thread-&gt;wait); //åˆå§‹åŒ–todoé˜Ÿåˆ— INIT_LIST_HEAD(&amp;thread-&gt;todo); //æ’å…¥çº¢é»‘æ ‘ rb_link_node(&amp;thread-&gt;rb_node, parent, p); rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads); thread-&gt;looper_need_return = true; thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR; thread-&gt;return_error.cmd = BR_OK; thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR; thread-&gt;reply_error.cmd = BR_OK; INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node); return thread;&#125; è¿™ä¸ªå‡½æ•°åˆ†ä¸ºå‰åä¸¤ä¸ªéƒ¨åˆ†ï¼Œå‰åŠéƒ¨åˆ†é€šè¿‡binder_proc-&gt;threadsè¿™ä¸ªçº¢é»‘æ ‘æŸ¥æ‰¾å½“å‰ç³»ç»Ÿè°ƒç”¨è¿›ç¨‹pidæ‰€å¯¹åº”çš„binder_threadï¼ŒååŠéƒ¨åˆ†åˆå§‹åŒ–äº†ä¼ å…¥çš„new_threadï¼Œå¹¶å°†å…¶æ’å…¥åˆ°çº¢é»‘æ ‘ä¸­ï¼ˆbinder_proc-&gt;threadsï¼‰ æ¥ä¸‹æ¥å°±æ˜¯åˆ¤æ–­å‘½ä»¤ç cmdï¼Œæ¥æ‰§è¡Œç›¸åº”çš„å·¥ä½œäº†ï¼Œæˆ‘ä»¬åªåˆ†ææ¯”è¾ƒé‡è¦çš„å‡ ä¸ªå‘½ä»¤ç  BINDER_WRITE_READbinderé©±åŠ¨ä¸­æœ€é‡è¦çš„å‘½ä»¤ç è‚¯å®šéBINDER_WRITE_READè«å±äº†ï¼Œè¿™ä¸ªå‘½ä»¤ç”¨æ¥è¿›è¡Œbinderè¯»å†™äº¤äº’ 12345678910111213141516171819static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; ... switch (cmd) &#123; case BINDER_WRITE_READ: ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; ... default: ret = -EINVAL; goto err; &#125; ret = 0;err: ... return ret;&#125; switch caseå‘½ä»¤ç åï¼Œç›´æ¥è°ƒç”¨äº†binder_ioctl_write_readå‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; //æ ¡éªŒç”¨æˆ·ä¼ å…¥argæ•°æ®å¤§å° if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto out; &#125; //å°†ç”¨æˆ·ç©ºé—´ubufæ‹·è´è‡³å†…æ ¸ç©ºé—´bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125; ... //å½“å†™ç¼“å­˜ä¸­æœ‰æ•°æ®ï¼Œæ‰§è¡Œbinderå†™æ“ä½œ if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); trace_binder_write_done(ret); if (ret &lt; 0) &#123; //æœ‰é”™è¯¯å‘ç”Ÿï¼Œå°†å·²è¯»æ•°æ®å¤§å°è®¾ä¸º0 bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; //å½“è¯»ç¼“å­˜ä¸­æœ‰æ•°æ®ï¼Œæ‰§è¡Œbinderè¯»æ“ä½œ if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); trace_binder_read_done(ret); //å¦‚æœtodoé˜Ÿåˆ—ä¸­æœ‰æœªå¤„ç†çš„ä»»åŠ¡ï¼Œå”¤é†’ç­‰å¾…çŠ¶æ€ä¸‹çš„çº¿ç¨‹ binder_inner_proc_lock(proc); if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; ... //å°†å†…æ ¸ç©ºé—´ä¿®æ”¹åçš„bwræ‹·è´è‡³ç”¨æˆ·ç©ºé—´ubuf if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125;out: return ret;&#125; binder_write_readç»“æ„ä½“BINDER_WRITE_READå‘½ä»¤ç æ‰€æ¥å—çš„å‚æ•°ä¸ºä¸€ä¸ªbinder_write_readç»“æ„ä½“ï¼Œæˆ‘ä»¬å…ˆæ¥äº†è§£ä¸€ä¸‹å®ƒ 12345678struct binder_write_read &#123; binder_size_t write_size; /* bytes to write */ binder_size_t write_consumed; /* bytes consumed by driver */ binder_uintptr_t write_buffer; binder_size_t read_size; /* bytes to read */ binder_size_t read_consumed; /* bytes consumed by driver */ binder_uintptr_t read_buffer;&#125;; write_sizeï¼šå†™æ•°æ®çš„æ€»å¤§å° write_consumedï¼šå·²å†™æ•°æ®å¤§å° write_bufferï¼šå†™æ•°æ®çš„è™šæ‹Ÿå†…å­˜åœ°å€ read_sizeï¼šè¯»æ•°æ®çš„æ€»å¤§å° read_consumedï¼šå·²è¯»æ•°æ®å¤§å° read_bufferï¼šè¯»æ•°æ®çš„è™šæ‹Ÿå†…å­˜åœ°å€ æ•´ä¸ªbinder_ioctl_write_readå‡½æ•°ç»“æ„æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œé¦–å…ˆæ ¡éªŒäº†ä¸€ä¸‹ç”¨æˆ·ç©ºé—´æ‰€ä¼ çš„å‚æ•°argä¸ºbinder_write_readç»“æ„ä½“ï¼Œæ¥ç€å°†å…¶ä»ç”¨æˆ·ç©ºé—´æ‹·è´è‡³å†…æ ¸ç©ºé—´bwrï¼Œæ¥ä¸‹æ¥ä¾¿æ˜¯åˆ†åˆ«æ£€æŸ¥å†™ç¼“å­˜è¯»ç¼“å­˜ä¸­æ˜¯å¦æœ‰æ•°æ®ï¼Œæœ‰çš„è¯åˆ™æ‰§è¡Œç›¸åº”çš„å†™è¯»æ“ä½œã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¯»å†™æ“ä½œæ‰€ä¼ å…¥çš„write_consumedå’Œread_consumedæ˜¯ä»¥åœ°å€çš„å½¢å¼ï¼Œå³ä¼šå¯¹è¿™ä¸¤ä¸ªå€¼è¿›è¡Œä¿®æ”¹ï¼Œä¸ç®¡è¯»å†™æ“ä½œæ˜¯å¦æ‰§è¡Œï¼ŒæˆåŠŸæˆ–è€…å¤±è´¥ï¼Œæœ€åéƒ½ä¼šè°ƒç”¨copy_to_userå°†bwrä»å†…æ ¸ç©ºé—´å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ubuf çœ‹åˆ°è¿™é‡Œï¼Œå¯èƒ½æœ‰äº›åŒå­¦ä¼šè§‰å¾—æœ‰äº›å¥‡æ€ªï¼Œè¯´å¥½binderåªè¿›è¡Œä¸€æ¬¡å¤åˆ¶çš„å‘¢ï¼Ÿå…¶å®æ˜¯è¿™æ ·çš„æ²¡é”™ï¼Œè¿™é‡Œçš„copy_from_useræˆ–è€…copy_to_useråªæ˜¯å¤åˆ¶äº†binder_write_readç»“æ„ä½“ï¼Œå¾—åˆ°äº†éœ€è¦IPCæ•°æ®çš„è™šæ‹Ÿå†…å­˜åœ°å€è€Œå·²ï¼ŒçœŸæ­£çš„å¤åˆ¶æ“ä½œæ˜¯åœ¨binderè¯»å†™æ“ä½œä¸­è¿›è¡Œçš„ binder_thread_writeå…ˆçœ‹binderå†™æ“ä½œï¼Œè¿™ä¸ªå‡½æ•°é¦–å…ˆä»ä¼ å…¥çš„å‚æ•°ä¸­ï¼Œè®¡ç®—å‡ºå¾…å†™çš„èµ·å§‹åœ°å€å’Œç»“æŸåœ°å€ï¼Œå› ä¸ºå¯èƒ½æ•°æ®ä¸­å«æœ‰å¤šä¸ªå‘½ä»¤å’Œå¯¹åº”æ•°æ®è¦å¤„ç†ï¼Œæ‰€ä»¥è¿™é‡Œå¼€äº†ä¸€ä¸ªå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­ï¼Œé¦–å…ˆè°ƒç”¨get_userï¼Œä»ç”¨æˆ·ç©ºé—´è¯»å–ä¸€ä¸ªå€¼åˆ°å†…æ ¸ç©ºé—´ä¸­æ¥ï¼Œè¿™ä¸ªå€¼å°±æ˜¯binderè¯·æ±‚ç ï¼Œç„¶åå°†æŒ‡é’ˆå‘åç§»åŠ¨32ä½ï¼Œä½¿å…¶æŒ‡å‘å¯¹åº”è¯·æ±‚ç çš„æ•°æ®å¤´ï¼Œæ¥ç€æ ¹æ®binderè¯·æ±‚ç å»å®Œæˆä¸åŒçš„å·¥ä½œï¼Œå¤„ç†å®Œåä¿®æ”¹å·²å†™æ•°æ®å¤§å° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed)&#123; uint32_t cmd; struct binder_context *context = proc-&gt;context; void __user *buffer = (void __user *)(uintptr_t)binder_buffer; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; //å¯èƒ½å«æœ‰å¤šä¸ªå‘½ä»¤å’Œå¯¹åº”æ•°æ®è¦å¤„ç† while (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123; int ret; //è·å¾—binderè¯·æ±‚ç  if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; //ä½¿æŒ‡é’ˆæŒ‡å‘æ•°æ®å¤´ ptr += sizeof(uint32_t); trace_binder_command(cmd); //è®°å½•binderæ•°æ®ä¿¡æ¯ if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123; atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]); atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]); atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]); &#125; //æ ¹æ®binderè¯·æ±‚ç ï¼Œæ‰§è¡Œä¸åŒå·¥ä½œ switch (cmd) &#123; case BC_INCREFS: case BC_ACQUIRE: case BC_RELEASE: case BC_DECREFS: &#123; ... break; &#125; case BC_INCREFS_DONE: case BC_ACQUIRE_DONE: &#123; ... break; &#125; case BC_ATTEMPT_ACQUIRE: pr_err(\"BC_ATTEMPT_ACQUIRE not supported\\n\"); return -EINVAL; case BC_ACQUIRE_RESULT: pr_err(\"BC_ACQUIRE_RESULT not supported\\n\"); return -EINVAL; case BC_FREE_BUFFER: &#123; ... break; &#125; case BC_TRANSACTION_SG: case BC_REPLY_SG: &#123; ... break; &#125; case BC_TRANSACTION: case BC_REPLY: &#123; ... break; &#125; case BC_REGISTER_LOOPER: ... break; case BC_ENTER_LOOPER: ... break; case BC_EXIT_LOOPER: ... break; case BC_REQUEST_DEATH_NOTIFICATION: case BC_CLEAR_DEATH_NOTIFICATION: &#123; ... &#125; break; case BC_DEAD_BINDER_DONE: &#123; ... &#125; break; default: pr_err(\"%d:%d unknown command %d\\n\", proc-&gt;pid, thread-&gt;pid, cmd); return -EINVAL; &#125; //è®¾ç½®å·²å†™æ•°æ®å¤§å° *consumed = ptr - buffer; &#125; return 0;&#125; binderè¯·æ±‚ç binderè¯·æ±‚ç ç”¨äºç”¨æˆ·ç©ºé—´ç¨‹åºå‘binderé©±åŠ¨å‘é€è¯·æ±‚æ¶ˆæ¯ï¼Œä»¥BCå¼€å¤´ï¼Œè¢«å®šä¹‰åœ¨enum binder_driver_command_protocolä¸­ï¼ˆinclude/uapi/linux/android/binder.hï¼‰ å‘½ä»¤ | è¯´æ˜ | å‚æ•°ç±»å‹ || â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“ | â€”â€”â€”â€”â€”â€”â€”â€”â€”- | â€”â€”â€”â€”â€”â€”â€“ || BC_TRANSACTION | Binderäº‹åŠ¡ï¼Œå³ï¼šClientå¯¹äºServerçš„è¯·æ±‚ | binder_transaction_data || BC_REPLY | äº‹åŠ¡çš„åº”ç­”ï¼Œå³ï¼šServerå¯¹äºClientçš„å›å¤ | binder_transaction_data || BC_FREE_BUFFER | é€šçŸ¥é©±åŠ¨é‡Šæ”¾Buffer | binder_uintptr_t || BC_ACQUIRE | å¼ºå¼•ç”¨è®¡æ•°+1 | __u32 || BC_RELEASE | å¼ºå¼•ç”¨è®¡æ•°-1 | __u32 || BC_INCREFS | å¼±å¼•ç”¨è®¡æ•°+1 | __u32 || BC_DECREFS | å¼±å¼•ç”¨è®¡æ•°-1 | __u32 || BC_ACQUIRE_DONE | BR_ACQUIREçš„å›å¤ | binder_ptr_cookie || BC_INCREFS_DONE | BR_INCREFSçš„å›å¤ | binder_ptr_cookie || BC_ENTER_LOOPER | é€šçŸ¥é©±åŠ¨ä¸»çº¿ç¨‹ready | void || BC_REGISTER_LOOPER | é€šçŸ¥é©±åŠ¨å­çº¿ç¨‹ready | void || BC_EXIT_LOOPER | é€šçŸ¥é©±åŠ¨çº¿ç¨‹å·²ç»é€€å‡º | void || BC_REQUEST_DEATH_NOTIFICATION | è¯·æ±‚æ¥æ”¶æ­»äº¡é€šçŸ¥ | binder_handle_cookie || BC_CLEAR_DEATH_NOTIFICATION | å»é™¤æ¥æ”¶æ­»äº¡é€šçŸ¥ | binder_handle_cookie || BC_DEAD_BINDER_DONE | å·²ç»å¤„ç†å®Œæ­»äº¡é€šçŸ¥ | binder_uintptr_t || BC_ATTEMPT_ACQUIRE | æš‚ä¸æ”¯æŒ | - || BC_ACQUIRE_RESULT | æš‚ä¸æ”¯æŒ | - | å…¶ä¸­ï¼Œæœ€é‡è¦ä¸”æœ€é¢‘ç¹çš„æ“ä½œä¸ºBC_TRANSACTION/BC_REPLYï¼Œæˆ‘ä»¬å°±åªåˆ†æä¸€ä¸‹è¿™ä¸¤ä¸ªè¯·æ±‚ç åšäº†ä»€ä¹ˆäº‹ binder_transaction12345678910111213141516171819202122232425static int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed)&#123; ... while (...) &#123; ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY, 0); break; &#125; ... &#125; ...&#125; å¯¹äºè¿™ä¸¤ä¸ªè¯·æ±‚ç ï¼Œé¦–å…ˆä»ç”¨æˆ·ç©ºé—´ä¸­å¤åˆ¶äº†ä¸€ä»½binder_transaction_dataåˆ°å†…æ ¸ç©ºé—´ï¼Œæ¥ç€å°±è°ƒç”¨binder_transactionå‡½æ•°ç»§ç»­å¤„ç† binder_transaction_dataç»“æ„ä½“åœ¨åˆ†æbinder_transactionå‡½æ•°å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€äº›ç»“æ„ä½“ binder_transaction_dataç»“æ„ä½“å°±æ˜¯BC_TRANSACTION/BC_REPLYæ‰€å¯¹åº”çš„å‚æ•°ç±»å‹ï¼Œå®ƒè¢«å®šä¹‰åœ¨include/uapi/linux/android/binder.hä¸­ 1234567891011121314151617181920212223242526272829303132333435struct binder_transaction_data &#123; union &#123; //å½“BINDER_WRITE_READå‘½ä»¤çš„ç›®æ ‡å¯¹è±¡éæœ¬åœ°binderå®ä½“æ—¶ï¼Œç”¨handleè¡¨ç¤ºå¯¹ç›®æ ‡binderçš„å¼•ç”¨ __u32 handle; //å½“BINDER_WRITE_READå‘½ä»¤çš„ç›®æ ‡å¯¹è±¡æ˜¯æœ¬åœ°binderå®ä½“æ—¶ï¼Œç”¨æ­¤åŸŸæˆå‘˜å˜é‡è¡¨ç¤ºè¿™ä¸ªå¯¹è±¡åœ¨æœ¬è¿›ç¨‹ä¸­çš„å†…å­˜åœ°å€ binder_uintptr_t ptr; &#125; target; //ç›®æ ‡binderå®ä½“æ‰€å¸¦çš„é™„åŠ æ•°æ® binder_uintptr_t cookie; //è¡¨ç¤ºè¦å¯¹ç›®æ ‡å¯¹è±¡è¯·æ±‚çš„å‘½ä»¤ä»£ç  __u32 code; //äº‹åŠ¡æ ‡å¿—ï¼Œè¯¦è§enum transaction_flags __u32 flags; //å‘èµ·è¯·æ±‚çš„è¿›ç¨‹pid pid_t sender_pid; //å‘èµ·è¯·æ±‚çš„è¿›ç¨‹uid uid_t sender_euid; //çœŸæ­£è¦ä¼ è¾“çš„æ•°æ®çš„å¤§å° binder_size_t data_size; //åç§»æ•°ç»„å¤§å°ï¼Œè¿™ä¸ªåç§»æ•°ç»„æ˜¯ç”¨æ¥æè¿°æ•°æ®åŒºä¸­ï¼Œæ¯ä¸€ä¸ªbinderå¯¹è±¡çš„ä½ç½®çš„ binder_size_t offsets_size; union &#123; struct &#123; //æ•°æ®åŒºçš„é¦–åœ°å€ binder_uintptr_t buffer; //åç§»æ•°ç»„çš„é¦–åœ°å€ï¼Œè¿™ä¸ªåç§»æ•°ç»„æ˜¯ç”¨æ¥æè¿°æ•°æ®åŒºä¸­ï¼Œæ¯ä¸€ä¸ªbinderå¯¹è±¡çš„ä½ç½®çš„ //æ•°ç»„çš„æ¯ä¸€é¡¹ä¸ºä¸€ä¸ªbinder_size_tï¼Œè¿™ä¸ªå€¼å¯¹åº”ç€æ¯ä¸€ä¸ªbinderå¯¹è±¡ç›¸å¯¹bufferé¦–åœ°å€çš„åç§» binder_uintptr_t offsets; &#125; ptr; //æ•°æ®è¾ƒå°çš„æ—¶å€™å¯ä»¥ç›´æ¥è£…åœ¨è¿™ä¸ªæ•°ç»„é‡Œ __u8 buf[8]; &#125; data;&#125;; å¯ä»¥çœ‹åˆ°ï¼ŒçœŸæ­£éœ€è¦æ‹·è´çš„æ•°æ®çš„åœ°å€æ˜¯ä¿å­˜åœ¨dataåŸŸä¸­çš„ï¼Œå¯èƒ½æ–‡å­—æè¿°çš„dataç»“æ„ä¸æ˜¯ç‰¹åˆ«æ¸…æ™°ï¼Œå¯ä»¥ç»“åˆä¸‹å›¾ç†è§£ï¼š è¿™é‡Œæˆ‘ç”¨ä¸€ä¸ªä¾‹å­æ¥è§£é‡Šä¸€ä¸‹binder_transaction_dataä¼ è¾“çš„æ•°æ®æ˜¯ä»€ä¹ˆæ ·å­çš„ å°ä¼™ä¼´ä»¬åº”è¯¥éƒ½äº†è§£Parcelå§ï¼Œå®ƒæ˜¯ä¸€ä¸ªå­˜æ”¾è¯»å–æ•°æ®çš„å®¹å™¨ï¼Œæˆ‘ä»¬binder_transaction_dataä¸­å®é™…ä¼ è¾“çš„æ•°æ®å°±æ˜¯é€šè¿‡å®ƒç»„åˆè€Œæˆçš„ï¼Œå®ƒå¯ä»¥ä¼ è¾“åŸºæœ¬æ•°æ®ç±»å‹ï¼ŒParcelableç±»å‹å’Œbinderç±»å‹ å…¶ä¸­åŸºæœ¬æ•°æ®ç±»å‹å°±ä¸ç”¨è¯´äº†ï¼Œæ¯ç§åŸºæœ¬ç±»å‹æ‰€å ç”¨çš„å¤§å°æ˜¯å›ºå®šçš„ï¼ŒParcelableç±»å‹å®é™…ä¸Šä¹Ÿæ˜¯ä¼ è¾“åŸºæœ¬æ•°æ®ç±»å‹ï¼Œå®ƒæ˜¯é€šè¿‡å®ç°Parcelableæ¥å£å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡ä¸­çš„æˆå‘˜åºåˆ—åŒ–æˆäº†ä¸€ä¸ªä¸ªåŸºæœ¬æ•°æ®ç±»å‹ä¼ è¾“ï¼Œè€Œbinderç±»å‹çš„ä¼ è¾“æœ‰ç‚¹ç‰¹åˆ«ï¼Œå®ƒä¼šå°†è¿™ä¸ªbinderå¯¹è±¡ â€œå‹æ‰â€ æˆä¸€ä¸ªflat_binder_objectç»“æ„ä½“ä¼ è¾“ å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯clientï¼Œä¸€ä¸ªæœåŠ¡ç«¯serverï¼Œclientæƒ³è¦å‘binderé©±åŠ¨å‘èµ·ä¸€ä¸ªäº‹ç‰©ï¼Œè°ƒç”¨serverçš„æŸä¸ªæ–¹æ³•ï¼Œæˆ‘ä»¬è¯¥æ€ä¹ˆæ„å»ºbinder_transaction_dataçš„æ•°æ®åŒºå‘¢ï¼Ÿ ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå†™ä¸€ä¸ªtokenï¼Œè¿™ä¸ªtokenæ˜¯ä¸ºäº†è¿›è¡Œæ ¡éªŒçš„ï¼Œä¸¤ç«¯éœ€è¦ä¿æŒä¸€è‡´ã€‚æ¥ç€æˆ‘ä»¬éœ€è¦æŒ‰é¡ºåºä¾æ¬¡å†™å…¥å‚æ•°ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¦è°ƒç”¨serverçš„callMe(int, Parcelable, IBinder)å‡½æ•°ï¼Œé‚£æˆ‘ä»¬å°±éœ€è¦å…ˆå†™å…¥ä¸€ä¸ªintï¼Œå†å†™å…¥ä¸€ä¸ªParcelableï¼Œæœ€åå†å°†IBinder â€œå‹æ‰â€ æˆä¸€ä¸ªflat_binder_objectå†™å…¥ã€‚ æ­¤æ—¶æ•°æ®å¸ƒå±€å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»å›¾ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ¥ï¼ŒoffsetsæŒ‡ç¤ºå‡ºäº†bufferä¸­ä¼ è¾“çš„binderå¯¹è±¡çš„ä½ç½®ï¼Œæœ‰å‡ ä¸ªbinderå¯¹è±¡ï¼Œå°±ä¼šæœ‰å‡ ä¸ªoffsetä¸ä¹‹å¯¹åº” transaction_flagsæˆ‘ä»¬å†çœ‹ä¸€ä¸‹æœ‰å“ªäº›äº‹åŠ¡æ ‡å¿—ï¼Œä»–ä»¬åˆ†åˆ«ä»£è¡¨ä»€ä¹ˆæ„æ€ 12345678910enum transaction_flags &#123; //å•å‘è°ƒç”¨ï¼Œå¼‚æ­¥æ“ä½œï¼Œæ— è¿”å› TF_ONE_WAY = 0x01, //replyå†…å®¹æ˜¯ä¸€ä¸ªç»„ä»¶çš„æ ¹å¯¹è±¡ï¼Œå¯¹åº”ç±»å‹ä¸ºæœ¬åœ°binder TF_ROOT_OBJECT = 0x04, //replyå†…å®¹æ˜¯ä¸€ä¸ª32ä½çš„çŠ¶æ€ç ï¼Œå¯¹åº”ç±»å‹ä¸ºè¿œç¨‹binderå¼•ç”¨çš„å¥æŸ„ TF_STATUS_CODE = 0x08, //å¯ä»¥æ¥æ”¶ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œå¯¹åº”çš„ç±»å‹ä¸ºæ–‡ä»¶ï¼ˆBINDER_TYPE_FDï¼‰ï¼Œå³handleä¸­å­˜å‚¨çš„ä¸ºæ–‡ä»¶æè¿°ç¬¦ TF_ACCEPT_FDS = 0x10,&#125;; binder_transactionç»“æ„ä½“binder_transactionç»“æ„ä½“ç”¨æ¥æè¿°è¿›ç¨‹é—´é€šä¿¡è¿‡ç¨‹ï¼ˆäº‹åŠ¡ï¼‰ï¼Œå®ƒè¢«å®šä¹‰åœ¨drivers/android/binder.cä¸­ 123456789101112131415161718192021222324252627282930313233struct binder_transaction &#123; int debug_id; //ç”¨æ¥æè¿°éœ€è¦å¤„ç†çš„å·¥ä½œäº‹é¡¹ struct binder_work work; //å‘èµ·äº‹åŠ¡çš„çº¿ç¨‹ struct binder_thread *from; //äº‹åŠ¡æ‰€ä¾èµ–çš„å¦ä¸€ä¸ªäº‹åŠ¡ struct binder_transaction *from_parent; //å¤„ç†è¯¥äº‹åŠ¡çš„è¿›ç¨‹ struct binder_proc *to_proc; //å¤„ç†è¯¥äº‹åŠ¡çš„çº¿ç¨‹ struct binder_thread *to_thread; //ç›®æ ‡çº¿ç¨‹ä¸‹ä¸€ä¸ªéœ€è¦å¤„ç†çš„äº‹åŠ¡ struct binder_transaction *to_parent; //1: è¡¨ç¤ºåŒæ­¥äº‹åŠ¡ï¼Œéœ€è¦ç­‰å¾…å¯¹æ–¹å›å¤ //0: è¡¨ç¤ºå¼‚æ­¥äº‹åŠ¡ unsigned need_reply:1; //æŒ‡å‘ä¸ºè¯¥äº‹åŠ¡åˆ†é…çš„å†…æ ¸ç¼“å†²åŒº struct binder_buffer *buffer; unsigned int code; unsigned int flags; //å‘èµ·äº‹åŠ¡çº¿ç¨‹çš„ä¼˜å…ˆçº§ struct binder_priority priority; //çº¿ç¨‹åœ¨å¤„ç†äº‹åŠ¡æ—¶ï¼Œé©±åŠ¨ä¼šä¿®æ”¹å®ƒçš„ä¼˜å…ˆçº§ä»¥æ»¡è¶³æºçº¿ç¨‹å’Œç›®æ ‡Serviceç»„å»ºçš„è¦æ±‚ //åœ¨ä¿®æ”¹ä¹‹å‰ï¼Œä¼šå°†å®ƒåŸæ¥çš„çº¿ç¨‹ä¼˜å…ˆçº§ä¿å­˜åœ¨è¯¥æˆå‘˜ä¸­ï¼Œä»¥ä¾¿çº¿ç¨‹å¤„ç†å®Œè¯¥äº‹åŠ¡åå¯ä»¥æ¢å¤åŸæ¥çš„ä¼˜å…ˆçº§ struct binder_priority saved_priority; bool set_priority_called; kuid_t sender_euid; binder_uintptr_t security_ctx; spinlock_t lock;&#125;; binder_workç»“æ„ä½“binder_workç»“æ„ä½“ç”¨æ¥æè¿°éœ€è¦å¤„ç†çš„å·¥ä½œäº‹é¡¹ï¼Œå®ƒè¢«å®šä¹‰åœ¨drivers/android/binder.cä¸­ 123456789101112131415struct binder_work &#123; //åŒå‘é“¾è¡¨ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™ä¸ªé“¾è¡¨å‚¨å­˜äº†æ‰€æœ‰çš„binder_work struct list_head entry; //å·¥ä½œé¡¹ç±»å‹ enum binder_work_type &#123; BINDER_WORK_TRANSACTION = 1, BINDER_WORK_TRANSACTION_COMPLETE, BINDER_WORK_RETURN_ERROR, BINDER_WORK_NODE, BINDER_WORK_DEAD_BINDER, BINDER_WORK_DEAD_BINDER_AND_CLEAR, BINDER_WORK_CLEAR_DEATH_NOTIFICATION, &#125; type;&#125;; ç®€å•çœ‹å®Œäº†ä¸€äº›å¿…è¦çš„ç»“æ„ä½“åï¼Œæˆ‘ä»¬æŠŠç›®å…‰è½¬å›binder_transactionå‡½æ•°ä¸Š binder_transactionå‡½æ•°çš„ä»£ç å¾ˆé•¿ï¼Œæˆ‘ä»¬ç²¾ç®€ä¸€ä¸‹ï¼Œç„¶åå†åˆ†æ®µæ¥çœ‹ï¼Œä»æ•´ä½“ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒåˆ†ä¸ºå‡ ä¸ªéƒ¨åˆ†ï¼š è·å¾—ç›®æ ‡è¿›ç¨‹/çº¿ç¨‹ä¿¡æ¯ å°†æ•°æ®æ‹·è´åˆ°ç›®æ ‡è¿›ç¨‹æ‰€æ˜ å°„çš„å†…å­˜ä¸­ï¼ˆæ­¤æ—¶ä¼šå»ºç«‹å®é™…çš„æ˜ å°„å…³ç³»ï¼‰ å°†å¾…å¤„ç†çš„ä»»åŠ¡åŠ å…¥todoé˜Ÿåˆ—ï¼Œå”¤é†’ç›®æ ‡çº¿ç¨‹ ç¬¬ä¸€éƒ¨åˆ†ï¼šè·å¾—ç›®æ ‡è¿›ç¨‹/çº¿ç¨‹ä¿¡æ¯è¿™é‡Œæ ¹æ®æ˜¯å¦ä¸ºreplyï¼Œåˆ†æˆäº†ä¸¤ç§æƒ…å†µ BC_TRANSACTIONæˆ‘ä»¬å…ˆçœ‹BC_TRANSACTIONçš„æƒ…å†µ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; uint32_t return_error = 0; struct binder_context *context = proc-&gt;context; if (reply) &#123; ... &#125; else &#123; if (tr-&gt;target.handle) &#123; struct binder_ref *ref; binder_proc_lock(proc); //æŸ¥æ‰¾binderå¼•ç”¨ ref = binder_get_ref_olocked(proc, tr-&gt;target.handle, true); //é€šè¿‡ç›®æ ‡binderå®ä½“è·å–ç›®æ ‡è¿›ç¨‹ä¿¡æ¯ target_node = binder_get_node_refs_for_txn( ref-&gt;node, &amp;target_proc, &amp;return_error); binder_proc_unlock(proc); &#125; else &#123; //handleä¸º0ä»£è¡¨ç›®æ ‡targetæ˜¯ServiceManager mutex_lock(&amp;context-&gt;context_mgr_node_lock); //ServiceManagerä¸ºbinderé©±åŠ¨çš„contextï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ä»contextä¸­è·å–binderå®ä½“ target_node = context-&gt;binder_context_mgr_node; if (target_node) //é€šè¿‡ç›®æ ‡binderå®ä½“è·å–ç›®æ ‡è¿›ç¨‹ä¿¡æ¯ target_node = binder_get_node_refs_for_txn( target_node, &amp;target_proc, &amp;return_error); else return_error = BR_DEAD_REPLY; mutex_unlock(&amp;context-&gt;context_mgr_node_lock); if (target_node &amp;&amp; target_proc == proc) &#123; ... //error &#125; &#125; ... //ä½¿ç”¨LSMè¿›è¡Œå®‰å…¨æ£€æŸ¥ if (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; 0) &#123; ... //error &#125; binder_inner_proc_lock(proc); //flagsä¸å¸¦TF_ONE_WAYï¼ˆå³éœ€è¦replyï¼‰å¹¶ä¸”å½“å‰çº¿ç¨‹å­˜åœ¨binderäº‹åŠ¡æ ˆ if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123; struct binder_transaction *tmp; tmp = thread-&gt;transaction_stack; if (tmp-&gt;to_thread != thread) &#123; ... //error &#125; //å¯»æ‰¾ä¸€ä¸ªåˆé€‚çš„ç›®æ ‡binderçº¿ç¨‹ while (tmp) &#123; struct binder_thread *from; spin_lock(&amp;tmp-&gt;lock); from = tmp-&gt;from; if (from &amp;&amp; from-&gt;proc == target_proc) &#123; atomic_inc(&amp;from-&gt;tmp_ref); target_thread = from; spin_unlock(&amp;tmp-&gt;lock); break; &#125; spin_unlock(&amp;tmp-&gt;lock); tmp = tmp-&gt;from_parent; &#125; &#125; binder_inner_proc_unlock(proc); &#125; ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œè™½ç„¶æ•´ä¸ªå‡½æ•°å¾ˆé•¿å¾ˆå¤æ‚ï¼Œä½†ç»è¿‡æˆ‘ä»¬çš„æ‹†åˆ†ç²¾ç®€ï¼Œé€»è¾‘å°±æ¸…æ™°å¾ˆå¤šäº† binder_transaction_data.target.handleç”¨ä¸€ä¸ªintå€¼è¡¨ç¤ºç›®æ ‡binderå¼•ç”¨ï¼Œå½“å®ƒä¸ä¸º0æ—¶ï¼Œè°ƒç”¨binder_get_ref_olockedå‡½æ•°æŸ¥æ‰¾binder_ref binder_get_ref_olocked12345678910111213141516171819202122static struct binder_ref *binder_get_ref_olocked(struct binder_proc *proc, u32 desc, bool need_strong_ref)&#123; struct rb_node *n = proc-&gt;refs_by_desc.rb_node; struct binder_ref *ref; while (n) &#123; ref = rb_entry(n, struct binder_ref, rb_node_desc); if (desc &lt; ref-&gt;data.desc) &#123; n = n-&gt;rb_left; &#125; else if (desc &gt; ref-&gt;data.desc) &#123; n = n-&gt;rb_right; &#125; else if (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123; binder_user_error(\"tried to use weak ref as strong ref\\n\"); return NULL; &#125; else &#123; return ref; &#125; &#125; return NULL;&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªå‡½æ•°å°±æ˜¯ä»binder_proc.refs_by_descè¿™ä¸ªçº¢é»‘æ ‘ä¸­ï¼Œé€šè¿‡descå¥æŸ„æŸ¥æ‰¾åˆ°å¯¹åº”çš„binderå¼•ç”¨binder_refï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡binder_ref.nodeè·å¾—åˆ°binderå®ä½“binder_node æ¥ç€å†è°ƒç”¨binder_get_node_refs_for_txnå‡½æ•°é€šè¿‡ç›®æ ‡binderå®ä½“è·å–ç›®æ ‡è¿›ç¨‹ä¿¡æ¯ binder_get_node_refs_for_txn123456789101112131415161718192021222324static struct binder_node *binder_get_node_refs_for_txn( struct binder_node *node, struct binder_proc **procp, uint32_t *error)&#123; struct binder_node *target_node = NULL; binder_node_inner_lock(node); if (node-&gt;proc) &#123; target_node = node; //binder_nodeå¼ºå¼•ç”¨è®¡æ•°åŠ 1 binder_inc_node_nilocked(node, 1, 0, NULL); //binder_nodeä¸´æ—¶å¼•ç”¨è®¡æ•°åŠ 1 binder_inc_node_tmpref_ilocked(node); //binder_procä¸´æ—¶å¼•ç”¨è®¡æ•°åŠ 1 atomic_inc(&amp;node-&gt;proc-&gt;tmp_ref); //ä½¿å¤–éƒ¨ä¼ å…¥çš„procæŒ‡é’ˆæŒ‡å‘binder_procåœ°å€ *procp = node-&gt;proc; &#125; else *error = BR_DEAD_REPLY; binder_node_inner_unlock(node); return target_node;&#125; è¿™ä¸ªå‡½æ•°ç¬¬äºŒä¸ªå‚æ•°æ¥å—ä¸€ä¸ªbinder_proc **ç±»å‹ï¼Œå³æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œè°ƒç”¨æ–¹å¯¹procå–åœ°å€ï¼Œå³æŒ‡å‘procæŒ‡é’ˆåˆ†é…åœ¨æ ˆä¸Šçš„åœ°å€ï¼Œè¿™æ ·å‡½æ•°ä¸­å¯¹procpè§£å¼•ç”¨å°±å¾—åˆ°äº†procæŒ‡é’ˆæœ¬èº«çš„åœ°å€ï¼Œå³å¯ä½¿procæŒ‡é’ˆæŒ‡å‘binder_procçš„åœ°å€ å½“binder_transaction_data.target.handleä¸º0æ—¶ï¼Œè¡¨ç¤ºç›®æ ‡æ˜¯ServiceManagerï¼Œè€ŒServiceManageræ˜¯binderé©±åŠ¨çš„contextï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ä»contextä¸­è·å–binderå®ä½“ï¼Œå…³äºServiceManageræ˜¯æ€ä¹ˆæˆä¸ºbinderé©±åŠ¨çš„contextçš„ï¼Œæˆ‘ä»¬ä¼šåœ¨åé¢çš„ç« èŠ‚è¿›è¡Œåˆ†æ æ¥ä¸‹æ¥åšä¸€ä¸‹å®‰å…¨æ£€æŸ¥ï¼Œå½“flagsä¸å¸¦TF_ONE_WAYï¼ˆå³éœ€è¦replyï¼‰å¹¶ä¸”å½“å‰çº¿ç¨‹å­˜åœ¨binderäº‹åŠ¡æ ˆæ—¶ï¼Œå¯»æ‰¾ä¸€ä¸ªåˆé€‚çš„ç›®æ ‡binderå·¥ä½œçº¿ç¨‹ç”¨æ¥å¤„ç†æ­¤äº‹åŠ¡ï¼ˆçº¿ç¨‹å¤ç”¨ï¼‰ è¿™é‡Œclientç«¯å¯èƒ½æ˜¯ç¬¬ä¸€æ¬¡è¯·æ±‚æœåŠ¡ï¼Œæ­¤æ—¶binder_threadé‡Œæ˜¯ä¸å­˜åœ¨binderäº‹åŠ¡æ ˆï¼Œæ‰€ä»¥æ˜¯æ²¡æ³•æ‰¾åˆ°ç›®æ ‡binderçº¿ç¨‹çš„ BC_REPLYæ¥ç€ï¼Œæˆ‘ä»¬å†çœ‹BC_REPLYçš„æƒ…å†µ 123456789101112131415161718192021222324252627282930313233343536static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_transaction *in_reply_to = NULL; if (reply) &#123; binder_inner_proc_lock(proc); //è¿™ä¸ªäº‹åŠ¡æ˜¯å‘èµ·äº‹åŠ¡ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªäº‹åŠ¡åšåº”ç­” in_reply_to = thread-&gt;transaction_stack; if (in_reply_to == NULL) &#123; ... //error &#125; if (in_reply_to-&gt;to_thread != thread) &#123; ... //error &#125; //æ”¹æŒ‡å‘ä¸‹ä¸€ä¸ªéœ€è¦å¤„ç†çš„äº‹åŠ¡ï¼Œå³å°†è¿™ä¸ªäº‹åŠ¡ç§»å‡ºé“¾è¡¨ thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; binder_inner_proc_unlock(proc); //ç›®æ ‡çº¿ç¨‹å³ä¸ºéœ€è¦å›åº”çš„äº‹åŠ¡çš„å‘èµ·çº¿ç¨‹ target_thread = binder_get_txn_from_and_acq_inner(in_reply_to); if (target_thread-&gt;transaction_stack != in_reply_to) &#123; ... //error &#125; //é€šè¿‡binder_threadè·å¾—binder_proc target_proc = target_thread-&gt;proc; atomic_inc(&amp;target_proc-&gt;tmp_ref); binder_inner_proc_unlock(target_thread-&gt;proc); &#125; else &#123; ... &#125; ...&#125; 123456789101112131415161718static struct binder_thread *binder_get_txn_from_and_acq_inner( struct binder_transaction *t)&#123; struct binder_thread *from; //ç›¸å½“äº from = t-&gt;from; å†…éƒ¨åŠ äº†é”å’Œå¼•ç”¨è®¡æ•°æ“ä½œ from = binder_get_txn_from(t); if (!from) return NULL; binder_inner_proc_lock(from-&gt;proc); if (t-&gt;from) &#123; BUG_ON(from != t-&gt;from); return from; &#125; binder_inner_proc_unlock(from-&gt;proc); binder_thread_dec_tmpref(from); return NULL;&#125; BC_REPLYè·å–ç›®æ ‡è¿›ç¨‹/çº¿ç¨‹ä¿¡æ¯å°±æ›´ç®€å•äº†ï¼ŒBC_TRANSACTIONä¸­æˆ‘ä»¬è¿˜éœ€è¦æ ¹æ®binderå¥æŸ„æ¥è·å–å„ç§ä¿¡æ¯ï¼ŒBC_REPLYæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°éœ€è¦å›åº”çš„é‚£ä¸ªäº‹åŠ¡ï¼Œé‚£ä¸ªäº‹åŠ¡æ‰€åœ¨çš„çº¿ç¨‹å’Œè¿›ç¨‹å³ä¸ºreplyäº‹åŠ¡çš„ç›®æ ‡çº¿ç¨‹å’Œç›®æ ‡è¿›ç¨‹ ç¬¬äºŒéƒ¨åˆ†ï¼šæ•°æ®æ‹·è´ï¼Œå»ºç«‹æ˜ å°„123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; int ret; struct binder_transaction *t; struct binder_work *tcomplete; binder_size_t *offp, *off_end, *off_start; binder_size_t off_min; u8 *sg_bufp, *sg_buf_end; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL u32 secctx_sz = 0; ... //ä¸ºç›®æ ‡è¿›ç¨‹binderäº‹åŠ¡åˆ†é…ç©ºé—´ï¼ˆåç»­ä¼šåŠ åˆ°ç›®æ ‡è¿›ç¨‹/çº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼Œç”±ç›®æ ‡è¿›ç¨‹/çº¿ç¨‹å¤„ç†è¿™ä¸ªäº‹åŠ¡ï¼‰ t = kzalloc(sizeof(*t), GFP_KERNEL); spin_lock_init(&amp;t-&gt;lock); tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); t-&gt;debug_id = t_debug_id; //è®¾ç½®äº‹åŠ¡å‘èµ·çº¿ç¨‹ if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; t-&gt;sender_euid = task_euid(proc-&gt;tsk); //è®¾ç½®äº‹åŠ¡å¤„ç†è¿›ç¨‹ t-&gt;to_proc = target_proc; //è®¾ç½®äº‹åŠ¡å¤„ç†çº¿ç¨‹ t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; t-&gt;flags = tr-&gt;flags; //è®¾ç½®ä¼˜å…ˆçº§ if (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; binder_supported_policy(current-&gt;policy)) &#123; /* Inherit supported policies for synchronous transactions */ t-&gt;priority.sched_policy = current-&gt;policy; t-&gt;priority.prio = current-&gt;normal_prio; &#125; else &#123; /* Otherwise, fall back to the default priority */ t-&gt;priority = target_proc-&gt;default_priority; &#125; //å®‰å…¨ç›¸å…³ if (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123; ... &#125; //åˆ†é…ç¼“å­˜ï¼Œå»ºç«‹æ˜ å°„ t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size, tr-&gt;offsets_size, extra_buffers_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; t-&gt;buffer-&gt;transaction = t; t-&gt;buffer-&gt;target_node = target_node; off_start = (binder_size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); offp = off_start; //è¿™é‡Œå°±æ˜¯çœŸæ­£çš„ä¸€æ¬¡å¤åˆ¶ copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t) tr-&gt;data.ptr.buffer, tr-&gt;data_size); copy_from_user(offp, (const void __user *)(uintptr_t) tr-&gt;data.ptr.offsets, tr-&gt;offsets_size); //æ£€æŸ¥æ•°æ®å¯¹é½ if (!IS_ALIGNED(tr-&gt;offsets_size, sizeof(binder_size_t))) &#123; ... //error &#125; if (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) &#123; ... //error &#125; off_end = (void *)off_start + tr-&gt;offsets_size; sg_bufp = (u8 *)(PTR_ALIGN(off_end, sizeof(void *))); sg_buf_end = sg_bufp + extra_buffers_size - ALIGN(secctx_sz, sizeof(u64)); off_min = 0; //å¾ªç¯éå†æ¯ä¸€ä¸ªbinderå¯¹è±¡ for (; offp &lt; off_end; offp++) &#123; struct binder_object_header *hdr; size_t object_size = binder_validate_object(t-&gt;buffer, *offp); if (object_size == 0 || *offp &lt; off_min) &#123; ... //error &#125; hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp); off_min = *offp + object_size; switch (hdr-&gt;type) &#123; //éœ€è¦å¯¹binderç±»å‹è¿›è¡Œè½¬æ¢ //å› ä¸ºåœ¨Aè¿›ç¨‹ä¸­ä¸ºæœ¬åœ°binderå¯¹è±¡ï¼Œå¯¹äºBè¿›ç¨‹åˆ™ä¸ºè¿œç¨‹binderå¯¹è±¡ï¼Œåä¹‹äº¦ç„¶ case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct flat_binder_object *fp; fp = to_flat_binder_object(hdr); ret = binder_translate_binder(fp, t, thread); &#125; break; case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; struct flat_binder_object *fp; fp = to_flat_binder_object(hdr); ret = binder_translate_handle(fp, t, thread); &#125; break; case BINDER_TYPE_FD: &#123; ... &#125; break; case BINDER_TYPE_FDA: &#123; ... &#125; break; case BINDER_TYPE_PTR: &#123; ... &#125; break; default: ... //error &#125; &#125; //è®¾ç½®å·¥ä½œç±»å‹ tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; //è®¾ç½®ç›®æ ‡è¿›ç¨‹çš„äº‹åŠ¡ç±»å‹ t-&gt;work.type = BINDER_WORK_TRANSACTION; ...&#125; æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸€éƒ¨åˆ†å†ç»†åˆ†æˆå‡ ä¸ªéƒ¨åˆ†ï¼š åˆ†é…ç¼“å­˜ï¼Œå»ºç«‹æ˜ å°„ æ•°æ®æ‹·è´ binderç±»å‹è½¬æ¢ åˆ†é…ç¼“å­˜ï¼Œå»ºç«‹æ˜ å°„æˆ‘ä»¬é¦–å…ˆçœ‹åˆ†é…ç¼“å­˜ï¼Œå»ºç«‹æ˜ å°„æ˜¯æ€ä¹ˆåšçš„ï¼Œå®ƒè°ƒç”¨äº†binder_alloc_new_bufå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å®šä¹‰åœ¨drivers/android/binder_alloc.cä¸­ï¼Œå†…éƒ¨åŠ äº†é”åè°ƒç”¨äº†binder_alloc_new_buf_lockedå‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static struct binder_buffer *binder_alloc_new_buf_locked( struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async)&#123; struct rb_node *n = alloc-&gt;free_buffers.rb_node; struct binder_buffer *buffer; size_t buffer_size; struct rb_node *best_fit = NULL; void *has_page_addr; void *end_page_addr; size_t size, data_offsets_size; int ret; if (alloc-&gt;vma == NULL) &#123; ... //error &#125; //è®¡ç®—éœ€è¦çš„ç¼“å†²åŒºå¤§å° //è¿™é‡Œéœ€è¦å°†sizeå¯¹é½void *ï¼ˆ32ä½ä¸‹å ç”¨4å­—èŠ‚ï¼Œ64ä½ä¸‹å ç”¨8å­—èŠ‚ï¼‰ data_offsets_size = ALIGN(data_size, sizeof(void *)) + ALIGN(offsets_size, sizeof(void *)); size = data_offsets_size + ALIGN(extra_buffers_size, sizeof(void *)); size = max(size, sizeof(void *)); //ä»binder_allocçš„ç©ºé—²ç¼“å†²çº¢é»‘æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªå¤§å°æœ€åˆé€‚çš„binder_buffer while (n) &#123; //å½“æ‰¾åˆ°ä¸€ä¸ªéœ€æ±‚å¤§å°å’Œç¼“å­˜åŒºå¤§å°åˆšå¥½ç›¸åŒçš„ç©ºé—²ç¼“å­˜åŒºæ—¶ //æ­¤æ—¶bufferå°±æ­£å¥½æŒ‡å‘è¿™ä¸ªç©ºé—²ç¼“å­˜åŒº buffer = rb_entry(n, struct binder_buffer, rb_node); BUG_ON(!buffer-&gt;free); buffer_size = binder_alloc_buffer_size(alloc, buffer); //å½“åªæ‰¾åˆ°ä¸€ä¸ªæ¯”éœ€æ±‚å¤§å°ç¨å¤§ä¸€ç‚¹çš„ç©ºé—²ç¼“å­˜åŒºæ—¶ //æ­¤æ—¶bufferæŒ‡å‘çš„æ˜¯è¿™ä¸ªç©ºé—²ç¼“å­˜åŒºæ‰€åœ¨èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ //ç„¶ånæŒ‡å‘NULL if (size &lt; buffer_size) &#123; best_fit = n; n = n-&gt;rb_left; &#125; else if (size &gt; buffer_size) n = n-&gt;rb_right; else &#123; best_fit = n; break; &#125; &#125; if (best_fit == NULL) &#123; ... //error &#125; //æ­¤æ—¶bufferæŒ‡å‘çš„æ˜¯æ‰€éœ€æ±‚çš„ç©ºé—²ç¼“å­˜åŒºæ‰€åœ¨çº¢é»‘æ ‘èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ //éœ€è¦è®©å…¶æŒ‡å‘çœŸæ­£éœ€æ±‚çš„é‚£ä¸ªç©ºé—²ç¼“å­˜åŒº if (n == NULL) &#123; buffer = rb_entry(best_fit, struct binder_buffer, rb_node); buffer_size = binder_alloc_buffer_size(alloc, buffer); &#125; //è®¡ç®—å‡ºbufferçš„ç»ˆç‚¹ï¼Œå‘ä¸‹å¯¹é½ï¼ˆä¸èƒ½è¶…è¿‡å¯ç”¨çš„buffer_sizeï¼‰ has_page_addr = (void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK); WARN_ON(n &amp;&amp; buffer_size != size); //è®¡ç®—å‡ºå®é™…ä¸Šæˆ‘ä»¬æ¥æ”¶æ•°æ®éœ€è¦çš„ç©ºé—´çš„ç»ˆç‚¹ï¼Œå‘ä¸Šæ˜ å°„ end_page_addr = (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + size); //å¦‚æœè¶…å‡ºäº†å¯ç”¨çš„buffer_sizeï¼Œæ¢å¤åˆ°æ­£å¸¸å¯ç”¨çš„ç»“æŸåœ°å€ if (end_page_addr &gt; has_page_addr) end_page_addr = has_page_addr; //åˆ†é…ç‰©ç†é¡µï¼Œå»ºç«‹æ˜ å°„ ret = binder_update_page_range(alloc, 1, (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr); if (ret) return ERR_PTR(ret); //æœ‰ç©ºä½™ç©ºé—´çš„è¯ï¼Œåˆ†éš”è¿™ä¸ªbufferï¼Œå‰©ä½™çš„bufferåŠ å…¥åˆ°ç©ºé—²ç¼“å­˜åŒºçº¢é»‘æ ‘ä¸­ï¼ˆåˆç†åˆ©ç”¨ç©ºé—´ï¼‰ if (buffer_size != size) &#123; struct binder_buffer *new_buffer; new_buffer = kzalloc(sizeof(*buffer), GFP_KERNEL); new_buffer-&gt;data = (u8 *)buffer-&gt;data + size; list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry); new_buffer-&gt;free = 1; binder_insert_free_buffer(alloc, new_buffer); &#125; //æˆ‘ä»¬å·²ç»ä½¿ç”¨äº†è¿™ä¸ªbufferï¼Œè¦å°†å…¶ä»ç©ºé—²ç¼“å­˜åŒºçº¢é»‘æ ‘ä¸­ç§»é™¤ rb_erase(best_fit, &amp;alloc-&gt;free_buffers); //æ ‡è®°ä¸ºéç©ºé—² buffer-&gt;free = 0; buffer-&gt;allow_user_free = 0; //æ’å…¥åˆ°å·²åˆ†é…ç¼“å­˜åŒºçº¢é»‘æ ‘ä¸­ binder_insert_allocated_buffer_locked(alloc, buffer); buffer-&gt;data_size = data_size; buffer-&gt;offsets_size = offsets_size; buffer-&gt;async_transaction = is_async; buffer-&gt;extra_buffers_size = extra_buffers_size; //å¦‚æœæ˜¯å¼‚æ­¥äº‹ä»¶, é‚£ä¹ˆæ›´æ–°binder_allocçš„å¼‚æ­¥äº‹ä»¶ç©ºé—²buffer if (is_async) &#123; alloc-&gt;free_async_space -= size + sizeof(struct binder_buffer); &#125; return buffer; ...&#125; è¿™ä¸ªå‡½æ•°çš„æ•´ä½“é€»è¾‘åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼š æ‰¾åˆ°å¯ç”¨çš„ç©ºé—²å†…æ ¸ç¼“å­˜åŒºï¼Œè®¡ç®—æˆ‘ä»¬éœ€è¦åˆ†é…çš„å¤§å° åˆ†é…ç‰©ç†é¡µï¼Œå»ºç«‹æ˜ å°„ åˆå§‹åŒ–æ–°åˆ†é…çš„buffer å…¶ä¸­1ã€3éƒ¨åˆ†å·²ç»ç”¨æ³¨é‡Šæ ‡å‡ºæ¥äº†ï¼Œåº”è¯¥è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼Œæˆ‘ä»¬ç»ˆç‚¹çœ‹ä¸€ä¸‹ç¬¬2éƒ¨åˆ†ï¼šæ€ä¹ˆåˆ†é…ç‰©ç†é¡µï¼Œå»ºç«‹æ˜ å°„ æˆ‘ä»¬åœ¨ä¸Šä¸€ç« Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸Šï¼‰ä¸­è¯´åˆ°ï¼Œbinder_mmapå¹¶æ²¡æœ‰ç«‹å³å°†å†…æ ¸è™šæ‹Ÿå†…å­˜å’Œè¿›ç¨‹è™šæ‹Ÿå†…å­˜ä¸ç‰©ç†å†…å­˜åšæ˜ å°„ï¼Œå®é™…ä¸Šè¿™ä¸ªæ˜ å°„æ“ä½œæ˜¯åœ¨binder_update_page_rangeè¿™é‡Œåšçš„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static int binder_update_page_range(struct binder_alloc *alloc, int allocate, void *start, void *end)&#123; void *page_addr; unsigned long user_page_addr; struct binder_lru_page *page; struct vm_area_struct *vma = NULL; struct mm_struct *mm = NULL; bool need_mm = false; if (end &lt;= start) return 0; if (allocate == 0) goto free_range; //æ£€æŸ¥æ˜¯å¦æœ‰é¡µæ¡†éœ€è¦åˆ†é… for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;buffer) / PAGE_SIZE]; if (!page-&gt;page_ptr) &#123; need_mm = true; break; &#125; &#125; //æŒ‡å‘ç›®æ ‡ç”¨æˆ·è¿›ç¨‹çš„å†…å­˜ç©ºé—´æè¿°ä½“ if (need_mm &amp;&amp; atomic_inc_not_zero(&amp;alloc-&gt;vma_vm_mm-&gt;mm_users)) mm = alloc-&gt;vma_vm_mm; if (mm) &#123; //è·å–mm_structçš„è¯»ä¿¡å·é‡ down_read(&amp;mm-&gt;mmap_sem); //æ£€æŸ¥mmæ˜¯å¦æœ‰æ•ˆ if (!mmget_still_valid(mm)) &#123; //é‡Šæ”¾ if (allocate == 0) goto free_range; //é”™è¯¯ goto err_no_vma; &#125; vma = alloc-&gt;vma; &#125; if (!vma &amp;&amp; need_mm) &#123; ... //error &#125; for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; int ret; bool on_lru; size_t index; //æŒ‡å‘å¯¹åº”é¡µæ¡†åœ°å€ï¼Œä¸ºåé¢èµ‹å€¼åšå‡†å¤‡ index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE; page = &amp;alloc-&gt;pages[index]; //page-&gt;page_pträ¸ä¸ºNULLè¯´æ˜ä¹‹å‰å·²ç»åˆ†é…å¹¶æ˜ å°„è¿‡äº† if (page-&gt;page_ptr) &#123; on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru); continue; &#125; //åˆ†é…ä¸€ä¸ªé¡µçš„ç‰©ç†å†…å­˜ page-&gt;page_ptr = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO); //æœªåˆ†é…æˆåŠŸ if (!page-&gt;page_ptr) &#123; ... //error &#125; page-&gt;alloc = alloc; INIT_LIST_HEAD(&amp;page-&gt;lru); //å°†ç‰©ç†å†…å­˜ç©ºé—´æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿå†…å­˜ç©ºé—´ ret = map_kernel_range_noflush((unsigned long)page_addr, PAGE_SIZE, PAGE_KERNEL, &amp;page-&gt;page_ptr); flush_cache_vmap((unsigned long)page_addr, (unsigned long)page_addr + PAGE_SIZE); //æ ¹æ®ä¹‹å‰è®¡ç®—çš„user_buffer_offsetå¯ä»¥ç›´æ¥å¾—åˆ°ç›®æ ‡ç”¨æˆ·ç©ºé—´è¿›ç¨‹è™šæ‹Ÿå†…å­˜åœ°å€ user_page_addr = (uintptr_t)page_addr + alloc-&gt;user_buffer_offset; //å°†ç‰©ç†å†…å­˜ç©ºé—´æ˜ å°„åˆ°ç›®æ ‡ç”¨æˆ·è¿›ç¨‹è™šæ‹Ÿå†…å­˜ç©ºé—´ ret = vm_insert_page(vma, user_page_addr, page[0].page_ptr); if (index + 1 &gt; alloc-&gt;pages_high) alloc-&gt;pages_high = index + 1; &#125; if (mm) &#123; //é‡Šæ”¾mm_structçš„è¯»ä¿¡å·é‡ up_read(&amp;mm-&gt;mmap_sem); mmput(mm); &#125; return 0; ... //é”™è¯¯å¤„ç†&#125; ä»£ç ä¸­çš„æ³¨é‡Šå†™çš„åº”è¯¥æ¯”è¾ƒæ¸…æ¥šäº†ï¼Œæ€»ä¹‹å°±æ˜¯å…ˆåˆ†é…ç‰©ç†å†…å­˜ï¼Œå†å°†è¿™å—ç‰©ç†å†…å­˜åˆ†åˆ«æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿç©ºé—´å’Œç”¨æˆ·è¿›ç¨‹è™šæ‹Ÿç©ºé—´ï¼Œè¿™æ ·å†…æ ¸è™šæ‹Ÿç©ºé—´ä¸ç”¨æˆ·è¿›ç¨‹è™šæ‹Ÿç©ºé—´ç›¸å½“äºä¹Ÿé—´æ¥çš„å»ºç«‹äº†æ˜ å°„å…³ç³» å…³äºç‰©ç†å†…å­˜çš„åˆ†é…ä»¥åŠæ˜ å°„ï¼Œå°±æ˜¯Linuxå†…æ ¸å±‚çš„äº‹æƒ…äº†ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥å†æ·±å…¥å¾€é‡Œçœ‹çœ‹ï¼Œè¿™é‡Œå°±ä¸å†å¤šè¯´äº† æ•°æ®æ‹·è´å…³äºæ•°æ®æ‹·è´è¿™éƒ¨åˆ†å°±ä¸ç”¨å¤šè¯´äº†ï¼Œç‰©ç†å†…å­˜å·²ç»åˆ†é…å¥½äº†ï¼Œæ˜ å°„ä¹Ÿå»ºç«‹äº†ï¼Œæ¥ä¸‹æ¥ç›´æ¥è°ƒç”¨copy_from_userå°†æ•°æ®ä»ç”¨æˆ·ç©ºé—´æ‹·è´è‡³æ˜ å°„çš„é‚£å—å†…å­˜å°±å¯ä»¥äº† binderç±»å‹è½¬æ¢æœ€åå¾ªç¯éå†æ¯ä¸€ä¸ªbinderå¯¹è±¡ï¼Œå¯¹å…¶ä¸­æ¯ä¸€ä¸ªbinderå¯¹è±¡ç±»å‹åšè½¬æ¢ï¼Œå› ä¸ºåœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ä¸ºæœ¬åœ°binderå¯¹è±¡ï¼Œå¯¹äºå¦ä¸€ä¸ªè¿›ç¨‹åˆ™ä¸ºè¿œç¨‹binderå¯¹è±¡ï¼Œåä¹‹äº¦ç„¶ flat_binder_objectç»“æ„ä½“è¿™é‡Œå°±æ˜¯æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼Œbinderå¯¹è±¡åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¼šè¢« â€œå‹æ‰â€ çš„ç»“æ„ 123456789101112131415161718struct flat_binder_object &#123; //æè¿°äº†binderå¯¹è±¡çš„ç±»å‹ struct binder_object_header hdr; //å’Œbinder_transaction_dataä¸­flagså«ä¹‰ç›¸åŒ __u32 flags; /* 8 bytes of data. */ union &#123; //å½“hdr.type == BINDER_TYPE_BINDERæ—¶ï¼Œè¡¨ç¤ºæ˜¯ä¸€ä¸ªbinderå®ä½“å¯¹è±¡ï¼ŒæŒ‡å‘binderå®ä½“åœ¨ç”¨æˆ·ç©ºé—´çš„åœ°å€ binder_uintptr_t binder; /* local object */ //å½“hdr.type == BINDER_TYPE_HANDLEï¼Œè¡¨ç¤ºæ˜¯ä¸€ä¸ªbinderå¼•ç”¨å¥æŸ„ __u32 handle; /* remote object */ &#125;; ////å½“hdr.type == BINDER_TYPE_BINDERæ—¶æ‰æœ‰å€¼ï¼Œè¡¨ç¤ºæºå¸¦çš„é¢å¤–æ•°æ® /* extra data associated with local object */ binder_uintptr_t cookie;&#125;; binder_translate_binderBINDER_TYPE_BINDERè¡¨ç¤ºæ˜¯ä¸€ä¸ªbinderå®ä½“å¯¹è±¡ï¼Œéœ€è¦å°†å®ƒè½¬æ¢æˆbinderå¼•ç”¨å¥æŸ„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int binder_translate_binder(struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread)&#123; struct binder_node *node; struct binder_proc *proc = thread-&gt;proc; struct binder_proc *target_proc = t-&gt;to_proc; struct binder_ref_data rdata; int ret = 0; //é€šè¿‡proc-&gt;nodes.rb_nodeçº¢é»‘æ ‘æŸ¥æ‰¾binder_node node = binder_get_node(proc, fp-&gt;binder); //å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œæ–°å»ºä¸€ä¸ªbinder_nodeå¹¶å°†å…¶æ’å…¥çº¢é»‘æ ‘ if (!node) &#123; node = binder_new_node(proc, fp); if (!node) return -ENOMEM; &#125; if (fp-&gt;cookie != node-&gt;cookie) &#123; ... //error &#125; //å®‰å…¨æ£€æŸ¥ if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123; ret = -EPERM; goto done; &#125; //æŸ¥æ‰¾binder_refå¹¶å°†å…¶å¼•ç”¨è®¡æ•°åŠ 1ï¼Œå¦‚æœæ²¡æœ‰æŸ¥æ‰¾åˆ°åˆ™åˆ›å»ºä¸€ä¸ªï¼Œå¹¶å°†å…¶æ’å…¥çº¢é»‘æ ‘ ret = binder_inc_ref_for_node(target_proc, node, fp-&gt;hdr.type == BINDER_TYPE_BINDER, &amp;thread-&gt;todo, &amp;rdata); if (ret) goto done; //è½¬æ¢binderç±»å‹ if (fp-&gt;hdr.type == BINDER_TYPE_BINDER) fp-&gt;hdr.type = BINDER_TYPE_HANDLE; else fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;binder = 0; //binderå¼•ç”¨å¥æŸ„èµ‹å€¼ fp-&gt;handle = rdata.desc; fp-&gt;cookie = 0;done: //binder_nodeä¸´æ—¶å¼•ç”¨è®¡æ•°å‡1 binder_put_node(node); return ret;&#125; binder_translate_handleBINDER_TYPE_HANDLEè¡¨ç¤ºæ˜¯ä¸€ä¸ªbinderå¼•ç”¨å¥æŸ„ï¼Œï¼Œéœ€è¦å°†å®ƒè½¬æ¢æˆbinderå®ä½“å¯¹è±¡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int binder_translate_handle(struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread)&#123; struct binder_proc *proc = thread-&gt;proc; struct binder_proc *target_proc = t-&gt;to_proc; struct binder_node *node; struct binder_ref_data src_rdata; int ret = 0; //ä»proc-&gt;refs_by_desc.rb_nodeçº¢é»‘æ ‘ä¸­æŸ¥æ‰¾binder_nodeï¼Œå¹¶å°†å…¶ä¸´æ—¶å¼•ç”¨è®¡æ•°åŠ 1 node = binder_get_node_from_ref(proc, fp-&gt;handle, fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata); //å®‰å…¨æ£€æŸ¥ if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123; ret = -EPERM; goto done; &#125; binder_node_lock(node); //å¦‚æœbinderå®ä½“æ‰€åœ¨çš„è¿›ç¨‹ä¸ºäº‹åŠ¡å¤„ç†è¿›ç¨‹ if (node-&gt;proc == target_proc) &#123; //binderç±»å‹è½¬æ¢ if (fp-&gt;hdr.type == BINDER_TYPE_HANDLE) fp-&gt;hdr.type = BINDER_TYPE_BINDER; else fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER; fp-&gt;binder = node-&gt;ptr; fp-&gt;cookie = node-&gt;cookie; if (node-&gt;proc) binder_inner_proc_lock(node-&gt;proc); //binderå¼ºå¼•ç”¨è®¡æ•°åŠ 1 binder_inc_node_nilocked(node, fp-&gt;hdr.type == BINDER_TYPE_BINDER, 0, NULL); if (node-&gt;proc) binder_inner_proc_unlock(node-&gt;proc); binder_node_unlock(node); &#125; else &#123; //é‡æ–°æŸ¥æ‰¾binder_ref struct binder_ref_data dest_rdata; binder_node_unlock(node); ret = binder_inc_ref_for_node(target_proc, node, fp-&gt;hdr.type == BINDER_TYPE_HANDLE, NULL, &amp;dest_rdata); if (ret) goto done; fp-&gt;binder = 0; fp-&gt;handle = dest_rdata.desc; fp-&gt;cookie = 0; &#125;done: //binder_nodeä¸´æ—¶å¼•ç”¨è®¡æ•°å‡1 binder_put_node(node); return ret;&#125; ç¬¬ä¸‰éƒ¨åˆ†ï¼šåŠ å…¥todoé˜Ÿåˆ—ï¼Œå”¤é†’ç›®æ ‡çº¿ç¨‹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_transaction *t; struct binder_work *tcomplete; struct binder_thread *target_thread = NULL; struct binder_transaction *in_reply_to = NULL; ... if (reply) &#123; //å¦‚æœè¯·æ±‚ç ä¸ºBC_REPLY //å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ binder_enqueue_thread_work(thread, tcomplete); binder_inner_proc_lock(target_proc); if (target_thread-&gt;is_dead) &#123; binder_inner_proc_unlock(target_proc); goto err_dead_proc_or_thread; &#125; //å°†å‘èµ·äº‹åŠ¡ä»ç›®æ ‡binderçº¿ç¨‹çš„äº‹åŠ¡é“¾è¡¨ä¸­ç§»é™¤ binder_pop_transaction_ilocked(target_thread, in_reply_to); //å°†t-&gt;workæ’å…¥åˆ°ç›®æ ‡binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work); binder_inner_proc_unlock(target_proc); //å”¤é†’ç›®æ ‡binderçº¿ç¨‹çš„ç­‰å¾…é˜Ÿåˆ— wake_up_interruptible_sync(&amp;target_thread-&gt;wait); //æ¢å¤å‘èµ·äº‹åŠ¡çš„ä¼˜å…ˆçº§ binder_restore_priority(current, in_reply_to-&gt;saved_priority); //é‡Šæ”¾å‘èµ·äº‹åŠ¡ binder_free_transaction(in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; //å¦‚æœè¯·æ±‚ç ä¸ºBC_TRANSACTIONå¹¶ä¸”ä¸ä¸ºå¼‚æ­¥æ“ä½œï¼Œéœ€è¦è¿”å› binder_inner_proc_lock(proc); //å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼ˆè¿™é‡Œä¼šå»¶è¿Ÿæ‰§è¡ŒBINDER_WORK_TRANSACTION_COMPLETEï¼‰ binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete); //è®¾ç½®ä¸ºéœ€è¦å›åº” t-&gt;need_reply = 1; //æ’å…¥äº‹åŠ¡é“¾è¡¨ä¸­ t-&gt;from_parent = thread-&gt;transaction_stack; thread-&gt;transaction_stack = t; binder_inner_proc_unlock(proc); //å°†t-&gt;workæ’å…¥ç›®æ ‡çº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­å¹¶å”¤é†’ç›®æ ‡è¿›ç¨‹ if (!binder_proc_transaction(t, target_proc, target_thread)) &#123; binder_inner_proc_lock(proc); //å‡ºé”™åï¼Œç§»é™¤è¯¥äº‹åŠ¡ binder_pop_transaction_ilocked(thread, t); binder_inner_proc_unlock(proc); goto err_dead_proc_or_thread; &#125; &#125; else &#123; //å¦‚æœè¯·æ±‚ç ä¸ºBC_TRANSACTIONå¹¶ä¸”ä¸ºå¼‚æ­¥æ“ä½œï¼Œä¸éœ€è¦è¿”å› //å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ binder_enqueue_thread_work(thread, tcomplete); //å°†t-&gt;workæ’å…¥ç›®æ ‡è¿›ç¨‹çš„æŸä¸ªçº¿ç¨‹ï¼ˆæˆ–ç›®æ ‡è¿›ç¨‹ï¼‰çš„todoé˜Ÿåˆ—ä¸­å¹¶å”¤é†’ç›®æ ‡è¿›ç¨‹ if (!binder_proc_transaction(t, target_proc, NULL)) goto err_dead_proc_or_thread; &#125; //å‡ä¸´æ—¶å¼•ç”¨è®¡æ•° if (target_thread) binder_thread_dec_tmpref(target_thread); binder_proc_dec_tmpref(target_proc); if (target_node) binder_dec_node_tmpref(target_node); return; ... //é”™è¯¯å¤„ç†&#125; è¿™ä¸€å—çš„ä»£ç åŸºæœ¬ä¸Šæ ¼å¼éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼Œt-&gt;workæ’å…¥åˆ°ç›®æ ‡binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼Œæœ€åå”¤é†’ç›®æ ‡è¿›ç¨‹ è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨BC_TRANSACTIONçš„æƒ…å†µä¸‹ï¼Œéœ€è¦åŒºåˆ†äº‹åŠ¡çš„flagsä¸­æ˜¯å¦åŒ…å«TF_ONE_WAYï¼Œè¿™æ„å‘³ç€è¿™ä¸ªäº‹åŠ¡æ˜¯å¦éœ€è¦å›åº” åœ¨æ²¡æœ‰TF_ONE_WAYçš„æƒ…å†µä¸‹ï¼Œä¼šä½¿ç”¨binder_enqueue_deferred_thread_work_ilockedå‡½æ•°å°†tcompleteæ’å…¥åˆ°äº‹åŠ¡å‘èµ·binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ï¼Œè¿™ä¸ªå‡½æ•°åŒºåˆ«äºbinder_enqueue_thread_work_ilockedå‡½æ•°ï¼Œå®ƒæ²¡æœ‰å°†thread-&gt;process_todoè®¾ä¸ºtrueï¼Œè¿™ä¸ªæ ‡è®°åœ¨ä¹‹å‰ä»‹ç»binder_threadç»“æ„ä½“çš„æ—¶å€™æåˆ°äº†ï¼Œå½“å…¶ä¸ºfalseçš„æƒ…å†µä¸‹ä¼šåœ¨binder_thread_readä¸­ä¼‘çœ ï¼Œå»¶è¿Ÿæ‰§è¡ŒBINDER_WORK_TRANSACTION_COMPLETEï¼Œå…·ä½“æ˜¯æ€ä¹ˆæ“ä½œçš„ï¼Œæˆ‘ä»¬ä¼šåœ¨åç»­çš„binder_thread_readå‡½æ•°ä¸­è¿›è¡Œåˆ†æ åœ¨TF_ONE_WAYçš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ˜¯æ²¡æœ‰å»å¯»æ‰¾åˆé€‚çš„ç›®æ ‡å¤„ç†binderçº¿ç¨‹çš„ï¼Œå…³äºè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦çœ‹ä¸€ä¸‹binder_proc_transactionå‡½æ•°æ˜¯æ€ä¹ˆå¤„ç†æ²¡æœ‰ä¼ å…¥binder_threadçš„æƒ…å†µçš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static bool binder_proc_transaction(struct binder_transaction *t, struct binder_proc *proc, struct binder_thread *thread)&#123; struct binder_node *node = t-&gt;buffer-&gt;target_node; struct binder_priority node_prio; bool oneway = !!(t-&gt;flags &amp; TF_ONE_WAY); bool pending_async = false; binder_node_lock(node); node_prio.prio = node-&gt;min_priority; node_prio.sched_policy = node-&gt;sched_policy; //å¦‚æœè®¾ç½®äº†TF_ONE_WAYæ ‡å¿— if (oneway) &#123; if (node-&gt;has_async_transaction) &#123; //å¦‚æœbinderå®ä½“å¯¹è±¡æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ï¼Œåšä¸€ä¸ªæ ‡è®° pending_async = true; &#125; else &#123; //å¦‚æœbinderå®ä½“å¯¹è±¡æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ï¼Œå°†has_async_transactionç½®ä¸ºtrueï¼Œè¡¨ç¤ºæ¥ä¸‹æ¥è¦å¤„ç†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ node-&gt;has_async_transaction = true; &#125; &#125; binder_inner_proc_lock(proc); //å¦‚æœç›®æ ‡è¿›ç¨‹æ­»äº¡æˆ–è€…ç›®æ ‡çº¿ç¨‹ä¸ä¸ºNULLä¸”æ­»äº¡ if (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123; binder_inner_proc_unlock(proc); binder_node_unlock(node); return false; &#125; //å¦‚æœæ²¡æœ‰ä¼ å…¥ç›®æ ‡çº¿ç¨‹ï¼Œä¸”ç›®æ ‡binderå®ä½“å¯¹è±¡æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ if (!thread &amp;&amp; !pending_async) //ä»proc-&gt;waiting_threadsé“¾è¡¨ä¸­å–å‡ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹å…ƒç´ ï¼ˆæ²¡æœ‰çš„è¯åˆ™ä¸ºNULLï¼‰ thread = binder_select_thread_ilocked(proc); if (thread) &#123; //å½“æ‰¾åˆ°äº†åˆé€‚çš„binderçº¿ç¨‹ //è®¾ç½®äº‹åŠ¡ä¼˜å…ˆçº§ binder_transaction_priority(thread-&gt;task, t, node_prio, node-&gt;inherit_rt); //å°†t-&gt;workæ’å…¥åˆ°ç›®æ ‡binderçº¿ç¨‹çš„todoé˜Ÿåˆ—ä¸­ binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work); &#125; else if (!pending_async) &#123; //æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„binderçº¿ç¨‹ï¼Œä¸”ç›®æ ‡binderå®ä½“å¯¹è±¡æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ //å°†t-&gt;workåŠ å…¥åˆ°ç›®æ ‡binderè¿›ç¨‹çš„todoé˜Ÿåˆ—ä¸­ binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo); &#125; else &#123; //æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„binderçº¿ç¨‹ï¼Œä¸”ç›®æ ‡binderå®ä½“å¯¹è±¡æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ //å°†t-&gt;workåŠ å…¥åˆ°ç›®æ ‡binderå®ä½“çš„async_todoé˜Ÿåˆ—ä¸­ binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo); &#125; //ç›®æ ‡binderå®ä½“å¯¹è±¡æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ if (!pending_async) //å”¤é†’ç›®æ ‡binderçº¿ç¨‹çš„ç­‰å¾…é˜Ÿåˆ— binder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */); binder_inner_proc_unlock(proc); binder_node_unlock(node); return true;&#125; å½“æ²¡æœ‰ä¼ å…¥ç›®æ ‡binderçº¿ç¨‹æ—¶ï¼Œä»ç›®æ ‡è¿›ç¨‹çš„ç­‰å¾…çº¿ç¨‹é“¾è¡¨ä¸­å–å‡ºç¬¬ä¸€ä¸ªbinder_threadä½œä¸ºå¤„ç†çº¿ç¨‹å¤„ç†è¯¥äº‹åŠ¡ï¼Œå¦‚æœæ²¡æ‰¾åˆ°åˆé€‚çš„ç©ºé—²çº¿ç¨‹ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š ç›®æ ‡binderå®ä½“å¯¹è±¡æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ï¼šå°†ç›¸åº”çš„binder_workæ’å…¥åˆ°ç›®æ ‡binderå®ä½“çš„async_todoé˜Ÿåˆ—ä¸­ ç›®æ ‡binderå®ä½“å¯¹è±¡æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸€ä¸ªå¼‚æ­¥äº‹åŠ¡ï¼šå°†ç›¸åº”çš„binder_workæ’å…¥åˆ°ç›®æ ‡binderè¿›ç¨‹çš„todoé˜Ÿåˆ—ä¸­ å…³äºbinderé©±åŠ¨æ˜¯æ€ä¹ˆä»è¿™äº›todoé˜Ÿåˆ—å–å‡ºbinder_workå¹¶å¤„ç†çš„ï¼Œæˆ‘ä»¬é©¬ä¸Šåœ¨åé¢binder_thread_readé‡Œåˆ†æï¼Œè¿™é‡Œæˆ‘ä»¬æœ€åå†çœ‹ä¸€ä¸‹å¦‚ä½•å”¤é†’ç›®æ ‡binderçº¿ç¨‹çš„ç­‰å¾…é˜Ÿåˆ— 123456789101112131415161718192021static void binder_wakeup_thread_ilocked(struct binder_proc *proc, struct binder_thread *thread, bool sync)&#123; assert_spin_locked(&amp;proc-&gt;inner_lock); if (thread) &#123; if (sync) wake_up_interruptible_sync(&amp;thread-&gt;wait); else wake_up_interruptible(&amp;thread-&gt;wait); return; &#125; //æ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„ç­‰å¾…çº¿ç¨‹ï¼Œå¯èƒ½åœ¨ä¸¤ç§æƒ…å†µä¸‹å‘ç”Ÿï¼š //1. æ‰€æœ‰çº¿ç¨‹éƒ½å¿™äºå¤„ç†äº‹åŠ¡ //åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿™äº›çº¿ç¨‹ä¸­çš„ä¸€ä¸ªåº”è¯¥å¾ˆå¿«å›è°ƒåˆ°å†…æ ¸é©±åŠ¨ç¨‹åºå¹¶æ‰§è¡Œè¿™é¡¹å·¥ä½œ //2. çº¿ç¨‹æ­£åœ¨ä½¿ç”¨epollè½®è¯¢ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä»¬å¯èƒ½åœ¨æ²¡æœ‰è¢«æ·»åŠ åˆ°waiting_threadsçš„æƒ…å†µä¸‹è¢«é˜»å¡åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Š //å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬åªå¾ªç¯è·å–æ‰€æœ‰ä¸å¤„ç†äº‹åŠ¡å·¥ä½œçš„çº¿ç¨‹ï¼Œå¹¶å°†å®ƒä»¬å…¨éƒ¨å”¤é†’ binder_wakeup_poll_threads_ilocked(proc, sync);&#125; è¿™ä¸ªå‡½æ•°ä¹Ÿæœ‰å¯èƒ½binder_threadå‚æ•°ä¼ å…¥NULLï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦å¾ªç¯è·å–ç›®æ ‡è¿›ç¨‹ä¸‹çš„æ‰€æœ‰binderçº¿ç¨‹ï¼Œå¯¹æ‰€æœ‰ä¸å¤„ç†äº‹åŠ¡å·¥ä½œçš„çº¿ç¨‹å…¨éƒ¨æ‰§è¡Œå”¤é†’æ“ä½œ 1234567891011121314151617static void binder_wakeup_poll_threads_ilocked(struct binder_proc *proc, bool sync)&#123; struct rb_node *n; struct binder_thread *thread; for (n = rb_first(&amp;proc-&gt;threads); n != NULL; n = rb_next(n)) &#123; thread = rb_entry(n, struct binder_thread, rb_node); if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_POLL &amp;&amp; binder_available_for_proc_work_ilocked(thread)) &#123; if (sync) wake_up_interruptible_sync(&amp;thread-&gt;wait); else wake_up_interruptible(&amp;thread-&gt;wait); &#125; &#125;&#125; æ€»ç»“åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å·²ç»åˆ†æäº†binder_ioctlå‡½æ•°çš„ä¸€åŠbinder_thread_writeï¼Œäº†è§£äº†ä¸€äº›ç›¸å…³çš„æ•°æ®ç»“æ„ï¼Œå¹¶ä¸”è¡¥å……äº†binder_mmapç¯‡æœªå®Œæˆçš„å†…å­˜æ˜ å°„çš„åˆ†æï¼Œå¤§å®¶åº”è¯¥å¯¹binderè¯·æ±‚çš„å‘èµ·ä¸è°ƒåº¦æœ‰äº†ä¸€ä¸ªåˆæ­¥çš„è®¤è¯†äº† æœ¬æ¥è¿™ä¸€ç¯‡æ˜¯æ‰“ç®—æŠŠæ•´ä¸ªbinder_ioctlåˆ†æå®Œçš„ï¼Œä½†æ²¡æƒ³åˆ°å†™åˆ°åé¢å†…å®¹è¿™ä¹ˆå¤šï¼Œåªå¥½å†åˆ†ä¸€ç¯‡ï¼Œä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æbinder_thread_readï¼Œå°†binderé©±åŠ¨ç¯‡å®Œç»“","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Androidæºç åˆ†æ - Binderé©±åŠ¨ï¼ˆä¸Šï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸Šï¼‰","date":"2022-02-09T10:29:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/02/09/android/aosp/Androidæºç åˆ†æ-Binderé©±åŠ¨ï¼ˆä¸Šï¼‰/","link":"","permalink":"http://yoursite.com/2022/02/09/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥aospåˆ†æ”¯android-11.0.0_r25ï¼Œkernelåˆ†æ”¯android-msm-wahoo-4.4-android11ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Binderæ¦‚è¿°æˆ‘ä»¬å¤§æ¦‚äº†è§£äº†ä¸€ä¸‹Androidé€‰ç”¨Binderçš„åŸå› ï¼Œä»¥åŠBinderçš„åŸºæœ¬ç»“æ„å’Œé€šä¿¡è¿‡ç¨‹ã€‚ä»Šå¤©ï¼Œæˆ‘ä»¬ä¾¿å¼€å§‹ä»Binderé©±åŠ¨å±‚ä»£ç å¼€å§‹åˆ†æBinderçš„æœºåˆ¶ æç¤ºBinderé©±åŠ¨éƒ¨åˆ†ä»£ç ä¸åœ¨AOSPé¡¹ç›®ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦å•ç‹¬cloneä¸€ä»½é©±åŠ¨ä»£ç  ç”±äºæˆ‘çš„å¼€å‘è®¾å¤‡æ˜¯pixel2ï¼ŒæŸ¥äº†Linuxå†…æ ¸ç‰ˆæœ¬å·ä¸º4.4.223ï¼Œå¯¹åº”çš„åˆ†æ”¯ä¸ºandroid-msm-wahoo-4.4-android11ï¼Œæ‰€ä»¥ä»Šå¤©çš„åˆ†ææˆ‘ä»¬ä¹Ÿæ˜¯åŸºäºæ­¤åˆ†æ”¯ æˆ‘æ˜¯ä»æ¸…åå¤§å­¦é•œåƒç«™cloneçš„ä»£ç ï¼Œé«˜é€šçš„è®¾å¤‡ï¼Œæ‰€ä»¥åœ°å€ä¸ºï¼šhttps://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git åˆå§‹åŒ–binderé©±åŠ¨çš„æºç ä½äºdrivers/androidç›®å½•ä¸‹ï¼Œæˆ‘ä»¬ä»binder.cæ–‡ä»¶çœ‹èµ· Linux initcallæœºåˆ¶åœ¨binder.cçš„æœ€åº•ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸€è¡Œä»£ç  1device_initcall(binder_init); åœ¨Linuxå†…æ ¸ä¸­ï¼Œé©±åŠ¨ç¨‹åºé€šå¸¸æ˜¯ç”¨xxx_initcall(fn)å¯åŠ¨çš„ï¼Œè¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œè¢«å®šä¹‰åœ¨å¹³å°å¯¹åº”çš„init.hæ–‡ä»¶ä¸­ 1234567891011121314151617#define early_initcall(fn) __define_initcall(fn, early)#define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4)#define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) å¯ä»¥çœ‹åˆ°ï¼Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯__define_initcall()å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°è¡¨ç¤ºä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ï¼Œä¼˜å…ˆçº§è¶Šé«˜ï¼Œå¸¦sçš„ä¼˜å…ˆçº§ä½äºä¸å¸¦sçš„ä¼˜å…ˆçº§ åœ¨Linuxå†…æ ¸å¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è°ƒç”¨å„ç§å‡½æ•°ï¼Œåœ¨åº•å±‚å®ç°æ˜¯é€šè¿‡åœ¨å†…æ ¸é•œåƒæ–‡ä»¶ä¸­ï¼Œè‡ªå®šä¹‰ä¸€ä¸ªæ®µï¼Œè¿™ä¸ªæ®µé‡Œé¢ä¸“é—¨ç”¨æ¥å­˜æ”¾è¿™äº›åˆå§‹åŒ–å‡½æ•°çš„åœ°å€ï¼Œå†…æ ¸å¯åŠ¨æ—¶ï¼Œåªéœ€è¦åœ¨è¿™ä¸ªæ®µåœ°å€å¤„å–å‡ºå‡½æ•°æŒ‡é’ˆï¼Œä¸€ä¸ªä¸ªæ‰§è¡Œå³å¯ï¼Œè€Œ__define_initcall()å‡½æ•°ï¼Œå°±æ˜¯å°†è‡ªå®šä¹‰çš„initå‡½æ•°æ·»åŠ åˆ°ä¸Šè¿°æ®µä¸­ binder_initäº†è§£äº†ä»¥ä¸Šå‡½æ•°å®šä¹‰åï¼Œæˆ‘ä»¬å†å›å¤´çœ‹device_initcall(binder_init)å°±å¯ä»¥çŸ¥é“ï¼Œåœ¨Linuxå†…æ ¸å¯åŠ¨æ—¶ï¼Œä¼šè°ƒç”¨binder_initè¿™ä¹ˆä¸€ä¸ªå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static int __init binder_init(void)&#123; int ret; char *device_name, *device_names, *device_tmp; struct binder_device *device; struct hlist_node *tmp; //åˆå§‹åŒ–binderå†…å­˜å›æ”¶ ret = binder_alloc_shrinker_init(); if (ret) return ret; ... //åˆ›å»ºä¸€ä¸ªå•çº¿ç¨‹å·¥ä½œé˜Ÿåˆ—ï¼Œç”¨äºå¤„ç†å¼‚æ­¥ä»»åŠ¡ binder_deferred_workqueue = create_singlethread_workqueue(\"binder\"); if (!binder_deferred_workqueue) return -ENOMEM; //åˆ›å»ºbinder/procç›®å½• binder_debugfs_dir_entry_root = debugfs_create_dir(\"binder\", NULL); if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(\"proc\", binder_debugfs_dir_entry_root); //åœ¨binderç›®å½•ä¸‹åˆ›å»º5ä¸ªæ–‡ä»¶ if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(\"state\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); debugfs_create_file(\"stats\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); debugfs_create_file(\"transactions\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); debugfs_create_file(\"transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); debugfs_create_file(\"failed_transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); &#125; //\"binder,hwbinder,vndbinder\" device_names = kzalloc(strlen(binder_devices_param) + 1, GFP_KERNEL); if (!device_names) &#123; ret = -ENOMEM; goto err_alloc_device_names_failed; &#125; strcpy(device_names, binder_devices_param); device_tmp = device_names; //ç”¨binder,hwbinder,vndbinderåˆ†åˆ«è°ƒç”¨init_binder_deviceå‡½æ•° while ((device_name = strsep(&amp;device_tmp, \",\"))) &#123; ret = init_binder_device(device_name); if (ret) goto err_init_binder_device_failed; &#125; return ret;err_init_binder_device_failed: ...err_alloc_device_names_failed: ...&#125; æˆ‘ä»¬å°†é‡ç‚¹æ”¾åœ¨init_binder_deviceå‡½æ•°ä¸Š init_binder_device123456789101112131415161718192021222324252627282930static int __init init_binder_device(const char *name)&#123; int ret; struct binder_device *binder_device; binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL); if (!binder_device) return -ENOMEM; //binderæ³¨å†Œè™šæ‹Ÿå­—ç¬¦è®¾å¤‡æ‰€å¯¹åº”çš„file_operations binder_device-&gt;miscdev.fops = &amp;binder_fops; //åŠ¨æ€åˆ†é…æ¬¡è®¾å¤‡å· binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR; binder_device-&gt;miscdev.name = name; binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID; binder_device-&gt;context.name = name; //åˆå§‹åŒ–äº’æ–¥é” mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock); //æ³¨å†Œmiscè®¾å¤‡ ret = misc_register(&amp;binder_device-&gt;miscdev); if (ret &lt; 0) &#123; kfree(binder_device); return ret; &#125; //å°†binderè®¾å¤‡åŠ å…¥é“¾è¡¨ï¼ˆå¤´æ’æ³•ï¼‰ hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices); return ret;&#125; å…ˆæ„é€ äº†ä¸€ä¸ªç»“æ„ä½“ç”¨æ¥å­˜æ”¾binderå‚æ•°ï¼Œç„¶åé€šè¿‡misc_registerå‡½æ•°ï¼Œä»¥miscè®¾å¤‡è¿›è¡Œæ³¨å†Œbinderï¼Œä½œä¸ºè™šæ‹Ÿå­—ç¬¦è®¾å¤‡ æ³¨å†Œmiscè®¾å¤‡æˆ‘ä»¬å…ˆå­¦ä¹ ä¸€ä¸‹åœ¨Linuxä¸­å¦‚ä½•æ³¨å†Œä¸€ä¸ªmiscè®¾å¤‡ åœ¨Linuxé©±åŠ¨ä¸­æŠŠæ— æ³•å½’ç±»çš„äº”èŠ±å…«é—¨çš„è®¾å¤‡å®šä¹‰ä¸ºmiscè®¾å¤‡ï¼ŒLinuxå†…æ ¸æ‰€æä¾›çš„miscè®¾å¤‡æœ‰å¾ˆå¼ºçš„åŒ…å®¹æ€§ï¼Œå„ç§æ— æ³•å½’ç»“ä¸ºæ ‡å‡†å­—ç¬¦è®¾å¤‡çš„ç±»å‹éƒ½å¯ä»¥å®šä¹‰ä¸ºmiscè®¾å¤‡ï¼Œè­¬å¦‚NVRAMï¼Œçœ‹é—¨ç‹—ï¼Œå®æ—¶æ—¶é’Ÿï¼Œå­—ç¬¦LCDç­‰ åœ¨Linuxå†…æ ¸é‡ŒæŠŠæ‰€æœ‰çš„miscè®¾å¤‡ç»„ç»‡åœ¨ä¸€èµ·ï¼Œæ„æˆäº†ä¸€ä¸ªå­ç³»ç»Ÿ(subsys)ï¼Œç»Ÿä¸€è¿›è¡Œç®¡ç†ã€‚åœ¨è¿™ä¸ªå­ç³»ç»Ÿé‡Œçš„æ‰€æœ‰miscdeviceç±»å‹çš„è®¾å¤‡å…±äº«ä¸€ä¸ªä¸»è®¾å¤‡å·MISC_MAJOR(10)ï¼Œä½†æ¬¡è®¾å¤‡å·ä¸åŒ åœ¨å†…æ ¸ä¸­ç”¨miscdeviceç»“æ„ä½“è¡¨ç¤ºmiscè®¾å¤‡ï¼Œå…·ä½“çš„å®šä¹‰åœ¨include/linux/miscdevice.hä¸­ 1234567891011struct miscdevice &#123; int minor; const char *name; const struct file_operations *fops; struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode;&#125;; æˆ‘ä»¬è‡ªå·±æ³¨å†Œmiscè®¾å¤‡æ—¶åªéœ€è¦å¡«å…¥å‰3é¡¹å³å¯ï¼š minorï¼šæ¬¡è®¾å¤‡å·ï¼Œå¦‚æœå¡«å……MISC_DYNAMIC_MINORï¼Œåˆ™ç”±å†…æ ¸åŠ¨æ€åˆ†é…æ¬¡è®¾å¤‡å· nameï¼šè®¾å¤‡å fopsï¼šfile_operationsç»“æ„ä½“ï¼Œç”¨äºå®šä¹‰è‡ªå·±miscè®¾å¤‡çš„æ–‡ä»¶æ“ä½œå‡½æ•°ï¼Œå¦‚æœä¸å¡«æ­¤é¡¹åˆ™ä¼šä½¿ç”¨é»˜è®¤çš„misc_fops file_operationsç»“æ„ä½“è¢«å®šä¹‰åœ¨include/linux/fs.hä¸­ 123456789101112131415161718192021222324252627282930313233struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif&#125;; file_operationæ˜¯æŠŠç³»ç»Ÿè°ƒç”¨å’Œé©±åŠ¨ç¨‹åºå…³è”èµ·æ¥çš„å…³é”®ç»“æ„ï¼Œè¿™ä¸ªç»“æ„çš„æ¯ä¸€ä¸ªæˆå‘˜éƒ½å¯¹åº”ç€ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼ŒLinuxç³»ç»Ÿè°ƒç”¨é€šè¿‡è¯»å–file_operationä¸­ç›¸åº”çš„å‡½æ•°æŒ‡é’ˆï¼Œæ¥ç€æŠŠæ§åˆ¶æƒè½¬äº¤ç»™å‡½æ•°ï¼Œä»è€Œå®ŒæˆLinuxè®¾å¤‡é©±åŠ¨ç¨‹åºçš„å·¥ä½œ æœ€åè°ƒç”¨misc_registerå‡½æ•°æ³¨å†Œmiscè®¾å¤‡ï¼Œå‡½æ•°åŸå‹å¦‚ä¸‹ï¼š 1234//æ³¨å†Œmiscè®¾å¤‡extern int misc_register(struct miscdevice *misc);//å¸è½½miscè®¾å¤‡extern void misc_deregister(struct miscdevice *misc); æ³¨å†Œbinderè®¾å¤‡äº†è§£äº†miscè®¾å¤‡çš„æ³¨å†Œï¼Œæˆ‘ä»¬å°±å¯ä»¥çœ‹ä¸€ä¸‹binderçš„æ³¨å†Œè¿‡ç¨‹äº†ï¼Œä»£ç ä¸­å…ˆæ„å»ºäº†ä¸€ä¸ªbinder_deviceç»“æ„ä½“ï¼Œæˆ‘ä»¬å…ˆè§‚å¯Ÿä¸€ä¸‹è¿™ä¸ªç»“æ„ä½“é•¿ä»€ä¹ˆæ ·å­ 12345struct binder_device &#123; struct hlist_node hlist; struct miscdevice miscdev; struct binder_context context;&#125;; å…¶ä¸­çš„hlist_nodeæ˜¯é“¾è¡¨ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œmiscdeviceå°±æ˜¯ä¸Šæ–‡æ‰€æè¿°çš„æ³¨å†Œmiscæ‰€å¿…è¦çš„ç»“æ„ä½“å‚æ•°ï¼Œbinder_contextç”¨äºä¿å­˜binderä¸Šä¸‹æ–‡ç®¡ç†è€…çš„ä¿¡æ¯ å›åˆ°ä»£ç ä¸­ï¼Œé¦–å…ˆç»™miscdeviceèµ‹äº†å€¼ï¼ŒæŒ‡å®šäº†file_operationï¼Œè®¾ç½®äº†minoråŠ¨æ€åˆ†é…æ¬¡è®¾å¤‡å·ï¼Œbinder_contextåˆ™æ˜¯ç®€å•åˆå§‹åŒ–äº†ä¸€ä¸‹ï¼Œç„¶åä¾¿è°ƒç”¨misc_registerå‡½æ•°æ³¨å†Œmiscè®¾å¤‡ï¼Œæœ€åå°†è¿™ä¸ªbinderè®¾å¤‡ä½¿ç”¨å¤´æ’æ³•åŠ å…¥åˆ°ä¸€ä¸ªå…¨å±€é“¾è¡¨ä¸­ æˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒæŒ‡å®šçš„file_operation 12345678910static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; å¯ä»¥çœ‹åˆ°ï¼Œbinderé©±åŠ¨æ”¯æŒä»¥ä¸Š7ç§ç³»ç»Ÿè°ƒç”¨ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±é€ä¸€åˆ†æè¿™äº›ç³»ç»Ÿè°ƒç”¨ binder_procåœ¨åˆ†æè¿™äº›ç³»ç»Ÿè°ƒç”¨å‰ï¼Œæˆ‘ä»¬æœ‰å¿…è¦å…ˆäº†è§£ä¸€ä¸‹åœ¨binderä¸­éå¸¸é‡è¦çš„ç»“æ„ä½“binder_procï¼Œå®ƒæ˜¯ç”¨æ¥æè¿°è¿›ç¨‹ä¸Šä¸‹æ–‡ä¿¡æ¯ä»¥åŠç®¡ç†IPCçš„ä¸€ä¸ªç»“æ„ä½“ï¼Œè¢«å®šä¹‰åœ¨drivers/android/binder.cä¸­ï¼Œæ˜¯ä¸€ä¸ªç§æœ‰çš„ç»“æ„ä½“ 1234567891011121314151617181920212223242526272829303132333435363738struct binder_proc &#123; //hashé“¾è¡¨ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ struct hlist_node proc_node; //å¤„ç†ç”¨æˆ·è¯·æ±‚çš„çº¿ç¨‹ç»„æˆçš„çº¢é»‘æ ‘ struct rb_root threads; //binderå®ä½“ç»„æˆçš„çº¢é»‘æ ‘ struct rb_root nodes; //binderå¼•ç”¨ç»„æˆçš„çº¢é»‘æ ‘ï¼Œä»¥å¥æŸ„æ¥æ’åº struct rb_root refs_by_desc; //binderå¼•ç”¨ç»„æˆçš„çº¢é»‘æ ‘ï¼Œä»¥å®ƒå¯¹åº”çš„binderå®ä½“çš„åœ°å€æ¥æ’åº struct rb_root refs_by_node; struct list_head waiting_threads; //è¿›ç¨‹id int pid; //è¿›ç¨‹æè¿°ç¬¦ struct task_struct *tsk; //è¿›ç¨‹æ‰“å¼€çš„æ‰€æœ‰æ–‡ä»¶æ•°æ® struct files_struct *files; struct mutex files_lock; struct hlist_node deferred_work_node; int deferred_work; bool is_dead; //å¾…å¤„ç†äº‹ä»¶é˜Ÿåˆ— struct list_head todo; struct binder_stats stats; struct list_head delivered_death; int max_threads; int requested_threads; int requested_threads_started; atomic_t tmp_ref; struct binder_priority default_priority; struct dentry *debugfs_entry; //ç”¨æ¥è®°å½•mmapåˆ†é…çš„ç”¨æˆ·è™šæ‹Ÿåœ°å€ç©ºé—´å’Œå†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´ç­‰ä¿¡æ¯ struct binder_alloc alloc; struct binder_context *context; spinlock_t inner_lock; spinlock_t outer_lock;&#125;; binder_openæˆ‘ä»¬å…ˆä»æ‰“å¼€binderé©±åŠ¨è®¾å¤‡å¼€å§‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static int binder_open(struct inode *nodp, struct file *filp)&#123; //ç®¡ç†IPCå’Œä¿å­˜è¿›ç¨‹ä¿¡æ¯çš„ç»“æ„ä½“ struct binder_proc *proc; struct binder_device *binder_dev; ... proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; //åˆå§‹åŒ–å†…æ ¸åŒæ­¥è‡ªæ—‹é” spin_lock_init(&amp;proc-&gt;inner_lock); spin_lock_init(&amp;proc-&gt;outer_lock); //åŸå­æ“ä½œèµ‹å€¼ atomic_set(&amp;proc-&gt;tmp_ref, 0); //ä½¿æ‰§è¡Œå½“å‰ç³»ç»Ÿè°ƒç”¨è¿›ç¨‹çš„task_struct.usageåŠ 1 get_task_struct(current-&gt;group_leader); //ä½¿binder_procä¸­çš„tskæŒ‡å‘æ‰§è¡Œå½“å‰ç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹ proc-&gt;tsk = current-&gt;group_leader; //åˆå§‹åŒ–æ–‡ä»¶é” mutex_init(&amp;proc-&gt;files_lock); //åˆå§‹åŒ–todoåˆ—è¡¨ INIT_LIST_HEAD(&amp;proc-&gt;todo); //è®¾ç½®ä¼˜å…ˆçº§ if (binder_supported_policy(current-&gt;policy)) &#123; proc-&gt;default_priority.sched_policy = current-&gt;policy; proc-&gt;default_priority.prio = current-&gt;normal_prio; &#125; else &#123; proc-&gt;default_priority.sched_policy = SCHED_NORMAL; proc-&gt;default_priority.prio = NICE_TO_PRIO(0); &#125; //æ‰¾åˆ°binder_deviceç»“æ„ä½“çš„é¦–åœ°å€ binder_dev = container_of(filp-&gt;private_data, struct binder_device, miscdev); //ä½¿binder_procçš„ä¸Šä¸‹æ–‡æŒ‡å‘binder_deviceçš„ä¸Šä¸‹æ–‡ proc-&gt;context = &amp;binder_dev-&gt;context; //åˆå§‹åŒ–binderç¼“å†²åŒº binder_alloc_init(&amp;proc-&gt;alloc); //å…¨å±€binder_statsç»“æ„ä½“ä¸­ï¼ŒBINDER_STAT_PROCç±»å‹çš„å¯¹è±¡åˆ›å»ºæ•°é‡åŠ 1 binder_stats_created(BINDER_STAT_PROC); //è®¾ç½®å½“å‰è¿›ç¨‹id proc-&gt;pid = current-&gt;group_leader-&gt;pid; //åˆå§‹åŒ–å·²åˆ†å‘çš„æ­»äº¡é€šçŸ¥åˆ—è¡¨ INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); //åˆå§‹åŒ–ç­‰å¾…çº¿ç¨‹åˆ—è¡¨ INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads); //ä¿å­˜binder_procæ•°æ® filp-&gt;private_data = proc; //å› ä¸ºbinderæ”¯æŒå¤šçº¿ç¨‹ï¼Œæ‰€ä»¥éœ€è¦åŠ é” mutex_lock(&amp;binder_procs_lock); //å°†binder_procæ·»åŠ åˆ°binder_procså…¨å±€é“¾è¡¨ä¸­ hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); //é‡Šæ”¾é” mutex_unlock(&amp;binder_procs_lock); //åœ¨binder/procç›®å½•ä¸‹åˆ›å»ºæ–‡ä»¶ï¼Œä»¥æ‰§è¡Œå½“å‰ç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹idä¸ºå if (binder_debugfs_dir_entry_proc) &#123; char strbuf[11]; snprintf(strbuf, sizeof(strbuf), \"%u\", proc-&gt;pid); proc-&gt;debugfs_entry = debugfs_create_file(strbuf, 0444, binder_debugfs_dir_entry_proc, (void *)(unsigned long)proc-&gt;pid, &amp;binder_proc_fops); &#125; return 0;&#125; binder_openå‡½æ•°åˆ›å»ºäº†binder_procç»“æ„ä½“ï¼Œå¹¶æŠŠåˆå§‹åŒ–å¹¶å°†å½“å‰è¿›ç¨‹ç­‰ä¿¡æ¯ä¿å­˜åˆ°binder_procç»“æ„ä½“ä¸­ï¼Œç„¶åå°†binder_procç»“æ„ä½“ä¿å­˜åˆ°æ–‡ä»¶æŒ‡é’ˆfilpçš„private_dataä¸­ï¼Œå†å°†binder_procåŠ å…¥åˆ°å…¨å±€é“¾è¡¨binder_procsä¸­ è¿™é‡Œé¢æœ‰ä¸€äº›å…³äºLinuxçš„çŸ¥è¯†éœ€è¦è§£é‡Šä¸€ä¸‹ spinlockspinlockæ˜¯å†…æ ¸ä¸­æä¾›çš„ä¸€ç§è‡ªæ—‹é”æœºåˆ¶ã€‚åœ¨Linuxå†…æ ¸å®ç°ä¸­ï¼Œå¸¸å¸¸ä¼šç¢°åˆ°å…±äº«æ•°æ®è¢«ä¸­æ–­ä¸Šä¸‹æ–‡å’Œè¿›ç¨‹ä¸Šä¸‹æ–‡è®¿é—®çš„åœºæ™¯ï¼Œå¦‚æœåªæœ‰è¿›ç¨‹ä¸Šä¸‹æ–‡çš„è¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨äº’æ–¥é”æˆ–è€…ä¿¡å·é‡è§£å†³ï¼Œå°†æœªè·å¾—é”çš„è¿›ç¨‹ç½®ä¸ºç¡çœ çŠ¶æ€ç­‰å¾…ï¼Œä½†ç”±äºä¸­æ–­ä¸Šä¸‹æ–‡ä¸æ˜¯ä¸€ä¸ªè¿›ç¨‹ï¼Œå®ƒä¸å­˜åœ¨task_structï¼Œæ‰€ä»¥ä¸å¯è¢«è°ƒåº¦ï¼Œå½“ç„¶ä¹Ÿå°±ä¸å¯ç¡çœ ï¼Œè¿™æ—¶å€™å°±å¯ä»¥é€šè¿‡spinlockè‡ªæ—‹é”çš„å¿™ç­‰å¾…æœºåˆ¶æ¥è¾¾æˆç¡çœ åŒæ ·çš„æ•ˆæœ currentåœ¨Linuxå†…æ ¸ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ªå«currentçš„å®ï¼Œå®ƒè¢«å®šä¹‰åœ¨asm/current.hä¸­ 123456static inline struct task_struct *get_current(void)&#123; return(current_thread_info()-&gt;task);&#125;#define current get_current() å®ƒè¿”å›ä¸€ä¸ªtask_structæŒ‡é’ˆï¼ŒæŒ‡å‘æ‰§è¡Œå½“å‰è¿™æ®µå†…æ ¸ä»£ç çš„è¿›ç¨‹ container_ofcontainer_ofä¹Ÿæ˜¯Linuxä¸­å®šä¹‰çš„ä¸€ä¸ªå®ï¼Œå®ƒçš„ä½œç”¨æ˜¯æ ¹æ®ä¸€ä¸ªç»“æ„ä½“å˜é‡ä¸­çš„ä¸€ä¸ªåŸŸæˆå‘˜å˜é‡çš„æŒ‡é’ˆæ¥è·å–æŒ‡å‘æ•´ä¸ªç»“æ„ä½“å˜é‡çš„æŒ‡é’ˆ 12345#define offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) fd&amp;filpfilp-&gt;private_dataä¿å­˜äº†binder_procç»“æ„ä½“ï¼Œå½“è¿›ç¨‹è°ƒç”¨openç³»ç»Ÿå‡½æ•°æ—¶ï¼Œå†…æ ¸ä¼šè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦fdï¼Œè¿™ä¸ªfdæŒ‡å‘æ–‡ä»¶æŒ‡é’ˆfilpï¼Œåœ¨åç»­è°ƒç”¨mmapï¼Œioctlç­‰å‡½æ•°ä¸binderé©±åŠ¨äº¤äº’æ—¶ï¼Œä¼šä¼ å…¥è¿™ä¸ªfdï¼Œå†…æ ¸å°±ä¼šä»¥è¿™ä¸ªfdæŒ‡å‘æ–‡ä»¶æŒ‡é’ˆfilpä½œä¸ºå‚æ•°è°ƒç”¨binder_mmapï¼Œbinder_ioctlç­‰å‡½æ•°ï¼Œè¿™æ ·è¿™äº›å‡½æ•°å°±å¯ä»¥é€šè¿‡filp-&gt;private_dataå–å‡ºbinder_procç»“æ„ä½“ binder_mmapvm_area_structåœ¨åˆ†æmmapå‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹vm_area_structè¿™ä¸ªç»“æ„ä½“ï¼Œå®ƒè¢«å®šä¹‰åœ¨include/linux/mm_types.hä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct vm_area_struct &#123; //å½“å‰vmaçš„é¦–åœ°å€ unsigned long vm_start; //å½“å‰vmaçš„æœ«åœ°å€åç¬¬ä¸€ä¸ªå­—èŠ‚çš„åœ°å€ unsigned long vm_end; //é“¾è¡¨ struct vm_area_struct *vm_next, *vm_prev; //çº¢é»‘æ ‘ä¸­å¯¹åº”èŠ‚ç‚¹ struct rb_node vm_rb; //å½“å‰vmaå‰é¢è¿˜æœ‰å¤šå°‘ç©ºé—²ç©ºé—´ unsigned long rb_subtree_gap; //å½“å‰vmaæ‰€å±çš„å†…å­˜åœ°å€ç©ºé—´ struct mm_struct *vm_mm; //è®¿é—®æƒé™ pgprot_t vm_page_prot; //vmaæ ‡è¯†é›†ï¼Œå®šä¹‰åœ¨ include/linux/mm.h ä¸­ unsigned long vm_flags; union &#123; struct &#123; struct rb_node rb; unsigned long rb_subtree_last; &#125; shared; const char __user *anon_name; &#125;; struct list_head anon_vma_chain; struct anon_vma *anon_vma; //å½“å‰vmaæ“ä½œå‡½æ•°é›†æŒ‡é’ˆ const struct vm_operations_struct *vm_ops; //å½“å‰vmaèµ·å§‹åœ°å€åœ¨vm_fileä¸­çš„æ–‡ä»¶åç§»ï¼Œå•ä½ä¸ºç‰©ç†é¡µé¢PAGE_SIZE unsigned long vm_pgoff; //è¢«æ˜ å°„çš„æ–‡ä»¶ï¼ˆå¦‚æœä½¿ç”¨æ–‡ä»¶æ˜ å°„ï¼‰ struct file * vm_file; void * vm_private_data;#ifndef CONFIG_MMU struct vm_region *vm_region; /* NOMMU mapping region */#endif#ifdef CONFIG_NUMA struct mempolicy *vm_policy; /* NUMA policy for the VMA */#endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx;&#125;; vm_area_structç»“æ„ä½“æè¿°äº†ä¸€æ®µè™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œé€šå¸¸ï¼Œè¿›ç¨‹æ‰€ä½¿ç”¨åˆ°çš„è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸è¿ç»­ï¼Œä¸”å„éƒ¨åˆ†è™šå­˜ç©ºé—´çš„è®¿é—®å±æ€§ä¹Ÿå¯èƒ½ä¸åŒï¼Œæ‰€ä»¥ä¸€ä¸ªè¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜ç©ºé—´éœ€è¦å¤šä¸ªvm_area_structç»“æ„æ¥æè¿°ï¼ˆåé¢ç®€ç§°vmaï¼‰ æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„task_structç»“æ„æè¿°ï¼Œè¿™ä¸ªtask_structç»“æ„ä¸­æœ‰ä¸€ä¸ªmm_structç»“æ„ç”¨äºæè¿°è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œmm_structç»“æ„ä¸­æœ‰ä¸¤ä¸ªåŸŸæˆå‘˜å˜é‡åˆ†åˆ«æŒ‡å‘äº†vmaé“¾è¡¨å¤´å’Œçº¢é»‘æ ‘æ ¹ vmaæ‰€æè¿°çš„è™šæ‹Ÿå†…å­˜ç©ºé—´èŒƒå›´ç”±vm_startå’Œvm_endè¡¨ç¤ºï¼Œvm_startä»£è¡¨å½“å‰vmaçš„é¦–åœ°å€ï¼Œvm_endä»£è¡¨å½“å‰vmaçš„æœ«åœ°å€åç¬¬ä¸€ä¸ªå­—èŠ‚çš„åœ°å€ï¼Œå³è™šæ‹Ÿå†…å­˜ç©ºé—´èŒƒå›´ä¸º[vm_start, vm_end) vm_operations_structå’Œä¸Šæ–‡ä¸­çš„file_operationsç±»ä¼¼ï¼Œç”¨æ¥å®šä¹‰è™šæ‹Ÿå†…å­˜çš„æ“ä½œå‡½æ•° ä»‹ç»å®Œvmaï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¾¿çœ‹ä¸€ä¸‹binder_mmapå‡½æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; //æ ¡éªŒè¿›ç¨‹ä¿¡æ¯ if (proc-&gt;tsk != current-&gt;group_leader) return -EINVAL; //å°†è™šæ‹Ÿå†…å­˜åœ°å€å¤§å°é™åˆ¶åœ¨4M if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; ... //æ£€æŸ¥ç”¨æˆ·ç©ºé—´æ˜¯å¦å¯å†™ï¼ˆFORBIDDEN_MMAP_FLAGS == VM_WRITEï¼‰ if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; //VM_DONTCOPYè¡¨ç¤ºæ­¤vmaä¸å¯è¢«forkæ‰€å¤åˆ¶ vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP; //ç”¨æˆ·ç©ºé—´ä¸å¯è®¾ç½®è¯¥vmaçš„VM_WRITEæ ‡å¿— vma-&gt;vm_flags &amp;= ~VM_MAYWRITE; //è®¾ç½®æ­¤vmaæ“ä½œå‡½æ•°é›† vma-&gt;vm_ops = &amp;binder_vm_ops; //æŒ‡å‘binder_proc vma-&gt;vm_private_data = proc; //å¤„ç†è¿›ç¨‹è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´çš„æ˜ å°„å…³ç³» ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma); if (ret) return ret; mutex_lock(&amp;proc-&gt;files_lock); //è·å–è¿›ç¨‹çš„æ‰“å¼€æ–‡ä»¶ä¿¡æ¯ç»“æ„ä½“files_structï¼Œå¹¶å°†å¼•ç”¨è®¡æ•°åŠ 1 proc-&gt;files = get_files_struct(current); mutex_unlock(&amp;proc-&gt;files_lock); return 0;err_bad_arg: pr_err(\"%s: %d %lx-%lx %s failed %d\\n\", __func__, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret); return ret;&#125; é¦–å…ˆä»filpä¸­è·å–å¯¹åº”çš„binder_procä¿¡æ¯ å°†å®ƒçš„è¿›ç¨‹task_structå’Œæ‰§è¡Œå½“å‰è¿™æ®µå†…æ ¸ä»£ç çš„è¿›ç¨‹task_structå¯¹æ¯”æ ¡éªŒ é™åˆ¶äº†ç”¨æˆ·ç©ºé—´è™šæ‹Ÿå†…å­˜çš„å¤§å°åœ¨4Mä»¥å†… æ£€æŸ¥ç”¨æˆ·ç©ºé—´æ˜¯å¦å¯å†™ï¼ˆbinderé©±åŠ¨ä¸ºè¿›ç¨‹åˆ†é…çš„ç¼“å†²åŒºåœ¨ç”¨æˆ·ç©ºé—´ä¸­åªå¯ä»¥è¯»ï¼Œä¸å¯ä»¥å†™ï¼‰ è®¾ç½®vm_flagsï¼Œä»¤vmaä¸å¯å†™ï¼Œä¸å¯å¤åˆ¶ è®¾ç½®vmaçš„æ“ä½œå‡½æ•°é›† å°†vm_area_structä¸­çš„æˆå‘˜å˜é‡vm_private_dataæŒ‡å‘binder_procï¼Œä½¿å¾—vmaè®¾ç½®çš„æ“ä½œå‡½æ•°ä¸­å¯ä»¥æ‹¿åˆ°binder_proc å¤„ç†è¿›ç¨‹è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´çš„æ˜ å°„å…³ç³» è·å–è¿›ç¨‹çš„æ‰“å¼€æ–‡ä»¶ä¿¡æ¯ç»“æ„ä½“files_structï¼Œä»¤binder_procçš„filesæŒ‡å‘å®ƒï¼Œå¹¶å°†å¼•ç”¨è®¡æ•°åŠ 1 binder_alloc_mmap_handlerbinder_alloc_mmap_handlerå°†è¿›ç¨‹è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´åšæ˜ å°„ï¼Œå®ƒè¢«å®ç°åœ¨drivers/android/binder_alloc.cä¸­ è¿™é‡Œå…ˆä»‹ç»ä¸€ä¸‹vm_structï¼Œä¹‹å‰æˆ‘ä»¬å·²ç»äº†è§£äº†vm_area_structè¡¨ç¤ºç”¨æˆ·è¿›ç¨‹ä¸­çš„è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œè€Œç›¸å¯¹åº”çš„ï¼Œvm_structåˆ™è¡¨ç¤ºå†…æ ¸ä¸­çš„è™šæ‹Ÿåœ°å€ç©ºé—´ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; const char *failure_string; struct binder_buffer *buffer; mutex_lock(&amp;binder_alloc_mmap_lock); //æ£€æŸ¥æ˜¯å¦å·²ç»åˆ†é…è¿‡å†…æ ¸ç¼“å†²åŒº if (alloc-&gt;buffer) &#123; ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; &#125; //è·å¾—ä¸€ä¸ªå†…æ ¸è™šæ‹Ÿç©ºé—´ area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; //alloc-&gt;bufferæŒ‡å‘å†…æ ¸è™šæ‹Ÿå†…å­˜ç©ºé—´åœ°å€ alloc-&gt;buffer = area-&gt;addr; //è®¡ç®—å‡ºç”¨æˆ·è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€åˆ°å†…æ ¸è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€çš„åç§»é‡ alloc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)alloc-&gt;buffer; mutex_unlock(&amp;binder_alloc_mmap_lock); ... //ç”³è¯·å†…å­˜ alloc-&gt;pages = kzalloc(sizeof(alloc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (alloc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; //bufferå¤§å°ç­‰äºvmaå¤§å° alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; buffer = kzalloc(sizeof(*buffer), GFP_KERNEL); if (!buffer) &#123; ret = -ENOMEM; failure_string = \"alloc buffer struct\"; goto err_alloc_buf_struct_failed; &#125; //æŒ‡å‘å†…æ ¸è™šæ‹Ÿç©ºé—´åœ°å€ buffer-&gt;data = alloc-&gt;buffer; //å°†bufferæ·»åŠ åˆ°é“¾è¡¨ä¸­ list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers); buffer-&gt;free = 1; //å°†æ­¤å†…æ ¸ç¼“å†²åŒºåŠ å…¥åˆ°binder_allocçš„ç©ºé—²ç¼“å†²çº¢é»‘æ ‘ä¸­ binder_insert_free_buffer(alloc, buffer); //è®¾ç½®è¿›ç¨‹æœ€å¤§å¯ç”¨å¼‚æ­¥äº‹åŠ¡ç¼“å†²åŒºå¤§å°ï¼ˆé˜²æ­¢å¼‚æ­¥äº‹åŠ¡æ¶ˆè€—è¿‡å¤šå†…æ ¸ç¼“å†²åŒºï¼Œå½±å“åŒæ­¥äº‹åŠ¡ï¼‰ alloc-&gt;free_async_space = alloc-&gt;buffer_size / 2; //å†…å­˜å±éšœï¼Œä¿è¯æŒ‡ä»¤é¡ºåºæ‰§è¡Œ barrier(); //è®¾ç½®binder_alloc alloc-&gt;vma = vma; alloc-&gt;vma_vm_mm = vma-&gt;vm_mm; //å¼•ç”¨è®¡æ•°+1 atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count); return 0; ... //é”™è¯¯å¤„ç†&#125; æ£€æŸ¥æ˜¯å¦å·²ç»åˆ†é…è¿‡å†…æ ¸ç¼“å†²åŒº ä»å†…æ ¸ä¸­å¯»æ‰¾ä¸€å—å¯ç”¨çš„è™šæ‹Ÿå†…å­˜åœ°å€ å°†æ­¤å†…æ ¸è™šæ‹Ÿå†…å­˜ç©ºé—´åœ°å€ä¿å­˜è‡³binder_alloc è®¡ç®—å‡ºç”¨æˆ·è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€åˆ°å†…æ ¸è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€çš„åç§»é‡ï¼ˆè¿™æ ·å°±å¯ä»¥éå¸¸æ–¹ä¾¿çš„åœ¨ç”¨æˆ·è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸å†…æ ¸è™šæ‹Ÿå†…å­˜ç©ºé—´é—´åˆ‡æ¢ï¼‰ ä¸ºalloc-&gt;pagesæ•°ç»„ç”³è¯·å†…å­˜ï¼Œç”³è¯·çš„å¤§å°ç­‰äºvmaèƒ½åˆ†é…å¤šå°‘ä¸ªé¡µæ¡† è®¾ç½®bufferå¤§å°ç­‰äºvmaå¤§å° ä¸ºbinder_bufferç”³è¯·å†…å­˜ï¼Œå¡«å……å‚æ•°ï¼Œä½¿å…¶æŒ‡å‘å†…æ ¸è™šæ‹Ÿç©ºé—´åœ°å€ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°é“¾è¡¨å’Œçº¢é»‘æ ‘ä¸­ è®¾ç½®binder_allocå…¶ä»–å‚æ•° è¿™é‡Œè¦æ³¨æ„ï¼Œè™½ç„¶æˆ‘ä»¬è®¡ç®—å‡ºäº†ç”¨æˆ·è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€åˆ°å†…æ ¸è™šæ‹Ÿç©ºé—´çº¿æ€§åœ°å€çš„åç§»é‡ï¼Œä½†å¹¶æ²¡æœ‰å»ºç«‹æ˜ å°„å…³ç³»ã€‚åœ¨æ—§ç‰ˆå†…æ ¸ä¸­ï¼Œè¿™é‡Œä¼šè°ƒç”¨binder_update_page_rangeå‡½æ•°åˆ†åˆ«å°†å†…æ ¸è™šæ‹Ÿå†…å­˜å’Œè¿›ç¨‹è™šæ‹Ÿå†…å­˜ä¸ç‰©ç†å†…å­˜åšæ˜ å°„ï¼Œè¿™æ ·å†…æ ¸è™šæ‹Ÿå†…å­˜å’Œè¿›ç¨‹è™šæ‹Ÿå†…å­˜ä¹Ÿç›¸å½“äºé—´æ¥å»ºç«‹äº†æ˜ å°„å…³ç³»ï¼Œè€Œåœ¨4.4.223ä¸­ï¼Œè¿™ä»¶äº‹å°†ä¼šå»¶è¿Ÿåˆ°binder_ioctlå å½“å®Œæˆç‰©ç†å†…å­˜çš„æ˜ å°„åï¼Œä»¥32ä½ç³»ç»Ÿï¼Œç¼“å†²åŒºå¤§å°4Mä¸ºä¾‹ï¼Œæ•ˆæœåº”è¯¥å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ€»ç»“åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº†binderé©±åŠ¨è®¾å¤‡æ˜¯å¦‚ä½•æ³¨å†Œçš„ï¼Œå¹¶ä¸”åˆ†æäº†binder_openå’Œbinder_mmapæ“ä½œå‡½æ•°ï¼Œäº†è§£äº†ä¸€äº›é‡è¦çš„ç»“æ„ä½“ï¼Œæ˜ç™½äº†mmapæ˜¯å¦‚ä½•æ˜ å°„ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„ï¼Œç”±äºç¯‡å¹…åŸå› ï¼Œä¸‹ä¸€ç« æˆ‘ä»¬ä¼šåˆ†æbinderé©±åŠ¨ä¸­æœ€é‡è¦çš„éƒ¨åˆ†binder_ioctl å‚è€ƒæ–‡çŒ® linuxä¸­çš„miscè®¾å¤‡ å†…å­˜æ˜ å°„ä¸VMA Android é‡å­¦ç³»åˆ— Binderé©±åŠ¨çš„åˆå§‹åŒ– æ˜ å°„åŸç†(äºŒ) Binderç³»åˆ—1â€”Binder Driveråˆæ¢ Linux 4.16 Binderé©±åŠ¨å­¦ä¹ ç¬”è®°â€”â€”â€“æ¥å£ç®€æ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Androidæºç åˆ†æ - Binderæ¦‚è¿°","slug":"android/aosp/Androidæºç åˆ†æ-Binderæ¦‚è¿°","date":"2022-02-01T05:03:00.000Z","updated":"2022-11-13T09:55:54.353Z","comments":true,"path":"2022/02/01/android/aosp/Androidæºç åˆ†æ-Binderæ¦‚è¿°/","link":"","permalink":"http://yoursite.com/2022/02/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E6%A6%82%E8%BF%B0/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡æ— æºç åˆ†æï¼Œåªå¯¹Binderåšé€šä¿¡è¿‡ç¨‹å’ŒåŸºç¡€æ¶æ„çš„ä»‹ç» Binderæ˜¯Androidä¸­æœ€é‡è¦çš„ä¸€ç§è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ï¼ŒåŸºäºå¼€æºçš„OpenBinder George Hoffmanå½“æ—¶ä»»Beå…¬å¸çš„å·¥ç¨‹å¸ˆï¼Œä»–å¯åŠ¨äº†ä¸€ä¸ªåä¸ºOpenBinderçš„é¡¹ç›®ï¼Œåœ¨Beå…¬å¸è¢«ParmSourceå…¬å¸æ”¶è´­åï¼ŒOpenBinderç”±Dinnie Hackbornç»§ç»­å¼€å‘ï¼Œåæ¥æˆä¸ºç®¡ç†ParmOS6 Cobalt OSçš„è¿›ç¨‹çš„åŸºç¡€ã€‚åœ¨HackbornåŠ å…¥è°·æ­Œåï¼Œä»–åœ¨OpenBinderçš„åŸºç¡€ä¸Šå¼€å‘å‡ºäº†Android Binder(ä»¥ä¸‹ç®€ç§°Binder)ï¼Œç”¨æ¥å®ŒæˆAndroidçš„è¿›ç¨‹é€šä¿¡ã€‚ ä¸ºä»€ä¹ˆéœ€è¦å­¦ä¹ Binderä½œä¸ºä¸€åAndroidå¼€å‘ï¼Œæˆ‘ä»¬æ¯å¤©éƒ½åœ¨å’ŒBinderæ‰“äº¤é“ï¼Œè™½ç„¶å¯èƒ½æœ‰çš„æ—¶å€™ä¸ä¼šæ³¨æ„åˆ°ï¼Œè­¬å¦‚ï¼š startActivityçš„æ—¶å€™ï¼Œä¼šè·å–AMSæœåŠ¡ï¼Œè°ƒç”¨AMSæœåŠ¡çš„startActivityæ–¹æ³• startActivityä¼ é€’çš„å¯¹è±¡ä¸ºä»€ä¹ˆéœ€è¦åºåˆ—åŒ– bindServiceä¸ºä»€ä¹ˆå›è°ƒçš„æ˜¯ä¸€ä¸ªIbinderå¯¹è±¡ å¤šè¿›ç¨‹åº”ç”¨ï¼Œå„ä¸ªè¿›ç¨‹ä¹‹é—´å¦‚ä½•é€šä¿¡ AIDLçš„ä½¿ç”¨ â€¦ å®ƒä»¬éƒ½å’ŒBinderæœ‰ç€è«åˆ‡å…³ç³»ï¼Œå½“ç¢°åˆ°ä¸Šé¢çš„åœºæ™¯ï¼Œæˆ–è€…ä¸€äº›ç–‘éš¾é—®é¢˜çš„æ—¶å€™ï¼Œç†è§£Binderæœºåˆ¶æ˜¯éå¸¸æœ‰å¿…è¦çš„ ä¸ºä»€ä¹ˆAndroidé€‰æ‹©Binderè¿™å°±è¦ä»è¿›ç¨‹é—´é€šä¿¡å¼€å§‹è¯´èµ·äº†ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹æ¯”è¾ƒå¸¸è§çš„å‡ ç§è¿›ç¨‹é—´é€šä¿¡æ–¹å¼ å¸¸è§è¿›ç¨‹é—´é€šä¿¡å…±äº«å†…å­˜å…±äº«å†…å­˜æ˜¯è¿›ç¨‹é—´é€šä¿¡ä¸­æœ€ç®€å•çš„æ–¹å¼ä¹‹ä¸€ï¼Œå…±äº«å†…å­˜å…è®¸ä¸¤ä¸ªæˆ–æ›´å¤šè¿›ç¨‹è®¿é—®åŒä¸€å—å†…å­˜ï¼Œå½“ä¸€ä¸ªè¿›ç¨‹æ”¹å˜äº†è¿™å—åœ°å€ä¸­çš„å†…å®¹çš„æ—¶å€™ï¼Œå…¶å®ƒè¿›ç¨‹éƒ½ä¼šå¯Ÿè§‰åˆ°è¿™ä¸ªæ›´æ”¹ï¼Œå®ƒçš„åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å› ä¸ºå…±äº«å†…å­˜æ˜¯è®¿é—®åŒä¸€å—å†…å­˜ï¼Œæ‰€ä»¥æ•°æ®ä¸éœ€è¦è¿›è¡Œä»»ä½•å¤åˆ¶ï¼Œæ˜¯IPCå‡ ç§æ–¹å¼ä¸­æœ€å¿«ï¼Œæ€§èƒ½æœ€å¥½çš„æ–¹å¼ã€‚ä½†ç›¸å¯¹åº”çš„ï¼Œå…±äº«å†…å­˜æœªæä¾›åŒæ­¥æœºåˆ¶ï¼Œéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ§åˆ¶å†…å­˜é—´çš„äº’æ–¥æ“ä½œï¼Œè¾ƒå®¹æ˜“å‘ç”Ÿé—®é¢˜ã€‚åŒæ—¶å…±äº«å†…å­˜ç”±äºèƒ½ä»»æ„çš„è®¿é—®å’Œä¿®æ”¹å†…å­˜ä¸­çš„æ•°æ®ï¼Œå¦‚æœæœ‰æ¶æ„ç¨‹åºå»é’ˆå¯¹æŸä¸ªç¨‹åºè®¾è®¡ä»£ç ï¼Œå¾ˆå¯èƒ½å¯¼è‡´éšç§æ³„æ¼æˆ–è€…ç¨‹åºå´©æºƒï¼Œæ‰€ä»¥å®‰å…¨æ€§è¾ƒå·®ã€‚ ç®¡é“ç®¡é“åˆ†ä¸ºå‘½åç®¡é“å’Œæ— åç®¡é“ï¼Œå®ƒæ˜¯ä»¥ä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ä½œä¸ºä¸­é—´ä»‹è´¨ï¼Œæˆ‘ä»¬ç§°ä¸ºç®¡é“æ–‡ä»¶ï¼Œå®ƒå…·æœ‰å›ºå®šçš„è¯»ç«¯å’Œå†™ç«¯ï¼Œå†™è¿›ç¨‹é€šè¿‡å†™æ®µå‘ç®¡é“æ–‡ä»¶é‡Œå†™å…¥æ•°æ®ï¼Œè¯»è¿›ç¨‹é€šè¿‡è¯»æ®µä»è¯»è¿›ç¨‹ä¸­è¯»å‡ºæ•°æ®ï¼Œæ„æˆä¸€æ¡æ•°æ®ä¼ é€’çš„æµæ°´çº¿ï¼Œå®ƒçš„åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç®¡é“ä¸€æ¬¡é€šä¿¡éœ€è¦ç»å†2æ¬¡æ•°æ®å¤åˆ¶ï¼ˆè¿›ç¨‹A -&gt; ç®¡é“æ–‡ä»¶ï¼Œç®¡é“æ–‡ä»¶ -&gt; è¿›ç¨‹Bï¼‰ã€‚ç®¡é“çš„è¯»å†™åˆ†é˜»å¡å’Œéé˜»å¡ï¼Œç®¡é“åˆ›å»ºä¼šåˆ†é…ä¸€ä¸ªç¼“å†²åŒºï¼Œè€Œè¿™ä¸ªç¼“å†²åŒºæ˜¯æœ‰é™çš„ï¼Œå¦‚æœä¼ è¾“çš„æ•°æ®å¤§å°è¶…è¿‡ç¼“å†²åŒºä¸Šé™ï¼Œæˆ–è€…åœ¨é˜»å¡æ¨¡å¼ä¸‹æ²¡æœ‰å®‰æ’å¥½æ•°æ®çš„è¯»å†™ï¼Œä¼šå‡ºç°é˜»å¡çš„æƒ…å†µã€‚ç®¡é“æ‰€ä¼ é€çš„æ˜¯æ— æ ¼å¼å­—èŠ‚æµï¼Œè¿™å°±è¦æ±‚ç®¡é“çš„è¯»å‡ºæ–¹å’Œå†™å…¥æ–¹å¿…é¡»äº‹å…ˆçº¦å®šå¥½æ•°æ®çš„æ ¼å¼ã€‚ æ¶ˆæ¯é˜Ÿåˆ—æ¶ˆæ¯é˜Ÿåˆ—æ˜¯å­˜æ”¾åœ¨å†…æ ¸ä¸­çš„æ¶ˆæ¯é“¾è¡¨ï¼Œæ¯ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ç”±æ¶ˆæ¯é˜Ÿåˆ—æ ‡è¯†ç¬¦è¡¨ç¤ºã€‚æ¶ˆæ¯é˜Ÿåˆ—å…è®¸å¤šä¸ªè¿›ç¨‹åŒæ—¶è¯»å†™æ¶ˆæ¯ï¼Œå‘é€æ–¹ä¸æ¥æ”¶æ–¹è¦çº¦å®šå¥½ï¼Œæ¶ˆæ¯ä½“çš„æ•°æ®ç±»å‹ä¸å¤§å°ã€‚æ¶ˆæ¯é˜Ÿåˆ—å…‹æœäº†ä¿¡å·æ‰¿è½½ä¿¡æ¯é‡å°‘ã€ç®¡é“åªèƒ½æ‰¿è½½æ— æ ¼å¼å­—èŠ‚æµç­‰ç¼ºç‚¹ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä¸€æ¬¡é€šä¿¡åŒæ ·éœ€è¦ç»å†2æ¬¡æ•°æ®å¤åˆ¶ï¼ˆè¿›ç¨‹A -&gt; æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ¶ˆæ¯é˜Ÿåˆ— -&gt; è¿›ç¨‹Bï¼‰ï¼Œå®ƒçš„åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š SocketSocketåŸæœ¬æ˜¯ä¸ºäº†ç½‘ç»œè®¾è®¡çš„ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡æœ¬åœ°å›ç¯åœ°å€ (127.0.0.1) è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡ï¼Œåæ¥åœ¨Socketçš„æ¡†æ¶ä¸Šæ›´æ˜¯å‘å±•å‡ºä¸€ç§IPCæœºåˆ¶ï¼Œåå«UNIX Domain Socketã€‚Socketæ˜¯ä¸€ç§å…¸å‹çš„C/Sæ¶æ„ï¼Œä¸€ä¸ªSocketä¼šæ‹¥æœ‰ä¸¤ä¸ªç¼“å†²åŒºï¼Œä¸€è¯»ä¸€å†™ï¼Œç”±äºå‘é€/æ¥æ”¶æ¶ˆæ¯éœ€è¦å°†ä¸€ä¸ªSocketç¼“å†²åŒºä¸­çš„å†…å®¹æ‹·è´è‡³å¦ä¸€ä¸ªSocketç¼“å†²åŒºï¼Œæ‰€ä»¥Socketä¸€æ¬¡é€šä¿¡ä¹Ÿæ˜¯éœ€è¦ç»å†2æ¬¡æ•°æ®å¤åˆ¶ï¼Œå®ƒçš„åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Binderäº†è§£äº†å¸¸è§è¿›ç¨‹é—´é€šä¿¡çš„æ–¹å¼ï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸‹Binderçš„åŸç† Binderæ˜¯åŸºäºå†…å­˜æ˜ å°„mmapè®¾è®¡å®ç°çš„ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€ä¸‹mmapçš„æ¦‚å¿µ mmapmmapæ˜¯ä¸€ç§å†…å­˜æ˜ å°„çš„æ–¹æ³•ï¼Œå³å°†ä¸€ä¸ªæ–‡ä»¶æˆ–è€…å…¶å®ƒå¯¹è±¡æ˜ å°„åˆ°è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œå®ç°æ–‡ä»¶ç£ç›˜åœ°å€å’Œè¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ä¸€æ®µè™šæ‹Ÿåœ°å€çš„ä¸€ä¸€å¯¹æ˜ å…³ç³»ã€‚å®ç°è¿™æ ·çš„æ˜ å°„å…³ç³»åï¼Œè¿›ç¨‹å°±å¯ä»¥é‡‡ç”¨æŒ‡é’ˆçš„æ–¹å¼è¯»å†™æ“ä½œè¿™ä¸€æ®µå†…å­˜ï¼Œè€Œç³»ç»Ÿä¼šè‡ªåŠ¨å›å†™è„é¡µé¢åˆ°å¯¹åº”çš„æ–‡ä»¶ç£ç›˜ä¸Šï¼Œå³å®Œæˆäº†å¯¹æ–‡ä»¶çš„æ“ä½œè€Œä¸å¿…å†è°ƒç”¨read,writeç­‰ç³»ç»Ÿè°ƒç”¨å‡½æ•°ã€‚ç›¸åï¼Œå†…æ ¸ç©ºé—´å¯¹è¿™æ®µåŒºåŸŸçš„ä¿®æ”¹ä¹Ÿç›´æ¥åæ˜ ç”¨æˆ·ç©ºé—´ï¼Œä»è€Œå¯ä»¥å®ç°ä¸åŒè¿›ç¨‹é—´çš„æ–‡ä»¶å…±äº«ã€‚ Linuxå†…æ ¸ä¸ä¼šä¸»åŠ¨å°†mmapä¿®æ”¹åçš„å†…å®¹åŒæ­¥åˆ°ç£ç›˜æ–‡ä»¶ä¸­ï¼Œæœ‰4ä¸ªæ—¶æœºä¼šè§¦å‘mmapæ˜ å°„åŒæ­¥åˆ°ç£ç›˜ï¼š è°ƒç”¨ msync å‡½æ•°ä¸»åŠ¨è¿›è¡Œæ•°æ®åŒæ­¥ï¼ˆä¸»åŠ¨ï¼‰ è°ƒç”¨ munmap å‡½æ•°å¯¹æ–‡ä»¶è¿›è¡Œè§£é™¤æ˜ å°„å…³ç³»æ—¶ï¼ˆä¸»åŠ¨ï¼‰ è¿›ç¨‹é€€å‡ºæ—¶ï¼ˆè¢«åŠ¨ï¼‰ ç³»ç»Ÿå…³æœºæ—¶ï¼ˆè¢«åŠ¨ï¼‰ é€šè¿‡è¿™ç§æ–¹å¼ï¼Œç›´æ¥æ“ä½œæ˜ å°„çš„è¿™ä¸€éƒ¨åˆ†å†…å­˜ï¼Œå¯ä»¥é¿å…ä¸€äº›æ•°æ®å¤åˆ¶ï¼Œä»è€Œè·å¾—æ›´å¥½çš„æ€§èƒ½ åŸç†ä¸€æ¬¡Binder IPCé€šä¿¡çš„è¿‡ç¨‹åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š é¦–å…ˆï¼ŒBinderé©±åŠ¨åœ¨å†…æ ¸ç©ºé—´ä¸­å¼€è¾Ÿå‡ºä¸€ä¸ªæ•°æ®æ¥æ”¶ç¼“å†²åŒº æ¥ç€ï¼Œåœ¨å†…æ ¸ç©ºé—´ä¸­å¼€è¾Ÿå‡ºä¸€ä¸ªå†…æ ¸ç¼“å†²åŒº å°†å†…æ ¸ç¼“å†²åŒºä¸æ•°æ®æ¥æ”¶ç¼“å†²åŒºå»ºç«‹æ˜ å°„å…³ç³» å°†æ•°æ®æ¥æ”¶ç¼“å†²åŒºä¸æ¥æ”¶è¿›ç¨‹çš„ç”¨æˆ·ç©ºé—´åœ°å€å»ºç«‹æ˜ å°„å…³ç³» å‘é€æ–¹è¿›ç¨‹é€šè¿‡copy_from_userå°†æ•°æ®ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶åˆ°å†…æ ¸ç¼“å†²åŒº ç”±äºå†…æ ¸ç¼“å†²åŒºä¸æ•°æ®æ¥æ”¶ç¼“å†²åŒºæœ‰æ˜ å°„å…³ç³»ï¼ŒåŒæ—¶æ•°æ®æ¥æ”¶ç¼“å†²åŒºä¸æ¥æ”¶è¿›ç¨‹çš„ç”¨æˆ·ç©ºé—´åœ°å€æœ‰æ˜ å°„å…³ç³»ï¼Œæ‰€ä»¥åœ¨æ¥æ”¶è¿›ç¨‹ä¸­å¯ä»¥ç›´æ¥è·å–åˆ°è¿™æ®µæ•°æ® è¿™æ ·ä¾¿å®Œæˆäº†ä¸€æ¬¡Binder IPCé€šä¿¡ï¼Œå®ƒçš„åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å¯ä»¥çœ‹åˆ°ï¼Œé€šè¿‡mmapï¼ŒBinderé€šä¿¡æ—¶ï¼Œåªéœ€è¦ç»å†ä¸€æ¬¡æ•°æ®å¤åˆ¶ï¼Œæ€§èƒ½è¦ä¼˜äºç®¡é“/æ¶ˆæ¯é˜Ÿåˆ—/socketç­‰æ–¹å¼ï¼Œåœ¨å®‰å…¨æ€§ï¼Œæ˜“ç”¨æ€§æ–¹é¢åˆä¼˜äºå…±äº«å†…å­˜ã€‚é‰´äºä¸Šè¿°åŸå› ï¼ŒAndroidé€‰æ‹©äº†è¿™ç§æŠ˜ä¸­çš„IPCæ–¹å¼ï¼Œæ¥æ»¡è¶³ç³»ç»Ÿå¯¹ç¨³å®šæ€§ã€ä¼ è¾“æ€§èƒ½å’Œå®‰å…¨æ€§æ–¹é¢çš„è¦æ±‚ Binderæ¶æ„Binderä¹Ÿæ˜¯ä¸€ç§C/Sæ¶æ„ï¼Œåˆ†ä¸ºBpBinderï¼ˆå®¢æˆ·ç«¯ï¼‰å’ŒBBinderï¼ˆæœåŠ¡ç«¯ï¼‰ï¼Œä»–ä»¬éƒ½æ´¾ç”Ÿè‡ªIBinderã€‚å…¶ä¸­BpBinderä¸­çš„pè¡¨ç¤ºproxyï¼Œå³ä»£ç†ã€‚BpBinderé€šè¿‡transactæ¥å‘é€äº‹åŠ¡è¯·æ±‚ï¼ŒBBinderé€šè¿‡onTransactæ¥æ¥æ”¶ç›¸åº”çš„äº‹åŠ¡ Binderä¸€æ¬¡é€šä¿¡çš„æ—¶åºå›¾å¦‚ä¸‹ï¼š Binderé‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ æ€»ç»“è‡³æ­¤ï¼Œæˆ‘ä»¬å¤§æ¦‚äº†è§£äº†ä¸€ä¸‹Androidé€‰ç”¨Binderçš„åŸå› ï¼Œä»¥åŠBinderçš„åŸºæœ¬ç»“æ„å’Œé€šä¿¡è¿‡ç¨‹ï¼Œä¸ºä¹‹åæ·±å…¥æºç å±‚åˆ†æBinderåšäº†å‡†å¤‡ å‚è€ƒæ–‡çŒ® å†™ç»™ Android åº”ç”¨å·¥ç¨‹å¸ˆçš„ Binder åŸç†å‰–æ Binderç³»åˆ—â€”å¼€ç¯‡ Android BinderåŸç†å›¾è§£ Binderå’ŒAIDLå®ä¾‹åŠåŸç†è§£æ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Androidæºç åˆ†æ - SystemServerï¼ˆä¸‹ï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-SystemServerï¼ˆä¸‹ï¼‰","date":"2022-01-29T08:36:00.000Z","updated":"2022-11-13T09:55:54.356Z","comments":true,"path":"2022/01/29/android/aosp/Androidæºç åˆ†æ-SystemServerï¼ˆä¸‹ï¼‰/","link":"","permalink":"http://yoursite.com/2022/01/29/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - SystemServerï¼ˆä¸Šï¼‰æˆ‘ä»¬åˆ†æäº†SystemServerè¿›ç¨‹æ˜¯æ€ä¹ˆè¢«å¯åŠ¨èµ·æ¥çš„ï¼Œä»Šå¤©è¿™ç¯‡ï¼Œæˆ‘ä»¬æ¥åˆ†æSystemServerè¿›ç¨‹å¯åŠ¨ååšäº†ä»€ä¹ˆ mainæˆ‘ä»¬ä¸Šä¸€ç« ä¸­è®²åˆ°ï¼ŒZygoteè¿›ç¨‹forkå‡ºå­è¿›ç¨‹åï¼Œæœ€ç»ˆè°ƒç”¨äº†SystemServer.mainæ–¹æ³•ï¼ŒSystemServeræºä»£ç åœ¨frameworks/base/services/java/com/android/server/SystemServer.javaä¸­ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹åšäº†ä»€ä¹ˆ 123public static void main(String[] args) &#123; new SystemServer().run();&#125; æ„é€ æ–¹æ³•éå¸¸ç®€å•ï¼Œå°±æ˜¯å…ˆnewäº†ä¸€ä¸ªSystemServerå¯¹è±¡ï¼Œç„¶åè°ƒç”¨å®ƒçš„runæ–¹æ³•ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹æ„é€ æ–¹æ³• 123456789public SystemServer() &#123; //å·¥å‚æ¨¡å¼ mFactoryTestMode = FactoryTest.getMode(); ... //è®°å½•å¯åŠ¨ä¿¡æ¯ //è®°å½•æ˜¯å¦ç»å†è¿‡é‡å¯ mRuntimeRestart = \"1\".equals(SystemProperties.get(\"sys.boot_completed\"));&#125; å·¥å‚æ¨¡å¼é¦–å…ˆï¼Œå…ˆä»ç³»ç»Ÿå±æ€§ä¸­è·å–å·¥å‚æ¨¡å¼çº§åˆ«ï¼Œæœ‰ä¸‰ç§å±æ€§ï¼š FACTORY_TEST_OFFï¼šæ­£å¸¸æ¨¡å¼ FACTORY_TEST_LOW_LEVELï¼šä½çº§åˆ«å·¥å‚æ¨¡å¼ï¼Œåœ¨æ­¤æ¨¡å¼ä¸‹ï¼Œå¾ˆå¤šServiceä¸ä¼šå¯åŠ¨ FACTORY_TEST_HIGH_LEVELï¼šé«˜çº§åˆ«å·¥å‚æ¨¡å¼ï¼Œæ­¤æ¨¡å¼ä¸æ­£å¸¸æ¨¡å¼åŸºæœ¬ç›¸åŒï¼Œç•¥æœ‰åŒºåˆ« å®ƒä»¬è¢«å®šä¹‰åœ¨frameworks/base/core/java/android/os/FactoryTest.javaä¸­ runç´§æ¥ç€ä¾¿å¼€å§‹æ‰§è¡Œrunæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private void run() &#123; ... //è®°å½•å¯åŠ¨ä¿¡æ¯ //å¦‚æœæ²¡æœ‰è®¾ç½®æ—¶åŒºï¼Œå°†æ—¶åŒºè®¾ç½®ä¸ºGMT String timezoneProperty = SystemProperties.get(\"persist.sys.timezone\"); if (timezoneProperty == null || timezoneProperty.isEmpty()) &#123; Slog.w(TAG, \"Timezone not set; setting to GMT.\"); SystemProperties.set(\"persist.sys.timezone\", \"GMT\"); &#125; //è®¾ç½®åŒºåŸŸä¸è¯­è¨€ if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125; //Binderäº‹åŠ¡å‘ç”Ÿé˜»å¡æ—¶å‘å‡ºè­¦å‘Š Binder.setWarnOnBlocking(true); //PackageManagerç›¸å…³ PackageItemInfo.forceSafeLabels(); ... //è®¾ç½®è™šæ‹Ÿæœºåº“æ–‡ä»¶libart.so SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); //æ¸…é™¤è™šæ‹Ÿæœºå†…å­˜å¢é•¿ä¸Šé™ï¼Œä»¥è·å¾—æ›´å¤šå†…å­˜ VMRuntime.getRuntime().clearGrowthLimit(); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); //è®¾ç½®åœ¨è®¿é—®ç¯å¢ƒå˜é‡å‰ï¼Œéœ€è¦æ˜ç¡®æŒ‡å®šç”¨æˆ· Environment.setUserRequired(true); //è®¾ç½®æ ‡è®°ï¼Œå½“å‘ç”ŸBadParcelableExceptionå¼‚å¸¸æ—¶ä¿å®ˆå¤„ç†ï¼Œä¸è¦æŠ›å‡ºå¼‚å¸¸ BaseBundle.setShouldDefuse(true); //è®¾ç½®å¼‚å¸¸è·Ÿè¸ª Parcel.setStackTraceParceling(true); //ç¡®ä¿Binderè°ƒç”¨ä¼˜å…ˆçº§æ€»ä¸ºå‰å°ä¼˜å…ˆçº§ BinderInternal.disableBackgroundScheduling(true); //è®¾ç½®Binderçº¿ç¨‹æ± æœ€å¤§æ•°é‡ BinderInternal.setMaxThreads(sMaxBinderThreads); //è®¾ç½®è¿›ç¨‹ä¼˜å…ˆçº§ä¸ºå‰å°è¿›ç¨‹ // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); //ä»¥å½“å‰çº¿ç¨‹ä½œä¸ºMainLooperå‡†å¤‡ Looper.prepareMainLooper(); Looper.getMainLooper().setSlowLogThresholdMs( SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS); SystemServiceRegistry.sEnableServiceNotFoundWtf = true; //åŠ è½½android_servers.soåº“ System.loadLibrary(\"android_servers\"); //æ ‡è®°è¯¥è¿›ç¨‹çš„å †å¯åˆ†æ initZygoteChildHeapProfiling(); //Debugé€‰é¡¹ - å¼€å¯ä¸€ä¸ªçº¿ç¨‹ç”¨æ¥ç›‘æµ‹FDæ³„æ¼ if (Build.IS_DEBUGGABLE) &#123; spawnFdLeakCheckThread(); &#125; //æ£€æŸ¥ä¸Šæ¬¡å…³æœºè¿‡ç¨‹ä¸­æ˜¯å¦å¤±è´¥ performPendingShutdown(); //åˆå§‹åŒ–System Context createSystemContext(); //åˆ›å»ºå¹¶è®¾ç½®ä¸€äº›æ¯ä¸ªè¿›ç¨‹å¯åŠ¨æ—¶éƒ½éœ€è¦çš„ä¸€äº›æ¨¡å— (TelephonyServiceManager, StatsServiceManager) ActivityThread.initializeMainlineModules(); //åˆ›å»ºSystemServiceManagerï¼ˆç®¡ç†æ‰€æœ‰çš„ç³»ç»ŸServiceï¼‰ mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); //å°†SystemServiceManagerä½œä¸ºæœ¬åœ°è¿›ç¨‹Serviceä½¿ç”¨ LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); //ä¸ºåˆå§‹åŒ–ä»»åŠ¡å‡†å¤‡çº¿ç¨‹æ±  SystemServerInitThreadPool.start(); ... //è®¾ç½®é»˜è®¤å¼‚å¸¸å¤„ç†ç¨‹åº RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf); ... //å¯åŠ¨å¼•å¯¼æœåŠ¡ startBootstrapServices(t); //å¯åŠ¨æ ¸å¿ƒæœåŠ¡ startCoreServices(t); //å¯åŠ¨å…¶ä»–æœåŠ¡ startOtherServices(t); ... //ä¸¥æ ¼æ¨¡å¼åˆå§‹åŒ–è™šæ‹Ÿæœºç­–ç•¥ StrictMode.initVmDefaults(null); ... //è¿›å…¥Looperæ­»å¾ªç¯ï¼Œç­‰å¾…Handleräº‹ä»¶ Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; å¯ä»¥çœ‹åˆ°ï¼Œrunæ–¹æ³•ä¸»è¦åšäº†ä»¥ä¸‹å·¥ä½œ æ£€æŸ¥å¹¶è®¾ç½®å„ç§å‚æ•°handler åˆ›å»ºSystemContext åˆ›å»ºSystemServiceManager å¯åŠ¨æœåŠ¡ Looperå¾ªç¯ å…¶ä¸­ï¼Œåˆ›å»ºSystemContextè¿™ä¸€æ­¥æ˜¯ç”±ContextImplå®Œæˆçš„ï¼Œç­‰åé¢åˆ†æåˆ°çš„æ—¶å€™åœ¨è¯¦ç»†å»çœ‹ï¼ŒLooperä¹Ÿæ˜¯ï¼Œæˆ‘ä»¬å°†é‡ç‚¹æ”¾åœ¨å¯åŠ¨æœåŠ¡ä¸Š å¯åŠ¨æœåŠ¡å¯åŠ¨æœåŠ¡åˆ†ä¸ºä¸‰æ­¥ï¼Œé¦–å…ˆæ˜¯å¯åŠ¨å¼•å¯¼æœåŠ¡ï¼Œå…¶æ¬¡æ˜¯å¯åŠ¨æ ¸å¿ƒæœåŠ¡ï¼Œæœ€åæ˜¯å¯åŠ¨å…¶ä»–æœåŠ¡ï¼Œæˆ‘ä»¬å…ˆä»å¼•å¯¼æœåŠ¡å¼€å§‹ ç”±äºå¯åŠ¨çš„æœåŠ¡å¤ªå¤šäº†ï¼Œæˆ‘ä»¬åªä»‹ç»ä¸€äº›æˆ‘ä»¬æ¯”è¾ƒç†Ÿæ‚‰çš„æœåŠ¡ startBootstrapServices1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123; ... //çœ‹é—¨ç‹— final Watchdog watchdog = Watchdog.getInstance(); watchdog.start(); ... final String TAG_SYSTEM_CONFIG = \"ReadingSystemConfig\"; //è¯»å–ç³»ç»Ÿé…ç½® SystemServerInitThreadPool.submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG); ... //InstalleræœåŠ¡ï¼ˆå®é™…ä¸Šæ˜¯ä¸installdè·¨è¿›ç¨‹é€šä¿¡ï¼‰ Installer installer = mSystemServiceManager.startService(Installer.class); ... //åˆ›å»º ATMS &amp; AMS ActivityTaskManagerService atm = mSystemServiceManager.startService( ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); mWindowManagerGlobalLock = atm.getGlobalLock(); ... //ç”µæºç®¡ç†æœåŠ¡ï¼Œåé¢æœ‰å…¶ä»–æœåŠ¡ä¾èµ–å®ƒï¼Œæ‰€ä»¥éœ€è¦è¾ƒæ—©å¯åŠ¨ mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); ... mActivityManagerService.initPowerManagement(); ... //ç¯å…‰æœåŠ¡ mSystemServiceManager.startService(LightsService.class); ... //æ˜¾ç¤ºç®¡ç†æœåŠ¡ mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); ... //é˜¶æ®µ100 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); ... //åˆ›å»ºPMS try &#123; Watchdog.getInstance().pauseWatchingCurrentThread(\"packagemanagermain\"); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); &#125; finally &#123; Watchdog.getInstance().resumeWatchingCurrentThread(\"packagemanagermain\"); &#125; //æ•è·dex loadè¡Œä¸º SystemServerDexLoadReporter.configureSystemServerDexReporter(mPackageManagerService); //æ˜¯å¦é¦–æ¬¡å¯åŠ¨ mFirstBoot = mPackageManagerService.isFirstBoot(); //è·å–PMS mPackageManager = mSystemContext.getPackageManager(); ... //ç”¨æˆ·ç®¡ç†æœåŠ¡ mSystemServiceManager.startService(UserManagerService.LifeCycle.class); ... //åˆå§‹åŒ–å±æ€§ç¼“å­˜ AttributeCache.init(mSystemContext); ... //æ³¨å†Œå„ç§ç³»ç»ŸæœåŠ¡ mActivityManagerService.setSystemProcess(); ... //ä½¿ç”¨AMSå®Œæˆçœ‹é—¨ç‹—çš„è®¾ç½®ï¼Œå¹¶ç›‘å¬é‡æ–°å¯åŠ¨ watchdog.init(mSystemContext, mActivityManagerService); ... //è®¾ç½®è°ƒåº¦ç­–ç•¥ mDisplayManagerService.setupSchedulerPolicies(); ... //åœ¨å•ç‹¬çº¿ç¨‹ä¸­å¯åŠ¨ä¼ æ„Ÿå™¨æœåŠ¡ mSensorServiceStart = SystemServerInitThreadPool.submit(() -&gt; &#123; TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog(); traceLog.traceBegin(START_SENSOR_SERVICE); startSensorService(); traceLog.traceEnd(); &#125;, START_SENSOR_SERVICE); ...&#125; startCoreServices1234567891011private void startCoreServices(@NonNull TimingsTraceAndSlog t) &#123; ... //ç”µæ± ç”µé‡æœåŠ¡ï¼Œä¾èµ–LightsService mSystemServiceManager.startService(BatteryService.class); ... //åº”ç”¨ç»Ÿè®¡æœåŠ¡ mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); ...&#125; startOtherServices123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123; ... //AccountManagerService - è´¦æˆ·ç®¡ç† mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS); ... //ContentService - å†…å®¹æœåŠ¡ mSystemServiceManager.startService(CONTENT_SERVICE_CLASS); ... //åŠ è½½SettingProvider mActivityManagerService.installSystemProviders(); ... //DropBoxæ—¥å¿—æœåŠ¡ mSystemServiceManager.startService(DropBoxManagerService.class); ... //éœ‡åŠ¨æœåŠ¡ vibrator = new VibratorService(context); ServiceManager.addService(\"vibrator\", vibrator); ... //æ—¶é’Ÿ/é—¹é’ŸæœåŠ¡ mSystemServiceManager.startService(new AlarmManagerService(context)); //è¾“å…¥æœåŠ¡ inputManager = new InputManagerService(context); ... //ç­‰å¾…ä¼ æ„Ÿå™¨æœåŠ¡å‡†å¤‡å®Œæ¯• ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE); mSensorServiceStart = null; //å¯åŠ¨WindowManagerService wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); ... mActivityManagerService.setWindowManager(wm); ... wm.onInitReady(); ... //HIDL services SystemServerInitThreadPool.submit(() -&gt; &#123; startHidlServices(); &#125;, START_HIDL_SERVICES); ... //å…³è”WMSï¼Œå¯åŠ¨è¾“å…¥æœåŠ¡ inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback()); inputManager.start(); ... mDisplayManagerService.windowManagerAndInputReady(); ... //æœ‰è“ç‰™åŠŸèƒ½ä¸”éä½çº§å·¥å‚æ¨¡å¼ï¼Œå¯åŠ¨è“ç‰™æœåŠ¡ if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; ... &#125; else if (!context.getPackageManager().hasSystemFeature (PackageManager.FEATURE_BLUETOOTH)) &#123; ... &#125; else &#123; mSystemServiceManager.startService(BluetoothService.class); &#125; ... //è¾“å…¥æ³•/æ— éšœç¢æœåŠ¡ if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; if (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) &#123; mSystemServiceManager.startService( MultiClientInputMethodManagerService.Lifecycle.class); &#125; else &#123; mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class); &#125; mSystemServiceManager.startService(ACCESSIBILITY_MANAGER_SERVICE_CLASS); &#125; wm.displayReady(); //å­˜å‚¨ç›¸å…³æœåŠ¡ if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; if (!\"0\".equals(SystemProperties.get(\"system_init.startmountservice\"))) &#123; mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS); storageManager = IStorageManager.Stub.asInterface( ServiceManager.getService(\"mount\")); mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS); &#125; &#125; //UIModeæœåŠ¡ï¼ˆå¤œé—´æ¨¡å¼ï¼Œé©¾é©¶æ¨¡å¼ç­‰ï¼‰ mSystemServiceManager.startService(UiModeManagerService.class); ... //æ‰§è¡Œç£ç›˜æ¸…ç†å·¥ä½œï¼Œé‡Šæ”¾ç£ç›˜ç©ºé—´ mPackageManagerService.performFstrimIfNeeded(); if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; ... final boolean hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(\"\"); ... if (hasPdb || OemLockService.isHalPresent()) &#123; //OEMé”æœåŠ¡ mSystemServiceManager.startService(OemLockService.class); &#125; ... if (!isWatch) &#123; //çŠ¶æ€æ ç®¡ç†æœåŠ¡ statusBar = new StatusBarManagerService(context); ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar); &#125; //ç½‘ç»œç›¸å…³æœåŠ¡ ConnectivityModuleConnector.getInstance().init(context); NetworkStackClient.getInstance().init(); networkManagement = NetworkManagementService.create(context); ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement); ipSecService = IpSecService.create(context, networkManagement); ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService); //æ–‡æœ¬æœåŠ¡ mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class); mSystemServiceManager .startService(TextClassificationManagerService.Lifecycle.class); //ç½‘ç»œç›¸å…³æœåŠ¡ mSystemServiceManager.startService(NetworkScoreService.Lifecycle.class); networkStats = NetworkStatsService.create(context, networkManagement); ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats); networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkManagement); ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy); if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); mSystemServiceManager.startServiceFromJar( WIFI_SCANNING_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_RTT)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_RTT_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_AWARE)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_AWARE_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_DIRECT)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_LOWPAN)) &#123; mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS); &#125; if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123; mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS); &#125; connectivity = new ConnectivityService( context, networkManagement, networkStats, networkPolicy); ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL); networkPolicy.bindConnectivityManager(connectivity); ... //ç³»ç»Ÿæ›´æ–°æœåŠ¡ ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE, new SystemUpdateManagerService(context)); ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context)); //é€šçŸ¥æœåŠ¡ mSystemServiceManager.startService(NotificationManagerService.class); SystemNotificationChannels.removeDeprecated(context); SystemNotificationChannels.createAll(context); notification = INotificationManager.Stub.asInterface( ServiceManager.getService(Context.NOTIFICATION_SERVICE)); ... //ä½ç½®æœåŠ¡ mSystemServiceManager.startService(LocationManagerService.Lifecycle.class); ... //å¢™çº¸æœåŠ¡ if (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) &#123; mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS); &#125; else &#123; ... &#125; //éŸ³é¢‘æœåŠ¡ if (!isArc) &#123; mSystemServiceManager.startService(AudioService.Lifecycle.class); &#125; else &#123; String className = context.getResources() .getString(R.string.config_deviceSpecificAudioService); mSystemServiceManager.startService(className + \"$Lifecycle\"); &#125; ... //ADBæœåŠ¡ mSystemServiceManager.startService(ADB_SERVICE_CLASS); //USBæœåŠ¡ if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature( PackageManager.FEATURE_USB_ACCESSORY) || isEmulator) &#123; mSystemServiceManager.startService(USB_SERVICE_CLASS); &#125; //å¾®ä»¶ï¼ˆå°ç»„ä»¶ï¼‰æœåŠ¡ if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) &#123; mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS); &#125; ... //Android10æ–°å¢ï¼Œç”¨äºæŠ¥å‘Šæ¥è‡ªè¿è¡Œæ—¶æ¨¡å—çš„ä¿¡æ¯ ServiceManager.addService(\"runtime\", new RuntimeService(context)); ... //Appåå°Dexä¼˜åŒ– BackgroundDexOptService.schedule(context); ... &#125; ... //ç›¸æœºæœåŠ¡ if (!disableCameraService) &#123; mSystemServiceManager.startService(CameraServiceProxy.class); &#125; //è¿›å…¥å®‰å…¨æ¨¡å¼ if (safeMode) &#123; mActivityManagerService.enterSafeMode(); &#125; //çŸ­ä¿¡æœåŠ¡ mmsService = mSystemServiceManager.startService(MmsServiceBroker.class); ... //å‰ªè´´æ¿æœåŠ¡ mSystemServiceManager.startService(ClipboardService.class); ... //è°ƒç”¨å„å¤§æœåŠ¡çš„systemReadyæ–¹æ³• vibrator.systemReady(); lockSettings.systemReady(); //é˜¶æ®µ480 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_LOCK_SETTINGS_READY); //é˜¶æ®µ500 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_SYSTEM_SERVICES_READY); wm.systemReady(); ... //æ‰‹åŠ¨æ›´æ–°Context Configuration final Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY); DisplayMetrics metrics = new DisplayMetrics(); context.getDisplay().getMetrics(metrics); context.getResources().updateConfiguration(config, metrics); final Theme systemTheme = context.getTheme(); if (systemTheme.getChangingConfigurations() != 0) &#123; systemTheme.rebase(); &#125; mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService()); ... mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(safeMode, mOnlyCore); mSystemServiceManager.setSafeMode(safeMode); //é˜¶æ®µ520 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY); ... //æœ€åè¿è¡ŒAMS.systemReady mActivityManagerService.systemReady(() -&gt; &#123; //é˜¶æ®µ550 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //é˜¶æ®µ600 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); ... &#125;, t);&#125; æœåŠ¡çš„å¯åŠ¨æ˜¯åˆ†é˜¶æ®µå®Œæˆçš„ï¼Œä»0-100-480-500-520-550-600-1000ï¼Œæœ€åçš„é˜¶æ®µ1000ï¼Œæ˜¯åœ¨AMSè°ƒç”¨finishBootingæ–¹æ³•åè¿›å…¥ å¯ä»¥çœ‹åˆ°ï¼Œå¯åŠ¨çš„æœåŠ¡éå¸¸ä¹‹å¤šï¼Œä¸å¯èƒ½å…¨çœ‹å¾—å®Œï¼Œå…¶ä¸­æœ€é‡è¦çš„å‡ ä¸ªï¼šActivityManagerServiceã€WindowManagerServiceã€PackageManagerServiceå’ŒInputManagerServiceï¼Œåé¢æˆ‘ä»¬ä¼šæ…¢æ…¢çœ‹è¿‡å»ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜æ˜¯å…ˆçœ‹çœ‹æœåŠ¡å¯åŠ¨çš„æ–¹å¼ SystemServiceManagerç»å¤§éƒ¨åˆ†çš„æœåŠ¡æ˜¯é€šè¿‡SystemServiceManagerå¯åŠ¨çš„ï¼Œå®ƒçš„æºç è·¯å¾„ä¸ºframeworks/base/services/core/java/com/android/server/SystemServiceManager.java startServiceæˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªç±»é‡Œçš„å¯åŠ¨æœåŠ¡æ–¹æ³• è¿™ä¸ªç±»ä¸­æœ‰ä¸‰ä¸ªæ–¹æ³•ç”¨äºå¯åŠ¨Serivceï¼Œåˆ†åˆ«æ˜¯ï¼š public SystemService startService(String className) public SystemService startServiceFromJar(String className, String path) public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) public void startService(@NonNull final SystemService service) å®é™…ä¸Šæœ€åéƒ½æ˜¯è°ƒç”¨äº†æœ€åä¸€ä¸ªæ–¹æ³• å…ˆçœ‹å‚æ•°ä¸ºStringçš„startServiceæ–¹æ³• 12345public SystemService startService(String className) &#123; final Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, this.getClass().getClassLoader()); return startService(serviceClass);&#125; 12345678private static Class&lt;SystemService&gt; loadClassFromLoader(String className, ClassLoader classLoader) &#123; try &#123; return (Class&lt;SystemService&gt;) Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; ... &#125;&#125; å®é™…ä¸Šå°±æ˜¯é€šè¿‡åå°„æ‹¿åˆ°ç±»åå¯¹åº”çš„Classï¼Œå†è°ƒç”¨Classä¸ºå‚çš„startServiceæ–¹æ³• startServiceFromJarå®é™…ä¸Šä¹Ÿæ˜¯ä¸€æ ·ï¼Œåªä¸è¿‡æ˜¯å…ˆé€šè¿‡PathClassLoaderåŠ è½½äº†jarè€Œå·² 1234567891011public SystemService startServiceFromJar(String className, String path) &#123; PathClassLoader pathClassLoader = mLoadedPaths.get(path); if (pathClassLoader == null) &#123; // NB: the parent class loader should always be the system server class loader. // Changing it has implications that require discussion with the mainline team. pathClassLoader = new PathClassLoader(path, this.getClass().getClassLoader()); mLoadedPaths.put(path, pathClassLoader); &#125; final Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, pathClassLoader); return startService(serviceClass);&#125; æ¥ç€æˆ‘ä»¬çœ‹çœ‹Classä¸ºå‚æ•°çš„startServiceæ–¹æ³• 12345678910111213141516171819public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; final String name = serviceClass.getName(); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException(\"Failed to create \" + name + \": service must extend \" + SystemService.class.getName()); &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (...) &#123; ... &#125; startService(service); return service;&#125; çœ‹å‡½æ•°æ³›å‹æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ï¼Œè¿™ä¸ªæ–¹æ³•åªæ¥å—SystemServiceçš„å­ç±»ï¼Œå¹¶ä¸”åœ¨æ–¹æ³•çš„å¼€å¤´ï¼Œè¿˜ä½¿ç”¨äº†isAssignableFromæ–¹æ³•åšäº†ç±»å‹æ ¡éªŒï¼Œé¿å…é€šè¿‡Stringåå°„è·å–çš„ClasséSystemServiceçš„å­ç±» ä¹‹åçš„é€»è¾‘ä¹Ÿå¾ˆç®€å•ï¼Œåå°„å®ä¾‹åŒ–å¯¹è±¡ï¼Œç„¶åè°ƒç”¨å¦ä¸€ä¸ªä»¥SystemServiceå¯¹è±¡ä¸ºå‚æ•°çš„é‡è½½æ–¹æ³• 123456789public void startService(@NonNull final SystemService service) &#123; mServices.add(service); try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(\"Failed to start service \" + service.getClass().getName() + \": onStart threw an exception\", ex); &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¼šå°†SystemServiceå¯¹è±¡åŠ å…¥ä¸€ä¸ªListä¸­ï¼Œç„¶åè°ƒç”¨å®ƒçš„onStartæ–¹æ³•ï¼Œé€šçŸ¥SystemServiceè‡ªè¡Œå¤„ç†å¯åŠ¨ startBootPhaseå› ä¸ºå„ç§æœåŠ¡ä¹‹é—´æ˜¯å­˜åœ¨ä¾èµ–å…³ç³»çš„ï¼Œæ‰€ä»¥Androidå°†æœåŠ¡çš„å¯åŠ¨åˆ’åˆ†äº†8ä¸ªé˜¶æ®µï¼š0-100-480-500-520-550-600-1000ï¼Œè€ŒstartBootPhaseæ–¹æ³•ä¾¿æ˜¯ç”¨æ¥é€šçŸ¥å„ä¸ªæœåŠ¡è¿›è¡Œåˆ°å“ªä¸€é˜¶æ®µäº† 12345678910111213141516public void startBootPhase(@NonNull TimingsTraceAndSlog t, int phase) &#123; if (phase &lt;= mCurrentPhase) &#123; throw new IllegalArgumentException(\"Next phase must be larger than previous\"); &#125; mCurrentPhase = phase; final int serviceLen = mServices.size(); for (int i = 0; i &lt; serviceLen; i++) &#123; final SystemService service = mServices.get(i); service.onBootPhase(mCurrentPhase); &#125; if (phase == SystemService.PHASE_BOOT_COMPLETED) &#123; SystemServerInitThreadPool.shutdown(); &#125;&#125; æ¯è¿›å…¥åˆ°ä¸€ä¸ªé˜¶æ®µï¼Œä¾¿ä¼šè°ƒç”¨Service Listä¸­æ‰€æœ‰SystemServiceçš„onBootPhaseæ–¹æ³•ï¼Œé€šçŸ¥SystemServiceé˜¶æ®µå˜æ¢ï¼Œè€Œå½“é˜¶æ®µè¾¾åˆ°1000 (PHASE_BOOT_COMPLETED) æ—¶ï¼Œå°±ä»£è¡¨ç€æ‰€æœ‰çš„æœåŠ¡éƒ½å·²å‡†å¤‡å®Œæ¯•ï¼Œå…³é—­SystemServerInitThreadPoolçº¿ç¨‹æ±  ServiceManagerå½“æœåŠ¡è¢«åˆ›å»ºå‡ºæ¥åï¼Œä¼šè°ƒç”¨ServiceManager.addServiceæ–¹æ³•æ·»åŠ æœåŠ¡ï¼Œä»¥ä¾›å…¶ä»–åœ°æ–¹ä½¿ç”¨è¿™äº›æœåŠ¡ addServiceæœ‰ä¸‰ä¸ªé‡è½½ï¼Œæœ€ç»ˆè°ƒç”¨çš„ä¸ºï¼š 12345678public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) &#123; try &#123; getIServiceManager().addService(name, service, allowIsolated, dumpPriority); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in addService\", e); &#125;&#125; 12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager;&#125; 12345678public static IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // ServiceManager is never local return new ServiceManagerProxy(obj);&#125; 12345678910111213141516171819class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; mServiceManager = IServiceManager.Stub.asInterface(remote); &#125; public IBinder asBinder() &#123; return mRemote; &#125; ... public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException &#123; mServiceManager.addService(name, service, allowIsolated, dumpPriority); &#125; ... private IBinder mRemote; private IServiceManager mServiceManager;&#125; ä»è¿™é‡Œå°±èƒ½çœ‹å‡ºæ¥ServiceManagerå®é™…ä¸Šæ˜¯ä¸€ä¸ªå•ç‹¬çš„è¿›ç¨‹ï¼Œåä¸ºservicemanagerï¼Œå®ƒè´Ÿè´£ç®¡ç†æ‰€æœ‰æœåŠ¡ï¼Œä½¿ç”¨äº†Binder IPCæœºåˆ¶ï¼Œæˆ‘ä»¬è°ƒç”¨addServiceæ–¹æ³•å®é™…ä¸Šæ˜¯è°ƒç”¨äº†Binder Proxyçš„æ–¹æ³•ï¼Œä»–å‘/dev/binderä¸­å†™å…¥æ¶ˆæ¯ï¼Œåœ¨servicemanagerè¿›ç¨‹ä¸­æ¥æ”¶åˆ°äº†è¿™ä¸ªæ¶ˆæ¯å¹¶å¤„ç†è¿™ä¸ªè¯·æ±‚ å…³äºBinderæœºåˆ¶ï¼Œæˆ‘ä»¬éšåä¾¿ä¼šåˆ†æå®ƒ æœ€ç»ˆè°ƒç”¨äº†frameworks/native/cmds/servicemanager/ServiceManager.cppä¸­çš„addServiceå‡½æ•° 12345678910111213141516171819202122Status ServiceManager::addService(const std::string&amp; name, const sp&lt;IBinder&gt;&amp; binder, bool allowIsolated, int32_t dumpPriority) &#123; auto ctx = mAccess-&gt;getCallingContext(); ... //æ·»åŠ æœåŠ¡ auto entry = mNameToService.emplace(name, Service &#123; .binder = binder, .allowIsolated = allowIsolated, .dumpPriority = dumpPriority, .debugPid = ctx.debugPid, &#125;); auto it = mNameToRegistrationCallback.find(name); if (it != mNameToRegistrationCallback.end()) &#123; for (const sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123; entry.first-&gt;second.guaranteeClient = true; // permission checked in registerForNotifications cb-&gt;onRegistration(name, binder); &#125; &#125; return Status::ok();&#125; å¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆé€šè¿‡service nameå’Œä¼ è¿‡æ¥çš„binderå¯¹è±¡æ„é€ å‡ºä¸€ä¸ªServiceç»“æ„ä½“ï¼Œå¹¶å°†å…¶ä¿å­˜è‡³mNameToServiceè¿™ä¸ªMapä¸­ï¼Œä»¥ä¾›åé¢ä½¿ç”¨ å…³äºè¿›ç¨‹SystemServerå¯åŠ¨çš„æœåŠ¡å¤§å¤šéƒ½è¿è¡Œåœ¨systemserverè¿›ç¨‹ä¸­ï¼Œä½†ä¹Ÿæœ‰ä¸€äº›ä¾‹å¤– è­¬å¦‚InstalleræœåŠ¡ï¼Œä¾¿æ˜¯ä»initè¿›ç¨‹å•ç‹¬forkå‡ºäº†ä¸€ä¸ªinstalldè¿›ç¨‹ ä¸‹é¢æ˜¯å®ƒçš„rcæ–‡ä»¶ï¼Œframeworks/native/cmds/installd/installd.rc 123service installd &#x2F;system&#x2F;bin&#x2F;installdclass main... è€Œåœ¨SystemServerè¿›ç¨‹ä¸­startçš„Installerï¼Œä¾¿æ˜¯é€šè¿‡binderè¿æ¥åˆ°installdè¿›ç¨‹æä¾›æœåŠ¡ æºç è·¯å¾„frameworks/base/services/core/java/com/android/server/pm/Installer.java 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onStart() &#123; if (mIsolated) &#123; mInstalld = null; &#125; else &#123; connect(); &#125;&#125;private void connect() &#123; IBinder binder = ServiceManager.getService(\"installd\"); if (binder != null) &#123; try &#123; binder.linkToDeath(new DeathRecipient() &#123; @Override public void binderDied() &#123; Slog.w(TAG, \"installd died; reconnecting\"); connect(); &#125; &#125;, 0); &#125; catch (RemoteException e) &#123; binder = null; &#125; &#125; if (binder != null) &#123; mInstalld = IInstalld.Stub.asInterface(binder); try &#123; invalidateMounts(); &#125; catch (InstallerException ignored) &#123; &#125; &#125; else &#123; Slog.w(TAG, \"installd not found; trying again\"); BackgroundThread.getHandler().postDelayed(() -&gt; &#123; connect(); &#125;, DateUtils.SECOND_IN_MILLIS); &#125;&#125; ç»“æŸSystemServerå¯åŠ¨äº†éå¸¸å¤šçš„æœåŠ¡ï¼Œå¹¶å°†è¿™äº›æœåŠ¡æ·»åŠ åˆ°äº†ServiceManagerä¸­ï¼Œæˆ‘ä»¬åˆä»ä¸­å¼•ç”³å‡ºäº†Binderæœºåˆ¶ï¼Œæˆ‘ä»¬ä¸‹ä¸€ç« ä¾¿å¼€å§‹åˆ†æBinder","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"}]},{"title":"Androidæºç åˆ†æ - SystemServerï¼ˆä¸Šï¼‰","slug":"android/aosp/Androidæºç åˆ†æ-SystemServerï¼ˆä¸Šï¼‰","date":"2022-01-17T12:42:00.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/01/17/android/aosp/Androidæºç åˆ†æ-SystemServerï¼ˆä¸Šï¼‰/","link":"","permalink":"http://yoursite.com/2022/01/17/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - Zygoteè¿›ç¨‹ï¼Œæˆ‘ä»¬åˆ†æäº†Android Zygoteè¿›ç¨‹çš„å¯åŠ¨å’Œä¹‹åæ˜¯å¦‚ä½•æ¥æ”¶æ¶ˆæ¯åˆ›å»ºAppè¿›ç¨‹çš„ åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬è¯´äº†ï¼ŒZygoteçš„ä¸€å¤§ä½œç”¨å°±æ˜¯å¯åŠ¨SystemServerï¼Œé‚£ä¹ˆSystemServeræ˜¯æ€ä¹ˆå¯åŠ¨çš„å‘¢ï¼Ÿå¯åŠ¨ååˆåšäº†äº›ä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬åˆ†ä¸Šä¸‹ä¸¤ç¯‡æ¥åˆ†æï¼Œæœ¬ç¯‡ä»‹ç»SystemServeræ˜¯å¦‚ä½•å¯åŠ¨çš„ ä»‹ç»SystemServerä¸»è¦æ˜¯ç”¨æ¥åˆ›å»ºç³»ç»ŸæœåŠ¡çš„ï¼Œè­¬å¦‚æˆ‘ä»¬ç†ŸçŸ¥çš„ActivityManagerServiceï¼ŒPackageManagerServiceéƒ½æ˜¯ç”±å®ƒåˆ›å»ºçš„ å¯åŠ¨SystemServeræˆ‘ä»¬ä»ä¸Šä¸€ç¯‡æ–‡ç« çš„ZygoteInitå¼€å§‹ï¼ŒZygoteInitç±»çš„æºç è·¯å¾„ä¸ºframeworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112131415161718192021222324public static void main(String argv[]) &#123; ... boolean startSystemServer = false; ... for (int i = 1; i &lt; argv.length; i++) &#123; //å‚æ•°ä¸­æœ‰start-system-server if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; ... &#125; ... //å¯åŠ¨SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); //å­è¿›ç¨‹ä¸­æ‰ä¼šæ»¡è¶³r != null if (r != null) &#123; //æ­¤æ—¶æ‰§è¡Œè¿™ä¸ªRunnable r.run(); return; &#125; &#125;&#125; ä¹‹å‰åœ¨c++ä»£ç ä¸­JNIè°ƒç”¨Javaå‡½æ•°çš„æ—¶å€™ï¼Œå¸¦äº†å‚æ•°start-system-serverï¼Œåœ¨è¿™é‡Œå°±ä¼šé€šè¿‡è¿™ä¸ªå‚æ•°åˆ¤æ–­æ˜¯å¦å¯åŠ¨SystemServerï¼Œæ¥ä¸‹æ¥è°ƒç”¨forkSystemServeræ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; //è®¾ç½®Linux capabilities long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_IPC_LOCK, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_PTRACE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG, OsConstants.CAP_WAKE_ALARM, OsConstants.CAP_BLOCK_SUSPEND ); //ç§»é™¤ä¸€äº›å½“å‰çº¿ç¨‹éƒ½ä¸å¯ç”¨çš„ç‰¹æƒ StructCapUserHeader header = new StructCapUserHeader( OsConstants._LINUX_CAPABILITY_VERSION_3, 0); StructCapUserData[] data; try &#123; data = Os.capget(header); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to capget()\", ex); &#125; //data[0].effectiveä¸ºå½“å‰çº¿ç¨‹æ‰€å¯ç”¨çš„ç‰¹æƒï¼Œdata[1].effectiveè²Œä¼¼ä¸º0 capabilities &amp;= ((long) data[0].effective) | (((long) data[1].effective) &lt;&lt; 32); //è®¾ç½®forkå‚æ•° String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,\" + \"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"--target-sdk-version=\" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, \"com.android.server.SystemServer\", &#125;; ZygoteArguments parsedArgs = null; int pid; try &#123; //è§£æè®¾ç½®çš„å‚æ•° parsedArgs = new ZygoteArguments(args); ... //è¿›ä¸€æ­¥è®¾ç½®å‚æ•° pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //SystemServerå­è¿›ç¨‹ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //å…³é—­zygote server socket zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null;&#125; Capabilitiesè¿™é‡Œéœ€è¦å…ˆäº†è§£ä¸€ä¸‹Linux Capabilitiesæœºåˆ¶ï¼šLinux Capabilitiesæœºåˆ¶ è¿™é‡Œå…ˆå®šä¹‰äº†SystemServerè¿›ç¨‹çš„Permittedå’ŒEffectiveèƒ½åŠ›é›†åˆ 123456789101112private static long posixCapabilitiesAsBits(int... capabilities) &#123; long result = 0; for (int capability : capabilities) &#123; //éæ³•capabilityï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸ if ((capability &lt; 0) || (capability &gt; OsConstants.CAP_LAST_CAP)) &#123; throw new IllegalArgumentException(String.valueOf(capability)); &#125; //ä¸ºæˆ–æ“ä½œï¼Œæ„å»ºcapabilitiesé›†åˆ result |= (1L &lt;&lt; capability); &#125; return result;&#125; æ£€æŸ¥ä¸€ä¸‹æœ‰æ— éæ³•capabilityï¼Œç„¶ååšä½æˆ–è¿ç®—ï¼Œæ„å»ºå‡ºä¸€ä¸ªcapabilitiesé›†åˆ ç„¶åé€šè¿‡Os.capgetæ–¹æ³•è·å–å½“å‰çº¿ç¨‹çš„capabilitiesé›†åˆï¼Œä¸Šä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å·²ç»åˆ†æè¿‡äº†Osçš„ä½œç”¨ï¼Œæœ€ç»ˆé€šè¿‡Linux_capgetJNIå‡½æ•°è°ƒç”¨Linuxcapgetå‡½æ•°ï¼Œé€šè¿‡è¿”å›å›æ¥çš„å€¼ï¼Œå‰”é™¤ä¸€äº›å½“å‰çº¿ç¨‹ä¸æ”¯æŒçš„ç‰¹æƒ Forkæ¥ç€è®¾ç½®ä¸€äº›forkå‚æ•°ï¼Œé€šè¿‡ZygoteArgumentså»è§£æå®ƒ ç„¶åè°ƒç”¨Zygote.forkSystemServeræ–¹æ³•ï¼Œè¿™ä¸ªå’Œä¸Šä¸€ç« é‡Œè¯´çš„fork Appçš„è¿‡ç¨‹å·®ä¸å¤š 123456789101112131415static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; //åœæ­¢å…¶ä»–çº¿ç¨‹ ZygoteHooks.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities); //è®¾ç½®é»˜è®¤çº¿ç¨‹ä¼˜å…ˆçº§ Thread.currentThread().setPriority(Thread.NORM_PRIORITY); //æ¢å¤å…¶ä»–çº¿ç¨‹ ZygoteHooks.postForkCommon(); return pid;&#125; å…ˆæŠŠå­çº¿ç¨‹éƒ½åœæ­¢æ‰ï¼Œforkå®Œåå†æ¢å¤ï¼Œè°ƒç”¨nativeå‡½æ•°nativeForkSystemServerï¼Œè·¯å¾„ä¸ºframeworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223242526272829303132333435363738static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) &#123; ... pid_t pid = ForkCommon(env, true, fds_to_close, fds_to_ignore, true); if (pid == 0) &#123; // System server prcoess does not need data isolation so no need to // know pkg_data_info_list. SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities, MOUNT_EXTERNAL_DEFAULT, nullptr, nullptr, true, false, nullptr, nullptr, /* is_top_app= */ false, /* pkg_data_info_list */ nullptr, /* whitelisted_data_info_list */ nullptr, false, false); &#125; else if (pid &gt; 0) &#123; ... gSystemServerPid = pid; //æ£€æŸ¥SystemServerè¿›ç¨‹çŠ¶æ€ int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //å¦‚æœSystemServerè¿›ç¨‹æ­»äº¡ï¼Œé‡å¯æ•´ä¸ªZygote ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\"); &#125; //å¦‚æœæ˜¯ä½å†…å­˜è®¾å¤‡ï¼Œé™åˆ¶SystemServerè¿›ç¨‹ä½¿ç”¨å†…å­˜å¤§å° if (UsePerAppMemcg()) &#123; if (!SetTaskProfiles(pid, std::vector&lt;std::string&gt;&#123;\"SystemMemoryProcess\"&#125;)) &#123; ALOGE(\"couldn't add process %d into system memcg group\", pid); &#125; &#125; &#125; return pid;&#125; ForkCommonæˆ‘ä»¬å…ˆçœ‹ForkCommonå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static pid_t ForkCommon(JNIEnv* env, bool is_system_server, const std::vector&lt;int&gt;&amp; fds_to_close, const std::vector&lt;int&gt;&amp; fds_to_ignore, bool is_priority_fork) &#123; //è®¾ç½®å­è¿›ç¨‹ä¿¡å·å¤„ç†å™¨ SetSignalHandlers(); //C++ä¸­çš„ä¸€ç§å¯è°ƒç”¨å¯¹è±¡ï¼ŒZygoteFailureå‡½æ•°æ¥æ”¶4ä¸ªå‚æ•°ï¼Œå‰ä¸‰ä¸ªå‚æ•°éƒ½å·²æä¾›ï¼Œæœ€åä¸€ä¸ªå‚æ•°å ä½ç­‰å¾…è°ƒç”¨æ–¹å¡«å…¥ auto fail_fn = std::bind(ZygoteFailure, env, is_system_server ? \"system_server\" : \"zygote\", nullptr, _1); //åœ¨forkæœŸé—´é˜»å¡ä½SIGCHLDä¿¡å·ï¼Œé¿å…åœ¨SIGCHLDä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰“å°logï¼Œå¯¼è‡´åé¢å…³é—­çš„æ—¥å¿—fdé‡æ–°è¢«æ‰“å¼€ BlockSignal(SIGCHLD, fail_fn); //å…³é—­æ‰€æœ‰æ—¥å¿—ç›¸å…³fd __android_log_close(); AStatsSocket_close(); //SystemServeræ˜¯Zygoteè¿›ç¨‹èµ·æ¥åç¬¬ä¸€ä¸ªforkçš„å‡ºæ¥è¿›ç¨‹ï¼Œåˆ›å»ºæ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ if (gOpenFdTable == nullptr) &#123; gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn); &#125; else &#123; gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn); &#125; android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level(); //ç«‹å³æ¸…é™¤ä»»ä½•æœªä½¿ç”¨çš„å†…å­˜ mallopt(M_PURGE, 0); pid_t pid = fork(); if (pid == 0) &#123; //fork SystemServeræ—¶ï¼Œæ­¤å‚æ•°ä¸ºtrue if (is_priority_fork) &#123; //è®¾ç½®æœ€é«˜è¿›ç¨‹ä¼˜å…ˆçº§ setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MAX); &#125; else &#123; setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MIN); &#125; // The child process. PreApplicationInit(); //æ¸…é™¤æ‰€æœ‰éœ€è¦ç«‹å³å…³é—­çš„fd DetachDescriptors(env, fds_to_close, fail_fn); //USAPæœºåˆ¶æˆ‘ä»¬ç°åœ¨ä¸å…³æ³¨ ClearUsapTable(); //é‡æ–°æ‰“å¼€å‰©ä½™æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œé¿å…æ–‡ä»¶æè¿°ç¬¦é€šè¿‡forkåœ¨SystemServerå’ŒZygoteä¹‹é—´å…±äº« gOpenFdTable-&gt;ReopenOrDetach(fail_fn); //Sanitizeræœºåˆ¶ï¼Œç”¨æ¥æ£€æµ‹ç¨‹åºå¼‚å¸¸ android_fdsan_set_error_level(fdsan_error_level); // Reset the fd to the unsolicited zygote socket gSystemServerSocketFd = -1; &#125; else &#123; ALOGD(\"Forked child process %d\", pid); &#125; //å–æ¶ˆä¹‹å‰é˜»å¡çš„SIGCHLDä¿¡å· UnblockSignal(SIGCHLD, fail_fn); return pid;&#125; å¤„ç†å­è¿›ç¨‹ä¿¡å·å…ˆè®¾ç½®å­è¿›ç¨‹ä¿¡å·å¤„ç†å™¨ 12345678910111213static void SetSignalHandlers() &#123; struct sigaction sig_chld = &#123;.sa_flags = SA_SIGINFO, .sa_sigaction = SigChldHandler&#125;; if (sigaction(SIGCHLD, &amp;sig_chld, nullptr) &lt; 0) &#123; ALOGW(\"Error setting SIGCHLD handler: %s\", strerror(errno)); &#125; struct sigaction sig_hup = &#123;&#125;; sig_hup.sa_handler = SIG_IGN; if (sigaction(SIGHUP, &amp;sig_hup, nullptr) &lt; 0) &#123; ALOGW(\"Error setting SIGHUP handler: %s\", strerror(errno)); &#125;&#125; å…³äºä¿¡å·çš„å¤„ç†ï¼Œæˆ‘ä»¬åœ¨Androidæºç åˆ†æ - initè¿›ç¨‹ä¸­å·²ç»äº†è§£è¿‡ä¸€æ¬¡ï¼ŒSA_SIGINFOè¿™ä¸ªflagä»£è¡¨è°ƒç”¨ä¿¡å·å¤„ç†å‡½æ•°sa_sigactionçš„æ—¶å€™ï¼Œä¼šå°†ä¿¡å·çš„ä¿¡æ¯é€šè¿‡å‚æ•°siginfo_tä¼ å…¥ SIGHUPè¡¨ç¤ºç»ˆç«¯æ–­å¼€ä¿¡å·ï¼ŒSIG_IGNè¡¨ç¤ºå¿½ç•¥ä¿¡å·ï¼Œå³å¿½ç•¥ç»ˆç«¯æ–­å¼€ä¿¡å· æˆ‘ä»¬çœ‹ä¸€ä¸‹Zygoteæ˜¯æ€ä¹ˆå¤„ç†å…¶å­è¿›ç¨‹ä¿¡å·çš„ 1234567891011121314151617181920static void SigChldHandler(int /*signal_number*/, siginfo_t* info, void* /*ucontext*/) &#123; pid_t pid; int status; ... int saved_errno = errno; while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123; //é€šçŸ¥SystemServerï¼ŒZygoteæ”¶åˆ°äº†ä¸€ä¸ªSIGCHLDä¿¡å· sendSigChildStatus(pid, info-&gt;si_uid, status); ... //æ‰“å°å­è¿›ç¨‹çŠ¶æ€æ—¥å¿— //å¦‚æœå´©æºƒçš„è¿›ç¨‹æ˜¯SystemServerï¼Œæ•´ä¸ªZygoteéƒ½ä¼šé€€å‡ºï¼Œå†é€šè¿‡initè¿›ç¨‹é‡å¯ if (pid == gSystemServerPid) &#123; async_safe_format_log(ANDROID_LOG_ERROR, LOG_TAG, \"Exit zygote because system server (pid %d) has terminated\", pid); kill(getpid(), SIGKILL); &#125; &#125; ... errno = saved_errno;&#125; å¦‚æœæ£€æµ‹åˆ°æœ‰å­è¿›ç¨‹é€€å‡ºï¼Œé€šçŸ¥SystemServerï¼Œå¦‚æœè¿™ä¸ªè¿›ç¨‹æ˜¯SystemServerè¿›ç¨‹ï¼Œæ€æ‰Zygoteè¿›ç¨‹é‡å¯ ZygoteFailureè¿™é‡Œå…ˆéœ€è¦ç†è§£ä¸€ä¸‹C++11 ä¸­çš„std::functionå’Œstd::bind ç®€å•æ¥è¯´ï¼Œstd::bindè¿”å›äº†ä¸€ä¸ªstd::functionå¯¹è±¡ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼Œå®é™…è°ƒç”¨çš„å°±æ˜¯ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼šZygoteFailureå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¥å—4ä¸ªå‚æ•°ï¼Œå‰ä¸‰ä¸ªå‚æ•°éƒ½åœ¨std::bindæ—¶æä¾›å¥½äº†ï¼Œç¬¬å››ä¸ªå‚æ•°ä»¥_1å ä½ç¬¦æ›¿ä»£ï¼ˆstd::placeholders::_1ï¼‰ å®é™…ä¸Šè°ƒç”¨fail_fn(msg)å°±ç›¸å½“äºè°ƒç”¨å‡½æ•°ZygoteFailure(env, &quot;system_server&quot;, nullptr, msg) 123456789101112131415161718static void ZygoteFailure(JNIEnv* env, const char* process_name, jstring managed_process_name, const std::string&amp; msg) &#123; std::unique_ptr&lt;ScopedUtfChars&gt; scoped_managed_process_name_ptr = nullptr; if (managed_process_name != nullptr) &#123; scoped_managed_process_name_ptr.reset(new ScopedUtfChars(env, managed_process_name)); if (scoped_managed_process_name_ptr-&gt;c_str() != nullptr) &#123; process_name = scoped_managed_process_name_ptr-&gt;c_str(); &#125; &#125; const std::string&amp; error_msg = (process_name == nullptr) ? msg : StringPrintf(\"(%s) %s\", process_name, msg.c_str()); //æŠ›å‡ºå¼‚å¸¸ env-&gt;FatalError(error_msg.c_str()); __builtin_unreachable();&#125; å½“å‘ç”Ÿé”™è¯¯åï¼Œæœ€ç»ˆå‘Javaå±‚æŠ›å‡ºäº†ä¸€ä¸ªå¼‚å¸¸ BlockSignal &amp; UnblockSignalåœ¨forkæœŸé—´éœ€è¦é˜»å¡ä½SIGCHLDä¿¡å·ï¼Œé¿å…åœ¨SIGCHLDä¿¡å·å¤„ç†å‡½æ•°ä¸­æ‰“å°logï¼Œå¯¼è‡´åé¢å…³é—­çš„æ—¥å¿—fdé‡æ–°è¢«æ‰“å¼€ 123456789static void BlockSignal(int signum, fail_fn_t fail_fn) &#123; sigset_t sigs; sigemptyset(&amp;sigs); sigaddset(&amp;sigs, signum); if (sigprocmask(SIG_BLOCK, &amp;sigs, nullptr) == -1) &#123; fail_fn(CREATE_ERROR(\"Failed to block signal %s: %s\", strsignal(signum), strerror(errno))); &#125;&#125; ç­‰forkç»“æŸï¼Œå–æ¶ˆé˜»å¡SIGCHLDä¿¡å· 123456789static void UnblockSignal(int signum, fail_fn_t fail_fn) &#123; sigset_t sigs; sigemptyset(&amp;sigs); sigaddset(&amp;sigs, signum); if (sigprocmask(SIG_UNBLOCK, &amp;sigs, nullptr) == -1) &#123; fail_fn(CREATE_ERROR(\"Failed to un-block signal %s: %s\", strsignal(signum), strerror(errno))); &#125;&#125; ä¿¡å·é›†å‡½æ•°æˆ‘ä»¬ä¹‹å‰å·²ç»åœ¨Androidæºç åˆ†æ - initè¿›ç¨‹ä¸­ä»‹ç»è¿‡äº†ï¼Œå¾ˆç®€å•ï¼Œå°±æ˜¯å°†SIGCHLDä¿¡å·æ·»åŠ åˆ°å±è”½é›†ä¸­ï¼Œforkå®Œåå†å°†è¿™ä¸ªä¿¡å·ä»å±è”½é›†ä¸­ç§»é™¤ SpecializeCommonè‡³æ­¤ï¼Œforkæ“ä½œç»“æŸï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹åœ¨SystemServerè¿›ç¨‹ä¸­æ‰§è¡Œçš„SpecializeCommonå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities, jint mount_external, jstring managed_se_info, jstring managed_nice_name, bool is_system_server, bool is_child_zygote, jstring managed_instruction_set, jstring managed_app_data_dir, bool is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, bool mount_data_dirs, bool mount_storage_dirs) &#123; //process_name = \"system_server\" const char* process_name = is_system_server ? \"system_server\" : \"zygote\"; auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1); auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1); //å‡ä¸ºnullptr auto se_info = extract_fn(managed_se_info); auto nice_name = extract_fn(managed_nice_name); auto instruction_set = extract_fn(managed_instruction_set); auto app_data_dir = extract_fn(managed_app_data_dir); //å½“UIDå‘ç”Ÿæ”¹å˜æ—¶ï¼ˆroot-&gt;érootï¼‰ä¿ç•™capabilities if (uid != 0) &#123; EnableKeepCapabilities(fail_fn); &#125; //è®¾ç½®Inheritableé›†åˆ SetInheritable(permitted_capabilities, fail_fn); //ä»Boundingé›†åˆä¸­ç§»é™¤è°ƒç”¨çº¿ç¨‹ç›¸å…³èƒ½åŠ› DropCapabilitiesBoundingSet(fail_fn); ... //åˆ›å»ºç§æœ‰æŒ‚è½½å‘½åç©ºé—´ï¼ŒæŒ‚è½½è™šæ‹Ÿå­˜å‚¨ MountEmulatedStorage(uid, mount_external, need_pre_initialize_native_bridge, fail_fn); ... //è®¾ç½®GroupId SetGids(env, gids, is_child_zygote, fail_fn); //è®¾ç½®èµ„æºLimit SetRLimits(env, rlimits, fail_fn); ... //è®¾ç½®gidåŠè®¿é—®æƒé™ if (setresgid(gid, gid, gid) == -1) &#123; fail_fn(CREATE_ERROR(\"setresgid(%d) failed: %s\", gid, strerror(errno))); &#125; //capabilitiesé›†åˆä¸­ä»ç„¶å­˜åœ¨CAP_SYS_ADMINï¼Œéœ€è¦è¿‡æ»¤ç³»ç»Ÿè°ƒç”¨ SetUpSeccompFilter(uid, is_child_zygote); //è®¾ç½®è°ƒåº¦ç­–ç•¥ SetSchedulerPolicy(fail_fn, is_top_app); //è®¾ç½®uidåŠè®¿é—®æƒé™ if (setresuid(uid, uid, uid) == -1) &#123; fail_fn(CREATE_ERROR(\"setresuid(%d) failed: %s\", uid, strerror(errno))); &#125; ... //è®¾ç½®Capabilities SetCapabilities(permitted_capabilities, effective_capabilities, permitted_capabilities, fail_fn); //å…³é—­æ‰€æœ‰æ—¥å¿—ç›¸å…³fd __android_log_close(); AStatsSocket_close(); ... //è®¾ç½®çº¿ç¨‹å if (nice_name.has_value()) &#123; SetThreadName(nice_name.value()); &#125; else if (is_system_server) &#123; //nice_nameä¸ºnullptr, è¿›å…¥æ­¤åˆ†æ”¯ SetThreadName(\"system_server\"); &#125; //å–æ¶ˆæ‰ä¹‹å‰è®¾ç½®çš„SIGCHIDä¿¡å·å¤„ç†å‡½æ•° UnsetChldSignalHandler(); if (is_system_server) &#123; //è°ƒç”¨ZygoteHooks.postForkSystemServer(runtime_flags); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork system server hooks.\"); &#125; ... &#125; ... //è°ƒç”¨ZygoteHooks.postForkChild(runtime_flags, true, false, null); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set); //è®¾ç½®é»˜è®¤è¿›ç¨‹ä¼˜å…ˆçº§ setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_DEFAULT); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork hooks.\"); &#125;&#125; è¿™é‡Œåšäº†å¾ˆå¤šå·¥ä½œï¼Œæœ‰Capabilitiesç›¸å…³ï¼Œselinuxç›¸å…³ï¼Œæƒé™ç›¸å…³ç­‰ç­‰ï¼Œæœ‰ç‚¹å¤ªå¤šäº†ï¼Œæˆ‘æ ‡äº†æ³¨é‡Šï¼Œå°±ä¸å†ä¸€ä¸€åˆ†æäº† æ¥ä¸‹æ¥å›åˆ°nativeForkSystemServerä¸­ï¼Œåœ¨Zygoteè¿›ç¨‹ä¸­ç»§ç»­æ‰§è¡Œ 123456789101112131415161718192021222324252627static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) &#123; ... if (pid == 0) &#123; ... &#125; else if (pid &gt; 0) &#123; ... gSystemServerPid = pid; //æ£€æŸ¥SystemServerè¿›ç¨‹çŠ¶æ€ int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //å¦‚æœSystemServerè¿›ç¨‹æ­»äº¡ï¼Œé‡å¯æ•´ä¸ªZygote ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\"); &#125; //å¦‚æœæ˜¯ä½å†…å­˜è®¾å¤‡ï¼Œé™åˆ¶SystemServerè¿›ç¨‹ä½¿ç”¨å†…å­˜å¤§å° if (UsePerAppMemcg()) &#123; if (!SetTaskProfiles(pid, std::vector&lt;std::string&gt;&#123;\"SystemMemoryProcess\"&#125;)) &#123; ALOGE(\"couldn't add process %d into system memcg group\", pid); &#125; &#125; &#125; return pid;&#125; é€šè¿‡Linuxå‡½æ•°waitpidæ£€æŸ¥SystemServerè¿›ç¨‹çŠ¶æ€ï¼Œè¿™ä¸ªå‡½æ•°å’Œä¹‹å‰åœ¨Androidæºç åˆ†æ - initè¿›ç¨‹ä¸­æè¿‡çš„waitidå‡½æ•°ç±»ä¼¼ï¼ŒWNOHANGè¡¨ç¤ºéé˜»å¡ç­‰å¾… å¦‚æœSystemServerè¿›ç¨‹æ­»äº¡ï¼Œé‡å¯æ•´ä¸ªZygote 12345678910111213141516private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... //SystemServerå­è¿›ç¨‹ if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //å…³é—­zygote server socket zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null;&#125; cgroupså¦‚æœæ˜¯å°å†…å­˜è®¾å¤‡ï¼Œä½¿ç”¨Linuxçš„cgroupsæœºåˆ¶ï¼Œé™åˆ¶SystemServerè¿›ç¨‹ä½¿ç”¨å†…å­˜å¤§å° 1234bool UsePerAppMemcg() &#123; bool low_ram_device = GetBoolProperty(\"ro.config.low_ram\", false); return GetBoolProperty(\"ro.config.per_app_memcg\", low_ram_device);&#125; å…³äºLinuxçš„cgroupsæœºåˆ¶ï¼Œå¯ä»¥æŸ¥çœ‹è¿™ç¯‡æ–‡æ¡£ï¼šcgroups(7) â€” Linux manual page å…³äºAndroidçš„Cgroupsæœºåˆ¶ï¼Œå¯ä»¥çœ‹è¿™ç¯‡å®˜æ–¹æ–‡æ¡£ï¼šCgroup æŠ½è±¡å±‚ è¿è¡Œåˆå§‹åŒ–12345678910111213141516171819202122232425262728293031private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123; //å°†umaskè®¾ç½®ä¸º0077ï¼Œè¿™æ ·æ–°çš„æ–‡ä»¶å’Œç›®å½•å°†é»˜è®¤ä¸ºä»…å±äºæ‰€æœ‰è€…çš„æƒé™ Os.umask(S_IRWXG | S_IRWXO); //è®¾ç½®è¿›ç¨‹å if (parsedArgs.mNiceName != null) &#123; Process.setArgV0(parsedArgs.mNiceName); &#125; //å¯¹classpathä¸­çš„apkï¼Œåˆ†åˆ«è¿›è¡Œdexä¼˜åŒ–æ“ä½œï¼Œç”±installdçœŸæ­£æ‰§è¡Œ final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); ... &#125; if (parsedArgs.mInvokeWith != null) &#123; ... &#125; else &#123; //SystemServerè¿›å…¥è¿™ä¸ªåˆ†æ”¯ ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); &#125;&#125; å¤„ç†ä¸€äº›åˆå§‹åŒ–æ“ä½œï¼Œç„¶åè°ƒç”¨ZygoteInit.zygoteInitæ–¹æ³• 12345678910public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... //é€šç”¨åˆå§‹åŒ– RuntimeInit.commonInit(); //å¼€å¯binderçº¿ç¨‹æ±  ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);&#125; RuntimeInitçš„è·¯å¾„ä¸ºframeworks/base/core/java/com/android/internal/os/RuntimeInit.javaï¼Œå…ˆæ‰§è¡Œé€šç”¨åˆå§‹åŒ– 12345678910111213141516171819202122protected static final void commonInit() &#123; //è®¾ç½®é»˜è®¤çº¿ç¨‹å¼‚å¸¸å¤„ç†å™¨ LoggingHandler loggingHandler = new LoggingHandler(); RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler); Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); //è®¾ç½®æ—¶åŒº RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(\"persist.sys.timezone\")); //é‡ç½®Logé…ç½® LogManager.getLogManager().reset(); new AndroidConfig(); //è®¾ç½®ç½‘ç»œUAä¿¡æ¯ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); //åˆå§‹åŒ–ç½‘ç»œæµé‡ç»Ÿè®¡ NetworkManagementSocketTagger.install(); ... initialized = true;&#125; æ¥ç€æ‰§è¡ŒRuntimeInit.applicationInit 12345678910111213protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; //å¦‚æœåº”ç”¨ç¨‹åºè°ƒç”¨System.exit()ï¼Œåˆ™ç«‹å³ç»ˆæ­¢è¯¥è¿›ç¨‹ï¼Œä¸è¿è¡Œä»»ä½•hookå‡½æ•° nativeSetExitWithoutCleanup(true); //è®¾ç½®è™šæ‹Ÿæœºå‚æ•° VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges); //è§£æå‚æ•° final Arguments args = new Arguments(argv); ... //æŸ¥æ‰¾startClassä¸­çš„mainæ–¹æ³• return findStaticMain(args.startClass, args.startArgs, classLoader);&#125; å‚æ•°è§£ææˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒæ˜¯æ€ä¹ˆè§£æå‚æ•°çš„ 1234567891011121314151617181920212223242526Arguments(String args[]) throws IllegalArgumentException &#123; parseArgs(args);&#125;private void parseArgs(String args[]) throws IllegalArgumentException &#123; int curArg = 0; for (; curArg &lt; args.length; curArg++) &#123; String arg = args[curArg]; if (arg.equals(\"--\")) &#123; curArg++; break; &#125; else if (!arg.startsWith(\"--\")) &#123; break; &#125; &#125; if (curArg == args.length) &#123; throw new IllegalArgumentException(\"Missing classname argument to RuntimeInit!\"); &#125; startClass = args[curArg++]; startArgs = new String[args.length - curArg]; System.arraycopy(args, curArg, startArgs, 0, startArgs.length);&#125; å¾ªç¯è¯»å‚æ•°ç›´åˆ°æœ‰ä¸€é¡¹å‚æ•°ä¸ºâ€â€“â€æˆ–è€…ä¸ä»¥â€â€“â€å¼€å¤´ï¼Œç„¶åä»¥ä¸‹ä¸€ä¸ªå‚æ•°ä½œä¸ºstartClassï¼Œç”¨å†ä¸‹ä¸€ä¸ªå‚æ•°åˆ°argsæ•°ç»„ç»“å°¾ç”Ÿæˆä¸€ä¸ªæ–°çš„æ•°ç»„ä½œä¸ºstartArgsï¼Œæˆ‘ä»¬è§‚å¯Ÿä¸€ä¸‹forkSystemServeræ–¹æ³•ä¸­è®¾ç½®çš„args 1234567891011String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,\" + \"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"--target-sdk-version=\" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, \"com.android.server.SystemServer\", &#125;; å¯ä»¥çœ‹å‡ºï¼ŒstartClassåº”è¯¥ä¸ºcom.android.server.SystemServerï¼ŒstartArgsæ•°ç»„ä¸ºç©º åå°„æ‰§è¡Œæ¥ç€è°ƒç”¨findStaticMainæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv);&#125; è¿™é‡Œä½¿ç”¨äº†Javaä¸­çš„åå°„ï¼Œæ‰¾åˆ°äº†SystemServerä¸­å¯¹åº”çš„mainæ–¹æ³•ï¼Œå¹¶ç”¨å…¶åˆ›å»ºäº†ä¸€ä¸ªRunnableå¯¹è±¡MethodAndArgsCaller 1234567891011121314151617181920212223242526static class MethodAndArgsCaller implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; //æ‰§è¡ŒSystemServer.mainæ–¹æ³• mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; æˆ‘ä»¬æœ€åå†å›åˆ°ZygoteInitçš„mainæ–¹æ³•ä¸­ 1234567891011121314public static void main(String argv[]) &#123; ... //å¯åŠ¨SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); //å­è¿›ç¨‹ä¸­æ‰ä¼šæ»¡è¶³r != null if (r != null) &#123; //æ­¤æ—¶æ‰§è¡Œè¿™ä¸ªRunnable r.run(); return; &#125; &#125;&#125; æ‰§è¡Œè¿™ä¸ªåœ¨å­è¿›ç¨‹ä¸­è¿”å›å‡ºå»çš„Runnableï¼šMethodAndArgsCallerï¼Œåå°„è°ƒç”¨SystemServer.mainæ–¹æ³• ç»“æŸè‡³æ­¤ï¼ŒSystemServerçš„å¯åŠ¨æˆ‘ä»¬å°±åˆ†æå®Œäº†ï¼Œä¸‹ä¸€ç¯‡æˆ‘ä»¬å°†åˆ†æSystemServerå¯åŠ¨ååšäº†ä»€ä¹ˆ","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"}]},{"title":"Linux Capabilitiesæœºåˆ¶","slug":"linux/LinuxCapabilitiesæœºåˆ¶","date":"2022-01-14T05:43:00.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2022/01/14/linux/LinuxCapabilitiesæœºåˆ¶/","link":"","permalink":"http://yoursite.com/2022/01/14/linux/LinuxCapabilities%E6%9C%BA%E5%88%B6/","excerpt":"","text":"ä»‹ç»ä¼ ç»Ÿçš„Linuxæƒé™æ§åˆ¶ç²’åº¦å¤ªç²—ï¼Œä»¥passwdå‘½ä»¤ä¸ºä¾‹ï¼Œä¿®æ”¹ç”¨æˆ·å¯†ç æ˜¯éœ€è¦rootæƒé™çš„ï¼Œä½†æ™®é€šç”¨æˆ·åº”è¯¥æ˜¯èƒ½å¤Ÿä¿®æ”¹è‡ªå·±å¯†ç çš„æ‰å¯¹ï¼Œè¿™æ—¶å€™Linuxå°±ä½¿ç”¨äº†SUIDã€EUIDæœºåˆ¶ï¼Œä½¿passwdè¿›ç¨‹ä»¥å®ƒçš„æ‰€æœ‰è€…rootæƒé™è¿è¡Œè¿™æ ·å°±å¯ä»¥ä»¥rootæƒé™ä¿®æ”¹å¯†ç äº† SUIDæœºåˆ¶æ˜¯æœ‰å®‰å…¨éšæ‚£çš„ï¼Œpasswdè¿›ç¨‹åªéœ€è¦ä¿®æ”¹å¯†ç çš„å°±å¯ä»¥äº†ï¼Œå´åœ¨æ•´ä¸ªè¿è¡Œå‘¨æœŸå†…è·å¾—äº†rootæƒé™ï¼Œä¸€æ—¦å‡ºç°æ¼æ´ï¼Œå¾ˆæœ‰å¯èƒ½ä¼šè¢«åˆ©ç”¨ æ‰€ä»¥ï¼ŒLinuxå†…æ ¸åœ¨2.2åå¼•å…¥äº†Capabilitiesæœºåˆ¶ï¼Œç»†ç²’åº¦åŒ–äº†æƒé™æ§åˆ¶ï¼Œå¯ä»¥åšåˆ°æŒ‰éœ€æˆæƒ è¿™é‡Œæ˜¯æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man7/capabilities.7.html å¦‚ä½•ä½¿ç”¨é¦–å…ˆï¼ŒCapabilitiesæ˜¯æœ‰ä¸€ä¸ªé›†åˆçš„æ¦‚å¿µçš„ï¼Œå³ä¸€ä¸ªè¿›ç¨‹æˆ–å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå®ƒå¯ä»¥æ‹¥æœ‰å“ªäº›ç‰¹æƒçš„é›†åˆ å¯æ‰§è¡Œæ–‡ä»¶å¯æ‰§è¡Œæ–‡ä»¶æœ‰ä¸‰ç§Capabilitiesé›†åˆï¼š Permittedå½“æ–‡ä»¶æ‰§è¡Œæ—¶ï¼Œè¿™ä¸ªé›†åˆçš„å†…å®¹ä¼šè¢«æ·»åŠ åˆ°è¿›ç¨‹çš„Permittedé›†åˆä¸­ Inheritableå½“æ–‡ä»¶æ‰§è¡Œåï¼Œè¿™ä¸ªé›†åˆä¼šä¸è¿›ç¨‹çš„Inheritableé›†åˆåšä½ä¸æ“ä½œ(&amp;)ï¼Œä»¥ç¡®å®šè¿›ç¨‹åœ¨æ‰§è¡Œexecveå‡½æ•°åå“ªäº›capabiliteså¯ä»¥è¢«ç»§æ‰¿ Effectiveè¿™ä¸æ˜¯ä¸€ä¸ªé›†åˆï¼Œè€Œæ˜¯ä¸€ä¸ªä½(bit)ï¼Œå¦‚æœæ­¤bitè®¾ä¸º1ï¼Œåˆ™Permittedé›†åˆä¸­æ–°å¢çš„capabilitesä¼šåœ¨æ‰§è¡Œexecveå‡½æ•°åæ·»åŠ åˆ°è¿›ç¨‹çš„Effectiveé›†åˆä¸­ å‘½ä»¤ è®¾ç½®capabilites 12345setcap [capability,capability,...]+[ep] [æ–‡ä»¶]# orsetcap [capability+ep capability+ep ...] [æ–‡ä»¶] capabilityå°±æ˜¯æŸä¸ªç‰¹æƒå€¼ï¼Œ+epä»£è¡¨åŠ å…¥Effectiveå’ŒPermittedé›†åˆä¸­ è·å–capabilites 1getcap [æ–‡ä»¶] çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰çº¿ç¨‹ï¼ˆè¿›ç¨‹ï¼‰æœ‰äº”ç§Capabilitiesé›†åˆï¼š Permittedè¿™ä¸ªé›†åˆå®šä¹‰äº†çº¿ç¨‹æ‰€èƒ½å¤Ÿæ‹¥æœ‰çš„ç‰¹æƒçš„ä¸Šé™ï¼Œæ˜¯Inheritableå’ŒEffectiveé›†åˆçš„çš„è¶…é›† InheritableåŒ…å«äº†å½“æ‰§è¡Œexecve å‡½æ•°æ—¶ï¼Œèƒ½å¤Ÿè¢«æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶ç»§æ‰¿çš„capabilitiesï¼ˆæ‰§è¡Œexecve å‡½æ•°åä¼šè¢«æ·»åŠ åˆ°Permittedé›†åˆä¸­ï¼‰ Effectiveå†…æ ¸æ£€æŸ¥ç‰¹æƒæ“ä½œæ—¶ï¼Œå®é™…æ£€æŸ¥çš„é›†åˆï¼ˆå¯ä»¥é€šè¿‡æ‰§è¡Œæ“ä½œå‰å¢/åˆ Effectiveä¸­çš„capabilitiesï¼Œä»¥è¾¾åˆ°ä¸´æ—¶å¼€/å…³æƒé™çš„åŠŸèƒ½ï¼‰ Bounding (å†…æ ¸2.6.25ä»¥å)è¿™ä¸ªé›†åˆæ˜¯ Inheritable é›†åˆçš„è¶…é›†ï¼Œå¦‚æœæŸä¸ªcapabilityä¸åœ¨Boundingé›†åˆä¸­ï¼Œå³ä½¿å®ƒåœ¨Permittedé›†åˆä¸­ï¼Œè¯¥çº¿ç¨‹ä¹Ÿä¸èƒ½å°†è¯¥capabilityæ·»åŠ åˆ°å®ƒçš„Inheritableé›†åˆä¸­ï¼Œè¯¥é›†åˆåœ¨execveåä¸å¯å†æ·»åŠ capabilities Ambient (å†…æ ¸4.3ä»¥å)è¿™ä¸ªé›†åˆæ˜¯Permittedå’ŒInheritableçš„å­é›†ï¼Œå½“Permittedå’ŒInheritableåˆ é™¤æŸä¸ªcapabilityæ—¶ï¼Œä¹Ÿä¼šè‡ªåŠ¨åˆ é™¤è¯¥é›†åˆä¸­å¯¹åº”çš„capabilityï¼Œå­è¿›ç¨‹ä¼šè‡ªåŠ¨ç»§æ‰¿è¿™ä¸ªé›†åˆä¸­çš„capabilitiesï¼Œå­è¿›ç¨‹çš„Permittedã€Effectiveå’ŒAmbientéƒ½ä¼šæ‹¥æœ‰è¿™äº›capabilities å‡½æ•°capsetåŸå‹ï¼š 1int capset(cap_user_header_t hdrp, const cap_user_data_t datap); æ–‡æ¡£ï¼šhttps://linux.die.net/man/2/capset capgetåŸå‹ï¼š 1int capget(cap_user_header_t hdrp , cap_user_data_t datap); æ–‡æ¡£ï¼šhttps://linux.die.net/man/2/capget ç»“æ„ä½“12345678910typedef struct __user_cap_header_struct &#123; __u32 version; int pid; &#125; *cap_user_header_t;typedef struct __user_cap_data_struct &#123; __u32 effective; __u32 permitted; __u32 inheritable; &#125; *cap_user_data_t; è®¡ç®—å…¬å¼æˆ‘ä»¬ç”¨ P ä»£è¡¨æ‰§è¡Œ execve() å‰çº¿ç¨‹çš„ capabilitiesï¼ŒP&#39; ä»£è¡¨æ‰§è¡Œ execve() åçº¿ç¨‹çš„ capabilitiesï¼ŒF ä»£è¡¨å¯æ‰§è¡Œæ–‡ä»¶çš„ capabilitiesï¼Œé‚£ä¹ˆï¼š Pâ€™(ambient) = (file is privileged) ? 0 : P(ambient) Pâ€™(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding))) | Pâ€™(ambient) Pâ€™(effective) = F(effective) ? Pâ€™(permitted) : Pâ€™(ambient) Pâ€™(inheritable) = P(inheritable) [i.e., unchanged] Pâ€™(bounding) = P(bounding) [i.e., unchanged] æˆ‘ä»¬ä¸€æ¡ä¸€æ¡æ¥è§£é‡Šï¼š å¦‚æœç”¨æˆ·æ˜¯ root ç”¨æˆ·ï¼Œé‚£ä¹ˆæ‰§è¡Œ execve() åçº¿ç¨‹çš„ Ambient é›†åˆæ˜¯ç©ºé›†ï¼›å¦‚æœæ˜¯æ™®é€šç”¨æˆ·ï¼Œé‚£ä¹ˆæ‰§è¡Œ execve() åçº¿ç¨‹çš„ Ambient é›†åˆå°†ä¼šç»§æ‰¿æ‰§è¡Œ execve() å‰çº¿ç¨‹çš„ Ambient é›†åˆã€‚ æ‰§è¡Œ execve() å‰çº¿ç¨‹çš„ Inheritable é›†åˆä¸å¯æ‰§è¡Œæ–‡ä»¶çš„ Inheritable é›†åˆå–äº¤é›†ï¼Œä¼šè¢«æ·»åŠ åˆ°æ‰§è¡Œ execve() åçº¿ç¨‹çš„ Permitted é›†åˆï¼›å¯æ‰§è¡Œæ–‡ä»¶çš„ capability bounding é›†åˆä¸å¯æ‰§è¡Œæ–‡ä»¶çš„ Permitted é›†åˆå–äº¤é›†ï¼Œä¹Ÿä¼šè¢«æ·»åŠ åˆ°æ‰§è¡Œ execve() åçº¿ç¨‹çš„ Permitted é›†åˆï¼›åŒæ—¶æ‰§è¡Œ execve() åçº¿ç¨‹çš„ Ambient é›†åˆä¸­çš„ capabilities ä¼šè¢«è‡ªåŠ¨æ·»åŠ åˆ°è¯¥çº¿ç¨‹çš„ Permitted é›†åˆä¸­ã€‚ å¦‚æœå¯æ‰§è¡Œæ–‡ä»¶å¼€å¯äº† Effective æ ‡å¿—ä½ï¼Œé‚£ä¹ˆåœ¨æ‰§è¡Œå®Œ execve() åï¼Œçº¿ç¨‹ Permitted é›†åˆä¸­çš„ capabilities ä¼šè‡ªåŠ¨æ·»åŠ åˆ°å®ƒçš„ Effective é›†åˆä¸­ã€‚ æ‰§è¡Œ execve() å‰çº¿ç¨‹çš„ Inheritable é›†åˆä¼šç»§æ‰¿ç»™æ‰§è¡Œ execve() åçº¿ç¨‹çš„ Inheritable é›†åˆã€‚ è¿™é‡Œæœ‰å‡ ç‚¹éœ€è¦ç€é‡å¼ºè°ƒï¼š ä¸Šé¢çš„å…¬å¼æ˜¯é’ˆå¯¹ç³»ç»Ÿè°ƒç”¨ execve() çš„ï¼Œå¦‚æœæ˜¯ fork()ï¼Œé‚£ä¹ˆå­çº¿ç¨‹çš„ capabilities ä¿¡æ¯å®Œå…¨å¤åˆ¶çˆ¶è¿›ç¨‹çš„ capabilities ä¿¡æ¯ã€‚ å¯æ‰§è¡Œæ–‡ä»¶çš„ Inheritable é›†åˆä¸çº¿ç¨‹çš„ Inheritable é›†åˆå¹¶æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œå¯æ‰§è¡Œæ–‡ä»¶ Inheritable é›†åˆä¸­çš„ capabilities ä¸ä¼šè¢«æ·»åŠ åˆ°æ‰§è¡Œ execve() åçº¿ç¨‹çš„ Inheritable é›†åˆä¸­ã€‚å¦‚æœæƒ³è®©æ–°çº¿ç¨‹çš„ Inheritable é›†åˆåŒ…å«æŸä¸ª capabilityï¼Œåªèƒ½é€šè¿‡ capset() å°†è¯¥ capability æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„ Inheritable é›†åˆä¸­ï¼ˆå› ä¸º Pâ€™(inheritable) = P(inheritable)ï¼‰ã€‚ å¦‚æœæƒ³è®©å½“å‰çº¿ç¨‹ Inheritable é›†åˆä¸­çš„ capabilities ä¼ é€’ç»™æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶çš„ Inheritable é›†åˆä¸­ä¹Ÿå¿…é¡»åŒ…å«è¿™äº› capabilitiesï¼ˆå› ä¸º Pâ€™(permitted) = (P(inheritable) &amp; F(inheritable))|â€¦ï¼‰ã€‚ å°†å½“å‰çº¿ç¨‹çš„ capabilities ä¼ é€’ç»™æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼Œä»…ä»…åªæ˜¯ä¼ é€’ç»™æ–°çº¿ç¨‹çš„ Permitted é›†åˆã€‚å¦‚æœæƒ³è®©å…¶ç”Ÿæ•ˆï¼Œæ–°çº¿ç¨‹å¿…é¡»é€šè¿‡ capset() å°† capabilities æ·»åŠ åˆ° Effective é›†åˆä¸­ã€‚æˆ–è€…å¼€å¯æ–°çš„å¯æ‰§è¡Œæ–‡ä»¶çš„ Effective æ ‡å¿—ä½ï¼ˆå› ä¸º Pâ€™(effective) = F(effective) ? Pâ€™(permitted) : Pâ€™(ambient)ï¼‰ã€‚ åœ¨æ²¡æœ‰ Ambient é›†åˆä¹‹å‰ï¼Œå¦‚æœæŸä¸ªè„šæœ¬ä¸èƒ½è°ƒç”¨ capset()ï¼Œä½†æƒ³è®©è„šæœ¬ä¸­çš„çº¿ç¨‹éƒ½èƒ½è·å¾—è¯¥è„šæœ¬çš„ Permitted é›†åˆä¸­çš„ capabilitiesï¼Œåªèƒ½å°† Permitted é›†åˆä¸­çš„ capabilities æ·»åŠ åˆ° Inheritable é›†åˆä¸­ï¼ˆPâ€™(permitted) = P(inheritable) &amp; F(inheritable)|â€¦ï¼‰ï¼ŒåŒæ—¶å¼€å¯ Effective æ ‡å¿—ä½ï¼ˆPâ€™(effective) = F(effective) ? Pâ€™(permitted) : Pâ€™(ambient)ï¼‰ã€‚æœ‰ æœ‰ Ambient é›†åˆä¹‹åï¼Œäº‹æƒ…å°±å˜å¾—ç®€å•å¤šäº†ï¼Œåç»­çš„æ–‡ç« ä¼šè¯¦ç»†è§£é‡Šã€‚ å¦‚æœæŸä¸ª UID éé›¶ï¼ˆæ™®é€šç”¨æˆ·ï¼‰çš„çº¿ç¨‹æ‰§è¡Œäº† execve()ï¼Œé‚£ä¹ˆ Permitted å’Œ Effective é›†åˆä¸­çš„ capabilities éƒ½ä¼šè¢«æ¸…ç©ºã€‚ ä» root ç”¨æˆ·åˆ‡æ¢åˆ°æ™®é€šç”¨æˆ·ï¼Œé‚£ä¹ˆ Permitted å’Œ Effective é›†åˆä¸­çš„ capabilities éƒ½ä¼šè¢«æ¸…ç©ºï¼Œé™¤éè®¾ç½®äº† SECBIT_KEEP_CAPS æˆ–è€…æ›´å®½æ³›çš„ SECBIT_NO_SETUID_FIXUPã€‚ é™„å½•Capabilitiesè¡¨ Capability æè¿° CAP_AUDIT_CONTROL å¯ç”¨å’Œç¦ç”¨å†…æ ¸å®¡è®¡ï¼›æ”¹å˜å®¡è®¡è¿‡æ»¤è§„åˆ™ï¼›æ£€ç´¢å®¡è®¡çŠ¶æ€å’Œè¿‡æ»¤è§„åˆ™ CAP_AUDIT_READ å…è®¸é€šè¿‡ multicast netlink å¥—æ¥å­—è¯»å–å®¡è®¡æ—¥å¿— CAP_AUDIT_WRITE å°†è®°å½•å†™å…¥å†…æ ¸å®¡è®¡æ—¥å¿— CAP_BLOCK_SUSPEND ä½¿ç”¨å¯ä»¥é˜»æ­¢ç³»ç»ŸæŒ‚èµ·çš„ç‰¹æ€§ CAP_BPF (5.8) ä»CAP_SYS_ADMINåˆ†ç¦»ä¸€éƒ¨åˆ†BFPåŠŸèƒ½ï¼Œæ§åˆ¶äº†ä¸€äº›BPFç‰¹å®šçš„æ“ä½œï¼ŒåŒ…æ‹¬åˆ›å»ºBPF mapsã€ä½¿ç”¨ä¸€äº›é«˜çº§çš„BPFç¨‹åºåŠŸèƒ½ã€è®¿é—®BPF type formatï¼ˆBTFï¼‰æ•°æ®ç­‰ CAP_CHECKPOINT_RESTORE (5.9) å…è®¸æ›´æ–°/proc/sys/kernel/ns_last_pidï¼Œä½¿ç”¨set_tidç‰¹æ€§ï¼Œè¯»å…¶ä»–è¿›ç¨‹çš„/proc/[pid]/map_files CAP_CHOWN ä¿®æ”¹æ–‡ä»¶æ‰€æœ‰è€…çš„æƒé™ CAP_DAC_OVERRIDE å¿½ç•¥æ–‡ä»¶çš„ DAC è®¿é—®é™åˆ¶ CAP_DAC_READ_SEARCH å¿½ç•¥æ–‡ä»¶è¯»åŠç›®å½•æœç´¢çš„ DAC è®¿é—®é™åˆ¶ CAP_FOWNER å¿½ç•¥æ–‡ä»¶å±ä¸» ID å¿…é¡»å’Œè¿›ç¨‹ç”¨æˆ· ID ç›¸åŒ¹é…çš„é™åˆ¶ CAP_FSETID å…è®¸è®¾ç½®æ–‡ä»¶çš„ setuid ä½ CAP_IPC_LOCK å…è®¸é”å®šå…±äº«å†…å­˜ç‰‡æ®µ CAP_IPC_OWNER å¿½ç•¥ IPC æ‰€æœ‰æƒæ£€æŸ¥ CAP_KILL å…è®¸å¯¹ä¸å±äºè‡ªå·±çš„è¿›ç¨‹å‘é€ä¿¡å· CAP_LEASE å…è®¸ä¿®æ”¹æ–‡ä»¶é”çš„ FL_LEASE æ ‡å¿— CAP_LINUX_IMMUTABLE å…è®¸ä¿®æ”¹æ–‡ä»¶çš„ IMMUTABLE å’Œ APPEND å±æ€§æ ‡å¿— CAP_MAC_ADMIN å…è®¸ MAC é…ç½®æˆ–çŠ¶æ€æ›´æ”¹ CAP_MAC_OVERRIDE å¿½ç•¥æ–‡ä»¶çš„ DAC è®¿é—®é™åˆ¶ CAP_MKNOD å…è®¸ä½¿ç”¨ mknod() ç³»ç»Ÿè°ƒç”¨ CAP_NET_ADMIN å…è®¸æ‰§è¡Œç½‘ç»œç®¡ç†ä»»åŠ¡ CAP_NET_BIND_SERVICE å…è®¸ç»‘å®šåˆ°å°äº 1024 çš„ç«¯å£ CAP_NET_BROADCAST å…è®¸ç½‘ç»œå¹¿æ’­å’Œå¤šæ’­è®¿é—® CAP_NET_RAW å…è®¸ä½¿ç”¨åŸå§‹å¥—æ¥å­— CAP_PERFMON (5.8) ç®¡ç†æ€§èƒ½ç›‘æ§task CAP_SETGID å…è®¸æ”¹å˜è¿›ç¨‹çš„ GID CAP_SETFCAP å…è®¸ä¸ºæ–‡ä»¶è®¾ç½®ä»»æ„çš„ capabilities CAP_SETPCAP å…è®¸è®¾ç½®å…¶ä»–è¿›ç¨‹çš„ capabilities CAP_SETUID å…è®¸æ”¹å˜è¿›ç¨‹çš„ UID CAP_SYS_ADMIN å…è®¸æ‰§è¡Œç³»ç»Ÿç®¡ç†ä»»åŠ¡ï¼Œå¦‚åŠ è½½æˆ–å¸è½½æ–‡ä»¶ç³»ç»Ÿã€è®¾ç½®ç£ç›˜é…é¢ç­‰ CAP_SYS_BOOT å…è®¸é‡æ–°å¯åŠ¨ç³»ç»Ÿ CAP_SYS_CHROOT å…è®¸ä½¿ç”¨ chroot() ç³»ç»Ÿè°ƒç”¨ CAP_SYS_MODULE å…è®¸æ’å…¥å’Œåˆ é™¤å†…æ ¸æ¨¡å— CAP_SYS_NICE å…è®¸æå‡ä¼˜å…ˆçº§åŠè®¾ç½®å…¶ä»–è¿›ç¨‹çš„ä¼˜å…ˆçº§ CAP_SYS_PACCT å…è®¸æ‰§è¡Œè¿›ç¨‹çš„ BSD å¼å®¡è®¡ CAP_SYS_PTRACE å…è®¸è·Ÿè¸ªä»»ä½•è¿›ç¨‹ CAP_SYS_RAWIO å…è®¸ç›´æ¥è®¿é—® /devportã€/dev/memã€/dev/kmem åŠåŸå§‹å—è®¾å¤‡ CAP_SYS_RESOURCE å¿½ç•¥èµ„æºé™åˆ¶ CAP_SYS_TIME å…è®¸æ”¹å˜ç³»ç»Ÿæ—¶é’Ÿ CAP_SYS_TTY_CONFIG å…è®¸é…ç½® TTY è®¾å¤‡ CAP_SYSLOG å…è®¸ä½¿ç”¨ syslog() ç³»ç»Ÿè°ƒç”¨ CAP_WAKE_ALARM å…è®¸è§¦å‘ä¸€äº›èƒ½å”¤é†’ç³»ç»Ÿçš„ä¸œè¥¿(æ¯”å¦‚ CLOCK_BOOTTIME_ALARM è®¡æ—¶å™¨) å‚è€ƒæ–‡çŒ®Linux Capabilities ç®€ä»‹ Linuxçš„capabilitiesæœºåˆ¶ Linux Capabilities å…¥é—¨æ•™ç¨‹ï¼šæ¦‚å¿µç¯‡","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Capabilities","slug":"Capabilities","permalink":"http://yoursite.com/tags/Capabilities/"}]},{"title":"Androidæºç åˆ†æ - Zygoteè¿›ç¨‹","slug":"android/aosp/Androidæºç åˆ†æ-Zygoteè¿›ç¨‹","date":"2022-01-10T09:30:00.000Z","updated":"2022-11-13T09:55:54.356Z","comments":true,"path":"2022/01/10/android/aosp/Androidæºç åˆ†æ-Zygoteè¿›ç¨‹/","link":"","permalink":"http://yoursite.com/2022/01/10/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Zygote%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ ä¸Šä¸€ç¯‡æ–‡ç« Androidæºç åˆ†æ - initè¿›ç¨‹ï¼Œæˆ‘ä»¬åˆ†æäº†Androidç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹initè¿›ç¨‹çš„å¯åŠ¨è¿‡ç¨‹å’Œä¹‹åçš„å®ˆæŠ¤æœåŠ¡ initè¿›ç¨‹å¯åŠ¨äº†å¾ˆå¤šæœåŠ¡ï¼Œä¾‹å¦‚Zygoteï¼ŒServiceManagerï¼ŒMediaServerï¼ŒSurfaceFlingerç­‰ï¼Œæˆ‘ä»¬å¹³å¸¸å†™Androidåº”ç”¨éƒ½æ˜¯ä½¿ç”¨Javaè¯­è¨€ï¼Œè¿™æ¬¡æˆ‘ä»¬å°±å…ˆä»Javaä¸–ç•Œçš„åŠè¾¹å¤©ï¼šZygoteè¿›ç¨‹ å¼€å§‹åˆ†æ ä»‹ç»Zygoteæ„ä¸ºå—ç²¾åµï¼Œå®ƒæœ‰ä¸¤å¤§ä½œç”¨ï¼Œä¸€æ˜¯å¯åŠ¨SystemServerï¼ŒäºŒæ˜¯å­µåŒ–å¯åŠ¨App å¯åŠ¨æœåŠ¡æˆ‘ä»¬å·²ç»çŸ¥é“äº†initè¿›ç¨‹ä¼šä»init.rcæ–‡ä»¶ä¸­è§£æå¹¶å¯åŠ¨æœåŠ¡ï¼Œé‚£zygoteæ˜¯åœ¨å“ªå®šä¹‰çš„å‘¢ï¼Œinit.rcçš„å¤´å‡ è¡Œå°±æœ‰ä¸€ä¸ªimportï¼šimport /system/etc/init/hw/init.${ro.zygote}.rc æˆ‘ä»¬åœ¨init.rcåŒç›®å½•ä¸‹å°±èƒ½æ‰¾åˆ°å‡ ä¸ªå¯¹åº”çš„æ–‡ä»¶ï¼šinit.zygote32_64.rc init.zygote32.rc init.zygote64_32.rc init.zygote64.rcï¼Œå…·ä½“importå“ªä¸ªæ–‡ä»¶ä¸å…·ä½“è®¾å¤‡ç¡¬ä»¶æœ‰å…³ï¼Œç°åœ¨64ä½æ‰‹æœºè¿™ä¹ˆæ™®åŠäº†ï¼Œæˆ‘ä»¬å°±ä»¥init.zygote64.rcä¸ºç›®æ ‡åˆ†æ 123456789101112131415service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse onrestart write &#x2F;sys&#x2F;power&#x2F;state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks ä¸‹é¢çš„å­é¡¹æˆ‘ä»¬æš‚æ—¶ä¸ç”¨å…³å¿ƒï¼Œå…ˆè®°ä½app_process64çš„å¯åŠ¨å‚æ•°-Xzygote /system/bin --zygote --start-system-serverå³å¯ Zygoteå¯åŠ¨çš„æºæ–‡ä»¶ä¸ºframeworks/base/cmds/app_process/app_main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int main(int argc, char* const argv[])&#123; ... //åˆ›å»ºäº†ä¸€ä¸ªAppRuntimeï¼Œç»§æ‰¿è‡ªAndroidRuntimeï¼Œé‡å†™äº†ä¸€äº›å›è°ƒæ–¹æ³• AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] //åœ¨å¯åŠ¨æœåŠ¡æ—¶ï¼Œä¼ è¿›æ¥çš„å‚æ•°æ˜¯åŒ…å«æ–‡ä»¶è·¯å¾„çš„ //æˆ‘ä»¬ä¸éœ€è¦è¿™ä¸ªå‚æ•°ï¼Œå°±å‡ä¸€ä¸‹ä¸ªæ•°ï¼Œç§»ä¸€ä¸‹æŒ‡é’ˆ argc--; argv++; ... //å¤„ç†å‚æ•°ï¼Œè¿™é‡Œåªæ·»åŠ äº†ä¸€ä¸ª-Xzygoteå‚æ•° int i; for (i = 0; i &lt; argc; i++) &#123; ... if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); ... &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //è·³è¿‡å‚æ•°/system/binï¼Œè¿™ä¸ªå‚æ•°ç›®å‰æ²¡æœ‰è¢«ä½¿ç”¨ ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; //æœ‰--zygoteå‚æ•° zygote = true; //ZYGOTE_NICE_NAMEåœ¨64ä½ä¸‹ä¸ºzygote64ï¼Œ32ä½ä¸‹ä¸ºzygote niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; //æœ‰-start-system-serverå‚æ•° startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; //è¿™ä¸ªåˆ†æ”¯ä¸ä¼šè¿›å…¥Zygoteæ¨¡å¼ ... &#125; else &#123; // We're in zygote mode. //æ–°å»ºDalvikç¼“å­˜ç›®å½• maybeCreateDalvikCache(); //æ·»åŠ å¯åŠ¨å‚æ•° if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. //Zygoteæ¨¡å¼ä¸‹æ²¡æœ‰å…¶ä»–å‚æ•°äº† for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; if (!niceName.isEmpty()) &#123; //è®¾ç½®ç¨‹åºåä»¥åŠè¿›ç¨‹å runtime.setArgv0(niceName.string(), true /* setProcName */); &#125; if (zygote) &#123; //æ‰§è¡ŒAndroidRuntime::startæ–¹æ³• runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); &#125;&#125; æ•´ä½“ç»“æ„è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå°±æ˜¯å¤„ç†ä¸€ä¸‹å‚æ•°ï¼Œè¿›å…¥zygoteå¯¹åº”çš„åˆ†æ”¯ï¼Œæ‰§è¡ŒAndroidRuntime::startæ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¼ çš„æ˜¯ZygoteInitåœ¨Javaä¸­çš„ç±»åï¼Œç¬¬äºŒä¸ªå‚æ•°ä¼ äº†ä¸€äº›é€‰é¡¹ï¼ˆstart-system-serverå’Œabi-listï¼‰ï¼Œç¬¬ä¸‰ä¸ªå‚æ•°ä¼ äº†trueï¼Œä»£è¡¨å¯åŠ¨è™šæ‹Ÿæœºçš„æ—¶å€™éœ€è¦é¢å¤–æ·»åŠ ä¸€äº›JVMå‚æ•° AndroidRuntime::start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... static const String8 startSystemServer(\"start-system-server\"); // Whether this is the primary zygote, meaning the zygote which will fork system server. //64_32ä½å…¼å®¹è®¾å¤‡ä¸Šä¼šå¯åŠ¨ä¸¤ä¸ªZygoteï¼Œä¸€ä¸ªå«zygoteï¼Œä¸€ä¸ªå«zygote_secondary bool primary_zygote = false; //æœ‰start-system-serveré€‰é¡¹åˆ™ä»£è¡¨æ˜¯ä¸»Zygote for (size_t i = 0; i &lt; options.size(); ++i) &#123; if (options[i] == startSystemServer) &#123; primary_zygote = true; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125; &#125; //æ£€æŸ¥å’Œé…ç½®ä¸€äº›ç¯å¢ƒå˜é‡ ... /* start the virtual machine */ //åŠ è½½libart.so JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; //å¯åŠ¨JVM if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; return; &#125; //å›è°ƒAppRuntimeä¸­é‡å†™çš„æ–¹æ³• onVmCreated(env); /* * Register android functions. */ //æ³¨å†ŒAndroid JNIå‡½æ•° if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; //åˆ›å»ºä¸€ä¸ªJavaå±‚çš„Stringæ•°ç»„ç”¨æ¥è£…å‚æ•° jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»åcom.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); //å‰©ä¸‹æ¥å‚æ•°åˆ†åˆ«æ˜¯start-system-serverå’Œabi-list for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //å°†Javaç±»åä¸­çš„\".\"æ›¿æ¢æˆ\"/\"ï¼Œè¿™æ˜¯JNIä¸­çš„ç±»åè§„åˆ™ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //è·å–ZygoteInitä¸­çš„mainæ–¹æ³•ï¼Œå‚æ•°ä¸ºStringç±»å‹ï¼Œè¿”å›å€¼ä¸ºvoid jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //æ‰§è¡ŒZygoteInitçš„mainæ–¹æ³• env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //åé¢çš„ä»£ç é™¤éJVMæŒ‚äº†ï¼Œå¦åˆ™ä¸ä¼šæ‰§è¡Œ ... &#125; &#125; ...&#125; é¦–å…ˆåˆ¤æ–­é€‰é¡¹ä¸­æ˜¯å¦æºå¸¦å‚æ•°start-system-serverï¼Œå¦‚æœ‰ï¼Œåˆ™å°†å®ƒè§†ä¸ºä¸»Zygoteï¼Œæ¥ç€å°±å¼€å§‹å¯åŠ¨JVMäº† å¯åŠ¨JVMJniInvocationä½¿ç”¨JniInvocationåˆå§‹åŒ–Android ARTè™šæ‹Ÿæœºç¯å¢ƒï¼Œå®ƒçš„è·¯å¾„æ˜¯libnativehelper/include_platform/nativehelper/JniInvocation.hï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å®ƒæ˜¯æ€ä¹ˆåšçš„ æˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹å®ƒçš„æ„é€ å‡½æ•° 123456789101112/* libnativehelper/include_platform/nativehelper/JniInvocation.h */class JniInvocation final &#123; public: JniInvocation() &#123; impl_ = JniInvocationCreate(); &#125; ~JniInvocation() &#123; JniInvocationDestroy(impl_); &#125; ...&#125; è°ƒç”¨JniInvocationCreateæ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ªJniInvocationImplå®ä¾‹å¯¹è±¡ 123JniInvocationImpl* JniInvocationCreate() &#123; return new JniInvocationImpl();&#125; æ¥ç€è°ƒç”¨JniInvocation::Initæ–¹æ³• 1234567bool Init(const char* library) &#123; return JniInvocationInit(impl_, library) != 0;&#125;int JniInvocationInit(JniInvocationImpl* instance, const char* library) &#123; return instance-&gt;Init(library) ? 1 : 0;&#125; å¯ä»¥çœ‹åˆ°ï¼ŒJniInvocationå®é™…ä¸Šæ˜¯ä¸ªä»£ç†ç±»ï¼Œå†…éƒ¨å®ç°æ˜¯äº¤ç»™JniInvocationImplçš„ï¼Œè·¯å¾„ä¸ºlibnativehelper/JniInvocation.cpp 12345678910111213141516171819202122232425262728293031323334353637bool JniInvocationImpl::Init(const char* library) &#123; ... //édebugä¸€å¾‹ä¸ºlibart.so library = GetLibrary(library, buffer); //åŠ è½½libart.soåº“ handle_ = OpenLibrary(library); if (handle_ == NULL) &#123; //å¦‚æœæ˜¯åŠ è½½libart.soåº“å¤±è´¥ï¼Œç›´æ¥è¿”å›false if (strcmp(library, kLibraryFallback) == 0) &#123; // Nothing else to try. ALOGE(\"Failed to dlopen %s: %s\", library, GetError().c_str()); return false; &#125; ... //å¦‚æœæ˜¯åŠ è½½å…¶ä»–åº“å¤±è´¥ï¼Œå°è¯•å›é€€åŠ è½½libart.soåº“ library = kLibraryFallback; handle_ = OpenLibrary(library); if (handle_ == NULL) &#123; ALOGE(\"Failed to dlopen %s: %s\", library, GetError().c_str()); return false; &#125; &#125; //ä»libart.soåº“è·å¾—ä¸‰ä¸ªJVMç›¸å…³çš„å‡½æ•°åœ°å€ if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_), \"JNI_GetDefaultJavaVMInitArgs\")) &#123; return false; &#125; if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_CreateJavaVM_), \"JNI_CreateJavaVM\")) &#123; return false; &#125; if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_GetCreatedJavaVMs_), \"JNI_GetCreatedJavaVMs\")) &#123; return false; &#125; return true;&#125; åŠ è½½libart.soåº“æˆ‘ä»¬å…ˆçœ‹GetLibraryæ–¹æ³• 12345678910111213141516171819202122232425static const char* kLibraryFallback = \"libart.so\";const char* JniInvocationImpl::GetLibrary(const char* library, char* buffer, bool (*is_debuggable)(), int (*get_library_system_property)(char* buffer)) &#123;#ifdef __ANDROID__ const char* default_library; if (!is_debuggable()) &#123; library = kLibraryFallback; default_library = kLibraryFallback; &#125; else &#123; ... &#125;#else ... const char* default_library = kLibraryFallback;#endif if (library == NULL) &#123; library = default_library; &#125; return library;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨debugæ¨¡å¼æˆ–libraryå‚æ•°ä¸ºNULLçš„æƒ…å†µä¸‹éƒ½æ˜¯ç›´æ¥è¿”å›çš„libart.so è€ŒOpenLibraryæ–¹æ³•æ˜¯ä½¿ç”¨äº†dlopenå‡½æ•°ï¼ŒåŠ è½½libart.soåº“ 123456void* OpenLibrary(const char* filename) &#123; ... const int kDlopenFlags = RTLD_NOW | RTLD_NODELETE; return dlopen(filename, kDlopenFlags); ...&#125; dlopenåŸå‹ï¼švoid *dlopen(const char *filename, int flags); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/dlopen.3.html è¿™æ˜¯ä¸€ä¸ªLinuxå‡½æ•°ï¼Œç”¨æ¥åŠ è½½ä¸€ä¸ªåŠ¨æ€é“¾æ¥åº“ï¼Œå½“åŠ è½½æˆåŠŸæ—¶ï¼Œä¼šè¿”å›ä¸€ä¸ªå¥æŸ„ ä¸Šé¢çš„è¿™ä¸¤ä¸ªå‚æ•°ï¼ŒRTLD_NOWä»£è¡¨ç«‹å³è®¡ç®—åº“çš„ä¾èµ–æ€§ï¼ŒRTLD_NODELETEä»£è¡¨ä¸è¦å†dlcloseæœŸé—´å¸è½½åº“ï¼Œè¿™æ ·å½“å†æ¬¡åŠ è½½åº“çš„æ—¶å€™ä¸ä¼šé‡æ–°åˆå§‹åŒ–å¯¹è±¡çš„é™æ€å…¨å±€å˜é‡ï¼Œä½¿ç”¨è¿™ä¸ªflagæ˜¯ä¸ºäº†ç¡®ä¿libart.soåœ¨å…³é—­æ—¶ä¸ä¼šè¢«å–æ¶ˆæ˜ å°„ã€‚å› ä¸ºå³ä½¿åœ¨ JNI_DeleteJavaVM è°ƒç”¨ä¹‹åï¼ŒæŸäº›çº¿ç¨‹ä»å¯èƒ½å°šæœªå®Œæˆé€€å‡ºï¼Œå¦‚æœå¸è½½è¯¥åº“ï¼Œåˆ™å¯èƒ½å¯¼è‡´æ®µé”™è¯¯ ä»libart.soåº“ä¸­å¯»æ‰¾å‡½æ•°åœ°å€æ¥ç€è°ƒç”¨FindSymbolå‡½æ•°æŸ¥æ‰¾å‡½æ•°åœ°å€ 1234567891011121314151617181920#define FUNC_POINTER void*bool JniInvocationImpl::FindSymbol(FUNC_POINTER* pointer, const char* symbol) &#123; //è·å¾—å‡½æ•°åœ°å€ *pointer = GetSymbol(handle_, symbol); //è·å–å¤±è´¥ï¼Œå¸è½½libart.soåº“ if (*pointer == NULL) &#123; ALOGE(\"Failed to find symbol %s: %s\\n\", symbol, GetError().c_str()); CloseLibrary(handle_); handle_ = NULL; return false; &#125; return true;&#125;FUNC_POINTER GetSymbol(void* handle, const char* symbol) &#123; ... return dlsym(handle, symbol); ...&#125; dlsymåŸå‹ï¼švoid *dlsym(void *restrict handle , const char *restrict symbol); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/dlsym.3.html ä¹Ÿæ˜¯ä¸€ä¸ªLinuxå‡½æ•°ï¼Œç”¨æ¥ä»å·²åŠ è½½çš„åŠ¨æ€é“¾æ¥åº“ä¸­è·å–ä¸€ä¸ªå‡½æ•°çš„åœ°å€ ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºä¹‹å‰åŠ è½½åº“æ—¶è¿”å›çš„å¥æŸ„ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºå‡½æ•°å æ€»ç»“å›é¡¾ä¸€ä¸‹å…¨å±€ï¼ŒJniInvocationImpl::Initçš„ä½œç”¨æ˜¯ï¼ŒåŠ è½½libart.soåº“ï¼Œå¹¶ä»ä¸­è·å–ä¸‰ä¸ªå‡½æ•°æŒ‡é’ˆï¼š JNI_GetDefaultJavaVMInitArgsï¼šè·å–è™šæ‹Ÿæœºçš„é»˜è®¤åˆå§‹åŒ–å‚æ•° JNI_CreateJavaVMï¼šåˆ›å»ºè™šæ‹Ÿæœºå®ä¾‹ JNI_GetCreatedJavaVMsï¼šè·å–åˆ›å»ºçš„è™šæ‹Ÿæœºå®ä¾‹ è¿™å‡ ä¸ªå‡½æ•°è¢«å®šä¹‰åœ¨jni.hä¸­ï¼Œåé¢æˆ‘ä»¬åˆ›å»ºJVMçš„æ—¶å€™ä¼šç”¨åˆ°è¿™äº›å‡½æ•° AndroidRuntime::startVm12345678910111213141516171819int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote, bool primary_zygote)&#123; JavaVMInitArgs initArgs; ... //é…ç½®äº†ä¸€å¤§å †JVMé€‰é¡¹ initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; //åˆ›å»ºå¹¶åˆå§‹åŒ–JVM if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125; JNI_CreateJavaVMæ–¹æ³•å°±æ˜¯æˆ‘ä»¬ä¹‹å‰ä»libart.soé‡Œè·å¾—çš„æ–¹æ³•ï¼Œè¢«ç¼–è¯‘è¿›libart.soå‰ï¼Œæºç çš„è·¯å¾„ä¸ºart/runtime/jni/java_vm_ext.ccï¼Œæ¥ä¸‹æ¥å±äºARTè™šæ‹Ÿæœºçš„å·¥ä½œï¼Œæˆ‘ä»¬å°±ä¸å†å¾€ä¸‹æ·±ç©¶äº† åé¢æœ‰ä¸€ä¸ªonVmCreatedå›è°ƒï¼Œä½†åœ¨zygoteæ¨¡å¼ä¸‹æ²¡åšä»»ä½•äº‹ æ³¨å†ŒJNIå‡½æ•°æ¥ç€è°ƒç”¨startRegå‡½æ•°æ³¨å†ŒAndroid JNIå‡½æ•° 12345678910111213141516171819202122232425/* * Register android native functions with the VM. *//*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; ... //è®¾ç½®Nativeåˆ›å»ºçº¿ç¨‹çš„å‡½æ•°ï¼Œé€šè¿‡javaCreateThreadEtcè¿™ä¸ªå‡½æ•°åˆ›å»ºçš„çº¿ç¨‹ //ä¼šæŠŠåˆ›å»ºçš„çº¿ç¨‹attachåˆ°JVMä¸­ï¼Œä½¿å…¶æ—¢èƒ½æ‰§è¡Œc/c++ä»£ç ï¼Œä¹Ÿèƒ½æ‰§è¡ŒJavaä»£ç  androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); //åˆ›å»ºå±€éƒ¨å¼•ç”¨æ ˆå¸§ env-&gt;PushLocalFrame(200); //æ³¨å†Œjniå‡½æ•° if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; //å°†å½“å‰æ ˆå¸§å‡ºæ ˆï¼Œé‡Šæ”¾å…¶ä¸­æ‰€æœ‰å±€éƒ¨å¼•ç”¨ env-&gt;PopLocalFrame(NULL); return 0;&#125; é¦–å…ˆhookäº†Nativeåˆ›å»ºçº¿ç¨‹çš„å‡½æ•°ï¼Œä¹‹ååˆ›å»ºçº¿ç¨‹ä¾¿ä¼šè°ƒç”¨æˆ‘ä»¬è®¾ç½®çš„javaCreateThreadEtcå‡½æ•°ï¼Œä¼šæŠŠåˆ›å»ºçš„çº¿ç¨‹attachåˆ°JVMä¸­ï¼Œä½¿å…¶æ—¢èƒ½æ‰§è¡Œc/c++ä»£ç ï¼Œä¹Ÿèƒ½æ‰§è¡ŒJavaä»£ç ã€‚è¿™ä¸ªç­‰ä¹‹åçœ‹åˆ°Androidçº¿ç¨‹åˆ›å»ºçš„æ—¶å€™å†åˆ†æ PushLocalFrameå’ŒPopLocalFrameæ˜¯ä¸€å¯¹å‡½æ•°ï¼Œå®ƒä»¬æ˜¯ç”¨æ¥ç®¡ç†JNIçš„å±€éƒ¨å¼•ç”¨çš„ é¦–å…ˆï¼ŒPushLocalFrameä¼šåˆ›å»ºå‡ºä¸€ä¸ªå±€éƒ¨å¼•ç”¨æ ˆå¸§ï¼Œä¹‹åJNIåˆ›å»ºå‡ºæ¥çš„å±€éƒ¨å¼•ç”¨éƒ½ä¼šæ”¾åœ¨è¿™ä¸ªæ ˆå¸§é‡Œï¼Œç­‰ä½¿ç”¨ç»“æŸåè°ƒç”¨PopLocalFrameå‡½æ•°ï¼Œä¼šå°†å½“å‰æ ˆå¸§å‡ºæ ˆï¼Œå¹¶ä¸”é‡Šæ”¾å…¶ä¸­æ‰€æœ‰çš„å±€éƒ¨å¼•ç”¨ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹register_jni_procså‡½æ•° 1234567891011121314struct RegJNIRec &#123; int (*mProc)(JNIEnv*);&#125;; static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; ... return -1; &#125; &#125; return 0;&#125; å¾ˆç®€å•ï¼Œå°±æ˜¯å¾ªç¯æ‰§è¡ŒgRegJNIæ•°ç»„ä¸­æ‰€æœ‰çš„å‡½æ•° 12345678910#define REG_JNI(name) &#123; name &#125;static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_com_android_internal_os_RuntimeInit), REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit), REG_JNI(register_android_os_SystemClock), REG_JNI(register_android_util_EventLog), REG_JNI(register_android_util_Log), ...&#125;; gRegJNIæ•°ç»„ä¸­å­˜æ”¾ç€å¾ˆå¤šJavaç±»æ³¨å†ŒJNIå‡½æ•°çš„å‡½æ•°ï¼Œåé¢å¤§å®¶å¦‚æœé˜…è¯»æºç çœ‹åˆ°äº†Androidä¸­çš„nativeæ–¹æ³•å¯ä»¥æ¥è¿™è¾¹æ‰¾å®ƒæ‰€å¯¹åº”çš„c++å®ç° è¿™è¾¹æ³¨å†Œçš„ç±»éå¸¸å¤šï¼Œæˆ‘ä»¬å°±å–ç¬¬ä¸€ä¸ªregister_com_android_internal_os_RuntimeInitä¸ºä¾‹åˆ†æä¸€ä¸‹ 1234567891011121314151617typedef struct &#123; const char* name; const char* signature; void* fnPtr;&#125; JNINativeMethod;int register_com_android_internal_os_RuntimeInit(JNIEnv* env)&#123; const JNINativeMethod methods[] = &#123; &#123;\"nativeFinishInit\", \"()V\", (void*)com_android_internal_os_RuntimeInit_nativeFinishInit&#125;, &#123;\"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup&#125;, &#125;; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", methods, NELEM(methods));&#125; åˆ›å»ºäº†ä¸€ä¸ªJNINativeMethodç»“æ„ä½“ï¼Œç¬¬ä¸€ä¸ªæˆå‘˜æ˜¯Javaä¸­çš„æ–¹æ³•åï¼Œç¬¬äºŒä¸ªæˆå‘˜æ˜¯Javaä¸­å¯¹åº”æ–¹æ³•çš„ç­¾åï¼Œç¬¬ä¸‰ä¸ªæˆå‘˜æ˜¯Javaæ–¹æ³•å¯¹åº”nativeå‡½æ•°çš„å‡½æ•°æŒ‡é’ˆï¼Œç„¶åè°ƒç”¨jniRegisterNativeMethodså‡½æ•° 123456789101112131415161718int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)&#123; JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env); ALOGV(\"Registering %s's %d native methods...\", className, numMethods); scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className)); ALOG_ALWAYS_FATAL_IF(c.get() == NULL, \"Native registration unable to find class '%s'; aborting...\", className); int result = e-&gt;RegisterNatives(c.get(), gMethods, numMethods); ALOG_ALWAYS_FATAL_IF(result &lt; 0, \"RegisterNatives failed for '%s'; aborting...\", className); return 0;&#125; è¿™ä¸ªå‡½æ•°å…ˆé€šè¿‡Javaç±»åè·å¾—ä¸€ä¸ªjclasså¯¹è±¡ï¼Œæ¥ç€è°ƒç”¨JNIEnv::RegisterNativeså‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å®šä¹‰åœ¨jni.hä¸­ï¼Œå®ç°åœ¨libart.soåº“ä¸­ï¼Œæˆ‘ä»¬åœ¨å¹³æ—¶å¼€å‘jniçš„æ—¶å€™ï¼ŒåŠ¨æ€æ³¨å†Œnativeæ–¹æ³•çš„æ—¶å€™å°±ä¼šä½¿ç”¨åˆ°å®ƒï¼Œè¿™é‡Œå°±ä¸å†å¾€ä¸‹åˆ†æäº† è¿›å…¥JAVAä¸–ç•ŒJVMå¯åŠ¨å¥½äº†ï¼ŒJNIå‡½æ•°ä¹Ÿæ³¨å†Œå®Œæ¯•äº†ï¼Œæ¥ä¸‹æ¥å°±è¯¥è¿›å…¥åˆ°JAVAä¸–ç•Œäº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... //åˆ›å»ºä¸€ä¸ªJavaå±‚çš„Stringæ•°ç»„ç”¨æ¥è£…å‚æ•° jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ç±»åcom.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); //å‰©ä¸‹æ¥å‚æ•°åˆ†åˆ«æ˜¯start-system-serverå’Œabi-list for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //å°†Javaç±»åä¸­çš„\".\"æ›¿æ¢æˆ\"/\"ï¼Œè¿™æ˜¯JNIä¸­çš„ç±»åè§„åˆ™ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //è·å–ZygoteInitä¸­çš„mainæ–¹æ³•ï¼Œå‚æ•°ä¸ºStringç±»å‹ï¼Œè¿”å›å€¼ä¸ºvoid jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //æ‰§è¡ŒZygoteInitçš„mainæ–¹æ³• env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //åé¢çš„ä»£ç é™¤éJVMæŒ‚äº†ï¼Œå¦åˆ™ä¸ä¼šæ‰§è¡Œ ... &#125; &#125; ...&#125; è¿™é‡Œçœ‹ä¸æ‡‚çš„è‡ªå·±å…ˆè¡¥ä¸€ä¸‹JNIçŸ¥è¯†ï¼Œæ€»ä¹‹å°±æ˜¯è°ƒç”¨äº†com.android.internal.os.ZygoteInitç±»çš„é™æ€æ–¹æ³•mainï¼Œä»¥com.android.internal.os.ZygoteInitï¼Œstart-system-serverå’Œabi-listä½œä¸ºå‚æ•° ZygoteInitZygoteInitç±»çš„æºç è·¯å¾„ä¸ºframeworks/base/core/java/com/android/internal/os/ZygoteInit.java æˆ‘ä»¬è¿™å°±å¼€å§‹åˆ†æå®ƒçš„mainæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public static void main(String argv[]) &#123; ZygoteServer zygoteServer = null; // Mark zygote start. This ensures that thread creation will throw // an error. //æ ‡è®°ç€zygoteå¼€å§‹å¯åŠ¨ï¼Œä¸å…è®¸åˆ›å»ºçº¿ç¨‹ï¼ˆZygoteå¿…é¡»ä¿è¯å•çº¿ç¨‹ï¼‰ ZygoteHooks.startZygoteNoThreadCreation(); // Zygote goes into its own process group. //è®¾ç½®è¿›ç¨‹ç»„id try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to setpgid(0,0)\", ex); &#125; Runnable caller; try &#123; ... //é…ç½®å‚æ•° boolean startSystemServer = false; String zygoteSocketName = \"zygote\"; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (\"--enable-lazy-preload\".equals(argv[i])) &#123; enableLazyPreload = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; //public static final String PRIMARY_SOCKET_NAME = \"zygote\"; final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME); ... if (!enableLazyPreload) &#123; ... //é¢„åŠ è½½ preload(bootTimingsTraceLog); ... &#125; ... //è°ƒç”¨Javaå±‚çš„åƒåœ¾å›æ”¶ gcAndFinalize(); ... //å›è°ƒAppRRuntimeä¸­çš„onZygoteInitå‡½æ•° Zygote.initNativeState(isPrimaryZygote); //è§£é™¤åˆ›å»ºçº¿ç¨‹é™åˆ¶ï¼ˆé©¬ä¸Šå°±è¦æ‰§è¡Œforkäº†ï¼Œå­è¿›ç¨‹è¦æœ‰èƒ½åŠ›åˆ›å»ºçº¿ç¨‹ï¼‰ ZygoteHooks.stopZygoteNoThreadCreation(); //åˆ›å»ºsocket zygoteServer = new ZygoteServer(isPrimaryZygote); //å¯åŠ¨SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; r.run(); return; &#125; &#125; Log.i(TAG, \"Accepting command socket connections\"); // The select loop returns early in the child process after a fork and // loops forever in the zygote. //æ‰§è¡Œæ­»å¾ªç¯ç›‘å¬socketï¼Œè´Ÿè´£æ¥æ”¶äº‹ä»¶ï¼Œå¯åŠ¨App caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, \"System zygote died with exception\", ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // We're in the child process and have exited the select loop. Proceed to execute the // command. //æ¥æ”¶åˆ°AMSçš„å¯åŠ¨Appè¯·æ±‚åï¼Œforkå‡ºå­è¿›ç¨‹ï¼Œå¤„ç†Appå¯åŠ¨ if (caller != null) &#123; caller.run(); &#125;&#125; å…ˆè°ƒç”¨ZygoteHooks.startZygoteNoThreadCreation()ç¦æ­¢åˆ›å»ºçº¿ç¨‹ï¼ŒZygoteå¿…é¡»ä¿è¯å•çº¿ç¨‹ï¼Œè¿™å’Œforkæœºåˆ¶æœ‰å…³ï¼Œforkå‡½æ•°åªä¼šå°†å½“å‰çº¿ç¨‹å¤åˆ¶åˆ°å­è¿›ç¨‹ï¼ŒåŒæ—¶ï¼Œforkä¼šå°†é”ä¹Ÿå¤åˆ¶åˆ°å­è¿›ç¨‹ä¸­ï¼Œå¦‚æœåœ¨forkä¹‹å‰ï¼Œæœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰äº†é”ï¼Œä½†æ˜¯forkçš„æ—¶å€™æ²¡æŠŠè¿™ä¸ªçº¿ç¨‹å¤åˆ¶åˆ°å­è¿›ç¨‹ä¸­ï¼Œè¿™æŠŠé”å°±è¢«æ°¸ä¹…æŒæœ‰äº†ï¼Œä¼šé€ æˆæ­»é” android.system.Osæˆ‘ä»¬çœ‹ä¸€ä¸‹Osæ˜¯ä»€ä¹ˆï¼Œæ ¹æ®importæˆ‘ä»¬çŸ¥é“å®ƒçš„å…¨é™å®šç±»åä¸ºandroid.system.Osï¼Œå®ƒçš„æºç è·¯å¾„ä¸ºlibcore/luni/src/main/java/android/system/Os.java 123456789...import libcore.io.Libcore;public final class Os &#123; private Os() &#123;&#125; ... public static void setpgid(int pid, int pgid) throws ErrnoException &#123; Libcore.os.setpgid(pid, pgid); &#125; ...&#125; å®ƒé‡Œé¢å…¨æ˜¯è¿™ç§å½¢å¼çš„é™æ€ä»£ç†æ–¹æ³•ï¼Œå®é™…è°ƒç”¨Libcore.osæ‰§è¡Œï¼Œæˆ‘ä»¬å°±ä»¥setpgidæ–¹æ³•å»è¿½è¸ªä¸€ä¸‹ Libcoreä½äºlibcore/luni/src/main/java/libcore/io/Libcore.javaï¼Œosæ˜¯å…¶ä¸­çš„ä¸€ä¸ªé™æ€å˜é‡ 1234567891011121314151617181920212223public final class Libcore &#123; private Libcore() &#123; &#125; /** * Direct access to syscalls. Code should strongly prefer using &#123;@link #os&#125; * unless it has a strong reason to bypass the helpful checks/guards that it * provides. */ public static final Os rawOs = new Linux(); /** * Access to syscalls with helpful checks/guards. * For read access only; the only supported way to update this field is via * &#123;@link #compareAndSetOs&#125;. */ @UnsupportedAppUsage public static volatile Os os = new BlockGuardOs(rawOs); public static Os getOs() &#123; return os; &#125; ...&#125; osçš„ç±»å‹ä¸ºBlockGuardOsï¼Œä»¥Linuxç±»å‹çš„å¸¸é‡rawOsä½œä¸ºæ„é€ æ–¹æ³•å‚æ•°å®ä¾‹åŒ–ï¼Œå®ƒç»§æ‰¿è‡ªForwardingOs 12345678910111213public class ForwardingOs implements Os &#123; @UnsupportedAppUsage private final Os os; @UnsupportedAppUsage @libcore.api.CorePlatformApi protected ForwardingOs(Os os) &#123; this.os = Objects.requireNonNull(os); &#125; ... public void setpgid(int pid, int pgid) throws ErrnoException &#123; os.setpgid(pid, pgid); &#125; ...&#125; å¯ä»¥çœ‹åˆ°ï¼Œè¿™å…¶å®åˆæ˜¯ä¸€ä¸ªä»£ç†ç±»ï¼Œå®é™…ä¸Šæ˜¯ç›´æ¥è°ƒç”¨äº†Linuxç±»çš„æ–¹æ³•ï¼Œè‡³äºBlockGuardOsï¼Œå®ƒåœ¨éƒ¨åˆ†æ–¹æ³•ä¸Šåšäº†ä¸€äº›å›è°ƒç›‘å¬ï¼Œé™¤æ­¤ä¹‹å¤–ä¹Ÿæ˜¯ç›´æ¥è°ƒç”¨äº†Linuxç±»çš„æ–¹æ³• 1234567public final class Linux implements Os &#123; Linux() &#123; &#125; ... public native int getpgid(int pid); ...&#125; é‡Œé¢åŸºæœ¬ä¸Šéƒ½æ˜¯JNIè°ƒç”¨nativeæ–¹æ³•ï¼Œå¯¹åº”çš„c++æºç è·¯å¾„ä¸ºlibcore/luni/src/main/native/libcore_io_Linux.cppï¼Œä¸‹é¢æ˜¯æ³¨å†ŒJNIå‡½æ•°çš„å‡½æ•° 12345678910111213141516171819202122232425262728293031323334#define NATIVE_METHOD(className, functionName, signature) \\ MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName) #define MAKE_JNI_NATIVE_METHOD(name, signature, function) \\ _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function) #define _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \\ MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn) #define MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \\ ([]() &#123; \\ using namespace nativehelper::detail; /* NOLINT(google-build-using-namespace) */ \\ static_assert( \\ MatchJniDescriptorWithFunctionType&lt;native_kind, \\ decltype(fn), \\ fn, \\ sizeof(signature_)&gt;(signature_),\\ \"JNI signature doesn't match C++ function type.\"); \\ /* Suppress implicit cast warnings by explicitly casting. */ \\ return JNINativeMethod &#123; \\ const_cast&lt;decltype(JNINativeMethod::name)&gt;(name_), \\ const_cast&lt;decltype(JNINativeMethod::signature)&gt;(signature_), \\ reinterpret_cast&lt;void*&gt;(&amp;(fn))&#125;; \\ &#125;)()static JNINativeMethod gMethods[] = &#123; ... NATIVE_METHOD(Linux, setpgid, \"(II)V\"), ...&#125;;void register_libcore_io_Linux(JNIEnv* env) &#123; ... jniRegisterNativeMethods(env, \"libcore/io/Linux\", gMethods, NELEM(gMethods));&#125; å¯ä»¥çœ‹åˆ°ï¼ŒJavaå±‚æ–¹æ³•å¯¹åº”nativeæ–¹æ³•çš„æ ¼å¼ä¸ºLinux_æ–¹æ³•åï¼Œæˆ‘ä»¬é€šè¿‡è¿™ç§è§„åˆ™æ‰¾åˆ°setpgidæ–¹æ³•å¯¹åº”çš„å‡½æ•° 123static void Linux_setpgid(JNIEnv* env, jobject, jint pid, int pgid) &#123; throwIfMinusOne(env, \"setpgid\", TEMP_FAILURE_RETRY(setpgid(pid, pgid)));&#125; å¯ä»¥çœ‹åˆ°æ˜¯ç›´æ¥è°ƒç”¨äº†Linuxç³»ç»Ÿå±‚å‡½æ•° æ€»ç»“ç»¼ä¸Šæ‰€è¿°ï¼Œandroid.system.Osç±»å­˜åœ¨çš„æ„ä¹‰æ˜¯å¯ä»¥ä½¿Javaå±‚èƒ½å¤Ÿæ–¹ä¾¿çš„è°ƒç”¨Linuxç³»ç»Ÿæ–¹æ³• é¢„åŠ è½½æ¥ä¸‹æ¥å°±æ˜¯ä¸€äº›å‚æ•°é…ç½®å·¥ä½œï¼Œç„¶åè°ƒç”¨preloadé¢„åŠ è½½ 12345678910111213141516171819202122232425262728static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; ... //é¢„åŠ è½½Javaç±» preloadClasses(); ... //åŠ è½½ä¸‰ä¸ªjaræ–‡ä»¶ /* /system/framework/android.hidl.base-V1.0-java.jar */ /* /system/framework/android.hidl.manager-V1.0-java.jar */ /* /system/framework/android.test.base.jar */ cacheNonBootClasspathClassLoaders(); ... //é¢„åŠ è½½ç³»ç»Ÿèµ„æº preloadResources(); ... //é¢„åŠ è½½ç¡¬ä»¶æŠ½è±¡å±‚ï¼Ÿ nativePreloadAppProcessHALs(); ... //é¢„åŠ è½½opengl maybePreloadGraphicsDriver(); ... //é¢„åŠ è½½åŠ¨æ€åº“ preloadSharedLibraries(); //TextViewé¢„åŠ è½½Font preloadTextResources(); //é¢„åŠ è½½webviewchromium WebViewFactory.prepareWebViewInZygote(); ...&#125; preloadClassesæˆ‘ä»¬çœ‹çœ‹Javaç±»çš„é¢„åŠ è½½ 1234567891011121314151617181920212223242526272829303132333435363738394041private static final String PRELOADED_CLASSES = \"/system/etc/preloaded-classes\";private static void preloadClasses() &#123; final VMRuntime runtime = VMRuntime.getRuntime(); InputStream is; try &#123; is = new FileInputStream(PRELOADED_CLASSES); &#125; catch (FileNotFoundException e) &#123; Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\"); return; &#125; ... try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE); int count = 0; String line; while ((line = br.readLine()) != null) &#123; // Skip comments and blank lines. line = line.trim(); if (line.startsWith(\"#\") || line.equals(\"\")) &#123; continue; &#125; ... //Javaç±»åŠ è½½å™¨åŠ è½½ç±» Class.forName(line, true, null); count++; ... &#125; Log.i(TAG, \"...preloaded \" + count + \" classes in \" + (SystemClock.uptimeMillis() - startTime) + \"ms.\"); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error reading \" + PRELOADED_CLASSES + \".\", e); &#125; finally &#123; ... &#125;&#125; ä¸»è¦çš„ä»£ç å°±æ˜¯ä»/system/etc/preloaded-classesè¿™ä¸ªæ–‡ä»¶ä¸­è¯»å–å‡ºéœ€è¦é¢„åŠ è½½çš„ç±»ï¼Œå†é€šè¿‡Class.forNameä½¿ç”¨ç±»åŠ è½½å™¨åŠ è½½ä¸€éï¼Œç¼–è¯‘å‰çš„è·¯å¾„ä¸ºframeworks/base/config/preloaded-classes ä¸ºä»€ä¹ˆéœ€è¦é¢„åŠ è½½Zygoteè¿›ç¨‹çš„ä¸€å¤§ä½œç”¨å°±æ˜¯å­µåŒ–Appï¼Œé‚£æ˜¯æ€ä¹ˆå­µåŒ–çš„å‘¢ï¼Ÿè¿™è¿‡ç¨‹ä¸­è‚¯å®šè¦ä½¿ç”¨åˆ°forkï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œforkåï¼Œçˆ¶å­è¿›ç¨‹æ˜¯å¯ä»¥å…±äº«èµ„æºçš„ï¼Œæ—¢ç„¶æˆ‘ä»¬æ¯å¯åŠ¨ä¸€ä¸ªAppï¼Œéƒ½éœ€è¦ä½¿ç”¨è™šæ‹Ÿæœºã€åŠ è½½ä¸€äº›Viewç­‰å¿…è¦çš„ç±»ç­‰ç­‰ï¼Œé‚£ä¸ºä½•ä¸åœ¨çˆ¶è¿›ç¨‹ä¸­åŠ è½½å¥½è¿™äº›ï¼Œforkåå­è¿›ç¨‹ä¸å°±å¯ä»¥ç›´æ¥ä½¿ç”¨å®ƒä»¬äº†å—ï¼Ÿè¿™å°±æ˜¯Zygoteè¿›ç¨‹é¢„åŠ è½½çš„åŸå›  å¯åŠ¨binderçº¿ç¨‹æ± é¢„åŠ è½½ç»“æŸåï¼Œä¼šå…ˆæ¸…ç†ä¸€ä¸‹Javaå±‚çš„åƒåœ¾ï¼Œç„¶åè°ƒç”¨Zygote.initNativeState(isPrimaryZygote)æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•è°ƒç”¨äº†nativeæ–¹æ³•nativeInitNativeStateï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯åœ¨AndroidRuntimeä¸­æ³¨å†Œçš„ï¼ŒåŒæ—¶ä¹Ÿå®ç°åœ¨AndroidRuntimeä¸­ï¼Œ 1234static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; æˆ‘ä»¬ä¹‹å‰åˆ†æè¿‡ï¼Œæ‰§è¡Œçš„æ˜¯AndroidRuntimeçš„å­ç±»AppRuntimeçš„onZygoteInitå‡½æ•° 123456virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool();&#125; é€šè¿‡è¿™ä¸ªå‡½æ•°å¯åŠ¨Binderçº¿ç¨‹æ± ï¼Œè‡³äºBinderçš„ç»†èŠ‚ï¼Œæˆ‘ä»¬ç•™åˆ°ä»¥åå†åˆ†æ å¯åŠ¨SystemServerZygoteè¿›ç¨‹å­µåŒ–çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ä¾¿æ˜¯SystemServerï¼Œå…·ä½“æ€ä¹ˆå­µåŒ–çš„ï¼Œå­µåŒ–åSystemServeråˆåšäº†ä»€ä¹ˆï¼Œç•™åœ¨ä¸‹ä¸€èŠ‚æˆ‘ä»¬å†åˆ†æ ZygoteServeræ„é€ æ–¹æ³•æˆ‘ä»¬çŸ¥é“ï¼Œæˆ‘ä»¬Appéƒ½æ˜¯ä»Zygoteå­µåŒ–è€Œæ¥çš„ï¼ŒAppå¯åŠ¨æ˜¯ä»ActivityManagerServiceçš„startActivityæ–¹æ³•å¼€å§‹çš„ï¼Œé‚£ä¹ˆAMSæ˜¯æ€ä¹ˆå’ŒZygoteé€šä¿¡çš„å‘¢ï¼Œç­”æ¡ˆæ˜¯é€šè¿‡socket æˆ‘ä»¬å…ˆä»ZygoteServerçš„æ„é€ æ–¹æ³•å¼€å§‹çœ‹èµ· 12345678910ZygoteServer(boolean isPrimaryZygote) &#123; ... if (isPrimaryZygote) &#123; mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME); ... &#125; else &#123; ... &#125; ...&#125; å…¶ä¸­æœ‰ä¸€äº›ä¸œè¥¿æ˜¯å’ŒUSAPæœºåˆ¶æœ‰å…³çš„ï¼Œä½†åœ¨AOSPä¸­é»˜è®¤æ˜¯å…³é—­çš„ï¼Œå…³äºUSAPæœºåˆ¶æˆ‘ä»¬ä»¥åå†åˆ†æï¼Œç°åœ¨åªéœ€è¦å…³æ³¨mZygoteSocketå°±å¯ä»¥äº†ï¼Œå®ƒæ˜¯é€šè¿‡è°ƒç”¨Zygote.createManagedSocketFromInitSocketèµ‹å€¼çš„ 12345678910111213141516171819202122static LocalServerSocket createManagedSocketFromInitSocket(String socketName) &#123; int fileDesc; //ANDROID_SOCKET_zygote final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //è·å¾—æ–‡ä»¶æè¿°ç¬¦ String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(\"Socket unset or invalid: \" + fullSocketName, ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); return new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error building socket from file descriptor: \" + fileDesc, ex); &#125;&#125; å¾ˆç®€å•ï¼Œå°±æ˜¯ä»ç³»ç»Ÿå±æ€§ä¸­è·å–ä¸€ä¸ªfdï¼Œç„¶åå®ä¾‹åŒ–LocalServerSocketï¼Œè·¯å¾„ä¸ºframeworks/base/core/java/android/net/LocalServerSocket.java 123456public LocalServerSocket(FileDescriptor fd) throws IOException&#123; impl = new LocalSocketImpl(fd); impl.listen(LISTEN_BACKLOG); localAddress = impl.getSockAddress();&#125; åœ¨å†…éƒ¨åˆ›å»ºäº†ä¸€ä¸ªLocalSocketImplï¼Œç„¶åè°ƒç”¨äº†listenæ–¹æ³•å£°æ˜å¼€å§‹ç›‘å¬è¿™ä¸ªfdï¼Œå†…éƒ¨è°ƒç”¨äº†Linuxçš„listenå‡½æ•° runSelectLoopç„¶åæˆ‘ä»¬æ¥çœ‹åœ¨ZygoteInitä¸­è°ƒç”¨çš„runSelectLoopæ–¹æ³• 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;(); //å°†server socket fdåŠ åˆ°åˆ—è¡¨å¤´ï¼ˆåé¢éœ€è¦åˆ¤æ–­æ˜¯å¦ä¸ºserver socketï¼‰ socketFDs.add(mZygoteSocket.getFileDescriptor()); peers.add(null); ... while (true) &#123; ... StructPollfd[] pollFDs; ... pollFDs = new StructPollfd[socketFDs.size()]; int pollIndex = 0; for (FileDescriptor socketFD : socketFDs) &#123; pollFDs[pollIndex] = new StructPollfd(); pollFDs[pollIndex].fd = socketFD; pollFDs[pollIndex].events = (short) POLLIN; ++pollIndex; &#125; ... //ä¸Šé¢ä¸€å¤§æ®µéƒ½ä¸USAPæœºåˆ¶æœ‰å…³ï¼Œè¿™é‡Œå…ˆä¸å…³æ³¨ int pollReturnValue; try &#123; //ç­‰å¾…æ–‡ä»¶æè¿°ç¬¦ä¸Šçš„äº‹ä»¶ pollReturnValue = Os.poll(pollFDs, pollTimeoutMs); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; if (pollReturnValue == 0) &#123; //æ²¡æœ‰æ¥æ”¶åˆ°äº‹ä»¶ï¼ˆè¶…æ—¶ï¼‰ï¼Œä»å¾ªç¯å¼€å¤´é‡æ–°å¼€å§‹ç­‰å¾…äº‹ä»¶ ... &#125; else &#123; ... while (--pollIndex &gt;= 0) &#123; //æ²¡æœ‰è¦è¯»å–çš„æ•°æ®ï¼Œè·³è¿‡ if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (pollIndex == 0) &#123; //pollIndex == 0è¯´æ˜è¿™ä¸ªfdæ˜¯ZygoteServer socketçš„fd //æ¥å—å¹¶å»ºç«‹ä¸€ä¸ªsocketè¿æ¥ ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); //å°†client socket fdåŠ å…¥åˆ—è¡¨ socketFDs.add(newPeer.getFileDescriptor()); &#125; else if (pollIndex &lt; usapPoolEventFDIndex) &#123; //ä¸ä½¿ç”¨USAPæœºåˆ¶çš„è¯ï¼ŒpollIndex &lt; usapPoolEventFDIndexæ¡ä»¶ä¸€å®šæˆç«‹ //è¿›å…¥è¿™è¾¹è¯´æ˜æ˜¯client socket try &#123; //å†…éƒ¨æ‰§è¡Œforkï¼Œè¿”å›ä¸€ä¸ªå¾…æ‰§è¡ŒRunnableç”¨äºå¤„ç†å­è¿›ç¨‹åç»­ä»»åŠ¡ ZygoteConnection connection = peers.get(pollIndex); final Runnable command = connection.processOneCommand(this); //forkåï¼Œåœ¨å­è¿›ç¨‹ä¸­ä¼šå°†è¿™ä¸ªå˜é‡è®¾ä¸ºtrue if (mIsForkChild) &#123; //å­è¿›ç¨‹ä¸­ if (command == null) &#123; throw new IllegalStateException(\"command == null\"); &#125; //returnå‡ºå»ï¼Œç”±ZygoteInitæ‰§è¡Œè¿™ä¸ªRunnable return command; &#125; else &#123; //çˆ¶è¿›ç¨‹ä¸­ if (command != null) &#123; throw new IllegalStateException(\"command != null\"); &#125; //è¯»å–å®Œäº†ï¼Œå…³é—­è¿™ä¸ªsocketï¼Œæ¸…ç†åˆ—è¡¨ if (connection.isClosedByPeer()) &#123; connection.closeSocket(); peers.remove(pollIndex); socketFDs.remove(pollIndex); &#125; &#125; &#125; catch (Exception e) &#123; ... &#125; finally &#123; mIsForkChild = false; &#125; &#125; else &#123; ... //ä¸å¼€å¯USAPæœºåˆ¶ä¸ä¼šèµ°åˆ°è¿™ä¸ªåˆ†æ”¯ &#125; &#125; ... &#125; ... &#125;&#125; åˆ›å»ºä¸¤ä¸ªåˆ—è¡¨ï¼ŒsocketFDså’Œpeersçš„ä¸‹æ ‡æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œé¦–å…ˆå°†server socket fdæ·»åŠ åˆ°åˆ—è¡¨å¤´ï¼Œæ–¹ä¾¿åç»­åˆ¤æ–­äº‹ä»¶æ˜¯æ¥è‡ªclientæˆ–æ˜¯server sockerï¼Œpeersåˆ—è¡¨ä¹Ÿè¦æ·»åŠ ä¸€ä¸ªnullä½œä¸ºsocketFDsçš„å¯¹åº” æ¥ç€å°±å¼€å§‹æ‰§è¡Œæ­»å¾ªç¯ï¼ŒZygoteè¿›ç¨‹æ°¸è¿œä¸ä¼šé€€å‡ºè¿™ä¸ªå¾ªç¯ï¼Œåªæœ‰forkå‡ºå­è¿›ç¨‹åï¼Œå­è¿›ç¨‹ä¼šä¸»åŠ¨return pollä¸ºäº†ç†è§£åé¢çš„å†…å®¹ï¼Œæˆ‘ä»¬å…ˆè¦å­¦ä¹ ä¸€ä¸‹pollå‡½æ•° pollæ˜¯Linuxä¸­çš„å­—ç¬¦è®¾å¤‡é©±åŠ¨ä¸­çš„ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„ä½œç”¨æ˜¯ç­‰å¾…æ–‡ä»¶æè¿°ç¬¦ä¸Šçš„æŸä¸ªäº‹ä»¶ åŸå‹ï¼šint poll(struct pollfd * fds , nfds_t nfds , int timeout ); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/poll.2.html ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªpollfdç»“æ„ä½“æŒ‡é’ˆ 12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; fdä¸ç”¨å¤šè¯´ï¼Œå°±æ˜¯æ–‡ä»¶æè¿°ç¬¦ eventä»£è¡¨å…³æ³¨å“ªäº›äº‹ä»¶ï¼ŒPOLLINä»£è¡¨å¯è¯»ï¼ŒPOLLOUTä»£è¡¨å¯å†™ç­‰ç­‰ reventsæ˜¯ç”±å†…æ ¸é€šçŸ¥çš„ï¼Œå‡½æ•°è¿”å›çš„æ—¶å€™ï¼Œä¼šè®¾ç½®å¯¹åº”çš„fdå®é™…å‘ç”Ÿçš„äº‹ä»¶ï¼Œæ¯”å¦‚fdæœ‰å¯è¯»çš„äº‹ä»¶ï¼Œè®¾ç½®POLLIN ç¬¬äºŒä¸ªå‚æ•°nfdsè¡¨ç¤ºfdçš„ä¸ªæ•°ï¼Œå³pollfdæ•°ç»„çš„size ç¬¬ä¸‰ä¸ªå‚æ•°è¡¨ç¤ºè¶…æ—¶æ—¶é—´ è¿”å›å€¼ï¼š å¤§äº0ï¼šè¡¨ç¤ºæœ‰fdäº‹ä»¶äº§ç”Ÿï¼Œå€¼ä¸ºæœ‰äº§ç”Ÿäº‹ä»¶çš„fdçš„ä¸ªæ•° ç­‰äº0ï¼šè¡¨ç¤ºè¶…æ—¶ å°äº0ï¼šè¡¨ç¤ºæœ‰é”™è¯¯äº§ç”Ÿ StructPollfd &amp; pollfdå¼„æ‡‚pollæ˜¯å¹²å˜›çš„åï¼Œæˆ‘ä»¬å†æ¥æ¥ç€çœ‹runSelectLoopæ–¹æ³• æ­»å¾ªç¯ä¸­é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªStructPollfdæ•°ç»„ï¼Œå®ƒæ ¹æ®socketFDsä¾æ¬¡åˆ›å»ºå‡ºä¸€ä¸ªä¸ªStructPollfdå¯¹è±¡ï¼Œå¹¶å°†ä»–ä»¬çš„äº‹ä»¶éƒ½è®¾ä¸ºPOLLINå¯è¯» StructPollfdå’Œcä¸­çš„ç»“æ„ä½“pollfdæ˜¯å¯¹åº”çš„ï¼Œç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿Javaå±‚è°ƒç”¨Linuxçš„pollå‡½æ•° StructPollfdçš„è·¯å¾„ä¸ºlibcore/luni/src/main/java/android/system/StructPollfd.java 1234567public final class StructPollfd &#123; public FileDescriptor fd; public short events; public short revents; public Object userData; ...&#125; è°ƒç”¨ç„¶åè°ƒç”¨Os.pollæ–¹æ³• å…³äºOsæˆ‘ä»¬ä¸Šé¢åˆšåˆ†æè¿‡ï¼ŒçŸ¥é“ä»–è°ƒç”¨äº†JNIå‡½æ•°ï¼Œnativeå‡½æ•°å‘½åæ ¼å¼ä¸ºLinux_å‡½æ•°åï¼Œæˆ‘ä»¬å»libcore/luni/src/main/native/libcore_io_Linux.cppä¸­æ‰¾ä¸€ä¸‹ 123456789101112131415161718static jint Linux_poll(JNIEnv* env, jobject, jobjectArray javaStructs, jint timeoutMs) &#123; ... //æŠŠJavaå¯¹è±¡StructPollfdæ•°ç»„è½¬æ¢æˆcä¸­çš„struct pollfdæ•°ç»„ int rc; while (true) &#123; ... rc = poll(fds.get(), count, timeoutMs); if (rc &gt;= 0 || errno != EINTR) &#123; break; &#125; ... &#125; if (rc == -1) &#123; throwErrnoException(env, \"poll\"); return -1; &#125; ... //è®¾ç½®Javaå¯¹è±¡StructPollfdçš„reventså€¼ return rc;&#125; ç®€å•çœ‹ä¸€ä¸‹ï¼Œå°±æ˜¯æŠŠä¼ è¿›å»çš„StructPollfdæ•°ç»„è½¬æ¢æˆäº†struct pollfdæ•°ç»„ï¼Œç„¶åè°ƒç”¨Linux pollå‡½æ•°ï¼Œå†æŠŠreventså†™è¿›StructPollfdå¯¹è±¡ä¸­ï¼Œæœ€åè¿”å› å†çœ‹å›runSelectLoopæ–¹æ³•ï¼Œå¦‚æœpollæ‰§è¡Œè¿”å›å€¼ä¸º-1ï¼Œä¼šç›´æ¥å¼•å‘ä¸€ä¸ªJavaå¼‚å¸¸ï¼Œå…¶ä»–æƒ…å†µå…ˆåˆ¤æ–­ä¸€ä¸‹pollçš„è¿”å›å€¼ï¼Œå¦‚æœä¸º0ï¼Œåˆ™æ²¡æœ‰äº‹ä»¶äº§ç”Ÿï¼Œå¦åˆ™ä¼šä»åå‘å‰ä¾æ¬¡åˆ¤æ–­pollFDsçš„reventsï¼Œå¦‚æœä¸ºPOLLINå¯è¯»ï¼Œåˆ™å¤„ç†ï¼Œä¸å¯è¯»åˆ™è·³è¿‡ å»ºç«‹è¿æ¥æˆ‘ä»¬å…ˆçœ‹ç¬¬ä¸€æ¬¡pollåˆ°äº‹ä»¶çš„æƒ…å†µï¼Œè¿™æ—¶å€™ï¼ŒpollFDsä¸­åªæœ‰ä¸€ä¸ªzygote socket fdï¼Œæ”¶åˆ°å¯è¯»äº‹ä»¶ï¼Œè¯´æ˜æœ‰å®¢æˆ·ç«¯socketå‘zygote socketè¯·æ±‚å‘èµ·è¿æ¥ï¼Œè¿™æ—¶å€™æˆ‘ä»¬è°ƒç”¨acceptCommandPeeræ–¹æ³•å»ºç«‹æ–°è¿æ¥ 12345678private ZygoteConnection acceptCommandPeer(String abiList) &#123; try &#123; return createNewConnection(mZygoteSocket.accept(), abiList); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"IOException during accept()\", ex); &#125;&#125; è°ƒç”¨äº†mZygoteSocket.acceptæ–¹æ³• 12345678public LocalSocket accept() throws IOException&#123; LocalSocketImpl acceptedImpl = new LocalSocketImpl(); impl.accept(acceptedImpl); return LocalSocket.createLocalSocketForAccept(acceptedImpl);&#125; æ–°å»ºäº†ä¸€ä¸ªLocalSocketImpl(client socket) å®ä¾‹ï¼Œç„¶åè°ƒç”¨LocalSocketImpl(zygote socket) çš„acceptæ–¹æ³• 123456789101112protected void accept(LocalSocketImpl s) throws IOException &#123; if (fd == null) &#123; throw new IOException(\"socket not created\"); &#125; try &#123; s.fd = Os.accept(fd, null /* address */); s.mFdCreatedInternally = true; &#125; catch (ErrnoException e) &#123; throw e.rethrowAsIOException(); &#125;&#125; è°ƒç”¨äº†Linuxçš„acceptå‡½æ•°ï¼Œæ¥å—å»ºç«‹è¿æ¥ï¼Œå¹¶è¿”å›äº†ä¸€ä¸ªæ–°çš„client socket fdï¼Œå°†LocalSocketImplä¸­çš„fdå˜é‡è®¾ç½®ä¸ºè¿™ä¸ªfdï¼Œæ¥ç€è°ƒç”¨LocalSocket.createLocalSocketForAcceptå°†LocalSocketImplåŒ…è£…æˆLocalSocket 1234567891011static LocalSocket createLocalSocketForAccept(LocalSocketImpl impl) &#123; return createConnectedLocalSocket(impl, SOCKET_UNKNOWN);&#125;private static LocalSocket createConnectedLocalSocket(LocalSocketImpl impl, int sockType) &#123; LocalSocket socket = new LocalSocket(impl, sockType); socket.isConnected = true; socket.isBound = true; socket.implCreated = true; return socket;&#125; ç„¶åä½¿ç”¨è¿™ä¸ªLocalSocketåˆ›å»ºäº†ä¸€ä¸ªZygoteConnectionåŒ…è£…socketè¿æ¥ 1234protected ZygoteConnection createNewConnection(LocalSocket socket, String abiList) throws IOException &#123; return new ZygoteConnection(socket, abiList);&#125; æˆ‘ä»¬çœ‹ä¸€ä¸‹æ„é€ æ–¹æ³•åšäº†ä»€ä¹ˆ 1234567891011ZygoteConnection(LocalSocket socket, String abiList) throws IOException &#123; mSocket = socket; this.abiList = abiList; mSocketOutStream = new DataOutputStream(socket.getOutputStream()); mSocketReader = new BufferedReader( new InputStreamReader(socket.getInputStream()), Zygote.SOCKET_BUFFER_SIZE); ... isEof = false;&#125; æ‰“å¼€äº†client socketçš„è¾“å…¥è¾“å‡ºæµï¼Œå‡†å¤‡è¯»å†™æ•°æ®äº† ç„¶åå°†è¿™ä¸ªè¿æ¥å’Œfdåˆ†åˆ«æ·»åŠ è¿›peerså’ŒsocketFDs æ‰§è¡Œclient socketå‘½ä»¤åœ¨ç¬¬äºŒæ¬¡å¾ªç¯ä¸­pollFDsæ•°ç»„ä¸­ä¾¿åŒ…æ‹¬äº†æ–°å»ºç«‹è¿æ¥çš„client socketäº†ï¼Œè¿™æ—¶è°ƒç”¨Os.pollï¼Œå¯ä»¥è·å¾—åˆ°è¿™ä¸ªclient socketçš„å¯è¯»äº‹ä»¶ï¼Œæ­¤æ—¶è°ƒç”¨connection.processOneCommandæ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Runnable processOneCommand(ZygoteServer zygoteServer) &#123; String[] args; try &#123; //è¯»å–ä»client socketä¼ æ¥çš„å‚æ•° args = Zygote.readArgumentList(mSocketReader); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"IOException on command socket\", ex); &#125; ... int pid; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; //è§£æå‚æ•° ZygoteArguments parsedArgs = new ZygoteArguments(args); ... //ä¸€ç³»åˆ—å‚æ•°æ ¡éªŒå·¥ä½œ //åˆ›å»ºå­è¿›ç¨‹ pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp, parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList, parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs); try &#123; if (pid == 0) &#123; //å­è¿›ç¨‹ä¸­ //è®¾ç½®mIsForkChild = true zygoteServer.setForkChild(); //å­è¿›ç¨‹ä¸­å…³é—­forkå¤åˆ¶æ¥çš„zygote socket zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; //çˆ¶è¿›ç¨‹ä¸­ IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, serverPipeFd); return null; &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; å¯åŠ¨APPè¿›ç¨‹é¦–å…ˆè¯»å–ä»client socketä¼ æ¥çš„å‚æ•°ï¼Œç„¶åæ ¡éªŒè¿™äº›å‚æ•°ï¼Œå®Œæ¯•åè°ƒç”¨Zygote.forkAndSpecializeæ–¹æ³•forkå‡ºå­è¿›ç¨‹ 12345678910111213141516171819static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir, boolean isTopApp, String[] pkgDataInfoList, String[] whitelistedDataInfoList, boolean bindMountAppDataDirs, boolean bindMountAppStorageDirs) &#123; //åœæ­¢å…¶ä»–çº¿ç¨‹ ZygoteHooks.preFork(); //forkè¿›ç¨‹ int pid = nativeForkAndSpecialize( uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose, fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList, whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs); ... //æ¢å¤å…¶ä»–çº¿ç¨‹ ZygoteHooks.postForkCommon(); return pid;&#125; Zygoteè¿›ç¨‹å¯åŠ¨äº†4ä¸ªçº¿ç¨‹ï¼š HeapTaskDaemon ReferenceQueueDaemon FinalizerDaemon FinalizerWatchdogDaemon ä¹‹å‰ä¸Šé¢ä¹Ÿåˆ†æè¿‡äº†å¤šçº¿ç¨‹å¯¹forkä¼šäº§ç”Ÿå½±å“ï¼Œæ‰€ä»¥è¿™é‡Œå…ˆæŠŠå…¶ä»–çº¿ç¨‹åœäº†ï¼Œç­‰forkå®Œäº†å†é‡æ–°å¯åŠ¨ ç„¶åæ‰§è¡Œnativeå‡½æ•°nativeForkAndSpecializeï¼Œè·¯å¾„ä¸ºframeworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223static jint com_android_internal_os_Zygote_nativeForkAndSpecialize( JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) &#123; ... pid_t pid = ForkCommon(env, false, fds_to_close, fds_to_ignore, true); if (pid == 0) &#123; SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, capabilities, capabilities, mount_external, se_info, nice_name, false, is_child_zygote == JNI_TRUE, instruction_set, app_data_dir, is_top_app == JNI_TRUE, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs == JNI_TRUE, mount_storage_dirs == JNI_TRUE); &#125; return pid;&#125; å…ˆè°ƒç”¨ForkCommonï¼Œå†åœ¨å­è¿›ç¨‹è°ƒç”¨SpecializeCommon 123456789101112131415161718static pid_t ForkCommon(JNIEnv* env, bool is_system_server, const std::vector&lt;int&gt;&amp; fds_to_close, const std::vector&lt;int&gt;&amp; fds_to_ignore, bool is_priority_fork) &#123; //è®¾ç½®å­è¿›ç¨‹ä¿¡å·å¤„ç†å‡½æ•° SetSignalHandlers(); ... //forkå‰å…ˆé˜»å¡SIGCHLDä¿¡å· BlockSignal(SIGCHLD, fail_fn); ... //æ‰§è¡Œfork pid_t pid = fork(); ... //æ¢å¤SIGCHLDä¿¡å· UnblockSignal(SIGCHLD, fail_fn); return pid;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities, jint mount_external, jstring managed_se_info, jstring managed_nice_name, bool is_system_server, bool is_child_zygote, jstring managed_instruction_set, jstring managed_app_data_dir, bool is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, bool mount_data_dirs, bool mount_storage_dirs) &#123; const char* process_name = is_system_server ? \"system_server\" : \"zygote\"; ... //åˆ›å»ºè¿›ç¨‹ç»„ if (!is_system_server &amp;&amp; getuid() == 0) &#123; const int rc = createProcessGroup(uid, getpid()); if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else if (rc != 0) &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, /* pid= */ 0, strerror(-rc)); &#125; &#125; //è®¾ç½®GroupId SetGids(env, gids, is_child_zygote, fail_fn); //è®¾ç½®èµ„æºLimit SetRLimits(env, rlimits, fail_fn); ... //è®¾ç½®è°ƒåº¦ç­–ç•¥ SetSchedulerPolicy(fail_fn, is_top_app); ... //è®¾ç½®çº¿ç¨‹å if (nice_name.has_value()) &#123; SetThreadName(nice_name.value()); &#125; else if (is_system_server) &#123; SetThreadName(\"system_server\"); &#125; //å­è¿›ç¨‹ä¸­ä¸å†å¤„ç†SIGCHLDä¿¡å· UnsetChldSignalHandler(); ... if (is_child_zygote) &#123; initUnsolSocketToSystemServer(); &#125; //è°ƒç”¨Zygote.callPostForkChildHooksæ–¹æ³• env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set); //è®¾ç½®é»˜è®¤è¿›ç¨‹ä¼˜å…ˆçº§ setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_DEFAULT); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork hooks.\"); &#125;&#125; å­è¿›ç¨‹åˆ›å»ºå®Œæˆåï¼ŒZygoteConnectionåœ¨å­è¿›ç¨‹ä¸­ä¼šè¿”å›handleChildProcï¼Œåœ¨çˆ¶è¿›ç¨‹ä¸­ä¼šè¿”å›null åœ¨ZygoteServerä¸­åšäº†åˆ¤æ–­ï¼Œå¦‚æœä¸ºå­è¿›ç¨‹ä¸”commandä¸ä¸ºnullï¼Œè¿”å›commonåˆ°ZygoteInitï¼Œå¦‚æœæ˜¯çˆ¶è¿›ç¨‹ï¼Œç»§ç»­socket pollå¾ªç¯ åœ¨ZygoteInit.runSelectLoopåï¼Œå¦‚æœè¿”å›å€¼callerï¼ˆå¯¹åº”ZygoteServerä¸­çš„commandï¼‰ä¸ä¸ºnullï¼Œåˆ™æ‰§è¡Œè¿™ä¸ªRunnable æˆ‘ä»¬çœ‹ä¸€ä¸‹handleChildProcåšäº†ä»€ä¹ˆ 1234567891011121314151617181920212223242526272829private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor pipeFd, boolean isZygote) &#123; //åœ¨å­è¿›ç¨‹ä¸­å…³é—­å‘èµ·å¯åŠ¨Appè¯·æ±‚çš„client socket closeSocket(); //è®¾ç½®è¿›ç¨‹å Zygote.setAppProcessName(parsedArgs, TAG); ... if (parsedArgs.mInvokeWith != null) &#123; //å’Œè¿›ç¨‹å†…å­˜æ³„éœ²æˆ–æº¢å‡ºæœ‰å…³ï¼Ÿ WrapperInit.execApplication(parsedArgs.mInvokeWith, parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.mRemainingArgs); // Should not get here. throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\"); &#125; else &#123; if (!isZygote) &#123; //æ ¹æ®å‚æ•°ï¼Œæ‰§è¡Œè¿™ä¸ªæ–¹æ³• return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; else &#123; return ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; &#125;&#125; æ‰§è¡ŒZygoteInit.zygoteInit 123456789101112public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... //é‡å®šå‘Log RuntimeInit.redirectLogStreams(); //é€šç”¨åˆå§‹åŒ– RuntimeInit.commonInit(); //ä¹‹å‰æœ‰æåˆ°ï¼Œå¼€å¯binderçº¿ç¨‹æ±  ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);&#125; RuntimeInitçš„è·¯å¾„ä¸ºframeworks/base/core/java/com/android/internal/os/RuntimeInit.javaï¼Œå…ˆæ‰§è¡Œé€šç”¨åˆå§‹åŒ– 12345678910111213141516171819202122protected static final void commonInit() &#123; //è®¾ç½®é»˜è®¤çº¿ç¨‹å¼‚å¸¸å¤„ç†å™¨ LoggingHandler loggingHandler = new LoggingHandler(); RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler); Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); //è®¾ç½®æ—¶åŒº RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(\"persist.sys.timezone\")); //é‡ç½®Logé…ç½® LogManager.getLogManager().reset(); new AndroidConfig(); //è®¾ç½®ç½‘ç»œUAä¿¡æ¯ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); //åˆå§‹åŒ–ç½‘ç»œæµé‡ç»Ÿè®¡ NetworkManagementSocketTagger.install(); ... initialized = true;&#125; ç„¶åæ‰§è¡ŒRuntimeInit.applicationInit 12345678910111213protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; //å¦‚æœåº”ç”¨ç¨‹åºè°ƒç”¨System.exit()ï¼Œåˆ™ç«‹å³ç»ˆæ­¢è¯¥è¿›ç¨‹ï¼Œä¸è¿è¡Œä»»ä½•hookå‡½æ•° nativeSetExitWithoutCleanup(true); //è®¾ç½®è™šæ‹Ÿæœºå‚æ•° VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges); //è§£æå‚æ•° final Arguments args = new Arguments(argv); ... //æŸ¥æ‰¾startClassä¸­çš„mainæ–¹æ³• return findStaticMain(args.startClass, args.startArgs, classLoader);&#125; è¿™é‡Œçš„startClassä¸ºandroid.app.ActivityThread 12345678910111213141516171819202122232425262728293031323334353637protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv);&#125; è¿™é‡Œä½¿ç”¨äº†Javaä¸­çš„åå°„ï¼Œæ‰¾åˆ°äº†ActivityThreadä¸­å¯¹åº”çš„mainæ–¹æ³•ï¼Œå¹¶ç”¨å…¶åˆ›å»ºäº†ä¸€ä¸ªRunnableå¯¹è±¡MethodAndArgsCaller 1234567891011121314151617181920212223242526static class MethodAndArgsCaller implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; //æ‰§è¡ŒActivityThread.mainæ–¹æ³• mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; ä¹‹å‰è¯´äº†ï¼Œåœ¨ZygoteInit.runSelectLoopåï¼Œå¦‚æœè¿”å›å€¼callerä¸ä¸ºnullï¼Œåˆ™æ‰§è¡Œè¿™ä¸ªRunnableï¼Œå³æ‰§è¡ŒMethodAndArgsCallerçš„runæ–¹æ³•ï¼Œåå°„è°ƒç”¨ActivityThread.mainæ–¹æ³• ç»“æŸè‡³æ­¤ï¼ŒZygoteè¿›ç¨‹éƒ¨åˆ†çš„åˆ†æå°±åˆ°æ­¤ä¸ºæ­¢äº†ï¼Œåé¢forkå‡ºAppè¿›ç¨‹é‚£æ®µè®²çš„å¾ˆç²—ç³™ï¼Œåé¢å†™åˆ°Appå¯åŠ¨é‚£å—çš„æ—¶å€™ï¼Œæˆ‘ä¼šé‡æ–°æ¢³ç†ä¸€éè¿™é‡Œçš„é€»è¾‘ï¼Œè¡¥å……ä¸Šå»","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Zygote","slug":"Zygote","permalink":"http://yoursite.com/tags/Zygote/"}]},{"title":"Androidæºç åˆ†æ - initè¿›ç¨‹","slug":"android/aosp/Androidæºç åˆ†æ-initè¿›ç¨‹","date":"2022-01-04T09:19:00.000Z","updated":"2022-11-13T09:55:54.357Z","comments":true,"path":"2022/01/04/android/aosp/Androidæºç åˆ†æ-initè¿›ç¨‹/","link":"","permalink":"http://yoursite.com/2022/01/04/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-init%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"å¼€ç¯‡æœ¬ç¯‡ä»¥android-11.0.0_r25ä½œä¸ºåŸºç¡€è§£æ PCå¯åŠ¨ä¼šé€šè¿‡BIOSå¼•å¯¼ï¼Œä»0x7c00å¤„æ‰¾åˆ°ä»¥0xaa55ä¸ºç»“å°¾çš„å¼•å¯¼ç¨‹åºå¯åŠ¨ã€‚è€ŒAndroidé€šå¸¸ä½¿ç”¨åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œæ²¡æœ‰PCçš„BIOSï¼Œå–è€Œä»£ä¹‹çš„æ˜¯BootLoaderã€‚ BootLoaderåœ¨CPUä¸Šç”µå¤ä½å®Œæˆåï¼Œä¼šä»ä¸€ä¸ªå›ºå®šçš„åœ°å€åŠ è½½ä¸€æ®µç¨‹åºï¼Œå³BootLoaderï¼Œä¸åŒçš„CPUå¯èƒ½è¿™ä¸ªåœ°å€ä¸åŒã€‚BootLoaderæ˜¯ä¸€æ®µå¼•å¯¼ç¨‹åºï¼Œå…¶ä¸­æœ€ä¸ºå¸¸è§çš„ä¸ºU-bootï¼Œå®ƒä¸€èˆ¬ä¼šå…ˆæ£€æµ‹ç”¨æˆ·æ˜¯å¦æŒ‰ä¸‹æŸäº›ç‰¹åˆ«æŒ‰é”®ï¼Œè¿™äº›ç‰¹åˆ«æŒ‰é”®æ˜¯ubootåœ¨ç¼–è¯‘æ—¶é¢„å…ˆè¢«çº¦å®šå¥½çš„ï¼Œç”¨äºè¿›å…¥è°ƒè¯•æ¨¡å¼ã€‚å¦‚æœç”¨æˆ·æ²¡æœ‰æŒ‰è¿™äº›ç‰¹åˆ«çš„æŒ‰é”®ï¼Œåˆ™ubootä¼šä»NAND Flashä¸­è£…è½½Linuxå†…æ ¸ï¼Œè£…è½½çš„åœ°å€æ˜¯åœ¨ç¼–è¯‘ubootæ—¶é¢„å…ˆçº¦å®šå¥½çš„ã€‚ è¿›ç¨‹idleLinuxå†…æ ¸å¯åŠ¨åï¼Œä¾¿ä¼šåˆ›å»ºç¬¬ä¸€ä¸ªè¿›ç¨‹idleã€‚idleè¿›ç¨‹æ˜¯Linuxä¸­çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œpidä¸º0ï¼Œæ˜¯å”¯ä¸€ä¸€ä¸ªæ²¡æœ‰é€šè¿‡forkäº§ç”Ÿçš„è¿›ç¨‹ï¼Œå®ƒçš„ä¼˜å…ˆçº§éå¸¸ä½ï¼Œç”¨äºCPUæ²¡æœ‰ä»»åŠ¡çš„æ—¶å€™è¿›è¡Œç©ºè½¬ã€‚ initinitè¿›ç¨‹ç”±idleè¿›ç¨‹åˆ›å»ºï¼Œæ˜¯Linuxç³»ç»Ÿçš„ç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹ï¼Œpidä¸º1ï¼Œæ˜¯ç³»ç»Ÿæ‰€æœ‰ç”¨æˆ·è¿›ç¨‹çš„ç›´æ¥æˆ–é—´æ¥çˆ¶è¿›ç¨‹ï¼Œæœ¬ç¯‡é‡ç‚¹è®²çš„å°±æ˜¯å®ƒã€‚ kthreaddkthreaddè¿›ç¨‹åŒæ ·ç”±idleè¿›ç¨‹åˆ›å»ºï¼Œpidä¸º2ï¼Œå®ƒå§‹ç»ˆè¿è¡Œåœ¨å†…æ ¸ç©ºé—´ï¼Œè´Ÿè´£æ‰€æœ‰å†…æ ¸çº¿ç¨‹çš„è°ƒåº¦ä¸ç®¡ç†ã€‚ initè¿›ç¨‹Androidçš„initè¿›ç¨‹ä»£ç åœ¨system/core/init/main.cppä¸­ï¼Œä»¥mainæ–¹æ³•ä½œä¸ºå…¥å£ï¼Œåˆ†ä¸ºå‡ ä¸ªé˜¶æ®µï¼š 12345678910111213141516171819202122232425262728int main(int argc, char** argv) &#123;#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#endif if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; if (!strcmp(argv[1], \"subcontext\")) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], \"selinux_setup\")) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], \"second_stage\")) &#123; return SecondStageMain(argc, argv); &#125; &#125; return FirstStageMain(argc, argv);&#125; è¿™é‡Œçš„ueventdå’Œsubcontextï¼Œéƒ½æ˜¯åœ¨å„è‡ªå®ˆæŠ¤è¿›ç¨‹ä¸­æ‰§è¡Œçš„ï¼Œä¸åœ¨initè¿›ç¨‹ä¸­æ‰§è¡Œï¼Œè¿™é‡Œå°±ä¸å¤šä»‹ç»äº† FirstStageMainé»˜è®¤ä¸åŠ ä»»ä½•å‚æ•°å¯åŠ¨initçš„è¯ï¼Œä¾¿ä¼šå¼€å§‹initç¬¬ä¸€é˜¶æ®µï¼Œè¿›å…¥åˆ°FirstStageMainå‡½æ•°ä¸­ï¼Œä»£ç åœ¨system/core/init/first_stage_init.cppä¸­ umaskæ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/umask.2.html åŸå‹ï¼šmode_t umask(mode_t mask); è¿™ä¸ªæ–¹æ³•æ˜¯ç”¨æ¥è®¾ç½®åˆ›å»ºç›®å½•æˆ–æ–‡ä»¶æ—¶æ‰€åº”è¯¥èµ‹äºˆæƒé™çš„æ©ç  Linuxä¸­ï¼Œæ–‡ä»¶é»˜è®¤æœ€å¤§æƒé™æ˜¯666ï¼Œç›®å½•æœ€å¤§æƒé™æ˜¯777ï¼Œå½“åˆ›å»ºç›®å½•æ—¶ï¼Œå‡è®¾æ©ç ä¸º022ï¼Œé‚£èµ‹äºˆå®ƒçš„æƒé™ä¸ºï¼ˆ777 &amp; ~022ï¼‰= 755 åœ¨æ‰§è¡Œinitç¬¬ä¸€é˜¶æ®µæ—¶ï¼Œå…ˆæ‰§è¡Œumask(0)ï¼Œä½¿åˆ›å»ºçš„ç›®å½•æˆ–æ–‡ä»¶çš„é»˜è®¤æƒé™ä¸ºæœ€é«˜ åˆ›å»ºç›®å½•ã€è®¾å¤‡èŠ‚ç‚¹ï¼ŒæŒ‚è½½1234567891011121314151617181920212223242526272829303132333435363738394041424344int FirstStageMain(int argc, char** argv) &#123; ...#define CHECKCALL(x) \\ if ((x) != 0) errors.emplace_back(#x \" failed\", errno); // Clear the umask. umask(0); CHECKCALL(clearenv()); CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1)); CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\")); CHECKCALL(mkdir(\"/dev/pts\", 0755)); CHECKCALL(mkdir(\"/dev/socket\", 0755)); CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));#define MAKE_STR(x) __STRING(x) CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));#undef MAKE_STR CHECKCALL(chmod(\"/proc/cmdline\", 0440)); std::string cmdline; android::base::ReadFileToString(\"/proc/cmdline\", &amp;cmdline); gid_t groups[] = &#123;AID_READPROC&#125;; CHECKCALL(setgroups(arraysize(groups), groups)); CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)); CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL)); CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11))); if constexpr (WORLD_WRITABLE_KMSG) &#123; CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11))); &#125; CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8))); CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9))); CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2))); CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3))); CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV, \"mode=0755,uid=0,gid=1000\")); CHECKCALL(mkdir(\"/mnt/vendor\", 0755)); CHECKCALL(mkdir(\"/mnt/product\", 0755)); CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV, \"mode=0755,uid=0,gid=0\"));#undef CHECKCALL ...&#125; åˆå§‹åŒ–æ—¥å¿—SetStdioToDevNullç”±äºLinuxå†…æ ¸æ‰“å¼€äº†/dev/consoleä½œä¸ºæ ‡å‡†è¾“å…¥è¾“å‡ºæµï¼ˆstdin/stdout/stderrï¼‰çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œè€Œinitè¿›ç¨‹åœ¨ç”¨æˆ·ç©ºé—´ï¼Œæ— æƒè®¿é—®/dev/consoleï¼Œåç»­å¦‚æœæ‰§è¡Œprintfçš„è¯å¯èƒ½ä¼šå¯¼è‡´é”™è¯¯ï¼Œæ‰€ä»¥å…ˆè°ƒç”¨SetStdioToDevNullå‡½æ•°æ¥å°†æ ‡å‡†è¾“å…¥è¾“å‡ºæµï¼ˆstdin/stdout/stderrï¼‰ç”¨/dev/nullæ–‡ä»¶æè¿°ç¬¦æ›¿æ¢ /dev/nullè¢«ç§°ä¸ºç©ºè®¾å¤‡ï¼Œæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„è®¾å¤‡æ–‡ä»¶ï¼Œå®ƒä¼šä¸¢å¼ƒä¸€åˆ‡å†™å…¥å…¶ä¸­çš„æ•°æ®ï¼Œè¯»å–å®ƒä¼šç«‹å³å¾—åˆ°ä¸€ä¸ªEOF InitKernelLoggingæ¥ç€è°ƒç”¨InitKernelLoggingå‡½æ•°ï¼Œåˆå§‹åŒ–äº†ä¸€ä¸ªç®€å•çš„kernelæ—¥å¿—ç³»ç»Ÿ åˆ›å»ºè®¾å¤‡ï¼ŒæŒ‚è½½åˆ†åŒº12345678910111213141516171819202122232425262728293031int FirstStageMain(int argc, char** argv) &#123; ... auto want_console = ALLOW_FIRST_STAGE_CONSOLE ? FirstStageConsole(cmdline) : 0; if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline), want_console)) &#123; if (want_console != FirstStageConsoleParam::DISABLED) &#123; LOG(ERROR) &lt;&lt; \"Failed to load kernel modules, starting console\"; &#125; else &#123; LOG(FATAL) &lt;&lt; \"Failed to load kernel modules\"; &#125; &#125; if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123; StartConsole(); &#125; if (ForceNormalBoot(cmdline)) &#123; mkdir(\"/first_stage_ramdisk\", 0755); // SwitchRoot() must be called with a mount point as the target, so we bind mount the // target directory to itself here. if (mount(\"/first_stage_ramdisk\", \"/first_stage_ramdisk\", nullptr, MS_BIND, nullptr) != 0) &#123; LOG(FATAL) &lt;&lt; \"Could not bind mount /first_stage_ramdisk to itself\"; &#125; SwitchRoot(\"/first_stage_ramdisk\"); &#125; ... if (!DoFirstStageMount()) &#123; LOG(FATAL) &lt;&lt; \"Failed to mount required partitions early ...\"; &#125; ...&#125; ç»“æŸè‡³æ­¤ï¼Œç¬¬ä¸€é˜¶æ®µçš„initç»“æŸï¼Œé€šè¿‡execvå‡½æ•°å¸¦å‚æ‰§è¡Œinitæ–‡ä»¶ï¼Œè¿›å…¥SetupSelinux 1234567891011const char* path = \"/system/bin/init\";const char* args[] = &#123;path, \"selinux_setup\", nullptr&#125;;auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);dup2(fd, STDOUT_FILENO);dup2(fd, STDERR_FILENO);close(fd);execv(path, const_cast&lt;char**&gt;(args));// execv() only returns if an error happened, in which case we// panic and never fall through this conditional.PLOG(FATAL) &lt;&lt; \"execv(\\\"\" &lt;&lt; path &lt;&lt; \"\\\") failed\"; execç³»åˆ—å‡½æ•°ç”¨execç³»åˆ—å‡½æ•°å¯ä»¥æŠŠå½“å‰è¿›ç¨‹æ›¿æ¢ä¸ºä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œä¸”æ–°è¿›ç¨‹ä¸åŸè¿›ç¨‹æœ‰ç›¸åŒçš„PIDã€‚ è¿™é‡Œåœ¨æœ«å°¾ç›´æ¥æ‰“logæ˜¯å› ä¸ºï¼Œexecç³»åˆ—å‡½æ•°å¦‚æœæ‰§è¡Œæ­£å¸¸æ˜¯ä¸ä¼šè¿”å›çš„ï¼Œæ‰€ä»¥åªè¦æ‰§è¡Œåˆ°ä¸‹é¢å°±ä»£è¡¨execæ‰§è¡Œå‡ºé”™äº† SetupSelinuxå¯åŠ¨Selinuxå®‰å…¨æœºåˆ¶ï¼Œåˆå§‹åŒ–selinuxï¼ŒåŠ è½½SELinuxè§„åˆ™ï¼Œé…ç½®SELinuxç›¸å…³logè¾“å‡ºï¼Œå¹¶å¯åŠ¨ç¬¬äºŒé˜¶æ®µï¼šSecondStageMain 123456789101112131415161718192021222324252627282930313233343536int SetupSelinux(char** argv) &#123; SetStdioToDevNull(argv); InitKernelLogging(argv); if (REBOOT_BOOTLOADER_ON_PANIC) &#123; InstallRebootSignalHandlers(); &#125; boot_clock::time_point start_time = boot_clock::now(); MountMissingSystemPartitions(); // Set up SELinux, loading the SELinux policy. SelinuxSetupKernelLogging(); SelinuxInitialize(); // We're in the kernel domain and want to transition to the init domain. File systems that // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here, // but other file systems do. In particular, this is needed for ramdisks such as the // recovery image for A/B devices. if (selinux_android_restorecon(\"/system/bin/init\", 0) == -1) &#123; PLOG(FATAL) &lt;&lt; \"restorecon failed of /system/bin/init failed\"; &#125; setenv(kEnvSelinuxStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(), 1); const char* path = \"/system/bin/init\"; const char* args[] = &#123;path, \"second_stage\", nullptr&#125;; execv(path, const_cast&lt;char**&gt;(args)); // execv() only returns if an error happened, in which case we // panic and never return from this function. PLOG(FATAL) &lt;&lt; \"execv(\\\"\" &lt;&lt; path &lt;&lt; \"\\\") failed\"; return 1;&#125; SecondStageMainä½¿ç”¨second_stageå‚æ•°å¯åŠ¨initçš„è¯ï¼Œä¾¿ä¼šå¼€å§‹initç¬¬äºŒé˜¶æ®µï¼Œè¿›å…¥åˆ°SecondStageMainå‡½æ•°ä¸­ï¼Œä»£ç åœ¨system/core/init/init.cppä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127int SecondStageMain(int argc, char** argv) &#123; ... //å’Œç¬¬ä¸€é˜¶æ®µä¸€æ ·ï¼Œåˆå§‹åŒ–æ—¥å¿— SetStdioToDevNull(argv); InitKernelLogging(argv); LOG(INFO) &lt;&lt; \"init second stage started!\"; ... // Set init and its forked children's oom_adj. //è®¾ç½®initè¿›ç¨‹å’Œä»¥åforkå‡ºæ¥çš„è¿›ç¨‹çš„OOMç­‰çº§ï¼Œè¿™é‡Œçš„å€¼ä¸º-1000ï¼Œä¿è¯è¿›ç¨‹ä¸ä¼šå› ä¸ºOOMè¢«æ€æ­» if (auto result = WriteFile(\"/proc/1/oom_score_adj\", StringPrintf(\"%d\", DEFAULT_OOM_SCORE_ADJUST)); !result.ok()) &#123; LOG(ERROR) &lt;&lt; \"Unable to write \" &lt;&lt; DEFAULT_OOM_SCORE_ADJUST &lt;&lt; \" to /proc/1/oom_score_adj: \" &lt;&lt; result.error(); &#125; ... // Indicate that booting is in progress to background fw loaders, etc. //è®¾ç½®ä¸€ä¸ªæ ‡è®°ï¼Œä»£è¡¨æ­£åœ¨å¯åŠ¨è¿‡ç¨‹ä¸­ close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); ... //åˆå§‹åŒ–ç³»ç»Ÿå±æ€§ PropertyInit(); ... // Mount extra filesystems required during second stage init //æŒ‚è½½é¢å¤–çš„æ–‡ä»¶ç³»ç»Ÿ MountExtraFilesystems(); // Now set up SELinux for second stage. //è®¾ç½®SELinux SelinuxSetupKernelLogging(); SelabelInitialize(); SelinuxRestoreContext(); //ä½¿ç”¨epollï¼Œæ³¨å†Œä¿¡å·å¤„ç†å‡½æ•°ï¼Œå®ˆæŠ¤è¿›ç¨‹æœåŠ¡ Epoll epoll; if (auto result = epoll.Open(); !result.ok()) &#123; PLOG(FATAL) &lt;&lt; result.error(); &#125; InstallSignalFdHandler(&amp;epoll); InstallInitNotifier(&amp;epoll); //å¯åŠ¨ç³»ç»Ÿå±æ€§æœåŠ¡ StartPropertyService(&amp;property_fd); ... //è®¾ç½®commandsæŒ‡ä»¤æ‰€å¯¹åº”çš„å‡½æ•°map const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); Action::set_function_map(&amp;function_map); ... //è§£æinit.rcè„šæœ¬ ActionManager&amp; am = ActionManager::GetInstance(); ServiceList&amp; sm = ServiceList::GetInstance(); LoadBootScripts(am, sm); ... //æ„å»ºäº†ä¸€äº›Actionï¼ŒTriggerç­‰äº‹ä»¶å¯¹è±¡åŠ å…¥äº‹ä»¶é˜Ÿåˆ—ä¸­ am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueEventTrigger(\"early-init\"); // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev... am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\"); am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\"); Keychords keychords; am.QueueBuiltinAction( [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123; for (const auto&amp; svc : ServiceList::GetInstance()) &#123; keychords.Register(svc-&gt;keycodes()); &#125; keychords.Start(&amp;epoll, HandleKeychord); return &#123;&#125;; &#125;, \"KeychordInit\"); // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\"); // Don't mount filesystems or start core system services in charger mode. std::string bootmode = GetProperty(\"ro.bootmode\", \"\"); if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\"); &#125; else &#123; am.QueueEventTrigger(\"late-init\"); &#125; // Run all property triggers based on current state of the properties. am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\"); //æ­»å¾ªç¯ï¼Œç­‰å¾…äº‹ä»¶å¤„ç† while (true) &#123; // By default, sleep until something happens. auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;; ... //æ‰§è¡Œä»init.rcè„šæœ¬è§£æå‡ºæ¥çš„æ¯æ¡æŒ‡ä»¤ if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; am.ExecuteOneCommand(); &#125; ... if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; // If there's more work to do, wake up again immediately. if (am.HasMoreCommands()) epoll_timeout = 0ms; &#125; auto pending_functions = epoll.Wait(epoll_timeout); if (!pending_functions.ok()) &#123; LOG(ERROR) &lt;&lt; pending_functions.error(); &#125; else if (!pending_functions-&gt;empty()) &#123; // We always reap children before responding to the other pending functions. This is to // prevent a race where other daemons see that a service has exited and ask init to // start it again via ctl.start before init has reaped it. //å¤„ç†å­è¿›ç¨‹é€€å‡ºåçš„ç›¸å…³äº‹é¡¹ ReapAnyOutstandingChildren(); for (const auto&amp; function : *pending_functions) &#123; (*function)(); &#125; &#125; ... &#125; return 0;&#125; Linux OOM Killeræœºåˆ¶Linuxä¸‹æœ‰ä¸€ç§ OOM KILLER çš„æœºåˆ¶ï¼Œå®ƒä¼šåœ¨ç³»ç»Ÿå†…å­˜è€—å°½çš„æƒ…å†µä¸‹ï¼Œå¯ç”¨è‡ªå·±ç®—æ³•æœ‰é€‰æ‹©æ€§çš„æ€æ‰ä¸€äº›è¿›ç¨‹ï¼Œè¿™ä¸ªç®—æ³•å’Œä¸‰ä¸ªå€¼æœ‰å…³ï¼š /proc/PID/oom_score ,OOM æœ€ç»ˆå¾—åˆ†ï¼Œå€¼è¶Šå¤§è¶Šæœ‰å¯èƒ½è¢«æ€æ‰ /proc/PID/oom_score_adj ï¼Œå–å€¼èŒƒå›´ä¸º-1000åˆ°1000ï¼Œè®¡ç®—oom_scoreæ—¶ä¼šåŠ ä¸Šè¯¥å‚æ•° /proc/PID/oom_adj ï¼Œå–å€¼æ˜¯-17åˆ°+15ï¼Œè¯¥å‚æ•°ä¸»è¦æ˜¯ä¸ºå…¼å®¹æ—§ç‰ˆå†…æ ¸ åœ¨initè¿‡ç¨‹ä¸­ï¼Œä»£ç è®¾ç½®äº†initè¿›ç¨‹å’Œä»¥åforkå‡ºæ¥çš„è¿›ç¨‹çš„OOMç­‰çº§ï¼Œè¿™é‡Œçš„å€¼ä¸º-1000ï¼Œè®¾ç½®ä¸ºè¿™ä¸ªå€¼å°±å¯ä»¥ä¿è¯è¿›ç¨‹æ°¸è¿œä¸ä¼šå› ä¸ºOOMè¢«æ€æ­» è§£æinit.rcè„šæœ¬Android Init Languagercæ–‡ä»¶ï¼Œæ˜¯ç”¨Android Init Languageç¼–å†™çš„ç‰¹æ®Šæ–‡ä»¶ã€‚ç”¨è¿™ç§è¯­æ³•ç¼–å†™çš„æ–‡ä»¶ï¼Œç»Ÿä¸€ç”¨â€.rcâ€åç¼€ å®ƒçš„è¯­æ³•è¯´æ˜å¯ä»¥åœ¨aospæºç system/core/init/README.mdä¸­æ‰¾åˆ°ï¼Œè¿™é‡Œå°±ç®€å•è¯´æ˜ä¸€ä¸‹è¯­æ³•è§„åˆ™ ActionsActionsæ˜¯ä¸€ç³»åˆ—å‘½ä»¤çš„å¼€å§‹ï¼Œä¸€ä¸ªActionä¼šæœ‰ä¸€ä¸ªè§¦å‘å™¨ï¼Œç”¨äºç¡®å®šActionä½•æ—¶æ‰§è¡Œã€‚å½“ä¸€ä¸ªä¸Actionçš„è§¦å‘å™¨åŒ¹é…çš„äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œè¯¥åŠ¨ä½œè¢«æ·»åŠ åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—çš„å°¾éƒ¨ æ ¼å¼å¦‚ä¸‹ï¼š 1234on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt; Triggersï¼ˆè§¦å‘å™¨ï¼‰è§¦å‘å™¨ä½œç”¨äºActionsï¼Œå¯ç”¨äºåŒ¹é…æŸäº›ç±»å‹çš„äº‹ä»¶ï¼Œå¹¶ç”¨äºå¯¼è‡´æ“ä½œå‘ç”Ÿ CommandsCommandså°±æ˜¯ä¸€ä¸ªä¸ªå‘½ä»¤çš„é›†åˆäº† Action, Triggers, Commandså…±åŒç»„æˆäº†ä¸€ä¸ªå•å…ƒï¼Œä¸¾ä¸ªä¾‹å­ï¼š 1234567on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted # A&#x2F;B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote start zygote_secondary ServicesServicesæ˜¯å¯¹ä¸€äº›ç¨‹åºçš„å®šä¹‰ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... å…¶ä¸­ï¼š nameï¼šå®šä¹‰çš„æœåŠ¡å pathnameï¼šè¿™ä¸ªç¨‹åºçš„è·¯å¾„ argumentï¼šç¨‹åºè¿è¡Œçš„å‚æ•° optionï¼šæœåŠ¡é€‰é¡¹ï¼Œåæ–‡å°†ä»‹ç» OptionsOptionsæ˜¯å¯¹Servicesçš„ä¿®é¥°ï¼Œå®ƒä»¬å½±å“ç€æœåŠ¡è¿è¡Œçš„æ–¹å¼å’Œæ—¶é—´ Services, Optionsç»„æˆäº†ä¸€ä¸ªå•å…ƒï¼Œä¸¾ä¸ªä¾‹å­ï¼š 123456789101112131415service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server --socket-name&#x3D;zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse onrestart write &#x2F;sys&#x2F;power&#x2F;state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond task_profiles ProcessCapacityHigh MaxPerformance Importså¯¼å…¥å…¶ä»–çš„rcæ–‡ä»¶æˆ–ç›®å½•è§£æï¼Œå¦‚æœpathæ˜¯ä¸€ä¸ªç›®å½•ï¼Œç›®å½•ä¸­çš„æ¯ä¸ªæ–‡ä»¶éƒ½è¢«è§£æä¸ºä¸€ä¸ªrcæ–‡ä»¶ã€‚å®ƒä¸æ˜¯é€’å½’çš„ï¼ŒåµŒå¥—çš„ç›®å½•å°†ä¸ä¼šè¢«è§£æã€‚ æ ¼å¼å¦‚ä¸‹ï¼š 1import &lt;path&gt; Importsçš„å†…å®¹ä¼šæ”¾åˆ°æœ€åè§£æ ä¸Šæ–‡æ‰€è¿°çš„Commandsï¼ŒOptionsç­‰å…·ä½“å‘½ä»¤ï¼Œå¯ä»¥ç½‘ä¸Šæœç´¢ä¸€ä¸‹ï¼Œæˆ–è€…è‡ªå·±çœ‹system/core/init/README.md Commandsçš„å®šä¹‰å¯ä»¥åœ¨system/core/init/builtins.cppä¸­æ‰¾åˆ° Optionsçš„å®šä¹‰å¯ä»¥åœ¨system/core/init/service_parser.cppä¸­æ‰¾åˆ° è§£æ12345678910111213141516171819202122232425static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123; Parser parser = CreateParser(action_manager, service_list); std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); if (bootscript.empty()) &#123; parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) &#123; late_import_paths.emplace_back(\"/system/etc/init\"); &#125; // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/product/etc/init\")) &#123; late_import_paths.emplace_back(\"/product/etc/init\"); &#125; if (!parser.ParseConfig(\"/odm/etc/init\")) &#123; late_import_paths.emplace_back(\"/odm/etc/init\"); &#125; if (!parser.ParseConfig(\"/vendor/etc/init\")) &#123; late_import_paths.emplace_back(\"/vendor/etc/init\"); &#125; &#125; else &#123; parser.ParseConfig(bootscript); &#125;&#125; è¿™ä¸ªå‡½æ•°ä¼šä»è¿™äº›åœ°æ–¹å¯»æ‰¾rcæ–‡ä»¶è§£æï¼Œ/system/etc/init/hw/init.rcæ˜¯ä¸»rcæ–‡ä»¶ï¼Œå‰©ä¸‹çš„ç›®å½•ï¼Œå¦‚æœsystemåˆ†åŒºå°šæœªæŒ‚è½½çš„è¯ï¼Œå°±æŠŠå®ƒä»¬åŠ å…¥åˆ°late_import_pathsä¸­ï¼Œç­‰åˆ°åé¢mount_allæ—¶å†åŠ è½½ ä¸»rcæ–‡ä»¶åœ¨ç¼–è¯‘å‰çš„ä½ç½®ä¸ºsystem/core/rootdir/init.rc ç®€å•åˆ†æä¸€ä¸‹ï¼š é¦–å…ˆï¼Œä»¥ActionManagerå’ŒServiceListä½œä¸ºå‚æ•°åˆ›å»ºäº†ä¸€ä¸ªParserè§£æå™¨ï¼Œè§£æåçš„ç»“æœä¼šå­˜æ”¾åœ¨ActionManagerå’ŒServiceListä¸­ï¼Œè¿™é‡Œçš„ä¸¤ä¸ªä¼ è¿›æ¥çš„å‚æ•°éƒ½æ˜¯å•ä¾‹æ¨¡å¼ 12345678910Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123; Parser parser; parser.AddSectionParser(\"service\", std::make_unique&lt;ServiceParser&gt;( &amp;service_list, GetSubcontext(), std::nullopt)); parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext())); parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;(&amp;parser)); return parser;&#125; å…ˆåˆ›å»ºäº†ä¸€ä¸ªParserå¯¹è±¡ï¼Œç„¶åå¾€é‡Œé¢æ·»åŠ äº†ServiceParserã€ActionParserä»¥åŠImportParserï¼Œè¿™ä¸‰ä¸ªç±»éƒ½æ˜¯ç»§æ‰¿è‡ªServiceParserï¼Œè¿™é‡Œçš„std::make_uniqueæ˜¯newäº†ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ç”¨å…¶åŸå§‹æŒ‡é’ˆæ„é€ å‡ºäº†ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ æ¥ç€èµ°åˆ°Parser::ParseConfigæ–¹æ³•ä¸­ï¼š 123456bool Parser::ParseConfig(const std::string&amp; path) &#123; if (is_dir(path.c_str())) &#123; return ParseConfigDir(path); &#125; return ParseConfigFile(path);&#125; åˆ¤æ–­æ˜¯å¦æ˜¯ç›®å½•ï¼Œå¦‚æœæ˜¯ç›®å½•ï¼Œå°±æŠŠç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶åŠ å…¥å®¹å™¨ä¸­æ’åºåä¾æ¬¡è§£æ 1234567891011121314151617181920212223242526bool Parser::ParseConfigDir(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing directory \" &lt;&lt; path &lt;&lt; \"...\"; std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir); if (!config_dir) &#123; PLOG(INFO) &lt;&lt; \"Could not import directory '\" &lt;&lt; path &lt;&lt; \"'\"; return false; &#125; dirent* current_file; std::vector&lt;std::string&gt; files; while ((current_file = readdir(config_dir.get()))) &#123; // Ignore directories and only process regular files. if (current_file-&gt;d_type == DT_REG) &#123; std::string current_path = android::base::StringPrintf(\"%s/%s\", path.c_str(), current_file-&gt;d_name); files.emplace_back(current_path); &#125; &#125; // Sort first so we load files in a consistent order (bug 31996208) std::sort(files.begin(), files.end()); for (const auto&amp; file : files) &#123; if (!ParseConfigFile(file)) &#123; LOG(ERROR) &lt;&lt; \"could not import file '\" &lt;&lt; file &lt;&lt; \"'\"; &#125; &#125; return true;&#125; å¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆéƒ½è°ƒç”¨äº†Parser::ParseConfigFileæ–¹æ³• 1234567891011121314bool Parser::ParseConfigFile(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing file \" &lt;&lt; path &lt;&lt; \"...\"; android::base::Timer t; auto config_contents = ReadFile(path); if (!config_contents.ok()) &#123; LOG(INFO) &lt;&lt; \"Unable to read config file '\" &lt;&lt; path &lt;&lt; \"': \" &lt;&lt; config_contents.error(); return false; &#125; ParseData(path, &amp;config_contents.value()); LOG(VERBOSE) &lt;&lt; \"(Parsing \" &lt;&lt; path &lt;&lt; \" took \" &lt;&lt; t &lt;&lt; \".)\"; return true;&#125; ä»æ–‡ä»¶ä¸­è¯»å–å‡ºå­—ç¬¦ä¸²ï¼Œå¹¶ç»§ç»­è°ƒç”¨Parser::ParseDataæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788void Parser::ParseData(const std::string&amp; filename, std::string* data) &#123; data-&gt;push_back('\\n'); // TODO: fix tokenizer data-&gt;push_back('\\0'); parse_state state; state.line = 0; state.ptr = data-&gt;data(); state.nexttoken = 0; SectionParser* section_parser = nullptr; int section_start_line = -1; std::vector&lt;std::string&gt; args; // If we encounter a bad section start, there is no valid parser object to parse the subsequent // sections, so we must suppress errors until the next valid section is found. bool bad_section_found = false; auto end_section = [&amp;] &#123; bad_section_found = false; if (section_parser == nullptr) return; if (auto result = section_parser-&gt;EndSection(); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; section_start_line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; section_parser = nullptr; section_start_line = -1; &#125;; for (;;) &#123; switch (next_token(&amp;state)) &#123; case T_EOF: end_section(); for (const auto&amp; [section_name, section_parser] : section_parsers_) &#123; section_parser-&gt;EndFile(); &#125; return; case T_NEWLINE: &#123; state.line++; if (args.empty()) break; // If we have a line matching a prefix we recognize, call its callback and unset any // current section parsers. This is meant for /sys/ and /dev/ line entries for // uevent. auto line_callback = std::find_if( line_callbacks_.begin(), line_callbacks_.end(), [&amp;args](const auto&amp; c) &#123; return android::base::StartsWith(args[0], c.first); &#125;); if (line_callback != line_callbacks_.end()) &#123; end_section(); if (auto result = line_callback-&gt;second(std::move(args)); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; &#125; else if (section_parsers_.count(args[0])) &#123; end_section(); section_parser = section_parsers_[args[0]].get(); section_start_line = state.line; if (auto result = section_parser-&gt;ParseSection(std::move(args), filename, state.line); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); section_parser = nullptr; bad_section_found = true; &#125; &#125; else if (section_parser) &#123; if (auto result = section_parser-&gt;ParseLineSection(std::move(args), state.line); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; &#125; else if (!bad_section_found) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": Invalid section keyword found\"; &#125; args.clear(); break; &#125; case T_TEXT: args.emplace_back(state.text); break; &#125; &#125;&#125; è¿™é‡Œæ–°å»ºäº†ä¸€ä¸ªparse_stateç»“æ„ä½“ï¼Œç”¨æ¥ä»¥è¡Œä¸ºå•ä½ï¼Œåˆ†å‰²æ•´ä¸ªæ–‡ä»¶å­—ç¬¦ä¸²ï¼Œæ ¹æ®åˆ†å‰²å‡ºæ¥çš„ç»“æœè¿”å›ç›¸åº”çš„TYPEï¼ŒParser::ParseDataæ–¹æ³•å†é€šè¿‡TYPEæ¥åšé€è¡Œè§£æ è¿™ä¸ªç»“æ„ä½“ä»¥åŠTPYEå’Œåˆ†å‰²åˆ†å‰²æ–¹æ³•çš„å®šä¹‰åœ¨system/core/init/tokenizer.hä¸­ï¼Œåœ¨system/core/init/tokenizer.cppä¸­å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122int next_token(struct parse_state *state)&#123; char *x = state-&gt;ptr; char *s; if (state-&gt;nexttoken) &#123; int t = state-&gt;nexttoken; state-&gt;nexttoken = 0; return t; &#125; for (;;) &#123; switch (*x) &#123; case 0: state-&gt;ptr = x; return T_EOF; case '\\n': x++; state-&gt;ptr = x; return T_NEWLINE; case ' ': case '\\t': case '\\r': x++; continue; case '#': while (*x &amp;&amp; (*x != '\\n')) x++; if (*x == '\\n') &#123; state-&gt;ptr = x+1; return T_NEWLINE; &#125; else &#123; state-&gt;ptr = x; return T_EOF; &#125; default: goto text; &#125; &#125;textdone: state-&gt;ptr = x; *s = 0; return T_TEXT;text: state-&gt;text = s = x;textresume: for (;;) &#123; switch (*x) &#123; case 0: goto textdone; case ' ': case '\\t': case '\\r': x++; goto textdone; case '\\n': state-&gt;nexttoken = T_NEWLINE; x++; goto textdone; case '\"': x++; for (;;) &#123; switch (*x) &#123; case 0: /* unterminated quoted thing */ state-&gt;ptr = x; return T_EOF; case '\"': x++; goto textresume; default: *s++ = *x++; &#125; &#125; break; case '\\\\': x++; switch (*x) &#123; case 0: goto textdone; case 'n': *s++ = '\\n'; x++; break; case 'r': *s++ = '\\r'; x++; break; case 't': *s++ = '\\t'; x++; break; case '\\\\': *s++ = '\\\\'; x++; break; case '\\r': /* \\ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */ if (x[1] != '\\n') &#123; x++; continue; &#125; x++; FALLTHROUGH_INTENDED; case '\\n': /* \\ &lt;lf&gt; -&gt; line continuation */ state-&gt;line++; x++; /* eat any extra whitespace */ while((*x == ' ') || (*x == '\\t')) x++; continue; default: /* unknown escape -- just copy */ *s++ = *x++; &#125; continue; default: *s++ = *x++; &#125; &#125; return T_EOF;&#125; ç®€å•æ¥è¯´å°±æ˜¯å…ˆçœ‹çœ‹æœ‰æ²¡æœ‰é‡åˆ°ç»“æŸç¬¦ï¼ˆæ¢è¡Œ \\n æˆ–è€…EOF \\0ï¼‰æˆ–è€…æ³¨é‡Šï¼ˆ#ï¼‰å¦‚æœé‡åˆ°äº†å°±è¿”å›T_NEWLINEæˆ–è€…T_EOFä»£è¡¨è¿™ä¸Šä¸€è¡Œç»“æŸäº†æˆ–è€…æ•´ä¸ªæ–‡ä»¶è¯»å–å®Œäº†ï¼Œæ²¡æœ‰é‡åˆ°çš„è¯è¯´æ˜è¯»å–çš„æ˜¯å¯è§£æçš„æ­£æ–‡ï¼Œè·³åˆ°textæ®µï¼Œå°†æ–‡æœ¬å†…å®¹å†™åˆ°state.textä¸­ï¼Œç›´åˆ°ç¢°åˆ°æ¢è¡Œç¬¦æˆ–ç©ºæ ¼ç­‰åˆ†å‰²æ ‡å¿—ï¼ˆä»¥ç©ºæ ¼æˆ–æ¢è¡Œç­‰ä½œä¸ºåˆ†éš”ç¬¦ï¼Œä¸€å°æ®µä¸€å°æ®µçš„è¿›è¡Œåˆ†å‰²ï¼‰ï¼Œå°†è¯»å–åˆ°çš„æœ€åä¸€ä¸ªæ­£æ–‡çš„ä½ç½®+1å¤„çš„å­—ç¬¦ç½®ä¸º\\0ï¼Œstate.texté‡Œçš„å†…å®¹ä¾¿ç§°ä¸ºäº†å®Œæ•´ä¸€æ®µçš„å†…å®¹ï¼Œæ¥ç€è¿”å›T_TEXTè¡¨ç¤ºå·²è¯»å…¥ä¸€æ®µæ–‡æœ¬ æ¥ç€å›åˆ°Parser::ParseDataæ–¹æ³•ä¸­ï¼Œå¦‚æœè¯»åˆ°çš„TYPEæ˜¯T_TEXTï¼Œå°±å°†è¿™ä¸€æ®µå†…å®¹å…ˆæ·»åŠ åˆ°å®¹å™¨ä¸­ï¼Œå½“è¯»åˆ°T_NEWLINEæ—¶ï¼Œè§£æä¹‹å‰è¯»å…¥çš„ä¸€æ•´è¡Œå†…å®¹ï¼Œå…ˆç”¨args[0]ï¼ˆä¸€è¡Œçš„å¼€å¤´ï¼‰å»å¯»æ‰¾æˆ‘ä»¬ä¹‹å‰æ·»åŠ çš„SectionParserï¼Œå¦‚æœèƒ½æ‰¾åˆ°ï¼Œè¯´æ˜è¿™ä¸€è¡Œæ˜¯serviceã€onæˆ–è€…importï¼Œå°†section_parserèµ‹å€¼ä¸ºç›¸åº”SectionParserå­ç±»çš„æŒ‡é’ˆï¼Œè°ƒç”¨å…¶ParseSectionæ–¹æ³•è§£æï¼Œå¦‚æœè¯»å…¥çš„ä¸€è¡Œé‡Œï¼Œä¸æ˜¯ä»¥serviceã€onæˆ–è€…importå¼€å¤´ï¼Œå¹¶ä¸”ä¹‹å‰å®šä¹‰çš„section_parserä¸ä¸ºç©ºæŒ‡é’ˆï¼Œè¯´æ˜æ˜¯serviceæˆ–è€…onå‚æ•°çš„å­å‚æ•°ï¼Œè°ƒç”¨ParseLineSectionæ–¹æ³•è§£æå­å‚æ•°ï¼Œå¹¶åŠ å…¥åˆ°çˆ¶å‚æ•°ä¸­ã€‚ æœ€åï¼Œæ¯æ¬¡è¯»å–å®Œéƒ½ä¼šæ‰§è¡Œargs.clear()æ¸…æ¥šè¿™ä¸€è¡Œçš„æ•°æ®ï¼Œå½“è¯»å–åˆ°æ–°çš„serviceã€onæˆ–è€…importæ—¶ï¼Œéœ€è¦å…ˆæ‰§è¡ŒEndSectionæ–¹æ³•ï¼Œå°†ä¹‹å‰è§£æå¥½çš„ç»“æ„æ·»åŠ åˆ°åˆ—è¡¨ä¸­ æ‰§è¡Œä»»åŠ¡å›åˆ°SecondStageMainä¸­ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œæœ€åæœ‰ä¸€ä¸ªæ­»å¾ªç¯ï¼Œç”¨æ¥ç­‰å¾…äº‹ä»¶å¤„ç† 12345678910111213141516171819202122232425262728293031323334int SecondStageMain(int argc, char** argv) &#123; ... while (true) &#123; // By default, sleep until something happens. auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;; ... //æ‰§è¡Œä»init.rcè„šæœ¬è§£æå‡ºæ¥çš„æ¯æ¡æŒ‡ä»¤ if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; am.ExecuteOneCommand(); &#125; ... if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; // If there's more work to do, wake up again immediately. if (am.HasMoreCommands()) epoll_timeout = 0ms; &#125; auto pending_functions = epoll.Wait(epoll_timeout); if (!pending_functions.ok()) &#123; LOG(ERROR) &lt;&lt; pending_functions.error(); &#125; else if (!pending_functions-&gt;empty()) &#123; // We always reap children before responding to the other pending functions. This is to // prevent a race where other daemons see that a service has exited and ask init to // start it again via ctl.start before init has reaped it. //å¤„ç†å­è¿›ç¨‹é€€å‡ºåçš„ç›¸å…³äº‹é¡¹ ReapAnyOutstandingChildren(); for (const auto&amp; function : *pending_functions) &#123; (*function)(); &#125; &#125; ... &#125; return 0;&#125; å…¶ä¸­am.ExecuteOneCommand()æ–¹æ³•ä¾¿æ˜¯æ‰§è¡Œä»rcæ–‡ä»¶ä¸­è§£æå‡ºæ¥çš„æŒ‡ä»¤ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void ActionManager::ExecuteOneCommand() &#123; &#123; auto lock = std::lock_guard&#123;event_queue_lock_&#125;; // Loop through the event queue until we have an action to execute //å½“å‰æ­£åœ¨æ‰§è¡Œçš„actioné˜Ÿåˆ—ä¸ºç©ºï¼Œä½†ç­‰å¾…æ‰§è¡Œçš„äº‹ä»¶é˜Ÿåˆ—ä¸ä¸ºç©º while (current_executing_actions_.empty() &amp;&amp; !event_queue_.empty()) &#123; for (const auto&amp; action : actions_) &#123; //ä»ç­‰å¾…æ‰§è¡Œçš„äº‹ä»¶é˜Ÿåˆ—å¤´å–å‡ºä¸€ä¸ªå…ƒç´ eventï¼Œ //ç„¶åè°ƒç”¨actionçš„CheckEventæ£€æŸ¥æ­¤eventæ˜¯å¦åŒ¹é…å½“å‰action //å¦‚æœåŒ¹é…ï¼Œå°†è¿™ä¸ªactionåŠ å…¥åˆ°æ­£åœ¨æ‰§è¡Œçš„actionsé˜Ÿåˆ—çš„é˜Ÿå°¾ if (std::visit([&amp;action](const auto&amp; event) &#123; return action-&gt;CheckEvent(event); &#125;, event_queue_.front())) &#123; current_executing_actions_.emplace(action.get()); &#125; &#125; event_queue_.pop(); &#125; &#125; if (current_executing_actions_.empty()) &#123; return; &#125; //ä»é˜Ÿåˆ—å¤´å–ä¸€ä¸ªactionï¼ˆfrontä¸ä¼šä½¿å…ƒç´ å‡ºé˜Ÿï¼‰ auto action = current_executing_actions_.front(); //å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ‰§è¡Œè¿™ä¸ªaction if (current_command_ == 0) &#123; std::string trigger_name = action-&gt;BuildTriggersString(); LOG(INFO) &lt;&lt; \"processing action (\" &lt;&lt; trigger_name &lt;&lt; \") from (\" &lt;&lt; action-&gt;filename() &lt;&lt; \":\" &lt;&lt; action-&gt;line() &lt;&lt; \")\"; &#125; //è¿™ä¸ªcurrent_command_æ˜¯ä¸ªæˆå‘˜å˜é‡ï¼Œæ ‡å¿—ç€æ‰§è¡Œåˆ°äº†å“ªä¸€è¡Œ action-&gt;ExecuteOneCommand(current_command_); // If this was the last command in the current action, then remove // the action from the executing list. // If this action was oneshot, then also remove it from actions_. ++current_command_; //current_command_ç­‰äºactionçš„commandsæ•°é‡ï¼Œè¯´æ˜è¿™ä¸ªactionä»¥åŠå…¨éƒ¨æ‰§è¡Œå®Œäº† if (current_command_ == action-&gt;NumCommands()) &#123; //æ­¤actionå‡ºé˜Ÿ current_executing_actions_.pop(); //é‡ç½®è®¡æ•°å™¨ current_command_ = 0; if (action-&gt;oneshot()) &#123; auto eraser = [&amp;action](std::unique_ptr&lt;Action&gt;&amp; a) &#123; return a.get() == action; &#125;; actions_.erase(std::remove_if(actions_.begin(), actions_.end(), eraser), actions_.end()); &#125; &#125;&#125; é‡Œé¢ä¼šæ‰§è¡ŒAction::ExecuteOneCommandæ–¹æ³• 123456void Action::ExecuteOneCommand(std::size_t command) const &#123; // We need a copy here since some Command execution may result in // changing commands_ vector by importing .rc files through parser Command cmd = commands_[command]; ExecuteCommand(cmd);&#125; æ¥ç€è°ƒç”¨åˆ°äº†Action::ExecuteCommandæ–¹æ³• 123456789101112131415161718void Action::ExecuteCommand(const Command&amp; command) const &#123; android::base::Timer t; //è¿™ä¸€è¡Œæ˜¯å…·ä½“çš„æ‰§è¡Œ auto result = command.InvokeFunc(subcontext_); auto duration = t.duration(); // Any action longer than 50ms will be warned to user as slow operation //å¤±è´¥ã€è¶…æ—¶æˆ–è€…debugç‰ˆæœ¬éƒ½éœ€è¦æ‰“å°ç»“æœ if (!result.has_value() || duration &gt; 50ms || android::base::GetMinimumLogSeverity() &lt;= android::base::DEBUG) &#123; std::string trigger_name = BuildTriggersString(); std::string cmd_str = command.BuildCommandString(); LOG(INFO) &lt;&lt; \"Command '\" &lt;&lt; cmd_str &lt;&lt; \"' action=\" &lt;&lt; trigger_name &lt;&lt; \" (\" &lt;&lt; filename_ &lt;&lt; \":\" &lt;&lt; command.line() &lt;&lt; \") took \" &lt;&lt; duration.count() &lt;&lt; \"ms and \" &lt;&lt; (result.ok() ? \"succeeded\" : \"failed: \" + result.error().message()); &#125;&#125; æ¥ç€ä¼šè°ƒç”¨Command::InvokeFuncæ–¹æ³• 12345678910111213141516171819Result&lt;void&gt; Command::InvokeFunc(Subcontext* subcontext) const &#123; //ä» /vendor æˆ– /oem è§£æå‡ºæ¥çš„rcæ–‡ä»¶éƒ½ä¼šèµ°è¿™é‡Œ //æ¶‰åŠåˆ°selinuxæƒé™é—®é¢˜ï¼ŒGoogleä¸ºäº†ä¿è¯å®‰å…¨ //é˜Ÿå¯¹å‚å•†å®šåˆ¶çš„rcæ–‡ä»¶ä¸­çš„å‘½ä»¤æ‰§è¡Œï¼Œä»¥åŠç”±æ­¤å¯åŠ¨çš„æœåŠ¡çš„æƒé™éƒ½ä¼šæœ‰ä¸€å®šé™åˆ¶ if (subcontext) &#123; if (execute_in_subcontext_) &#123; return subcontext-&gt;Execute(args_); &#125; auto expanded_args = subcontext-&gt;ExpandArgs(args_); if (!expanded_args.ok()) &#123; return expanded_args.error(); &#125; return RunBuiltinFunction(func_, *expanded_args, subcontext-&gt;context()); &#125; //ç³»ç»ŸåŸç”Ÿçš„rcæ–‡ä»¶å‘½ä»¤éƒ½ä¼šèµ°è¿™é‡Œ return RunBuiltinFunction(func_, args_, kInitContext);&#125; ç³»ç»ŸåŸç”Ÿçš„rcæ–‡ä»¶å‘½ä»¤éƒ½ä¼šèµ°åˆ°RunBuiltinFunctionæ–¹æ³•ä¸­ 12345678910111213141516Result&lt;void&gt; RunBuiltinFunction(const BuiltinFunction&amp; function, const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; context) &#123; auto builtin_arguments = BuiltinArguments(context); builtin_arguments.args.resize(args.size()); builtin_arguments.args[0] = args[0]; for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; return expanded_arg.error(); &#125; builtin_arguments.args[i] = std::move(*expanded_arg); &#125; return function(builtin_arguments);&#125; è¿™é‡Œçš„functionæ˜¯ä¸€ä¸ªä»¥BuiltinArgumentsä¸ºå‚æ•°çš„std::functionå‡½æ•°åŒ…è£…å™¨æ¨¡æ¿ï¼Œå¯ä»¥åŒ…è£…å‡½æ•°ã€å‡½æ•°æŒ‡é’ˆã€ç±»æˆå‘˜å‡½æ•°æŒ‡é’ˆæˆ–ä»»æ„ç±»å‹çš„å‡½æ•°å¯¹è±¡ï¼Œåœ¨Commandå¯¹è±¡newå‡ºæ¥çš„æ—¶å€™æ„é€ å‡½æ•°å°±æŒ‡å®šäº†è¿™ä¸ªfunc_ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹Action::AddCommandæ–¹æ³•ï¼š 123456789101112131415Result&lt;void&gt; Action::AddCommand(std::vector&lt;std::string&gt;&amp;&amp; args, int line) &#123; if (!function_map_) &#123; return Error() &lt;&lt; \"no function map available\"; &#125; //ä»function_map_ä¸­è¿›è¡Œé”®å€¼å¯¹æŸ¥æ‰¾ auto map_result = function_map_-&gt;Find(args); if (!map_result.ok()) &#123; return Error() &lt;&lt; map_result.error(); &#125; commands_.emplace_back(map_result-&gt;function, map_result-&gt;run_in_subcontext, std::move(args), line); return &#123;&#125;;&#125; å¯ä»¥çœ‹åˆ°ï¼Œæ˜¯é€šè¿‡rcæ–‡ä»¶ä¸­çš„å­—ç¬¦ä¸²å»ä¸€ä¸ªfunction_map_å¸¸é‡ä¸­æŸ¥æ‰¾å¾—åˆ°çš„ï¼Œè€Œè¿™ä¸ªfunction_map_æ˜¯åœ¨å“ªèµ‹å€¼çš„å‘¢ï¼Œç­”æ¡ˆæ˜¯åœ¨SecondStageMainå‡½æ•°ä¸­ 1234567int SecondStageMain(int argc, char** argv) &#123; ... //è®¾ç½®commandsæŒ‡ä»¤æ‰€å¯¹åº”çš„å‡½æ•°map const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); Action::set_function_map(&amp;function_map); ...&#125; è¿™ä¸ªåœ¨å‰æ–‡ä»£ç ä¸­æœ‰æåŠï¼Œmapçš„å®šä¹‰åœ¨system/core/init/builtins.cppä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const BuiltinFunctionMap&amp; GetBuiltinFunctionMap() &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); // clang-format off static const BuiltinFunctionMap builtin_functions = &#123; &#123;\"bootchart\", &#123;1, 1, &#123;false, do_bootchart&#125;&#125;&#125;, &#123;\"chmod\", &#123;2, 2, &#123;true, do_chmod&#125;&#125;&#125;, &#123;\"chown\", &#123;2, 3, &#123;true, do_chown&#125;&#125;&#125;, &#123;\"class_reset\", &#123;1, 1, &#123;false, do_class_reset&#125;&#125;&#125;, &#123;\"class_reset_post_data\", &#123;1, 1, &#123;false, do_class_reset_post_data&#125;&#125;&#125;, &#123;\"class_restart\", &#123;1, 1, &#123;false, do_class_restart&#125;&#125;&#125;, &#123;\"class_start\", &#123;1, 1, &#123;false, do_class_start&#125;&#125;&#125;, &#123;\"class_start_post_data\", &#123;1, 1, &#123;false, do_class_start_post_data&#125;&#125;&#125;, &#123;\"class_stop\", &#123;1, 1, &#123;false, do_class_stop&#125;&#125;&#125;, &#123;\"copy\", &#123;2, 2, &#123;true, do_copy&#125;&#125;&#125;, &#123;\"domainname\", &#123;1, 1, &#123;true, do_domainname&#125;&#125;&#125;, &#123;\"enable\", &#123;1, 1, &#123;false, do_enable&#125;&#125;&#125;, &#123;\"exec\", &#123;1, kMax, &#123;false, do_exec&#125;&#125;&#125;, &#123;\"exec_background\", &#123;1, kMax, &#123;false, do_exec_background&#125;&#125;&#125;, &#123;\"exec_start\", &#123;1, 1, &#123;false, do_exec_start&#125;&#125;&#125;, &#123;\"export\", &#123;2, 2, &#123;false, do_export&#125;&#125;&#125;, &#123;\"hostname\", &#123;1, 1, &#123;true, do_hostname&#125;&#125;&#125;, &#123;\"ifup\", &#123;1, 1, &#123;true, do_ifup&#125;&#125;&#125;, &#123;\"init_user0\", &#123;0, 0, &#123;false, do_init_user0&#125;&#125;&#125;, &#123;\"insmod\", &#123;1, kMax, &#123;true, do_insmod&#125;&#125;&#125;, &#123;\"installkey\", &#123;1, 1, &#123;false, do_installkey&#125;&#125;&#125;, &#123;\"interface_restart\", &#123;1, 1, &#123;false, do_interface_restart&#125;&#125;&#125;, &#123;\"interface_start\", &#123;1, 1, &#123;false, do_interface_start&#125;&#125;&#125;, &#123;\"interface_stop\", &#123;1, 1, &#123;false, do_interface_stop&#125;&#125;&#125;, &#123;\"load_persist_props\", &#123;0, 0, &#123;false, do_load_persist_props&#125;&#125;&#125;, &#123;\"load_system_props\", &#123;0, 0, &#123;false, do_load_system_props&#125;&#125;&#125;, &#123;\"loglevel\", &#123;1, 1, &#123;false, do_loglevel&#125;&#125;&#125;, &#123;\"mark_post_data\", &#123;0, 0, &#123;false, do_mark_post_data&#125;&#125;&#125;, &#123;\"mkdir\", &#123;1, 6, &#123;true, do_mkdir&#125;&#125;&#125;, // TODO: Do mount operations in vendor_init. // mount_all is currently too complex to run in vendor_init as it queues action triggers, // imports rc scripts, etc. It should be simplified and run in vendor_init context. // mount and umount are run in the same context as mount_all for symmetry. &#123;\"mount_all\", &#123;0, kMax, &#123;false, do_mount_all&#125;&#125;&#125;, &#123;\"mount\", &#123;3, kMax, &#123;false, do_mount&#125;&#125;&#125;, &#123;\"perform_apex_config\", &#123;0, 0, &#123;false, do_perform_apex_config&#125;&#125;&#125;, &#123;\"umount\", &#123;1, 1, &#123;false, do_umount&#125;&#125;&#125;, &#123;\"umount_all\", &#123;0, 1, &#123;false, do_umount_all&#125;&#125;&#125;, &#123;\"update_linker_config\", &#123;0, 0, &#123;false, do_update_linker_config&#125;&#125;&#125;, &#123;\"readahead\", &#123;1, 2, &#123;true, do_readahead&#125;&#125;&#125;, &#123;\"remount_userdata\", &#123;0, 0, &#123;false, do_remount_userdata&#125;&#125;&#125;, &#123;\"restart\", &#123;1, 1, &#123;false, do_restart&#125;&#125;&#125;, &#123;\"restorecon\", &#123;1, kMax, &#123;true, do_restorecon&#125;&#125;&#125;, &#123;\"restorecon_recursive\", &#123;1, kMax, &#123;true, do_restorecon_recursive&#125;&#125;&#125;, &#123;\"rm\", &#123;1, 1, &#123;true, do_rm&#125;&#125;&#125;, &#123;\"rmdir\", &#123;1, 1, &#123;true, do_rmdir&#125;&#125;&#125;, &#123;\"setprop\", &#123;2, 2, &#123;true, do_setprop&#125;&#125;&#125;, &#123;\"setrlimit\", &#123;3, 3, &#123;false, do_setrlimit&#125;&#125;&#125;, &#123;\"start\", &#123;1, 1, &#123;false, do_start&#125;&#125;&#125;, &#123;\"stop\", &#123;1, 1, &#123;false, do_stop&#125;&#125;&#125;, &#123;\"swapon_all\", &#123;0, 1, &#123;false, do_swapon_all&#125;&#125;&#125;, &#123;\"enter_default_mount_ns\", &#123;0, 0, &#123;false, do_enter_default_mount_ns&#125;&#125;&#125;, &#123;\"symlink\", &#123;2, 2, &#123;true, do_symlink&#125;&#125;&#125;, &#123;\"sysclktz\", &#123;1, 1, &#123;false, do_sysclktz&#125;&#125;&#125;, &#123;\"trigger\", &#123;1, 1, &#123;false, do_trigger&#125;&#125;&#125;, &#123;\"verity_update_state\", &#123;0, 0, &#123;false, do_verity_update_state&#125;&#125;&#125;, &#123;\"wait\", &#123;1, 2, &#123;true, do_wait&#125;&#125;&#125;, &#123;\"wait_for_prop\", &#123;2, 2, &#123;false, do_wait_for_prop&#125;&#125;&#125;, &#123;\"write\", &#123;2, 2, &#123;true, do_write&#125;&#125;&#125;, &#125;; // clang-format on return builtin_functions;&#125; å¯åŠ¨æœåŠ¡ä»¥ä¸‹é¢ä¸€æ®µrcè„šæœ¬ä¸ºä¾‹ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹ä¸€ä¸ªæœåŠ¡æ˜¯æ€ä¹ˆå¯åŠ¨çš„ 12on zygote-start start zygote é¦–å…ˆè¿™æ˜¯ä¸€ä¸ªactionï¼Œå½“initè¿›ç¨‹åœ¨æ­»å¾ªç¯ä¸­æ‰§è¡Œåˆ°ActionManager::ExecuteOneCommandæ–¹æ³•æ—¶ï¼Œæ£€æŸ¥åˆ°è¿™ä¸ªactionåˆšå¥½ç¬¦åˆevent_queue_é˜Ÿé¦–çš„EventTriggerï¼Œä¾¿ä¼šæ‰§è¡Œè¿™ä¸ªactionä¸‹é¢çš„commandsã€‚commandsæ€ä¹ˆæ‰§è¡Œåœ¨ä¸Šé¢å·²ç»åˆ†æè¿‡äº†ï¼Œæˆ‘ä»¬å»system/core/init/builtins.cppé‡Œçš„mapä¸­æ‰¾key-valueå¯¹åº”å…³ç³»ï¼Œå‘ç°startå¯¹åº”ç€do_startå‡½æ•°ï¼š 12345678static Result&lt;void&gt; do_start(const BuiltinArguments&amp; args) &#123; Service* svc = ServiceList::GetInstance().FindService(args[1]); if (!svc) return Error() &lt;&lt; \"service \" &lt;&lt; args[1] &lt;&lt; \" not found\"; if (auto result = svc-&gt;Start(); !result.ok()) &#123; return ErrorIgnoreEnoent() &lt;&lt; \"Could not start service: \" &lt;&lt; result.error(); &#125; return &#123;&#125;;&#125; ServiceListé€šè¿‡args[1]å³å®šä¹‰çš„æœåŠ¡åå»å¯»æ‰¾ä¹‹å‰è§£æå¥½çš„serviceï¼Œå¹¶æ‰§è¡ŒService::Startæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233Result&lt;void&gt; Service::Start() &#123; ... //ä¸Šé¢åŸºæœ¬ä¸Šæ˜¯ä¸€äº›æ£€æŸ¥å’Œå‡†å¤‡å·¥ä½œï¼Œè¿™é‡Œå…ˆå¿½ç•¥ pid_t pid = -1; //é€šè¿‡namespaces_.flagsåˆ¤æ–­ä½¿ç”¨å“ªç§æ–¹å¼åˆ›å»ºè¿›ç¨‹ if (namespaces_.flags) &#123; pid = clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr); &#125; else &#123; pid = fork(); &#125; if (pid == 0) &#123; //è®¾ç½®æƒé™æ©ç  umask(077); ... //å†…éƒ¨è°ƒç”¨execvå‡½æ•°å¯åŠ¨æ–‡ä»¶ if (!ExpandArgsAndExecv(args_, sigstop_)) &#123; PLOG(ERROR) &lt;&lt; \"cannot execv('\" &lt;&lt; args_[0] &lt;&lt; \"'). See the 'Debugging init' section of init's README.md for tips\"; &#125; _exit(127); &#125; if (pid &lt; 0) &#123; pid_ = 0; return ErrnoError() &lt;&lt; \"Failed to fork\"; &#125; ... return &#123;&#125;;&#125; 123456789101112131415161718192021222324static bool ExpandArgsAndExecv(const std::vector&lt;std::string&gt;&amp; args, bool sigstop) &#123; std::vector&lt;std::string&gt; expanded_args; std::vector&lt;char*&gt; c_strings; expanded_args.resize(args.size()); //å°†è¦æ‰§è¡Œçš„æ–‡ä»¶è·¯å¾„å…ˆåŠ å…¥å®¹å™¨ c_strings.push_back(const_cast&lt;char*&gt;(args[0].data())); for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; LOG(FATAL) &lt;&lt; args[0] &lt;&lt; \": cannot expand arguments': \" &lt;&lt; expanded_arg.error(); &#125; expanded_args[i] = *expanded_arg; c_strings.push_back(expanded_args[i].data()); &#125; c_strings.push_back(nullptr); if (sigstop) &#123; kill(getpid(), SIGSTOP); &#125; //è°ƒç”¨execvå‡½æ•°ï¼Œå¸¦å‚æ‰§è¡Œæ–‡ä»¶ return execv(c_strings[0], c_strings.data()) == 0;&#125; è¿™é‡Œå…ˆforkï¼ˆæˆ–cloneï¼‰å‡ºäº†ä¸€ä¸ªå­è¿›ç¨‹ï¼Œå†åœ¨è¿™ä¸ªå­è¿›ç¨‹ä¸­è°ƒç”¨execvå‡½æ•°æ‰§è¡Œæ–‡ä»¶ åˆ°æ­¤ä¸ºæ­¢ï¼Œä¸€ä¸ªæœåŠ¡ä¾¿è¢«å¯åŠ¨èµ·æ¥äº† å®ˆæŠ¤æœåŠ¡å½“æœåŠ¡å¯åŠ¨èµ·æ¥åï¼Œinitè¿›ç¨‹ä¹Ÿè¦è´Ÿè´£æœåŠ¡çš„å®ˆæŠ¤ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿ å‡è®¾zygoteè¿›ç¨‹æŒ‚äº†ï¼Œé‚£zygoteè¿›ç¨‹ä¸‹çš„æ‰€æœ‰å­è¿›ç¨‹éƒ½å¯èƒ½ä¼šè¢«æ€ï¼Œæ•´ä¸ªAndroidç³»ç»Ÿä¼šå‡ºç°å¤§é—®é¢˜ï¼Œé‚£æ€ä¹ˆåŠå‘¢ï¼Ÿå¾—æŠŠzygoteè¿›ç¨‹é‡å¯èµ·æ¥å‘€ã€‚initè¿›ç¨‹å®ˆæŠ¤æœåŠ¡åšçš„å°±æ˜¯è¿™äº›äº‹ï¼Œå½“æ¥æ”¶åˆ°å­è¿›ç¨‹é€€å‡ºä¿¡å·ï¼Œå°±ä¼šè§¦å‘å¯¹åº”çš„å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œå»æ ¹æ®è¿™ä¸ªè¿›ç¨‹æ‰€å¯¹åº”çš„æœåŠ¡ï¼Œå¤„ç†åäº‹ï¼ˆé‡å¯ç­‰ï¼‰ ä»£ç åœ¨è¿™ä¸ªä½ç½®ï¼š 123456789int SecondStageMain(int argc, char** argv) &#123; Epoll epoll; if (auto result = epoll.Open(); !result.ok()) &#123; PLOG(FATAL) &lt;&lt; result.error(); &#125; InstallSignalFdHandler(&amp;epoll); InstallInitNotifier(&amp;epoll);&#125; å…ˆåˆ›å»ºå‡ºæ¥ä¸€ä¸ªepollå¥æŸ„ï¼Œå†ç”¨å®ƒå»InstallSignalFdHandlerè£…è½½ä¿¡å·handlerï¼š 12345678910111213141516171819202122232425262728293031323334353637383940static void InstallSignalFdHandler(Epoll* epoll) &#123; // Applying SA_NOCLDSTOP to a defaulted SIGCHLD handler prevents the signalfd from receiving // SIGCHLD when a child process stops or continues (b/77867680#comment9). //è®¾ç½®SIGCHLDä¿¡å·çš„å¤„ç†æ–¹å¼ const struct sigaction act &#123; .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;; sigaction(SIGCHLD, &amp;act, nullptr); //åœ¨initè¿›ç¨‹ä¸­å±è”½SIGCHLDã€SIGTERMä¿¡å· sigset_t mask; sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); if (!IsRebootCapable()) &#123; // If init does not have the CAP_SYS_BOOT capability, it is running in a container. // In that case, receiving SIGTERM will cause the system to shut down. sigaddset(&amp;mask, SIGTERM); &#125; if (sigprocmask(SIG_BLOCK, &amp;mask, nullptr) == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to block signals\"; &#125; // Register a handler to unblock signals in the child processes. //åœ¨å­è¿›ç¨‹ä¸­å–æ¶ˆSIGCHLDã€SIGTERMä¿¡å·å±è”½ const int result = pthread_atfork(nullptr, nullptr, &amp;UnblockSignals); if (result != 0) &#123; LOG(FATAL) &lt;&lt; \"Failed to register a fork handler: \" &lt;&lt; strerror(result); &#125; //åˆ›å»ºç”¨äºæ¥å—ä¿¡å·çš„æ–‡ä»¶æè¿°ç¬¦ signal_fd = signalfd(-1, &amp;mask, SFD_CLOEXEC); if (signal_fd == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to create signalfd\"; &#125; //æ³¨å†Œä¿¡å·å¤„ç†å™¨ if (auto result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) &#123; LOG(FATAL) &lt;&lt; result.error(); &#125;&#125; sigactionå‡½æ•°å…ˆä»‹ç»ä¸€ä¸‹sigactionå‡½æ•°ï¼Œå®ƒæ˜¯ç”¨æ¥æ£€æŸ¥å’Œè®¾ç½®ä¸€ä¸ªä¿¡å·çš„å¤„ç†æ–¹å¼çš„ æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/sigaction.2.html ç¬¬ä¸€ä¸ªå‚æ•°signumï¼Œå®šä¹‰åœ¨signal.hä¸­ï¼Œç”¨æ¥æŒ‡å®šä¿¡å·çš„ç¼–å·ï¼ˆéœ€è¦è®¾ç½®å“ªä¸ªä¿¡å·ï¼‰ ç¬¬äºŒä¸ªå‚æ•°actæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼š 1234567struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);&#125;; å…¶ä¸­ï¼Œsa_handlerè¡¨ç¤ºä¿¡å·çš„å¤„ç†æ–¹å¼ï¼Œsa_flagsç”¨æ¥è®¾ç½®ä¿¡å·å¤„ç†çš„å…¶ä»–ç›¸å…³æ“ä½œ ç¬¬ä¸‰ä¸ªå‚æ•°oldactï¼Œå¦‚æœä¸ä¸ºnullï¼Œä¼šå°†æ­¤ä¿¡å·åŸæ¥çš„å¤„ç†æ–¹å¼ä¿å­˜è¿›å» å¯¹åº”ä¸€ä¸‹InstallSignalFdHandleré‡Œçš„è°ƒç”¨ï¼Œ.sa_handler = SIG_DFLè¡¨ç¤ºä½¿ç”¨é»˜è®¤çš„ä¿¡å·å¤„ç†ï¼Œ.sa_flags = SA_NOCLDSTOPå½“å‚æ•°signumä¸ºSIGCHLDçš„æ—¶å€™ç”Ÿæ•ˆï¼Œè¡¨ç¤ºå½“å­è¿›ç¨‹æš‚åœæ—¶ä¸ä¼šé€šçŸ¥çˆ¶è¿›ç¨‹ ä¿¡å·é›†å‡½æ•°æ¥ä¸‹æ¥InstallSignalFdHandlerå‡½æ•°è°ƒç”¨äº†ä¸€äº›ä¿¡å·é›†å‡½æ•° sigemptysetåŸå‹ï¼šint sigemptyset(sigset_t *set); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigemptyset.3p.html è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯å°†ä¿¡å·é›†åˆå§‹åŒ–ä¸ºç©º sigaddsetåŸå‹ï¼šint sigaddset(sigset_t *set, int signo); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/sigaddset.3p.html è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯æŠŠä¿¡å·signoæ·»åŠ åˆ°ä¿¡å·é›†setä¸­ sigpromaskåŸå‹ï¼šint sigpromask(int how, const sigset_t *set, sigset_t *oldset); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/sigprocmask.2.html è¯¥å‡½æ•°å¯ä»¥æ ¹æ®å‚æ•°æŒ‡å®šçš„æ–¹æ³•ä¿®æ”¹è¿›ç¨‹çš„ä¿¡å·å±è”½å­— ç¬¬ä¸€ä¸ªå‚æ•°howæœ‰3ç§å–å€¼ï¼š SIG_BLOCKï¼šå°†setä¸­çš„ä¿¡å·æ·»åŠ åˆ°ä¿¡å·å±è”½å­—ä¸­ï¼ˆä¸æ”¹å˜åŸæœ‰å·²å­˜åœ¨ä¿¡å·å±è”½å­—ï¼Œç›¸å½“äºç”¨setä¸­çš„ä¿¡å·ä¸åŸæœ‰ä¿¡å·å–å¹¶é›†è®¾ç½®ï¼‰ SIG_UNBLOCKï¼šå°†setä¸­çš„ä¿¡å·ç§»é™¤ä¿¡å·å±è”½å­—ï¼ˆç›¸å½“äºç”¨setä¸­çš„ä¿¡å·çš„è¡¥é›†ä¸åŸæœ‰ä¿¡å·å–äº¤é›†è®¾ç½®ï¼‰ SIG_SETMASKï¼šä½¿ç”¨setä¸­çš„ä¿¡å·ç›´æ¥ä»£æ›¿åŸæœ‰ä¿¡å·å±è”½å­—ä¸­çš„ä¿¡å· ç¬¬äºŒä¸ªå‚æ•°setæ˜¯ä¸€ä¸ªä¿¡å·é›†ï¼Œæ€ä¹ˆä½¿ç”¨å’Œå‚æ•°howç›¸å…³ ç¬¬ä¸‰ä¸ªå‚æ•°oldsetï¼Œå¦‚æœä¸ä¸ºnullï¼Œä¼šå°†åŸæœ‰ä¿¡å·å±è”½å­—çš„ä¿¡å·é›†ä¿å­˜è¿›å» ä¸ºä»€ä¹ˆinitè¿›ç¨‹è¦å±è”½è¿™äº›ä¿¡å·å‘¢ï¼Ÿå› ä¸ºå®ƒåé¢ä¼šç‰¹æ®Šå¤„ç†è¿™äº›ä¿¡å· pthread_atforkè¿™ä¹Ÿæ˜¯ä¸€ä¸ªLinuxå‡½æ•°ï¼Œç”¨æ¥æ³¨å†Œforkçš„handlers åŸå‹ï¼šint pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); è°ƒç”¨è¿™ä¸ªå‡½æ•°åï¼Œå½“è¿›ç¨‹å†è°ƒç”¨forkæ—¶ï¼Œå†…éƒ¨åˆ›å»ºå­è¿›ç¨‹é’±ä¼šå…ˆåœ¨çˆ¶è¿›ç¨‹ä¸­è°ƒç”¨prepareå‡½æ•°ï¼Œåˆ›å»ºå­è¿›ç¨‹æˆåŠŸåï¼Œä¼šåœ¨çˆ¶è¿›ç¨‹ä¸­è°ƒç”¨parentå‡½æ•°ï¼Œå­è¿›ç¨‹ä¸­è°ƒç”¨childå‡½æ•° å¯¹åº”åˆ°InstallSignalFdHandleré‡Œæ¥ï¼Œå³å½“initè¿›ç¨‹forkå‡ºå­è¿›ç¨‹åè°ƒç”¨UnblockSignalså‡½æ•° 12345678910111213static void UnblockSignals() &#123; const struct sigaction act &#123; .sa_handler = SIG_DFL &#125;; sigaction(SIGCHLD, &amp;act, nullptr); sigset_t mask; sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); sigaddset(&amp;mask, SIGTERM); if (sigprocmask(SIG_UNBLOCK, &amp;mask, nullptr) == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to unblock signals for PID \" &lt;&lt; getpid(); &#125;&#125; ä¹Ÿå°±æ˜¯ï¼Œå…ˆåœ¨initè¿›ç¨‹ä¸­å±è”½äº†SIGCHLDã€SIGTERMä¿¡å·ï¼Œå†åœ¨å­è¿›ç¨‹ä¸­è§£é™¤äº†è¿™ä¸¤ä¸ªä¿¡å·çš„å±è”½ signalfdå‡½æ•°åŒæ ·ä¹Ÿæ˜¯Linuxå‡½æ•°ï¼Œç”¨æ¥åˆ›å»ºç”¨äºæ¥å—ä¿¡å·çš„æ–‡ä»¶æè¿°ç¬¦ åŸå‹ï¼šint signalfd(int fd, const sigset_t *mask, int flags); å‚æ•°fdå¦‚æœä¸º-1ï¼Œåˆ™è¯¥å‡½æ•°ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦ä¸maskä¿¡å·é›†ç›¸å…³è”ï¼Œå¦‚æœä¸ä¸º-1ï¼Œåˆ™è¯¥å‡½æ•°ä¼šç”¨maskæ›¿æ¢ä¹‹å‰ä¸è¿™ä¸ªfdç›¸å…³è”çš„ä¿¡å·é›† flagsï¼š SFD_NONBLOCKï¼šç»™æ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®O_NONBLOCKæ ‡å¿—ï¼Œéé˜»å¡I/Oæ¨¡å¼ SFD_CLOEXECï¼šç»™æ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦è®¾ç½®O_CLOEXECæ ‡å¿—ï¼Œå½“execå‡½æ•°æ‰§è¡ŒæˆåŠŸåï¼Œä¼šè‡ªåŠ¨å…³é—­è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦ å¯¹åº”åˆ°InstallSignalFdHandlerä¸­ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªç”¨äºæ¥å—SIGCHLDã€SIGTERMä¿¡å·çš„æ–‡ä»¶æè¿°ç¬¦ã€‚å›å¿†ä¸€ä¸‹ä¹‹å‰å¯¹å¯åŠ¨æœåŠ¡çš„åˆ†æï¼Œæ˜¯å…ˆè°ƒç”¨forkåˆ›å»ºè¿›ç¨‹ï¼Œåœ¨execæ‰§è¡Œæ–‡ä»¶ï¼Œå°†flagsè®¾ç½®ä¸ºSFD_CLOEXECï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯åœ¨å­è¿›ç¨‹ä¸­å…³é—­ç”±forkå¾—åˆ°çš„æ¥æ”¶ä¿¡å·çš„æ–‡ä»¶æè¿°ç¬¦ æ³¨å†Œä¿¡å·å¤„ç†å™¨ æœ€åè°ƒç”¨Epoll::RegisterHandleræ–¹æ³•æ³¨å†Œå¤„ç†å™¨ï¼Œå†…éƒ¨è°ƒç”¨äº†epoll_ctlå‡½æ•°ï¼Œæ„Ÿå…´è¶£å¯ä»¥è‡ªå·±çœ‹ä¸€ä¸‹ï¼Œæ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man2/epoll_ctl.2.html è¿™æ ·ï¼Œå½“initè¿›ç¨‹æ¥æ”¶åˆ°SIGCHLDã€SIGTERMä¿¡å·æ—¶ä¾¿ä¼šè°ƒç”¨HandleSignalFdæ–¹æ³•ï¼š 123456789101112131415161718192021static void HandleSignalFd() &#123; signalfd_siginfo siginfo; //ä»ä¿¡å·é›†æ–‡ä»¶æè¿°ç¬¦ä¸­è¯»å–ä¿¡æ¯ ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, sizeof(siginfo))); if (bytes_read != sizeof(siginfo)) &#123; PLOG(ERROR) &lt;&lt; \"Failed to read siginfo from signal_fd\"; return; &#125; switch (siginfo.ssi_signo) &#123; case SIGCHLD: ReapAnyOutstandingChildren(); break; case SIGTERM: HandleSigtermSignal(siginfo); break; default: PLOG(ERROR) &lt;&lt; \"signal_fd: received unexpected signal \" &lt;&lt; siginfo.ssi_signo; break; &#125;&#125; æˆ‘ä»¬è¿™é‡Œä¸»è¦çœ‹SIGCHLDï¼Œå½“å­è¿›ç¨‹é€€å‡ºï¼Œinitè¿›ç¨‹ä¾¿ä¼šæ•è·åˆ°SIGCHLDï¼Œæ‰§è¡ŒReapAnyOutstandingChildrenæ–¹æ³•ï¼š 1234void ReapAnyOutstandingChildren() &#123; while (ReapOneProcess() != 0) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static pid_t ReapOneProcess() &#123; siginfo_t siginfo = &#123;&#125;; // This returns a zombie pid or informs us that there are no zombies left to be reaped. // It does NOT reap the pid; that is done below. //è·å–ä¸€ä¸ªå·²ç»é€€å‡ºçš„å­è¿›ç¨‹ï¼Œä½†æš‚æ—¶å…ˆä¸é”€æ¯ if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) &#123; PLOG(ERROR) &lt;&lt; \"waitid failed\"; return 0; &#125; auto pid = siginfo.si_pid; if (pid == 0) return 0; // At this point we know we have a zombie pid, so we use this scopeguard to reap the pid // whenever the function returns from this point forward. // We do NOT want to reap the zombie earlier as in Service::Reap(), we kill(-pid, ...) and we // want the pid to remain valid throughout that (and potentially future) usages. //æœ€åï¼Œé”€æ¯è¿™ä¸ªå­è¿›ç¨‹ auto reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, nullptr, WNOHANG)); &#125;); std::string name; std::string wait_string; Service* service = nullptr; if (SubcontextChildReap(pid)) &#123; name = \"Subcontext\"; &#125; else &#123; //é€šè¿‡pidè·å¾—service service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid); ... &#125; ... if (!service) return pid; //å¤„ç†serviceåäº‹ service-&gt;Reap(siginfo); if (service-&gt;flags() &amp; SVC_TEMPORARY) &#123; ServiceList::GetInstance().RemoveService(*service); &#125; return pid;&#125; waitidå‡½æ•°Linuxå‡½æ•°ï¼Œç”¨äºç­‰å¾…ä¸€ä¸ªå­è¿›ç¨‹çŠ¶æ€çš„æ”¹å˜ åŸå‹ï¼šint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); æ–‡æ¡£ï¼šhttps://man7.org/linux/man-pages/man3/waitid.3p.html ç¬¬ä¸€ä¸ªå‚æ•°idtypeï¼š P_PIDï¼šç­‰å¾…çš„å­è¿›ç¨‹çš„pidå¿…é¡»å’Œå‚æ•°idåŒ¹é… P_GIDï¼šç­‰å¾…çš„å­è¿›ç¨‹çš„ç»„idå¿…é¡»å’Œå‚æ•°idåŒ¹é… P_ADDï¼šç­‰å¾…æ‰€æœ‰å­è¿›ç¨‹ï¼Œæ­¤æ—¶ï¼Œå‚æ•°idè¢«å¿½ç•¥ è¿™ä¸ªå‡½æ•°ä¼šå°†æ‰§è¡Œçš„ç»“æœä¿å­˜åœ¨ç¬¬ä¸‰ä¸ªå‚æ•°infopä¸­ optionsï¼š WCONTINUEDï¼šç­‰å¾…é‚£äº›ç”±SIGCONTé‡æ–°å¯åŠ¨çš„å­è¿›ç¨‹ WEXITEDï¼šç­‰å¾…é‚£äº›å·²ç»é€€å‡ºçš„å­è¿›ç¨‹ WSTOPPEDï¼šç­‰å¾…é‚£äº›è¢«ä¿¡å·æš‚åœçš„å­è¿›ç¨‹ WNOHANGï¼šéé˜»å¡ç­‰å¾… WNOWAITï¼šä¿æŒè¿”å›çš„å­è¿›ç¨‹å¤„äºå¯ç­‰å¾…çŠ¶æ€ï¼ˆåç»­å¯ä»¥å†å¯¹è¿™ä¸ªå­è¿›ç¨‹è¿›è¡Œwaitï¼‰ å›åˆ°ReapOneProcesså‡½æ•°ä¸­æ¥ï¼Œå®ƒå…ˆè°ƒç”¨waitidå‡½æ•°ï¼Œè·å¾—ä¸€ä¸ªçŠ¶æ€å‘ç”Ÿæ”¹å˜çš„å­è¿›ç¨‹ï¼ˆoptionsè®¾ç½®äº†WEXITEDï¼Œå³å·²é€€å‡ºçš„å­è¿›ç¨‹ï¼‰ï¼Œä½¿ç”¨äº†WNOWAITå‚æ•°ï¼Œä¹Ÿå°±æ˜¯æš‚æ—¶å…ˆä¸é”€æ¯å­è¿›ç¨‹ï¼Œä½¿ç”¨éé˜»å¡çš„æ–¹å¼è·å– ScopeGuard ScopeGuardçš„æ„æ€æ˜¯ï¼Œå‡ºä½œç”¨åŸŸåï¼Œè‡ªåŠ¨æ‰§è¡ŒæŸæ®µä»£ç  å‡½æ•°ä¸­é‚£æ®µmake_scope_guardçš„æ„æ€æ˜¯ï¼Œå½“è¿™ä¸ªå‡½æ•°æ‰§è¡Œå®Œåï¼Œä½¿ç”¨waitpidå‡½æ•°é”€æ¯å­è¿›ç¨‹ ä¹‹åä¼šä»ServiceListä¸­é€šè¿‡pidå»æŸ¥æ‰¾serviceï¼ŒæŸ¥åˆ°åè°ƒç”¨Service::Reapå¤„ç†åäº‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void Service::Reap(const siginfo_t&amp; siginfo) &#123; //å½“serviceçš„å‚æ•°æ²¡æœ‰oneshotæˆ–è€…restartæ—¶ï¼Œkillæ•´ä¸ªè¿›ç¨‹ç»„ if (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123; KillProcessGroup(SIGKILL, false); &#125; else &#123; // Legacy behavior from ~2007 until Android R: this else branch did not exist and we did not // kill the process group in this case. if (SelinuxGetVendorAndroidVersion() &gt;= __ANDROID_API_R__) &#123; // The new behavior in Android R is to kill these process groups in all cases. The // 'true' parameter instructions KillProcessGroup() to report a warning message where it // detects a difference in behavior has occurred. KillProcessGroup(SIGKILL, true); &#125; &#125; // Remove any socket resources we may have created. //ç§»é™¤å·²åˆ›å»ºçš„sockets for (const auto&amp; socket : sockets_) &#123; auto path = ANDROID_SOCKET_DIR \"/\" + socket.name; unlink(path.c_str()); &#125; //æ‰§è¡Œå›è°ƒ for (const auto&amp; f : reap_callbacks_) &#123; f(siginfo); &#125; //å¦‚æœè¿›ç¨‹æ¥æ”¶ä¿¡å·å¼‚å¸¸æˆ–è¢«ç»ˆæ­¢çš„çŠ¶æ€å¼‚å¸¸ï¼Œå¹¶ä¸”åŒ…å«reboot_on_failureæ ‡å¿—ï¼Œé‡å¯ç³»ç»Ÿ if ((siginfo.si_code != CLD_EXITED || siginfo.si_status != 0) &amp;&amp; on_failure_reboot_target_) &#123; LOG(ERROR) &lt;&lt; \"Service with 'reboot_on_failure' option failed, shutting down system.\"; trigger_shutdown(*on_failure_reboot_target_); &#125; //å½“serviceå‚æ•°ä¸ºexecæ—¶ï¼Œé‡Šæ”¾ç›¸åº”æœåŠ¡èµ„æº if (flags_ &amp; SVC_EXEC) UnSetExec(); if (flags_ &amp; SVC_TEMPORARY) return; pid_ = 0; flags_ &amp;= (~SVC_RUNNING); start_order_ = 0; // Oneshot processes go into the disabled state on exit, // except when manually restarted. //å½“serviceå‚æ•°æœ‰oneshotï¼Œæ²¡æœ‰restartå’Œresetæ—¶ï¼Œå°†serviceçŠ¶æ€ç½®ä¸ºdisable if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123; flags_ |= SVC_DISABLED; &#125; // Disabled and reset processes do not get restarted automatically. //ç¦ç”¨å’Œé‡ç½®çš„æœåŠ¡ï¼Œéƒ½ä¸èƒ½è‡ªåŠ¨é‡å¯ if (flags_ &amp; (SVC_DISABLED | SVC_RESET)) &#123; NotifyStateChange(\"stopped\"); return; &#125; ... //å°†æ ‡å¿—ç½®ä¸ºé‡å¯ä¸­ flags_ &amp;= (~SVC_RESTART); flags_ |= SVC_RESTARTING; // Execute all onrestart commands for this service. //æ‰§è¡Œè¯¥serviceä¸‹çš„æ‰€æœ‰onrestartå‘½ä»¤ onrestart_.ExecuteAllCommands(); NotifyStateChange(\"restarting\"); return;&#125; serviceç›¸å…³çš„å‚æ•°å¯ä»¥å»system/core/init/README.mdä¸­è‡ªè¡ŒæŸ¥çœ‹ è¿™ä¸ªå‡½æ•°æ£€æŸ¥äº†ä¸€å †serviceçš„æ ‡å¿—å’ŒçŠ¶æ€ï¼Œåˆ¤æ–­å¦‚ä½•å¤„ç†è¿™ä¸ªserviceï¼Œå¦‚æœéœ€è¦é‡å¯ï¼Œåˆ™è°ƒç”¨onrestart_.ExecuteAllCommands()æ‰§è¡Œè¯¥serviceä¸‹çš„æ‰€æœ‰onrestartå‘½ä»¤ï¼Œå…·ä½“çš„æ‰§è¡Œè¿‡ç¨‹ä¹‹å‰åœ¨å¯åŠ¨æœåŠ¡é‚£è¾¹å·²ç»åˆ†æè¿‡äº†ï¼Œè¿™é‡Œå°±ä¸å†å¾€ä¸‹çœ‹äº† æ€»ç»“è‡³æ­¤ï¼Œæ•´ä¸ªinitè¿›ç¨‹çš„å¯åŠ¨è¿‡ç¨‹æœ€é‡è¦çš„éƒ¨åˆ†åŸºæœ¬éƒ½å·²åˆ†æå®Œæˆï¼Œæˆ‘ä¹Ÿæ˜¯ä¸€è¾¹ä»ç½‘ä¸Šæœé›†èµ„æ–™ä¸€è¾¹å¯¹ç…§ç€æºç ç£•ç£•ç»Šç»Šçœ‹è¿‡æ¥çš„ï¼Œæœ‰ä»€ä¹ˆé”™è¯¯æˆ–è€…é—æ¼çš„éƒ¨åˆ†æ¬¢è¿æŒ‡æ­£ï¼Œè°¢è°¢ï½","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"initè¿›ç¨‹","slug":"initè¿›ç¨‹","permalink":"http://yoursite.com/tags/init%E8%BF%9B%E7%A8%8B/"}]},{"title":"å„å‚å•†Androidç³»ç»Ÿç¢°åˆ°çš„å¥‡å¥‡æ€ªæ€ªé—®é¢˜çš„è®°å½•","slug":"android/common/å„å‚å•†Androidç³»ç»Ÿç¢°åˆ°çš„å¥‡å¥‡æ€ªæ€ªé—®é¢˜çš„è®°å½•","date":"2021-12-23T02:39:00.000Z","updated":"2022-11-13T09:55:54.358Z","comments":true,"path":"2021/12/23/android/common/å„å‚å•†Androidç³»ç»Ÿç¢°åˆ°çš„å¥‡å¥‡æ€ªæ€ªé—®é¢˜çš„è®°å½•/","link":"","permalink":"http://yoursite.com/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/","excerpt":"","text":"å°ç±³MIUICamera2CaptureRequest.Builderçš„setæ–¹æ³•ï¼Œå¯¹éƒ¨åˆ†keyä¸ç”Ÿæ•ˆ 12// MIUIä¸­ï¼ŒCaptureRequest.Builderè®¾ç½®å›¾ç‰‡æ–¹å‘ä¸ç”Ÿæ•ˆcaptureBuilder.set(CaptureRequest.JPEG_ORIENTATION,getJpegOrientation(deviceRotation)); è§£å†³æ–¹æ³•ï¼šè·å¾—æ‹æ‘„å¥½çš„ç…§ç‰‡Bitmapåï¼Œå†å¯¹å…¶è¿›è¡Œæ—‹è½¬ 12345public Bitmap rotateBitmap(Bitmap bitmap, int angle) &#123; Matrix matrix = new Matrix(); matrix.setRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125; åä¸ºHarmonyOsTextureViewåä¸ºROMï¼ˆEMUIä¸ç¡®å®šæœ‰æ²¡æœ‰è¿™ç§æƒ…å†µï¼‰è®¡ç®—TextureViewè¾¹ç•Œçš„ä»£ç ä¼¼ä¹æœ‰bug ç°è±¡ï¼š ç›¸æœºé¢„è§ˆå’Œæ‹æ‘„æ—¶æœ‰æ¦‚ç‡ç”»é¢ç•¸å½¢ æ¸²æŸ“è¶…è¿‡ä¸€å±çš„æ–‡æœ¬ä¼šæ¸²æŸ“ç©ºç™½ è§£å†³æ–¹æ³•ï¼šæ‰‹åŠ¨ç®¡ç†TextureViewçš„é”€æ¯å’Œåˆ›å»º ç¬¬ä¸€æ­¥ï¼šåœ¨å¯¹TextureViewè®¾ç½®TextureView.SurfaceTextureListeneræ—¶ï¼Œå¦onSurfaceTextureDestroyedè¿”å›false 1234567891011121314151617181920mTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() &#123; @Override public void onSurfaceTextureAvailable(@NonNull SurfaceTexture surface, int width, int height) &#123; ... &#125; @Override public void onSurfaceTextureSizeChanged(@NonNull SurfaceTexture surface, int width, int height) &#123; &#125; @Override public boolean onSurfaceTextureDestroyed(@NonNull SurfaceTexture surface) &#123; // è¿™é‡Œé»˜è®¤æ˜¯è¿”å›trueï¼Œä»£è¡¨ç³»ç»Ÿè‡ªåŠ¨ç®¡ç†ï¼Œæˆ‘ä»¬æŠŠå®ƒè®¾ä¸ºfalseæ‰‹åŠ¨ç®¡ç† return false; &#125; @Override public void onSurfaceTextureUpdated(@NonNull SurfaceTexture surface) &#123; &#125;&#125;); ç¬¬äºŒæ­¥ï¼šåœ¨TextureViewä¸æ¸²æŸ“çš„æ—¶å€™æ‰‹åŠ¨releaseæ‰å…¶ä¸­çš„SurfaceTextureï¼Œåé¢å†æ¸²æŸ“æ—¶ï¼Œç³»ç»Ÿè°ƒç”¨drawæ–¹æ³•åï¼Œä¼šè‡ªåŠ¨é‡æ–°newä¸€ä¸ªSurfaceTextureå‡ºæ¥ 1234SurfaceTexture surfaceTexture = mTextureView.getSurfaceTexture();if (surfaceTexture != null) &#123; surfaceTexture.release();&#125; VIVOOriginOSå­—ä½“OriginOSä¸­ï¼ŒTextViewè®¾ç½®äº†android:fontFamilyåï¼Œä¸èƒ½åœ¨è®¾ç½®android:textStyleå±æ€§ï¼Œå¦åˆ™ä¼šå¯¼è‡´ä½¿ç”¨çš„å­—ä½“è¢«ç³»ç»Ÿé»˜è®¤å­—ä½“è¦†ç›–","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"å¸¸è§é—®é¢˜","slug":"Android/å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"å¸¸è§é—®é¢˜","slug":"å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"AOSPçš„ç¼–è¯‘åŠåˆ·æœº","slug":"android/aosp/AOSPçš„ç¼–è¯‘åŠåˆ·æœº","date":"2021-12-18T06:13:00.000Z","updated":"2023-02-26T10:34:30.144Z","comments":true,"path":"2021/12/18/android/aosp/AOSPçš„ç¼–è¯‘åŠåˆ·æœº/","link":"","permalink":"http://yoursite.com/2021/12/18/android/aosp/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA/","excerpt":"","text":"ç®€ä»‹ä¼—æ‰€å‘¨çŸ¥ï¼ŒAndroidæ˜¯å¼€æºçš„ï¼ŒAOSPï¼ˆAndroid Open Source Projectï¼‰ä¸ºAndroidå¼€æºé¡¹ç›®çš„ç¼©å†™ã€‚ä½œä¸ºä¸€åAndroidå¼€å‘ï¼ŒæŒæ¡Androidç³»ç»Ÿçš„å·¥ä½œæœºåˆ¶æ˜¯æŠ€æœ¯æˆé•¿ä¸­çš„å¿…ç»ä¹‹è·¯ï¼Œç¬¬ä¸€æ­¥å°±æ˜¯è‡ªå·±ç¼–è¯‘Androidç³»ç»Ÿã€‚ å‡†å¤‡å·¥ä½œ ä¸€å°å¯ä»¥è§£BLé”ï¼ˆBootLoaderï¼‰ï¼Œå¹¶ä¸”å‚å•†æä¾›äº†ç¡¬ä»¶é©±åŠ¨çš„è®¾å¤‡ï¼Œè¿™é‡Œæ¨èä½¿ç”¨Googleäº²å„¿å­æ‰‹æœºï¼ˆNexusã€Pixelç³»åˆ—ï¼‰ï¼Œå¯ä»¥è§£BLé”ï¼ŒGoogleå®˜æ–¹ä¼šæä¾›ç¡¬ä»¶é©±åŠ¨ï¼Œå¹¶ä¸”AOSPé‡Œä¼šæä¾›å¯¹åº”æœºå‹çš„é…ç½® ä¸€å—å‰©ä½™ç©ºé—´è‡³å°‘å¤§äº300GBçš„ç¡¬ç›˜ï¼ˆAndroid11æºç -150GBå·¦å³ï¼Œç¼–è¯‘äº§ç‰©-150GBå·¦å³ï¼‰ ç³»ç»Ÿæœ€å¥½ä¸ºLinuxï¼ŒMacOSä¹Ÿå¯ï¼ˆWindowså¯ä»¥ç”¨WSLï¼‰ ç³»ç»Ÿéœ€è¦ä½¿ç”¨Ubuntuï¼ˆæˆ‘ä¸ç¡®å®šåˆ«çš„Linuxå‘è¡Œç‰ˆå¯ä¸å¯ç”¨ï¼‰ï¼Œè‡ª2021å¹´6æœˆ22æ—¥èµ·ï¼ŒAOSPä¸å†æ”¯æŒåœ¨Windowsæˆ–MacOSä¸Šæ„å»ºï¼ˆWindowså¯ä»¥ä½¿ç”¨WSLï¼Œè¯¦è§WSLç¼–è¯‘AOSPå¿…è¦çš„å‡ ä¸ªå‰ç½®å·¥ä½œï¼‰ å†…å­˜è‡³å°‘è¦16GBï¼Œè¿‡å°çš„å†…å­˜ä¼šå¯¼è‡´ç”Ÿæˆbuild.ninjaæ–‡ä»¶å¤±è´¥ è¿™é‡Œæ˜¯Googleå®˜æ–¹çš„æ¨èè¦æ±‚ï¼šhttps://source.android.com/setup/build/requirements?hl=zh-cN ç¯å¢ƒæ­å»ºå‚è€ƒæ–‡æ¡£ï¼šhttps://source.android.com/source/initializing?hl=zh-cn ä¸»è¦å°±æ˜¯ä¸‹è½½å„ç§ç¼–è¯‘å·¥å…·ï¼Œåƒjdkï¼Œgccï¼Œg++ç­‰ï¼Œè¿˜æœ‰å„ç§åŠ¨æ€åº“ä»¥åŠè¾…åŠ©å·¥å…· æ³¨ï¼šæ­¤æ–‡æ¡£ä¸­éƒ¨åˆ†ç¯å¢ƒå®‰è£…æœ‰è¯¯ï¼Œç¼ºå¤±äº†ä¸€äº›å¿…è¦çš„åº“å®‰è£…ï¼Œå¯èƒ½ä¼šç¼–è¯‘ä¸­é€”æŠ¥é”™ï¼Œå¯ä»¥å‚è€ƒä¸‹æ–‡çš„ç¯å¢ƒå®‰è£…ï¼Œå¦‚æœç¼–è¯‘è¿˜æ˜¯å‡ºç°äº†ä¾èµ–ç¼ºå¤±ï¼Œå®‰è£…å¥½ç»§ç»­ç¼–è¯‘å³å¯ å®‰è£…JDKä»¥Ubuntuç³»ç»Ÿä¸ºä¾‹ï¼š 12sudo apt-get updatesudo apt-get install openjdk-11-jdk æ³¨ï¼šç°åœ¨AOSPç¼–è¯‘è¦æ±‚JDKç‰ˆæœ¬&gt;=9 å®‰è£…å…¶ä»–ç¨‹åºåŒ…1sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5 æ³¨ï¼šå®˜æ–¹æ–‡æ¡£ä¸­ç¼ºå¤±äº†libncurses5ï¼Œä¼šå¯¼è‡´ç¼–è¯‘ä¸­é€”æ‰¾ä¸åˆ°libncurses.so.5åº“ ä¸‹è½½æºç Androidæºç æ˜¯ç”±éå¸¸å¤šçš„Gitä»“åº“ç»„æˆçš„ï¼Œä¸ºäº†å¯ä»¥ç»Ÿä¸€ç®¡ç†è¿™ä¹ˆå¤šä¸ªGitä»“åº“ï¼ŒGoogleå‡ºäº†ä¸€æ¬¾å·¥å…·ï¼Œå«Repo å‚è€ƒæ–‡æ¡£ï¼šhttps://source.android.com/source/downloading?hl=zh-cn å› ä¸ºGoogleåœ¨å›½å†…è®¿é—®çš„é—®é¢˜ï¼Œå»ºè®®ä½¿ç”¨é•œåƒä¸‹è½½æºç ï¼Œä¸‹é¢æä¾›å‡ ä¸ªé•œåƒåœ°å€ï¼š æ¸…åå¤§å­¦ https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest ä¸­ç§‘å¤§ git://mirrors.ustc.edu.cn/aosp/platform/manifest repo initçš„æ—¶å€™å¯ä»¥æŒ‡å®šåˆ†æ”¯ï¼šhttps://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds åœ¨è¿™é‡Œå¯ä»¥æ‰¾åˆ°å¯¹åº”ç³»ç»Ÿåˆ†æ”¯æ‰€æ”¯æŒçš„è®¾å¤‡ï¼Œæ¯”å¦‚è¯´æˆ‘çš„è®¾å¤‡æ˜¯Pixel2ï¼Œåœ¨è¿™å¼ è¡¨ä¸Šå¯ä»¥çœ‹åˆ°android-11.0.0_r25è¿™ä¸ªåˆ†æ”¯ä¸‹çš„ä»£ç æ”¯æŒæˆ‘çš„è®¾å¤‡ï¼Œæ‰€ä»¥å¯ä»¥æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 1repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r25 ç„¶åå¼€å§‹è¿›è¡ŒåŒæ­¥ï¼š 1repo sync -j8 #j8ä»£è¡¨ä½¿ç”¨8ä¸ªçº¿ç¨‹ AOSPä»£ç ä¸‹è½½æ˜¯ä¸ªæ¼«é•¿çš„è¿‡ç¨‹ï¼Œéœ€è¦è€å¿ƒç­‰å¾… ä¸‹è½½é©±åŠ¨åœ¨https://developers.google.com/android/drivers?hl=zh-cnè¿™ä¸ªç½‘ç«™å¯ä»¥æ‰¾åˆ°Nexusã€Pixelç³»åˆ—çš„é©±åŠ¨ï¼Œè¦æ³¨æ„æ¯ä¸ªé©±åŠ¨åé¢ä¼šæœ‰ä¸€ä¸²ä»£å·ï¼Œéœ€è¦å’Œä½ ä¸‹è½½çš„AOSPæºç çš„buildå·ç›¸å¯¹åº” å°†ä»–ä»¬è§£å‹åä¼šå¾—åˆ°ä¸¤ä¸ªshellæ–‡ä»¶ å°†ä»–ä»¬å¤åˆ¶åˆ°ä¸‹è½½å¥½çš„aospæºç çš„æ ¹ç›®å½• æ³¨ï¼šç½‘ä¸Šå¾ˆå¤šæ•™ç¨‹è¯´ç»ˆç«¯è¦é€‰ç”¨bashä¸è¦ä½¿ç”¨zshï¼Œæˆ‘äº²æµ‹ä½¿ç”¨zshæ²¡æœ‰é—®é¢˜ï¼Œå¦‚æœåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­å‡ºç°é—®é¢˜ï¼Œå¯ä»¥å°è¯•åˆ‡æ¢shell å…ˆå°†shellåˆ‡æ¢åˆ°aospæºç æ ¹ç›®å½• æ‰§è¡Œä¸¤ä¸ªè§£å‹å‡ºæ¥çš„é©±åŠ¨shellï¼Œè®°å¾—è¦åŒæ„License æ‰§è¡Œsource build/envsetup.shï¼Œè¿™ä¼šå‘shellä¸­å†™å…¥ä¸€äº›ç¯å¢ƒå˜é‡ å…ˆmake cleanä¸€ä¸‹ ä½¿ç”¨lunchå‘½ä»¤é€‰æ‹©æ„å»ºç›®æ ‡ è¿™é‡Œæ˜¯è¯¥å‘½ä»¤çš„è§„åˆ™ï¼šhttps://source.android.com/setup/build/building?hl=zh-cn#choose-a-target 1lunch aosp_walleye-userdebug åé¢è·Ÿéšçš„çš„å‚æ•°å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼šhttps://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build ä½ ä¹Ÿå¯ä»¥åœ¨lunchåä¸åŠ å‚æ•°ï¼Œè¿™æ ·ä¼šå¼¹å‡ºä¸€ä¸ªèœå•æç¤ºæ‚¨é€‰æ‹©ç›®æ ‡ æŒ‡å®šå®Œæˆåä¼šå¼¹å‡ºè¿™æ ·ä¸€ä¸ªä¿¡æ¯æç¤º å¼€å§‹ç¼–è¯‘æ„å»ºéƒ¨åˆ†çš„æ–‡æ¡£åœ¨è¿™é‡Œï¼šhttps://source.android.com/setup/build/building?hl=zh-cn#build-the-codeå¦‚æœæ˜¯åˆæ¬¡ç¼–è¯‘ï¼Œæˆ‘ä»¬å°±ç›´æ¥ä½¿ç”¨må‘½ä»¤å°±å¯ä»¥äº† 1m -j8 #å¼€å¯8çº¿ç¨‹ç¼–è¯‘ æ³¨æ„äº‹é¡¹ï¼š ç°åœ¨ç›´æ¥ä½¿ç”¨makeå‘½ä»¤ä¼šæç¤ºCalling make directly is no longer supportedç„¶åé€€å‡ºç¼–è¯‘ï¼Œæ‰€ä»¥ä½¿ç”¨må‘½ä»¤æ›¿ä»£make ä¸èƒ½ä½¿ç”¨rootè´¦å·ç¼–è¯‘ åˆ·æœº å…ˆå°†æ‰‹æœºçš„BLé”è§£å¼€ï¼ˆæ¯ä¸ªæœºå‹éƒ½ä¸åŒï¼Œç½‘ä¸Šä¼šæœ‰å¯¹åº”çš„æ•™ç¨‹ï¼‰ï¼Œè¿›å…¥fastbootæ¨¡å¼\\ é…ç½®fastbootå·¥å…·ï¼ˆç°åœ¨Googleå¥½åƒæ¨å‡ºäº†åœ¨çº¿åˆ·å†™å·¥å…·https://flash.android.com/ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ï¼‰ï¼Œå¯ä»¥åœ¨aospç›®å½•ä¸‹é€šè¿‡make fastbootå‘½ä»¤ç¼–è¯‘å‡ºæ¥ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä»ç½‘ä¸Šä¸‹è½½ï¼šhttps://developer.android.com/studio/releases/platform-tools è¿›å…¥ç¼–è¯‘åäº§ç”Ÿçš„é•œåƒçš„ç›®å½•â€¦./aosp/out/target/product/walleye(è¿™ä¸ªæ˜¯ä½ æœºå‹çš„ä»£å·ï¼Œæ¯ç§æœºå™¨éƒ½ä¸ä¸€æ ·) æ‰§è¡Œå‘½ä»¤ 1fastboot flashall -w é‡å¯å³å¯çœ‹åˆ°ï¼Œæˆ‘ä»¬ç¼–è¯‘çš„Androidç³»ç»Ÿå·²ç»è¿è¡Œåˆ°äº†æ‰‹æœºä¸Š 1fastboot reboot #é‡å¯å‘½ä»¤ å¸¸è§é—®é¢˜MacOSä¸Šæ‰¾ä¸åˆ°SDK å»è¿™é‡Œhttps://github.com/phracker/MacOSX-SDKs/releasesä¸‹è½½å¯¹åº”ç‰ˆæœ¬çš„sdkï¼Œç„¶åå°†å®ƒæ”¾åˆ°/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKsç›®å½•ä¸‹ï¼Œç„¶åé‡æ–°ç¼–è¯‘ é™¤æ­¤ä¹‹å¤–ï¼Œä¹Ÿå¯ä»¥åœ¨Finderä¸­æŸ¥çœ‹ /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs è¿™ä¸ªç›®å½•ä¸‹å­˜åœ¨å“ªä¸ªç‰ˆæœ¬çš„sdkï¼Œç¡®å®šåå»ä¿®æ”¹â€¦./aosp/build/soong/cc/config/x86_darwin_host.goæ–‡ä»¶ï¼Œåœ¨darwinSupportedSdkVersionsè¿™ä¸ªæ•°ç»„ä¸­åŠ ä¸Šä½ ä½¿ç”¨çš„sdkçš„ç‰ˆæœ¬ ä¿å­˜åé‡æ–°ç¼–è¯‘ï¼Œè¿™ä¸ªæ–¹å¼å¯èƒ½å½“å‰ç¼–è¯‘è„šæœ¬ä¸æ”¯æŒä½ æ‰€ç”¨çš„sdkï¼Œå¯èƒ½ä¼šç¼–è¯‘æŠ¥é”™ï¼Œæ‰€ä»¥è¿˜æ˜¯æ¨èä½¿ç”¨ç¬¬ä¸€ç§æ–¹å¼ too many open filesåœ¨Linuxç³»ç»Ÿä¸‹æœ‰æ‰“å¼€æ–‡ä»¶æ•°çš„é™åˆ¶ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤è®¾ç½®æœ€å¤§å¯æ‰“å¼€æ–‡ä»¶æ•° 12# ulimit -a å¯ä»¥æŸ¥çœ‹å½“å‰é™åˆ¶ulimit -n 2048","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"}]},{"title":"èµ°é©¬ç¯å¼æ¨ªå‘æ»šåŠ¨çš„TextView","slug":"android/view/èµ°é©¬ç¯å¼æ¨ªå‘æ»šåŠ¨çš„TextView","date":"2021-05-26T10:01:00.000Z","updated":"2023-10-25T04:46:27.810Z","comments":true,"path":"2021/05/26/android/view/èµ°é©¬ç¯å¼æ¨ªå‘æ»šåŠ¨çš„TextView/","link":"","permalink":"http://yoursite.com/2021/05/26/android/view/%E8%B5%B0%E9%A9%AC%E7%81%AF%E5%BC%8F%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84TextView/","excerpt":"","text":"ç®€ä»‹æˆ‘ä»¬å¯ä»¥è®¾ç½®TextViewçš„android:ellipsize=&quot;marquee&quot;å±æ€§ï¼Œæ¥åšåˆ°å½“æ–‡å­—è¶…å‡ºä¸€è¡Œçš„æ—¶å€™å‘ˆç°è·‘é©¬ç¯æ•ˆæœã€‚ä½†TextViewçš„è¿™ä¸ªèµ°é©¬ç¯æ•ˆæœéœ€è¦è·å–ç„¦ç‚¹ï¼Œè€ŒåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªæ§ä»¶å¯ä»¥è·å¾—ç„¦ç‚¹ï¼Œæ›´é‡è¦çš„æ˜¯äº§å“è¦æ±‚æ— è®ºæ–‡å­—å†…å®¹æ˜¯å¦è¶…å‡ºä¸€è¡Œï¼Œéƒ½è¦æ»šåŠ¨æ•ˆæœã€‚ è¿™é‡Œå…ˆè´´ä¸€ä¸‹æœ€åå®ç°çš„Githubåœ°å€å’Œæ•ˆæœå›¾ https://github.com/dreamgyf/MarqueeTextView æ€è·¯æ€è·¯å…¶å®å¾ˆç®€å•ï¼Œæˆ‘ä»¬åªè¦å°†å•è¡Œçš„TextViewæˆªæˆä¸€å¼ Bitmapï¼Œç„¶åæˆ‘ä»¬å†è‡ªå®šä¹‰ä¸€ä¸ªViewï¼Œé‡å†™å®ƒçš„onDrawæ–¹æ³•ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´ï¼Œå°†è¿™å¼ Bitmapç”»åœ¨ä¸åŒçš„åæ ‡ä¸Šï¼ˆå·¦å³ä¸¤è¾¹å„drawä¸€æ¬¡ï¼‰ï¼Œè¿™æ ·è¿ç»­èµ·æ¥çœ‹èµ·æ¥å°±æ˜¯èµ°é©¬ç¯æ•ˆæœäº†ã€‚ åæ¥å’ŒåŒäº‹è®¨è®ºï¼Œä»–æå‡ºèƒ½ä¸èƒ½é€šè¿‡Canvasçš„å¹³ç§»é…åˆdrawTextå®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘æƒ³åº”è¯¥ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œä½†æˆ‘æ²¡æœ‰åšå°è¯•ï¼Œå„ä½çœ‹å®˜æ„Ÿå…´è¶£çš„å¯æ˜¯è¯•ä¸€ä¸‹è¿™ç§æ–¹æ¡ˆã€‚ å®ç°æˆ‘ä»¬å…ˆè‡ªå®šä¹‰ä¸€ä¸ªViewç»§æ‰¿è‡ªAppCompatTextViewï¼Œå†åœ¨åˆå§‹åŒ–çš„æ—¶å€™newä¸€ä¸ªTextViewï¼Œå¹¶é‡å†™onMeasureå’ŒonLayoutæ–¹æ³• 1234567891011121314151617181920private void init() &#123; mTextView = new TextView(getContext(), attrs); //TextViewå¦‚æœæ²¡æœ‰è®¾ç½®LayoutParamsï¼Œå½“setTextçš„æ—¶å€™ä¼šå¼•å‘NPEå¯¼è‡´å´©æºƒ mTextView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)); mTextView.setMaxLines(1);&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //å®½åº¦ä¸è®¾é™åˆ¶ mTextView.measure(MeasureSpec.UNSPECIFIED, heightMeasureSpec);&#125;@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); //ä¿è¯å¸ƒå±€åŒ…å«å®Œæ•´çš„Textå†…å®¹ mTextView.layout(left, top, left + mTextView.getMeasuredWidth(), bottom);&#125; è¿™æ ·åšæ˜¯ä¸ºäº†åˆ©ç”¨è¿™ä¸ªå†…éƒ¨TextViewç”Ÿæˆæˆ‘ä»¬éœ€è¦çš„Bitmapï¼ŒåŒæ—¶å€Ÿç”¨TextViewå†™å¥½çš„onMeasureæ–¹æ³•ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸ç”¨å†é‚£ä¹ˆå¤æ‚çš„é‡å†™onMeasureæ–¹æ³•äº† æ¥ä¸‹æ¥æ˜¯ç”ŸæˆBitmap 12345private void updateBitmap() &#123; mBitmap = Bitmap.createBitmap(mTextView.getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(mBitmap); mTextView.draw(canvas);&#125; è¿™ä¸ªå¾ˆç®€å•ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯é•¿åº¦è¦ä½¿ç”¨å†…éƒ¨æŒæœ‰çš„TextViewçš„getMeasuredWidthï¼Œå¦‚æœä½¿ç”¨getWidthçš„è¯ï¼Œæœ€å¤§å€¼ä¸ºå±å¹•çš„å®½åº¦ï¼Œå¾ˆå¯èƒ½å¯¼è‡´ç”Ÿæˆå‡ºçš„Bitmapä¸å…¨ï¼Œé«˜åº¦ç”¨è°çš„å€’æ˜¯æ— æ‰€è°“ åœ¨æ¯æ¬¡setTextæˆ–setTextSizeçš„æ—¶å€™éƒ½éœ€è¦æ›´æ–°Bitmapå¹¶é‡æ–°å¸ƒå±€ç»˜åˆ¶ 1234567891011121314151617181920212223242526272829private void init() &#123; mTextView.addOnLayoutChangeListener(new OnLayoutChangeListener() &#123; @Override public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; updateBitmap(); restartScroll(); &#125; &#125;);&#125;@Overridepublic void setText(CharSequence text, BufferType type) &#123; super.setText(text, type); //æ‰§è¡Œçˆ¶ç±»æ„é€ å‡½æ•°æ—¶ï¼Œå¦‚æœAttributeSetä¸­æœ‰textå‚æ•°ä¼šå…ˆè°ƒç”¨setTextï¼Œæ­¤æ—¶mTextViewå°šæœªåˆå§‹åŒ– if (mTextView != null) &#123; mTextView.setText(text); requestLayout(); &#125;&#125;@Overridepublic void setTextSize(int unit, float size) &#123; super.setTextSize(unit, size); //æ‰§è¡Œçˆ¶ç±»æ„é€ å‡½æ•°æ—¶ï¼Œå¦‚æœAttributeSetä¸­æœ‰textSizeå‚æ•°ä¼šå…ˆè°ƒç”¨setTextSizeï¼Œæ­¤æ—¶mTextViewå°šæœªåˆå§‹åŒ– if (mTextView != null) &#123; mTextView.setTextSize(size); requestLayout(); &#125;&#125; æ¥ä¸‹æ¥ï¼Œæˆ‘ç»™è¿™ä¸ªMarqueeTextViewå®šä¹‰äº†ä¸€äº›å‚æ•°ï¼Œä¸€ä¸ªæ˜¯spaceï¼ˆæ–‡å­—æ»šåŠ¨æ—¶ï¼Œå¤´å°¾çš„æœ€å°é—´éš”è·ç¦»ï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¯speedï¼ˆæ–‡å­—æ»šåŠ¨çš„é€Ÿåº¦ï¼‰ å…ˆçœ‹ä¸€ä¸‹onDrawçš„å®ç°å§ 123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected void onDraw(Canvas canvas) &#123; if (mBitmap != null) &#123; //å½“æ–‡å­—å†…å®¹ä¸è¶…è¿‡ä¸€è¡Œ if (mTextView.getMeasuredWidth() &lt;= getWidth()) &#123; //è®¡ç®—å¤´å°¾éœ€è¦é—´éš”çš„å®½åº¦ int space = mSpace - (getWidth() - mTextView.getMeasuredWidth()); if (space &lt; 0) &#123; space = 0; &#125; //å½“å·¦è¾¹çš„drawBitmapçš„åæ ‡è¶…è¿‡äº†æ˜¾ç¤ºå®½åº¦+é—´éš”å®½åº¦ï¼Œå³èµ°å®Œä¸€ä¸ªå¾ªç¯ï¼Œå³è¾¹çš„Bitmapå·²ç»æŒªåˆ°äº†æœ€å·¦è¾¹ï¼Œå°†åæ ‡é‡ç½® if (mLeftX &lt; -getWidth() - space) &#123; mLeftX += getWidth() + space; &#125; //ç”»å·¦è¾¹çš„bitmap canvas.drawBitmap(mBitmap, mLeftX, 0, getPaint()); if (mLeftX &lt; 0) &#123; //ç”»å³è¾¹çš„bitmapï¼Œä½ç½®ä¸ºæœ€å³è¾¹çš„åæ ‡-å·¦è¾¹bitmapå·²æ¶ˆå¤±çš„å®½åº¦+é—´éš”å®½åº¦ canvas.drawBitmap(mBitmap, getWidth() + mLeftX + space, 0, getPaint()); &#125; &#125; else &#123; //å½“æ–‡å­—å†…å®¹è¶…è¿‡ä¸€è¡Œ //å½“å·¦è¾¹çš„drawBitmapçš„åæ ‡è¶…è¿‡äº†å†…å®¹å®½åº¦+é—´éš”å®½åº¦ï¼Œå³èµ°å®Œä¸€ä¸ªå¾ªç¯ï¼Œå³è¾¹çš„Bitmapå·²ç»æŒªåˆ°äº†æœ€å·¦è¾¹ï¼Œå°†åæ ‡é‡ç½® if (mLeftX &lt; -mTextView.getMeasuredWidth() - mSpace) &#123; mLeftX += mTextView.getMeasuredWidth() + mSpace; &#125; //ç”»å·¦è¾¹çš„bitmap canvas.drawBitmap(mBitmap, mLeftX, 0, getPaint()); //å½“å°¾éƒ¨å·²ç»æ˜¾ç¤ºå‡ºæ¥çš„æ—¶å€™ if (mLeftX + (mTextView.getMeasuredWidth() - getWidth()) &lt; 0) &#123; //ç”»å³è¾¹çš„bitmapï¼Œä½ç½®ä¸ºå°¾éƒ¨çš„åæ ‡+é—´éš”å®½åº¦ canvas.drawBitmap(mBitmap, mTextView.getMeasuredWidth() + mLeftX + mSpace, 0, getPaint()); &#125; &#125; &#125;&#125; è¿™å°±æ˜¯åŸºæœ¬çš„ç»˜åˆ¶æ€è·¯ æ¥ä¸‹æ¥éœ€è¦è®©ä»–åŠ¨èµ·æ¥ï¼Œè¿™é‡Œä½¿ç”¨çš„Choreographerï¼Œæ¯æ¬¡æ”¶åˆ°Vsyncä¿¡å·ç³»ç»Ÿç»˜åˆ¶æ–°å¸§æ—¶éƒ½æ›´æ–°ä¸€ä¸‹åæ ‡å¹¶é‡ç»˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static final float BASE_FPS = 60f;private float mFps = BASE_FPS;/** * è·å–å½“å‰å±å¹•åˆ·æ–°ç‡ */private void updateFps() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123; mFps = context.getDisplay().getRefreshRate(); &#125; else &#123; WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); mFps = windowManager.getDefaultDisplay().getRefreshRate(); &#125;&#125;private Choreographer.FrameCallback frameCallback = new Choreographer.FrameCallback() &#123; @Override public void doFrame(long frameTimeNanos) &#123; invalidate(); //ä¿è¯åœ¨ä¸åŒåˆ·æ–°ç‡çš„å±å¹•ä¸Šï¼Œè§†è§‰ä¸Šçš„é€Ÿåº¦ä¸€è‡´ int speed = (int) (BASE_FPS / mFps * mSpeed); mLeftX -= speed; Choreographer.getInstance().postFrameCallback(this); &#125;&#125;;public void startScroll() &#123; Choreographer.getInstance().postFrameCallback(frameCallback);&#125;public void pauseScroll() &#123; Choreographer.getInstance().removeFrameCallback(frameCallback);&#125;public void stopScroll() &#123; mLeftX = 0; Choreographer.getInstance().removeFrameCallback(frameCallback);&#125;public void restartScroll() &#123; stopScroll(); startScroll();&#125; æœ€åï¼Œåœ¨Viewå¯è§æ€§å‘ç”Ÿå˜åŒ–æ—¶ï¼Œéœ€è¦æ§åˆ¶ä¸€ä¸‹åŠ¨ç”»çš„å¯åœ 123456789@Overrideprotected void onVisibilityChanged(@NonNull View changedView, int visibility) &#123; if (visibility == VISIBLE) &#123; updateFps(); Choreographer.getInstance().postFrameCallback(frameCallback); &#125; else &#123; Choreographer.getInstance().removeFrameCallback(frameCallback); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"}]},{"title":"Androidå¼€å‘å¸¸è§é—®é¢˜æ€»ç»“ï¼ˆæŒç»­æ›´æ–°ï¼‰","slug":"android/common/Androidå¼€å‘å¸¸è§é—®é¢˜æ€»ç»“ï¼ˆæŒç»­æ›´æ–°ï¼‰","date":"2021-04-19T08:47:00.000Z","updated":"2025-01-12T06:21:52.840Z","comments":true,"path":"2021/04/19/android/common/Androidå¼€å‘å¸¸è§é—®é¢˜æ€»ç»“ï¼ˆæŒç»­æ›´æ–°ï¼‰/","link":"","permalink":"http://yoursite.com/2021/04/19/android/common/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"Activityé€æ˜ä¸æ–¹å‘å½“ä¸”ä»…å½“Android 8.0ç³»ç»Ÿä¸­ï¼Œä¸èƒ½å¯¹ä¸€ä¸ªActivityåŒæ—¶è®¾ç½®é€æ˜ï¼ˆwindowIsTranslucentå’ŒwindowIsFloatingï¼‰å’Œæ–¹å‘ï¼ˆscreenOrientationï¼‰ï¼Œå¦åˆ™ä¼šæŠ›å‡ºOnly fullscreen opaque activities can request orientationå¼‚å¸¸å´©æºƒ è§£å†³æ–¹æ³•ï¼š åœ¨ä»£ç ä¸­å…ˆåˆ¤æ–­ç³»ç»Ÿç‰ˆæœ¬ï¼Œå†è®¾ç½®æ–¹å‘ 12345678override fun onCreate(savedInstanceState: Bundle?) &#123; ... if (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) &#123; @SuppressLint(\"SourceLockedOrientationActivity\") requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT &#125; ...&#125; TextViewé‡æ–°å¸ƒå±€TextViewåœ¨è°ƒç”¨setTextåä¸ä¸€å®šä¼šèµ°requestLayoutæ–¹æ³•ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ä¼šå¯¼è‡´æ˜¾ç¤ºå¼‚å¸¸ï¼Œæ¯”å¦‚å› RecyclerViewå¤ç”¨å¯¼è‡´é•¿åº¦ä¸ç¬¦åˆé¢„æœŸçš„é—®é¢˜ è§£å†³æ–¹æ¡ˆï¼šç®€å•æ¥è¯´å½“TextViewçš„widthå±æ€§ä¸ä¸ºWRAP_CONTENTä¸”æ–‡å­—é«˜åº¦æ²¡å‘ç”Ÿå˜åŒ–çš„æƒ…å†µä¸‹ï¼Œå®ƒå°±ä¸ä¼šé‡æ–°å¸ƒå±€ï¼Œå¦‚æœä½ éœ€è¦å®ƒé‡æ–°è®¡ç®—å®½é«˜çš„è¯ï¼Œæ³¨æ„ä»¥ä¸Šçš„æ¡ä»¶ï¼Œè®¾ç½®åˆé€‚çš„å±æ€§å³å¯ï¼Œå…·ä½“çš„æºç åˆ†æå¯ä»¥å‚è€ƒ ä» TextView.setText() çœ‹ requestLayout å’Œ invalidate æ–¹æ³•æœ‰ä»€ä¹ˆä¸åŒ è¿™ç¯‡æ–‡ç«  ellipseTextViewåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œellipseå±æ€§ä¼šå¤±æ•ˆ setTextè®¾ç½®äº†BufferTypeä¸ºNORMALä»¥å¤–çš„å…¶ä»–å€¼ TextViewè®¾ç½®äº†MovementMethod layouté€šè¿‡TextViewä¸­çš„android.text.Layoutï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®ƒè®¡ç®—å¾ˆå¤šä¸œè¥¿ï¼Œæ¯”å¦‚é€šè¿‡x ,yåæ ‡å»è·å–å­—ç¬¦ä¸‹æ ‡å‘€ï¼Œæˆ–è€…é€šè¿‡å­—ç¬¦ä¸‹æ ‡å»è®¡ç®—è¿™ä¸ªæ–‡å­—xåæ ‡ç­‰ç­‰ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œandroid.text.Layoutåœ¨è®¡ç®—çš„è¿‡ç¨‹ä¸­ä¸ä¼šå»è€ƒè™‘TextViewçš„paddingï¼Œæ‰€ä»¥åœ¨å¼€å‘çš„è¿‡ç¨‹ä¸­æˆ‘ä»¬è‡ªå·±éœ€è¦è¿›è¡Œä¸€äº›å¤„ç†ï¼Œæ¯”å¦‚è¯´é€šè¿‡x ,yåæ ‡å»è·å–å­—ç¬¦ä¸‹æ ‡çš„æ—¶å€™ï¼Œä¼ å…¥çš„x, yå€¼è¦å‡å»paddingLeftï¼ŒpaddingTopï¼Œå½“é€šè¿‡å­—ç¬¦ä¸‹æ ‡å»è®¡ç®—æ–‡å­—xåæ ‡åï¼Œè¦å†åŠ ä¸ŠpaddingLeftæ‰æ˜¯æ­£ç¡®çš„xåæ ‡ æ»‘åŠ¨ æ»‘åŠ¨åµŒå¥— æ»‘åŠ¨ç»„ä»¶çš„åµŒå¥—å¯èƒ½ä¼šäº§ç”Ÿä»¥ä¸‹ä¸€äº›é—®é¢˜ï¼š æ»‘åŠ¨å†²çª è§£å†³æ–¹æ³•ï¼šä½¿ç”¨NestedScrollViewæ›¿ä»£ScrollViewï¼ŒRecyclerViewå¯ä»¥è®¾ç½®å±æ€§android:nestedScrollingEnabled=&quot;false&quot;æˆ–ä»£ç é‡ŒsetNestedScrollingEnabled(false);æ¥ç¦ç”¨ç»„ä»¶è‡ªèº«çš„æ»‘åŠ¨ æ³¨æ„ï¼šå¦‚æœRecyclerViewåªèƒ½æ˜¾ç¤ºä¸€ä¸ªItemçš„è¯ï¼Œéœ€è¦è®¾ç½®NestedScrollViewçš„å±æ€§android:fillViewport=&quot;true&quot; æ»‘åŠ¨å¤±æ•ˆ ScrollViewè®¾ç½®fillViewport=&quot;true&quot;çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå¯¹ScrollViewçš„ç›´æ¥å­viewè®¾ç½®ä¸Šä¸‹marginï¼Œåœ¨è¶…å‡ºå†…å®¹çš„é«˜åº¦å°äºè®¾ç½®çš„marginçš„æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ•´ä¸ªScrollViewæ»‘åŠ¨å¤±æ•ˆ ç„¦ç‚¹æŠ¢å  ScrollViewã€RecyclerViewç­‰æ»‘åŠ¨ç»„ä»¶å¯èƒ½ä¼šæŠ¢å ç„¦ç‚¹ï¼Œå¯¼è‡´ç•Œé¢æ˜¾ç¤ºæ—¶ç›´æ¥æ»‘åŠ¨åˆ°å¯¹åº”ç»„ä»¶çš„ä½ç½®ï¼Œè€Œä¸æ˜¯é¡¶éƒ¨ è§£å†³æ–¹æ³•ï¼šåœ¨é¡¶éƒ¨View(æˆ–è€…å…¶ä»–ä½ æ‰€æœŸæœ›çš„åˆå§‹ä½ç½®)åŠ ä¸Šå±æ€§android:focusable=&quot;true&quot;å’Œandroid:focusableInTouchMode=&quot;true&quot; æ–°è§£å†³æ–¹æ³•ï¼šåœ¨é¡¶éƒ¨Viewä¸ŠåŠ android:descendantFocusabilityå±æ€§ï¼Œè¯¥å±æ€§æ˜¯ç”¨æ¥å®šä¹‰çˆ¶å¸ƒå±€ä¸å­å¸ƒå±€ä¹‹é—´çš„å…³ç³»çš„ï¼Œå®ƒæœ‰ä¸‰ç§å€¼ï¼š beforeDescendantsï¼šçˆ¶å¸ƒå±€ä¼šä¼˜å…ˆå…¶å­ç±»æ§ä»¶è€Œè·å–åˆ°ç„¦ç‚¹ afterDescendantsï¼šçˆ¶å¸ƒå±€åªæœ‰å½“å…¶å­ç±»æ§ä»¶ä¸éœ€è¦è·å–ç„¦ç‚¹æ—¶æ‰è·å–ç„¦ç‚¹ blocksDescendantsï¼šçˆ¶å¸ƒå±€ä¼šè¦†ç›–å­ç±»æ§ä»¶è€Œç›´æ¥è·å¾—ç„¦ç‚¹ ä½¿ç”¨blocksDescendantsè¦†ç›–å­å¸ƒå±€ç„¦ç‚¹ä»¥è§£å†³ç„¦ç‚¹æŠ¢å é—®é¢˜ RecyclerViewAdapter åœ¨onBindViewHolderä¸­è®¾ç½®å­Viewå›è°ƒæ—¶éœ€è¦æ³¨æ„ å¦‚æœå›è°ƒçš„å‚æ•°åŒ…æ‹¬positionæ—¶ï¼Œéœ€è¦æ³¨æ„æœ‰æ²¡æœ‰åœ°æ–¹ä¼šè°ƒç”¨notifyItemRemovedæˆ–notifyItemRangeRemovedï¼Œå¦‚æœæœ‰ï¼Œéœ€è¦ä½¿ç”¨holder.getAdapterPosition()æ¥ä»£æ›¿onBindViewHolderæ–¹æ³•çš„positionå‚æ•° åŸå› ï¼šnotifyItemRemovedä¸ä¼šå¯¹å…¶ä»–çš„Itemé‡æ–°è°ƒç”¨onBindViewHolderï¼Œè¿™æ ·å¯èƒ½ä¼šå¯¼è‡´positioné”™ä½ã€‚holder.getAdapterPosition()æ–¹æ³•ä¼šè¿”å›æ•°æ®åœ¨ Adapter ä¸­çš„ä½ç½®ï¼ˆå³ä½¿ä½ç½®çš„å˜åŒ–è¿˜æœªåˆ·æ–°åˆ°å¸ƒå±€ä¸­ï¼‰ å¦‚ä½•åœ¨æ›´æ–°æ•°æ®åé‡æ–°å®šä½åˆ°é¡¶éƒ¨ 1234567891011//é‡å†™çˆ¶ç±»æ–¹æ³•ï¼Œè·å¾—ç»‘å®šçš„RecyclerView@Overridepublic void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); mRecyclerView = recyclerView;&#125;//å½“æ•°æ®æ›´æ–°åè°ƒç”¨if (mRecyclerView != null &amp;&amp; mRecyclerView.getChildCount() &gt; 0) &#123; mRecyclerView.scrollToPosition(0);&#125; ä¹‹å‰å°è¯•è¿‡mRecyclerView.scrollTo(0, 0);ä½†æ²¡æœ‰èµ·æ•ˆï¼Œä¸æ¸…æ¥šä¸ºä»€ä¹ˆ åŠ¨æ€éƒ¨åˆ†æ›´æ–°æ•°æ®æ—¶ å¦‚æœRecyclerViewéœ€è¦åŠ¨æ€æ›´æ–°éƒ¨åˆ†æ•°æ®ï¼Œå¹¶ä¸”åœ¨onBindViewHolderæ—¶å¯¹æŸäº›viewè®¾ç½®äº†äº‹ä»¶æˆ–è€…å›è°ƒç­‰ï¼Œå¦‚æœæ­¤æ—¶ä½¿ç”¨åˆ°äº†positionå‚æ•°éœ€è¦æ³¨æ„ï¼Œå¦‚æœä½ åªnotifyäº†éƒ¨åˆ†æ•°æ®æ›´æ–°ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ›´æ–°åéƒ¨åˆ†ViewHolderä¸­çš„å›è°ƒé‡Œçš„positionä¸æ­£ç¡®ï¼Œå»ºè®®ï¼š ä½¿ç”¨notifyDataSetChanged() ä½¿ç”¨notifyItemï¼Œä½†æ˜¯åœ¨onBindViewHolderä¸­è®¾ç½®å›è°ƒæ—¶ä¸è¦ä½¿ç”¨positionå‚æ•°ï¼Œè€Œæ˜¯ä½¿ç”¨holder.getAdapterPosition()æ›¿ä»£ï¼ˆæ³¨æ„è¿™ä¸ªæ–¹æ³•åœ¨ViewHolderæ²¡æœ‰å’ŒRecyclerViewç»‘å®šæ—¶ä¼šè¿”å›-1 NO_POSITIONï¼‰ ItemDecoration StaggeredGridLayoutManagerä¸‹ItemDecorationçš„offsetè®¡ç®—é”™è¯¯ ä¸»è¦æ˜¯å› ä¸ºRecyclerViewåŠ¨æ€æ›´æ–°æ•°æ®æ—¶ï¼Œä¼šæ‰§è¡Œå¤šæ¬¡measureï¼Œä½†åªä¼šåœ¨ç¬¬ä¸€æ¬¡measureçš„æ—¶å€™è°ƒç”¨ItemDecoration.getItemOffsetsï¼ˆå› ä¸ºLPé‡Œçš„mInsetsDirtyå˜é‡ï¼‰ï¼Œæ­¤æ—¶è·å¾—çš„spanIndexæ˜¯ä¸€ä¸ªé”™è¯¯å€¼ è¿™ä¸ªé—®é¢˜çš„å…·ä½“åˆ†æå¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« ï¼Œæš‚æ—¶æ²¡æœ‰ä»€ä¹ˆå¥½çš„è§£å†³æ–¹æ¡ˆï¼Œä¸å»ºè®®å¤§å®¶ä½¿ç”¨åå°„ï¼Œæ¯•ç«Ÿä½ ä¸çŸ¥é“Androidä¼šä¸ä¼šæ›´æ”¹è¿™ä¸ªå˜é‡ åµŒå¥—ViewPageråœ¨RecyclerViewä¸­åµŒå¥—ViewPagerçš„æƒ…å†µä¸‹ï¼Œå½“ä½ å°†ä¸€ä¸ªViewPageræ»‘åŠ¨å‡ºè§†é‡å†æ»‘å›æ¥ï¼Œè¿™ä¸ªViewPagerçš„ä¸‹ä¸€ä¸ªåˆ‡æ¢ä¼šæ²¡æœ‰åŠ¨ç”» åŸå› ï¼šå½“RecyclerViewçš„Itemæ»‘å…¥æ»‘å‡ºå±å¹•æ—¶åˆ†åˆ«ä¼šè°ƒç”¨å­Viewçš„onAttachedToWindowå’ŒonDetachedFromWindowæ–¹æ³•ï¼Œå½“ViewPagerè§¦å‘onAttachedToWindowåï¼Œä¼šå°†å…¶é‡Œé¢çš„ä¸€ä¸ªè¡¨ç¤ºæ˜¯å¦ä¸ºç¬¬ä¸€æ¬¡å¸ƒå±€çš„æˆå‘˜å˜é‡mFirstLayoutèµ‹å€¼ä¸ºtrueï¼Œå½“è¿™ä¸ªå˜é‡ä¸ºtrueæ—¶ï¼ŒViewPagerä¼šä»¥æ— åŠ¨ç”»çš„æ–¹å¼æ˜¾ç¤ºå½“å‰Item è§£å†³æ–¹æ³•ï¼šé‡å†™RecyclerView.Adapterçš„onViewAttachedToWindowæ–¹æ³•ï¼Œåœ¨é‡Œé¢å¯¹ViewPagerè°ƒç”¨å…¶requestLayoutæ–¹æ³•ï¼Œåœ¨ViewPager.onLayoutæ–¹æ³•æœ€åï¼Œä¼šå°†mFirstLayoutå˜é‡é‡æ–°èµ‹å€¼ä¸ºfalse BitmapRenderScripté«˜æ–¯æ¨¡ç³Šåœ¨ä½¿ç”¨RenderScriptåšé«˜æ–¯æ¨¡ç³Šæ—¶ï¼Œéœ€è¦æ³¨æ„ï¼Œå®ƒåªæ”¯æŒæ ¼å¼ä¸ºALPHA_8ã€ARGB_4444ã€ARGB_8888ã€RGB_565çš„Bitmapï¼Œå¯¹äºå…¶ä»–æ ¼å¼çš„Bitmapï¼Œå¯ä»¥å°è¯•ä½¿ç”¨Bitmap.reconfigureæ–¹æ³•è½¬æ¢æ ¼å¼ï¼ˆè¿™ä¸ªæ–¹æ³•ä¸èƒ½å°†Bitmapä»å°æ ¼å¼è½¬æ¢æˆå¤§æ ¼å¼ï¼Œæ¯”å¦‚ä¸èƒ½ä»å ç”¨32ä¸ªbitsçš„ARGB_8888è½¬æ¢æˆå ç”¨64ä¸ªbitsçš„RGBA_F16ï¼‰ Dialog ç”Ÿå‘½å‘¨æœŸ åˆå§‹åŒ–æ—¶éœ€è¦æ³¨æ„ Dialogåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨show()æ–¹æ³•åæ‰ä¼šæ‰§è¡ŒonCreate(Bundle savedInstanceState)æ–¹æ³•ï¼Œå› æ­¤å»ºè®®è‡ªå®šä¹‰Dialogæ—¶å°†findViewByIdç­‰åˆå§‹åŒ–æ“ä½œæ”¾åœ¨æ„é€ å‡½æ•°ä¸­è¿›è¡Œï¼Œé¿å…å¤–éƒ¨ä½¿ç”¨æ—¶å› åœ¨show()ä¹‹å‰è®¾ç½®è§†å›¾æ•°æ®å¯¼è‡´NPE PopupWindow ç‚¹å‡»æ²¡ååº” PopupWindowå¦‚æœä¸è®¾ç½®èƒŒæ™¯çš„è¯ï¼Œåœ¨æŸäº›5.xä»¥ä¸‹ç³»ç»Ÿæœºå‹ä¸Šä¼šå‡ºç°ç‚¹å‡»æ²¡ååº”çš„é—®é¢˜ è§£å†³æ–¹æ³•ï¼šç»™PopupWindowè®¾ç½®ä¸€ä¸ªç©ºèƒŒæ™¯popupWindow.setBackgroundDrawable(new BitmapDrawable(mContext.getResources(), (Bitmap) null)); è¯¦è§ï¼šhttps://juejin.cn/post/6844903761488379912 å¹¿æ’­ éšå¼å¹¿æ’­ åœ¨Android8.0ä»¥ä¸Šçš„ç³»ç»Ÿï¼Œå¤§éƒ¨åˆ†çš„éšå¼å¹¿æ’­éƒ½è¢«é™åˆ¶ä¸å¯ä½¿ç”¨ã€‚ è§£å†³æ–¹æ³•ï¼š ä½¿ç”¨åŠ¨æ€å¹¿æ’­ ä½¿ç”¨æ˜¾ç¤ºå¹¿æ’­1234567891011121314151617181920// æ–¹å¼ä¸€: è®¾ç½®ComponentIntent intent = new Intent(SOME_ACTION);intent.setComponent(new ComponentName(context, SomeReceiver.class));context.sendBroadcast(intent);// æ–¹å¼äºŒ: è®¾ç½®PackageIntent intent = new Intent(SOME_ACTION);intent.setPackage(\"com.dreamgyf.xxx\");context.sendBroadcast(intent);// ä¸çŸ¥é“åŒ…åçš„è¯å¯ä»¥é€šè¿‡PackageManagerè·å–æ‰€æœ‰æ³¨å†Œäº†æŒ‡å®šactionçš„å¹¿æ’­çš„packageIntent actionIntent = new Intent(SOME_ACTION);PackageManager pm = context.getPackageManager();List&lt;ResolveInfo&gt; matches = pm.queryBroadcastReceivers(actionIntent, 0);for (ResolveInfo resolveInfo : matches) &#123; Intent intent = new Intent(actionIntent); intent.setPackage(resolveInfo.activityInfo.applicationInfo.packageName); intent.setAction(SOME_ACTION); context.sendBroadcast(intent); &#125; è½¯é”®ç›˜ å¼¹èµ·è½¯é”®ç›˜ ç½‘ä¸Šå¤§éƒ¨åˆ†æ–‡ç« æ‰€å†™çš„å¼¹èµ·è½¯é”®ç›˜çš„æ–¹æ³•å¹¶ä¸å®Œç¾ï¼Œå¤§éƒ¨åˆ†æ–‡ç« è®©ä½ åœ¨onResumeæ—¶å†å¼¹èµ·ï¼Œæœ‰çš„æ–‡ç« ç”šè‡³è®©ä½ postDelayedï¼Œéå¸¸ä¸é è°±ï¼Œç»è¿‡æœ¬äººåˆ†æï¼Œè½¯é”®ç›˜çš„å¼¹èµ·éœ€è¦æ»¡è¶³ä»¥ä¸‹å‡ ä¸ªæ¡ä»¶ï¼š æ§ä»¶ä¸ºEditTextæˆ–å…¶å­ç±» æ§ä»¶æ‰€åœ¨çš„windowè¦è·å¾—ç„¦ç‚¹ æ§ä»¶æœ¬èº«è¦è·å¾—ç„¦ç‚¹ æ ¹æ®ä»¥ä¸Šå‡ ä¸ªæ¡ä»¶ï¼Œæˆ‘å†™äº†ä¸€ä¸ªå®Œç¾å¼¹èµ·è½¯é”®ç›˜çš„æ–¹æ³•ï¼ŒonCreateæ—¶ä¹Ÿå¯ä»¥ç…§å¸¸ä½¿ç”¨ï¼š 1234567891011121314151617fun View.showKeyboard() &#123; val ims = context.getSystemService(Context.INPUT_METHOD_SERVICE) as? InputMethodManager ?: return if (hasWindowFocus()) &#123; requestFocus() ims.showSoftInput(this, 0) &#125; else &#123; viewTreeObserver.addOnWindowFocusChangeListener(object : OnWindowFocusChangeListener &#123; override fun onWindowFocusChanged(hasFocus: Boolean) &#123; if (hasFocus) &#123; viewTreeObserver.removeOnWindowFocusChangeListener(this) requestFocus() ims.showSoftInput(this@showKeyboard, 0) &#125; &#125; &#125;) &#125;&#125; å®ä½“é”®ç›˜ EditTextæœ‰ç„¦ç‚¹æ—¶ä¼šæ‹¦æˆªé”®ç›˜çš„æ•°å­—é”® è§£å†³æ–¹æ³•ï¼šä½¿ç”¨TextWatcherç­‰ç›‘å¬EditTextè¾“å…¥ å†…å­˜æ³„æ¼ åŠ¨ç”» åœ¨Activityé”€æ¯ä¹‹å‰å¦‚æœæ²¡æœ‰cancelæ‰ï¼Œä¼šå¯¼è‡´è¿™ä¸ªActivityå†…å­˜æ³„æ¼ ClickableSpan ä½¿ç”¨SpannableString.setSpanæ–¹æ³•è®¾ç½®ClickableSpanå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ åŸå› ï¼šTextViewåœ¨onSaveInstanceStateæ—¶ä¼šå°†ClickableSpanå¤åˆ¶ä¸€ä»½ï¼Œç”±äºæŸäº›åŸå› ï¼ŒSpannableStringä¸ä¼šåˆ é™¤è¿™ä¸ªClickableSpanï¼Œä»è€Œå¯¼è‡´å†…å­˜æ³„æ¼ï¼Œè¯¦è§ï¼šStackOverflow è§£å†³æ–¹æ³•ï¼šè‡ªå®šä¹‰ä¸€ä¸ªæŠ½è±¡ç±»åŒæ—¶ç»§æ‰¿ClickableSpanå’Œå®ç°NoCopySpanæ¥å£ï¼Œå¤–éƒ¨setSpanæ—¶ä½¿ç”¨è¿™ä¸ªæŠ½è±¡ç±» Fragment Fragmentå°½é‡ä¸è¦ä½¿ç”¨å¸¦å‚æ„é€ å‡½æ•°ï¼Œä¸€å®šè¦ä¿è¯æœ‰ä¸€ä¸ªä¸å«å‚çš„æ„é€ å‡½æ•°ï¼Œå¦åˆ™åœ¨Activityé‡å»ºæ—¶å°è¯•åå°„newInstanceæ¢å¤Fragmentæ—¶ä¼šæŠ›å‡ºCould not find Fragment constructorå¼‚å¸¸ æ··æ·† åå°„ å¦‚æœä½¿ç”¨åˆ°äº†åå°„ï¼Œéœ€è¦ç‰¹åˆ«æ³¨æ„éœ€ä¸éœ€è¦åœ¨proguard-rulesä¸­åŠ å…¥keepè§„åˆ™ moduleæ··æ·† å¦‚æœæ˜¯å¤šmoduleé¡¹ç›®ï¼Œæƒ³è¦åœ¨moduleä¸­å¢åŠ æ··æ·†è§„åˆ™ï¼ŒproguardFileså±æ€§æ˜¯æ— æ•ˆçš„ï¼Œåº”è¯¥ä½¿ç”¨consumerProguardFileså±æ€§ 1234567891011121314android &#123; compileSdkVersion 28 defaultConfig &#123; minSdkVersion 21 targetSdkVersion 28 versionName repo.version testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" consumerProguardFiles 'proguard-rules.pro' //è¿™é‡Œ &#125; ...&#125; ç›¸æœºå¼€å‘ æ‹ç…§è§’åº¦ ç›¸æœºçš„æ–¹å‘ä¸€èˆ¬æ˜¯ä»¥æ‰‹æœºæ¨ªå‘ä½œä¸ºæ­£æ–¹å‘ï¼Œè¿™æ ·å¦‚æœæˆ‘ä»¬ä»¥ç«–å±çš„æ–¹å¼æ‹ç…§ï¼Œæ‹å‡ºæ¥çš„ç…§ç‰‡å¯èƒ½ä¼šå‡ºç°æ—‹è½¬äº†90åº¦çš„æƒ…å†µï¼Œè¿™æ—¶å€™å°±éœ€è¦åœ¨æ‹ç…§å®Œåå¤„ç†ä¸€ä¸‹å›¾ç‰‡ï¼Œæ—‹è½¬åˆ°æ­£ç¡®ä½ç½®ã€‚ å…·ä½“ä»‹ç»ä¸ç®—æ³•åœ¨Android SDKä¸­CaptureRequest.JPEG_ORIENTATIONçš„æ³¨é‡Šä¸­ 12345678910111213141516171819private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) &#123; if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0; //è·å¾—ç›¸æœºæ–¹å‘ä¸è®¾å¤‡æ–¹å‘é—´çš„å¤¹è§’ int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION); // Round device orientation to a multiple of 90 deviceOrientation = (deviceOrientation + 45) / 90 * 90; // Reverse device orientation for front-facing cameras boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT; if (facingFront) deviceOrientation = -deviceOrientation; // Calculate desired JPEG orientation relative to camera orientation to make // the image upright relative to the device orientation int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360; return jpegOrientation;&#125; è®¡ç®—å¥½è§’åº¦åå°±å¯ä»¥å¯¹å›¾ç‰‡åšæ—‹è½¬äº†ï¼Œç½‘ä¸Šæœ‰å¾ˆå¤šæ–‡ç« éƒ½è¯´ä½¿ç”¨è¿™ç§æ–¹å¼åšæ—‹è½¬ 1captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getJpegOrientation(deviceRotation)); ä½†å®é™…ä¸Šåœ¨æŸäº›ç³»ç»Ÿä¸Š (MIUI)ï¼Œè®¾ç½®çš„è¿™ä¸ªå‚æ•°å¹¶ä¸ä¼šç”Ÿæ•ˆï¼Œæ‰€ä»¥æˆ‘çš„æ–¹æ¡ˆæ˜¯ï¼Œè·å¾—æ‹æ‘„å¥½çš„ç…§ç‰‡Bitmapåï¼Œå†å¯¹å…¶è¿›è¡Œæ—‹è½¬ 12345public Bitmap rotateBitmap(Bitmap bitmap, int angle) &#123; Matrix matrix = new Matrix(); matrix.setRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"å¸¸è§é—®é¢˜","slug":"Android/å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"å¸¸è§é—®é¢˜","slug":"å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"Androidå¯¹Javaçš„ä¿®æ”¹-SimpleDateFormatç±»","slug":"android/common/Androidå¯¹Javaçš„ä¿®æ”¹-SimpleDateFormatç±»","date":"2021-03-01T09:06:00.000Z","updated":"2022-11-13T09:55:54.357Z","comments":true,"path":"2021/03/01/android/common/Androidå¯¹Javaçš„ä¿®æ”¹-SimpleDateFormatç±»/","link":"","permalink":"http://yoursite.com/2021/03/01/android/common/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB/","excerpt":"","text":"ç®€ä»‹Androidä¼šå¯¹éƒ¨åˆ†OpenJDKä¸­çš„ä»£ç è¿›è¡Œä¸€äº›ä¿®æ”¹ï¼Œæœ¬ç¯‡è®°å½•ä¸€ä¸‹å› ä¸ºè¿™äº›ä¿®æ”¹è€Œè¸©è¿‡çš„ä¸€äº›å‘ã€‚ é—®é¢˜æè¿°ä¸€ä¸ªåœ¨çº¿ä¸Šè¿è¡Œè‰¯å¥½çš„Dateå·¥å…·ç±»åœ¨å†™å•å…ƒæµ‹è¯•æ—¶ä¸€ç›´æŠ¥ParseExceptionï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617public static String utc2Local(String utcTime) &#123; String utcTimePatten = \"yyyy-MM-dd'T'HH:mm:ssZZZZZ\"; String localTimePatten = \"yyyy.MM.dd\"; SimpleDateFormat utcFormater = new SimpleDateFormat(utcTimePatten); utcFormater.setTimeZone(TimeZone.getTimeZone(\"UTC\"));//æ—¶åŒºå®šä¹‰å¹¶è¿›è¡Œæ—¶é—´è·å– Date gpsUTCDate = null; try &#123; gpsUTCDate = utcFormater.parse(formatTimeStr(utcTime)); &#125; catch (Exception e) &#123; e.printStackTrace(); return utcTime; &#125; SimpleDateFormat localFormater = new SimpleDateFormat(localTimePatten); localFormater.setTimeZone(TimeZone.getDefault()); String localTime = localFormater.format(gpsUTCDate.getTime()); return localTime;&#125; è¿™é‡Œä¼ å…¥çš„å‚æ•°utcTimeä¸ºâ€2020-01-01 08:00:00+08:00â€ è¿™æ®µä»£ç åœ¨Androidç¯å¢ƒä¸‹è¿è¡Œè‰¯å¥½ï¼Œä½†åœ¨å•å…ƒæµ‹è¯•ä¸‹ä¸€ç›´æŠ¥é”™ åŸå› Androidå¯¹OpenJDKä¸­çš„SimpleDateFormatè¿›è¡Œäº†ä¿®æ”¹ï¼Œå…·ä½“åœ¨subParseNumericZoneæ–¹æ³•ä¸­ï¼š å¯ä»¥çœ‹åˆ°ï¼ŒOpenJDKåŸæœ¬æ˜¯ä¸æ”¯æŒå¸¦å†’å·çš„å†™æ³•çš„ï¼Œè€Œåœ¨Androidä¸­ä¿®æ”¹äº†subParseNumericZoneæ–¹æ³•ï¼Œä½¿å…¶å¯ä»¥è§£æå¸¦å†’å·çš„å†™æ³•ã€‚ è§£å†³è§£å†³æ–¹æ³•ä¹Ÿå¾ˆç®€å•ï¼Œåœ¨æµ‹è¯•æ—¶ç›´æ¥ä¿®æ”¹å…¥å‚ï¼Œå»æ‰å…¥å‚ä¸­çš„å†’å·å°±å¥½äº†ï¼š 12345678910111213141516try (MockedStatic&lt;DateUtils&gt; mockedDateUtils = Mockito.mockStatic(DateUtils.class, new CallsRealMethods())) &#123; mockedDateUtils.when(() -&gt; &#123; DateUtils.utc2Local(argThat((argument) -&gt; &#123; int index = argument.length() - 3; return argument.charAt(index) == ':'; )); &#125;).then((invocation) -&gt; &#123; String utcTime = invocation.getArgument(0, String.class); String fixedDate = formatDate; int index = formatDate.length() - 3; if (formatDate.charAt(index) == ':') &#123; fixedDate = formatDate.substring(0, index) + formatDate.substring(index + 1); &#125; return DateUtils.utc2Local(fixedDate); &#125;);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://yoursite.com/tags/SimpleDateFormat/"}]},{"title":"Android-Kotlinå•å…ƒæµ‹è¯•ä¹‹ å¦‚ä½•é…åˆMockitoæ¨¡æ‹Ÿé¡¶å±‚å‡½æ•°","slug":"android/unit-test/Android-Kotlinå•å…ƒæµ‹è¯•ä¹‹å¦‚ä½•é…åˆMockitoæ¨¡æ‹Ÿé¡¶å±‚å‡½æ•°","date":"2021-02-24T08:05:00.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2021/02/24/android/unit-test/Android-Kotlinå•å…ƒæµ‹è¯•ä¹‹å¦‚ä½•é…åˆMockitoæ¨¡æ‹Ÿé¡¶å±‚å‡½æ•°/","link":"","permalink":"http://yoursite.com/2021/02/24/android/unit-test/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0/","excerpt":"","text":"ç®€ä»‹éšç€Kotlinè¯­è¨€åœ¨Androidå¼€å‘ä¸­è¶Šæ¥è¶Šæµè¡Œï¼Œè‡ªç„¶ä¹Ÿä¼šé‡åˆ°å„ç§å„æ ·çš„é—®é¢˜ã€‚ æœ¬ç¯‡ä¸»è¦æ˜¯é’ˆå¯¹æˆ‘ä¸ªäººåœ¨Androidå•å…ƒæµ‹è¯•Kotlinç±»æ—¶é‡åˆ°çš„ä¸€äº›é—®é¢˜çš„æ€è€ƒå’Œè§£å†³æ–¹æ¡ˆã€‚ é‡åˆ°çš„é—®é¢˜æˆ‘ä»¬éƒ½çŸ¥é“Kotlinç»™å¼€å‘è€…æä¾›äº†å¾ˆå¤šè¯­æ³•ç³–ï¼Œå…¶ä¸­ä¹‹ä¸€å°±æ˜¯é¡¶å±‚å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æŠŠå‡½æ•°æ”¾åœ¨ä»£ç æ–‡ä»¶çš„é¡¶å±‚ï¼Œè®©å®ƒä¸ä»å±äºä»»ä½•ç±»ã€‚ å®ƒçš„ä½¿ç”¨å¾ˆç®€å•ï¼Œç›´æ¥åœ¨kotlinä»£ç çš„ä»»æ„ä½ç½®ç›´æ¥å½“ä½œä¸€ä¸ªæ™®é€šå‡½æ•°è°ƒç”¨å°±è¡Œäº†ï¼Œè€Œåœ¨javaä¸­ï¼Œéœ€è¦åƒä½¿ç”¨é™æ€æ–¹æ³•ä¸€æ ·ï¼Œä»¥æ–‡ä»¶å+Ktä¸ºç±»åè°ƒç”¨ (é»˜è®¤é…ç½®) åœ¨javaå•å…ƒæµ‹è¯•ä¸­ï¼Œå¦‚æœæƒ³mockè¿™ä¸ªé¡¶å±‚å‡½æ•°ï¼Œåªéœ€è¦åƒå¯¹å¾…ä¸€ä¸ªé™æ€æ–¹æ³•ä¸€æ ·ï¼Œä½¿ç”¨mockStaticæ–¹æ³•å³å¯ è€Œåœ¨kotlinå•å…ƒæµ‹è¯•ä¸­ï¼Œæˆ‘ä»¬å´æ— æ³•æ‰¾åˆ°è¿™ä¸ªclass ç¡®å®šè·¯çº¿æˆ‘ä»¬å…ˆå»ºç«‹ä¸€ä¸ªæ–‡ä»¶æ¥å†™ä¸€ä¸ªé¡¶å±‚å‡½æ•°ï¼Œå†å»ºç«‹ä¸€ä¸ªå•å…ƒæµ‹è¯•ç±»å»æµ‹è¯•å®ƒ: å…¶å®ä»ä¸Šæ–‡ä¸­å·²ç»å¯ä»¥çœ‹å‡ºï¼Œkotlinçš„é¡¶å±‚å‡½æ•°åœ¨ç¼–è¯‘ä¹‹åå®é™…ä¸Šå°±å˜æˆäº†ä¸€ä¸ªè¢«classåŒ…èµ·æ¥çš„staticæ–¹æ³•ã€‚å¯¹æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•éªŒè¯ä¸€ä¸‹: åœ¨Android Studioä¸­ç‚¹å‡»èœå•ä¸­çš„Tools-&gt;Kotlin-&gt;Show Kotlin ByteCodeï¼Œä¼šå¼¹å‡ºå¯¹åº”ç±»çš„å­—èŠ‚ç ï¼Œå†ç‚¹å‡»DecompileæŒ‰é’®ï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°ç¡®å®è¢«ç¼–è¯‘æˆäº†ä¸€ä¸ªç±»ä¸­çš„é™æ€æ–¹æ³• ç¡®å®šäº†è¿™ä¸€ç‚¹åï¼Œæˆ‘ä»¬åªéœ€è¦åœ¨kotlinä¸­æ‹¿åˆ°è¿™ä¸ªé¡¶å±‚å‡½æ•°çš„æ‰€å±ç±»ï¼Œå°±å¯ä»¥åƒjavaé‡Œä¸€æ ·ä½¿ç”¨mockStaticæ¥æ¨¡æ‹Ÿäº†ã€‚ åˆ†æè¿‡ç¨‹æ—¢ç„¶æ¶‰åŠåˆ°äº†è¿è¡Œæ—¶ç±»å‹åˆ†æï¼Œè‡ªç„¶è€Œç„¶å°±æƒ³åˆ°äº†åå°„ï¼Œæˆ‘ä»¬å…ˆå¼•å…¥kotlinçš„åå°„åº“ implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot; å…¶å®æˆ‘å¯¹kotlinçš„åå°„å¹¶ä¸ç†Ÿæ‚‰ï¼Œå»æ–‡æ¡£é‡ŒæŸ¥é˜…äº†ä¸€ä¸‹å‘ç°äº†::sampleTopFunè¿™ç§å†™æ³•ï¼Œå®ƒçš„è¿”å›å€¼ä¸ºä¸€ä¸ªå«KFunctionçš„æ¥å£ç±»ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹å®ƒæœ‰å“ªäº›æ–¹æ³•å¯ä»¥ä¾›æˆ‘ä»¬è°ƒç”¨ ä»å­—é¢ä¸Šçœ‹å¥½åƒæ²¡æœ‰ä»€ä¹ˆæ–¹æ³•å’Œæˆ‘ä»¬çš„éœ€æ±‚æœ‰å…³ï¼Œæ€ä¹ˆåŠå‘¢ï¼Ÿé‚£æˆ‘ä»¬å†çœ‹ä¸€ä¸‹å®ƒçš„å®ç°ç±»å§ï¼Œè¯´ä¸å®šä¼šæœ‰ä¸€äº›ç§æœ‰å˜é‡ä¿å­˜äº†æˆ‘ä»¬éœ€è¦çš„ä¿¡æ¯ã€‚ é‚£ä¹ˆæ€ä¹ˆæ‰¾åˆ°å®ƒçš„å®ç°ç±»å‘¢ï¼Ÿç›´æ¥åˆ†ææºç é”™ç»¼å¤æ‚çš„å…³ç³»æ˜¯å¾ˆè€—æ—¶ä¸”ä½æ•ˆçš„ï¼Œè¿™é‡Œæˆ‘é‡‡å–äº†äº†ä¸€ç§å–å·§çš„æ–¹æ³•ï¼Œåˆ©ç”¨Android Studioçš„DebugåŠŸèƒ½: å’Œé¢„æ–™çš„ä¸åŒï¼Œä¸ºä»€ä¹ˆè¿™é‡Œæ‹¿åˆ°çš„ç±»å‹æ˜¯è¿™ä¹ˆä¸ªå¥‡è‘©ç©æ„å„¿å‘¢ï¼Ÿæˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™ä¸ªæ–‡ä»¶çš„å­—èŠ‚ç  å†å¾€ä¸‹çœ‹ æˆ‘ä»¬å‘ç°ï¼Œè¿™ä¸ªå¥‡è‘©çš„ç±»å‹æ˜¯åœ¨kotlinç¼–è¯‘åè‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå®ƒç»§æ‰¿è‡ªFunctionReferenceï¼ŒåŒæ—¶ï¼Œåœ¨Debuggeré‡Œï¼Œæˆ‘ä»¬è·å¾—äº†ä¸€ä¸ªé‡è¦çš„ä¿¡æ¯: KFunctionImpl æ ¹æ®åå­—çŒœæµ‹ï¼Œå®ƒåº”è¯¥æ‰æ˜¯KFunctionçœŸæ­£åŠŸèƒ½å®ç°çš„åœ°æ–¹ï¼Œæˆ‘ä»¬å°†å®ƒçš„ä¿¡æ¯å±•å¼€ å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬å·²ç»æ‰¾åˆ°æˆ‘ä»¬æƒ³è¦çš„é‚£ä¸ªç±»äº†ï¼Œåªè¦æ‹¿åˆ°å®ƒï¼Œåç»­çš„mockå·¥ä½œå°±å¾ˆç®€å•äº†~ å¼€å§‹Mockæ ¹æ®ä¸Šæ–‡ï¼Œæˆ‘ä»¬å·²ç»å¾—çŸ¥äº†æˆ‘ä»¬éœ€è¦è·å–çš„jClassçš„è·¯å¾„ æˆ‘ä»¬å…ˆä»FunctionReferenceå»è·å–è¢«reflectedå¼•ç”¨çš„KFunctionImplï¼Œè¿™ä¸ªreflectedå®é™…æ˜¯è¢«FunctionReferenceç»§æ‰¿çš„CallableReferenceä¸­çš„ä¸€ä¸ªå˜é‡ï¼Œåœ¨FunctionReferenceæä¾›äº†ä¸€ä¸ªgetReflectedæ–¹æ³•ï¼Œæˆ‘ä»¬é€šè¿‡åå°„è°ƒç”¨è¿™ä¸ªæ–¹æ³•å³å¯å¾—åˆ°è¿™ä¸ªå¯¹è±¡ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡åå°„Fieldè·å¾—å®ƒï¼Œä½†æ³¨æ„åˆ°getReflectedæ–¹æ³•å¤„ç†äº†ä¸€äº›ç©ºå¯¹è±¡çš„æƒ…å†µï¼Œä¸ºäº†ä¿é™©èµ·è§ï¼Œæˆ‘ä»¬è¿˜æ˜¯é‡‡å–åå°„è°ƒç”¨getReflectedçš„æ–¹æ³•è·å–KFunctionImpl åå°„è°ƒç”¨getReflectedæ–¹æ³•è·å–KFunctionImpl ç¬¬ä¸€æ­¥æ²¡é—®é¢˜ï¼Œæ¥ä¸‹æ¥å¼€å§‹åå°„è·å–container ç¬¬äºŒæ­¥ä¹Ÿæ²¡ä»€ä¹ˆé—®é¢˜ï¼Œæ¥ä¸‹æ¥å°±æ˜¯åå°„è·å–jClassäº† okï¼Œä¸€åˆ‡æ­£å¸¸ï¼Œæ¥ä¸‹æ¥å’Œjavaä¸€æ ·ï¼Œè®©æˆ‘ä»¬è¯•è¯•ç”¨è¿™ä¸ªæˆ‘ä»¬è·å–åˆ°çš„ç±»mockStaticå§ å¯ä»¥çœ‹åˆ°ï¼Œæµ‹è¯•æˆåŠŸé€šè¿‡ï¼Œè‡³æ­¤ï¼Œæˆ‘ä»¬æˆåŠŸè§£å†³äº†Mockitoæ¨¡æ‹Ÿé¡¶å±‚å‡½æ•°çš„é—®é¢˜ã€‚ä¸ºäº†æ–¹ä¾¿ä½¿ç”¨ï¼Œå¯ä»¥å°†ä»¥ä¸Šä»£ç å°è£…æˆä¸€ä¸ªå‡½æ•°ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"å•å…ƒæµ‹è¯•","slug":"Android/å•å…ƒæµ‹è¯•","permalink":"http://yoursite.com/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"å•å…ƒæµ‹è¯•","slug":"å•å…ƒæµ‹è¯•","permalink":"http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"æ±‡ç¼–æŒ‡ä»¤ç¬”è®°","slug":"common/æ±‡ç¼–æŒ‡ä»¤ç¬”è®°","date":"2020-12-31T08:18:37.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2020/12/31/common/æ±‡ç¼–æŒ‡ä»¤ç¬”è®°/","link":"","permalink":"http://yoursite.com/2020/12/31/common/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"å¯„å­˜å™¨æ•°æ®å¯„å­˜å™¨AX: AH-AL (æ•°æ®ç´¯åŠ å™¨, å¯ç”¨äºä¹˜ã€ é™¤ã€è¾“å…¥/è¾“å‡ºç­‰æ“ä½œ) BX: BH-BL (åŸºå€å¯„å­˜å™¨, å¯ä½œä¸ºå­˜å‚¨å™¨æŒ‡é’ˆæ¥ä½¿ç”¨) CX: CH-CL (è®¡æ•°å¯„å­˜å™¨, å¯ç”¨æ¥æ§åˆ¶å¾ªç¯æ¬¡æ•°) DX: DH-DL (æ•°æ®å¯„å­˜å™¨, åœ¨è¿›è¡Œä¹˜ã€é™¤è¿ç®—æ—¶ï¼Œå®ƒå¯ä½œä¸ºé»˜è®¤çš„æ“ä½œæ•°å‚ä¸è¿ç®—ï¼Œä¹Ÿå¯ç”¨äºå­˜æ”¾I/Oçš„ç«¯å£åœ°å€) å˜å€å¯„å­˜å™¨ ä¸»è¦ç”¨äºå­˜æ”¾å­˜å‚¨å•å…ƒåœ¨æ®µå†…çš„åç§»é‡ï¼Œç”¨å®ƒä»¬å¯å®ç°å¤šç§å­˜å‚¨å™¨æ“ä½œæ•°çš„å¯»å€æ–¹å¼ï¼Œä¸ºä»¥ä¸åŒçš„åœ°å€å½¢å¼è®¿é—®å­˜å‚¨å•å…ƒæä¾›æ–¹ä¾¿ï¼Œ ä¹Ÿå¯å­˜å‚¨ç®—æœ¯é€»è¾‘è¿ç®—çš„æ“ä½œæ•°å’Œè¿ç®—ç»“æœã€‚å®ƒä»¬å¯ä½œä¸€èˆ¬çš„å­˜å‚¨å™¨æŒ‡é’ˆä½¿ç”¨ã€‚ ESI: 32bit == SI: 16bit (æºå˜å€å¯„å­˜å™¨, ä¸DSè”ç”¨, æŒ‡ç¤ºæ•°æ®æ®µä¸­æŸæ“ä½œçš„åç§»é‡. åœ¨åšä¸²å¤„ç†æ—¶, SIæŒ‡ç¤ºæºæ“ä½œæ•°åœ°å€, å¹¶æœ‰è‡ªåŠ¨å¢é‡æˆ–è‡ªåŠ¨å‡é‡çš„åŠŸèƒ½ã€‚ å˜å€å¯»å€æ—¶, SIä¸æŸä¸€ä½ç§»é‡å…±åŒæ„æˆæ“ä½œæ•°çš„åç§»é‡) EDI: 32bit == DI: 16bit (ä¸DSè”ç”¨, æŒ‡ç¤ºæ•°æ®æ®µä¸­æŸæ“ä½œæ•°çš„åç§»é‡, æˆ–ä¸æŸä¸€ä½ç§»é‡å…±åŒæ„æˆæ“ä½œæ•°çš„åç§»é‡. ä¸²å¤„ç†æ“ä½œæ—¶, DIæŒ‡ç¤ºé™„åŠ æ®µä¸­ç›®çš„åœ°å€, å¹¶æœ‰è‡ªåŠ¨å¢é‡æˆ–å‡é‡çš„åŠŸèƒ½) æŒ‡é’ˆå¯„å­˜å™¨ ä¸»è¦ç”¨äºå­˜æ”¾å †æ ˆå†…å­˜å‚¨å•å…ƒçš„åç§»é‡ï¼Œç”¨å®ƒä»¬å¯å®ç°å¤šç§å­˜å‚¨å™¨æ“ä½œæ•°çš„å¯»å€æ–¹å¼ï¼Œä¸ºä»¥ä¸åŒçš„åœ°å€å½¢å¼è®¿é—®å­˜å‚¨å•å…ƒæä¾›æ–¹ä¾¿ï¼Œ ä¹Ÿå¯å­˜å‚¨ç®—æœ¯é€»è¾‘è¿ç®—çš„æ“ä½œæ•°å’Œè¿ç®—ç»“æœã€‚ EBP: 32bit == BP: 16bit (åŸºæŒ‡é’ˆå¯„å­˜å™¨, ç”¨å®ƒå¯ç›´æ¥å­˜å–å †æ ˆä¸­çš„æ•°æ®) ESP: 32bit == SP: 16bit (å †æ ˆæŒ‡é’ˆå¯„å­˜å™¨, å§‹ç»ˆåªæ˜¯æ ˆé¡¶çš„ä½ç½®, ä¸SSå¯„å­˜å™¨ä¸€èµ·ç»„æˆæ ˆé¡¶æ•°æ®çš„ç‰©ç†åœ°å€) æ®µå¯„å­˜å™¨ æ®µå¯„å­˜å™¨æ˜¯æ ¹æ®å†…å­˜åˆ†æ®µçš„ç®¡ç†æ¨¡å¼è€Œè®¾ç½®çš„ã€‚å†…å­˜å•å…ƒçš„ç‰©ç†åœ°å€ç”±æ®µå¯„å­˜å™¨çš„å€¼å’Œä¸€ä¸ªåç§»é‡ç»„åˆè€Œæˆçš„ï¼Œè¿™æ ·å¯ç”¨ä¸¤ä¸ªè¾ƒå°‘ä½æ•°çš„å€¼ç»„åˆæˆä¸€ä¸ªå¯è®¿é—®è¾ƒå¤§ç‰©ç†ç©ºé—´çš„å†…å­˜åœ°å€ã€‚ 16ä½ CSâ€”â€”ä»£ç æ®µå¯„å­˜å™¨ï¼Œå­˜æ”¾å½“å‰ç¨‹åºçš„æŒ‡ä»¤ä»£ç  DSâ€”â€”æ•°æ®æ®µå¯„å­˜å™¨ï¼Œå­˜æ”¾ç¨‹åºæ‰€æ¶‰åŠçš„æºæ•°æ®æˆ–ç»“æœ ESâ€”â€”é™„åŠ æ®µå¯„å­˜å™¨ï¼Œè¾…åŠ©æ•°æ®åŒº, å­˜æ”¾ä¸²æˆ–å…¶ä»–æ•°æ® SSâ€”â€”å †æ ˆæ®µå¯„å­˜å™¨ï¼Œå…¶å€¼ä¸ºå †æ ˆæ®µçš„æ®µå€¼ 32ä½ FSâ€”â€”é™„åŠ æ®µå¯„å­˜å™¨ï¼Œå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µå€¼ GSâ€”â€”é™„åŠ æ®µå¯„å­˜å™¨ï¼Œå…¶å€¼ä¸ºé™„åŠ æ•°æ®æ®µçš„æ®µå€¼ æŒ‡ä»¤cmp (é…åˆjz, jnz)ç®—æ•°è¿ç®—æŒ‡ä»¤ï¼Œæ¯”è¾ƒä¸¤ä¸ªå€¼ï¼Œå¦‚æœç›¸ç­‰åˆ™è®¾ç½®ZF(é›¶æ ‡å¿—)ä¸º1, å¯ç”¨jz(jump if zero)æˆ–jnz(jump if not zero)æŒ‡ä»¤æ£€æŸ¥ZFä½, jz(ZFé›¶æ ‡å¿—ä¸º1)å³ç›¸ç­‰, jnz(ZFé›¶æ ‡å¿—ä¸º1)å³ä¸ç›¸ç­‰ 12345678910111213ä¾‹:compare: mov $0x1000, %ax cmp $0x1000, %ax ;åˆ¤æ–­axå¯„å­˜å™¨ä¸­çš„å€¼æ˜¯å¦ä¸º0x1000 jz is_equal ;å¦‚æœç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°ä»£ç æ®µis_equal jnz is_not_equal ;å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™è·³è½¬åˆ°ä»£ç æ®µis_not_equalis_equal: ;do somethingis_not_equal: ;do something repé‡å¤æ‰§è¡Œåé¢çš„æŒ‡ä»¤ï¼Œç›´åˆ°cxå¯„å­˜å™¨ä¸­çš„å€¼ä¸º0 12345ä¾‹:example: mov $0, %ax //å°†axå¯„å­˜å™¨ç½®0 mov $0x1000, %cx rep add $1, %ax //ä½¿axå¯„å­˜å™¨åŠ 1ï¼Œæ‰§è¡Œ1000æ¬¡","categories":[{"name":"å…¶ä»–","slug":"å…¶ä»–","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"æ±‡ç¼–","slug":"æ±‡ç¼–","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"è‡ªå®šä¹‰EditViewæ—¶è¸©è¿‡çš„å‘","slug":"android/view/è‡ªå®šä¹‰EditViewæ—¶è¸©è¿‡çš„å‘","date":"2020-10-19T04:05:34.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/10/19/android/view/è‡ªå®šä¹‰EditViewæ—¶è¸©è¿‡çš„å‘/","link":"","permalink":"http://yoursite.com/2020/10/19/android/view/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","excerpt":"","text":"ç®€ä»‹è¿™æ¬¡çš„éœ€æ±‚æ˜¯ä¸€ä¸ªå•è¯æ‹¼å†™çš„è¾“å…¥æ¡†ï¼Œè¦æ±‚æ¯ä¸ªå­—æ¯åˆ†å‰²å¼€æ¥è¾“å…¥ï¼Œæ¯ä¸ªå­—æ¯ä¸‹é¢æœ‰ä¸€ä¸ªä¸‹åˆ’çº¿ï¼Œå°±ç±»ä¼¼äºéªŒè¯ç è¾“å…¥æˆ–è€…æ”¯ä»˜å¯†ç è¾“å…¥çš„æ•ˆæœ æœ€ç»ˆæˆå“æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰Viewï¼Œå®ç°å‚è€ƒäº†VercodeEditText EditViewè¿˜æ˜¯TextViewï¼Ÿåˆšå¼€å§‹çš„æ—¶å€™ï¼Œæˆ‘é€‰æ‹©äº†ç»§æ‰¿AppCompatEditTextï¼Œä½†åœ¨æˆ‘è¯•ç€draw on canvasçš„æ—¶å€™ï¼Œå¥‡æ€ªçš„å‘ç°ç»˜åˆ¶çš„ä¸œè¥¿å¹¶æ²¡æœ‰åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºï¼Œç„¶åæˆ‘å°è¯•å°†è§†å›¾çš„é«˜åº¦è°ƒå¤§ï¼Œå½“åˆ°è¾¾äº†ä¸€ä¸ªä¸´ç•Œç‚¹åï¼Œå†…å®¹çªç„¶æ˜¾ç¤ºå‡ºæ¥äº†ã€‚ ä¸ºäº†å¾—çŸ¥è¿™ä¸ªé—®é¢˜çš„æˆå› ï¼Œæˆ‘è¯•ç€ç”»ä¸€ä¸ªå æ»¡æ•´ä¸ªç”»å¸ƒçš„çŸ©å½¢ï¼Œæ‰“å¼€å¼€å‘è€…é€‰é¡¹é‡Œçš„æ˜¾ç¤ºå¸ƒå±€è¾¹ç•Œåå‘ç°ï¼Œè¿™ä¸ªçŸ©å½¢å¹¶æ²¡æœ‰å æ»¡æ•´ä¸ªå¸ƒå±€ã€‚ä¸€å¼€å§‹çŒœæƒ³å¯èƒ½æ˜¯å› ä¸ºç”»å¸ƒçš„é«˜åº¦å°äºè§†å›¾çš„é«˜åº¦ï¼Œäºæ˜¯æ‰“å¼€debugè°ƒè¯•æ–­ç‚¹å‘ç°ï¼Œä¸¤è€…æ˜¯ä¸€è‡´çš„ï¼›ç„¶åçŒœæµ‹æ˜¯ä¸æ˜¯ç”»å¸ƒå› ä¸ºä»€ä¹ˆåŸå› äº§ç”Ÿäº†åç§»ï¼Ÿä½†æ€ä¹ˆå°è¯•éƒ½æ²¡æœ‰å¾—åˆ°ç¡®å®šæ€§çš„ç»“è®ºï¼Œç›´åˆ°æŸæ¬¡æˆ‘æ‰“å¼€äº†EditTextçš„èƒŒæ™¯ï¼Œå¹¶éšä¾¿æ»‘åŠ¨äº†å‡ ä¸‹å‘ç°ï¼Œåœ¨å‘ä¸‹æ»‘åŠ¨çš„æ—¶å€™ï¼ŒåŸæœ¬ç»˜åˆ¶çš„å†…å®¹ä¾¿ä»è§†å›¾æœ€ä¸Šæ–¹æ»šåŠ¨äº†ä¸‹æ¥ã€‚åŸæ¥æ˜¯å› ä¸ºå½“EditTexté«˜åº¦å°äº1è¡Œæ—¶ï¼ŒEditTextä¼šè‡ªåŠ¨é€‚é…å¹¶æ»šåŠ¨åˆ°æœ€ä¸‹æ–¹ã€‚ æ—¢ç„¶çŸ¥é“äº†é—®é¢˜çš„æˆå› ï¼Œé‚£å°±å¼€å§‹ç€æ‰‹è§£å†³ä»–ï¼Œæœ€ç›´æ¥çš„åŠæ³•å°±æ˜¯ç¦æ­¢EditTextçš„æ»šåŠ¨ã€‚ä¸ºæ­¤ï¼Œæˆ‘å°è¯•äº†setMinHeight()ï¼ŒsetMinLines()éƒ½æ²¡æœ‰ç”¨ã€‚ç„¶åæˆ‘é€€è€Œæ±‚å…¶æ¬¡ï¼Œå°è¯•ä½¿ç”¨scrollTo(0, 0)ï¼Œå°†è§†å›¾å›ºå®šæ»‘åŠ¨åˆ°æœ€é¡¶éƒ¨ï¼Œå‘ç°æ•ˆæœå¹¶ä¸æ˜¯å¾ˆç†æƒ³ã€‚ç„¶ååœ¨æŸ¥èµ„æ–™çš„è¿‡ç¨‹ä¸­æˆ‘å‘ç°äº†MovementMethodè¿™ä¹ˆä¸€ä¸ªä¸œè¥¿ã€‚ ç½‘ä¸Šå…³äºMovementMethodçš„èµ„æ–™æ¯”è¾ƒå°‘ï¼Œæˆ‘æŸ¥è¯¢äº†ä¸€ä¸‹Googleçš„å®˜æ–¹æ–‡æ¡£é‡Œé¢ä»‹ç»ï¼š Provides cursor positioning, scrolling and text selection functionality in a TextView.å³ï¼šåœ¨ TextViewæä¾›äº†å…‰æ ‡å®šä½ï¼Œæ»šåŠ¨å’Œæ–‡æœ¬é€‰æ‹©åŠŸèƒ½ã€‚ æ‰¾åˆ°äº†äº§ç”Ÿæ»šåŠ¨çš„å…ƒå‡¶ï¼Œé‚£é—®é¢˜å°±å¥½åŠäº†ï¼Œåœ¨æºç é‡Œå¯ä»¥çœ‹åˆ°ï¼ŒEditTextçš„getDefaultMovementMethod()è¿”å›äº†ä¸€ä¸ªArrowKeyMovementMethodï¼Œæˆ‘ä»¬ç›´æ¥setMovementMethod(null)æˆ–è€…é‡å†™çˆ¶ç±»çš„getDefaultMovementMethod()ä½¿å…¶è¿”å›å€¼ä¸ºnullï¼Œæ»šåŠ¨çš„é—®é¢˜ä¾¿è§£å†³äº†ã€‚ è§£å†³å®Œè¿™ä¸€æ­¥åï¼Œåˆå‘ç°äº†ä¸€ä¸ªæ–°é—®é¢˜ï¼ŒEditTextçš„ä¸Šä¸‹å·¦å³æœ‰ä¸€å®šçš„paddingï¼Œç‚¹å‡»åˆ°è¿™éƒ¨åˆ†paddingçš„åŒºåŸŸæ˜¯ä¸ä¼šè§¦å‘EditTextçš„è·å–ç„¦ç‚¹å¼¹å‡ºè¾“å…¥æ³•çš„ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥é‡å†™onTouchEventæ–¹æ³•åŠ ä¸ŠrequestFocus()æ–¹æ³•è§£å†³ï¼Œä½†è€ƒè™‘åˆ°ç»§æ‰¿EditTextè¦é‡è®¾èƒŒæ™¯ï¼Œåˆè¦setMovementMethodï¼Œè¿˜è¦å¤„ç†è¾¹ç¼˜ç‚¹å‡»äº‹ä»¶ï¼Œæ„Ÿè§‰å¤ªéº»çƒ¦ï¼Œä¸å¦‚ç›´æ¥ç»§æ‰¿TextViewï¼Œå¤„ç†çš„äº‹æƒ…ä¼šç¨å¾®å°‘ä¸€äº›ã€‚ äºæ˜¯æˆ‘é€‰æ‹©ç»§æ‰¿AppCompatTextViewï¼Œé‡å†™getDefaultEditable()ä½¿å…¶è¿”å›trueä»¥æ‰“å¼€ç¼–è¾‘åŠŸèƒ½ï¼ŒsetFocusableInTouchMode(true)ä½¿å…¶èƒ½è·å–ç„¦ç‚¹ï¼Œé‡å†™onTouchEventæ–¹æ³•åŠ ä¸ŠrequestFocus()æ–¹æ³•ä½¿å…¶ç‚¹å‡»èƒ½å¤Ÿç›´æ¥è·å–ç„¦ç‚¹ï¼ŒsetCursorVisible(false)éšè—å…‰æ ‡ï¼ŒsetLongClickable(false)ç¦æ­¢é•¿æŒ‰å¼¹å‡ºç¼–è¾‘èœå•ï¼Œåˆ°è¿™ä¸€æ­¥ï¼ŒåŸºæœ¬éš¾ç‚¹å·²ç»è§£å†³äº†ã€‚ onTextChangedå¤šæ¬¡è°ƒç”¨ï¼Ÿä¸ºäº†ç›‘å¬æ–‡æœ¬æ”¹å˜çš„äº‹ä»¶ï¼Œæˆ‘ä¸€å¼€å§‹é€‰æ‹©äº†è‡ªå®šä¹‰Viewç›´æ¥implements TextWatcherï¼Œç„¶åaddTextChangedListener(this)ï¼Œè¿™æ ·åœ¨æ–­ç‚¹è°ƒè¯•çš„æ—¶å€™å‘ç°ï¼ŒonTextChanged()æ–¹æ³•è¢«æ‰§è¡Œäº†å¤šæ¬¡ï¼Œä½†beforeTextChanged()å’ŒafterTextChanged()æ‰§è¡Œæ¬¡æ•°å´æ˜¯æ­£å¸¸çš„ã€‚åŸæ¥ï¼Œåœ¨TextViewå†…éƒ¨å·²ç»æœ‰äº†ä¸€ä¸ªå¯é‡å†™çš„onTextChanged()æ–¹æ³•ï¼Œå’ŒTextWatcheré‡Œçš„onTextChanged()ä¸€æ¨¡ä¸€æ ·ï¼Œå½“addTextChangedListener(this)åï¼ŒTextViewä¼šå…ˆæ‰§è¡ŒTextWatcherçš„onTextChanged()ï¼Œå†æ‰§è¡Œè‡ªå·±å†…éƒ¨çš„onTextChanged()ã€‚è§£å†³æ–¹æ³•å¾ˆç®€å•ï¼Œå°†implements TextWatcherå»æ‰ï¼Œæ”¹ä¸ºaddTextChangedListenerä¸€ä¸ªåŒ¿åå†…éƒ¨ç±»å°±å¥½äº†ã€‚ é•¿åº¦è¶…è¿‡é™åˆ¶äº†æ€ä¹ˆåŠï¼Ÿåˆšå¼€å§‹ï¼Œæˆ‘åœ¨onTextChanged()é‡Œå¢åŠ äº†å¯¹Texté•¿åº¦çš„åˆ¤æ–­ï¼Œå¦‚æœé•¿åº¦è¶…é•¿ï¼Œå°±æŠŠåŸTextæˆªæ–­åˆ°æœ€å¤§é•¿åº¦ï¼Œç„¶åé‡æ–°setTextè¿›å»ã€‚è¿™æ ·åšæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œè¿™æ ·å¹¶ä¸èƒ½ä¿è¯afterTextChanged()å›è°ƒé‡Œçš„Textå‚æ•°é•¿åº¦åˆæ³•ã€‚å½“è¿™ä¹ˆåšåï¼ŒTextViewé¦–å…ˆä¼šè§¦å‘æˆªæ–­Textçš„afterTextChanged()ï¼Œç„¶åå†è§¦å‘è¶…é•¿Textçš„afterTextChanged()ã€‚åæ¥åœ¨æœç´¢èµ„æ–™çš„æ—¶å€™å‘ç°ï¼ŒTextViewå†…éƒ¨æŒæœ‰äº†ä¸€ä¸ªInputFilteræ•°ç»„ï¼Œè¿™ä¸ªæ¥å£å¯ä»¥å¾ˆå¥½çš„å¸®åŠ©æˆ‘ä»¬åœ¨è§¦å‘å›è°ƒä¹‹å‰å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œè¿‡æ»¤æ“ä½œã€‚ InputFilteræ¥å£æ–¹æ³• public CharSequence filter(CharSequence source, int start, int end,Spanned dest, int dstart, int dend); å…¶ä¸­ï¼ŒInputFilterå·²ç»å†…ç½®å®ç°äº†é•¿åº¦è¿‡æ»¤åŠŸèƒ½ï¼Œåªéœ€è¦åœ¨è®¾ç½®æ–°answerçš„æ—¶å€™ï¼Œé‡æ–°setFilters()å°±è¡Œäº† 1234InputFilter[] filters = new InputFilter[]&#123; new InputFilter.LengthFilter(answer.length())&#125;;setFilters(filters); å…·ä½“çš„ç»˜åˆ¶å®ç°ï¼Ÿè®¡ç®—é¢„ç•™ä½ç½®æˆ‘å®šä¹‰äº†ä¸€ä¸ªå˜é‡String ALL_CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;ç”¨æ¥è®¡ç®—ç”¨æˆ·è¾“å…¥çš„é¢„ç•™å®½é«˜ã€‚ 123456789101112private void measureChar() &#123; int width = 0, height = 0; Rect rect = new Rect(); for (int i = 0; i &lt; ALL_CHARS.length(); i++) &#123; mTextPaint.getTextBounds(ALL_CHARS, i, i + 1, rect); width = Math.max(width, rect.width()); height = Math.max(height, rect.height()); &#125; mCharWidth = width; mCharHeight = height;&#125; åœ¨onMeasure()é‡Œè®¡ç®—å¥½å¸ƒå±€å®½é«˜åï¼Œæ ¹æ®å®½é«˜å’Œé—´éš”è·ç¦»å¹³å‡åˆ†é…ä¸€ä¸‹æ¯ä¸ªå­—æ¯çš„åæ ‡ã€‚ è‡ªé€‚åº”å®½åº¦è¿™æ¬¡çš„éœ€æ±‚è¿˜è¦æ±‚å½“å¸ƒå±€çš„å®½åº¦è¶…è¿‡çˆ¶å¸ƒå±€æ—¶ï¼Œè‡ªåŠ¨ç¼©å°å­—ä½“å¤§å°ä»¥é€‚åº”çˆ¶å¸ƒå±€å®½åº¦ã€‚è¿™ä¸ªå…¶å®ä¹Ÿå¾ˆç®€å•ï¼Œè®¡ç®—ä¸€ä¸‹ç»˜åˆ¶éœ€è¦çš„å®½åº¦ï¼Œå¦‚æœè¶…è¿‡çˆ¶å¸ƒå±€å®½åº¦ï¼Œå°±å‡å°å­—å·ï¼Œå¾ªç¯ä¸€ä¸‹å³å¯ã€‚ 123456int answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - 1);while (answerWidth &gt; width - getPaddingLeft() - getPaddingRight()) &#123; mTextPaint.setTextSize(--mTextSize); measureChar(); answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - 1);&#125; ç”¨æˆ·è¾“å…¥æ–‡å­—çš„ç»˜åˆ¶ç”±äºæ¯ä¸ªå­—æ¯çš„å®½é«˜å¯èƒ½ä¸åŒï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥ä½¿ç”¨ä¹‹å‰è®¡ç®—å¥½çš„åæ ‡ç»˜åˆ¶ï¼Œéœ€è¦ä½¿ç”¨ä¹‹å‰æµ‹é‡å¥½çš„é¢„ç•™çš„å®½åº¦å‡å»ç”¨æˆ·å®é™…è¾“å…¥å­—æ¯çš„å®½åº¦é™¤ä»¥2ï¼Œç„¶ååŠ ä¸Šè¿™ä¸ªé¢„ç•™ä½ç½®çš„èµ·å§‹åæ ‡ã€‚ 12345private float computeCharX(CharCoordinate coordinate, char letter) &#123; mTextPaint.getTextBounds(String.valueOf(letter), 0, 1, mTempRect); int realCharWidth = mTempRect.width(); return coordinate.start + (float) (mCharWidth - realCharWidth) / 2 - mTempRect.left;&#125; è¿™é‡Œå‡å»mTempRect.leftæ˜¯å› ä¸ºç»˜åˆ¶å‡ºæ¥çš„å­—ç¬¦æœ‰äº›å‘å³åç¦» ç»˜åˆ¶å…‰æ ‡TextViewåŸæœ¬çš„å…‰æ ‡ä¸ç¬¦åˆæˆ‘ä»¬çš„éœ€æ±‚ï¼Œæˆ‘ä»¬éœ€è¦ç»˜åˆ¶ä¸€ä¸‹è‡ªå®šä¹‰çš„å…‰æ ‡ã€‚ å…ˆå®šä¹‰ä¸€ä¸‹å…‰æ ‡é—ªçƒæ—¶é—´ï¼š 12private final static int DEFAULT_CURSOR_DURATION = 800;private int mCursorDuration = DEFAULT_CURSOR_DURATION; å†å®šä¹‰ä¸€ä¸ªHandlerå’ŒRunnableç”¨æ¥é—´éš”æ‰§è¡Œä»»åŠ¡ 12345678910private Runnable mCursorRunnable = new Runnable() &#123; @Override public void run() &#123; if (mNeedCursorShow) &#123; mIsCursorShowing = !mIsCursorShowing; invalidate(); &#125; mHandler.postDelayed(mCursorRunnable, mCursorDuration); &#125;&#125;; è¿™æ ·é€šè¿‡è®¾ç½®ä¸€ä¸ªboolå€¼å’Œå®šæ—¶ä»»åŠ¡æ¯éš”ä¸€æ®µæ—¶é—´åˆ·æ–°ä¸€ä¸‹è§†å›¾å°±å¯ä»¥è½»æ¾å®ç°å…‰æ ‡çš„é—ªçƒã€‚","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"EditView","slug":"EditView","permalink":"http://yoursite.com/tags/EditView/"}]},{"title":"Gitå‘½ä»¤ç®€ä»‹","slug":"common/Gitå‘½ä»¤ç®€ä»‹","date":"2020-08-01T08:58:57.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/08/01/common/Gitå‘½ä»¤ç®€ä»‹/","link":"","permalink":"http://yoursite.com/2020/08/01/common/Git%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/","excerpt":"","text":"é…ç½®12git config --global user.name 'dreamgyf' //è®¾ç½®ç”¨æˆ·ågit config --global user.email g2409197994@gmail.com //è®¾ç½®é‚®ç®± åŸºæœ¬å‘½ä»¤12345678910git init //åœ¨å½“å‰ç›®å½•åˆ›å»ºç‰ˆæœ¬åº“git add README.md //å°†æ–‡ä»¶æ·»åŠ åˆ°æš‚å­˜åŒºgit commit //æäº¤æš‚å­˜åŒºä¸­çš„ä¿®æ”¹ -m\"xxx\":æœ¬æ¬¡æäº¤çš„è¯´æ˜ -a:ç›¸å½“å¤šåŠ äº†ä¸€æ­¥äºgit add .git branch åˆ†æ”¯å //åˆ›å»ºåˆ†æ”¯ï¼Œä¸åŠ åˆ†æ”¯åå¯ä»¥æŸ¥çœ‹æ‰€æœ‰åˆ†æ”¯ -d:åˆ é™¤æŒ‡å®šåˆ†æ”¯git checkout åˆ†æ”¯å //åˆ‡æ¢åˆ†æ”¯ -b:åˆ›å»ºå¹¶åˆ‡æ¢åˆ†æ”¯ï¼Œç›¸å½“äºå¤šåŠ äº†ä¸€æ­¥git branch åˆ†æ”¯ågit remote add https://github.com/xxx/xxx.git //æ·»åŠ è¿œç¨‹ä»“åº“ï¼Œä¸€èˆ¬æ”¯æŒhttpså’Œsshä¸¤ç§åè®®git fetch //å°†è¿œç¨‹ä¸»æœºçš„æ›´æ–°å…¨éƒ¨å–å›æœ¬åœ°ï¼Œåé¢åŠ åˆ†æ”¯åçš„è¯åªä¼šå–å›æŒ‡å®šåˆ†æ”¯git merge åˆ†æ”¯å //å°†é€‰ä¸­åˆ†æ”¯åˆå¹¶åˆ°å½“å‰åˆ†æ”¯git pull åˆ†æ”¯å //ç›¸å½“äºgit fetch åˆ†æ”¯å + git merge åˆ†æ”¯ågit push //å°†å½“å‰æœ¬åœ°åˆ†æ”¯æ¨é€è‡³è¿œç¨‹åˆ†æ”¯ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ¨é€åˆ™éœ€è¦-uå‚æ•°æŒ‡å®šè¿œç¨‹åˆ†æ”¯å¹¶å»ºç«‹è”ç³»ï¼Œå¦‚git push -u origin masterï¼Œä¸‹ä¸€æ¬¡ä¾¿å¯ä¸åŠ å‚æ•°ç›´æ¥æ¨é€ -f:å¼ºåˆ¶æ¨é€ï¼Œä¼šè¦†ç›–è¿œç¨‹åˆ†æ”¯ Rebase åˆå¹¶commitè®°å½• 1git rebase -i [startpoint] [endpoint] å…¶ä¸­-içš„æ„æ€æ˜¯--interactiveï¼Œå³å¼¹å‡ºäº¤äº’å¼çš„ç•Œé¢è®©ç”¨æˆ·ç¼–è¾‘å®Œæˆåˆå¹¶æ“ä½œï¼Œ[startpoint] [endpoint]åˆ™æŒ‡å®šäº†ä¸€ä¸ªç¼–è¾‘åŒºé—´ï¼Œå¦‚æœä¸æŒ‡å®š[endpoint]ï¼Œåˆ™è¯¥åŒºé—´çš„ç»ˆç‚¹é»˜è®¤æ˜¯å½“å‰åˆ†æ”¯HEADæ‰€æŒ‡å‘çš„commit(æ³¨ï¼šè¯¥åŒºé—´æŒ‡å®šçš„æ˜¯ä¸€ä¸ªå‰å¼€åé—­çš„åŒºé—´)ã€‚ å‘½ä»¤å¯ä»¥æŒ‰å¦‚ä¸‹æ–¹å¼ï¼š 1git rebase -i [commit id] æˆ– 1git rebase -i HEAD~3 ç„¶åä¼šå‡ºç°ä¸€ä¸ªviç¼–è¾‘å™¨ç•Œé¢ï¼Œä¼šæä¾›ç»™æˆ‘ä»¬ä¸€ä¸ªå‘½ä»¤åˆ—è¡¨ï¼š pickï¼šä¿ç•™è¯¥commitï¼ˆç¼©å†™:pï¼‰ rewordï¼šä¿ç•™è¯¥commitï¼Œä½†æˆ‘éœ€è¦ä¿®æ”¹è¯¥commitçš„æ³¨é‡Šï¼ˆç¼©å†™:rï¼‰ editï¼šä¿ç•™è¯¥commit, ä½†æˆ‘è¦åœä¸‹æ¥ä¿®æ”¹è¯¥æäº¤(ä¸ä»…ä»…ä¿®æ”¹æ³¨é‡Š)ï¼ˆç¼©å†™:eï¼‰ squashï¼šå°†è¯¥commitå’Œå‰ä¸€ä¸ªcommitåˆå¹¶ï¼ˆç¼©å†™:sï¼‰ fixupï¼šå°†è¯¥commitå’Œå‰ä¸€ä¸ªcommitåˆå¹¶ï¼Œä½†æˆ‘ä¸è¦ä¿ç•™è¯¥æäº¤çš„æ³¨é‡Šä¿¡æ¯ï¼ˆç¼©å†™:fï¼‰ execï¼šæ‰§è¡Œshellå‘½ä»¤ï¼ˆç¼©å†™:xï¼‰ dropï¼šä¸¢å¼ƒè¯¥commitï¼ˆç¼©å†™:dï¼‰ ç„¶åæˆ‘ä»¬å°±å¯ä»¥åœ¨é‡Œé¢ä¿®æ”¹æäº¤äº†ï¼Œä¾‹å¦‚: 123pick d2cf1f9 fix: ç¬¬ä¸€æ¬¡æäº¤s 47971f6 ç¬¬äºŒæ¬¡æäº¤s fb28c8d ç¬¬ä¸‰æ¬¡æäº¤ å°†ç¬¬äºŒã€ä¸‰æ¬¡çš„commitåˆå¹¶åˆ°ç¬¬ä¸€æ¬¡ä¸Š ç¼–è¾‘å®Œä¿å­˜é€€å‡ºviå°±å¯ä»¥å®Œæˆå¯¹commitçš„åˆå¹¶äº† å¦‚æœä¿å­˜æ—¶å‡ºç°é”™è¯¯ï¼Œè¾“å…¥git rebase --edit-todoä¾¿ä¼šå›åˆ°ç¼–è¾‘æ¨¡å¼é‡Œï¼Œä¿®æ”¹å®Œåä¿å­˜ï¼Œgit rebase --continue å‚è€ƒé“¾æ¥ åˆå¹¶åˆ†æ”¯ rebaseå’Œmergeéƒ½æ˜¯åˆå¹¶åˆ†æ”¯çš„æ“ä½œ mergeä¼šåœ¨åˆå¹¶åˆ†æ”¯æ—¶äº§ç”Ÿä¸€ä¸ªæ–°çš„commitè®°å½•ï¼Œè€Œrebaseä¼šä»¥æŒ‡å®šåˆ†æ”¯ä½œä¸ºåŸºç¡€åˆ†æ”¯ï¼Œä¹‹å‰æ‰€åšçš„æ”¹åŠ¨å…¨éƒ¨ä¼šåœ¨æŒ‡å®šåˆ†æ”¯çš„åŸºç¡€ä¸Šæäº¤ï¼Œä¸ä¼šäº§ç”Ÿæ–°çš„commitè®°å½•ã€‚ 12git checkout devgit rebase master åˆ†æä¸€ä¸‹ä¸Šé¢å‘½ä»¤è¿›è¡Œçš„æ“ä½œï¼š é¦–å…ˆï¼Œåˆ‡æ¢åˆ°devåˆ†æ”¯ä¸Šï¼› ç„¶åï¼Œgit ä¼šæŠŠ dev åˆ†æ”¯é‡Œé¢çš„æ¯ä¸ª commit å–æ¶ˆæ‰ï¼› å…¶æ¬¡ï¼ŒæŠŠä¹‹å‰çš„commitä¸´æ—¶ä¿å­˜æˆ patch æ–‡ä»¶ï¼Œå­˜åœ¨ .git/rebase ç›®å½•ä¸‹ï¼› ç„¶åï¼ŒæŠŠdevåˆ†æ”¯æ›´æ–°åˆ°æœ€æ–°çš„ master åˆ†æ”¯ï¼› æœ€åï¼ŒæŠŠä¸Šé¢ä¿å­˜çš„ patch æ–‡ä»¶åº”ç”¨åˆ° dev åˆ†æ”¯ä¸Šï¼› ä½¿ç”¨åœºæ™¯ æƒ³è¦å¹²å‡€ç®€æ´çš„åˆ†æ”¯æ ‘ åœ¨ä¸€ä¸ªè¿‡æ—¶çš„åˆ†æ”¯ä¸Šé¢å¼€å‘çš„æ—¶å€™ï¼Œæ‰§è¡Œ rebase ä»¥åŒæ­¥ master åˆ†æ”¯æœ€æ–°å˜åŠ¨ æ³¨æ„ï¼šå½“åŒä¸€ä¸ªåˆ†æ”¯æœ‰å¤šä¸ªäººä½¿ç”¨çš„æƒ…å†µä¸‹ï¼Œè°¨æ…ä½¿ç”¨rebaseï¼Œå› ä¸ºå®ƒæ”¹å˜äº†å†å²ï¼Œå¯èƒ½ä¼šå‡ºç°ä¸¢å¤±commitçš„æƒ…å†µ å‚è€ƒé“¾æ¥","categories":[{"name":"å…¶ä»–","slug":"å…¶ä»–","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Markdownè¯­æ³•","slug":"common/Markdownè¯­æ³•","date":"2020-06-26T15:31:57.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/06/26/common/Markdownè¯­æ³•/","link":"","permalink":"http://yoursite.com/2020/06/26/common/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdownæ˜¯ä¸€ç§è½»é‡çº§æ ‡è®°è¯­è¨€ï¼Œå®ƒä»¥çº¯æ–‡æœ¬å½¢å¼ç¼–å†™æ–‡æ¡£ï¼Œå¹¶æœ€ç»ˆä»¥HTMLæ ¼å¼å‘å¸ƒã€‚ å…ˆæ¨èä¸€æ¬¾Markdownç¼–è¾‘å™¨Typoraï¼Œæ”¯æŒ Windowsã€OS X å’Œ Linuxï¼Œæ”¯æŒå³æ—¶æ¸²æŸ“æŠ€æœ¯ï¼Œæ‰€è§å³æ‰€å¾—ï¼Œç•Œé¢ç®€æ´å¤§æ–¹ï¼Œéå¸¸å¥½ç”¨ã€‚ æ³¨ï¼šå› ä¸ºæœ¬ç«™ä½¿ç”¨äº†ä¸»é¢˜ï¼Œæ‰€ä»¥éƒ¨åˆ†Markdownå‘ˆç°çš„æ•ˆæœä¸åŸæ¥ä¸åŒ æ ‡é¢˜æ–‡å­—å‰åŠ å‡ ä¸ª#å³ä¸ºå‡ çº§æ ‡é¢˜ æ³¨ï¼š#ä¸æ–‡å­—ä¹‹é—´éœ€è¦æœ‰ç©ºæ ¼ 123456# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜### ä¸‰çº§æ ‡é¢˜#### å››çº§æ ‡é¢˜##### äº”çº§æ ‡é¢˜###### å…­çº§æ ‡é¢˜ å­—ä½“åœ¨æ–‡å­—ä¸¤ä¾§åŠ ä¸Šç‰¹æ®Šç¬¦å· 1234*å€¾æ–œ***åŠ ç²—*****å€¾æ–œåŠ ç²—***~~åˆ é™¤çº¿~~ å€¾æ–œåŠ ç²—å€¾æ–œåŠ ç²—åˆ é™¤çº¿ ç‰¹æ®Šç¬¦å·åœ¨ç‰¹æ®Šç¬¦å·ä¹‹å‰åŠ ä¸Š\\è½¬ä¹‰å­—ç¬¦ 12345\\\\ åæ–œæ \\* æ˜Ÿå·\\_ ä¸‹åˆ’çº¿\\&#123;\\&#125; \\[\\] \\(\\) æ‹¬å·\\+ åŠ å· \\ åæ–œæ * æ˜Ÿå·_ ä¸‹åˆ’çº¿{} [] () æ‹¬å·+ åŠ å· æ¢è¡Œè¿ç»­ä¸¤ä¸ªä»¥ä¸Šçš„ç©ºæ ¼+å›è½¦ï¼Œæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„å›è½¦ åˆ†å‰²çº¿åœ¨ä¸€è¡Œä¸­ç”¨ä¸‰ä¸ªä»¥ä¸Šçš„æ˜Ÿå·ã€å‡å·ã€åº•çº¿ 123456**************--------------______________ å¯åœ¨ä¸­é—´æ’å…¥ç©ºæ ¼ï¼Œæ•ˆæœç›¸åŒ å¼•ç”¨åœ¨å¼•ç”¨æ–‡å­—å‰åŠ  &gt; 1&gt; è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— å¼•ç”¨å¯ä»¥åµŒå¥— 123&gt; è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­—&gt;&gt; è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­—&gt;&gt;&gt; è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— è¿™æ˜¯ä¸€è¡Œå¼•ç”¨æ–‡å­— åˆ—è¡¨æ— åºåˆ—è¡¨åœ¨æ–‡å­—å‰åŠ å…¥- + * ä»»æ„ä¸€ä¸ªç¬¦å· æ³¨ï¼šç¬¦å·ä¸æ–‡å­—ä¹‹é—´éœ€è¦æœ‰ç©ºæ ¼ 123- åˆ—è¡¨1+ åˆ—è¡¨2* åˆ—è¡¨3 åˆ—è¡¨1 åˆ—è¡¨2 åˆ—è¡¨3 æœ‰åºåˆ—è¡¨åœ¨æ–‡å­—å‰åŠ å…¥æ•°å­—å’Œç‚¹ 1231. åˆ—è¡¨12. åˆ—è¡¨23. åˆ—è¡¨3 åˆ—è¡¨1 åˆ—è¡¨2 åˆ—è¡¨3 å›¾ç‰‡æ ¼å¼ ![å›¾ç‰‡alt](å›¾ç‰‡åœ°å€ &quot;å›¾ç‰‡title&quot;) Titleå¯é€‰ 1![Fate](/images/cover.jpg \"Fate\") è¶…é“¾æ¥Markdownçš„è¶…é“¾æ¥æ”¯æŒä¸‰ç§å†™æ³• è¡Œå†…å¼æ ¼å¼ [è¶…é“¾æ¥å](è¶…é“¾æ¥åœ°å€ &quot;è¶…é“¾æ¥title&quot;) å…¶ä¸­Titleå¯é€‰ 123[å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github-1](https://github.com/dreamgyf \"å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github\")è¶…é“¾æ¥åä¹Ÿå¯ä»¥åµŒå¥—å›¾ç‰‡å¦‚ [![å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github-1](/images/avatar.jpeg)](https://github.com/dreamgyf) å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github 1 å‚è€ƒå¼å¯ä»¥å¯¹ä¸€ä¸ªé“¾æ¥è¿›è¡Œå¤šæ¬¡å¼•ç”¨ ä½¿ç”¨ [è¶…é“¾æ¥å][è¶…é“¾æ¥æ ‡è®°] å®šä¹‰ [è¶…é“¾æ¥æ ‡è®°]:è¶…é“¾æ¥åœ°å€ &quot;è¶…é“¾æ¥title&quot; å…¶ä¸­Titleå¯é€‰,å¯å®šä¹‰åœ¨ä»»æ„ä½ç½® 12[å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github-2][2][2]:https://github.com/dreamgyf å§‹ç»ˆéƒ½æ˜¯æ¢¦çš„Github-2 è‡ªåŠ¨é“¾æ¥å°†é“¾æ¥ç›´æ¥ç”¨&lt;&gt;åŒ…è£¹èµ·æ¥ 1&lt;https://github.com/dreamgyf&gt; https://github.com/dreamgyf è„šæ³¨ åœ¨éœ€è¦æ·»åŠ æ³¨è„šçš„æ–‡å­—ååŠ ä¸Š[^è„šæ³¨å] åœ¨æ–‡æœ¬çš„ä»»æ„ä½ç½®(ä¸€èˆ¬åœ¨æœ€å)å®šä¹‰è„šæ³¨ [^è„šæ³¨å]:è„šæ³¨å†…å®¹ 12ç¤ºä¾‹æ–‡æœ¬[^1][^1]:æˆ‘æ˜¯ç¤ºä¾‹æ–‡æœ¬çš„è„šæ³¨ ç”±äºæœ¬ç«™ä¸»é¢˜åŸå› ä¸åšæ¼”ç¤º ä»£ç å•è¡Œä»£ç å°†ä»£ç ç”¨ç‰¹æ®Šå­—ç¬¦`åŒ…è£¹(ä¸€èˆ¬ä¸ºEscä¸‹é¢çš„é”®) 1`printf(\"hello world\");` printf(&quot;hello world&quot;); ä»£ç å—ä½¿ç”¨ä¸¤ç»„ä¸‰ä¸ªç‰¹æ®Šå­—ç¬¦`åŒ…è£¹ä»£ç å— å¯ä»¥åœ¨ç¬¬ä¸€ç»„```åæ·»åŠ è¯­è¨€å 12345678â€‹```c++#include &lt;iostream&gt;int main(void) &#123; std::cout &gt;&gt; \"hello world\" &gt;&gt; endl; return 0;&#125;â€‹``` 123456#include &lt;iostream&gt;int main(void) &#123; std::cout &gt;&gt; \"hello world\" &gt;&gt; endl; return 0;&#125;","categories":[{"name":"å…¶ä»–","slug":"å…¶ä»–","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}],"categories":[{"name":"å…¶ä»–","slug":"å…¶ä»–","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"é¢è¯•","slug":"Android/é¢è¯•","permalink":"http://yoursite.com/categories/Android/%E9%9D%A2%E8%AF%95/"},{"name":"æºç åˆ†æ","slug":"Android/æºç åˆ†æ","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"Service","slug":"Android/Service","permalink":"http://yoursite.com/categories/Android/Service/"},{"name":"ContentProvider","slug":"Android/ContentProvider","permalink":"http://yoursite.com/categories/Android/ContentProvider/"},{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"},{"name":"AIäººå£°","slug":"AI/AIäººå£°","permalink":"http://yoursite.com/categories/AI/AI%E4%BA%BA%E5%A3%B0/"},{"name":"åŠ¨ç”»","slug":"Android/åŠ¨ç”»","permalink":"http://yoursite.com/categories/Android/%E5%8A%A8%E7%94%BB/"},{"name":"æƒé™","slug":"Android/æƒé™","permalink":"http://yoursite.com/categories/Android/%E6%9D%83%E9%99%90/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"Android/ActivityTaskManagerService","permalink":"http://yoursite.com/categories/Android/ActivityTaskManagerService/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"},{"name":"æ²‰æµ¸å¼","slug":"Android/æ²‰æµ¸å¼","permalink":"http://yoursite.com/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"çŠ¶æ€æ ","slug":"Android/çŠ¶æ€æ ","permalink":"http://yoursite.com/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"å¯¼èˆªæ ","slug":"Android/å¯¼èˆªæ ","permalink":"http://yoursite.com/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"Android/StatusBar","permalink":"http://yoursite.com/categories/Android/StatusBar/"},{"name":"NavigationBar","slug":"Android/NavigationBar","permalink":"http://yoursite.com/categories/Android/NavigationBar/"},{"name":"äº¤å‰ç¼–è¯‘","slug":"Android/äº¤å‰ç¼–è¯‘","permalink":"http://yoursite.com/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"ç¼–è¯‘","slug":"ç¼–è¯‘","permalink":"http://yoursite.com/categories/%E7%BC%96%E8%AF%91/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"},{"name":"Jetpack Compose","slug":"Android/Jetpack-Compose","permalink":"http://yoursite.com/categories/Android/Jetpack-Compose/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"æ’æ¡©","slug":"Android/æ’æ¡©","permalink":"http://yoursite.com/categories/Android/%E6%8F%92%E6%A1%A9/"},{"name":"å¸¸è§é—®é¢˜","slug":"Android/å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"å•å…ƒæµ‹è¯•","slug":"Android/å•å…ƒæµ‹è¯•","permalink":"http://yoursite.com/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Emoji","slug":"Emoji","permalink":"http://yoursite.com/tags/Emoji/"},{"name":"é¢è¯•","slug":"é¢è¯•","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Androidæºç ","slug":"Androidæºç ","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"},{"name":"åœ†è§’","slug":"åœ†è§’","permalink":"http://yoursite.com/tags/%E5%9C%86%E8%A7%92/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://yoursite.com/tags/ContentProvider/"},{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"AIGC","slug":"AIGC","permalink":"http://yoursite.com/tags/AIGC/"},{"name":"AIäººå£°","slug":"AIäººå£°","permalink":"http://yoursite.com/tags/AI%E4%BA%BA%E5%A3%B0/"},{"name":"Sovits","slug":"Sovits","permalink":"http://yoursite.com/tags/Sovits/"},{"name":"åŠ¨ç”»","slug":"åŠ¨ç”»","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"AnimationDrawable","slug":"AnimationDrawable","permalink":"http://yoursite.com/tags/AnimationDrawable/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"æƒé™","slug":"æƒé™","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"ActivityTaskManagerService","permalink":"http://yoursite.com/tags/ActivityTaskManagerService/"},{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"},{"name":"æ²‰æµ¸å¼","slug":"æ²‰æµ¸å¼","permalink":"http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"çŠ¶æ€æ ","slug":"çŠ¶æ€æ ","permalink":"http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"å¯¼èˆªæ ","slug":"å¯¼èˆªæ ","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://yoursite.com/tags/StatusBar/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"},{"name":"Androidäº¤å‰ç¼–è¯‘","slug":"Androidäº¤å‰ç¼–è¯‘","permalink":"http://yoursite.com/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"x264","slug":"x264","permalink":"http://yoursite.com/tags/x264/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"},{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"http://yoursite.com/tags/Jetpack-Compose/"},{"name":"ä¿¡å·","slug":"ä¿¡å·","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"},{"name":"æ’æ¡©","slug":"æ’æ¡©","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A1%A9/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"},{"name":"Capabilities","slug":"Capabilities","permalink":"http://yoursite.com/tags/Capabilities/"},{"name":"Zygote","slug":"Zygote","permalink":"http://yoursite.com/tags/Zygote/"},{"name":"initè¿›ç¨‹","slug":"initè¿›ç¨‹","permalink":"http://yoursite.com/tags/init%E8%BF%9B%E7%A8%8B/"},{"name":"å¸¸è§é—®é¢˜","slug":"å¸¸è§é—®é¢˜","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://yoursite.com/tags/SimpleDateFormat/"},{"name":"å•å…ƒæµ‹è¯•","slug":"å•å…ƒæµ‹è¯•","permalink":"http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"æ±‡ç¼–","slug":"æ±‡ç¼–","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"EditView","slug":"EditView","permalink":"http://yoursite.com/tags/EditView/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}