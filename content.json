{"meta":{"title":"始终都是梦","subtitle":"","description":"","author":"dreamgyf","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","date":"2020-06-26T17:21:13.000Z","updated":"2022-11-13T09:55:54.351Z","comments":true,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-26T17:15:50.000Z","updated":"2022-11-13T09:55:54.362Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-26T17:15:01.000Z","updated":"2022-11-13T09:55:54.370Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"Markdown"}],"posts":[{"title":"有手就行！Sovits AI人声模型训练","slug":"AI/AI人声/有手就行！Sovits AI人声模型训练","date":"2023-06-06T07:30:34.000Z","updated":"2023-06-19T14:06:38.286Z","comments":true,"path":"2023/06/06/AI/AI人声/有手就行！Sovits AI人声模型训练/","link":"","permalink":"http://yoursite.com/2023/06/06/AI/AI%E4%BA%BA%E5%A3%B0/%E6%9C%89%E6%89%8B%E5%B0%B1%E8%A1%8C%EF%BC%81Sovits%20AI%E4%BA%BA%E5%A3%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/","excerpt":"","text":"简介随着AI孙燕姿的爆火出圈，各大视频平台的AI人声投稿量激增，B站首页频频给我推送相关视频，正好我对AIGC方面也挺感兴趣，心动不如行动，于是我用自己的声音训练了一个模型，发现整个过程异常的简单，并且最终出来的效果也不错，真的是有手就行，所以这次将我自己训练推理的过程经验分享给大家 Sovits首先介绍一下今天要讲的Sovits，So-vits-svc（也称Sovits）是由是中国民间歌声合成爱好者Rcell基于VITS、soft-vc、VISinger2等一系列项目开发的一款开源免费AI语音转换软件，通过SoftVC内容编码器提取源音频语音特征，与F0同时输入VITS替换原本的文本输入达到歌声转换的效果。 由于某些原因，原作者Rcell删除了原代码仓库，现由svc-develop-team接手进行后续维护，现仓库地址：https://github.com/svc-develop-team/so-vits-svc 配置要求 一张支持 CUDA 的，拥有至少 6G 以上显存的 NVIDIA 显卡 推荐使用Windows系统，教程后续的素材处理、训练、推理均在Windows平台上完成，同时使用整合包GUI也可以帮助新手将注意力集中在训练/推理本身上，避免了繁杂的环境配置等工作 环境配置本次的环境使用的是 bilibili@羽毛布団 大佬提供的整合包：https://www.yuque.com/umoubuton/ueupp5/sdahi7m5m6r0ur1r ，在这里能找到下载地址和一些说明 下载完后，你会得到一个Sovits的压缩包和一些工具软件，将其中的so-vits-svc解压缩后，打开里面的启动webui.bat文件，它会自动准备环境，然后弹出一个网页 在网页中将Tab页切换至训练页，可以看到我们的显卡信息 确认无误后我们就可以开始训练了 准备数据集数据集的质量及多少决定了训练模型质量的上下限，质量差的数据集无论你训练多久，训练了多少万个step，都不可能达到一个理想的效果 准备干声Sovits的训练我们需要找一些想训练的声线所对应的干声素材，不可混杂多种声线，时长最好在2个小时以上，最低不要少于30分钟，否则无法保证训练出来的模型的质量，可以是说话、读书或唱歌的声音（有的人说加入一些哭闹、大笑等各种各样的声音有奇效，我没尝试过，大家可以试试看），如果想让你的模型唱歌的话，唱歌的素材需要覆盖低中高音多个频率 干声素材中不能有伴奏、混响、和声（避免转换后的声音自带BGM），不要有换气声、颤音、转音等，尽量将背景噪音去除干净 降噪如果你本来的素材就是不带伴奏混响的干声文件，但是有一些嘈杂的背景噪音，可以使用Adobe Audition（以下简称AU）进行降噪处理 教程：https://helpx.adobe.com/cn/audition/using/noise-reduction-restoration-effects.html 去伴奏混响如果你的素材是之前录好的歌曲，那么需要对它进行去伴奏去混响处理，这里推荐使用 Ultimate Vocal Remover v5（简称UVR5） 下载完UVR5，在处理音频前建议先去Advanced VR Options中将Post-Process选项打开，这样去混响的效果可能更好（玄学） 接着开始去伴奏，推荐采用以下配置： Process Method: Demucs Stems: Vocals Demucs Model: v3 | UVR_Model_1 注：找不到对应模型的可以在下拉框中选择Download在软件内下载相应模型 勾选GPU Conversion 然后对处理完后的人声文件再做一次去混响处理，推荐采用以下配置： Process Method: VR Architecture Window Size: 320 Aggression Setting: 10 VR Model: 5_HP-Karaoke_UVR 勾选GPU Conversion 勾选Voacls Only 这样简单的几步，我们就将干声从歌曲文件中提取出来了，如果你觉得提取出来的效果差强人意，也可以使用 RipX DeepAudio 做一些精修 将文件导入RipX中，会产生如下图一样的一段曲线 点击其中的某段黄色曲线可以播放这段音频，我们可以一段段听过去，遇到杂音部分可以将其手动删除 匹配响度如果你的干声素材的来源不同，很可能会有素材响度大小不一的情况，这种情况下需要使用AU对所有音频去做匹配响度，使所有素材的分贝值在一个统一的范围内 教程：https://helpx.adobe.com/cn/audition/using/match-loudness.html 压限干声的响度不宜超过-6db，建议使用Adobe Audition中的压限器将声音的分贝限制在-6db以内 教程：https://helpx.adobe.com/cn/audition/using/amplitude-compression-effects.html 切片干声素材都处理完后，下一步就是将这些素材切成一个个2-15s的小片段（片段太长容易爆显存，最好不要超过20s），这里推荐使用 Audio Slicer ，可以根据响度阈值和间隔时间等自动将音频切片 将干声文件拖进去后可以先使用默认参数切一遍，然后去输出目录，将文件按文件大小由大到小排列，查看是否还有大于15s的音频切片，如有的话，将这些音频重新拖入软件中，按照以下参数重新切片一次： Threshold（db）: -20 Minimum Interval: 100 Maximum Silence Length（ms）: 500 一般这样就不会有大于15s的音频了，如果还有的话，我将这些参数的含义列在下面，大家可以自己调整参数尝试，大家也可以使用其他的一些音频处理工具（如：AU）手动切片 Threshold（阈值） 以 dB 表示的 RMS 阈值。所有 RMS 值都低于此阈值的区域将被视为静音。如果音频有噪音，请增加此值。默认值为 -40。 Minimum Length（最小长度） 每个切片音频剪辑所需的最小长度，以毫秒为单位。默认值为 5000。 Minimum Interval（最小间距） 要切片的静音部分的最小长度，以毫秒为单位。如果音频仅包含短暂的中断，请将此值设置得更小。此值越小，此应用程序可能生成的切片音频剪辑就越多。请注意，此值必须小于 min length 且大于 hop size。默认值为 300。 Hop Size（跳跃步长） 每个 RMS 帧的长度，以毫秒为单位。增加此值将提高切片的精度，但会降低处理速度。默认值为 10。 Maximum Silence Length（最大静音长度） 在切片音频周围保持的最大静音长度，以毫秒为单位。根据需要调整此值。请注意，设置此值并不意味着切片音频中的静音部分具有完全给定的长度。如上所述，该算法将搜索要切片的最佳位置。默认值为 1000。 最后，记得把过短的音频切片删除掉 格式转换数据集的格式必须是wav原始波形格式，大家检查一下，如果如果有非wav格式的文件，需要做一下格式转换，推荐使用Foobar2000，或者直接使用FFmepg进行转换 重命名数据集中不能出现中文等非英文字符，特殊字符推荐只使用下划线，Windows下直接将文件全选后重命名，文件名会变成以下这种格式： xxx (1).wav xxx (2).wav … 本人亲测这样命名虽然会报Warning，但不影响训练，是可行的 预训练接着我们就开始准备训练了 放置数据集首先将处理好的干声全部放到一个文件夹下，然后再将这个文件夹放到so-vits-svc目录下的dataset_raw文件夹下 数据预处理打开webui界面，切换到训练选项卡，首先点击识别数据集，上面的文本框中便会显示出我们准备好的数据集名，然后选择训练使用的编码器和f0预测器，这里选择我图中标出的两个选项，是目前效果比较好的选项，接着点击数据预处理，在预处理输出信息那一栏会打印进度，耐心等待它跑完 训练配置等待数据预处理完成后，我们要将训练的设置和参数写入到配置文件中 介绍一下这里参数的含义和推荐设置： 每隔多少步(steps)生成一次评估日志：每隔一定步数输出一下当前步数下的学习率，loss值等信息，根据个人偏好自己填写即可 每隔多少步(steps)验证并保存一次模型：字面意思，根据个人偏好自己填写即可 仅保留最新的X个模型：我训练到11万步时一个模型接近600MB，大家根据自己的硬盘大小和个人偏好填写即可 批量大小：大的batch size可以减少训练时间，提高稳定性，但同时也会导致模型泛化能力下降，所以，就算你的显存很大也不建议将本参数设置的过大，推荐使用4 学习率：初始学习率过大会导致模型无法收敛，过小则会导致模型收敛特别慢或无法学习，建议使用默认值0.0001 使用fp16混合精度训练：混合精度训练是在尽可能减少精度损失的情况下利用半精度浮点数加速训练，它使用FP16即半精度浮点数存储权重和梯度，在减少占用内存的同时起到了加速训练的效果，理论上来说使用混合精度几乎不会造成精度损失，但目前没对模型质量的影响尚未查证，在显卡性能足够的情况下建议还是先不要勾选 加载数据集到内存中：在内存足够的情况下建议勾选，可以加快训练速度 所有训练参数设置好后，点击下面的写入配置文件按钮，在下面的输出信息那里会显示配置文件写入完成，接下来就可以开始正式训练了 正式训练点击下面的从头开始训练，会弹出一个新的终端窗口，在这个终端窗口中，会不断的输出当前训练的日志 我的训练参数设置的是每隔200步生成一次评估日志，每隔1000步保存一次模型，日志中输出的reference_loss值代表了模型的输出与真实值之间的差距，理论来说，这个值越低越好，越低，模型输出的声音就和真人的声音越像，但从经验来说未必如此，过低的loss值也可能代表了模型过拟合，我们只能将这个参数作为一个参考，实际效果要使用测试了这个模型后才能得知，我们可以参考这个值初步选择模型进行推理测试 训练是不会自动终止的，当我们感觉训练的差不多了，想试一下模型的实际效果时，可以在训练终端窗口中键盘键入Ctrl + C停止训练，如果对本次训练出来的模型还不满意，想要继续训练，则可以点击继续上一次的训练进度，程序会从上一个自动保存的模型的进度开始继续训练 推理加载模型模型训练完后我们就可以将选项卡切换到推理来测试模型的实际效果了 我们先点击刷新选项，此时在模型选择和配置文件的下拉菜单中就出现了我们之前训练好的模型，参考之前的reference_loss值我们选取一个模型（G开头），并且选择训练所使用的配置文件，点击加载模型，等待下面的Output Message文本框出现模型加载成功字样，就可以正式开始我们的推理了 开始推理Sovits是一个声音转换工具，我们首先需要找一段想要转换的原声音频，和准备数据集那一章的要求一样，我们需要一段干声，不能有伴奏、混响、和声。如果想让模型唱歌的话，我们可以采用前面准备数据集所用的方法，直接将原曲去伴奏混响，处理好后将其拖入音频上传区域中 默认的 pm f0预测器推理出来的音质效果最好，所以建议先使用默认参数推理一遍，出现问题再针对性的对参数进行调整 我们点击下面的音频转换按钮，稍等一会儿，在Output Audio那里便会生成一段推理后的音频 我们试听后根据具体的问题设置转换参数： 出现哑音 哑音是因为原声音频中的和声部分没有去处干净，导致f0预测器对音高的预测出现了错误，预测成了一个极高的音高，模型唱不上去导致的 有两种办法解决这个问题，一种就是从源头解决问题，想办法将原声音频的和声混响去除，获得更纯净的干声重新推理，另一种方法可以将f0预测器换成crepe，适度调节F0过滤阈值（一般使用默认值就行，改大改小没什么区别），然后重新进行推理基本就可以解决这个问题，但是音质不如f0预测器pm，电流音等杂音会变多，两种方法大家可以自行判断选取 音域差距过大 如果训练的模型是男声，但推理使用的原声是女声，或者反过来，碰到这种音域差距过大的情况会导致推理出来的音频不堪入耳 我们可以打开f0自动预测选项来解决这个问题，但正如选项里描述的那样，此选择仅限于转换语音时才可用，转换歌声时打开此选项会导致灾难性的跑调 如果是歌声并且实在是想要唱这首歌的话，建议去找一个和自己音域比较契合的翻唱音频，用这个音频处理后作为原声进行推理 部分音调唱不上（下）去 训练时喂的数据集没有覆盖到部分音域 这里的变调选项似乎是先推理再变调？所以对这种情况不起作用，建议使用AU先将原声音频升降调到合适的音域，再进行推理 爆显存 在推理的过程中有可能会出现爆显存的情况，因为推理也是将原音频按照响度阈值切成一段段小切片分别进行推理，最后再合成，如果其中有一段切片时常过长就可能会导致爆显存 我们可以将切片阈值调高，使得原声音频可以切的更加细碎，甚至你也可以直接调整音频自动切片的值开启强制切片，比如输入10，音频就会被切成每10s一段，确保音频时常不会爆显存 合成如果转换的是歌声，最后可以将转换出来的干声和伴奏合并成一个音频文件，可以使用AU等软件，在合成之前还可以对干声进行一些EQ、混响的调整等，关于音乐方面的知识这里就不多说了 结尾最后贴一下我自己练的模型所推理出来的歌声，使用了30分钟质量较好的干声素材和30分钟质量较差的素材（噪音和混响比较多），训练了11万步，使用crepef0预测器推理得出 链接：https://www.bilibili.com/audio/au3907000 这是我第一次尝试训练Sovits模型，如果有什么疏漏或错误欢迎大家指出","categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"},{"name":"AI人声","slug":"AI/AI人声","permalink":"http://yoursite.com/categories/AI/AI%E4%BA%BA%E5%A3%B0/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"AIGC","slug":"AIGC","permalink":"http://yoursite.com/tags/AIGC/"},{"name":"AI人声","slug":"AI人声","permalink":"http://yoursite.com/tags/AI%E4%BA%BA%E5%A3%B0/"},{"name":"Sovits","slug":"Sovits","permalink":"http://yoursite.com/tags/Sovits/"}]},{"title":"如何完美监听帧动画？AnimationDrawable深度解析","slug":"android/animation/如何完美监听帧动画？AnimationDrawable深度解析","date":"2023-06-01T07:20:51.000Z","updated":"2023-06-19T14:06:38.286Z","comments":true,"path":"2023/06/01/android/animation/如何完美监听帧动画？AnimationDrawable深度解析/","link":"","permalink":"http://yoursite.com/2023/06/01/android/animation/%E5%A6%82%E4%BD%95%E5%AE%8C%E7%BE%8E%E7%9B%91%E5%90%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%EF%BC%9FAnimationDrawable%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","excerpt":"","text":"简介作为苦逼的程序员，产品和设计提出来的需求咱也没法拒绝，这不，前两天设计就给提了个需求，要求在帧动画结束后，把原位置的动画替换成一段文字。我们知道，在Android中，帧动画的实现类为AnimationDrawable，而这玩意儿又不像Animator一样可以通过addListener之类的方法监听动画的开始、结束等事件，那我们该怎么监听AnimationDrawable的结束事件呢？ 目前网上大多数的做法都是获取帧动画的总时长，然后用Handler做一个postDelayed执行结束后的事情。这种方法怎么说呢？能用，但是不够精准也不够优雅，本文我们将从源码层面解析AnimationDrawable是如何将一帧帧的图片组合起来展示成连续的动画的，再从中寻求动画监听的切入点。 注：只想看实现的朋友们可以直接跳到 包装Drawable.Callback 这一节看最终实现 ImageView如何展示DrawableAnimationDrawable说到底它也就是个Drawable，而我们一般都是使用ImageView作为Drawable展示的布局，那我们就以此作为入口开始分析Drawable在ImageView中是如何被展示的。 回想一下，我们想要给一个ImageView设置图片一般可以用下面几种方法： setImageBitmap setImageResource setImageURI setImageDrawable setImageBitmap会将Bitmap包装成一个BitmapDrawable，然后再调用setImageDrawable方法。 setImageResource和setImageURI方法会通过resolveUri方法从Resource或Uri中解析出Drawable，然后调用updateDrawable方法 setImageDrawable方法则会直接调用updateDrawable方法 最终殊途同归走到updateDrawable方法中 123456789101112131415161718private void updateDrawable(Drawable d) &#123; ... if (mDrawable != null) &#123; sameDrawable = mDrawable == d; mDrawable.setCallback(null); unscheduleDrawable(mDrawable); ... &#125; mDrawable = d; if (d != null) &#123; d.setCallback(this); ... &#125; else &#123; ... &#125;&#125; 可以看到，这里将我们设置的图片资源赋值到mDrawable上。注意，这里有一个Drawable动起来的关键点，同时也是我们动画监听的最终切入点：Drawable.setCallback(this)，我们后面分析帧切换的时候会详细去聊它。 我们知道，一个控件想要绘制内容得在onDraw方法中操作Canvas，所以让我们再来看看onDraw方法 123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mDrawable == null) &#123; return; // couldn't resolve the URI &#125; if (mDrawableWidth == 0 || mDrawableHeight == 0) &#123; return; // nothing to draw (empty bounds) &#125; ... mDrawable.draw(canvas); ...&#125; 可以看到，这里调用了Drawable.draw方法将Drawable自身绘制到ImageView的Canvas上 DrawableContainer查看AnimationDrawable的继承关系我们可以得知它继承自DrawableContainer，从命名中我们就能看出来，它是Drawable的容器，我们来看一下它所实现的draw方法： 12345678public void draw(Canvas canvas) &#123; if (mCurrDrawable != null) &#123; mCurrDrawable.draw(canvas); &#125; if (mLastDrawable != null) &#123; mLastDrawable.draw(canvas); &#125;&#125; mLastDrawable是为了完成动画的切换效果（出入场动画）所准备的，我们可以不用关心它。 我们可以发现，它的内部有一个名为mCurrDrawable的成员变量，我们可以合理猜测它是通过切换mCurrDrawable指向的目标Drawable来完成展示不同图片的功能，那么事实是这样吗？ 没错，DrawableContainer给我们提供了一个selectDrawable方法，用来切换不同的图片： 1234567891011121314151617181920212223public boolean selectDrawable(int index) &#123; if (index == mCurIndex) &#123; return false; &#125; ... if (index &gt;= 0 &amp;&amp; index &lt; mDrawableContainerState.mNumChildren) &#123; final Drawable d = mDrawableContainerState.getChild(index); mCurrDrawable = d; mCurIndex = index; ... &#125; else &#123; mCurrDrawable = null; mCurIndex = -1; &#125; ... invalidateSelf(); return true;&#125; 可以看到，和我们猜想的一样，在DrawableContainer的内部有一个子类DrawableContainerState用于保存所有的Drawable，它继承自Drawable.ConstantState，是用来储存Drawable间的常量状态和数据的。在DrawableContainerState中有一个mDrawables数组用于保存所有的Drawable，通过addChild方法将Drawable加入到这个数组中 而在selectDrawable方法中，它通过getChild方法去获取当前应该显示的Drawable，并将其和index分别赋值给它的两个成员变量mCurrDrawable和mCurIndex，然后调用invalidateSelf方法执行重绘： 123456public void invalidateSelf() &#123; final Callback callback = getCallback(); if (callback != null) &#123; callback.invalidateDrawable(this); &#125;&#125; invalidateSelf被定义实现在Drawable类中，还记得我之前让大家注意的Callback吗？在设置图片这一步时，它就被赋值了，实际上这个接口被View所实现，所以在前面我们可以看到调用setCallback时，我们传入的参数为this 不过ImageView在继承View的同时也重写了这个invalidateDrawable方法，最终调用了invalidate方法执行重绘，此时，一张新的图片就被展示到我们的屏幕上了 1234567891011121314151617181920212223242526//ImageView.invalidateDrawablepublic void invalidateDrawable(@NonNull Drawable dr) &#123; if (dr == mDrawable) &#123; if (dr != null) &#123; // update cached drawable dimensions if they've changed final int w = dr.getIntrinsicWidth(); final int h = dr.getIntrinsicHeight(); if (w != mDrawableWidth || h != mDrawableHeight) &#123; mDrawableWidth = w; mDrawableHeight = h; // updates the matrix, which is dependent on the bounds configureBounds(); &#125; &#125; /* we invalidate the whole view in this case because it's very * hard to know where the drawable actually is. This is made * complicated because of the offsets and transformations that * can be applied. In theory we could get the drawable's bounds * and run them through the transformation and offsets, but this * is probably not worth the effort. */ invalidate(); &#125; else &#123; super.invalidateDrawable(dr); &#125;&#125; AnimationDrawableDrawableContainer分析完后，我们可以很自然的想到，AnimationDrawable就是通过DrawableContainer这种可以切换图片的机制，每隔一定时间执行一下selectDrawable便可以达成帧动画的效果了。 我们先回想一下，在代码中怎么构造出一个多帧的AnimationDrawable？没错，用默认构造方法实例化出来后，调用它的addFrame方法往里一帧帧的添加图片： 123456public void addFrame(@NonNull Drawable frame, int duration) &#123; mAnimationState.addFrame(frame, duration); if (!mRunning) &#123; setFrame(0, true, false); &#125;&#125; 可以看到AnimationDrawable也有一个内部类AnimationState，继承自DrawableContainerState，它的addFrame方法就是调用DrawableContainerState.addChild方法添加图片，同时将这张图片的持续时间保存在mDurations数组中： 1234public void addFrame(Drawable dr, int dur) &#123; int pos = super.addChild(dr); mDurations[pos] = dur;&#125; 想让AnimationDrawable动起来的话，我们得要调用它的start方法，那我们就从这个方法开始分析： 123456789public void start() &#123; mAnimating = true; if (!isRunning()) &#123; // Start from 0th frame. setFrame(0, false, mAnimationState.getChildCount() &gt; 1 || !mAnimationState.mOneShot); &#125;&#125; 这里将mAnimating状态置为true，然后调用setFrame方法从第0帧开始展示图片 1234567891011121314151617private void setFrame(int frame, boolean unschedule, boolean animate) &#123; if (frame &gt;= mAnimationState.getChildCount()) &#123; return; &#125; mAnimating = animate; mCurFrame = frame; selectDrawable(frame); if (unschedule || animate) &#123; unscheduleSelf(this); &#125; if (animate) &#123; // Unscheduling may have clobbered these values; restore them mCurFrame = frame; mRunning = true; scheduleSelf(this, SystemClock.uptimeMillis() + mAnimationState.mDurations[frame]); &#125;&#125; 这里可以看到，和我们所想的一样，调用了DrawableContainer.selectDrawable切换当前展示图片，由于我们之前将mAnimating赋值为了true，所以会调用scheduleSelf方法调度展示下一张图片，时间为当前帧持续时间后 123456public void scheduleSelf(@NonNull Runnable what, long when) &#123; final Callback callback = getCallback(); if (callback != null) &#123; callback.scheduleDrawable(this, what, when); &#125;&#125; scheduleSelf方法调用了Drawable.Callback.scheduleDrawable方法，我们去View里面看实现： 1234567891011121314public void scheduleDrawable(@NonNull Drawable who, @NonNull Runnable what, long when) &#123; if (verifyDrawable(who) &amp;&amp; what != null) &#123; final long delay = when - SystemClock.uptimeMillis(); if (mAttachInfo != null) &#123; mAttachInfo.mViewRootImpl.mChoreographer.postCallbackDelayed( Choreographer.CALLBACK_ANIMATION, what, who, Choreographer.subtractFrameDelay(delay)); &#125; else &#123; // Postpone the runnable until we know // on which thread it needs to run. getRunQueue().postDelayed(what, delay); &#125; &#125;&#125; 实际上两个分支最终都是通过Handler实现延时调用，而调用的Runnable对象就是之前scheduleSelf传入的this。没错，AnimationDrawable实现了Runnable接口： 12345678910111213141516public void run() &#123; nextFrame(false);&#125;private void nextFrame(boolean unschedule) &#123; int nextFrame = mCurFrame + 1; final int numFrames = mAnimationState.getChildCount(); final boolean isLastFrame = mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= (numFrames - 1); // Loop if necessary. One-shot animations should never hit this case. if (!mAnimationState.mOneShot &amp;&amp; nextFrame &gt;= numFrames) &#123; nextFrame = 0; &#125; setFrame(nextFrame, unschedule, !isLastFrame);&#125; 可以看到，在一帧持续时间结束后，便会调用nextFrame方法，计算下一帧的index，然后调用setFrame方法切换下一帧，形成一个循环，这样一帧帧的图片便动了起来，形成了帧动画 包装Drawable.Callback我们从源码层面分析了帧动画是如何运作的，那么怎么监听动画事件相信各位应该都能得出结论了吧？没错，就是重设Drawable的Callback 当Drawable被设置到控件中后，控件会将自身作为Drawable.Callback设置给Drawable，那么我们只需要重新给Drawable设置一个Drawable.Callback，在其中调用View回调方法的同时，加入自己的监听逻辑即可 123456789101112131415161718192021222324252627val animDrawable = imageView.drawable as AnimationDrawableval callback = object : Drawable.Callback &#123; override fun invalidateDrawable(who: Drawable) &#123; imageView.invalidateDrawable(who) if (animDrawable.getFrame(animDrawable.numberOfFrames - 1) == current &amp;&amp; animDrawable.isOneShot &amp;&amp; animDrawable.isRunning &amp;&amp; animDrawable.isVisible ) &#123; val lastFrameDuration = getDuration(animDrawable.numberOfFrames - 1) postDelayed(&#123; ...//结束后需要做的事 &#125;, lastFrameDuration.toLong()) &#125; &#125; override fun scheduleDrawable(who: Drawable, what: Runnable, `when`: Long) &#123; imageView.scheduleDrawable(who, what, `when`) &#125; override fun unscheduleDrawable(who: Drawable, what: Runnable) &#123; imageView.unscheduleDrawable(who, what) &#125;&#125;//注意一定需要用一个成员变量或其他方式持有这个Callback//因为Drawable.Callback是以弱引用的形式被保存在Drawable内的，很容易被回收mCallbackHolder = callbackanimDrawable.callback = callbackanimDrawable.start() 以上的代码便是示例，当满足动画运行到最后一帧，且满足结束状态时，在最后一帧的持续时间后处理结束后需要做的事 当AnimationDrawable切换Visible状态为false时，动画会被暂停，如果在动画结束后触发setVisible(false)事件，也会触发invalidateDrawable回调，所以这里需要额外判断一下isVisible 自己包装的Drawable.Callback一定需要找个东西将它强引用起来，因为Drawable.Callback是以弱引用的形式被保存在Drawable内的，很容易被回收，一旦被回收，整个AnimationDrawable动画就动不起来了 尾声为了这么简单一个小功能，还得跑到源码里看怎么实现，对此我的感受是：一入安卓深似海，从此头发是路人","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"动画","slug":"Android/动画","permalink":"http://yoursite.com/categories/Android/%E5%8A%A8%E7%94%BB/"}],"tags":[{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"AnimationDrawable","slug":"AnimationDrawable","permalink":"http://yoursite.com/tags/AnimationDrawable/"}]},{"title":"Android动态权限申请从未如此简单","slug":"android/common/Android动态权限申请从未如此简单","date":"2023-04-23T13:55:46.000Z","updated":"2023-04-24T15:17:47.677Z","comments":true,"path":"2023/04/23/android/common/Android动态权限申请从未如此简单/","link":"","permalink":"http://yoursite.com/2023/04/23/android/common/Android%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%E4%BB%8E%E6%9C%AA%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/","excerpt":"","text":"前言注：只想看实现的朋友们可以直接跳到最后面的最终实现 大家是否还在为动态权限申请感到苦恼呢？传统的动态权限申请需要在Activity中重写onRequestPermissionsResult方法来接收用户权限授予的结果。试想一下，你需要在一个子模块中申请权限，那得从这个模块所在的Activity的onRequestPermissionsResult中将结果一层层再传回到这个模块中，相当的麻烦，代码也相当冗余和不干净，逼死强迫症。 使用为了解决这个痛点，我封装出了两个方法，用于随时随地快速的动态申请权限，我们先来看看我们的封装方法是如何调用的： 12345678activity.requestPermission(Manifest.permission.CAMERA, onPermit = &#123; //申请权限成功 Do something&#125;, onDeny = &#123; shouldShowCustomRequest -&gt; //申请权限失败 Do something if (shouldShowCustomRequest) &#123; //用户选择了拒绝并且不在询问，此时应该使用自定义弹窗提醒用户授权（可选） &#125;&#125;) 这样是不是非常的简单便捷？申请和结果回调都在一个方法内处理，并且支持随用随调。 方案那么，这么方便好用的方法是怎么实现的呢？不知道小伙伴们在平时开发中有没有注意到过，当你调用startActivityForResult时，AS会提示你该方法已被弃用，点进去看会告诉你应该使用registerForActivityResult方法替代。没错，这就是androidx给我们提供的ActivityResult功能，并且这个功能不仅支持ActivityResult回调，还支持打开文档，拍摄照片，选择文件等各种各样的回调，同样也包括我们今天要说的权限申请 其实Android在官方文档 请求运行时权限 中就已经将其作为动态权限申请的推荐方法了，如下示例代码所示： 12345678910111213141516171819202122232425262728293031323334353637val requestPermissionLauncher = registerForActivityResult(RequestPermission() ) &#123; isGranted: Boolean -&gt; if (isGranted) &#123; // Permission is granted. Continue the action or workflow in your // app. &#125; else &#123; // Explain to the user that the feature is unavailable because the // feature requires a permission that the user has denied. At the // same time, respect the user's decision. Don't link to system // settings in an effort to convince the user to change their // decision. &#125; &#125;when &#123; ContextCompat.checkSelfPermission( CONTEXT, Manifest.permission.REQUESTED_PERMISSION ) == PackageManager.PERMISSION_GRANTED -&gt; &#123; // You can use the API that requires the permission. &#125; shouldShowRequestPermissionRationale(...) -&gt; &#123; // In an educational UI, explain to the user why your app requires this // permission for a specific feature to behave as expected, and what // features are disabled if it's declined. In this UI, include a // \"cancel\" or \"no thanks\" button that lets the user continue // using your app without granting the permission. showInContextUI(...) &#125; else -&gt; &#123; // You can directly ask for the permission. // The registered ActivityResultCallback gets the result of this request. requestPermissionLauncher.launch( Manifest.permission.REQUESTED_PERMISSION) &#125;&#125; 说到这里，可能有小伙伴要质疑我了：“官方文档里都写明了的东西，你还特地写一遍，还起了这么个标题，是不是在水文章？！” 莫急，如果你遵照以上方法这么写的话，在实际调用的时候会直接发生崩溃： 123java.lang.IllegalStateException: LifecycleOwner Activity is attempting to register while current state is RESUMED. LifecycleOwners must call register before they are STARTED. 这段报错很明显的告诉我们，我们的注册工作必须要在Activity声明周期STARTED之前进行（也就是onCreate时和onStart完成前），但这样我们就必须要事先注册好所有可能会用到的权限，没办法做到随时随地有需要时再申请权限了，有办法解决这个问题吗？答案是肯定的。 绕过生命周期检测想解决这个问题，我们必须要知道问题的成因，让我们带着问题进到源码中一探究竟： 12345678910111213141516171819202122232425262728293031323334353637383940public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; registerForActivityResult( @NonNull ActivityResultContract&lt;I, O&gt; contract, @NonNull ActivityResultCallback&lt;O&gt; callback) &#123; return registerForActivityResult(contract, mActivityResultRegistry, callback);&#125;public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; registerForActivityResult( @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultRegistry registry, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; return registry.register( \"activity_rq#\" + mNextLocalRequestCode.getAndIncrement(), this, contract, callback);&#125;public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; register( @NonNull final String key, @NonNull final LifecycleOwner lifecycleOwner, @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; Lifecycle lifecycle = lifecycleOwner.getLifecycle(); if (lifecycle.getCurrentState().isAtLeast(Lifecycle.State.STARTED)) &#123; throw new IllegalStateException(\"LifecycleOwner \" + lifecycleOwner + \" is \" + \"attempting to register while current state is \" + lifecycle.getCurrentState() + \". LifecycleOwners must call register before \" + \"they are STARTED.\"); &#125; registerKey(key); LifecycleContainer lifecycleContainer = mKeyToLifecycleContainers.get(key); if (lifecycleContainer == null) &#123; lifecycleContainer = new LifecycleContainer(lifecycle); &#125; LifecycleEventObserver observer = new LifecycleEventObserver() &#123; ... &#125;; lifecycleContainer.addObserver(observer); mKeyToLifecycleContainers.put(key, lifecycleContainer); return new ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;&#125; 我们可以发现，registerForActivityResult实际上就是调用了ComponentActivity内部成员变量的mActivityResultRegistry.register方法，而在这个方法的一开头就检查了当前Activity的生命周期，如果生命周期位于STARTED后则直接抛出异常，那我们该如何绕过这个限制呢？ 其实在register方法的下面就有一个同名重载方法，这个方法并没有做生命周期的检测： 1234567891011121314151617181920212223public final &lt;I, O&gt; ActivityResultLauncher&lt;I&gt; register( @NonNull final String key, @NonNull final ActivityResultContract&lt;I, O&gt; contract, @NonNull final ActivityResultCallback&lt;O&gt; callback) &#123; registerKey(key); mKeyToCallback.put(key, new CallbackAndContract&lt;&gt;(callback, contract)); if (mParsedPendingResults.containsKey(key)) &#123; @SuppressWarnings(\"unchecked\") final O parsedPendingResult = (O) mParsedPendingResults.get(key); mParsedPendingResults.remove(key); callback.onActivityResult(parsedPendingResult); &#125; final ActivityResult pendingResult = mPendingResults.getParcelable(key); if (pendingResult != null) &#123; mPendingResults.remove(key); callback.onActivityResult(contract.parseResult( pendingResult.getResultCode(), pendingResult.getData())); &#125; return new ActivityResultLauncher&lt;I&gt;() &#123; ... &#125;;&#125; 找到这个方法就简单了，我们将registerForActivityResult方法调用替换成activityResultRegistry.register调用就可以了 当然，我们还需要注意一些小细节，检查生命周期的register方法同时也会注册生命周期回调，当Activity被销毁时会将我们注册的ActivityResult回调移除，我们也需要给我们封装的方法加上这个逻辑，最终实现就如下所示。 最终实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293private val nextLocalRequestCode = AtomicInteger()private val nextKey: String get() = \"activity_rq#$&#123;nextLocalRequestCode.getAndIncrement()&#125;\"fun ComponentActivity.requestPermission( permission: String, onPermit: () -&gt; Unit, onDeny: (shouldShowCustomRequest: Boolean) -&gt; Unit) &#123; if (ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED) &#123; onPermit() return &#125; var launcher by Delegates.notNull&lt;ActivityResultLauncher&lt;String&gt;&gt;() launcher = activityResultRegistry.register( nextKey, ActivityResultContracts.RequestPermission() ) &#123; result -&gt; if (result) &#123; onPermit() &#125; else &#123; onDeny(!ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#125; launcher.unregister() &#125; lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; launcher.unregister() lifecycle.removeObserver(this) &#125; &#125; &#125;) launcher.launch(permission)&#125;fun ComponentActivity.requestPermissions( permissions: Array&lt;String&gt;, onPermit: () -&gt; Unit, onDeny: (shouldShowCustomRequest: Boolean) -&gt; Unit) &#123; var hasPermissions = true for (permission in permissions) &#123; if (ContextCompat.checkSelfPermission( this, permission ) != PackageManager.PERMISSION_GRANTED ) &#123; hasPermissions = false break &#125; &#125; if (hasPermissions) &#123; onPermit() return &#125; var launcher by Delegates.notNull&lt;ActivityResultLauncher&lt;Array&lt;String&gt;&gt;&gt;() launcher = activityResultRegistry.register( nextKey, ActivityResultContracts.RequestMultiplePermissions() ) &#123; result -&gt; var allAllow = true for (allow in result.values) &#123; if (!allow) &#123; allAllow = false break &#125; &#125; if (allAllow) &#123; onPermit() &#125; else &#123; var shouldShowCustomRequest = false for (permission in permissions) &#123; if (!ActivityCompat.shouldShowRequestPermissionRationale(this, permission)) &#123; shouldShowCustomRequest = true break &#125; &#125; onDeny(shouldShowCustomRequest) &#125; launcher.unregister() &#125; lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123; if (event == Lifecycle.Event.ON_DESTROY) &#123; launcher.unregister() lifecycle.removeObserver(this) &#125; &#125; &#125;) launcher.launch(permissions)&#125; 总结其实很多实用技巧本质上都是很简单的，但没有接触过就很难想到，我将我的开发经验分享给大家，希望能帮助到大家。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"权限","slug":"Android/权限","permalink":"http://yoursite.com/categories/Android/%E6%9D%83%E9%99%90/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"}]},{"title":"Android源码分析 - Activity销毁流程","slug":"android/aosp/Android源码分析-Activity销毁流程","date":"2023-03-08T07:49:50.000Z","updated":"2023-04-23T13:51:43.890Z","comments":true,"path":"2023/03/08/android/aosp/Android源码分析-Activity销毁流程/","link":"","permalink":"http://yoursite.com/2023/03/08/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 我们在之前的几篇Activity启动流程分析中已经了解了Activity一半的生命周期，接下来这篇文章我们就来分析一下Activity销毁相关的生命周期 前几期文章回顾： Android源码分析 - Activity启动流程（上） Android源码分析 - Activity启动流程（中） Android源码分析 - Activity启动流程（下） 触发销毁既然要分析Activity销毁流程，那我们就从最常见的入口Activity.finish入手 123public void finish() &#123; finish(DONT_FINISH_TASK_WITH_ACTIVITY);&#125; 默认的finish方法调用了另一个同名重载方法，接受一个int类型的参数表明是否需要在销毁Activity的同时销毁Task，该参数有以下三种： DONT_FINISH_TASK_WITH_ACTIVITY：默认参数，表示在销毁Activity的时候不要销毁Task FINISH_TASK_WITH_ROOT_ACTIVITY：当Activity为跟Activity的时候，销毁的同时销毁Task，同时这个任务也会从最近任务中移除 FINISH_TASK_WITH_ACTIVITY：销毁Activity的时候同时销毁Task，但不会从最近任务中移除 123456789101112131415161718192021222324252627282930313233private void finish(int finishTask) &#123; if (mParent == null) &#123; //当finish后才可能会触发onActivityResult回调 //这里准备将result返回给之前调用startActivityForResult的Activity int resultCode; Intent resultData; synchronized (this) &#123; resultCode = mResultCode; resultData = mResultData; &#125; try &#123; //两个Activity可能处于不同进程中，做进程间通信的准备 if (resultData != null) &#123; resultData.prepareToLeaveProcess(this); &#125; //调用ATMS销毁Activity if (ActivityTaskManager.getService() .finishActivity(mToken, resultCode, resultData, finishTask)) &#123; mFinished = true; &#125; &#125; catch (RemoteException e) &#123; // Empty &#125; &#125; else &#123; mParent.finishFromChild(this); &#125; // Activity was launched when user tapped a link in the Autofill Save UI - Save UI must // be restored now. if (mIntent != null &amp;&amp; mIntent.hasExtra(AutofillManager.EXTRA_RESTORE_SESSION_TOKEN)) &#123; restoreAutofillSaveUi(); &#125;&#125; onActivityResult回调是在对应Activity resume时才可能触发，具体过程后面会分析，将ActivityRecord.Token和Result作为参数调用ATMS.finishActivity方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) &#123; // Refuse possible leaked file descriptors //回传的ResultIntent中不允许包含fd，防止泄漏 if (resultData != null &amp;&amp; resultData.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; final ActivityRecord r; synchronized (mGlobalLock) &#123; //获取ActivityRecord并保证其在栈中 r = ActivityRecord.isInStackLocked(token); //为null说明已被移出ActivityStack，视作已被finish if (r == null) &#123; return true; &#125; &#125; // Carefully collect grants without holding lock //检查调用方（即待finish的Activity）是否能授予result所对应Activity package访问uri的权限 final NeededUriGrants resultGrants = collectGrants(resultData, r.resultTo); synchronized (mGlobalLock) &#123; // Sanity check in case activity was removed before entering global lock. if (!r.isInHistory()) &#123; return true; &#125; // Keep track of the root activity of the task before we finish it final Task tr = r.getTask(); final ActivityRecord rootR = tr.getRootActivity(); // Do not allow task to finish if last task in lockTask mode. Launchable priv-apps can // finish. //LockTask模式下，如果此为最后一个Task，则不允许被销毁 //详见：https://developer.android.com/work/dpc/dedicated-devices/lock-task-mode if (getLockTaskController().activityBlockedFromFinish(r)) &#123; return false; &#125; // TODO: There is a dup. of this block of code in ActivityStack.navigateUpToLocked // We should consolidate. //IActivityController分发Activity状态变化 if (mController != null) &#123; // Find the first activity that is not finishing. //寻找该Activity销毁后的下一个顶层Activity final ActivityRecord next = r.getRootTask().topRunningActivity(token, INVALID_TASK_ID); if (next != null) &#123; // ask watcher if this is allowed boolean resumeOK = true; try &#123; resumeOK = mController.activityResuming(next.packageName); &#125; catch (RemoteException e) &#123; mController = null; Watchdog.getInstance().setActivityController(null); &#125; if (!resumeOK) &#123; return false; &#125; &#125; &#125; // note down that the process has finished an activity and is in background activity // starts grace period //设置Activity销毁的最新时间 if (r.app != null) &#123; r.app.setLastActivityFinishTimeIfNeeded(SystemClock.uptimeMillis()); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; boolean res; final boolean finishWithRootActivity = finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY; if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY || (finishWithRootActivity &amp;&amp; r == rootR)) &#123; //需要同时销毁Task // If requested, remove the task that is associated to this activity only if it // was the root activity in the task. The result code and data is ignored // because we don't support returning them across task boundaries. Also, to // keep backwards compatibility we remove the task from recents when finishing // task with root activity. //移除Task mStackSupervisor.removeTask(tr, false /*killProcess*/, finishWithRootActivity, \"finish-activity\"); res = true; // Explicitly dismissing the activity so reset its relaunch flag. r.mRelaunchReason = RELAUNCH_REASON_NONE; &#125; else &#123; //不需要同时销毁Task r.finishIfPossible(resultCode, resultData, resultGrants, \"app-request\", true /* oomAdj */); res = r.finishing; &#125; return res; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125;&#125; 这个方法里分了两个case，当需要同时销毁Task的时候，直接调用ActivityStackSupervisor.removeTask，当不需要同时销毁Task的时候，调用ActivityRecord.finishIfPossible 我们先看需要同时销毁Task的case 1234567891011121314151617181920212223void removeTask(Task task, boolean killProcess, boolean removeFromRecents, String reason) &#123; if (task.mInRemoveTask) &#123; // Prevent recursion. return; &#125; task.mInRemoveTask = true; try &#123; //执行Task移除操作 task.performClearTask(reason); //对Task执行杀进程，从最近任务列表移除等操作 cleanUpRemovedTaskLocked(task, killProcess, removeFromRecents); //关闭LockTask模式 mService.getLockTaskController().clearLockedTask(task); //通知Task状态发生变化 mService.getTaskChangeNotificationController().notifyTaskStackChanged(); //将最近任务持久化保存 if (task.isPersistable) &#123; mService.notifyTaskPersisterLocked(null, true); &#125; &#125; finally &#123; task.mInRemoveTask = false; &#125;&#125; 本篇文章我们主要关注的是Activity销毁流程，至于进程的关闭，最近任务列表的更新我们在这里就不关心了，而这里Activity销毁的重点在于Task.performClearTask方法 12345678910111213141516171819/** Completely remove all activities associated with an existing task. */void performClearTask(String reason) &#123; // Broken down into to cases to avoid object create due to capturing mStack. if (getStack() == null) &#123; forAllActivities((r) -&gt; &#123; if (r.finishing) return; // Task was restored from persistent storage. r.takeFromHistory(); removeChild(r); &#125;); &#125; else &#123; forAllActivities((r) -&gt; &#123; if (r.finishing) return; // TODO: figure-out how to avoid object creation due to capture of reason variable. r.finishIfPossible(Activity.RESULT_CANCELED, null /* resultData */, null /* resultGrants */, reason, false /* oomAdj */); &#125;); &#125;&#125; 我们看后半部分代码可以发现，这个方法对Task中所有未销毁的Activity都执行了ActivityRecord.finishIfPossible方法，这样路径就和上面ATMS.finishActivity方法中第二个case统一了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * Finish activity if possible. If activity was resumed - we must first pause it to make the * activity below resumed. Otherwise we will try to complete the request immediately by calling * &#123;@link #completeFinishing(String)&#125;. * @return One of &#123;@link FinishRequest&#125; values: * &#123;@link #FINISH_RESULT_REMOVED&#125; if this activity has been removed from the history list. * &#123;@link #FINISH_RESULT_REQUESTED&#125; if removal process was started, but it is still in the list * and will be removed from history later. * &#123;@link #FINISH_RESULT_CANCELLED&#125; if activity is already finishing or in invalid state and the * request to finish it was not ignored. */@FinishRequest int finishIfPossible(int resultCode, Intent resultData, NeededUriGrants resultGrants, String reason, boolean oomAdj) &#123; //防止重复销毁 if (finishing) &#123; return FINISH_RESULT_CANCELLED; &#125; //此Activity不在任务栈中 if (!isInStackLocked()) &#123; return FINISH_RESULT_CANCELLED; &#125; final ActivityStack stack = getRootTask(); //应该调整顶部Activity final boolean mayAdjustTop = (isState(RESUMED) || stack.mResumedActivity == null) &amp;&amp; stack.isFocusedStackOnDisplay(); //应该调整全局焦点 final boolean shouldAdjustGlobalFocus = mayAdjustTop // It must be checked before &#123;@link #makeFinishingLocked&#125; is called, because a stack // is not visible if it only contains finishing activities. &amp;&amp; mRootWindowContainer.isTopDisplayFocusedStack(stack); //暂停布局工作 mAtmService.deferWindowLayout(); try &#123; //设置当前Activity状态为finishing makeFinishingLocked(); // Make a local reference to its task since this.task could be set to null once this // activity is destroyed and detached from task. final Task task = getTask(); //获取上一个ActivityRecord ActivityRecord next = task.getActivityAbove(this); //传递FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET：重置该Task时清除此Activity if (next != null) &#123; if ((intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) != 0) &#123; // If the caller asked that this activity (and all above it) // be cleared when the task is reset, don't lose that information, // but propagate it up to the next activity. next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET); &#125; &#125; //暂停输入事件分发 pauseKeyDispatchingLocked(); // We are finishing the top focused activity and its task has nothing to be focused so // the next focusable task should be focused. //应该调整顶部Activity，但此Task没有Activity可以被运行在顶部，将焦点转移至下一个可聚焦的Task if (mayAdjustTop &amp;&amp; ((ActivityStack) task).topRunningActivity(true /* focusableOnly */) == null) &#123; task.adjustFocusToNextFocusableTask(\"finish-top\", false /* allowFocusSelf */, shouldAdjustGlobalFocus); &#125; //将Result信息写入到对应ActivityRecord中，待后面resume的时候触发onActivityResult回调 finishActivityResults(resultCode, resultData, resultGrants); //终止Task final boolean endTask = task.getActivityBelow(this) == null &amp;&amp; !task.isClearingToReuseTask(); final int transit = endTask ? TRANSIT_TASK_CLOSE : TRANSIT_ACTIVITY_CLOSE; if (isState(RESUMED)) &#123; if (endTask) &#123; //通知Task移除已开始 mAtmService.getTaskChangeNotificationController().notifyTaskRemovalStarted( task.getTaskInfo()); &#125; // Prepare app close transition, but don't execute just yet. It is possible that // an activity that will be made resumed in place of this one will immediately // launch another new activity. In this case current closing transition will be // combined with open transition for the new activity. //准备Activity转场动画 mDisplayContent.prepareAppTransition(transit, false); // When finishing the activity preemptively take the snapshot before the app window // is marked as hidden and any configuration changes take place //更新Task快照 if (mAtmService.mWindowManager.mTaskSnapshotController != null) &#123; final ArraySet&lt;Task&gt; tasks = Sets.newArraySet(task); mAtmService.mWindowManager.mTaskSnapshotController.snapshotTasks(tasks); mAtmService.mWindowManager.mTaskSnapshotController .addSkipClosingAppSnapshotTasks(tasks); &#125; // Tell window manager to prepare for this one to be removed. //设置可见性 setVisibility(false); if (stack.mPausingActivity == null) &#123; //开始暂停此Activity stack.startPausingLocked(false /* userLeaving */, false /* uiSleeping */, null /* resuming */); &#125; if (endTask) &#123; //屏幕固定功能 mAtmService.getLockTaskController().clearLockedTask(task); // This activity was in the top focused stack and this is the last activity in // that task, give this activity a higher layer so it can stay on top before the // closing task transition be executed. //更新窗口层级 if (mayAdjustTop) &#123; mNeedsZBoost = true; mDisplayContent.assignWindowLayers(false /* setLayoutNeeded */); &#125; &#125; &#125; else if (!isState(PAUSING)) &#123; ... //正常不会进入此case &#125; return FINISH_RESULT_REQUESTED; &#125; finally &#123; //恢复布局工作 mAtmService.continueWindowLayout(); &#125;&#125; 这个方法中，我们需要关注一下对于Result信息的处理，这里调用了finishActivityResults方法，将Result信息写入到对应ActivityRecord中，待后面resume的时候触发onActivityResult回调 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Sets the result for activity that started this one, clears the references to activities * started for result from this one, and clears new intents. */private void finishActivityResults(int resultCode, Intent resultData, NeededUriGrants resultGrants) &#123; // Send the result if needed if (resultTo != null) &#123; if (resultTo.mUserId != mUserId) &#123; if (resultData != null) &#123; resultData.prepareToLeaveUser(mUserId); &#125; &#125; if (info.applicationInfo.uid &gt; 0) &#123; mAtmService.mUgmInternal.grantUriPermissionUncheckedFromIntent(resultGrants, resultTo.getUriPermissionsLocked()); &#125; resultTo.addResultLocked(this, resultWho, requestCode, resultCode, resultData); resultTo = null; &#125; // Make sure this HistoryRecord is not holding on to other resources, // because clients have remote IPC references to this object so we // can't assume that will go away and want to avoid circular IPC refs. results = null; pendingResults = null; newIntents = null; setSavedState(null /* savedState */);&#125;//将Result结果添加到results列表中void addResultLocked(ActivityRecord from, String resultWho, int requestCode, int resultCode, Intent resultData) &#123; ActivityResult r = new ActivityResult(from, resultWho, requestCode, resultCode, resultData); if (results == null) &#123; results = new ArrayList&lt;ResultInfo&gt;(); &#125; results.add(r);&#125; 这个方法很简单，就是将Result信息添加到ActivityRecord.results列表中 然后我们继续沿着finish主线链路走，后面有一个isState的判断，正常来说，ActivityRecord的state应该为RESUMED，具体为什么我们可以回顾一下之前分析的Activity启动流程，在ActivityStackSupervisor.realStartActivityLocked方法最后，会调用ActivityStack.minimalResumeActivityLocked，在这个方法中，会将ActivityRecord的state设置为RESUMED，由于ClientTransaction的执行是通过Handler.sendMessage进行的，所以早在Activity onCreate之前，ActivityRecord的状态就已经被设为了RESUMED 根据以上分析，我们会走进isState(RESUMED)这个case中，接着调用ActivityStack.startPausingLocked方法暂停Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * Start pausing the currently resumed activity. It is an error to call this if there * is already an activity being paused or there is no resumed activity. * * @param userLeaving True if this should result in an onUserLeaving to the current activity. * @param uiSleeping True if this is happening with the user interface going to sleep (the * screen turning off). * @param resuming The activity we are currently trying to resume or null if this is not being * called as part of resuming the top activity, so we shouldn't try to instigate * a resume here if not null. * @return Returns true if an activity now is in the PAUSING state, and we are waiting for * it to tell us when it is done. */final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming) &#123; //已有Activity正在暂停中 if (mPausingActivity != null) &#123; if (!shouldSleepActivities()) &#123; // Avoid recursion among check for sleep and complete pause during sleeping. // Because activity will be paused immediately after resume, just let pause // be completed by the order of activity paused from clients. completePauseLocked(false, resuming); &#125; &#125; //上一个已resume的Activity ActivityRecord prev = mResumedActivity; //既没有已resume的Activity，也没有正在resume的Activity //从栈顶找一个Activity恢复 if (prev == null) &#123; if (resuming == null) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return false; &#125; //不能暂停一个正在resume的Activity if (prev == resuming) &#123; return false; &#125; //设置各种状态 mPausingActivity = prev; mLastPausedActivity = prev; mLastNoHistoryActivity = prev.isNoHistory() ? prev : null; prev.setState(PAUSING, \"startPausingLocked\"); prev.getTask().touchActiveTime(); clearLaunchTime(prev); //更新统计信息 mAtmService.updateCpuStats(); boolean pauseImmediately = false; ... //当前流程下pauseImmediately始终为false if (prev.attachedToProcess()) &#123; try &#123; //调度Pause生命周期事务 mAtmService.getLifecycleManager().scheduleTransaction(prev.app.getThread(), prev.appToken, PauseActivityItem.obtain(prev.finishing, userLeaving, prev.configChangeFlags, pauseImmediately)); &#125; catch (Exception e) &#123; // Ignore exception, if process died other code will cleanup. mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; &#125; else &#123; mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; &#125; // If we are not going to sleep, we want to ensure the device is // awake until the next activity is started. //获取Wakelock，确保设备awake状态直到下一个Activity启动 if (!uiSleeping &amp;&amp; !mAtmService.isSleepingOrShuttingDownLocked()) &#123; mStackSupervisor.acquireLaunchWakelock(); &#125; if (mPausingActivity != null) &#123; // Have the window manager pause its key dispatching until the new // activity has started. If we're pausing the activity just because // the screen is being turned off and the UI is sleeping, don't interrupt // key dispatch; the same activity will pick it up again on wakeup. if (!uiSleeping) &#123; //暂停输入事件分发 prev.pauseKeyDispatchingLocked(); &#125; if (pauseImmediately) &#123; //不会进入此case // If the caller said they don't want to wait for the pause, then complete // the pause now. completePauseLocked(false, resuming); return false; &#125; else &#123; //设置超时监听（500ms内没有完成便视为超时） prev.schedulePauseTimeout(); return true; &#125; &#125; else &#123; // This activity failed to schedule the // pause, so just treat it as being paused now. //未能成功暂停此Activity，从栈顶找一个Activity恢复 if (resuming == null) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return false; &#125;&#125; 可以看到，和Activity启动流程类似，该方法里面调用了ClientLifecycleManager.scheduleTransaction方法来调度Activity暂停的生命周期，具体是怎样调度的可以看我之前的文章 Android源码分析 - Activity启动流程（下），里面分析了ClientTransaction事务是怎么被调度执行的 了解完后我们就可以知道，生命周期事务的执行也就相当于分别调用ActivityLifecycleItem的preExecute、execute、postExecute方法，而PauseActivityItem没有重写preExecute方法，所以我们就依次分析其execute、postExecute方法就好了 12345public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions, \"PAUSE_ACTIVITY_ITEM\");&#125; ClientTransactionHandler这个我们之前说过，这是一个抽象类，被ActivityThread继承实现，所以这里实际上就是调用ActivityThread.handlePauseActivity方法 handlePauseActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, PendingTransactionActions pendingActions, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (r != null) &#123; ... r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(r, finished, reason, pendingActions); // Make sure any pending writes are now committed. //确保所有全局任务都被处理完成 if (r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; //更新标记 mSomeActivitiesChanged = true; &#125;&#125;/** * Pause the activity. * @return Saved instance state for pre-Honeycomb apps if it was saved, &#123;@code null&#125; otherwise. */private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason, PendingTransactionActions pendingActions) &#123; ... //异常状态检查 if (finished) &#123; r.activity.mFinished = true; &#125; // Pre-Honeycomb apps always save their state before pausing //是否需要保存状态信息（Android 3.0前无论是否finish都会触发保存） final boolean shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb(); if (shouldSaveState) &#123; //回调Activity的onSaveInstanceState方法 callActivityOnSaveInstanceState(r); &#125; performPauseActivityIfNeeded(r, reason); ...//回调OnActivityPausedListener，目前看来只有NFC部分有注册这个回调 ... //Android 3.0之前的特殊处理 //返回保存状态的Bundle return shouldSaveState ? r.state : null;&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123; //已暂停，直接返回 if (r.paused) &#123; // You are already paused silly... return; &#125; // Always reporting top resumed position loss when pausing an activity. If necessary, it // will be restored in performResumeActivity(). //报告resume状态变更 reportTopResumedActivityChanged(r, false /* onTop */, \"pausing\"); try &#123; r.activity.mCalled = false; //回调Activity的onPause方法 mInstrumentation.callActivityOnPause(r.activity); if (!r.activity.mCalled) &#123; //必须要调用super.onPause方法 throw new SuperNotCalledException(\"Activity \" + safeToComponentShortString(r.intent) + \" did not call through to super.onPause()\"); &#125; &#125; catch ... //设置状态 r.setState(ON_PAUSE);&#125; 这一条调用链路看下来还是很简单的，和之前我们分析过的其他生命周期调用是一个套路，这里显示调用了callActivityOnSaveInstanceState方法保存状态信息 1234567891011private void callActivityOnSaveInstanceState(ActivityClientRecord r) &#123; r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) &#123; r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); &#125;&#125; 通过Instrumentation调用Activity.performSaveInstanceState方法 1234567891011121314final void performSaveInstanceState(@NonNull Bundle outState) &#123; //分发PreSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreSaveInstanceState回调 dispatchActivityPreSaveInstanceState(outState); //回调onSaveInstanceState onSaveInstanceState(outState); //保存受管理的Dialog的状态 saveManagedDialogs(outState); //共享元素动画相关 mActivityTransitionState.saveState(outState); //保存权限请求状态 storeHasCurrentPermissionRequest(outState); //分发PostSaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostSaveInstanceState回调 dispatchActivityPostSaveInstanceState(outState);&#125; 最终回调Activity.onSaveInstanceState方法 123456789101112131415161718protected void onSaveInstanceState(@NonNull Bundle outState) &#123; //保存窗口信息 outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId); //保存Fragment状态 Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; //自动填充相关 if (mAutoFillResetNeeded) &#123; outState.putBoolean(AUTOFILL_RESET_NEEDED, true); getAutofillManager().onSaveInstanceState(outState); &#125; //分发SaveInstanceState事件，执行所有注册的ActivityLifecycleCallbacks的onActivitySaveInstanceState回调 dispatchActivitySaveInstanceState(outState);&#125; 保存状态的流程就基本完成了，我们再回过头来看onPause的触发 在上面performPauseActivityIfNeeded方法中有一行代码调用了Instrumentation.callActivityOnPause方法，通过Instrumentation调用了Activity.performPause方法 1234567891011121314151617181920final void performPause() &#123; //分发PrePaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPrePaused回调 dispatchActivityPrePaused(); mDoReportFullyDrawn = false; //FragmentManager分发pause状态 mFragments.dispatchPause(); mCalled = false; //回调onPause onPause(); mResumed = false; //Target Sdk 9以上（Android 2.3）需要保证在onPause中调用super.onPause方法 if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); &#125; //分发PostPaused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostPaused回调 dispatchActivityPostPaused();&#125; 执行onPause回调 1234567891011121314151617181920protected void onPause() &#123; //分发Paused事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPaused回调 dispatchActivityPaused(); //自动填充相关 if (mAutoFillResetNeeded) &#123; if (!mAutoFillIgnoreFirstResumePause) &#123; View focus = getCurrentFocus(); if (focus != null &amp;&amp; focus.canNotifyAutofillEnterExitEvent()) &#123; getAutofillManager().notifyViewExited(focus); &#125; &#125; else &#123; // reset after first pause() mAutoFillIgnoreFirstResumePause = false; &#125; &#125; //内容捕获服务 notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_PAUSE); //super.onPause标注为已被执行 mCalled = true;&#125; 到此为止，Activity的onPause生命周期已经基本走完了，此时我们再回到PauseActivityItem.postExecute方法中做一些善后处理 1234567891011121314public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; //mDontReport为我们之前obtain方法中传入的pauseImmediately参数，始终为false if (mDontReport) &#123; return; &#125; try &#123; // TODO(lifecycler): Use interface callback instead of AMS. //调用ATMS.activityPaused方法 ActivityTaskManager.getService().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 这里调用ATMS.activityPaused方法回到system_server进程处理Activity暂停后的事项 1234567891011public final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (mGlobalLock) &#123; //通过ActivityRecord.Token获取ActivityRecord final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r != null) &#123; r.activityPaused(false); &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; 调用ActivityRecord.activityPaused方法继续处理 123456789101112131415161718192021222324252627282930void activityPaused(boolean timeout) &#123; final ActivityStack stack = getStack(); if (stack != null) &#123; //移除超时监听 removePauseTimeout(); if (stack.mPausingActivity == this) &#123; //暂停布局工作 mAtmService.deferWindowLayout(); try &#123; stack.completePauseLocked(true /* resumeNext */, null /* resumingActivity */); &#125; finally &#123; //恢复布局工作 mAtmService.continueWindowLayout(); &#125; return; &#125; else &#123; //暂停Activity失败 if (isState(PAUSING)) &#123; setState(PAUSED, \"activityPausedLocked\"); if (finishing) &#123; completeFinishing(\"activityPausedLocked\"); &#125; &#125; &#125; &#125; //更新Activity可见性 mRootWindowContainer.ensureActivitiesVisible(null, 0, !PRESERVE_WINDOWS);&#125; 正常情况下会进入到ActivityStack.completePauseLocked方法中，但在暂停Activity失败的情况下，如果当前状态为PAUSING，则直接将其状态置为PAUSED已暂停，如果被标记为finishing，则会调用ActivityRecord.completeFinishing继续finish流程，这其实和正常情况下的调用链路差不多，具体我们往下就能看到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123; ActivityRecord prev = mPausingActivity; if (prev != null) &#123; prev.setWillCloseOrEnterPip(false); //之前的状态是否为正在停止 final boolean wasStopping = prev.isState(STOPPING); //设置状态为已暂停 prev.setState(PAUSED, \"completePausedLocked\"); if (prev.finishing) &#123; //继续finish流程 prev = prev.completeFinishing(\"completePausedLocked\"); &#125; else if (prev.hasProcess()) &#123; //Configuration发生变化时可能会设置这个flag if (prev.deferRelaunchUntilPaused) &#123; // Complete the deferred relaunch that was waiting for pause to complete. //等待暂停完成后relaunch Activity prev.relaunchActivityLocked(prev.preserveWindowOnDeferredRelaunch); &#125; else if (wasStopping) &#123; // We are also stopping, the stop request must have gone soon after the pause. // We can't clobber it, because the stop confirmation will not be handled. // We don't need to schedule another stop, we only need to let it happen. //之前的状态为正在停止，将状态置回即可 prev.setState(STOPPING, \"completePausedLocked\"); &#125; else if (!prev.mVisibleRequested || shouldSleepOrShutDownActivities()) &#123; // Clear out any deferred client hide we might currently have. prev.setDeferHidingClient(false); // If we were visible then resumeTopActivities will release resources before // stopping. //添加到stop列表中等待空闲时执行stop prev.addToStopping(true /* scheduleIdle */, false /* idleDelayed */, \"completePauseLocked\"); &#125; &#125; else &#123; //App在pause过程中死亡 prev = null; &#125; // It is possible the activity was freezing the screen before it was paused. // In that case go ahead and remove the freeze this activity has on the screen // since it is no longer visible. if (prev != null) &#123; //停止屏幕冻结 prev.stopFreezingScreenLocked(true /*force*/); &#125; //Activity暂停完毕 mPausingActivity = null; &#125; //恢复前一个顶层Activity if (resumeNext) &#123; final ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack(); if (topStack != null &amp;&amp; !topStack.shouldSleepOrShutDownActivities()) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(topStack, prev, null); &#125; else &#123; checkReadyForSleep(); final ActivityRecord top = topStack != null ? topStack.topRunningActivity() : null; if (top == null || (prev != null &amp;&amp; top != prev)) &#123; // If there are no more activities available to run, do resume anyway to start // something. Also if the top activity on the stack is not the just paused // activity, we need to go ahead and resume it to ensure we complete an // in-flight app switch. mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; &#125; &#125; if (prev != null) &#123; //恢复按键分发 prev.resumeKeyDispatchingLocked(); ... //更新统计信息 &#125; //更新Activity可见性 mRootWindowContainer.ensureActivitiesVisible(resuming, 0, !PRESERVE_WINDOWS); // Notify when the task stack has changed, but only if visibilities changed (not just // focus). Also if there is an active pinned stack - we always want to notify it about // task stack changes, because its positioning may depend on it. //通知Task状态发生变化 if (mStackSupervisor.mAppVisibilitiesChangedSinceLastPause || (getDisplayArea() != null &amp;&amp; getDisplayArea().hasPinnedTask())) &#123; mAtmService.getTaskChangeNotificationController().notifyTaskStackChanged(); mStackSupervisor.mAppVisibilitiesChangedSinceLastPause = false; &#125;&#125; 可以看到，无论暂停成功与否，最后都会走到ActivityRecord.completeFinishing方法中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Complete activity finish request that was initiated earlier. If the activity is still * pausing we will wait for it to complete its transition. If the activity that should appear in * place of this one is not visible yet - we'll wait for it first. Otherwise - activity can be * destroyed right away. * @param reason Reason for finishing the activity. * @return Flag indicating whether the activity was removed from history. */ActivityRecord completeFinishing(String reason) &#123; ... //状态检查 final boolean isCurrentVisible = mVisibleRequested || isState(PAUSED); if (isCurrentVisible) &#123; ... //更新Activity可见性 &#125; boolean activityRemoved = false; // If this activity is currently visible, and the resumed activity is not yet visible, then // hold off on finishing until the resumed one becomes visible. // The activity that we are finishing may be over the lock screen. In this case, we do not // want to consider activities that cannot be shown on the lock screen as running and should // proceed with finishing the activity if there is no valid next top running activity. // Note that if this finishing activity is floating task, we don't need to wait the // next activity resume and can destroy it directly. // TODO(b/137329632): find the next activity directly underneath this one, not just anywhere final ActivityRecord next = getDisplayArea().topRunningActivity( true /* considerKeyguardState */); // isNextNotYetVisible is to check if the next activity is invisible, or it has been // requested to be invisible but its windows haven't reported as invisible. If so, it // implied that the current finishing activity should be added into stopping list rather // than destroy immediately. final boolean isNextNotYetVisible = next != null &amp;&amp; (!next.nowVisible || !next.mVisibleRequested); //如果此Activity当前可见，而要恢复的Activity还不可见，则推迟finish，直到要恢复的Activity可见为止 if (isCurrentVisible &amp;&amp; isNextNotYetVisible) &#123; // Add this activity to the list of stopping activities. It will be processed and // destroyed when the next activity reports idle. //添加到stop列表中等待空闲时执行stop addToStopping(false /* scheduleIdle */, false /* idleDelayed */, \"completeFinishing\"); //设置状态为stop中 setState(STOPPING, \"completeFinishing\"); &#125; else if (addToFinishingAndWaitForIdle()) &#123; // We added this activity to the finishing list and something else is becoming resumed. // The activity will complete finishing when the next activity reports idle. No need to // do anything else here. //将此Activity添加到待finish列表中，等待空闲时执行finish &#125; else &#123; // Not waiting for the next one to become visible, and nothing else will be resumed in // place of this activity - requesting destruction right away. //立刻销毁此Activity activityRemoved = destroyIfPossible(reason); &#125; return activityRemoved ? null : this;&#125; 对于非锁屏状态且当前要销毁的Activity在前台的情况下，该Activity可见而待恢复的Activity尚不可见，此时优先完成待恢复Activity的resume生命周期，等到之后空闲再去处理待销毁Activity的destroy生命周期 所以在面试中常问的Activity从B返回到A的生命周期顺序我们从这里就可以看出来，理解后我们就不用去死记硬背了： B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory 对于锁屏状态或者要销毁的Activity不在前台的情况下，由于不需要立刻恢复Activity，所以可能会直接处理待销毁Activity的destroy生命周期 我们以第一种当前要销毁的Activity在前台的情况分析，此时会将这个Activity添加到stop列表中，并将状态设置为STOPPING，之后返回到ActivityStack.completePauseLocked方法中，继续执行resumeNext工作 在resumeNext中会调用RootWindowContainer.resumeFocusedStacksTopActivities方法恢复栈顶Activity，由于这个方法之前已经在Android源码分析 - Activity启动流程（上） 中分析过了，这里就不再赘述了，我们还是将目光放在销毁流程上 通过之前的文章，我们知道恢复Activity会调用到ActivityThread.handleResumeActivity方法，而当Activity恢复完毕后，此方法最后一行会向MessageQueue添加一个IdleHandler，关于IdleHandler这里就不再介绍了，这是每位Android开发都应该了解的东西 1234567public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; ... r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler());&#125; 这里的Idler是ActivityThread的一个内部类 12345678910111213141516171819202122232425262728private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; ... if (a != null) &#123; mNewActivities = null; IActivityTaskManager am = ActivityTaskManager.getService(); ActivityClientRecord prev; //遍历整条ActivityClientRecord.nextIdle链，依次调用ATMS.activityIdle do &#123; if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; ... return false; &#125;&#125; 这里会遍历整个进程内所有的ActivityClientRecord，并依次调用ATMS.activityIdle方法 12345678910public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; ... final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r == null) &#123; return; &#125; mStackSupervisor.activityIdleInternal(r, false /* fromTimeout */, false /* processPausingActivities */, config); ...&#125; 从ActivityRecord.Token获取到ActivityRecord，接着调用ActivityStackSupervisor.activityIdleInternal方法 1234567void activityIdleInternal(ActivityRecord r, boolean fromTimeout, boolean processPausingActivities, Configuration config) &#123; ... // Atomically retrieve all of the other things to do. processStoppingAndFinishingActivities(r, processPausingActivities, \"idle\"); ...&#125; 这里我们只需要重点关注processStoppingAndFinishingActivities这一个方法，从方法名我们也能看出来，它是用来处理Activity stop或destroy的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Processes the activities to be stopped or destroyed. This should be called when the resumed * activities are idle or drawn. */private void processStoppingAndFinishingActivities(ActivityRecord launchedActivity, boolean processPausingActivities, String reason) &#123; // Stop any activities that are scheduled to do so but have been waiting for the transition // animation to finish. ArrayList&lt;ActivityRecord&gt; readyToStopActivities = null; for (int i = mStoppingActivities.size() - 1; i &gt;= 0; --i) &#123; final ActivityRecord s = mStoppingActivities.get(i); final boolean animating = s.isAnimating(TRANSITION | PARENTS, ANIMATION_TYPE_APP_TRANSITION | ANIMATION_TYPE_RECENTS); //不在动画中或者ATMS服务正在关闭 if (!animating || mService.mShuttingDown) &#123; //跳过正在pause的Activitiy if (!processPausingActivities &amp;&amp; s.isState(PAUSING)) &#123; // Defer processing pausing activities in this iteration and reschedule // a delayed idle to reprocess it again removeIdleTimeoutForActivity(launchedActivity); scheduleIdleTimeout(launchedActivity); continue; &#125; if (readyToStopActivities == null) &#123; readyToStopActivities = new ArrayList&lt;&gt;(); &#125; //将准备好stop的Activitiy加入列表中 readyToStopActivities.add(s); mStoppingActivities.remove(i); &#125; &#125; final int numReadyStops = readyToStopActivities == null ? 0 : readyToStopActivities.size(); for (int i = 0; i &lt; numReadyStops; i++) &#123; final ActivityRecord r = readyToStopActivities.get(i); //Activity是否在任务栈中 if (r.isInHistory()) &#123; if (r.finishing) &#123; // TODO(b/137329632): Wait for idle of the right activity, not just any. //被标记为finishing，尝试销毁Activity r.destroyIfPossible(reason); &#125; else &#123; //否则仅仅只是stop Activity r.stopIfPossible(); &#125; &#125; &#125; final int numFinishingActivities = mFinishingActivities.size(); if (numFinishingActivities == 0) &#123; return; &#125; // Finish any activities that are scheduled to do so but have been waiting for the next one // to start. final ArrayList&lt;ActivityRecord&gt; finishingActivities = new ArrayList&lt;&gt;(mFinishingActivities); mFinishingActivities.clear(); for (int i = 0; i &lt; numFinishingActivities; i++) &#123; final ActivityRecord r = finishingActivities.get(i); if (r.isInHistory()) &#123; //立刻执行Activity的销毁流程 r.destroyImmediately(true /* removeFromApp */, \"finish-\" + reason); &#125; &#125;&#125; 对于被标记为finishing的Activity，调用destroyIfPossible方法销毁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Destroy and cleanup the activity both on client and server if possible. If activity is the * last one left on display with home stack and there is no other running activity - delay * destroying it until the next one starts. */boolean destroyIfPossible(String reason) &#123; //设置状态 setState(FINISHING, \"destroyIfPossible\"); // Make sure the record is cleaned out of other places. //确保此Activity已从待stop列表中移除 mStackSupervisor.mStoppingActivities.remove(this); final ActivityStack stack = getRootTask(); final TaskDisplayArea taskDisplayArea = getDisplayArea(); final ActivityRecord next = taskDisplayArea.topRunningActivity(); final boolean isLastStackOverEmptyHome = next == null &amp;&amp; stack.isFocusedStackOnDisplay() &amp;&amp; taskDisplayArea.getOrCreateRootHomeTask() != null; if (isLastStackOverEmptyHome) &#123; // Don't destroy activity immediately if this is the last activity on the display and // the display contains home stack. Although there is no next activity at the moment, // another home activity should be started later. Keep this activity alive until next // home activity is resumed. This way the user won't see a temporary black screen. //如果Home栈存在且这是当前焦点栈中最后一个Activity，则不要立即销毁它 //将此Activity添加到待finish列表中，等待空闲时执行finish addToFinishingAndWaitForIdle(); return false; &#125; //设置finishing标记（之前设过了，这里是重复设置） makeFinishingLocked(); //立刻执行Activity的销毁流程 final boolean activityRemoved = destroyImmediately(true /* removeFromApp */, \"finish-imm:\" + reason); // If the display does not have running activity, the configuration may need to be // updated for restoring original orientation of the display. //更新可见性和屏幕显示方向 if (next == null) &#123; mRootWindowContainer.ensureVisibilityAndConfig(next, getDisplayId(), false /* markFrozenIfConfigChanged */, true /* deferResume */); &#125; //更新恢复栈顶Activity if (activityRemoved) &#123; mRootWindowContainer.resumeFocusedStacksTopActivities(); &#125; return activityRemoved;&#125; 这里做了最后的一些判断，然后调用destroyImmediately方法，立刻执行Activity的销毁流程（这里和上一个方法processStoppingAndFinishingActivities中，待finish列表的处理是一样的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Destroy the current CLIENT SIDE instance of an activity. This may be called both when * actually finishing an activity, or when performing a configuration switch where we destroy * the current client-side object but then create a new client-side object for this same * HistoryRecord. * Normally the server-side record will be removed when the client reports back after * destruction. If, however, at this point there is no client process attached, the record will * be removed immediately. * * @return &#123;@code true&#125; if activity was immediately removed from history, &#123;@code false&#125; * otherwise. */boolean destroyImmediately(boolean removeFromApp, String reason) &#123; //已经被销毁或正在被销毁，直接返回 if (isState(DESTROYING, DESTROYED)) &#123; return false; &#125; boolean removedFromHistory = false; //清理工作 cleanUp(false /* cleanServices */, false /* setState */); if (hasProcess()) &#123; //清理更新工作 if (removeFromApp) &#123; app.removeActivity(this); if (!app.hasActivities()) &#123; mAtmService.clearHeavyWeightProcessIfEquals(app); // Update any services we are bound to that might care about whether // their client may have activities. // No longer have activities, so update LRU list and oom adj. //更新进程信息 app.updateProcessInfo(true /* updateServiceConnectionActivities */, false /* activityChange */, true /* updateOomAdj */, false /* addPendingTopUid */); &#125; &#125; boolean skipDestroy = false; try &#123; //调度销毁生命周期事务 mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken, DestroyActivityItem.obtain(finishing, configChangeFlags)); &#125; catch (Exception e) &#123; // We can just ignore exceptions here... if the process has crashed, our death // notification will clean things up. if (finishing) &#123; //从历史任务中移除 removeFromHistory(reason + \" exceptionInScheduleDestroy\"); removedFromHistory = true; skipDestroy = true; &#125; &#125; nowVisible = false; // If the activity is finishing, we need to wait on removing it from the list to give it // a chance to do its cleanup. During that time it may make calls back with its token // so we need to be able to find it on the list and so we don't want to remove it from // the list yet. Otherwise, we can just immediately put it in the destroyed state since // we are not removing it from the list. if (finishing &amp;&amp; !skipDestroy) &#123; //设置状态 setState(DESTROYING, \"destroyActivityLocked. finishing and not skipping destroy\"); //设置销毁超时回调 mAtmService.mH.postDelayed(mDestroyTimeoutRunnable, DESTROY_TIMEOUT); &#125; else &#123; //设置状态 setState(DESTROYED, \"destroyActivityLocked. not finishing or skipping destroy\"); app = null; &#125; &#125; else &#123; // Remove this record from the history. if (finishing) &#123; //没有绑定进程，从历史任务中移除 removeFromHistory(reason + \" hadNoApp\"); removedFromHistory = true; &#125; else &#123; //没有绑定进程且不在finishing中，直接设置状态为已被销毁 setState(DESTROYED, \"destroyActivityLocked. not finishing and had no app\"); &#125; &#125; configChangeFlags = 0; return removedFromHistory;&#125; scheduleTransaction这个方法做了一些清理工作，重头戏在于调用了ClientLifecycleManager.scheduleTransaction方法调度销毁生命周期事务，接下来我们就重点分析这个事务的执行路径 scheduleTransaction的调用链路我们在 Android源码分析 - Activity启动流程（下） 中已经分析过了，这里我就简单的标注一下流程： ClientLifecycleManager.scheduleTransaction -&gt;ClientTransaction.schedule -&gt;ActivityThread.scheduleTransaction -&gt;ClientTransaction.preExecute -&gt;ActivityLifecycleItem.preExecute-&gt;ActivityThread.sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction) -&gt;TransactionExecutor.execute -&gt;TransactionExecutor.executeCallbacks -&gt;TransactionExecutor.executeLifecycleState -&gt;TransactionExecutor.cycleToPath -&gt;ActivityLifecycleItem.execute -&gt;ActivityLifecycleItem.postExecute 这里的链路基本上和Activity启动事务链路相差无几，甚至更短了（Activity销毁事务没有添加callback），所以没看过我上篇文章的强烈推荐去看一下，这里我就不再做分析了 我们从TransactionExecutor.cycleToPath开始，之前我们分析过，我们在事务中设置的ActivityLifecycleItem代表了Activity最终需要到达执行的生命周期，而中间的那些过渡生命周期就由cycleToPath方法推进执行，我们目前的生命周期状态为ON_PAUSE，而我们的目标生命周期为ON_DESTROY，中间还夹着一个ON_STOP，所以这个方法会帮我们执行ClientTransactionHandler.handleStopActivity方法，也就是ActivityThread.handleStopActivity方法 handleStopActivity1234567891011121314151617181920212223242526public void handleStopActivity(IBinder token, int configChanges, PendingTransactionActions pendingActions, boolean finalStateRequest /* false */, String reason) &#123; final ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; final StopInfo stopInfo = new StopInfo(); //执行onStop生命周期 performStopActivityInner(r, stopInfo, true /* saveState */, finalStateRequest, reason); //更新可见性 updateVisibility(r, false); // Make sure any pending writes are now committed. //确保所有全局任务都被处理完成 if (!r.isPreHoneycomb()) &#123; QueuedWork.waitToFinish(); &#125; //记录Stop信息（不过在后续销毁链路中似乎并没有被用到） stopInfo.setActivity(r); stopInfo.setState(r.state); stopInfo.setPersistentState(r.persistentState); pendingActions.setStopInfo(stopInfo); mSomeActivitiesChanged = true;&#125; 接下来的路径就和其他生命周期差不多了，大部分内容我都用注释标注了，大家顺着往下看就行了 123456789101112131415161718192021222324/** * Core implementation of stopping an activity. * @param r Target activity client record. * @param info Action that will report activity stop to server. * @param saveState Flag indicating whether the activity state should be saved. * @param finalStateRequest Flag indicating if this call is handling final lifecycle state * request for a transaction. * @param reason Reason for performing this operation. */private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean saveState, boolean finalStateRequest /* false */, String reason) &#123; if (r != null) &#123; ... //异常状态处理 // One must first be paused before stopped... //如果没有被暂停则先执行pause生命周期 performPauseActivityIfNeeded(r, reason); ... //设置描述（Activity.onCreateDescription） //回调Activity的onStop方法 callActivityOnStop(r, saveState, reason); &#125;&#125; 123456789101112131415161718192021222324252627282930313233/** * Calls &#123;@link Activity#onStop()&#125; and &#123;@link Activity#onSaveInstanceState(Bundle)&#125;, and updates * the client record's state. * All calls to stop an activity must be done through this method to make sure that * &#123;@link Activity#onSaveInstanceState(Bundle)&#125; is also executed in the same call. */private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) &#123; // Before P onSaveInstanceState was called before onStop, starting with P it's // called after. Before Honeycomb state was always saved before onPause. //这里shouldSaveState为true，因为activity.mFinished早在performPauseActivity的时候就被设为了true final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null &amp;&amp; !r.isPreHoneycomb(); //targetSdkVersion为Android P (Android 9)之前 final boolean isPreP = r.isPreP(); if (shouldSaveState &amp;&amp; isPreP) &#123; callActivityOnSaveInstanceState(r); &#125; try &#123; //执行stop生命周期 r.activity.performStop(r.mPreserveWindow, reason); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; //设置生命周期状态 r.setState(ON_STOP); if (shouldSaveState &amp;&amp; !isPreP) &#123; callActivityOnSaveInstanceState(r); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final void performStop(boolean preserveWindow, String reason) &#123; mDoReportFullyDrawn = false; //Loader相关，详见https://developer.android.com/guide/components/loaders mFragments.doLoaderStop(mChangingConfigurations /*retain*/); // Disallow entering picture-in-picture after the activity has been stopped //stop后禁用画中画 mCanEnterPictureInPicture = false; if (!mStopped) &#123; //分发PreStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreStopped回调 dispatchActivityPreStopped(); //关闭所有子窗口 if (mWindow != null) &#123; mWindow.closeAllPanels(); &#125; // If we're preserving the window, don't setStoppedState to true, since we // need the window started immediately again. Stopping the window will // destroys hardware resources and causes flicker. if (!preserveWindow &amp;&amp; mToken != null &amp;&amp; mParent == null) &#123; //设置停止状态，释放硬件资源，销毁Surface WindowManagerGlobal.getInstance().setStoppedState(mToken, true); &#125; //FragmentManager分发stop状态 mFragments.dispatchStop(); mCalled = false; //执行onStop回调 mInstrumentation.callActivityOnStop(this); EventLogTags.writeWmOnStopCalled(mIdent, getComponentName().getClassName(), reason); if (!mCalled) &#123; //必须要调用super.onStop方法 throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onStop()\"); &#125; //释放Cursors synchronized (mManagedCursors) &#123; final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) &#123; ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) &#123; mc.mCursor.deactivate(); mc.mReleased = true; &#125; &#125; &#125; mStopped = true; //分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调 dispatchActivityPostStopped(); &#125; mResumed = false;&#125; 通过Instrumentation执行onStop回调 123456789101112131415protected void onStop() &#123; //ActionBar动画 if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(false); //共享元素动画 mActivityTransitionState.onStop(); //分发PostStopped事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostStopped回调 dispatchActivityStopped(); mTranslucentCallback = null; //super.onStop标注为已被执行 mCalled = true; ... //自动填充相关 mEnterAnimationComplete = false;&#125; 这样，一整个onStop生命周期就执行完成了，最后还剩下个onDestroy，根据之前写的事务调度链路，现在应该走到了DestroyActivityItem.execute方法 12345public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.handleDestroyActivity(token, mFinished, mConfigChanges, false /* getNonConfigInstance */, \"DestroyActivityItem\");&#125; 可以看到，实际上就直接调用了ActivityThread.handleDestroyActivity方法 handleDestroyActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; //执行onDestroy生命周期 ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance, reason); if (r != null) &#123; //清理之前设置的延时移除的window cleanUpPendingRemoveWindows(r, finishing); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) &#123; if (r.activity.mVisibleFromServer) &#123; mNumVisibleActivities--; &#125; IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) &#123; if (r.mPreserveWindow) &#123; // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = r.window; r.mPendingRemoveWindowManager = wm; // We can only keep the part of the view hierarchy that we control, // everything else must be removed, because it might not be able to // behave properly when activity is relaunching. //从DecorView中移除ContentView r.window.clearContentView(); &#125; else &#123; //立刻执行View的移除操作，释放硬件资源，销毁Surface，回调View.onDetachedFromWindow wm.removeViewImmediate(v); &#125; &#125; if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) &#123; //移除指定Window下的所有rootView WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), \"Activity\"); &#125; else if (r.mPendingRemoveWindow != null) &#123; // We're preserving only one window, others should be closed so app views // will be detached before the final tear down. It should be done now because // some components (e.g. WebView) rely on detach callbacks to perform receiver // unregister and other cleanup. //移除指定Window下除了当前DecorView以外的所有rootView WindowManagerGlobal.getInstance().closeAllExceptView(token, v, r.activity.getClass().getName(), \"Activity\"); &#125; r.activity.mDecor = null; &#125; if (r.mPendingRemoveWindow == null) &#123; // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), \"Activity\"); &#125; // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. //清理Context Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) &#123; ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), \"Activity\"); &#125; &#125; if (finishing) &#123; try &#123; //处理一些销毁后的事项，移除超时回调等 ActivityTaskManager.getService().activityDestroyed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true;&#125; Window这块的处理我目前也不太了解，等以后我学习了WMS那块再补吧 其他的和之前的套路一样，调用performDestroyActivity方法执行销毁Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** Core implementation of activity destroy call. */ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) &#123; ActivityClientRecord r = mActivities.get(token); Class&lt;? extends Activity&gt; activityClass = null; if (r != null) &#123; activityClass = r.activity.getClass(); r.activity.mConfigChangeFlags |= configChanges; if (finishing) &#123; r.activity.mFinished = true; &#125; //如果没有被暂停则先执行pause生命周期 performPauseActivityIfNeeded(r, \"destroy\"); //如果没有被停职则先执行stop生命周期 if (!r.stopped) &#123; callActivityOnStop(r, false /* saveState */, \"destroy\"); &#125; if (getNonConfigInstance) &#123; ... //getNonConfigInstance为false，这里不执行 &#125; try &#123; r.activity.mCalled = false; //执行onDestroy回调 mInstrumentation.callActivityOnDestroy(r.activity); //必须要调用super.onDestroy方法 if (!r.activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + safeToComponentShortString(r.intent) + \" did not call through to super.onDestroy()\"); &#125; //关闭所有子窗口 if (r.window != null) &#123; r.window.closeAllPanels(); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; //设置生命周期状态 r.setState(ON_DESTROY); &#125; //空闲时清理资源 schedulePurgeIdler(); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. synchronized (mResourcesManager) &#123; mActivities.remove(token); &#125; //严格模式更新Activity计数器，与实际Activity数量对比，判断是否产生内存泄漏 StrictMode.decrementExpectedActivityCount(activityClass); return r;&#125; 通过Instrumentation调用Activity.performDestroy方法 12345678910111213141516final void performDestroy() &#123; //分发PreDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreDestroyed回调 dispatchActivityPreDestroyed(); mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); EventLogTags.writeWmOnDestroyCalled(mIdent, getComponentName().getClassName(), \"performDestroy\"); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) &#123; mVoiceInteractor.detachActivity(); &#125; //分发PostDestroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostDestroyed回调 dispatchActivityPostDestroyed();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected void onDestroy() &#123; //super.onDestroy标注为已被执行 mCalled = true; ... //自动填充相关 // dismiss any dialogs we are managing. //关闭所有被管理的Dialog if (mManagedDialogs != null) &#123; final int numDialogs = mManagedDialogs.size(); for (int i = 0; i &lt; numDialogs; i++) &#123; final ManagedDialog md = mManagedDialogs.valueAt(i); if (md.mDialog.isShowing()) &#123; md.mDialog.dismiss(); &#125; &#125; mManagedDialogs = null; &#125; // close any cursors we are managing. //关闭所有被管理的Cursor synchronized (mManagedCursors) &#123; int numCursors = mManagedCursors.size(); for (int i = 0; i &lt; numCursors; i++) &#123; ManagedCursor c = mManagedCursors.get(i); if (c != null) &#123; c.mCursor.close(); &#125; &#125; mManagedCursors.clear(); &#125; // Close any open search dialog //关闭系统搜索服务的弹窗 if (mSearchManager != null) &#123; mSearchManager.stopSearch(); &#125; if (mActionBar != null) &#123; mActionBar.onDestroy(); &#125; //分发Destroyed事件，执行所有注册的ActivityLifecycleCallbacks的onActivityDestroyed回调 dispatchActivityDestroyed(); //内容捕获服务 notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_STOP);&#125; DestroyActivityItem没有重写postExecute方法，所以到此为止，Activity整个销毁流程就结束了 Tips我们通过本篇文章的分析，可以发现，触发Activity销毁后，onStop和onDestroy这两个生命周期回调的触发时机是不确定的，如果有需求需要在确定Activity要被销毁后立刻执行，我们可以在onPause回调中调用Activity.isFinishing方法判断mFinished标志是否被置true，如果为true则可以判定这个Activity将被销毁 结尾至此，Activity的启动流程和销毁流程我们都分析完了，后面应该暂时不会再写Activity相关的源码分析了 之后的一段时间，我可能会将我的精力投入到AIGC的技术调研中，Android源码分析这一系列的后续更新可能会放慢，希望大家多多谅解","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"Android/ActivityTaskManagerService","permalink":"http://yoursite.com/categories/Android/ActivityTaskManagerService/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"ActivityTaskManagerService","permalink":"http://yoursite.com/tags/ActivityTaskManagerService/"}]},{"title":"WSL编译AOSP必要的几个前置工作","slug":"android/aosp/WSL编译AOSP必要的几个前置工作","date":"2023-02-06T03:13:31.000Z","updated":"2023-06-19T14:07:02.874Z","comments":true,"path":"2023/02/06/android/aosp/WSL编译AOSP必要的几个前置工作/","link":"","permalink":"http://yoursite.com/2023/02/06/android/aosp/WSL%E7%BC%96%E8%AF%91AOSP%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%89%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C/","excerpt":"","text":"前言首先，关于AOSP的编译可以查看我的这篇文章：AOSP的编译及刷机 我之前都是在MacOS上构建的AOSP的，但是自2021年6月22日起，AOSP不再支持在Windows或MacOS上构建，但我又不想给我的电脑安装Ubuntu双系统，只得另寻他路，在Windows上使用WSL就是一个很好的选择。 其实之前我尝试过用WSL编译AOSP，但几次都失败了，这次过年回家潜心研究了几天，总算是成功了，我会将我之前失败的原因和这次成功的心得总结分享给大家，教大家如何避坑 关于NAS我是将我的AOSP源码放在NAS上进行编译的，毕竟磁盘空间够大，而且共享起来也方便，但需要千万注意 不要使用SMB协议共享AOSP源码编译，这样做直接就会卡在源码sync完后的lunch那一步，可以使用iSCSI协议将NAS上的一部分磁盘空间映射成一个虚拟磁盘，这样在Windows上就可以将这块磁盘当成普通的硬盘使用，几乎完全没有区别 修改大小写敏感在同步AOSP源码前一定要做的工作，不然你就等着把辛苦下载好的源码删了重新下吧 在同步AOSP源码之前，我们会首先创建一个新的目录用来保存它，我们新建完这个目录后，用管理员身份打开Windows的Powershell，执行以下命令： 1fsutil.exe file setCaseSensitiveInfo &lt;path&gt; enable 其中的path就是刚新建用来同步AOSP源码的目录，需要注意的是，这个命令只对指定的目录有效，不会改变已存在的子目录的大小写敏感，所以千万要在同步代码之前做这件事 重新挂载磁盘如果你的AOSP源码放在了Windows驱动器上，比如说 F:\\aosp ，在WSL中的路径应该是 /mnt/f/aosp 这种形式的，此时需要以drvfs文件系统重新挂载盘符，否则编译到中途会报错： 12sudo umount /mnt/fsudo mount -t drvfs F: /mnt/f -o metadata 注意，每次WSL重启，在编译AOSP之前都需要执行这步操作，当然你也可以将它新建成WSL的一个开机服务，确保每次打开WSL都会执行这两段命令 尾声可以发现，用WSL编译出错主要还是文件系统的问题，经过以上几步前置工作，相信你一定可以顺利的编译AOSP","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"}]},{"title":"史上最完美的Android沉浸式状态导航栏攻略","slug":"android/common/史上最完美的Android沉浸式状态导航栏攻略","date":"2023-01-07T12:51:52.000Z","updated":"2023-04-23T13:51:43.890Z","comments":true,"path":"2023/01/07/android/common/史上最完美的Android沉浸式状态导航栏攻略/","link":"","permalink":"http://yoursite.com/2023/01/07/android/common/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5/","excerpt":"","text":"前言最近我在小破站开发一款新App，叫高能链。我是一个完美主义者，所以不管对架构还是UI，我都是比较抠细节的，在状态栏和导航栏沉浸式这一块，我还是踩了挺多坑，费了挺多精力的。这次我将我踩坑，适配各机型总结出来的史上最完美的Android沉浸式状态导航栏攻略分享给大家，大家也可以去 高能链官网 下载体验一下我们的App，实际感受一下沉浸式状态导航栏的效果（登录，实名等账号相关页面由于不是我开发的，就没有适配沉浸式导航栏啦，嘻嘻） 注：此攻略只针对 Android 5.0 及以上机型，即 minSdkVersion &gt;= 21 实际效果在开始攻略之前，我们先看看完美的沉浸式状态导航栏效果 传统三键式导航栏 全面屏导航条 理论分析在上具体实现代码之前，我们先分析一下，实现沉浸式状态导航栏需要几步 状态栏导航栏底色透明 根据当前页面的背景色，给状态栏字体和导航栏按钮（或导航条）设置亮色或暗色 状态栏导航栏设置透明后，我们页面的布局会延伸到原本状态栏导航栏的位置，这时候需要一些手段将我们需要显示的正文内容回缩到其正确的显示范围内 这里我给大家提供以下几种思路，大家可以根据实际情况自行选择： 设置fitsSystemWindows属性 根据状态栏导航栏的高度，给根布局设置相应的paddingTop和paddingBottom 根据状态栏导航栏的高度，给需要移位的控件设置相应的marginTop和marginBottom 在顶部和底部增加两个占位的View，高度分别设置成状态栏和导航栏的高度 针对滑动视图，巧用clipChildren和clipToPadding属性（可参照高能链藏品详情页样式） 沉浸式状态栏思路说完了，我们现在开始进入实战，沉浸式状态栏比较简单，没什么坑 状态栏透明首先第一步，我们需要将状态栏的背景设置为透明，这里我直接放代码 123456789101112fun transparentStatusBar(window: Window) &#123; window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE window.decorView.systemUiVisibility = systemUiVisibility window.statusBarColor = Color.TRANSPARENT //设置状态栏文字颜色 setStatusBarTextColor(window, NightMode.isNightMode(window.context))&#125; 首先，我们需要将FLAG_TRANSLUCENT_STATUS这个windowFlag换成FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，否则状态栏不会完全透明，会有一个半透明的灰色蒙层 FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS这个flag表示系统Bar的背景将交给当前window绘制 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN这个flag表示Activity全屏显示，但状态栏不会被隐藏，依然可见 SYSTEM_UI_FLAG_LAYOUT_STABLE这个flag表示保持整个View稳定，使View不会因为系统UI的变化而重新layout SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE这两个flag通常是一起使用的，我们设置这两个flag，然后再将statusBarColor设置为透明，就达成了状态栏背景透明的效果 状态栏文字颜色接着我们就该设置状态栏文字颜色了，细心的小伙伴们应该已经注意到了，我在transparentStatusBar方法的末尾加了一个setStatusBarTextColor的方法调用，一般情况下，如果是日间模式，页面背景通常都是亮色，所以此时状态栏文字颜色设置为黑色比较合理，而在夜间模式下，页面背景通常都是暗色，此时状态栏文字颜色设置为白色比较合理，对应代码如下 1234567891011fun setStatusBarTextColor(window: Window, light: Boolean) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = if (light) &#123; //白色文字 systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() &#125; else &#123; //黑色文字 systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR &#125; window.decorView.systemUiVisibility = systemUiVisibility &#125;&#125; Android 8.0以上才支持导航栏文字颜色的修改，SYSTEM_UI_FLAG_LIGHT_STATUS_BAR这个flag表示亮色状态栏，即黑色状态栏文字，所以如果希望状态栏文字为黑色，就设置这个flag，如果希望状态栏文字为白色，就将这个flag从systemUiVisibility中剔除 可能有小伙伴不太了解kotlin中的位运算，kotlin中的or、and、inv分别对应着或、与、取反运算 所以 1systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv() 翻译成java即为 1systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR 在原生系统上，这么设置就可以成功设置状态栏文字颜色，但我发现，在某些系统上，这样设置后的效果是不可预期的，譬如MIUI系统的状态栏文字颜色似乎是根据状态栏背景颜色自适应的，且日间模式和黑夜模式下的自适应策略还略有不同。不过在大多数情况下，它自适应的颜色都是正常的，我们就按照我们希望的结果设置就可以了。 矫正显示区域fitsSystemWindows矫正状态栏显示区域最简单的办法就是设置fitsSystemWindows属性，设置了该属性的View的所有padding属性都将失效，并且系统会自动为其添加paddingTop（设置了透明状态栏的情况下）和paddingBottom（设置了透明导航栏的情况下） 我个人是不用这种方式的，首先它会覆盖你设置的padding，其次，如果你同时设置了透明状态栏和透明导航栏，这个属性没有办法分开来处理，很不灵活 获取状态栏高度除了fitsSystemWindows这种方法外，其他的方法都得依靠获取状态栏高度了，这里直接上代码 123456fun getStatusBarHeight(context: Context): Int &#123; val resId = context.resources.getIdentifier( \"status_bar_height\", \"dimen\", \"android\" ) return context.resources.getDimensionPixelSize(resId)&#125; 状态栏不像导航栏那样多变，所以直接这样获取高度就可以了，导航栏的高度飘忽不定才是真正的噩梦 这里再给两个设置View margin或padding的工具方法吧，帮助大家快速使用 1234567891011121314151617fun fixStatusBarMargin(vararg views: View) &#123; views.forEach &#123; view -&gt; (view.layoutParams as? ViewGroup.MarginLayoutParams)?.let &#123; lp -&gt; lp.topMargin = lp.topMargin + getStatusBarHeight(view.context) view.requestLayout() &#125; &#125;&#125;fun paddingByStatusBar(view: View) &#123; view.setPadding( view.paddingLeft, view.paddingTop + getStatusBarHeight(view.context), view.paddingRight, view.paddingBottom )&#125; 沉浸式导航栏沉浸式导航栏相比沉浸式状态栏坑会多很多，具体原因我们后面再说 导航栏透明和沉浸式状态栏一样，第一步我们需要将导航栏的背景设置为透明 123456789101112131415fun transparentNavigationBar(window: Window) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123; window.isNavigationBarContrastEnforced = false &#125; window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION window.decorView.systemUiVisibility = systemUiVisibility window.navigationBarColor = Color.TRANSPARENT //设置导航栏按钮或导航条颜色 setNavigationBarBtnColor(window, NightMode.isNightMode(window.context))&#125; 在Android 10以上，当设置了导航栏栏背景为透明时，isNavigationBarContrastEnforced如果为true，则系统会自动绘制一个半透明背景来提供对比度，所以我们要将这个属性设为false ps：状态栏其实也有对应的属性isStatusBarContrastEnforced，只不过这个属性默认即为false，我们不需要特意去设置 导航栏按钮或导航条颜色和设置状态栏文字颜色一样，我这里就不多介绍了 1234567891011fun setNavigationBarBtnColor(window: Window, light: Boolean) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; var systemUiVisibility = window.decorView.systemUiVisibility systemUiVisibility = if (light) &#123; //白色按钮 systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR.inv() &#125; else &#123; //黑色按钮 systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR &#125; window.decorView.systemUiVisibility = systemUiVisibility &#125;&#125; 矫正显示区域fitsSystemWindows和状态栏使用一样，我就不重复说明了 获取导航栏高度自从全面屏手势开始流行，导航栏也从原先的三键式，变成了三键式、导航条、全隐藏这三种情况，这三种情况下的高度也是互不相同的 三键式和导航条这两种情况我们都可以通过android.R.dimen.navigation_bar_height这个资源获取到准确高度，但现在很多系统都支持隐藏导航栏的功能，在这种情况下，虽然实际导航栏的高度应该是0，但是通过资源获取到的高度却为三键式或导航条的高度，这就给我们沉浸式导航栏的适配带来了很大困难 经过我的各种尝试，我发现只有一种方式可以准确的获取到当前导航栏的高度，那就是WindowInsets，至于WindowInsets是什么我就不多介绍了，我们直接看代码 123456789/*** 仅当view attach window后生效*/private fun getRealNavigationBarHeight(view: View): Int &#123; val insets = ViewCompat.getRootWindowInsets(view) ?.getInsets(WindowInsetsCompat.Type.navigationBars()) //WindowInsets为null则默认通过资源获取高度 return insets?.bottom ?: getNavigationBarHeight(view.context)&#125; 这里需要注意到我在方法上写的注释，只有当View和Window attach 后，才能获得到WindowInsets，否则为null，所以我一开始的想法是先检查View是否 attach 了Window，如果有的话则直接调用getRealNavigationBarHeight方法，如果没有的话，调用View.addOnAttachStateChangeListener方法，当出发attach回调后，再调用getRealNavigationBarHeight方法获取高度 这种方式在大部分情况下运行良好，但在我一次无意中切换了系统夜间模式后发现，获取到的导航栏高度变成了0，并且这还是一个偶现的问题，于是我尝试使用View.setOnApplyWindowInsetsListener，监听WindowInsets的变化发现，这个回调有可能会触发多次，在触发多次的情况下，前几次的值都为0，只有最后一次的值为真正的导航栏高度 于是我准备用View.setOnApplyWindowInsetsListener代替View.addOnAttachStateChangeListener，但毕竟一个是setListener，一个是addListener，setListener有可能会把之前设置好的Listener覆盖，或者被别的Listener覆盖掉，再考虑到之后会提到的底部Dialog沉浸式导航栏适配的问题，我折中了一下，决定只对Activity下的rootView设置回调 以下是完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117private class NavigationViewInfo( val hostRef: WeakReference&lt;View&gt;, val viewRef: WeakReference&lt;View&gt;, val rawBottom: Int, val onNavHeightChangeListener: (View, Int, Int) -&gt; Unit)private val navigationViewInfoList = mutableListOf&lt;NavigationViewInfo&gt;()private val onApplyWindowInsetsListener = View.OnApplyWindowInsetsListener &#123; v, insets -&gt; val windowInsetsCompat = WindowInsetsCompat.toWindowInsetsCompat(insets, v) val navHeight = windowInsetsCompat.getInsets(WindowInsetsCompat.Type.navigationBars()).bottom val it = navigationViewInfoList.iterator() while (it.hasNext()) &#123; val info = it.next() val host = info.hostRef.get() val view = info.viewRef.get() if (host == null || view == null) &#123; it.remove() continue &#125; if (host == v) &#123; info.onNavHeightChangeListener(view, info.rawBottom, navHeight) &#125; &#125; insets&#125;private val actionMarginNavigation: (View, Int, Int) -&gt; Unit = &#123; view, rawBottomMargin, navHeight -&gt; (view.layoutParams as? ViewGroup.MarginLayoutParams)?.let &#123; it.bottomMargin = rawBottomMargin + navHeight view.requestLayout() &#125; &#125;private val actionPaddingNavigation: (View, Int, Int) -&gt; Unit = &#123; view, rawBottomPadding, navHeight -&gt; view.setPadding( view.paddingLeft, view.paddingTop, view.paddingRight, rawBottomPadding + navHeight ) &#125;fun fixNavBarMargin(vararg views: View) &#123; views.forEach &#123; fixSingleNavBarMargin(it) &#125;&#125;private fun fixSingleNavBarMargin(view: View) &#123; val lp = view.layoutParams as? ViewGroup.MarginLayoutParams ?: return val rawBottomMargin = lp.bottomMargin val viewForCalculate = getViewForCalculate(view) if (viewForCalculate.isAttachedToWindow) &#123; val realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate) lp.bottomMargin = rawBottomMargin + realNavigationBarHeight view.requestLayout() &#125; //isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听 val hostRef = WeakReference(viewForCalculate) val viewRef = WeakReference(view) val info = NavigationViewInfo(hostRef, viewRef, rawBottomMargin, actionMarginNavigation) navigationViewInfoList.add(info) viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)&#125;fun paddingByNavBar(view: View) &#123; val rawBottomPadding = view.paddingBottom val viewForCalculate = getViewForCalculate(view) if (viewForCalculate.isAttachedToWindow) &#123; val realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate) view.setPadding( view.paddingLeft, view.paddingTop, view.paddingRight, rawBottomPadding + realNavigationBarHeight ) &#125; //isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听 val hostRef = WeakReference(viewForCalculate) val viewRef = WeakReference(view) val info = NavigationViewInfo(hostRef, viewRef, rawBottomPadding, actionPaddingNavigation) navigationViewInfoList.add(info) viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)&#125;/*** Dialog下的View在低版本机型中获取到的WindowInsets值有误，* 所以尝试去获得Activity的contentView，通过Activity的contentView获取WindowInsets*/@SuppressLint(\"ContextCast\")private fun getViewForCalculate(view: View): View &#123; return (view.context as? ContextWrapper)?.let &#123; return@let (it.baseContext as? Activity)?.findViewById&lt;View&gt;(android.R.id.content)?.rootView &#125; ?: view.rootView&#125;/*** 仅当view attach window后生效*/private fun getRealNavigationBarHeight(view: View): Int &#123; val insets = ViewCompat.getRootWindowInsets(view) ?.getInsets(WindowInsetsCompat.Type.navigationBars()) return insets?.bottom ?: getNavigationBarHeight(view.context)&#125; 我简单解释一下这段代码：为所有需要沉浸的页面的根View设置同一个回调，并将待适配导航栏高度的View添加到列表中，当WindowInsets回调触发后，遍历这个列表，判断触发回调的View的host是否与待适配导航栏高度的View对应，对应的话则处理View适配导航栏高度 这里需要注意，WindowInsets的分发其实是在dispatchAttachedToWindow之后的，所以isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，具体可以去看ViewRootImpl中的源码，关键方法：dispatchApplyInsets，这里判断isAttachedToWindow并设置高度是为了防止出现View已经完全布局完成，之后再也不会触发OnApplyWindowInsets的情况 这里我也测试了内存泄漏情况，确认无内存泄漏，大家可以放心食用 底部Dialog适配沉浸式底部Dialog适配沉浸式要比正常的Activity更麻烦一些，主要问题也是集中在沉浸式导航栏上 获取导航栏高度仔细的小伙伴们可以已经注意到了我在沉浸式导航栏获取高度那里代码中的注释，Dialog下的View在低版本机型（经测试，Android 9一下就会有这个问题）中获取到的WindowInsets值有误，所以尝试去获得Activity的contentView，通过Activity的contentView获取WindowInsets LayoutParams导致的异常在某些系统上（比如MIUI），当我window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)时，沉浸式会出现问题，状态栏会被蒙层盖住，Dialog底部的内容也会被一个莫名其妙的东西遮挡住 我的解决方案是，window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)，然后布局最外层全部占满，内部留一个底部容器 123456789101112131415&lt;!-- dialog_pangu_bottom_wrapper --&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/transparent\"&gt; &lt;FrameLayout android:id=\"@+id/pangu_bottom_dialog_container\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" android:clickable=\"true\" android:focusable=\"true\" /&gt;&lt;/FrameLayout&gt; 然后在代码中重写setContentView方法 123456789101112131415161718192021222324252627282930313233343536373839404142private var canceledOnTouchOutside = trueoverride fun setContentView(layoutResID: Int) &#123; setContentView( LayoutInflater.from(context).inflate(layoutResID, null, false) )&#125;override fun setContentView(view: View) &#123; setContentView( view, ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT ) )&#125;override fun setContentView(view: View, params: ViewGroup.LayoutParams?) &#123; val root = LayoutInflater.from(context).inflate(R.layout.dialog_pangu_bottom_wrapper, null, false) root.setOnClickListener &#123; if (canceledOnTouchOutside) &#123; dismiss() &#125; &#125; val container = root.findViewById&lt;ViewGroup&gt;(R.id.pangu_bottom_dialog_container) container.addView(view, params) super.setContentView( root, ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) )&#125;override fun setCanceledOnTouchOutside(cancel: Boolean) &#123; super.setCanceledOnTouchOutside(cancel) canceledOnTouchOutside = cancel&#125; 这样的话视觉效果就和普通的底部Dialog一样了，为了进一步减小底部Dialog显示隐藏动画之间的差异，我将动画插值器从linear_interpolator换成了decelerate_interpolator和accelerate_interpolator 123456&lt;!-- dialog_enter_from_bottom_to_top --&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"100%\" android:interpolator=\"@android:anim/decelerate_interpolator\" android:toYDelta=\"0\" /&gt; 123456&lt;!-- dialog_exit_from_top_to_bottom --&gt;&lt;translate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"300\" android:fromYDelta=\"0\" android:interpolator=\"@android:anim/accelerate_interpolator\" android:toYDelta=\"100%\" /&gt; 尾声自此，目前沉浸式遇到的问题全部都解决了，如果以后发现了什么新的问题，我会在这篇文章中补充说明，如果还有什么不明白的地方可以评论，我考虑要不要拿几个具体的场景实战讲解，各位看官老爷麻烦点个赞收个藏不迷路😄","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"沉浸式","slug":"Android/沉浸式","permalink":"http://yoursite.com/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"状态栏","slug":"Android/状态栏","permalink":"http://yoursite.com/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"导航栏","slug":"Android/导航栏","permalink":"http://yoursite.com/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"Android/StatusBar","permalink":"http://yoursite.com/categories/Android/StatusBar/"},{"name":"NavigationBar","slug":"Android/NavigationBar","permalink":"http://yoursite.com/categories/Android/NavigationBar/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"沉浸式","slug":"沉浸式","permalink":"http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"状态栏","slug":"状态栏","permalink":"http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"导航栏","slug":"导航栏","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://yoursite.com/tags/StatusBar/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"}]},{"title":"Android源码分析 - Activity启动流程（下）","slug":"android/aosp/Android源码分析-Activity启动流程（下）","date":"2022-12-19T13:49:36.000Z","updated":"2023-02-26T10:34:30.145Z","comments":true,"path":"2022/12/19/android/aosp/Android源码分析-Activity启动流程（下）/","link":"","permalink":"http://yoursite.com/2022/12/19/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 上一篇文章 Android源码分析 - Activity启动流程（中） 中，我们分析了App进程的启动过程，包括Application是怎么创建并执行onCreate方法的，本篇文章我们将会继续分析App进程启动、Application创建完成后，Activity是如何启动的 两种路径启动Activity我们在 Android源码分析 - Activity启动流程（上） 的末尾分析过，Activity的启动存在两条路径 启动进程，然后启动Activity这条路径就是我们在上一篇文章 Android源码分析 - Activity启动流程（中） 中分析了前半部分：启动进程 当进程启动后，会执行到AMS.attachApplicationLocked方法，在这个方法的最后，会有一段代码检查是否有Activity等待启动 123456789101112131415161718private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; ... // See if the top visible activity is waiting to run in this process... //检查是否有Activity等待启动 if (normalMode) &#123; try &#123; didSomething = mAtmInternal.attachApplication(app.getWindowProcessController()); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; ... return true;&#125; 然后调用ActivityTaskManagerInternal.attachApplication，ActivityTaskManagerInternal是一个抽象类，被ATMS的内部类LocalService实现 123456789public boolean attachApplication(WindowProcessController wpc) throws RemoteException &#123; synchronized (mGlobalLockWithoutBoost) &#123; try &#123; return mRootWindowContainer.attachApplication(wpc); &#125; finally &#123; ... &#125; &#125;&#125; 接着调用RootWindowContainer.attachApplication 12345678910111213141516171819202122232425262728293031323334boolean attachApplication(WindowProcessController app) throws RemoteException &#123; boolean didSomething = false; for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) &#123; mTmpRemoteException = null; mTmpBoolean = false; // Set to true if an activity was started. final DisplayContent display = getChildAt(displayNdx); for (int areaNdx = display.getTaskDisplayAreaCount() - 1; areaNdx &gt;= 0; --areaNdx) &#123; final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx); for (int taskNdx = taskDisplayArea.getStackCount() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx); if (rootTask.getVisibility(null /*starting*/) == STACK_VISIBILITY_INVISIBLE) &#123; break; &#125; //遍历ActivityStack下的所有ActivityRecord， //以其为参数调用startActivityForAttachedApplicationIfNeeded方法 final PooledFunction c = PooledLambda.obtainFunction( RootWindowContainer::startActivityForAttachedApplicationIfNeeded, this, PooledLambda.__(ActivityRecord.class), app, rootTask.topRunningActivity()); rootTask.forAllActivities(c); c.recycle(); if (mTmpRemoteException != null) &#123; throw mTmpRemoteException; &#125; &#125; &#125; didSomething |= mTmpBoolean; &#125; if (!didSomething) &#123; ensureActivitiesVisible(null, 0, false /* preserve_windows */); &#125; return didSomething;&#125; 这里有两层for循环，可以看出来，这个方法遍历了所有可见的ActivityStack，然后再对每个可见的ActivityStack进行操作 其中，PooledLambda这个类采用了池化技术，用于构造可回收复用的匿名函数，这里PooledLambda.obtainFunction方法得到的结果是一个Function&lt;ActivityRecord, Boolean&gt;，forAllActivities方法被定义在父类WindowContainer中，就是遍历执行所有child的forAllActivities方法，而ActivityRecord中重写了这个方法，直接用自身执行这个Function 简单来说，可以将这部分代码看作以下伪代码： 123rootTask.forEachAllActivityRecord((activityRecord) -&gt; &#123; startActivityForAttachedApplicationIfNeeded(activityRecord, app, rootTask.topRunningActivity())&#125;) 接着我们来观察startActivityForAttachedApplicationIfNeeded方法 123456789101112131415161718192021private boolean startActivityForAttachedApplicationIfNeeded(ActivityRecord r, WindowProcessController app, ActivityRecord top) &#123; //Activity是否正在finish，是否应为当前用户显示Activity，忽略锁屏情况，此Activity是否可见 //对比Activity与发起进程的uid和进程名 if (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != null || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) &#123; return false; &#125; try &#123; //启动Activity if (mStackSupervisor.realStartActivityLocked(r, app, top == r &amp;&amp; r.isFocusable() /*andResume*/, true /*checkConfig*/)) &#123; mTmpBoolean = true; &#125; &#125; catch (RemoteException e) &#123; ... return true; &#125; return false;&#125; 上面一系列的判断检查传入的ActivityRecord所对应的Activity是否需要启动，然后调用ActivityStackSupervisor.realStartActivityLocked方法启动Activity 已有进程，直接启动Activity这条路径我在 Android源码分析 - Activity启动流程（上） 中的末尾也分析过，如果App进程已经启动，则会调用ActivityStackSupervisor.startSpecificActivity方法 12345678910111213141516171819202122232425262728void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? final WindowProcessController wpc = mService.getProcessController(r.processName, r.info.applicationInfo.uid); boolean knownToBeDead = false; if (wpc != null &amp;&amp; wpc.hasThread()) &#123; try &#123; //启动Activity realStartActivityLocked(r, wpc, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. knownToBeDead = true; &#125; //锁屏状态下启动Activity防闪烁机制 r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); //出现异常，重启进程 final boolean isTop = andResume &amp;&amp; r.isTopRunningActivity(); mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? \"top-activity\" : \"activity\");&#125; 可以看到，这里也调用了ActivityStackSupervisor.realStartActivityLocked方法启动Activity realStartActivityLocked最终两条路径都走到了ActivityStackSupervisor.realStartActivityLocked方法中，那我们就来看看这个方法做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc, boolean andResume, boolean checkConfig) throws RemoteException &#123; //确保所有Activity都已暂停 if (!mRootWindowContainer.allPausedActivitiesComplete()) &#123; // While there are activities pausing we skipping starting any new activities until // pauses are complete. NOTE: that we also do this for activities that are starting in // the paused state because they will first be resumed then paused on the client side. return false; &#125; final Task task = r.getTask(); final ActivityStack stack = task.getStack(); //延迟resume以避免重复resume //通过设置标记位mDeferResumeCount，只有当其为0时才能执行resume beginDeferResume(); try &#123; //冻结屏幕（不接收输入、不执行动画，截取屏幕进行显示） r.startFreezingScreenLocked(proc, 0); // schedule launch ticks to collect information about slow apps. //收集启动缓慢信息 r.startLaunchTickingLocked(); r.setProcess(proc); // Ensure activity is allowed to be resumed after process has set. //确保Activity允许被resume if (andResume &amp;&amp; !r.canResumeByCompat()) &#123; andResume = false; &#125; //锁屏状态下启动Activity防闪烁机制 r.notifyUnknownVisibilityLaunchedForKeyguardTransition(); // Have the window manager re-evaluate the orientation of the screen based on the new // activity order. Note that as a result of this, it can call back into the activity // manager with a new orientation. We don't care about that, because the activity is // not currently running so we are just restarting it anyway. if (checkConfig) &#123; // Deferring resume here because we're going to launch new activity shortly. // We don't want to perform a redundant launch of the same record while ensuring // configurations and trying to resume top activity of focused stack. //确保所有Activity的可见性、更新屏幕方向和配置 mRootWindowContainer.ensureVisibilityAndConfig(r, r.getDisplayId(), false /* markFrozenIfConfigChanged */, true /* deferResume */); &#125; //检查Activity是否在后台锁屏状态下启动 if (r.getRootTask().checkKeyguardVisibility(r, true /* shouldBeVisible */, true /* isTop */) &amp;&amp; r.allowMoveToFront()) &#123; // We only set the visibility to true if the activity is not being launched in // background, and is allowed to be visible based on keyguard state. This avoids // setting this into motion in window manager that is later cancelled due to later // calls to ensure visible activities that set visibility back to false. //只有Activity不是在后台启动，才将其可见性设置为true r.setVisibility(true); &#125; ... //异常情况检查 r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); proc.setLastActivityLaunchTime(r.lastLaunchTime); //屏幕固定功能 final LockTaskController lockTaskController = mService.getLockTaskController(); if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED &amp;&amp; lockTaskController.getLockTaskModeState() == LOCK_TASK_MODE_LOCKED)) &#123; lockTaskController.startLockTaskMode(task, false, 0 /* blank UID */); &#125; try &#123; if (!proc.hasThread()) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; // We don't need to deliver new intents and/or set results if activity is going // to pause immediately after launch. results = r.results; newIntents = r.newIntents; &#125; //如果是ACTIVITY_TYPE_HOME类型的应用（Launcher） if (r.isActivityTypeHome()) &#123; // Home process is the root process of the task. updateHomeProcess(task.getBottomMostActivity().app); &#125; //信息记录 mService.getPackageManagerInternalLocked().notifyPackageUse( r.intent.getComponent().getPackageName(), NOTIFY_PACKAGE_USE_ACTIVITY); r.setSleeping(false); r.forceNewConfig = false; //如果有必要的话，显示一些App警告弹窗（不支持的CompileSdk、不支持的TargetSdk、不支持的显示大小） mService.getAppWarningsLocked().onStartActivity(r); //兼容性信息 r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo); // Because we could be starting an Activity in the system process this may not go // across a Binder interface which would create a new Configuration. Consequently // we have to always create a new Configuration here. final MergedConfiguration mergedConfiguration = new MergedConfiguration( proc.getConfiguration(), r.getMergedOverrideConfiguration()); r.setLastReportedConfiguration(mergedConfiguration); // Create activity launch transaction. //创建或获取一个client事务 final ClientTransaction clientTransaction = ClientTransaction.obtain( proc.getThread(), r.appToken); final DisplayContent dc = r.getDisplay().mDisplayContent; //添加一条Activity启动消息 clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent), System.identityHashCode(r), r.info, // TODO: Have this take the merged configuration instead of separate global // and override configs. mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(), results, newIntents, dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(), r.assistToken, r.createFixedRotationAdjustmentsIfNeeded())); // Set desired final state. final ActivityLifecycleItem lifecycleItem; if (andResume) &#123; lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward()); &#125; else &#123; lifecycleItem = PauseActivityItem.obtain(); &#125; //设置client执行事务后应处于的生命周期状态 clientTransaction.setLifecycleStateRequest(lifecycleItem); // Schedule transaction. //调度执行此事务，启动Activity mService.getLifecycleManager().scheduleTransaction(clientTransaction); //处理重量级进程 if ((proc.mInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0 &amp;&amp; mService.mHasHeavyWeightFeature) &#123; // This may be a heavy-weight process! Note that the package manager will ensure // that only activity can run in the main process of the .apk, which is the only // thing that will be considered heavy-weight. if (proc.mName.equals(proc.mInfo.packageName)) &#123; if (mService.mHeavyWeightProcess != null &amp;&amp; mService.mHeavyWeightProcess != proc) &#123; Slog.w(TAG, \"Starting new heavy weight process \" + proc + \" when already running \" + mService.mHeavyWeightProcess); &#125; mService.setHeavyWeightProcess(r); &#125; &#125; &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; // This is the second time we failed -- finish activity and give up. //第二次启动失败，finish掉Activity并放弃重试，直接返回false Slog.e(TAG, \"Second failure launching \" + r.intent.getComponent().flattenToShortString() + \", giving up\", e); proc.appDied(\"2nd-crash\"); r.finishIfPossible(\"2nd-crash\", false /* oomAdj */); return false; &#125; // This is the first time we failed -- restart process and // retry. //第一次启动失败，尝试重启进程并重试启动Activity r.launchFailed = true; proc.removeActivity(r); throw e; &#125; &#125; finally &#123; endDeferResume(); &#125; r.launchFailed = false; // TODO(lifecycler): Resume or pause requests are done as part of launch transaction, // so updating the state should be done accordingly. //更新生命周期状态 if (andResume &amp;&amp; readyToResume()) &#123; // As part of the process of launching, ActivityThread also performs // a resume. stack.minimalResumeActivityLocked(r); &#125; else &#123; // This activity is not starting in the resumed state... which should look like we asked // it to pause+stop (but remain visible), and it has done so and reported back the // current icicle and other state. r.setState(PAUSED, \"realStartActivityLocked\"); mRootWindowContainer.executeAppTransitionForAllDisplay(); &#125; // Perform OOM scoring after the activity state is set, so the process can be updated with // the latest state. //更新进程oom adj，更新进程状态 proc.onStartActivity(mService.mTopProcessState, r.info); // Launch the new version setup screen if needed. We do this -after- // launching the initial activity (that is, home), so that it can have // a chance to initialize itself while in the background, making the // switch back to it faster and look better. if (mRootWindowContainer.isTopDisplayFocusedStack(stack)) &#123; mService.getActivityStartController().startSetupActivity(); &#125; // Update any services we are bound to that might care about whether // their client may have activities. //更新进程绑定的所有服务 if (r.app != null) &#123; r.app.updateServiceConnectionActivities(); &#125; return true;&#125; 这个方法中最关键的部分在于创建了ClientTransaction事务，并向里添加了一条启动Activity的消息，然后调用ATMS.getLifecycleManager.scheduleTransaction调度执行这个事务，启动Activity ClientTransaction我们先来看看ClientTransaction这个对象是怎么创建获取的，我们首先调用了ClientTransaction.obtain方法，并传入了一个ActivityThread内部类ApplicationThread的Binder对象IApplicationThread和一个ActivityRecord.Token对象 12345678910public static ClientTransaction obtain(IApplicationThread client, IBinder activityToken) &#123; ClientTransaction instance = ObjectPool.obtain(ClientTransaction.class); if (instance == null) &#123; instance = new ClientTransaction(); &#125; instance.mClient = client; instance.mActivityToken = activityToken; return instance;&#125; 这个方法很简单，从池子里拿一个实例，或者新创建一个实例对象，将这个实例对象的两个成员变量赋值后返回 然后我们调用了ClientTransaction.addCallback方法将ClientTransactionItem加入到回调队列中，ClientTransactionItem是一条能够被执行的生命周期回调消息，它是一个抽象类，子类需要实现它的preExecute、execute、postExecute方法 我们这里传入的是LaunchActivityItem，这条消息是用来启动Activity的 然后我们调用ClientTransaction.setLifecycleStateRequest设置当事务执行结束后，Activity应该处在一个怎样的生命周期 最后调用ATMS.getLifecycleManager.scheduleTransaction调度执行这个事务，ATMS.getLifecycleManager获得的是一个ClientLifecycleManager对象，我们沿着这个方法继续往下看 12345678910void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; final IApplicationThread client = transaction.getClient(); transaction.schedule(); if (!(client instanceof Binder)) &#123; // If client is not an instance of Binder - it's a remote call and at this point it is // safe to recycle the object. All objects used for local calls will be recycled after // the transaction is executed on client in ActivityThread. transaction.recycle(); &#125;&#125; 除了回收调用recycle之外，我们又回到了ClientTransaction中，调用其schedule方法 123public void schedule() throws RemoteException &#123; mClient.scheduleTransaction(this);&#125; 这里又跨进程回到了App进程中，调用ApplicationThread.scheduleTransaction 123public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123; ActivityThread.this.scheduleTransaction(transaction);&#125; 最后调用ActivityThread.scheduleTransaction执行事务，ActivityThread继承自ClientTransactionHandler，scheduleTransaction方法是在这里面定义的 1234void scheduleTransaction(ClientTransaction transaction) &#123; transaction.preExecute(this); sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);&#125; 首先，调用ClientTransaction.preExecute方法，然后通过Handler发送执行一条EXECUTE_TRANSACTION消息，我们先看一下preExecute 1234567891011public void preExecute(android.app.ClientTransactionHandler clientTransactionHandler) &#123; if (mActivityCallbacks != null) &#123; final int size = mActivityCallbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; mActivityCallbacks.get(i).preExecute(clientTransactionHandler, mActivityToken); &#125; &#125; if (mLifecycleStateRequest != null) &#123; mLifecycleStateRequest.preExecute(clientTransactionHandler, mActivityToken); &#125;&#125; 可以看到，就是遍历整个callback列表，执行preExecute方法，最后再执行LifecycleStateRequest的preExecute方法，对应到Activity启动流程中，就是先执行LaunchActivityItem.preExecute，再执行ResumeActivityItem.preExecute 123456// LaunchActivityItempublic void preExecute(ClientTransactionHandler client, IBinder token) &#123; client.countLaunchingActivities(1); client.updateProcessState(mProcState, false); client.updatePendingConfiguration(mCurConfig);&#125; 1234567// ResumeActivityItempublic void preExecute(ClientTransactionHandler client, IBinder token) &#123; //这里mUpdateProcState为false，不执行 if (mUpdateProcState) &#123; client.updateProcessState(mProcState, false); &#125;&#125; 都是一些状态更新之类的东西，我们就直接跳过，然后我们看ActivityThread在收到EXECUTE_TRANSACTION消息后做了什么 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... case EXECUTE_TRANSACTION: final ClientTransaction transaction = (ClientTransaction) msg.obj; mTransactionExecutor.execute(transaction); ... break; ... &#125; ...&#125; 这里可以看到，调用了TransactionExecutor对象的execute方法，TransactionExecutor对象在ActivityThread创建时便创建了，内部持有一个ClientTransactionHandler引用，即ActivityThread自身 1234567891011121314151617181920212223242526272829public void execute(ClientTransaction transaction) &#123; final IBinder token = transaction.getActivityToken(); //处理需要销毁的Activities if (token != null) &#123; final Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed(); final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token); if (destroyItem != null) &#123; if (transaction.getLifecycleStateRequest() == destroyItem) &#123; // It is going to execute the transaction that will destroy activity with the // token, so the corresponding to-be-destroyed record can be removed. activitiesToBeDestroyed.remove(token); &#125; if (mTransactionHandler.getActivityClient(token) == null) &#123; // The activity has not been created but has been requested to destroy, so all // transactions for the token are just like being cancelled. //Activity尚未被创建就被请求destroy，直接取消整个事务 Slog.w(TAG, tId(transaction) + \"Skip pre-destroyed transaction:\\n\" + transactionToString(transaction, mTransactionHandler)); return; &#125; &#125; &#125; executeCallbacks(transaction); executeLifecycleState(transaction); mPendingActions.clear();&#125; 处理需要销毁的Activities这里我们不关注，就直接跳过，然后就是分别执行各个ClientTransactionItem回调消息，最后让其调度执行我们设置的最终的生命周期 12345678910111213141516171819202122232425262728public void executeCallbacks(ClientTransaction transaction) &#123; final List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks(); if (callbacks == null || callbacks.isEmpty()) &#123; // No callbacks to execute, return early. return; &#125; final IBinder token = transaction.getActivityToken(); ActivityClientRecord r = mTransactionHandler.getActivityClient(token); ... //生命周期转换相关 final int size = callbacks.size(); for (int i = 0; i &lt; size; ++i) &#123; final ClientTransactionItem item = callbacks.get(i); ... //生命周期转换，在Activity启动时不会走进这个case item.execute(mTransactionHandler, token, mPendingActions); item.postExecute(mTransactionHandler, token, mPendingActions); if (r == null) &#123; // Launch activity request will create an activity record. //在执行完启动Activity后会新建一个ActivityClientRecord，重新赋值 r = mTransactionHandler.getActivityClient(token); &#125; ... //生命周期转换，在Activity启动时不会走进这个case &#125;&#125; 关于生命周期转换，由于Activity启动的当前阶段不会进入这些case，所以这里就不提了 经过简化，实际上也就执行了LaunchActivityItem.execute和LaunchActivityItem.postExecute方法 12345678public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo, mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState, mPendingResults, mPendingNewIntents, mIsForward, mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments); client.handleLaunchActivity(r, pendingActions, null /* customIntent */);&#125; 这里使用之前在AMS中创建LaunchActivityItem所使用到的信息，创建了一个ActivityClientRecord对象，接着回到ActivityThread，调用其handleLaunchActivity方法 handleLaunchActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. //确保Configuration为最新 handleConfigurationChanged(null, null); // Initialize before creating the activity //初始化硬件加速 if (!ThreadedRenderer.sRendererDisabled &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; HardwareRenderer.preload(); &#125; //确保WMS被初始化 WindowManagerGlobal.initialize(); // Hint the GraphicsEnvironment that an activity is launching on the process. //通知有Activity启动 GraphicsEnvironment.hintActivityLaunch(); //执行启动Activity final Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; //设置Configuration r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); //设置一些延迟执行的动作（作用域到整个ClientTransaction结束） if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123; pendingActions.setOldState(r.state); //当Activity生命周期走到onStart前，会通过这里设置的值 //判断是否需要执行onRestoreInstanceState、onPostCreate pendingActions.setRestoreInstanceState(true); pendingActions.setCallOnPostCreate(true); &#125; &#125; else &#123; // If there was an error, for any reason, tell the activity manager to stop us. //出现错误，停止启动Activity try &#123; ActivityTaskManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; return a;&#125; 这个方法中，最重要的莫过于performLaunchActivity了，它是创建Activity的核心方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** Core implementation of activity launch. */private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; //设置LoadedApk if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //如果启动的Activity是一个activity-alias，将Component设置为真正的Activity组件 //详见：https://developer.android.com/guide/topics/manifest/activity-alias-element?hl=zh-cn if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //为Activity创建BaseContext ContextImpl appContext = createBaseContextForActivity(r); Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); //实例化Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //创建或获取Application //如果该Activity指定在其他的一个新的进程中启动（设置了android:process属性），则会新创建Application //正常不涉及多进程，都是直接获取之前创建好的Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; //Manifest中Activity标签下的label属性 CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); //准备Configuration Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; Window window = null; //当relaunch Activity的时候mPreserveWindow才会为true（比如说调用Activity.recreate方法） if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; // Activity resources must be initialized with the same loaders as the // application context. //设置Activity Resource的Loaders与Application Resource的Loaders一致 appContext.getResources().addLoaders( app.getResources().getLoaders().toArray(new ResourcesLoader[0])); appContext.setOuterContext(activity); //重要：绑定BaseContext、创建PhoneWindow等一系列初始化工作 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; //更新网络状态 checkAndBlockForNetworkAccess(); activity.mStartedActivity = false; //设置主题 int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //调用Activity的onCreate方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //在执行完super.onCreate方法后，mCalled会被置为true //如果mCalled为false，说明没有执行super.onCreate方法 throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; mLastReportedWindowingMode.put(activity.getActivityToken(), config.windowConfiguration.getWindowingMode()); &#125; //设置生命周期状态为onCreate r.setState(ON_CREATE); // updatePendingActivityConfiguration() reads from mActivities to update // ActivityClientRecord which runs in a different thread. Protect modifications to // mActivities to avoid race. //将新建的ActivityClientRecord添加到mActivities中 synchronized (mResourcesManager) &#123; mActivities.put(r.token, r); &#125; &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 这个方法主要做了以下几个工作： 准备创建Activity所必要的信息，譬如类名等 为Activity创建BaseContext 通过Instrumentation实例化Activity 创建或获取Activity进程所对应的Application 初始化Activity，执行各种绑定工作，创建PhoneWindow等 执行Activity的onCreate生命周期方法 将ActivityClientRecord生命周期状态设置为onCreate 我们重点看一下最主要的实例化、attach和onCreate这三点 Instrumentation.newActivity我们在 Android源码分析 - Activity启动流程（中） 中分析了，Application是怎么通过Instrumentation创建的，Activity的创建和它类似 12345678public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; String pkg = intent != null &amp;&amp; intent.getComponent() != null ? intent.getComponent().getPackageName() : null; return getFactory(pkg).instantiateActivity(cl, className, intent);&#125; 同样的使用了AppComponentFactory创建，我们还是去看一下它的默认实现 12345public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className, @Nullable Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity) cl.loadClass(className).newInstance();&#125; 同样的，也是通过类名反射创建一个Activity的实例 Activity.attach紧接着，我们来看Activity.attach方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) &#123; //绑定BaseContext attachBaseContext(context); //初始化Fragment控制器 mFragments.attachHost(null /*parent*/); //创建并设置Window用于显示界面 mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //各成员变量初始化 mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mAssistToken = assistToken; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) &#123; if (lastNonConfigurationInstances != null) &#123; mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; &#125; else &#123; mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); &#125; &#125; //设置WindowManager、ActivityRecordToken以及是否使用硬件加速 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; mWindow.setColorMode(info.colorMode); mWindow.setPreferMinimalPostProcessing( (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != 0); //设置自动填充选项 setAutofillOptions(application.getAutofillOptions()); //设置内容捕获功能 setContentCaptureOptions(application.getContentCaptureOptions());&#125; 这里可以看到，attach方法主要做了以下几件事： 绑定BaseContext 初始化Fragment控制器 创建并设置Window 各种成员变量及其他属性初始化 看完这个方法，我们可以发现，原来Activity的Window是在这个时候创建的，并且Window的具体实现类为PhoneWindow 再然后便是通过Instrumentation执行Activity的onCreate生命周期方法了 12345public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity);&#125; 其中prePerformCreate和postPerformCreate似乎只有在单元测试和CTS测试下才会产生实质性的影响，在正常情况下我们就当作它们不存在，我们接着看performCreate方法 Activity.performCreate1234567891011121314151617181920212223242526272829303132333435final void performCreate(Bundle icicle) &#123; performCreate(icicle, null);&#125;final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; //分发PreCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreCreated回调 dispatchActivityPreCreated(icicle); mCanEnterPictureInPicture = true; // initialize mIsInMultiWindowMode and mIsInPictureInPictureMode before onCreate final int windowingMode = getResources().getConfiguration().windowConfiguration .getWindowingMode(); //多窗口模式 mIsInMultiWindowMode = inMultiWindowMode(windowingMode); //画中画模式（小窗播放视频等场景） mIsInPictureInPictureMode = windowingMode == WINDOWING_MODE_PINNED; //恢复请求权限中的标志位 restoreHasCurrentPermissionRequest(icicle); //执行onCreate生命周期方法 if (persistentState != null) &#123; onCreate(icicle, persistentState); &#125; else &#123; onCreate(icicle); &#125; //共享元素动画相关 mActivityTransitionState.readState(icicle); mVisibleFromClient = !mWindow.getWindowStyle().getBoolean( com.android.internal.R.styleable.Window_windowNoDisplay, false); //FragmentManager分发ACTIVITY_CREATED状态 mFragments.dispatchActivityCreated(); //共享元素动画相关 mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); //分发PostCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostCreated回调 dispatchActivityPostCreated(icicle);&#125; 其中的参数icicle就是我们平时重写Activity.onCreate方法时的第一个入参savedInstanceState，如果Activity发生了重建之类的情况，它会保存一些状态数据，第一次启动Activity时为null 无论persistentState是否为null，最终都会进入到单个参数的onCreate方法中 12345678910111213141516171819202122232425262728293031323334353637383940protected void onCreate(@Nullable Bundle savedInstanceState) &#123; //恢复LoaderManager if (mLastNonConfigurationInstances != null) &#123; mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); &#125; //ActionBar if (mActivityInfo.parentActivityName != null) &#123; if (mActionBar == null) &#123; mEnableDefaultActionBarUp = true; &#125; else &#123; mActionBar.setDefaultDisplayHomeAsUpEnabled(true); &#125; &#125; if (savedInstanceState != null) &#123; //自动填充功能 mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false); mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID, View.LAST_APP_AUTOFILL_ID); if (mAutoFillResetNeeded) &#123; getAutofillManager().onCreate(savedInstanceState); &#125; //恢复FragmentManager状态 Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); &#125; //FragmentManager分发CREATED状态，执行内部Fragment的生命周期 mFragments.dispatchCreate(); //分发Created事件，执行所有注册的ActivityLifecycleCallbacks的onActivityCreated回调 dispatchActivityCreated(savedInstanceState); //语音交互功能 if (mVoiceInteractor != null) &#123; mVoiceInteractor.attachActivity(this); &#125; mRestoredFromBundle = savedInstanceState != null; //这里表示已调用过super.onCreate方法 mCalled = true;&#125; 到这里，Activity的onCreate生命周期就走完了，我们也可以从这整个流程中得到一些新的收获，比如说，原来注册在Application中的ActivityLifecycleCallbacks回调是在这里触发的，FragmentManager状态分发的顺序是这样的，为什么必须要调用super.onCreate方法等等 接着，我们再回到TransactionExecutor中，它接下来执行的是LaunchActivityItem.postExecute 1234public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; client.countLaunchingActivities(-1);&#125; 这里就非常简单了，计数器减一 postExecute执行完后，整个LaunchActivityItem的工作就完成了，接下来执行的是TransactionExecutor.executeLifecycleState方法 12345678910111213141516171819202122232425private void executeLifecycleState(ClientTransaction transaction) &#123; final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest(); if (lifecycleItem == null) &#123; // No lifecycle request, return early. return; &#125; final IBinder token = transaction.getActivityToken(); final ActivityClientRecord r = mTransactionHandler.getActivityClient(token); if (r == null) &#123; // Ignore requests for non-existent client records for now. return; &#125; // Cycle to the state right before the final requested state. //excludeLastState为true的情况下，推进生命周期直到最终生命周期的上一个生命周期 //excludeLastState为false的情况下，推进生命周期直到最终生命周期 cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */, transaction); // Execute the final transition with proper parameters. //执行最终的生命周期事务 lifecycleItem.execute(mTransactionHandler, token, mPendingActions); lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);&#125; 我们目前处在的生命周期为ON_CREATE最终目标要到达的生命周期为ON_RESUME，cycleToPath方法会帮助我们把生命周期推进到ON_RESUME的上一个生命周期也就是ON_START 123456private void cycleToPath(ActivityClientRecord r, int finish, boolean excludeLastState, ClientTransaction transaction) &#123; final int start = r.getLifecycleState(); final IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState); performLifecycleSequence(r, path, transaction);&#125; TransactionExecutorHelper.getLifecyclePath方法会帮我们计算出一个剩余要经过的生命周期路线的一个有序数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public IntArray getLifecyclePath(int start, int finish, boolean excludeLastState) &#123; ... //错误判断 mLifecycleSequence.clear(); if (finish &gt;= start) &#123; if (start == ON_START &amp;&amp; finish == ON_STOP) &#123; // A case when we from start to stop state soon, we don't need to go // through the resumed, paused state. mLifecycleSequence.add(ON_STOP); &#125; else &#123; // just go there //按顺序添加生命周期 for (int i = start + 1; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; &#125; else &#123; // finish &lt; start, can't just cycle down if (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123; // Special case when we can just directly go to resumed state. mLifecycleSequence.add(ON_RESUME); &#125; else if (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123; // Restart and go to required state. // Go to stopped state first. for (int i = start + 1; i &lt;= ON_STOP; i++) &#123; mLifecycleSequence.add(i); &#125; // Restart mLifecycleSequence.add(ON_RESTART); // Go to required state for (int i = ON_START; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; else &#123; // Relaunch and go to required state // Go to destroyed state first. for (int i = start + 1; i &lt;= ON_DESTROY; i++) &#123; mLifecycleSequence.add(i); &#125; // Go to required state for (int i = ON_CREATE; i &lt;= finish; i++) &#123; mLifecycleSequence.add(i); &#125; &#125; &#125; // Remove last transition in case we want to perform it with some specific params. if (excludeLastState &amp;&amp; mLifecycleSequence.size() != 0) &#123; mLifecycleSequence.remove(mLifecycleSequence.size() - 1); &#125; return mLifecycleSequence;&#125; 其实从这个方法，我们就能看出Activity生命周期是怎么设计的，代码很简单，我就不解释了 123456789public static final int UNDEFINED = -1;public static final int PRE_ON_CREATE = 0;public static final int ON_CREATE = 1;public static final int ON_START = 2;public static final int ON_RESUME = 3;public static final int ON_PAUSE = 4;public static final int ON_STOP = 5;public static final int ON_DESTROY = 6;public static final int ON_RESTART = 7; 我们结合这上面这个生命周期大小来看，start为ON_CREATE，finish为ON_RESUME，excludeLastState为true移除最后一个生命周期，得出的结果便是[ON_START]，然后调用performLifecycleSequence方法执行生命周期 123456789101112131415161718192021222324252627282930313233343536373839404142private void performLifecycleSequence(ActivityClientRecord r, IntArray path, ClientTransaction transaction) &#123; final int size = path.size(); for (int i = 0, state; i &lt; size; i++) &#123; state = path.get(i); switch (state) &#123; case ON_CREATE: mTransactionHandler.handleLaunchActivity(r, mPendingActions, null /* customIntent */); break; case ON_START: mTransactionHandler.handleStartActivity(r, mPendingActions, null /* activityOptions */); break; case ON_RESUME: mTransactionHandler.handleResumeActivity(r, false /* finalStateRequest */, r.isForward, \"LIFECYCLER_RESUME_ACTIVITY\"); break; case ON_PAUSE: mTransactionHandler.handlePauseActivity(r, false /* finished */, false /* userLeaving */, 0 /* configChanges */, false /* autoEnteringPip */, mPendingActions, \"LIFECYCLER_PAUSE_ACTIVITY\"); break; case ON_STOP: mTransactionHandler.handleStopActivity(r, 0 /* configChanges */, mPendingActions, false /* finalStateRequest */, \"LIFECYCLER_STOP_ACTIVITY\"); break; case ON_DESTROY: mTransactionHandler.handleDestroyActivity(r, false /* finishing */, 0 /* configChanges */, false /* getNonConfigInstance */, \"performLifecycleSequence. cycling to:\" + path.get(size - 1)); break; case ON_RESTART: mTransactionHandler.performRestartActivity(r, false /* start */); break; default: throw new IllegalArgumentException(\"Unexpected lifecycle state: \" + state); &#125; &#125;&#125; 这个方法很简单啊，就是遍历这个数组，依次执行生命周期，结合我们传入的数组[ON_START]，最后便是调用ActivityThread.handleStartActivity方法 handleStartActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public void handleStartActivity(IBinder token, PendingTransactionActions pendingActions) &#123; final ActivityClientRecord r = mActivities.get(token); final Activity activity = r.activity; ... //检查 unscheduleGcIdler(); // Start //执行onStart生命周期 activity.performStart(\"handleStartActivity\"); //设置生命周期状态为onStart r.setState(ON_START); if (pendingActions == null) &#123; // No more work to do. return; &#125; // Restore instance state //之前在handleLaunchActivity方法中设置了pendingActions.setRestoreInstanceState(true) //这里便会判断是否需要并执行Activity.onRestoreInstanceState if (pendingActions.shouldRestoreInstanceState()) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; // Call postOnCreate() //之前在handleLaunchActivity方法中设置了pendingActions.setCallOnPostCreate(true) //这里便会执行Activity.onPostCreate，如果不是从onCreate转到onStart，不会进入此case if (pendingActions.shouldCallOnPostCreate()) &#123; activity.mCalled = false; //调用Activity.onPostCreate if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //和onCreate一样，onPostCreate也必须要调用super.onPostCreate throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; //更新可见性 //Activity启动时，由于此时mDecor还未赋值，所以不会产生影响 updateVisibility(r, true /* show */); mSomeActivitiesChanged = true;&#125; 这里有一点需要注意，我们一般重写Activity的onCreate方法，在其中调用setContentView方法，此时DecorView虽然被创建出来了，但是只在PhoneWindow中持有，尚未给Activity.mDecor赋值，所以此时调用updateVisibility方法并不会将DecorView加入到WindowManager中，也就是目前界面还尚未可见 另外，我们可以注意到，performStart是先于callActivityOnPostCreate，所以Activity中的生命周期回调onPostCreate是在onStart之后触发的，各位在开发App的时候不要弄错了这一点 其他的地方注释都写的都很明白了哈，也没什么必要再看performStart了，无非也就和performCreate一样，执行ActivityLifecycleCallbacks回调，FragmentManager分发STARTED状态，调用onStart方法等 接下来我们再回到TransactionExecutor中，后面便是执行ResumeActivityItem的execute和postExecute方法了 12345public void execute(ClientTransactionHandler client, ActivityClientRecord r, PendingTransactionActions pendingActions) &#123; client.handleResumeActivity(r, true /* finalStateRequest */, mIsForward, \"RESUME_ACTIVITY\");&#125; 可以看到，又执行了ActivityThread.handleResumeActivity方法 handleResumeActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward, String reason) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration //执行onResume生命周期 final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) &#123; // We didn't actually resume the activity, so skipping any follow-up actions. return; &#125; //如果Activity将被destroy，那就没必要再执行resume了，直接返回 if (mActivitiesToBeDestroyed.containsKey(token)) &#123; // Although the activity is resumed, it is going to be destroyed. So the following // UI operations are unnecessary and also prevents exception because its token may // be gone that window manager cannot recognize it. All necessary cleanup actions // performed below will be done while handling destruction. return; &#125; final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityTaskManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; //设置Window if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); //DecorView暂时不可见 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); //给Activity的mDecor成员变量赋值 a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; //如果DecorView尚未添加到WindowManager中，将其添加进去，否则更新Window属性 //Activity启动过程中，第一次resume时，DecorView还尚未添加至WindowManager，所以会走进上面这个case //由于我们之前将DecorView的Visibility设置成了INVISIBLE，所以此时界面还是不可见 if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; else &#123; // The activity will get a callback for this &#123;@link LayoutParams&#125; change // earlier. However, at that time the decor will not be set (this is set // in this method), so no action will be taken. This call ensures the // callback occurs with the decor set. a.onWindowAttributesChanged(l); &#125; &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; r.hideForNow = true; &#125; // Get rid of anything left hanging around. //清除遗留的东西 cleanUpPendingRemoveWindows(r, false /* force */); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //分发Configuration更新事件 if (r.newConfig != null) &#123; performConfigurationChangedForActivity(r, r.newConfig); r.newConfig = null; &#125; //当DecorView add进WindowManager后，ViewRootImpl被创建 ViewRootImpl impl = r.window.getDecorView().getViewRootImpl(); WindowManager.LayoutParams l = impl != null ? impl.mWindowAttributes : r.window.getAttributes(); ... //软键盘相关 r.activity.mVisibleFromServer = true; mNumVisibleActivities++; //使DecorView可见 if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; //当空闲时，检查处理其他后台Activity状态 //对处在stopping或finishing的Activity执行onStop或onDestroy生命周期 r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler());&#125; 这里有三个重要的地方需要注意： 执行performResumeActivity，这里和之前分析的两个生命周期类似，我们后面再看 给Activity的mDecor成员变量赋值，将DecorView添加到WindowManager中，使DecorView可见 将上一个活动的ActivityClientRecord以链表的形式串在当前ActivityClientRecord后面，向MessageQueue添加一条闲时处理消息Idler，这条消息会遍历ActivityClientRecord的整条nextIdle链，依次检查是否需要stop或destroy Activity，这一点我会在后面关于Activity其他生命周期的文章中再分析 接下来我们简单过一下performResumeActivity吧 1234567891011121314151617181920212223242526272829303132333435363738394041public ActivityClientRecord performResumeActivity(IBinder token, boolean finalStateRequest, String reason) &#123; final ActivityClientRecord r = mActivities.get(token); ... //状态检查 //为最终生命周期状态 if (finalStateRequest) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; try &#123; r.activity.onStateNotSaved(); //标记Fragments状态为未保存 r.activity.mFragments.noteStateNotSaved(); //更新网络状态 checkAndBlockForNetworkAccess(); if (r.pendingIntents != null) &#123; deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; &#125; if (r.pendingResults != null) &#123; deliverResults(r, r.pendingResults, reason); r.pendingResults = null; &#125; //执行Activity.onResume生命周期 r.activity.performResume(r.startsNotResumed, reason); //将保存信息的savedInstanceState和persistentState重置为null r.state = null; r.persistentState = null; //设置生命周期状态 r.setState(ON_RESUME); //回调Activity.onTopResumedActivityChanged，报告栈顶活动Activity发生变化 reportTopResumedActivityChanged(r, r.isTopResumedActivity, \"topWhenResuming\"); &#125; catch (Exception e) &#123; ... &#125; return r;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void performResume(boolean followedByPause, String reason) &#123; //回调ActivityLifecycleCallbacks.onActivityPreResumed dispatchActivityPreResumed(); //执行onRestart生命周期 //内部会判断当前Activity是否为stop状态，是的话才会真正执行onRestart生命周期 //启动Activity第一次resume时不会进入onRestart生命周期 performRestart(true /* start */, reason); mFragments.execPendingActions(); mLastNonConfigurationInstances = null; ... //自动填充功能 mCalled = false; // mResumed is set by the instrumentation //执行Activity.onResume回调 mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; //必须执行super.onResume方法 throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onResume()\"); &#125; // invisible activities must be finished before onResume() completes ... //异常检查 // Now really resume, and install the current status bar and menu. mCalled = false; //FragmentManager分发resume状态 mFragments.dispatchResume(); mFragments.execPendingActions(); //执行onPostResume回调 onPostResume(); if (!mCalled) &#123; //必须要执行super.onPostResume throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPostResume()\"); &#125; //回调ActivityLifecycleCallbacks.onActivityPostResumed dispatchActivityPostResumed();&#125; 12345678910protected void onResume() &#123; //回调ActivityLifecycleCallbacks.onActivityResumed dispatchActivityResumed(); //共享元素动画 mActivityTransitionState.onResume(this); ... //自动填充功能 notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_RESUME); mCalled = true;&#125; 可以看到，基本上和之前的两个生命周期的执行是一个套路，唯一需要注意的是，在执行onResume生命周期之前，会先检查Activity是否处在stop状态，如果是的话，则会先执行onRestart生命周期，其他地方我在注释上标注的应该已经很明白了，这里就不再多讲了 不要忘了，在TransactionExecutor中还有最后一步ResumeActivityItem.postExecute没做 123456789public void postExecute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) &#123; try &#123; // TODO(lifecycler): Use interface callback instead of AMS. ActivityTaskManager.getService().activityResumed(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125;&#125; 这里通过Binder又回到了系统进程调用了ATMS.activityResumed方法 1234567public final void activityResumed(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (mGlobalLock) &#123; ActivityRecord.activityResumedLocked(token); &#125; Binder.restoreCallingIdentity(origId);&#125; 12345678910111213141516static void activityResumedLocked(IBinder token, boolean handleSplashScreenExit) &#123; final ActivityRecord r = ActivityRecord.forTokenLocked(token); if (r == null) &#123; // If an app reports resumed after a long delay, the record on server side might have // been removed (e.g. destroy timeout), so the token could be null. return; &#125; //SplashScreen r.setCustomizeSplashScreenExitAnimation(handleSplashScreenExit); //重置savedState Bundle r.setSavedState(null /* savedState */); r.mDisplayContent.handleActivitySizeCompatModeIfNeeded(r); //防闪烁功能 r.mDisplayContent.mUnknownAppVisibilityController.notifyAppResumedFinished(r);&#125; 可以看到，最后也就做了一些收尾工作，到这里，整个Activity的启动流程也就圆满结束了 结尾至此为止，我们Activity启动流程三部连续剧终于是圆满完成了，历时整整半年的时间，我心里压着的这块石头也终于是落地了，后面我应该会再做一些关于Activity其他生命周期变换的分析，比如说Activity是怎样销毁的，欢迎感兴趣的小伙伴点赞、收藏、关注我","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"}]},{"title":"Android源码分析 - Activity启动流程（中）","slug":"android/aosp/Android源码分析-Activity启动流程（中）","date":"2022-10-24T06:49:22.000Z","updated":"2023-02-26T10:34:30.148Z","comments":true,"path":"2022/10/24/android/aosp/Android源码分析-Activity启动流程（中）/","link":"","permalink":"http://yoursite.com/2022/10/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 上一篇文章 Android源码分析 - Activity启动流程（上） 中，我们分析了Activity启动流程中的一小部分，基本上可以算是Activity启动的前置准备工作，这篇文章我们将会分析App进程启动的主要流程 启动App进程准备ProcessRecord上篇文章中我们说过了，如果App尚未启动，则会调用ATMS的startProcessAsync方法去启动App进程 1234567891011121314void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop, String hostingType) &#123; try &#123; ... // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess, mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead, isTop, hostingType, activity.intent.getComponent()); mH.sendMessage(m); &#125; finally &#123; ... &#125;&#125; 这个方法实际上是通过Hander调用了ActivityManagerInternal (AMS.LocalService)的startProcess方法 123456789101112131415161718@Overridepublic void startProcess(String processName, ApplicationInfo info, boolean knownToBeDead, boolean isTop, String hostingType, ComponentName hostingName) &#123;try &#123; ... synchronized (ActivityManagerService.this) &#123; // If the process is known as top app, set a hint so when the process is // started, the top priority can be applied immediately to avoid cpu being // preempted by other processes before attaching the process of top app. startProcessLocked(processName, info, knownToBeDead, 0 /* intentFlags */, new HostingRecord(hostingType, hostingName, isTop), ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, false /* allowWhileBooting */, false /* isolated */, true /* keepIfLarge */); &#125;&#125; finally &#123; ...&#125;&#125; 这里将进程启动的一些信息封装到了HostingRecord类中 123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) &#123;return mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */);&#125; AMS将启动进程的任务转交给了ProcessList，这个类的职责是管理进程，包括管理进程优先级(Adj)、进程OOM等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, HostingRecord hostingRecord, int zygotePolicyFlags, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123; long startTime = SystemClock.uptimeMillis(); ProcessRecord app; if (!isolated) &#123; //先通过进程名和uid查找相应App的ProcessRecord app = getProcessRecordLocked(processName, info.uid, keepIfLarge); //如果是由后台进程发起的 startProcess //判断启动进程是否为 bad process，如果是，直接启动失败返回 //这里 bad process 的定义为：短时间内连续崩溃两次以上的进程 if ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != 0) &#123; // If we are in the background, then check to see if this process // is bad. If so, we will just silently fail. if (mService.mAppErrors.isBadProcessLocked(info)) &#123; return null; &#125; &#125; else &#123; // When the user is explicitly starting a process, then clear its // crash count so that we won't make it bad until they see at // least one crash dialog again, and make the process good again // if it had been bad. //如果是用户显式的要求启动进程，则会清空启动进程的崩溃次数，将启动进程从 bad process 列表中移除 mService.mAppErrors.resetProcessCrashTimeLocked(info); if (mService.mAppErrors.isBadProcessLocked(info)) &#123; EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, UserHandle.getUserId(info.uid), info.uid, info.processName); mService.mAppErrors.clearBadProcessLocked(info); if (app != null) &#123; app.bad = false; &#125; &#125; &#125; &#125; else &#123; // If this is an isolated process, it can't re-use an existing process. app = null; &#125; // We don't have to do anything more if: // (1) There is an existing application record; and // (2) The caller doesn't think it is dead, OR there is no thread // object attached to it so we know it couldn't have crashed; and // (3) There is a pid assigned to it, so it is either starting or // already running. ProcessRecord precedence = null; //如果已经存在了对应App的ProcessRecord，并且分配了pid if (app != null &amp;&amp; app.pid &gt; 0) &#123; //如果进程没有死亡或者进程还未绑定binder线程，说明进程是正常运行状态或正在启动中 if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123; // We already have the app running, or are waiting for it to // come up (we have a pid but not yet its thread), so keep it. // If this is a new package in the process, add the package to the list //将要启动的包信息记录在ProcessRecord中（Android多个App可以运行在同一个进程中） app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats); return app; &#125; // An application record is attached to a previous process, // clean it up now. //App绑定在之前的一个进程上了，杀死并清理这个进程 ProcessList.killProcessGroup(app.uid, app.pid); Slog.wtf(TAG_PROCESSES, app.toString() + \" is attached to a previous process\"); // We are not going to re-use the ProcessRecord, as we haven't dealt with the cleanup // routine of it yet, but we'd set it as the precedence of the new process. precedence = app; app = null; &#125; //没有找到对应的ProcessRecord if (app == null) &#123; //新创建一个ProcessRecord对象 app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord); if (app == null) &#123; Slog.w(TAG, \"Failed making new process record for \" + processName + \"/\" + info.uid + \" isolated=\" + isolated); return null; &#125; app.crashHandler = crashHandler; app.isolatedEntryPoint = entryPoint; app.isolatedEntryPointArgs = entryPointArgs; if (precedence != null) &#123; app.mPrecedence = precedence; precedence.mSuccessor = app; &#125; &#125; else &#123; //存在对应的ProcessRecord，但进程尚未启动或已被清理 // If this is a new package in the process, add the package to the list //将要启动的包信息记录在ProcessRecord中 app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats); &#125; // If the system is not ready yet, then hold off on starting this // process until it is. //如果系统尚未准备好（开机中或system_server进程崩溃重启中），将其先添加到等待队列中 if (!mService.mProcessesReady &amp;&amp; !mService.isAllowedWhileBooting(info) &amp;&amp; !allowWhileBooting) &#123; if (!mService.mProcessesOnHold.contains(app)) &#123; mService.mProcessesOnHold.add(app); &#125; return app; &#125; final boolean success = startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride); return success ? app : null;&#125; 这个方法主要是处理ProcessRecord对象，如果找不到对应的ProcessRecord或对应的ProcessRecord里的信息表明App进程尚未启动，则会调用另一个startProcessLocked重载方法启动进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159final boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags, String abiOverride) &#123; return startProcessLocked(app, hostingRecord, zygotePolicyFlags, false /* disableHiddenApiChecks */, false /* disableTestApiChecks */, false /* mountExtStorageFull */, abiOverride);&#125;boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord, int zygotePolicyFlags, boolean disableHiddenApiChecks, boolean disableTestApiChecks, boolean mountExtStorageFull, String abiOverride) &#123; //进程正在启动中 if (app.pendingStart) &#123; return true; &#125; //从刚才方法中的判断来看，应该不会进入这个case if (app.pid &gt; 0 &amp;&amp; app.pid != ActivityManagerService.MY_PID) &#123; //将ProcessRecord的pid从PidMap中移除 mService.removePidLocked(app); app.bindMountPending = false; //将ProcessRecord的pid重置为0 app.setPid(0); app.startSeq = 0; &#125; //将ProcessRecord从启动等待队列中移除 mService.mProcessesOnHold.remove(app); mService.updateCpuStats(); try &#123; try &#123; //检测当前用户是否可以启动这个App final int userId = UserHandle.getUserId(app.uid); AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; int uid = app.uid; int[] gids = null; //默认不挂载外置存储 int mountExternal = Zygote.MOUNT_EXTERNAL_NONE; if (!app.isolated) &#123; int[] permGids = null; try &#123; final IPackageManager pm = AppGlobals.getPackageManager(); //获取GIDS（App申请的权限） permGids = pm.getPackageGids(app.info.packageName, MATCH_DIRECT_BOOT_AUTO, app.userId); if (StorageManager.hasIsolatedStorage() &amp;&amp; mountExtStorageFull) &#123; //挂载外置存储，允许读写 mountExternal = Zygote.MOUNT_EXTERNAL_FULL; &#125; else &#123; StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); //获取App对外置存储的读写权限 mountExternal = storageManagerInternal.getExternalStorageMountMode(uid, app.info.packageName); &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; // Remove any gids needed if the process has been denied permissions. // NOTE: eventually we should probably have the package manager pre-compute // this for us? //从刚刚过去的App申请权限中剔除进程所被拒绝的权限 if (app.processInfo != null &amp;&amp; app.processInfo.deniedPermissions != null) &#123; for (int i = app.processInfo.deniedPermissions.size() - 1; i &gt;= 0; i--) &#123; int[] denyGids = mService.mPackageManagerInt.getPermissionGids( app.processInfo.deniedPermissions.valueAt(i), app.userId); if (denyGids != null) &#123; for (int gid : denyGids) &#123; permGids = ArrayUtils.removeInt(permGids, gid); &#125; &#125; &#125; &#125; //计算得出进程所应拥有的所有权限 gids = computeGidsForProcess(mountExternal, uid, permGids); &#125; //设置挂载模式 app.mountMode = mountExternal; //工厂测试进程 if (mService.mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) &#123; uid = 0; &#125; //进程启动参数（传递到Zygoto） int runtimeFlags = 0; //如果manifest中设置了android:debuggable if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP; runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE; // Also turn on CheckJNI for debuggable apps. It's quite // awkward to turn on otherwise. runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI; // Check if the developer does not want ART verification if (android.provider.Settings.Global.getInt(mService.mContext.getContentResolver(), android.provider.Settings.Global.ART_VERIFIER_VERIFY_DEBUGGABLE, 1) == 0) &#123; runtimeFlags |= Zygote.DISABLE_VERIFIER; Slog.w(TAG_PROCESSES, app + \": ART verification disabled\"); &#125; &#125; ... //设置各种高进程启动参数 String invokeWith = null; //如果manifest中设置了android:debuggable //使用logwrapper工具捕获stdout信息 if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; // Debuggable apps may include a wrapper script with their library directory. String wrapperFileName = app.info.nativeLibraryDir + \"/wrap.sh\"; StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); try &#123; if (new File(wrapperFileName).exists()) &#123; invokeWith = \"/system/bin/logwrapper \" + wrapperFileName; &#125; &#125; finally &#123; StrictMode.setThreadPolicy(oldPolicy); &#125; &#125; //确定App进程使用的abi（有so库的App会通过so库的架构决定，没有so库的使用系统最优先支持的abi） String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi; if (requiredAbi == null) &#123; requiredAbi = Build.SUPPORTED_ABIS[0]; &#125; //将abi转成InstructionSet String instructionSet = null; if (app.info.primaryCpuAbi != null) &#123; instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi); &#125; app.gids = gids; app.setRequiredAbi(requiredAbi); app.instructionSet = instructionSet; ... final String seInfo = app.info.seInfo + (TextUtils.isEmpty(app.info.seInfoUser) ? \"\" : app.info.seInfoUser); // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. //重要：设置进程启动入口 final String entryPoint = \"android.app.ActivityThread\"; //启动进程 return startProcessLocked(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); &#125; catch (RuntimeException e) &#123; ... mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, app.userId, \"start failure\"); return false; &#125;&#125; 到这一步位置仍然是在进行准备工作，主要做了以下几件事： 权限处理：App安装时会检测manifest里申请的权限，并由此生成出一个GIDS数组 设置挂载模式 设置进程的各种启动参数 设置App进程使用的abi 设置进程启动入口 继续调用重载方法启动进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean startProcessLocked(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; //初始化一些参数 //标识App进程正在启动 app.pendingStart = true; app.killedByAm = false; app.removed = false; app.killed = false; app.mDisabledCompatChanges = null; if (mPlatformCompat != null) &#123; app.mDisabledCompatChanges = mPlatformCompat.getDisabledChanges(app.info); &#125; final long startSeq = app.startSeq = ++mProcStartSeqCounter; app.setStartParams(uid, hostingRecord, seInfo, startTime); app.setUsingWrapper(invokeWith != null || Zygote.getWrapProperty(app.processName) != null); //将ProcessRecord添加到待启动列表中 mPendingStarts.put(startSeq, app); if (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123; //异步启动进程 if (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES, \"Posting procStart msg for \" + app.toShortString()); mService.mProcStartHandler.post(() -&gt; handleProcessStart( app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal, requiredAbi, instructionSet, invokeWith, startSeq)); return true; &#125; else &#123; //同步启动进程 try &#123; final Process.ProcessStartResult startResult = startProcess(hostingRecord, entryPoint, app, uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime); handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false); &#125; catch (RuntimeException e) &#123; //出错，将pendingStart标志复位并强行停止进程 app.pendingStart = false; mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, app.userId, \"start failure\"); &#125; return app.pid &gt; 0; &#125;&#125; 在异步模式下，程序会等待ProcessRecord.mPrecedence进程结束才会启动进程（这里对应着最开始的startProcessLocked方法中，已经存在了对应App的ProcessRecord，并且分配了pid，但是进程被标记为死亡这种情况） 最终都会进入到startProcess和handleProcessStartedLocked方法中来 startProcess123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106private Process.ProcessStartResult startProcess(HostingRecord hostingRecord, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int zygotePolicyFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) &#123; try &#123; final boolean isTopApp = hostingRecord.isTopApp(); if (isTopApp) &#123; // Use has-foreground-activities as a temporary hint so the current scheduling // group won't be lost when the process is attaching. The actual state will be // refreshed when computing oom-adj. app.setHasForegroundActivities(true); &#125; //处理应用目录隔离机制 Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap; Map&lt;String, Pair&lt;String, Long&gt;&gt; whitelistedAppDataInfoMap; boolean bindMountAppStorageDirs = false; boolean bindMountAppsData = mAppDataIsolationEnabled &amp;&amp; (UserHandle.isApp(app.uid) || UserHandle.isIsolated(app.uid)) &amp;&amp; mPlatformCompat.isChangeEnabled(APP_DATA_DIRECTORY_ISOLATION, app.info); // Get all packages belongs to the same shared uid. sharedPackages is empty array // if it doesn't have shared uid. final PackageManagerInternal pmInt = mService.getPackageManagerInternalLocked(); final String[] sharedPackages = pmInt.getSharedUserPackagesForPackage( app.info.packageName, app.userId); final String[] targetPackagesList = sharedPackages.length == 0 ? new String[]&#123;app.info.packageName&#125; : sharedPackages; pkgDataInfoMap = getPackageAppDataInfoMap(pmInt, targetPackagesList, uid); if (pkgDataInfoMap == null) &#123; // TODO(b/152760674): Handle inode == 0 case properly, now we just give it a // tmp free pass. bindMountAppsData = false; &#125; // Remove all packages in pkgDataInfoMap from mAppDataIsolationWhitelistedApps, so // it won't be mounted twice. final Set&lt;String&gt; whitelistedApps = new ArraySet&lt;&gt;(mAppDataIsolationWhitelistedApps); for (String pkg : targetPackagesList) &#123; whitelistedApps.remove(pkg); &#125; whitelistedAppDataInfoMap = getPackageAppDataInfoMap(pmInt, whitelistedApps.toArray(new String[0]), uid); if (whitelistedAppDataInfoMap == null) &#123; // TODO(b/152760674): Handle inode == 0 case properly, now we just give it a // tmp free pass. bindMountAppsData = false; &#125; int userId = UserHandle.getUserId(uid); StorageManagerInternal storageManagerInternal = LocalServices.getService( StorageManagerInternal.class); if (needsStorageDataIsolation(storageManagerInternal, app)) &#123; bindMountAppStorageDirs = true; if (pkgDataInfoMap == null || !storageManagerInternal.prepareStorageDirs(userId, pkgDataInfoMap.keySet(), app.processName)) &#123; // Cannot prepare Android/app and Android/obb directory or inode == 0, // so we won't mount it in zygote, but resume the mount after unlocking device. app.bindMountPending = true; bindMountAppStorageDirs = false; &#125; &#125; // If it's an isolated process, it should not even mount its own app data directories, // since it has no access to them anyway. if (app.isolated) &#123; pkgDataInfoMap = null; whitelistedAppDataInfoMap = null; &#125; final Process.ProcessStartResult startResult; if (hostingRecord.usesWebviewZygote()) &#123; startResult = startWebView(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, app.mDisabledCompatChanges, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else if (hostingRecord.usesAppZygote()) &#123; final AppZygote appZygote = createAppZygoteForProcessIfNeeded(app); // We can't isolate app data and storage data as parent zygote already did that. startResult = appZygote.getProcess().start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, null, app.info.packageName, /*zygotePolicyFlags=*/ ZYGOTE_POLICY_FLAG_EMPTY, isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap, false, false, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; else &#123; //没有特别指定hostingZygote时，进入此case startResult = Process.start(entryPoint, app.processName, uid, uid, gids, runtimeFlags, mountExternal, app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags, isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs, new String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;); &#125; return startResult; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125;&#125; 从Android 11开始引入了应用目录隔离机制，使得应用仅可以发现和访问自己的储存目录，不可以访问其他应用的储存目录 这里处理完应用目录隔离机制后，调用了Process.start方法启动进程，最终走到ZygoteProcess.startViaZygote方法 向zygoto发送socket请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap, @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt; allowlistedDataInfoList, boolean bindMountAppsData, boolean bindMountAppStorageDirs, @Nullable String[] extraArgs) throws ZygoteStartFailedEx &#123; ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;&gt;(); // --runtime-args, --setuid=, --setgid=, // and --setgroups= must go first argsForZygote.add(\"--runtime-args\"); argsForZygote.add(\"--setuid=\" + uid); argsForZygote.add(\"--setgid=\" + gid); argsForZygote.add(\"--runtime-flags=\" + runtimeFlags); if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123; argsForZygote.add(\"--mount-external-default\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123; argsForZygote.add(\"--mount-external-installer\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123; argsForZygote.add(\"--mount-external-pass-through\"); &#125; else if (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123; argsForZygote.add(\"--mount-external-android-writable\"); &#125; argsForZygote.add(\"--target-sdk-version=\" + targetSdkVersion); // --setgroups is a comma-separated list if (gids != null &amp;&amp; gids.length &gt; 0) &#123; final StringBuilder sb = new StringBuilder(); sb.append(\"--setgroups=\"); final int sz = gids.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(gids[i]); &#125; argsForZygote.add(sb.toString()); &#125; if (niceName != null) &#123; argsForZygote.add(\"--nice-name=\" + niceName); &#125; if (seInfo != null) &#123; argsForZygote.add(\"--seinfo=\" + seInfo); &#125; if (instructionSet != null) &#123; argsForZygote.add(\"--instruction-set=\" + instructionSet); &#125; if (appDataDir != null) &#123; argsForZygote.add(\"--app-data-dir=\" + appDataDir); &#125; if (invokeWith != null) &#123; argsForZygote.add(\"--invoke-with\"); argsForZygote.add(invokeWith); &#125; if (startChildZygote) &#123; argsForZygote.add(\"--start-child-zygote\"); &#125; if (packageName != null) &#123; argsForZygote.add(\"--package-name=\" + packageName); &#125; if (isTopApp) &#123; argsForZygote.add(Zygote.START_AS_TOP_APP_ARG); &#125; if (pkgDataInfoMap != null &amp;&amp; pkgDataInfoMap.size() &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(Zygote.PKG_DATA_INFO_MAP); sb.append(\"=\"); boolean started = false; for (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123; if (started) &#123; sb.append(','); &#125; started = true; sb.append(entry.getKey()); sb.append(','); sb.append(entry.getValue().first); sb.append(','); sb.append(entry.getValue().second); &#125; argsForZygote.add(sb.toString()); &#125; if (allowlistedDataInfoList != null &amp;&amp; allowlistedDataInfoList.size() &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(Zygote.ALLOWLISTED_DATA_INFO_MAP); sb.append(\"=\"); boolean started = false; for (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : allowlistedDataInfoList.entrySet()) &#123; if (started) &#123; sb.append(','); &#125; started = true; sb.append(entry.getKey()); sb.append(','); sb.append(entry.getValue().first); sb.append(','); sb.append(entry.getValue().second); &#125; argsForZygote.add(sb.toString()); &#125; if (bindMountAppStorageDirs) &#123; argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS); &#125; if (bindMountAppsData) &#123; argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS); &#125; if (disabledCompatChanges != null &amp;&amp; disabledCompatChanges.length &gt; 0) &#123; StringBuilder sb = new StringBuilder(); sb.append(\"--disabled-compat-changes=\"); int sz = disabledCompatChanges.length; for (int i = 0; i &lt; sz; i++) &#123; if (i != 0) &#123; sb.append(','); &#125; sb.append(disabledCompatChanges[i]); &#125; argsForZygote.add(sb.toString()); &#125; argsForZygote.add(processClass); if (extraArgs != null) &#123; Collections.addAll(argsForZygote, extraArgs); &#125; synchronized(mLock) &#123; // The USAP pool can not be used if the application will not use the systems graphics // driver. If that driver is requested use the Zygote application start path. return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), zygotePolicyFlags, argsForZygote); &#125;&#125; 这个方法的功能就很简单了，就是将各种参数拼装起来，然后调用zygoteSendArgsAndGetResult方法 我们先看openZygoteSocketIfNeeded这个方法，它返回了一个ZygoteState对象，这个类是对与ZygoteServerSocket建立连接后的封装 1234567891011121314151617181920212223242526private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; try &#123; //尝试连接主ZygoteServerSocket attemptConnectionToPrimaryZygote(); //主zygote进程支持此abi if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; if (mZygoteSecondarySocketAddress != null) &#123; // The primary zygote didn't match. Try the secondary. //尝试连接辅ZygoteServerSocket attemptConnectionToSecondaryZygote(); //辅zygote进程支持此abi if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; &#125; &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to zygote\", ioe); &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; attemptConnectionToxxxZygote方法使用LocalSocket进行连接，并返回一个ZygoteState封装对象 我们之前在 Android源码分析 - Zygote进程 中说过，一般，64位的cpu会启动两个zygoto进程，一个64位（主zygote），一个32位（辅zygote） 接下来我们看zygoteSendArgsAndGetResult方法 123456789101112131415161718192021222324252627282930313233private Process.ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, int zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; ... /* * See com.android.internal.os.ZygoteArguments.parseArgs() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ //构建出符合zygote解析规则的参数（argc + argv） String msgStr = args.size() + \"\\n\" + String.join(\"\\n\", args) + \"\\n\"; //USAP机制 if (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123; try &#123; return attemptUsapSendArgsAndGetResult(zygoteState, msgStr); &#125; catch (IOException ex) &#123; // If there was an IOException using the USAP pool we will log the error and // attempt to start the process through the Zygote. Log.e(LOG_TAG, \"IO Exception while communicating with USAP pool - \" + ex.getMessage()); &#125; &#125; return attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);&#125; USAP机制我们先跳过，这个方法就做了一件事：拼装参数，然后调用attemptZygoteSendArgsAndGetResult方法 12345678910111213141516171819202122232425262728private Process.ProcessStartResult attemptZygoteSendArgsAndGetResult( ZygoteState zygoteState, String msgStr) throws ZygoteStartFailedEx &#123; try &#123; final BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter; final DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream; zygoteWriter.write(msgStr); zygoteWriter.flush(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. Process.ProcessStartResult result = new Process.ProcessStartResult(); result.pid = zygoteInputStream.readInt(); result.usingWrapper = zygoteInputStream.readBoolean(); if (result.pid &lt; 0) &#123; throw new ZygoteStartFailedEx(\"fork() failed\"); &#125; return result; &#125; catch (IOException ex) &#123; zygoteState.close(); Log.e(LOG_TAG, \"IO Exception while communicating with Zygote - \" + ex.toString()); throw new ZygoteStartFailedEx(ex); &#125;&#125; 这个方法很明显就能看出来，这是一次socket通信发送 -&gt; 接收 具体zygote进程接收到socket后做了什么可以回顾我之前写的文章 Android源码分析 - Zygote进程 handleProcessStartedLocked向zygote发送完socket请求后，zygote开始forkApp进程，fork完后会将App进程的pid和usingWrapper信息再通过socket传回system_server，此时程序会继续执行handleProcessStartedLocked方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper, long expectedStartSeq, boolean procAttached) &#123; //从待启动列表中移除此ProcessRecord mPendingStarts.remove(expectedStartSeq); final String reason = isProcStartValidLocked(app, expectedStartSeq); //未通过进程启动验证，杀死进程 if (reason != null) &#123; app.pendingStart = false; killProcessQuiet(pid); Process.killProcessGroup(app.uid, app.pid); noteAppKill(app, ApplicationExitInfo.REASON_OTHER, ApplicationExitInfo.SUBREASON_INVALID_START, reason); return false; &#125; ... //记录进程启动 //通知看门狗有进程启动 Watchdog.getInstance().processStarted(app.processName, pid); ... //记录进程启动 //设置ProcessRecord app.setPid(pid); app.setUsingWrapper(usingWrapper); app.pendingStart = false; //从PidMap中获取未清理的ProcessRecord ProcessRecord oldApp; synchronized (mService.mPidsSelfLocked) &#123; oldApp = mService.mPidsSelfLocked.get(pid); &#125; // If there is already an app occupying that pid that hasn't been cleaned up //清理ProcessRecord if (oldApp != null &amp;&amp; !app.isolated) &#123; mService.cleanUpApplicationRecordLocked(oldApp, false, false, -1, true /*replacingPid*/); &#125; //将ProcessRecord添加到PidMap中 mService.addPidLocked(app); synchronized (mService.mPidsSelfLocked) &#123; //attach超时检测 if (!procAttached) &#123; Message msg = mService.mHandler.obtainMessage(PROC_START_TIMEOUT_MSG); msg.obj = app; mService.mHandler.sendMessageDelayed(msg, usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT); &#125; &#125; return true;&#125; 这个方法将从zygote fork后得到的信息设置到ProcessRecord中，然后将此ProcessRecord添加到PidMap中（AMS.mPidsSelfLocked），后续当attachApplication时会用到它 ActivityThreadzygote进程将App进程fork出来后，便通过反射调用我们之前设置的entryPoint类的main方法，即android.app.ActivityThread.main(String[] args)方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static void main(String[] args) &#123; // Install selective syscall interception //设置拦截器，拦截部分系统调用自行处理 AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. //资源关闭检测器 CloseGuard.setEnabled(false); //初始化用户环境 Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates //设置CA证书搜索位置 final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); // Call per-process mainline module initialization. //初始化主模块各个注册服务 initializeMainlineModules(); //预设进程名 Process.setArgV0(\"&lt;pre-initialized&gt;\"); //准备Looper Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format \"seq=114\" //查找startSeq参数 long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; //创建App进程ActivityThread实例 ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); //设置全局Handler if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; //Looper循环处理消息 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 在main方法中主要做了两件事，一是启动Looper，循环处理消息，保证进程不会退出，二是实例化ActivityThread并执行attach方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private void attach(boolean system, long startSeq) &#123; sCurrentActivityThread = this; mConfigurationController = new ConfigurationController(this); mSystemThread = system; if (!system) &#123; //非系统ActivityThread //预设进程名 android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); //处理一些错误异常需要使用ActivityThread，将其传入 RuntimeInit.setApplicationObject(mAppThread.asBinder()); //AMS代理binder对象 final IActivityManager mgr = ActivityManager.getService(); try &#123; //执行AMS.attachApplication方法 mgr.attachApplication(mAppThread, startSeq); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; // Watch for getting close to heap limit. //每次GC时检测内存，如果内存不足则会尝试释放部分不可见的Activity BinderInternal.addGcWatcher(new Runnable() &#123; @Override public void run() &#123; if (!mSomeActivitiesChanged) &#123; return; &#125; Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) &#123; if (DEBUG_MEMORY_TRIM) Slog.d(TAG, \"Dalvik max=\" + (dalvikMax/1024) + \" total=\" + (runtime.totalMemory()/1024) + \" used=\" + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try &#123; ActivityTaskManager.getService().releaseSomeActivities(mAppThread); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125;); &#125; else &#123; //系统ActivityThread ... &#125; //处理ConfigChanged相关逻辑（屏幕旋转之类） ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; &#123; synchronized (mResourcesManager) &#123; // We need to apply this change to the resources immediately, because upon returning // the view hierarchy will be informed about it. if (mResourcesManager.applyConfigurationToResources(globalConfig, null /* compat */)) &#123; mConfigurationController.updateLocaleListFromAppContext( mInitialApplication.getApplicationContext()); // This actually changed the resources! Tell everyone about it. final Configuration updatedConfig = mConfigurationController.updatePendingConfiguration(globalConfig); if (updatedConfig != null) &#123; sendMessage(H.CONFIGURATION_CHANGED, globalConfig); mPendingConfiguration = updatedConfig; &#125; &#125; &#125; &#125;; ViewRootImpl.addConfigCallback(configChangedCallback);&#125; 而attach方法最重要的一步又是调用了AMS的attachApplication方法 AMS.attachApplication123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289public final void attachApplication(IApplicationThread thread, long startSeq) &#123; if (thread == null) &#123; throw new SecurityException(\"Invalid application interface\"); &#125; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid, callingUid, startSeq); Binder.restoreCallingIdentity(origId); &#125;&#125;private boolean attachApplicationLocked(@NonNull IApplicationThread thread, int pid, int callingUid, long startSeq) &#123; // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; long startTime = SystemClock.uptimeMillis(); long bindApplicationTimeMillis; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; //通过pid查找PidMap中存在的ProcessRecord //对应着handleProcessStartedLocked方法中执行的中的mService.addPidLocked方法 //在进程同步启动模式下，这里应该是必能取到的 synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; //如果此ProcessRecord对不上App的ProcessRecord，则将其清理掉 if (app != null &amp;&amp; (app.startUid != callingUid || app.startSeq != startSeq)) &#123; ... // If there is already an app occupying that pid that hasn't been cleaned up cleanUpApplicationRecordLocked(app, false, false, -1, true /*replacingPid*/); removePidLocked(app); app = null; &#125; &#125; else &#123; app = null; &#125; // It's possible that process called attachApplication before we got a chance to // update the internal state. //在进程异步启动模式下，有可能尚未执行到handleProcessStartedLocked方法 //所以从PidMap中无法取到相应的ProcessRecord //这时候从ProcessList.mPendingStarts这个待启动列表中获取ProcessRecord if (app == null &amp;&amp; startSeq &gt; 0) &#123; final ProcessRecord pending = mProcessList.mPendingStarts.get(startSeq); if (pending != null &amp;&amp; pending.startUid == callingUid &amp;&amp; pending.startSeq == startSeq &amp;&amp; mProcessList.handleProcessStartedLocked(pending, pid, pending .isUsingWrapper(), startSeq, true)) &#123; app = pending; &#125; &#125; //没有找到相应的ProcessRecord，杀死进程 if (app == null) &#123; if (pid &gt; 0 &amp;&amp; pid != MY_PID) &#123; killProcessQuiet(pid); &#125; else &#123; try &#123; thread.scheduleExit(); &#125; catch (Exception e) &#123; // Ignore exceptions. &#125; &#125; return false; &#125; // If this application record is still attached to a previous // process, clean it up now. //如果ProcessRecord绑定了其他的ApplicationThread，则需要清理这个进程 if (app.thread != null) &#123; handleAppDiedLocked(app, true, true); &#125; final String processName = app.processName; try &#123; //注册App进程死亡回调 AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; &#125; catch (RemoteException e) &#123; //如果出现异常则重启进程 app.resetPackageList(mProcessStats); mProcessList.startProcessLocked(app, new HostingRecord(\"link fail\", processName), ZYGOTE_POLICY_FLAG_EMPTY); return false; &#125; //初始化ProcessRecord各参数 app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; mOomAdjuster.setAttachingSchedGroupLocked(app); app.forcingToImportant = null; updateProcessForegroundLocked(app, false, 0, false); app.hasShownUi = false; app.setDebugging(false); app.setCached(false); app.killedByAm = false; app.killed = false; // We carefully use the same state that PackageManager uses for // filtering, since we use this flag to decide if we need to install // providers when user is unlocked later app.unlocked = StorageManager.isUserKeyUnlocked(app.userId); //移除之前在handleProcessStartedLocked中设置的attach超时检测 mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); //普通App启动肯定在system_server准备完成后，所以此处为true boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : null; //设置ContentProvider启动超时检测 if (providers != null &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123; Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG); msg.obj = app; mHandler.sendMessageDelayed(msg, ContentResolver.CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS); &#125; final BackupRecord backupTarget = mBackupTargets.get(app.userId); try &#123; //对应着开发者模式里的 Select debug app 和 Wait for debugger int testMode = ApplicationThreadConstants.DEBUG_OFF; if (mDebugApp != null &amp;&amp; mDebugApp.equals(processName)) &#123; testMode = mWaitForDebugger ? ApplicationThreadConstants.DEBUG_WAIT : ApplicationThreadConstants.DEBUG_ON; app.setDebugging(true); if (mDebugTransient) &#123; mDebugApp = mOrigDebugApp; mWaitForDebugger = mOrigWaitForDebugger; &#125; &#125; boolean enableTrackAllocation = false; if (mTrackAllocationApp != null &amp;&amp; mTrackAllocationApp.equals(processName)) &#123; enableTrackAllocation = true; mTrackAllocationApp = null; &#125; // If the app is being launched for restore or full backup, set it up specially boolean isRestrictedBackupMode = false; ... //备份相关 final ActiveInstrumentation instr; ... //自动化测试相关 ApplicationInfo appInfo = instr != null ? instr.mTargetInfo : app.info; app.compat = compatibilityInfoForPackage(appInfo); ProfilerInfo profilerInfo = null; String preBindAgent = null; ... //性能分析相关 // We deprecated Build.SERIAL and it is not accessible to // Instant Apps and target APIs higher than O MR1. Since access to the serial // is now behind a permission we push down the value. //序列号（Android 8.0后不可再通过Build.SERIAL获取序列号） final String buildSerial = (!appInfo.isInstantApp() &amp;&amp; appInfo.targetSdkVersion &lt; Build.VERSION_CODES.P) ? sTheRealBuildSerial : Build.UNKNOWN; ... //自动化测试相关 ... //性能分析相关 //debug模式 if ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0) &#123; thread.attachStartupAgents(app.info.dataDir); &#125; ... //自动填充功能（账号密码等） ... //内容捕获相关（ContentCaptureManager） //自动化测试 final ActiveInstrumentation instr2 = app.getActiveInstrumentation(); if (mPlatformCompat != null) &#123; mPlatformCompat.resetReporting(app.info); &#125; final ProviderInfoList providerList = ProviderInfoList.fromList(providers); //调用ApplicationThread.bindApplication方法 if (app.isolatedEntryPoint != null) &#123; // This is an isolated process which should just call an entry point instead of // being bound to an application. thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs); &#125; else if (instr2 != null) &#123; thread.bindApplication(processName, appInfo, providerList, instr2.mClass, profilerInfo, instr2.mArguments, instr2.mWatcher, instr2.mUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.mDisabledCompatChanges); &#125; else &#123; thread.bindApplication(processName, appInfo, providerList, null, profilerInfo, null, null, null, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.isPersistent(), new Configuration(app.getWindowProcessController().getConfiguration()), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked(), buildSerial, autofillOptions, contentCaptureOptions, app.mDisabledCompatChanges); &#125; ... // Make app active after binding application or client may be running requests (e.g // starting activities) before it is ready. //ProcessRecord保存ApplicationThread代理对象 app.makeActive(thread, mProcessStats); //更新进程使用情况 mProcessList.updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); &#125; catch (Exception e) &#123; //出现错误，杀死进程 app.resetPackageList(mProcessStats); app.unlinkDeathRecipient(); app.kill(\"error during bind\", ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, true); handleAppDiedLocked(app, false, true); return false; &#125; // Remove this record from the list of starting applications. //从persistent启动列表中移除此ProcessRecord //persistent是manifest中application标签下的一个属性 //设置了此属性代表此App会跟随系统启动而启动 mPersistentStartingProcesses.remove(app); boolean badApp = false; boolean didSomething = false; // See if the top visible activity is waiting to run in this process... //检查是否有Activity等待启动 if (normalMode) &#123; try &#123; didSomething = mAtmInternal.attachApplication(app.getWindowProcessController()); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Find any services that should be running in this process... //检查是否有Services等待启动 if (!badApp) &#123; try &#123; didSomething |= mServices.attachApplicationLocked(app, processName); &#125; catch (Exception e) &#123; badApp = true; &#125; &#125; // Check if a next-broadcast receiver is in this process... //检查是否有广播接收器需要启动 if (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123; try &#123; didSomething |= sendPendingBroadcastsLocked(app); &#125; catch (Exception e) &#123; // If the app died trying to launch the receiver we declare it 'bad' badApp = true; &#125; &#125; ... //备份相关 //以上几步发生异常，杀死App进程 if (badApp) &#123; app.kill(\"error during init\", ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, true); handleAppDiedLocked(app, false, true); return false; &#125; if (!didSomething) &#123; //更新进程OOM等级 updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN); &#125; return true;&#125; 总结一下这个方法主要做了哪些事，首先获取ProcessRecord，然后对其做一些初始化设置，然后调用ApplicaionThread.bindApplication方法，最后分别检查处理Activity、Service和BroadcastReceiver的启动 获取ProcessRecord我们看一下这个方法是怎么获取ProcessRecord的，我们先回顾一下之前在startProcessLocked方法的最后，会使用同步或异步的方式启动进程，最终两者都会调用startProcess和handleProcessStartedLocked方法 同步启动进程我们回顾一下之前讲到的ActivityManagerInternal.startProcess方法，可以发现它内部使用了synchronized (ActivityManagerService.this)加锁，而AMS.attachApplication方法同样也使用了AMS实例对象加了锁，所以在同步启动进程的情况下，必然会先执行handleProcessStartedLocked方法，再执行attachApplication方法，根据之前所分析的，handleProcessStartedLocked方法会将ProcessRecord存到PidMap中，然后attachApplication方法又会从PidMap中去取，此时取出的ProcessRecord必然不为null 异步启动进程在异步启动进程的情况下，是通过Handler将启动进程的工作插入到任务队列中，这个任务的执行是不在锁的作用域范围内的，在这个任务内没有对startProcess方法加锁，只对handleProcessStartedLocked方法加了锁，所以这里会有两种情况： 先执行handleProcessStartedLocked方法，再执行attachApplication方法 这种情况和同步启动进程的执行顺序是一样的，ProcessRecord获取方式也相同 先执行attachApplication方法，再执行handleProcessStartedLocked方法 这种情况下，PidMap中取不到相应的ProcessRecord，此时ProcessList.mPendingStarts中还没有将ProcessRecord移除，所以会从mPendingStarts这个启动列表中取出ProcessRecord，然后再调用handleProcessStartedLocked方法，等到attachApplication方法走完，锁释放后，在进入到外部的handleProcessStartedLocked重载方法，这个方法会先判断mPendingStarts中是否还存在对应的ProcessRecord，如果不存在，便会直接返回，保证handleProcessStartedLocked方法只执行一次 ApplicationThread.bindApplication接着，我们继续看重点方法ApplicationThread.bindApplication ApplicationThread是ActivityThread的一个内部类 1234567891011121314151617181920212223242526272829303132333435363738394041public final void bindApplication(String processName, ApplicationInfo appInfo, ProviderInfoList providerList, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map services, Bundle coreSettings, String buildSerial, AutofillOptions autofillOptions, ContentCaptureOptions contentCaptureOptions, long[] disabledCompatChanges) &#123; if (services != null) &#123; ... // Setup the service cache in the ServiceManager //初始化通用系统服务缓存 ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providerList.getList(); data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableBinderTracking = enableBinderTracking; data.trackAllocation = trackAllocation; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; data.buildSerial = buildSerial; data.autofillOptions = autofillOptions; data.contentCaptureOptions = contentCaptureOptions; data.disabledCompatChanges = disabledCompatChanges; sendMessage(H.BIND_APPLICATION, data);&#125; 这个方法很简单，只是将参数包装成一个AppBindData，然后通过Handler发送消息处理，根据消息的类型，最终会调用ActivityThread.handleBindApplication方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379private void handleBindApplication(AppBindData data) &#123; // Register the UI Thread as a sensitive thread to the runtime. //将UI线程注册成JIT敏感线程 VMRuntime.registerSensitiveThread(); ... mProfiler = new Profiler(); ... //性能分析相关 // send up app name; do this *before* waiting for debugger //设置进程名 Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName, data.appInfo.packageName, UserHandle.myUserId()); VMRuntime.setProcessPackageName(data.appInfo.packageName); // Pass data directory path to ART. This is used for caching information and // should be set before any application code is loaded. //设置进程数据目录 VMRuntime.setProcessDataDirectory(data.appInfo.dataDir); //性能分析相关 if (mProfiler.profileFd != null) &#123; mProfiler.startProfiling(); &#125; // If the app is Honeycomb MR1 or earlier, switch its AsyncTask // implementation to use the pool executor. Normally, we use the // serialized executor as the default. This has to happen in the // main thread so the main looper is set right. //当App的targetSdkVersion小于等于 3.1 (12) 时，AsyncTask使用线程池实现 if (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123; AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR); &#125; // Let the util.*Array classes maintain \"undefined\" for apps targeting Pie or earlier. //当App的targetSdkVersion大于等于 10 (29) 时，针对Android SDK提供的容器（SparseArray等） //如果index越界，会主动抛ArrayIndexOutOfBoundsException异常 //（之前数组越界的行为未被定义） UtilConfig.setThrowExceptionForUpperArrayOutOfBounds( data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.Q); //当App的targetSdkVersion大于等于 5.0 (21) 时，回收正在使用的Message会抛出异常 Message.updateCheckRecycle(data.appInfo.targetSdkVersion); // Prior to P, internal calls to decode Bitmaps used BitmapFactory, // which may scale up to account for density. In P, we switched to // ImageDecoder, which skips the upscale to save memory. ImageDecoder // needs to still scale up in older apps, in case they rely on the // size of the Bitmap without considering its density. ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion; /* * Before spawning a new process, reset the time zone to be the system time zone. * This needs to be done because the system time zone could have changed after the * the spawning of this process. Without doing this this process would have the incorrect * system time zone. */ //设置时区 TimeZone.setDefault(null); /* * Set the LocaleList. This may change once we create the App Context. */ LocaleList.setDefault(data.config.getLocales()); //更新Configuration synchronized (mResourcesManager) &#123; /* * Update the system configuration since its preloaded and might not * reflect configuration changes. The configuration object passed * in AppBindData can be safely assumed to be up to date */ mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo); mCurDefaultDisplayDpi = data.config.densityDpi; // This calls mResourcesManager so keep it within the synchronized block. applyCompatConfiguration(mCurDefaultDisplayDpi); &#125; //获取LoadedApk data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); //性能分析器代理JVM（JVMTI） if (agent != null) &#123; handleAttachAgent(agent, data.info); &#125; /** * Switch this process to density compatibility mode if needed. */ //在manifest，supports-screens标签中设置了android:anyDensity //详见：https://developer.android.com/guide/topics/manifest/supports-screens-element#any if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) &#123; //指示App包含用于适应任何屏幕密度的资源 mDensityCompatMode = true; Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT); &#125; //设置默认密度 updateDefaultDensity(); /* 设置 12/24 小时时间制 */ final String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24); Boolean is24Hr = null; if (use24HourSetting != null) &#123; is24Hr = \"24\".equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE; &#125; // null : use locale default for 12/24 hour formatting, // false : use 12 hour format, // true : use 24 hour format. DateFormat.set24HourTimePref(is24Hr); //更新view debug属性sDebugViewAttributes //设置了这个属性，View将会保存它本身的属性 //和Layout Inspector相关 updateDebugViewAttributeState(); //初始化默认线程策略 StrictMode.initThreadDefaults(data.appInfo); //初始化默认VM策略 StrictMode.initVmDefaults(data.appInfo); //debug模式 if (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) &#123; // XXX should have option to change the port. Debug.changeDebugPort(8100); if (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" is waiting for the debugger on port 8100...\"); IActivityManager mgr = ActivityManager.getService(); try &#123; mgr.showWaitingForDebugger(mAppThread, true); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; Debug.waitForDebugger(); try &#123; mgr.showWaitingForDebugger(mAppThread, false); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; else &#123; Slog.w(TAG, \"Application \" + data.info.getPackageName() + \" can be debugged on port 8100...\"); &#125; &#125; // Allow binder tracing, and application-generated systrace messages if we're profileable. //性能分析模式 boolean isAppProfileable = data.appInfo.isProfileableByShell(); //允许应用程序跟踪 Trace.setAppTracingAllowed(isAppProfileable); if ((isAppProfileable || Build.IS_DEBUGGABLE) &amp;&amp; data.enableBinderTracking) &#123; Binder.enableTracing(); &#125; // Initialize heap profiling. //初始化堆分析 if (isAppProfileable || Build.IS_DEBUGGABLE) &#123; nInitZygoteChildHeapProfiling(); &#125; // Allow renderer debugging features if we're debuggable. boolean isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != 0; //开启硬件加速调试功能 HardwareRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE); HardwareRenderer.setPackageName(data.appInfo.packageName); /** * Initialize the default http proxy in this process for the reasons we set the time zone. */ //设置默认HTTP代理 final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE); if (b != null) &#123; // In pre-boot mode (doing initial launch to collect password), not // all system is up. This includes the connectivity service, so don't // crash if we can't get it. final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); try &#123; Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(null)); &#125; catch (RemoteException e) &#123; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); throw e.rethrowFromSystemServer(); &#125; &#125; // Instrumentation info affects the class loader, so load it before // setting up the app context. //准备自动化测试信息 final InstrumentationInfo ii; if (data.instrumentationName != null) &#123; try &#123; ii = new ApplicationPackageManager( null, getPackageManager(), getPermissionManager()) .getInstrumentationInfo(data.instrumentationName, 0); &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException( \"Unable to find instrumentation info for: \" + data.instrumentationName); &#125; // Warn of potential ABI mismatches. ... mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii); mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); &#125; else &#123; ii = null; &#125; //创建Context final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); //更新区域列表 updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); if (!Process.isIsolated()) &#123; final int oldMask = StrictMode.allowThreadDiskWritesMask(); try &#123; setupGraphicsSupport(appContext); &#125; finally &#123; StrictMode.setThreadPolicyMask(oldMask); &#125; &#125; else &#123; HardwareRenderer.setIsolatedProcess(true); &#125; // Install the Network Security Config Provider. This must happen before the application // code is loaded to prevent issues with instances of TLS objects being created before // the provider is installed. //网络安全设置 NetworkSecurityConfigProvider.install(appContext); // Continue loading instrumentation. if (ii != null) &#123; //如果设置了自动化测试，实例化指定的自动化测试类 ApplicationInfo instrApp; try &#123; instrApp = getPackageManager().getApplicationInfo(ii.packageName, 0, UserHandle.myUserId()); &#125; catch (RemoteException e) &#123; instrApp = null; &#125; if (instrApp == null) &#123; instrApp = new ApplicationInfo(); &#125; ii.copyTo(instrApp); instrApp.initForUser(UserHandle.myUserId()); final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); // The test context's op package name == the target app's op package name, because // the app ops manager checks the op package name against the real calling UID, // which is what the target package name is associated with. final ContextImpl instrContext = ContextImpl.createAppContext(this, pi, appContext.getOpPackageName()); try &#123; final ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException( \"Unable to instantiate instrumentation \" + data.instrumentationName + \": \" + e.toString(), e); &#125; final ComponentName component = new ComponentName(ii.packageName, ii.name); mInstrumentation.init(this, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) &#123; mProfiler.handlingProfiling = true; final File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); &#125; &#125; else &#123; //直接实例化Instrumentation mInstrumentation = new Instrumentation(); mInstrumentation.basicInit(this); &#125; //调整应用可用内存上限 if ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != 0) &#123; dalvik.system.VMRuntime.getRuntime().clearGrowthLimit(); &#125; else &#123; // Small heap, clamp to the current growth limit and let the heap release // pages after the growth limit to the non growth limit capacity. b/18387825 dalvik.system.VMRuntime.getRuntime().clampGrowthLimit(); &#125; // Allow disk access during application and provider setup. This could // block processing ordered broadcasts, but later processing would // probably end up doing the same disk access. Application app; final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites(); final StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy(); try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. //创建Application app = data.info.makeApplication(data.restrictedBackupMode, null); // Propagate autofill compat state //设置自动填充功能 app.setAutofillOptions(data.autofillOptions); // Propagate Content Capture options //设置内容捕获功能 app.setContentCaptureOptions(data.contentCaptureOptions); mInitialApplication = app; // don't bring up providers in restricted mode; they may depend on the // app's custom Application class //在非受限模式下启动ContentProvider if (!data.restrictedBackupMode) &#123; if (!ArrayUtils.isEmpty(data.providers)) &#123; installContentProviders(app, data.providers); &#125; &#125; // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. //执行onCreate方法（默认Instrumentation实现为空方法） try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; catch (Exception e) &#123; ... &#125; //执行Application的onCreate方法 try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; finally &#123; // If the app targets &lt; O-MR1, or doesn't change the thread policy // during startup, clobber the policy to maintain behavior of b/36951662 if (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1 || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123; StrictMode.setThreadPolicy(savedPolicy); &#125; &#125; // Preload fonts resources //预加载字体资源 FontsContract.setApplicationContextForResources(appContext); if (!Process.isIsolated()) &#123; try &#123; final ApplicationInfo info = getPackageManager().getApplicationInfo( data.appInfo.packageName, PackageManager.GET_META_DATA /*flags*/, UserHandle.myUserId()); if (info.metaData != null) &#123; final int preloadedFontsResource = info.metaData.getInt( ApplicationInfo.METADATA_PRELOADED_FONTS, 0); if (preloadedFontsResource != 0) &#123; data.info.getResources().preloadFonts(preloadedFontsResource); &#125; &#125; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125;&#125; 这个方法很重要，我们先过一下几个重点部分，然后再按着主线继续往下研究： Debug、Profiler、Layout Inspector Android应用开发的同学对这三样肯定不陌生，在Android Studio中我们可以对App进行调试，性能分析和布局检查，在这个方法中，我们可以找到与这三样相关的一些代码 获取LoadedApk LoadedApk是Apk文件在内存中的表示，包含了Apk文件中的代码、资源、组件、manifest等信息 创建Context 这里通过ActivityThread和LoadedApk创建出了一个ContextImpl 实例化Instrumentation 这里和自动化测试相关，如果设置了自动化测试，实例化指定的自动化测试类，否则实例化默认的Instrumentation 创建Application 这里根据LoadedApk创建出相应的Application，需要注意，这里创建的Application并不与上面创建出的ContextImpl绑定，而是在创建Application的过程中，以同样的参数重新创建了一个ContextImpl，然后调用attachBaseContext方法绑定它 设置HTTP代理 App在启动过程中设置HTTP代理，所以我们在开发过程中使用代理抓包等时候需要注意，设置了代理后需要重启App才会生效 启动ContentProvider ContentProvider的启动过程以后会新开文章进行分析，这里只需要知道ContentProvider启动的入口在这就行了 执行Application的onCreate方法 当创建完Application，执行attachBaseContext方法后，便会调用onCreate方法 我们拣重点来看，首先是Application的创建过程 LoadedApk.makeApplication在上文的方法中，调用了data.info.makeApplication方法创建Application，其中data.info为LoadedApk类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; //如果之前创建过了就可以直接返回 if (mApplication != null) &#123; return mApplication; &#125; Application app = null; //获取Application类名（App可以自定义Application这个应该所有开发都知道吧） //对应AndroidManifest中application标签下的android:name属性 String appClass = mApplicationInfo.className; //没有设置自定义Application或强制使用默认Application的情况下，使用默认Application if (forceDefaultAppClass || (appClass == null)) &#123; appClass = \"android.app.Application\"; &#125; try &#123; //初始化ContextClassLoader final java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(\"android\")) &#123; initializeJavaContextClassLoader(); &#125; // Rewrite the R 'constants' for all library apks. //Android共享库资源ID动态映射 SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers( false, false); for (int i = 0, n = packageIdentifiers.size(); i &lt; n; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(cl, packageIdentifiers.valueAt(i), id); &#125; //创建Context ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); // The network security config needs to be aware of multiple // applications in the same process to handle discrepancies //网络安全设置 NetworkSecurityConfigProvider.handleNewApplication(appContext); //创建Application app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; ... &#125; //加入Application列表中（多个App可以运行在同一个进程中） mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; //调用Application的OnCreate方法 try &#123; instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; ... &#125; &#125; return app;&#125; 这个方法首先尝试取成员变量mApplication，如果不为null，说明曾创建过，直接返回就可以了 然后再去获取Application类名，默认为android.app.Application，开发可以通过设置AndroidManifest中application标签下的android:name属性来选择创建自定义的Application 然后对共享库资源ID做动态映射，关于这部分感兴趣的同学可以去搜索Android Dynamic Reference 接着创建出ContextImpl作为Application的BaseContext，Application继承自ContextWrapper，而ContextWrapper又继承自Context，ContextWrapper是对Context的包装，里面有一个mBase成员变量，调用任何方法实际上都是调用mBase这个实例的方法，在Application创建后会调用attachBaseContext将刚刚创建出来的ContextImpl赋值给mBase成员变量，所以调用Application中的任何Context方法，实际上最终都是调用ContextImpl的方法 然后创建Application，并将其设置成ContextImpl的OuterContext 最后将创建好的Application设置给成员变量mApplication，方便以后获取，然后将其再添加到mActivityThread.mAllApplications列表中，返回 ContextImpl.createAppContext我们简单看一下ContextImpl的创建，对于不同的组件，创建ContextImpl对象的方法不同，比如说Activity的Context是通过createActivityContext方法创建的，我们这里是通过createAppContext创建Application的Context的 123456789101112131415static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123; return createAppContext(mainThread, packageInfo, null);&#125;static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo, String opPackageName) &#123; if (packageInfo == null) throw new IllegalArgumentException(\"packageInfo\"); ContextImpl context = new ContextImpl(null, mainThread, packageInfo, ContextParams.EMPTY, null, null, null, null, null, 0, null, opPackageName); context.setResources(packageInfo.getResources()); //检查android.permission.STATUS_BAR_SERVICE权限 context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI : CONTEXT_TYPE_NON_UI; return context;&#125; 简单看看就好，我们的重点不在这里，这个方法实例化了一个ContextImpl对象，然后通过ResourcesManager获得Apk的Resource，将其设置到ContextImpl中 Instrumentation.newApplication接着我们来看一下Application是怎么创建的 12345678public Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Application app = getFactory(context.getPackageName()) .instantiateApplication(cl, className); app.attach(context); return app;&#125; 这里，getFactory方法返回的是一个AppComponentFactory对象，这个类是在Android 9之后加入的，它包括一个实例化ClassLoader的方法，一个实例化Application的方法和四个实例化四大组件的方法 我们可以在AndroidManifest中设置application标签的android:appComponentFactory属性，将其设置成我们自定义的AppComponentFactory，从而进行一些监控或别的操作 我们看一下AppComponentFactory的默认实现是怎样的 12345public @NonNull Application instantiateApplication(@NonNull ClassLoader cl, @NonNull String className) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Application) cl.loadClass(className).newInstance();&#125; 可以看到非常简单，就是通过className反射实例化出一个Application 接着我们回到newApplication方法中，我们对新创建的Application调用了attach方法去绑定ContextImpl 1234/* package */ final void attach(Context context) &#123; attachBaseContext(context); mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;&#125; 这里的attachBaseContext调用的是父类ContextWrapper中的方法 123456protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException(\"Base context already set\"); &#125; mBase = base;&#125; 可以看到，就是将ContextImpl赋值给ContextWrapper中的mBase赋值，这样后面对Application调用Context的方法，实际上就是代理给这个mBase去执行了 到这一步位置，Application就创建完成了，接下来在ActivityThread.handleBindApplication方法中，还有一步重要操作，就是调用Application的onCreate方法 这里是借助了Instrumentation.callApplicationOnCreate方法 123public void callApplicationOnCreate(Application app) &#123; app.onCreate();&#125; 就是简简单单直接调用了Application的onCreate方法 结束到这里为止，整个Application的工作都做完了，接下来还剩检查并启动Activity、Service和BroadcastReceiver，这些内容就放到下一篇再讲吧 话说回来有点惭愧，这篇文章距离上一篇间隔了三个月，最近在忙一些别的项目，这篇文章断断续续写了一个多月才憋出来，感谢大家的支持，在这里我厚着脸皮求点赞求收藏，大家的支持就是我创作的动力","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"}]},{"title":"Android交叉编译OpenCV+FFmpeg+x264的艰难历程","slug":"android/compile/Android交叉编译OpenCV+FFmpeg+x264的艰难历程","date":"2022-09-14T06:55:13.000Z","updated":"2022-11-13T09:55:54.358Z","comments":true,"path":"2022/09/14/android/compile/Android交叉编译OpenCV+FFmpeg+x264的艰难历程/","link":"","permalink":"http://yoursite.com/2022/09/14/android/compile/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV+FFmpeg+x264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/","excerpt":"","text":"前言如果你没有兴趣看完本文，只想获得可编译的代码或编译后的产物，可以直接点击下面的链接，跟随步骤编译代码或直接下载我编译好的产物 注：编译顺序要按照 x264 -&gt; FFmpeg -&gt; OpenCV 这样来 x264 FFmpeg OpenCV 起因最近在做一个视频生成的app，使用OpenCV库实现，用的是C语言，一开始我是在mac_x86上书写代码，fourcc视频编码器选择的是mp4v，视频输出一切正常，然后当我将代码移植到Android上时发现，从OpenCV官网下载的so库它不支持编码mp4v格式，只能编码成mjpg格式，后缀名为avi，尴尬的是Android原生又不支持播放这种格式的视频，所以要想办法让OpenCV支持编码mp4v或h264等格式 我在网上搜索了一下为什么OpenCV默认不支持h264格式，得知OpenCV默认使用FFmpeg做视频处理，FFmpeg使用的是LGPL协议，而x264使用的是GPL协议，GPL协议具有传染性，如果代码中使用了GPL协议的软件，则要求你的代码也必须开源。我猜测是因为这个原因，FFmpeg默认不使用GPL协议的软件，避免产生一些不必要的问题和纠纷，如果想要使用GPL协议的软件，则需要在编译的时候加上--enable-gpl选项 基于此上原因，我开启了我艰难的编译之路 声明本篇文章只针对Linux系统编译，其他系统不保证可以编译通过 本篇文章使用的NDK版本为21.4.7075529，不同的版本可能会有些差别，需要自行调整 本人对c/c++编译这块并不是很了解，很多东西也是边学习边尝试的，如果有什么错误的话也恳请大佬们指正，谢谢 准备准备一台Linux系统的电脑或使用虚拟机，安装一些最基本的编译工具（make、cmake等），我使用的是Ubuntu系统，强烈建议在安装的时候选择完整安装，这样这些编译工具应该都会跟随系统自动安装好 Android交叉编译肯定是需要NDK的，我使用的是21.4.7075529版本，r19以上版本的NDK都是直接自带了工具链，而r19之前的版本则需要先生成工具链，具体可以参考独立工具链（已弃用）这篇文档 x264既然需要依赖x264，那我们肯定是先要编译x264库，各位可以clone我准备好的tag 1git clone -b v0.164_compilable https://github.com/dreamgyf/x264.git 这个版本是从原x264镜像仓库的stable分支切出的，版本为0.164。想知道x264版本的话，可以运行其目录下的version.sh脚本，它会输出三串数字，前面的164是在x264.h中定义的X264_BUILD，第二个3095+4表示master分支的提交数 + master分支到HEAD的提交数，最后的一串数字表示当前分支最新的commit id 在构建编译脚本之前，我们先要看看这个库提供了哪些编译选项，我们可以看到在x264根目录下有一个configure文件，这是一个脚本文件，大多数库都提供了这个脚本，用来负责生成Makefile，准备好构建环境，我们可以通过下面这个命令获取帮助文件 1./configure --help &gt; help.txt 可以看到，里面提供了一些编译选项及其描述，我们可以根据这些选项和描述构建编译脚本 先看一下我写好的脚本吧 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# Linux 交叉编译 Android 库脚本if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang export CFLAGS=\"-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security -O0 -DNDEBUG -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;\" ../../configure \\ --host=$&#123;TRIPLE&#125; \\ --prefix=$PREFIX \\ --enable-static \\ --enable-shared \\ --enable-pic \\ --disable-lavf \\ --sysroot=$TOOLCHAIN/sysroot make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd ..&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do build $arch breakdone 这也是我其他库编译脚本的基本结构，首先需要ANDROID_NDK环境变量用来确定NDK的位置 OUTPUT_DIR为编译的输出路径，我这里命名为_output_，防止和源码本身的目录重名 API为最低支持的Android API版本，我这里写的21，也就是Android 5.0 TOOLCHAIN为交叉编译工具链的路径，对于r19之前的NDK，需要将其改为你生成出来的工具链的路径，r19之后不需要改动 我这里定义了一个build函数，通过输入的ABI编译出对应架构的产物。ABI总共有四种：armeabi-v7a，arm64-v8a，x86，x86-64，这个决定你的App能在哪些平台架构上运行 这里，我通过不同的ABI定义了不同的TRIPLE变量，这是遵循了NDK工具链的命名规则，可以在 将 NDK 与其他构建系统配合使用 这篇文档中找到 在$TOOLCHAIN/bin目录下，我们也能发现这种命名方式 我们需要根据其命名规则，指定相应的编译器，设置相应的host，target 关于build、host和target的含义可以参阅 Cross-Compilation 这篇文档 build: 编译该库所使用的平台，不设置的话，编译器会自动推测所在平台 host: 编译出的库要运行在哪个平台上，不设置的话，默认为build值，但这样也就不再是交叉编译了 target: 该库所处理的目标平台，不设置的话，默认为host值 多数UNIX平台会通过CC调用C语言编译器，而CFLAGS则是C语言编译器的编译选项，根据我们上文所说的命名规则可以发现，工具链中C语言编译器的命名规则为${TRIPLE}${API}-clang，假设我们要编译arm64-v8a ABI，API 21的库，则需要指定CC为aarch64-linux-android21-clang 至于CFLAGS这里就不多说了，可以自行查阅 Clang编译器参数手册 ，这里需要注意的是，必须要指定--gcc-toolchain和--target，否则编译会报错 然后就是configure的选项了，这里必须指定--host和--sysroot，sysroot表示使用这个值作为编译的头文件和库文件的查找目录，该目录结构如下 12345678sysroot└── usr ├── include └── lib ├── aarch64-linux-android ├── arm-linux-androideabi ├── i686-linux-android └── x86_64-linux-android --prefix为编译后的安装路径，也就是编译产物的输出路径 --enable-static和--enable-shared选项表示生成静态库和动态库，大家可以根据情况自行选择 nproc是Linux下的一个命令，表示当前进程可用的CPU核数，一般make使用线程数为CPU核数就可以了，如果编译产生问题，可以尝试调小这个值 到这里基本上整个构建脚本就分析完了，大家调整完编译选项后保存，就可以执行命令./build.sh开始编译了 FFmpeg然后我们开始编译FFmpeg 1git clone -b v5.0_compilable https://github.com/dreamgyf/FFmpeg.git 这个版本是从原FFmpeg镜像仓库的n5.0分支切出的，版本为5.0。其实我一开始用的是5.1版本，但当我解决了各种问题编译OpenCV到一半时，提示我FFmpeg的一些符号找不到，然后我去查了一下OpenCV的 Change Log ，发现它的最新版本4.6.0刚刚支持FFmpeg 5.0版本，无奈切到5.0重新编译 还是一样，先看编译脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Linux 交叉编译 Android 库脚本if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"ROOT_PATH=`pwd`OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64# 编译出的x264库地址X264_ANDROID_DIR=/home/dreamgyf/compile/x264/_output_/productEXTRA_CONFIGURATIONS=\"--disable-stripping \\ --disable-ffmpeg \\ --disable-doc \\ --disable-appkit \\ --disable-avfoundation \\ --disable-coreimage \\ --disable-amf \\ --disable-audiotoolbox \\ --disable-cuda-llvm \\ --disable-cuvid \\ --disable-d3d11va \\ --disable-dxva2 \\ --disable-ffnvcodec \\ --disable-nvdec \\ --disable-nvenc \\ --disable-vdpau \\ --disable-videotoolbox\"function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang export CFLAGS=\"-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security -O0 -DNDEBUG -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;\" ../../configure \\ --prefix=$PREFIX \\ --enable-cross-compile \\ --sysroot=$TOOLCHAIN/sysroot \\ --cc=$CC \\ --enable-static \\ --enable-shared \\ --disable-asm \\ --enable-gpl \\ --enable-libx264 \\ --extra-cflags=\"-I$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/include\" \\ --extra-ldflags=\"-L$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib\" \\ $EXTRA_CONFIGURATIONS make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd $PREFIX `$ROOT_PATH/ffmpeg-config-gen.sh $&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib/libx264.a` cd $OUTPUT_PATH&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do build $arch breakdone 这个脚本和x264的编译脚本基本相同，由于我们需要依赖x264库，所以我们要使刚刚编译出来的x264产物参与FFmpeg的编译，为此，需要将X264_ANDROID_DIR改成自己编译出来的x264产物路径 在configure选项中，我们需要--enable-cross-compile选项表示开启交叉编译，我们这里需要设置--cc选择C语言编译器，否则编译时会使用系统默认的编译器，--disable-asm选项我测试是必须要带上的，否则编译会报错，然后就是--enable-libx264开启x264依赖了，根据我在起因中说到的开源协议问题，所以--enable-gpl选项也要开启，最后需要指定x264的头文件和库文件目录，分别使用--extra-cflags和--extra-ldflags加上对应的参数 这里提一下，编译器会优先从-I -L两个参数指定的目录中去查找头文件和库文件，如果没找到的话再会从sysroot目录中查找 最后，我还写了一个ffmpeg-config-gen.sh脚本，它的作用是生成ffmpeg-config.cmake文件，用来给OpenCV编译提供FFmpeg依赖查找，这个等我们后面讲到OpenCV依赖FFmpeg的处理时再说 和x264一样，大家调整完编译选项后保存，就可以执行命令./build.sh开始编译了 OpenCV最后，我们开始编译OpenCV 1git clone -b v4.6.0_compilable https://github.com/dreamgyf/opencv.git 这个版本是从原OpenCV仓库的4.6.0分支切出的，版本为4.6.0，是目前的最新版本。其实前面两个库的编译都挺顺利的，最麻烦的问题都出在OpenCV这里 我们还是先看编译脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Linux 交叉编译 Android 库脚本if [[ -z $ANDROID_NDK ]]; then echo 'Error: Can not find ANDROID_NDK path.' exit 1fiecho \"ANDROID_NDK path: $&#123;ANDROID_NDK&#125;\"OUTPUT_DIR=\"_output_\"mkdir $&#123;OUTPUT_DIR&#125;cd $&#123;OUTPUT_DIR&#125;OUTPUT_PATH=`pwd`API=21TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64# 编译出的ffmpeg库地址FFMPEG_ANDROID_DIR=/home/dreamgyf/compile/FFmpeg/_output_/productEXTRA_ATTRS=\"-DWITH_CUDA=OFF \\ -DWITH_GTK=OFF \\ -DWITH_1394=OFF \\ -DWITH_GSTREAMER=OFF \\ -DWITH_LIBV4L=OFF \\ -DWITH_TIFF=OFF \\ -DBUILD_OPENEXR=OFF \\ -DWITH_OPENEXR=OFF \\ -DBUILD_opencv_ocl=OFF \\ -DWITH_OPENCL=OFF\"function build &#123; ABI=$1 if [[ $ABI == \"armeabi-v7a\" ]]; then ARCH=\"arm\" TRIPLE=\"armv7a-linux-androideabi\" TOOLCHAIN_NAME=\"arm-linux-androideabi\" elif [[ $ABI == \"arm64-v8a\" ]]; then ARCH=\"arm64\" TRIPLE=\"aarch64-linux-android\" TOOLCHAIN_NAME=\"aarch64-linux-android\" elif [[ $ABI == \"x86\" ]]; then ARCH=\"x86\" TRIPLE=\"i686-linux-android\" TOOLCHAIN_NAME=\"i686-linux-android\" elif [[ $ABI == \"x86-64\" ]]; then ARCH=\"x86_64\" TRIPLE=\"x86_64-linux-android\" TOOLCHAIN_NAME=\"x86_64-linux-android\" else echo \"Unsupported ABI $&#123;ABI&#125;!\" exit 1 fi echo \"Build ABI $&#123;ABI&#125;...\" rm -rf $&#123;ABI&#125; mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125; PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI cmake ../.. \\ -DCMAKE_INSTALL_PREFIX=$PREFIX \\ -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \\ -DANDROID_ABI=$ABI \\ -DANDROID_NDK=$ANDROID_NDK \\ -DANDROID_PLATFORM=\"android-$&#123;API&#125;\" \\ -DANDROID_LINKER_FLAGS=\"-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API\" \\ -DBUILD_ANDROID_PROJECTS=OFF \\ -DBUILD_ANDROID_EXAMPLES=OFF \\ -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS \\ -DWITH_FFMPEG=ON \\ -DOPENCV_GENERATE_PKGCONFIG=ON \\ -DOPENCV_FFMPEG_USE_FIND_PACKAGE=ON \\ -DFFMPEG_DIR=$&#123;FFMPEG_ANDROID_DIR&#125;/$&#123;ABI&#125; \\ $EXTRA_ATTRS make clean &amp;&amp; make -j`nproc` &amp;&amp; make install cd ..&#125;echo \"Select arch:\"select arch in \"armeabi-v7a\" \"arm64-v8a\" \"x86\" \"x86-64\"do echo \"Select build static or shared libs:\" select type in \"static\" \"shared\" do if [[ $type == \"static\" ]]; then BUILD_SHARED_LIBS=OFF elif [[ $type == \"shared\" ]]; then BUILD_SHARED_LIBS=ON else BUILD_SHARED_LIBS=OFF fi break done build $arch breakdone 上面的准备工作和前面的几个脚本一样，不同的是，OpenCV并没有为我们准备configure脚本，所以这次我们使用cmake生成Makefile，再进行编译 既然使用cmake了，我们就可以不再像之前一样，自己指定编译器等工具链了，NDK为我们提供了交叉编译工具链cmake脚本$ANDROID_NDK/build/cmake/android.toolchain.cmake，我们只需要指定其为CMAKE_TOOLCHAIN_FILE，然后为其提供相关参数即可，具体的使用方式可以参考 CMake 这篇文档。我们这里只需要提供最低限度的几个参数ANDROID_ABI、ANDROID_NDK、ANDROID_PLATFORM即可 如果需要编译Android示例工程的话，还需要在环境变量中设置ANDROID_HOME和ANDROID_SDK，我这里就直接使用-DBUILD_ANDROID_PROJECTS=OFF和-DBUILD_ANDROID_EXAMPLES=OFF将其关闭了 然后就是如何让OpenCV依赖我们编译的FFmpeg的问题了，到这一步我们就需要去它的CMakeLists.txt中看看它是怎样声明FFmpeg的了 打开CMakeLists.txt文件，搜索FFMPEG关键字，我们可以找到这一段代码 1234567891011121314if(WITH_FFMPEG OR HAVE_FFMPEG) if(OPENCV_FFMPEG_USE_FIND_PACKAGE) status(\" FFMPEG:\" HAVE_FFMPEG THEN \"YES (find_package)\" ELSE \"NO (find_package)\") elseif(WIN32) status(\" FFMPEG:\" HAVE_FFMPEG THEN \"YES (prebuilt binaries)\" ELSE NO) else() status(\" FFMPEG:\" HAVE_FFMPEG THEN YES ELSE NO) endif() status(\" avcodec:\" FFMPEG_libavcodec_VERSION THEN \"YES ($&#123;FFMPEG_libavcodec_VERSION&#125;)\" ELSE NO) status(\" avformat:\" FFMPEG_libavformat_VERSION THEN \"YES ($&#123;FFMPEG_libavformat_VERSION&#125;)\" ELSE NO) status(\" avutil:\" FFMPEG_libavutil_VERSION THEN \"YES ($&#123;FFMPEG_libavutil_VERSION&#125;)\" ELSE NO) status(\" swscale:\" FFMPEG_libswscale_VERSION THEN \"YES ($&#123;FFMPEG_libswscale_VERSION&#125;)\" ELSE NO) status(\" avresample:\" FFMPEG_libavresample_VERSION THEN \"YES ($&#123;FFMPEG_libavresample_VERSION&#125;)\" ELSE NO)endif() 我们可以发现，要想依赖FFmpeg，我们需要将HAVE_FFMPEG的值设为true，并且要指定FFmpeg libs的版本 我们再看到OPENCV_FFMPEG_USE_FIND_PACKAGE这个参数，表示通过find_package的方式寻找FFmpeg库 这里，我们其实有两种办法依赖FFmpeg库，一是通过find_package，二是通过pkg-config，我两种方式都尝试了后，觉得还是使用find_package这种方式比较容易，侵入性较小，使用pkg-config需要手动修改OpenCV检测FFmpeg的cmake文件源码，不优雅 接着我们去看OpenCV是如何检测FFmpeg是否存在的，这里我们需要找到$OPENCV/modules/videoio/cmake/detect_ffmpeg.cmake这个文件，在开头第一段代码中，我们就可以发现 123456789if(NOT HAVE_FFMPEG AND OPENCV_FFMPEG_USE_FIND_PACKAGE) if(OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"1\" OR OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"ON\") set(OPENCV_FFMPEG_USE_FIND_PACKAGE \"FFMPEG\") endif() find_package($&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;) # Required components: AVCODEC AVFORMAT AVUTIL SWSCALE if(FFMPEG_FOUND OR FFmpeg_FOUND) set(HAVE_FFMPEG TRUE) endif()endif() 如果OPENCV_FFMPEG_USE_FIND_PACKAGE选项被打开，则会使用find_package(FFMPEG)去查找这个库 find_package(&lt;PackageName&gt;)有两种模式，一种是Module模式，一种是Config模式 在Module模式中，cmake需要找到一个名为Find&lt;PackageName&gt;.cmake的文件，这个文件负责找到库所在路径，引入头文件和库文件。cmake会在两个地方查找这个文件，先是我们手动指定的CMAKE_MODULE_PATH目录，搜索不到再搜索$CMAKE/share/cmake-&lt;version&gt;/Modules目录 如果Module模式没找到相应文件，则会转为Config模式，在这个模式下，cmake需要找到&lt;lowercasePackageName&gt;-config.cmake或&lt;PackageName&gt;Config.cmake文件，通过这个文件找到库所在路径，引入头文件和库文件。cmake会优先在&lt;PackageName&gt;_DIR目录下搜索相应文件 关于find_package更详细的解释，可以去查看 官方文档 我这里选用了Config模式，再结合之前在CMakeLists.txt和detect_ffmpeg.cmake中的内容，我们可以得出结论： 我们需要在构建脚本中设置WITH_FFMPEG=ON，OPENCV_FFMPEG_USE_FIND_PACKAGE=ON，FFMPEG_DIR并且FFMPEG_DIR目录下需要有ffmpeg-config.cmake或FFMPEGConfig.cmake文件 这里就衔接了上文，我为什么要写一个ffmpeg-config-gen.sh脚本，脚本的内容很简单，我们直接看它生成出来的ffmpeg-config.cmake文件 123456789101112131415161718192021222324252627282930313233343536373839set(FFMPEG_PATH \"$&#123;CMAKE_CURRENT_LIST_DIR&#125;\")set(FFMPEG_EXEC_DIR \"$&#123;FFMPEG_PATH&#125;/bin\")set(FFMPEG_LIBDIR \"$&#123;FFMPEG_PATH&#125;/lib\")set(FFMPEG_INCLUDE_DIRS \"$&#123;FFMPEG_PATH&#125;/include\")set(FFMPEG_LIBRARIES $&#123;FFMPEG_LIBDIR&#125;/libavformat.a $&#123;FFMPEG_LIBDIR&#125;/libavdevice.a $&#123;FFMPEG_LIBDIR&#125;/libavcodec.a $&#123;FFMPEG_LIBDIR&#125;/libavutil.a $&#123;FFMPEG_LIBDIR&#125;/libswscale.a $&#123;FFMPEG_LIBDIR&#125;/libswresample.a $&#123;FFMPEG_LIBDIR&#125;/libavfilter.a $&#123;FFMPEG_LIBDIR&#125;/libpostproc.a /home/dreamgyf/compile/x264/_output_/product/arm64-v8a/lib/libx264.a z)set(FFMPEG_libavformat_FOUND TRUE)set(FFMPEG_libavdevice_FOUND TRUE)set(FFMPEG_libavcodec_FOUND TRUE)set(FFMPEG_libavutil_FOUND TRUE)set(FFMPEG_libswscale_FOUND TRUE)set(FFMPEG_libswresample_FOUND TRUE)set(FFMPEG_libavfilter_FOUND TRUE)set(FFMPEG_libpostproc_FOUND TRUE)set(FFMPEG_libavcodec_VERSION 59.18.100)set(FFMPEG_libavdevice_VERSION 59.4.100)set(FFMPEG_libavfilter_VERSION 8.24.100)set(FFMPEG_libavformat_VERSION 59.16.100)set(FFMPEG_libavutil_VERSION 57.17.100)set(FFMPEG_libpostproc_VERSION 56.3.100)set(FFMPEG_libswresample_VERSION 4.3.100)set(FFMPEG_libswscale_VERSION 6.4.100)set(FFMPEG_FOUND TRUE)set(FFMPEG_LIBS $&#123;FFMPEG_LIBRARIES&#125;) 这里主要为cmake提供了三个变量 FFMPEG_INCLUDE_DIRS：提供头文件目录 FFMPEG_LIBRARIES：提供库文件链接 FFMPEG_FOUND：告诉cmake找到了FFmpeg库 这里还有几个点要说，首先，cmake中的库文件链接顺序符合gcc链接顺序规则，所以说库的书写顺序也是有严格要求的，被依赖的库要放在依赖它的库的后面，正如这个文件，FFmpeg需要依赖x264，所以我需要将x264放在所有FFmpeg库的最后面 FFmpeg需要依赖zlib库，所以我在后面增加了一个z表示依赖zlib库 FFmpeg这些库的版本定义是从$FFMPEG_PRODUCT/$ABI/lib/pkgconfig目录下各个文件读出来的 ffmpeg-config.cmake文件写完，我们再回过头来看一下detect_ffmpeg.cmake 123456789if(NOT HAVE_FFMPEG AND OPENCV_FFMPEG_USE_FIND_PACKAGE) if(OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"1\" OR OPENCV_FFMPEG_USE_FIND_PACKAGE STREQUAL \"ON\") set(OPENCV_FFMPEG_USE_FIND_PACKAGE \"FFMPEG\") endif() find_package($&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;) # Required components: AVCODEC AVFORMAT AVUTIL SWSCALE if(FFMPEG_FOUND OR FFmpeg_FOUND) set(HAVE_FFMPEG TRUE) endif()endif() 可以看到最后的 if 中，如果FFMPEG_FOUND为true，则设置HAVE_FFMPEG为true，正好对应了我们在ffmpeg-config.cmake中的行为，这下，CMakeLists.txt就可以找到我们的FFmpeg库了 这里还有一点，detect_ffmpeg.cmake中有一段用来测试的代码 1234567891011121314if(HAVE_FFMPEG AND NOT HAVE_FFMPEG_WRAPPER AND NOT OPENCV_FFMPEG_SKIP_BUILD_CHECK) try_compile(__VALID_FFMPEG \"$&#123;OpenCV_BINARY_DIR&#125;\" \"$&#123;OpenCV_SOURCE_DIR&#125;/cmake/checks/ffmpeg_test.cpp\" CMAKE_FLAGS \"-DINCLUDE_DIRECTORIES:STRING=$&#123;FFMPEG_INCLUDE_DIRS&#125;\" \"-DLINK_LIBRARIES:STRING=$&#123;FFMPEG_LIBRARIES&#125;\" OUTPUT_VARIABLE TRY_OUT ) if(NOT __VALID_FFMPEG) message(FATAL_ERROR \"FFMPEG: test check build log:\\n$&#123;TRY_OUT&#125;\") message(STATUS \"WARNING: Can't build ffmpeg test code\") set(HAVE_FFMPEG FALSE) endif()endif() 其中的message(FATAL_ERROR &quot;FFMPEG: test check build log:\\n${TRY_OUT}&quot;)原本是被注释了的，我强烈建议各位将其打开，这样如果哪里有误，一开始就可以报错并附带详细信息，免得到时候编到一半才报错，浪费时间 到这里，我本以为万事大吉了，于是开始编译，这里我使用了BUILD_SHARED_LIBS=ON选项编译动态库，armeabi-v7a顺利编译通过，但当arm64-v8a编译到一半时突然报错，提示libz.so, needed by ../../lib/arm64-v8a/libopencv_core.so, not found (try using -rpath or -rpath-link) 我观察了一下NDK目录结构，发现libz.so动态库文件可以在$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API下找到，需要注意的是，这里的TOOLCHAIN_NAME和TRIPLE很相似，但在armeabi-v7a情况下又有些细微的不同，所以我又新定义了这个变量 然后我开始尝试加入-rpath-link选项，首先，我尝试添加了一项cmake选项CMAKE_SHARED_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;，发现，虽然在编译开头的输出中可以看出，这个参数确实被加上生效了，但在编译到同样的地方时，仍然会报相同的错误，这里我不太清楚，难道参数的顺序也会对编译造成影响吗？ 于是我去查看了android.toolchain.cmake文件，看他是怎么添加这些选项的，发现了这么一行 1set(CMAKE_SHARED_LINKER_FLAGS \"$&#123;ANDROID_LINKER_FLAGS&#125; $&#123;CMAKE_SHARED_LINKER_FLAGS&#125;\") 于是我在这行代码前加了这么一行 1list(APPEND ANDROID_LINKER_FLAGS -Wl,-rpath-link=$&#123;ANDROID_TOOLCHAIN_ROOT&#125;/sysroot/usr/lib/$&#123;ANDROID_TOOLCHAIN_NAME&#125;/$&#123;ANDROID_PLATFORM_LEVEL&#125;) 让-rpath-link这个选项提前一点，果不其然，编译顺利通过了，但这样做有点麻烦，还得改NDK里的配置，于是我在构建脚本里加了一个参数ANDROID_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;，这样的话，-rpath-link选项会被提到Linker flags的最前面，经过测试，这样也可以编译通过，于是OpenCV的编译脚本也就这么完成了 当然这里还剩一个疑点，为什么不加-rpath-link的时候，arm64-v8a编译报错但armeabi-v7a却编译通过，希望有大佬可以指点一下 FreeType我的App中还用到了FreeType库渲染字体，在这里顺便也把它的编译方式放出来吧 直接去 FreeType 这里下载我编译好的版本或者源码，根据我写的步骤进行编译就可以了 在Android中使用在Android中使用时需要注意，如果你使用静态库的方式的话，需要将OpenCV编译出来的第三方库也加入到链接中，放在OpenCV的后面，另外FFmpeg还需要mediandk和zlib这两个依赖，具体可以参考下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546target_link_libraries( textvideo freetype # opencv opencv_videoio opencv_photo opencv_highgui opencv_imgproc opencv_imgcodecs opencv_dnn opencv_core # ffmpeg ffmpeg_avformat ffmpeg_avdevice ffmpeg_avcodec ffmpeg_avutil ffmpeg_swscale ffmpeg_swresample ffmpeg_avfilter # ffmpeg依赖 mediandk z # x264 x264 # opencv第三方支持库 ade cpufeatures ittnotify libjpeg-turbo libopenjp2 libpng libprotobuf libwebp quirc tegra_hal # android jni库 jnigraphics android log) 总结虽然我这篇文章写的看起来编译的过程很简单，根本不像标题所说的那么艰难，但实际上我前前后后弄了大概有一个多星期才真正完整编出可用版本，前前后后编译失败了不说一百次也有几十次，对我这种不懂c语言编译的简直是折磨。因为我是在全部弄完后才开始写的文章，所以基本上坑都踩的差不多了，其中有些坑印象也没那么清楚了，我也没那么多精力再去复现出那些坑了，怎么说呢，能成功就万事大吉吧 😭","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"交叉编译","slug":"Android/交叉编译","permalink":"http://yoursite.com/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"编译","slug":"编译","permalink":"http://yoursite.com/categories/%E7%BC%96%E8%AF%91/"}],"tags":[{"name":"Android交叉编译","slug":"Android交叉编译","permalink":"http://yoursite.com/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"x264","slug":"x264","permalink":"http://yoursite.com/tags/x264/"}]},{"title":"Android源码分析 - Activity启动流程（上）","slug":"android/aosp/Android源码分析-Activity启动流程（上）","date":"2022-08-01T07:19:35.000Z","updated":"2022-11-13T09:55:54.352Z","comments":true,"path":"2022/08/01/android/aosp/Android源码分析-Activity启动流程（上）/","link":"","permalink":"http://yoursite.com/2022/08/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 作为一名Android开发，我们最熟悉并且最常打交道的当然非四大组件中的Activity莫属，这次我们就来讲讲一个Activity是怎样启动起来的 本来本篇想要讲ActivityManagerService的，但AMS中的内容过多过于繁杂，不如用这种以线及面的方式，通过Activity的启动流程这一条线，去了解ActivityThread，AMS等是怎么工作的 Android窗口结构关系在开始正式深入代码之前，我们需要先理一下Android的窗口结构关系，以免后面看到源码里各种parent、child头晕，我画了一张树状关系图来描述它 上图中的所有类都是WindowContainer的子类，WindowContainer是一个窗口容器，它的child也是WindowContainer，它是用来管理窗口子容器的 可以先不用纠结理解这张图中的关系，顺着源码往下看，碰到不理解的地方回头看一下就可以了 startActivity作为Android开发，startActivity这个方法一定非常熟悉，我们以这个函数作为入口来分析Activity的启动流程 Activity和ContextImpl的startActivity方法实现不太一样，但最终都调用了Instrumentation.execStartActivity方法 Instrumentation路径：frameworks/base/core/java/android/app/Instrumentation.java 以下是Google官方对这个类功能的注释 Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xml’s &lt;instrumentation&gt; tag. 简单翻译一下，就是这个类是用于监控系统与应用的交互的（onCreate等生命周期会经历Instrumentation这么一环），它会在任何App代码执行前被初始化。 本人猜测，这个类主要存在的意义是为了给自动化测试提供一个切入点 1234567891011121314151617181920212223242526272829public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; //记录调用者 Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; ... //自动化测试相关 try &#123; //迁移额外的URI数据流到剪贴板（处理Intent使用ACTION_SEND或ACTION_SEND_MULTIPLE共享数据的情况） intent.migrateExtraStreamToClipData(who); //处理离开当前App进程的情况 intent.prepareToLeaveProcess(who); //请求ATMS启动Activity int result = ActivityTaskManager.getService().startActivity(whoThread, who.getBasePackageName(), who.getAttributionTag(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查异常情况，抛出对应异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 这个函数调用了ActivityTaskManager.getService.startActivity方法 123456789101112public static IActivityTaskManager getService() &#123; return IActivityTaskManagerSingleton.get();&#125;private static final Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton = new Singleton&lt;IActivityTaskManager&gt;() &#123; @Override protected IActivityTaskManager create() &#123; final IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE); return IActivityTaskManager.Stub.asInterface(b); &#125; &#125;; 这里getService出来的很明显的是一个远程binder对象，我们之前已经分析过那么多binder知识了，以后就不再过多啰嗦了，这里实际上调用的是ActivityTaskManagerSerivce（以下简称ATMS）的startActivity方法 ActivityTaskManagerSerivceATMS是Android 10以后新加的一个服务，用来专门处理Activity相关工作，分担AMS的工作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage, String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125;@Overridepublic int startActivityAsUser(IApplicationThread caller, String callingPackage, String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true /*validateIncomingUser*/);&#125;private int startActivityAsUser(IApplicationThread caller, String callingPackage, @Nullable String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; //断言发起startActivity请求方的UID和callingPackage指向的是同一个App assertPackageMatchesCallingUid(callingPackage); //确认请求方没有被隔离 enforceNotIsolatedCaller(\"startActivityAsUser\"); //检查并获取当前用户ID（多用户模式） userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), \"startActivityAsUser\"); //使用ActivityStarter启动Activity return getActivityStartController().obtainStarter(intent, \"startActivityAsUser\") .setCaller(caller) //调用方ApplicationThread .setCallingPackage(callingPackage) //调用方包名 .setCallingFeatureId(callingFeatureId) // Context.getAttributionTag() .setResolvedType(resolvedType) //设置Intent解析类型 .setResultTo(resultTo) //设置目标Activity Token（ContextImpl.startActivity传入参数为null） .setResultWho(resultWho) //设置目标Activity（ContextImpl.startActivity传入参数为null） .setRequestCode(requestCode) //设置requestCode .setStartFlags(startFlags) // startFlags == 0 .setProfilerInfo(profilerInfo) // null .setActivityOptions(bOptions) //设置Activity Options Bundle .setUserId(userId) //设置用户ID .execute();&#125; 这个函数大部分内容都是检查，最重要的是最后一段使用ActivityStarter启动Activity，首先通过ActivityStartController的obtainStarter方法获取一个ActivityStarter实例，然后调用各种set方法设置参数，最后执行execute方法执行 ActivityStarter这个类从名字就能看出来，就是一个专门处理Activity启动的类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162int execute() &#123; try &#123; // Refuse possible leaked file descriptors //校验Intent，不允许其携带fd if (mRequest.intent != null &amp;&amp; mRequest.intent.hasFileDescriptors()) &#123; throw new IllegalArgumentException(\"File descriptors passed in Intent\"); &#125; final LaunchingState launchingState; synchronized (mService.mGlobalLock) &#123; //通过Token获取调用方ActivityRecord final ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo); //记录启动状态 launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching( mRequest.intent, caller); &#125; // If the caller hasn't already resolved the activity, we're willing // to do so here. If the caller is already holding the WM lock here, // and we need to check dynamic Uri permissions, then we're forced // to assume those permissions are denied to avoid deadlocking. //通过Intent解析Activity信息 if (mRequest.activityInfo == null) &#123; mRequest.resolveActivity(mSupervisor); &#125; int res; synchronized (mService.mGlobalLock) &#123; ... //处理Configuration //清除Binder调用方UID和PID，用当前进程的UID和PID替代，并返回之前的UID和PID（UID：前32位，PID：后32位） final long origId = Binder.clearCallingIdentity(); //解析成为重量级进程（如果设置了相关flag的话） //这里的重量级进程指的是不能保存状态的应用进程 res = resolveToHeavyWeightSwitcherIfNeeded(); if (res != START_SUCCESS) &#123; return res; &#125; //执行请求 res = executeRequest(mRequest); //恢复之前的Binder调用方UID和PID Binder.restoreCallingIdentity(origId); ... //更新Configuration // Notify ActivityMetricsLogger that the activity has launched. // ActivityMetricsLogger will then wait for the windows to be drawn and populate // WaitResult. //记录启动状态 mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res, mLastStartActivityRecord); //返回启动结果 return getExternalResult(mRequest.waitResult == null ? res : waitForResult(res, mLastStartActivityRecord)); &#125; &#125; finally &#123; //清理回收工作 onExecutionComplete(); &#125;&#125; 这个函数每一步做了什么我都用注释标出来了，大家看看就好，重点在于其中的executeRequest(mRequest) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319/** * Executing activity start request and starts the journey of starting an activity. Here * begins with performing several preliminary checks. The normally activity launch flow will * go through &#123;@link #startActivityUnchecked&#125; to &#123;@link #startActivityInner&#125;. */private int executeRequest(Request request) &#123; if (TextUtils.isEmpty(request.reason)) &#123; throw new IllegalArgumentException(\"Need to specify a reason.\"); &#125; mLastStartReason = request.reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord = null; final IApplicationThread caller = request.caller; Intent intent = request.intent; NeededUriGrants intentGrants = request.intentGrants; String resolvedType = request.resolvedType; ActivityInfo aInfo = request.activityInfo; ResolveInfo rInfo = request.resolveInfo; final IVoiceInteractionSession voiceSession = request.voiceSession; final IBinder resultTo = request.resultTo; String resultWho = request.resultWho; int requestCode = request.requestCode; int callingPid = request.callingPid; int callingUid = request.callingUid; String callingPackage = request.callingPackage; String callingFeatureId = request.callingFeatureId; final int realCallingPid = request.realCallingPid; final int realCallingUid = request.realCallingUid; final int startFlags = request.startFlags; final SafeActivityOptions options = request.activityOptions; Task inTask = request.inTask; int err = ActivityManager.START_SUCCESS; // Pull the optional Ephemeral Installer-only bundle out of the options early. final Bundle verificationBundle = options != null ? options.popAppVerificationBundle() : null; WindowProcessController callerApp = null; if (caller != null) &#123; //获取调用方应用进程对应的WindowProcessController //这个类是用于和ProcessRecord进行通讯的 callerApp = mService.getProcessController(caller); if (callerApp != null) &#123; callingPid = callerApp.getPid(); callingUid = callerApp.mInfo.uid; &#125; else &#123; //异常情况，startActivity的调用方进程不存在或未启动 Slog.w(TAG, \"Unable to find app for caller \" + caller + \" (pid=\" + callingPid + \") when starting: \" + intent.toString()); err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //获取当前用户ID final int userId = aInfo != null &amp;&amp; aInfo.applicationInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; if (err == ActivityManager.START_SUCCESS) &#123; Slog.i(TAG, \"START u\" + userId + \" &#123;\" + intent.toShortString(true, true, true, false) + \"&#125; from uid \" + callingUid); &#125; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; //调用方Activity Token != null if (resultTo != null) &#123; //获取调用方ActivityRecord（要求存在任意一个Window栈中，即是RootWindow的子嗣） sourceRecord = mRootWindowContainer.isInAnyStack(resultTo); if (DEBUG_RESULTS) &#123; Slog.v(TAG_RESULTS, \"Will send result to \" + resultTo + \" \" + sourceRecord); &#125; if (sourceRecord != null) &#123; //调用方需要response if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; resultRecord = sourceRecord; &#125; &#125; &#125; final int launchFlags = intent.getFlags(); //多Activity传值场景 if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; ... &#125; //找不到可以处理此Intent的组件 if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; // We couldn't find a class that can handle the given Intent. // That's the end of that! err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; //Intent中解析不出相应的Activity信息 if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; // We couldn't find the specific class specified in the Intent. // Also the end of the line. err = ActivityManager.START_CLASS_NOT_FOUND; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != null &amp;&amp; sourceRecord.getTask().voiceSession != null) &#123; ... //语言交互相关 &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != null) &#123; ... //语言交互相关 &#125; final ActivityStack resultStack = resultRecord == null ? null : resultRecord.getRootTask(); if (err != START_SUCCESS) &#123; //回调给调用方Activity结果 if (resultRecord != null) &#123; resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED, null /* data */, null /* dataGrants */); &#125; SafeActivityOptions.abort(options); return err; &#125; //检查启动Activity的权限 boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, callingFeatureId, request.ignoreTargetSecurity, inTask != null, callerApp, resultRecord, resultStack); abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid, callingPackage); boolean restrictedBgActivity = false; if (!abort) &#123; try &#123; Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, \"shouldAbortBackgroundActivityStart\"); //检查是否要限制后台启动Activity restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid, callingPid, callingPackage, realCallingUid, realCallingPid, callerApp, request.originatingPendingIntent, request.allowBackgroundActivityStart, intent); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER); &#125; &#125; // Merge the two options bundles, while realCallerOptions takes precedence. //过渡动画相关 ActivityOptions checkedOptions = options != null ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : null; if (request.allowPendingRemoteAnimationRegistryLookup) &#123; checkedOptions = mService.getActivityStartController() .getPendingRemoteAnimationRegistry() .overrideOptionsIfNeeded(callingPackage, checkedOptions); &#125; if (mService.mController != null) &#123; try &#123; // The Intent we give to the watcher has the extra data stripped off, since it // can contain private information. Intent watchIntent = intent.cloneFilter(); //这个方法似乎只打印了一些日志，恒返回true，即abort |= false abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; catch (RemoteException e) &#123; mService.mController = null; &#125; &#125; //初始化ActivityStartInterceptor mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage, callingFeatureId); if (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid, callingUid, checkedOptions)) &#123; // activity start was intercepted, e.g. because the target user is currently in quiet // mode (turn off work) or the target application is suspended //拦截并转化成其他的启动模式 intent = mInterceptor.mIntent; rInfo = mInterceptor.mRInfo; aInfo = mInterceptor.mAInfo; resolvedType = mInterceptor.mResolvedType; inTask = mInterceptor.mInTask; callingPid = mInterceptor.mCallingPid; callingUid = mInterceptor.mCallingUid; checkedOptions = mInterceptor.mActivityOptions; // The interception target shouldn't get any permission grants // intended for the original destination intentGrants = null; &#125; if (abort) &#123; //回调给调用方Activity结果 if (resultRecord != null) &#123; resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED, null /* data */, null /* dataGrants */); &#125; // We pretend to the caller that it was really started, but they will just get a // cancel result. ActivityOptions.abort(checkedOptions); return START_ABORTED; &#125; // If permissions need a review before any of the app components can run, we // launch the review activity and pass a pending intent to start the activity // we are to launching now after the review is completed. if (aInfo != null) &#123; //如果启动的Activity没有相应权限，则需要用户手动确认允许权限后，再进行启动工作 if (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired( aInfo.packageName, userId)) &#123; //将原来的Intent包装在新的Intent中，用这个确认权限的新Intent继续后面的启动工作 final IIntentSender target = mService.getIntentSenderLocked( ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingFeatureId, callingUid, userId, null, null, 0, new Intent[]&#123;intent&#125;, new String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null); Intent newIntent = new Intent(Intent.ACTION_REVIEW_PERMISSIONS); int flags = intent.getFlags(); flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS; /* * Prevent reuse of review activity: Each app needs their own review activity. By * default activities launched with NEW_TASK or NEW_DOCUMENT try to reuse activities * with the same launch parameters (extras are ignored). Hence to avoid possible * reuse force a new activity via the MULTIPLE_TASK flag. * * Activities that are not launched with NEW_TASK or NEW_DOCUMENT are not re-used, * hence no need to add the flag in this case. */ if ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != 0) &#123; flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK; &#125; newIntent.setFlags(flags); newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName); newIntent.putExtra(Intent.EXTRA_INTENT, new IntentSender(target)); if (resultRecord != null) &#123; newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, true); &#125; intent = newIntent; // The permissions review target shouldn't get any permission // grants intended for the original destination intentGrants = null; resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, 0, computeResolveFilterUid( callingUid, realCallingUid, request.filterCallingUid)); aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); &#125; &#125; // If we have an ephemeral app, abort the process of launching the resolved intent. // Instead, launch the ephemeral installer. Once the installer is finished, it // starts either the intent we resolved here [on install error] or the ephemeral // app [on install success]. if (rInfo != null &amp;&amp; rInfo.auxiliaryInfo != null) &#123; ... //Instant App相关 &#125; //创建启动Activity的ActivityRecord final ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, callingFeatureId, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, request.componentSpecified, voiceSession != null, mSupervisor, checkedOptions, sourceRecord); mLastStartActivityRecord = r; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; // If the caller didn't specify an explicit time tracker, we want to continue // tracking under any it has. r.appTimeTracker = sourceRecord.appTimeTracker; &#125; //获取顶层焦点的Acticity栈 final ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack(); // If we are starting an activity that is not from the same uid as the currently resumed // one, check whether app switches are allowed. //当此时栈顶Activity UID != 调用方 UID的时候（比如悬浮窗） if (voiceSession == null &amp;&amp; stack != null &amp;&amp; (stack.getResumedActivity() == null || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123; //检查是否可以直接切换应用 // 1. 设置的 mAppSwitchesAllowedTime &lt; 当前系统时间（stopAppSwitches） // 2. 调用方在最近任务中 // 3. 调用方具有 STOP_APP_SWITCHES 权限 // ... if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, \"Activity start\")) &#123; //加入到延时启动列表中 if (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123; mController.addPendingActivityLaunch(new PendingActivityLaunch(r, sourceRecord, startFlags, stack, callerApp, intentGrants)); &#125; ActivityOptions.abort(checkedOptions); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; //回调处理延迟应用切换 mService.onStartActivitySetDidAppSwitch(); mController.doPendingActivityLaunches(false); //核心：进入Activity启动的下一阶段 mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession, request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, restrictedBgActivity, intentGrants); if (request.outActivity != null) &#123; request.outActivity[0] = mLastStartActivityRecord; &#125; return mLastStartActivityResult;&#125; 这个函数大部分都是检查工作，这些可以看我标的注释，基本上介绍的比较详细了，然后进入到Activity启动的下一步，startActivityUnchecked 123456789101112131415161718192021222324252627282930/** * Start an activity while most of preliminary checks has been done and caller has been * confirmed that holds necessary permissions to do so. * Here also ensures that the starting activity is removed if the start wasn't successful. */private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; int result = START_CANCELED; final ActivityStack startedActivityStack; try &#123; //暂停布局工作，避免重复刷新 mService.deferWindowLayout(); Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, \"startActivityInner\"); //接着把启动Activity工作交给这个方法 result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER); //进行一些更新Configuration，清理栈等收尾工作 startedActivityStack = handleStartResult(r, result); //恢复布局工作 mService.continueWindowLayout(); &#125; postStartActivityProcessing(r, result, startedActivityStack); return result;&#125; 这个方法也不是主要逻辑所在，我们往下接着看startActivityInner方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167/** * Start an activity and determine if the activity should be adding to the top of an existing * task or delivered new intent to an existing activity. Also manipulating the activity task * onto requested or valid stack/display. * * Note: This method should only be called from &#123;@link #startActivityUnchecked&#125;. */// TODO(b/152429287): Make it easier to exercise code paths through startActivityInner@VisibleForTestingint startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; //设置初始化参数 setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor, restrictedBgActivity); //计算处理Activity启动模式 computeLaunchingTaskFlags(); //计算调用方Activity任务栈 computeSourceStack(); //将flags设置为调整后的LaunchFlags mIntent.setFlags(mLaunchFlags); //查找是否有可复用的Task final Task reusedTask = getReusableTask(); // If requested, freeze the task list if (mOptions != null &amp;&amp; mOptions.freezeRecentTasksReordering() &amp;&amp; mSupervisor.mRecentTasks.isCallerRecents(r.launchedFromUid) &amp;&amp; !mSupervisor.mRecentTasks.isFreezeTaskListReorderingSet()) &#123; mFrozeTaskList = true; mSupervisor.mRecentTasks.setFreezeTaskListReordering(); &#125; // Compute if there is an existing task that should be used for. //计算是否存在可使用的现有Task final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask(); final boolean newTask = targetTask == null; mTargetTask = targetTask; //计算启动参数 computeLaunchParams(r, sourceRecord, targetTask); // Check if starting activity on given task or on a new task is allowed. //检查是否允许在targetTask上或者新建Task启动 int startResult = isAllowedToStart(r, newTask, targetTask); if (startResult != START_SUCCESS) &#123; return startResult; &#125; //获得栈顶未finish的ActivityRecord final ActivityRecord targetTaskTop = newTask ? null : targetTask.getTopNonFinishingActivity(); if (targetTaskTop != null) &#123; // Recycle the target task for this launch. //回收，准备复用这个Task startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; else &#123; mAddingToTask = true; &#125; // If the activity being launched is the same as the one currently at the top, then // we need to check if it should only be launched once. //处理singleTop启动模式 final ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack(); if (topStack != null) &#123; startResult = deliverToCurrentTopIfNeeded(topStack, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; //复用或创建Activity栈 if (mTargetStack == null) &#123; mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions); &#125; if (newTask) &#123; //开启新Task final Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; //复用或新建一个Task，并建立Task与ActivityRecord之间的关联 setNewTask(taskToAffiliate); if (mService.getLockTaskController().isLockTaskModeViolation( mStartActivity.getTask())) &#123; Slog.e(TAG, \"Attempted Lock Task Mode violation mStartActivity=\" + mStartActivity); return START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; &#125; else if (mAddingToTask) &#123; //复用Task //将启动Activity添加到targetTask容器顶部或将其父容器替换成targetTask（也会将启动Activity添加到targetTask容器顶部） addOrReparentStartingActivity(targetTask, \"adding to task\"); &#125; if (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123; mTargetStack.getStack().moveToFront(\"reuseOrNewTask\", targetTask); if (mOptions != null) &#123; if (mOptions.getTaskAlwaysOnTop()) &#123; mTargetStack.setAlwaysOnTop(true); &#125; &#125; if (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123; // Launching underneath dream activity (fullscreen, always-on-top). Run the launch- // -behind transition so the Activity gets created and starts in visible state. mLaunchTaskBehind = true; r.mLaunchTaskBehind = true; &#125; &#125; ... mTargetStack.mLastPausedActivity = null; mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded( false /* forceSend */, mStartActivity); //将Task移到ActivityStack容器顶部 mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(), newTask, mKeepCurTransition, mOptions); if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); //启动的Activity不可获得焦点，无法恢复它 if (!mTargetStack.isTopActivityFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.isTaskOverlay() &amp;&amp; mStartActivity != topTaskActivity)) &#123; // If the activity is not focusable, we can't resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don't want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. // Passing &#123;@code null&#125; as the start parameter ensures all activities are made // visible. mTargetStack.ensureActivitiesVisible(null /* starting */, 0 /* configChanges */, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mTargetStack.getDisplay().mDisplayContent.executeAppTransition(); &#125; else &#123; // If the target stack was not previously focusable (previous top running activity // on that stack was not visible) then any prior calls to move the stack to the // will not update the focused stack. If starting the new activity now allows the // task stack to be focusable, then ensure that we now update the focused stack // accordingly. if (mTargetStack.isTopActivityFocusable() &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(\"startActivityInner\"); &#125; //重点：恢复栈顶Activities mRootWindowContainer.resumeFocusedStacksTopActivities( mTargetStack, mStartActivity, mOptions); &#125; &#125; mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack); // Update the recent tasks list immediately when the activity starts //当Activity启动后立刻更新最近任务列表 mSupervisor.mRecentTasks.add(mStartActivity.getTask()); mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack); return START_SUCCESS;&#125; 这里主要做了一些Task和栈的操作，是否可以复用栈，是否需要新栈，处理栈顶复用等相关操作。我们需要注意一下这里关于Task的操作，不管是新建Task（newTask）还是复用Task（mAddingToTask），都会调用到addOrReparentStartingActivity方法将启动ActivityRecord添加到targetTask容器顶部（newTask的情况下会调用setNewTask方法先复用或创建Task，然后再用这个Task调用addOrReparentStartingActivity方法），之后调用mTargetStack.startActivityLocked方法将Task移到mTargetStack容器顶部，此时调用mTargetStack.topRunningActivity便会得到我们将要启动的这个ActivityRecord 最后判断目标Activity是否可获得焦点，当可获得焦点的时候，调用RootWindowContainer.resumeFocusedStacksTopActivities方法恢复Activity 要注意，从这个方法开始的以后的方法不再只是针对Activity启动的方法，它们有可能被多方调用，所以其中的一些步骤case我们是不会经历的，可以忽略掉这部分 RootWindowContainerRootWindowContainer是显示窗口的根窗口容器，它主要是用来管理显示屏幕的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061boolean resumeFocusedStacksTopActivities( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (!mStackSupervisor.readyToResume()) &#123; return false; &#125; boolean result = false; //目标栈在栈顶显示区域 if (targetStack != null &amp;&amp; (targetStack.isTopStackInDisplayArea() || getTopDisplayFocusedStack() == targetStack)) &#123; //使用目标栈进行恢复 result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; //可能存在多显示设备（投屏等） for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) &#123; boolean resumedOnDisplay = false; final DisplayContent display = getChildAt(displayNdx); for (int tdaNdx = display.getTaskDisplayAreaCount() - 1; tdaNdx &gt;= 0; --tdaNdx) &#123; final TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx); for (int sNdx = taskDisplayArea.getStackCount() - 1; sNdx &gt;= 0; --sNdx) &#123; final ActivityStack stack = taskDisplayArea.getStackAt(sNdx); final ActivityRecord topRunningActivity = stack.topRunningActivity(); if (!stack.isFocusableAndVisible() || topRunningActivity == null) &#123; continue; &#125; if (stack == targetStack) &#123; //如果进入到这里，代表着targetStack在上面已经恢复过了，此时只需要记录结果即可 resumedOnDisplay |= result; continue; &#125; if (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123; //执行切换效果 stack.executeAppTransition(targetOptions); &#125; else &#123; //使顶部显示的Activity执行Resume、Pause或Start生命周期 resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target); &#125; &#125; &#125; if (!resumedOnDisplay) &#123; // In cases when there are no valid activities (e.g. device just booted or launcher // crashed) it's possible that nothing was resumed on a display. Requesting resume // of top activity in focused stack explicitly will make sure that at least home // activity is started and resumed, and no recursion occurs. //当没有任何有效的Activity的时候（设备刚启动或Launcher崩溃），可能没有任何东西可被恢复 //这时候使用DisplayContent中的焦点栈进行恢复 //如果连存在焦点的栈都没有，则恢复Launcher的Activity final ActivityStack focusedStack = display.getFocusedStack(); if (focusedStack != null) &#123; result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; else if (targetStack == null) &#123; result |= resumeHomeActivity(null /* prev */, \"no-focusable-task\", display.getDefaultTaskDisplayArea()); &#125; &#125; &#125; return result;&#125; 这个方法主要做了几件事： 如果目标栈在栈顶显示区域，执行Resume 遍历显示设备，从中遍历所有有焦点并且可见的栈，对其栈顶Activity执行相应的切换效果及生命周期 对每个显示设备，如果存在焦点栈，则使用其执行Resume，否则启动Launcher 在正常情况下，我们会走进ActivityStack.resumeTopActivityUncheckedLocked这个方法 ActivityStackActivity栈，用于管理栈中的Activity 1234567891011121314151617181920212223242526272829303132boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mInResumeTopActivity) &#123; // Don't even start recursing. //防止递归 return false; &#125; boolean result = false; try &#123; // Protect against recursion. //防止递归 mInResumeTopActivity = true; result = resumeTopActivityInnerLocked(prev, options); // When resuming the top activity, it may be necessary to pause the top activity (for // example, returning to the lock screen. We suppress the normal pause logic in // &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the // end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here // to ensure any necessary pause logic occurs. In the case where the Activity will be // shown regardless of the lock screen, the call to // &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped. final ActivityRecord next = topRunningActivity(true /* focusableOnly */); if (next == null || !next.canTurnScreenOn()) &#123; //准备休眠 checkReadyForSleep(); &#125; &#125; finally &#123; mInResumeTopActivity = false; &#125; return result;&#125; 这里做了一个防止递归调用的措施，接下来调用了resumeTopActivityInnerLocked方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; if (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123; // Not ready yet! //ATMS服务尚未准备好 return false; &#125; // Find the next top-most activity to resume in this stack that is not finishing and is // focusable. If it is not focusable, we will fall into the case below to resume the // top activity in the next focusable task. //在之前我们已经把要启动的ActivityRecord加到了栈顶 ActivityRecord next = topRunningActivity(true /* focusableOnly */); final boolean hasRunningActivity = next != null; ... if (!hasRunningActivity) &#123; // There are no activities left in the stack, let's look somewhere else. return resumeNextFocusableActivityWhenStackIsEmpty(prev, options); &#125; next.delayedResume = false; final TaskDisplayArea taskDisplayArea = getDisplayArea(); // If the top activity is the resumed one, nothing to do. //如果需要Resume的已在顶部且状态为Resume，不需要做任何事 //启动Activity不会碰到这种case if (mResumedActivity == next &amp;&amp; next.isState(RESUMED) &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123; ... return false; &#125; if (!next.canResumeByCompat()) &#123; return false; &#125; // If we are currently pausing an activity, then don't do anything until that is done. //如果有正在Pause的Activity，在它Pause完成前不要做任何事 final boolean allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete(); if (!allPausedComplete) &#123; return false; &#125; ... // Make sure that the user who owns this activity is started. If not, // we will just leave it as is because someone should be bringing // another user's activities to the top of the stack. //确保拥有此Activity的用户已启动 if (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) &#123; return false; &#125; // The activity may be waiting for stop, but that is no longer // appropriate for it. mStackSupervisor.mStoppingActivities.remove(next); next.setSleeping(false); //这里似乎重复检查了，我去查看了一下master分支的代码，已经没有这一段了 if (!mRootWindowContainer.allPausedActivitiesComplete()) &#123; return false; &#125; //设置启动Activity UID，获取WakeLock，保证在显示Activity的过程中，系统不会进行休眠状态 mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid); ActivityRecord lastResumed = null; //上一个具有焦点的ActivityStack（目前仍是屏幕上正在显示的那个Activity的栈） final ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack(); if (lastFocusedStack != null &amp;&amp; lastFocusedStack != this) &#123; lastResumed = lastFocusedStack.mResumedActivity; ... &#125; //Pause掉其他ActivityStack中的栈顶状态为Resume的Activity boolean pausing = taskDisplayArea.pauseBackStacks(userLeaving, next); //Pause掉当前ActivityStack中的栈顶状态为Resume的Activity if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false /* uiSleeping */, next); &#125; if (pausing) &#123; //有Activity执行了Pause // At this point we want to put the upcoming activity's process // at the top of the LRU list, since we know we will be needing it // very soon and it would be a waste to let it get killed if it // happens to be sitting towards the end. if (next.attachedToProcess()) &#123; //将启动的Activity进程信息移至lru列表的头部 //因为很快就会使用它启动Activity next.app.updateProcessInfo(false /* updateServiceConnectionActivities */, true /* activityChange */, false /* updateOomAdj */, false /* addPendingTopUid */); &#125; else if (!next.isProcessRunning()) &#123; //App进程未启动 // Since the start-process is asynchronous, if we already know the process of next // activity isn't running, we can start the process earlier to save the time to wait // for the current activity to be paused. final boolean isTop = this == taskDisplayArea.getFocusedStack(); //启动App进程 mAtmService.startProcessAsync(next, false /* knownToBeDead */, isTop, isTop ? \"pre-top-activity\" : \"pre-activity\"); &#125; ... //这里会先结束掉启动Activity的流程，等待onPause生命周期走完后 //再重新调用这个方法执行下一步操作，避免Activity生命周期紊乱 return true; &#125; else if (mResumedActivity == next &amp;&amp; next.isState(RESUMED) &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123; // It is possible for the activity to be resumed when we paused back stacks above if the // next activity doesn't have to wait for pause to complete. // So, nothing else to-do except: // Make sure we have executed any pending transitions, since there // should be nothing left to do at this point. //不需要等待其他的Activity onPause完成 //执行完切换效果后就没有什么其他需要做的了 executeAppTransition(options); return true; &#125; ... //启动Activity流程不会进入这个case if (prev != null &amp;&amp; prev != next &amp;&amp; next.nowVisible) &#123; if (prev.finishing) &#123; prev.setVisibility(false); &#125; &#125; //修改启动Activity的package的状态 mAtmService.getPackageManager().setPackageStoppedState( next.packageName, false, next.mUserId); ... //Activity转场动画准备 if (next.attachedToProcess()) &#123; //对于将要启动的ActivityRecord来说，此时尚未完成和Process的绑定，返回false ... ActivityRecord lastResumedActivity = lastFocusedStack == null ? null : lastFocusedStack.mResumedActivity; //保存状态以做后面恢复使用 final ActivityState lastState = next.getState(); mAtmService.updateCpuStats(); //更新ActivityRecord状态 next.setState(RESUMED, \"resumeTopActivityInnerLocked\"); //更新启动Activity的进程信息并将其移至lru列表的头部 next.app.updateProcessInfo(false /* updateServiceConnectionActivities */, true /* activityChange */, true /* updateOomAdj */, true /* addPendingTopUid */); ... //更新Activity显示、方向和Configuration try &#123; final ClientTransaction transaction = ClientTransaction.obtain(next.app.getThread(), next.appToken); // Deliver all pending results. ArrayList&lt;ResultInfo&gt; a = next.results; if (a != null) &#123; final int N = a.size(); if (!next.finishing &amp;&amp; N &gt; 0) &#123; if (DEBUG_RESULTS) Slog.v(TAG_RESULTS, \"Delivering results to \" + next + \": \" + a); transaction.addCallback(ActivityResultItem.obtain(a)); &#125; &#125; if (next.newIntents != null) &#123; transaction.addCallback( NewIntentItem.obtain(next.newIntents, true /* resume */)); &#125; // Well the app will no longer be stopped. // Clear app token stopped state in window manager if needed. next.notifyAppResumed(next.stopped); EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next), next.getTask().mTaskId, next.shortComponentName); next.setSleeping(false); mAtmService.getAppWarningsLocked().onResumeActivity(next); next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState); next.clearOptionsLocked(); //设置onResume生命周期请求 transaction.setLifecycleStateRequest( ResumeActivityItem.obtain(next.app.getReportedProcState(), dc.isNextTransitionForward())); //调度执行Activity onResume生命周期 mAtmService.getLifecycleManager().scheduleTransaction(transaction); if (DEBUG_STATES) Slog.d(TAG_STATES, \"resumeTopActivityLocked: Resumed \" + next); &#125; catch (Exception e) &#123; //resume失败需要尝试restart //恢复初始状态 next.setState(lastState, \"resumeTopActivityInnerLocked\"); if (lastResumedActivity != null) &#123; lastResumedActivity.setState(RESUMED, \"resumeTopActivityInnerLocked\"); &#125; ... //重新启动Activity mStackSupervisor.startSpecificActivity(next, true, false); return true; &#125; // From this point on, if something goes wrong there is no way // to recover the activity. try &#123; //更新信息 next.completeResumeLocked(); &#125; catch (Exception e) &#123; // If any exception gets thrown, toss away this // activity and try the next one. Slog.w(TAG, \"Exception thrown during resume of \" + next, e); next.finishIfPossible(\"resume-exception\", true /* oomAdj */); return true; &#125; &#125; else &#123; //尚未绑定Process // Whoops, need to restart this activity! if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; next.showStartingWindow(null /* prev */, false /* newTask */, false /* taskSwich */); &#125; &#125; //启动Activity mStackSupervisor.startSpecificActivity(next, true, true); &#125; return true;&#125; 这里的代码很长，其实我们只需要关注三个点： Pause掉其他Activity 如果对应App尚未启动，启动App进程 启动Activity 第一步，在启动Activity前，我们需要先Pause掉其他Activity，这一点很好理解，我们可以对照着看Activity生命周期也是这样的，这里会通过ATMS跨进程调用相应Activity的onPause生命周期，等待onPause执行完成后，再跨进程调用回ATMS，经过一系列方法调用，又重新调用resumeTopActivityInnerLocked方法，继续执行下一步操作 第二步，如果App尚未启动，则先去启动App进程，这主要体现在这里 12345if (!next.isProcessRunning()) &#123; //App进程未启动 //启动App进程 mAtmService.startProcessAsync(next, false /* knownToBeDead */, isTop, isTop ? \"pre-top-activity\" : \"pre-activity\");&#125; 在启动完App进程后，会调用ATMS的attachApplication方法，最终调用到ActivityStackSupervisor.realStartActivityLocked方法启动Activity，这个方法后面会讲 第三步，如果App进程已经启动，这时候会调用ActivityStackSupervisor.startSpecificActivity方法，最终殊途同归调用ActivityStackSupervisor.realStartActivityLocked方法启动Activity 结束这里篇幅有点过长了，所以我觉得还是分篇比较好，这一章其实重要内容不是很多，最主要的内容，像Activity的生命周期控制，App进程的启动，Activity具体的启动及其后续生命周期执行都会放在下一章来讲","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"}]},{"title":"Android源码分析-ActivityManagerService","slug":"android/aosp/Android源码分析-ActivityManagerService","date":"2022-07-26T10:03:08.000Z","updated":"2022-11-13T09:55:54.352Z","comments":true,"path":"2022/07/26/android/aosp/Android源码分析-ActivityManagerService/","link":"","permalink":"http://yoursite.com/2022/07/26/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ActivityManagerService/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 作为一名Android开发，我们最熟悉并且最常打交道的当然非四大组件中的Activity莫属，这次我们就来讲讲ActivityManagerService这个Android系统核心服务究竟扮演了一个怎样的角色，提供了哪些功能 简介ActivityManagerService（以下简称AMS）是Android系统中最核心的服务之一，主要负责系统中四大组件的调度管理 启动我们在Android源码分析 - SystemServer（下）中提到过AMS的启动，在SystemServer启动的各个阶段，AMS做了一些不同的工作，我们先从它的实例化开始 12345678910private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123; ... //创建 ATMS &amp; AMS ActivityTaskManagerService atm = mSystemServiceManager.startService( ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); ...&#125; ActivityTaskManagerService路径：frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java Android 10以后增加了一个ActivityTaskManagerService（以下简称ATMS）来分担AMS的工作 startService12345678910111213141516171819202122232425262728293031323334353637public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; try &#123; final String name = serviceClass.getName(); //必须是SystemService的子类 if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException(...); &#125; final T service; //反射调用构造方法实例化 try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (...) &#123; ... &#125; startService(service); return service; &#125; finally &#123; ... &#125;&#125;public void startService(@NonNull final SystemService service) &#123; //添加到List中 mServices.add(service); long time = SystemClock.elapsedRealtime(); try &#123; //回调 service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(...); &#125; //启动时间过长会打一个Warnning级别日志 warnIfTooLong(SystemClock.elapsedRealtime() - time, service, \"onStart\");&#125; ATMS和AMS的启动通过了SystemServiceManager.startService方法，它需要参数为SystemService子类的class，对于ATMS来说，它的内部类Lifecycle继承自SystemService SystemServiceManager.startService方法首先通过反射创建了对应传进来类的实例，然后将其添加到SystemServiceManager内部的一个List中，接着回调其onStart方法 1234567891011121314151617181920212223242526272829303132public static final class Lifecycle extends SystemService &#123; private final ActivityTaskManagerService mService; public Lifecycle(Context context) &#123; super(context); mService = new ActivityTaskManagerService(context); &#125; @Override public void onStart() &#123; publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService); mService.start(); &#125; @Override public void onUnlockUser(int userId) &#123; synchronized (mService.getGlobalLock()) &#123; mService.mStackSupervisor.onUserUnlocked(userId); &#125; &#125; @Override public void onCleanupUser(int userId) &#123; synchronized (mService.getGlobalLock()) &#123; mService.mStackSupervisor.mLaunchParamsPersister.onCleanupUser(userId); &#125; &#125; public ActivityTaskManagerService getService() &#123; return mService; &#125;&#125; 其实ATMS.Lifecycle很短，我们看它的构造方法，其实就是实例化了一个ATMS出来 123456789101112public ActivityTaskManagerService(Context context) &#123; mContext = context; mFactoryTest = FactoryTest.getMode(); mSystemThread = ActivityThread.currentActivityThread(); mUiContext = mSystemThread.getSystemUiContext(); //管理Activity生命周期 mLifecycleManager = new ClientLifecycleManager(); mInternal = new LocalService(); GL_ES_VERSION = SystemProperties.getInt(\"ro.opengles.version\", GL_ES_VERSION_UNDEFINED); mWindowOrganizerController = new WindowOrganizerController(this); mTaskOrganizerController = mWindowOrganizerController.mTaskOrganizerController;&#125; 这里面初始化了很多东西，我们暂且跳过，等以后使用到时候在细说，然后startService方法会回调ATMS.Lifecycle.onStart方法，这个方法首先将创建好的ATMS注册到ServiceManager中 12345678910111213protected final void publishBinderService(@NonNull String name, @NonNull IBinder service) &#123; publishBinderService(name, service, false);&#125;protected final void publishBinderService(@NonNull String name, @NonNull IBinder service, boolean allowIsolated) &#123; publishBinderService(name, service, allowIsolated, DUMP_FLAG_PRIORITY_DEFAULT);&#125;protected final void publishBinderService(String name, IBinder service, boolean allowIsolated, int dumpPriority) &#123; ServiceManager.addService(name, service, allowIsolated, dumpPriority);&#125; 然后调用了ATMS.start方法，将刚创建出来的mInternal添加到本地服务中 123private void start() &#123; LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);&#125; ActivityManagerService接着我们回到SystemServer.startBootstrapServices中，接下来是对AMS的启动 startServiceAMS的启动和ATMS类似，它们同样是通过内部的一个Lifecycle类 123456789101112131415161718192021222324252627282930313233343536373839404142public static final class Lifecycle extends SystemService &#123; private final ActivityManagerService mService; private static ActivityTaskManagerService sAtm; public Lifecycle(Context context) &#123; super(context); mService = new ActivityManagerService(context, sAtm); &#125; public static ActivityManagerService startService( SystemServiceManager ssm, ActivityTaskManagerService atm) &#123; sAtm = atm; return ssm.startService(ActivityManagerService.Lifecycle.class).getService(); &#125; @Override public void onStart() &#123; mService.start(); &#125; @Override public void onBootPhase(int phase) &#123; mService.mBootPhase = phase; if (phase == PHASE_SYSTEM_SERVICES_READY) &#123; mService.mBatteryStatsService.systemServicesReady(); mService.mServices.systemServicesReady(); &#125; else if (phase == PHASE_ACTIVITY_MANAGER_READY) &#123; mService.startBroadcastObservers(); &#125; else if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123; mService.mPackageWatchdog.onPackagesReady(); &#125; &#125; @Override public void onUserStopped(@NonNull TargetUser user) &#123; mService.mBatteryStatsService.onCleanupUser(user.getUserIdentifier()); &#125; public ActivityManagerService getService() &#123; return mService; &#125;&#125; 可以看到，这里将ATMS作为参数参与AMS的实例化，我么看一下它的构造方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167public ActivityManagerService(Context systemContext, ActivityTaskManagerService atm) &#123; LockGuard.installLock(this, LockGuard.INDEX_ACTIVITY); mInjector = new Injector(systemContext); mContext = systemContext; mFactoryTest = FactoryTest.getMode(); //获取系统ActivityThread mSystemThread = ActivityThread.currentActivityThread(); mUiContext = mSystemThread.getSystemUiContext(); Slog.i(TAG, \"Memory class: \" + ActivityManager.staticGetMemoryClass()); //创建线程来处理AMS的各种状态 mHandlerThread = new ServiceThread(TAG, THREAD_PRIORITY_FOREGROUND, false /*allowIo*/); mHandlerThread.start(); mHandler = new MainHandler(mHandlerThread.getLooper()); mUiHandler = mInjector.getUiHandler(this); //创建proc线程 mProcStartHandlerThread = new ServiceThread(TAG + \":procStart\", THREAD_PRIORITY_FOREGROUND, false /* allowIo */); mProcStartHandlerThread.start(); mProcStartHandler = new Handler(mProcStartHandlerThread.getLooper()); //获取定义常量 mConstants = new ActivityManagerConstants(mContext, this, mHandler); //记录活跃的进程uid final ActiveUids activeUids = new ActiveUids(this, true /* postChangesToAtm */); mPlatformCompat = (PlatformCompat) ServiceManager.getService( Context.PLATFORM_COMPAT_SERVICE); //新建ProcessList对象用来处理进程 mProcessList = mInjector.getProcessList(this); mProcessList.init(this, activeUids, mPlatformCompat); //低内存检测器 mLowMemDetector = new LowMemDetector(this); //OOM调节器 mOomAdjuster = new OomAdjuster(this, mProcessList, activeUids); //定义广播策略参数 final BroadcastConstants foreConstants = new BroadcastConstants( Settings.Global.BROADCAST_FG_CONSTANTS); foreConstants.TIMEOUT = BROADCAST_FG_TIMEOUT; final BroadcastConstants backConstants = new BroadcastConstants( Settings.Global.BROADCAST_BG_CONSTANTS); backConstants.TIMEOUT = BROADCAST_BG_TIMEOUT; final BroadcastConstants offloadConstants = new BroadcastConstants( Settings.Global.BROADCAST_OFFLOAD_CONSTANTS); offloadConstants.TIMEOUT = BROADCAST_BG_TIMEOUT; // by default, no \"slow\" policy in this queue offloadConstants.SLOW_TIME = Integer.MAX_VALUE; mEnableOffloadQueue = SystemProperties.getBoolean( \"persist.device_config.activity_manager_native_boot.offload_queue_enabled\", false); //初始化前台广播队列 mFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", foreConstants, false); //初始化后台广播队列 mBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", backConstants, true); //初始化卸载广播队列 mOffloadBroadcastQueue = new BroadcastQueue(this, mHandler, \"offload\", offloadConstants, true); mBroadcastQueues[0] = mFgBroadcastQueue; mBroadcastQueues[1] = mBgBroadcastQueue; mBroadcastQueues[2] = mOffloadBroadcastQueue; mServices = new ActiveServices(this); mProviderMap = new ProviderMap(this); mPackageWatchdog = PackageWatchdog.getInstance(mUiContext); mAppErrors = new AppErrors(mUiContext, this, mPackageWatchdog); final File systemDir = SystemServiceManager.ensureSystemDir(); // TODO: Move creation of battery stats service outside of activity manager service. mBatteryStatsService = new BatteryStatsService(systemContext, systemDir, BackgroundThread.get().getHandler()); mBatteryStatsService.getActiveStatistics().readLocked(); mBatteryStatsService.scheduleWriteToDisk(); mOnBattery = DEBUG_POWER ? true : mBatteryStatsService.getActiveStatistics().getIsOnBattery(); mBatteryStatsService.getActiveStatistics().setCallback(this); mOomAdjProfiler.batteryPowerChanged(mOnBattery); mProcessStats = new ProcessStatsService(this, new File(systemDir, \"procstats\")); mAppOpsService = mInjector.getAppOpsService(new File(systemDir, \"appops.xml\"), mHandler); mUgmInternal = LocalServices.getService(UriGrantsManagerInternal.class); mUserController = new UserController(this); mPendingIntentController = new PendingIntentController( mHandlerThread.getLooper(), mUserController, mConstants); if (SystemProperties.getInt(\"sys.use_fifo_ui\", 0) != 0) &#123; mUseFifoUiScheduling = true; &#125; mTrackingAssociations = \"1\".equals(SystemProperties.get(\"debug.track-associations\")); mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), mHandler); //ATMS进一步初始化 mActivityTaskManager = atm; mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController, DisplayThread.get().getLooper()); mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal.class); mProcessCpuThread = new Thread(\"CpuTracker\") &#123; @Override public void run() &#123; synchronized (mProcessCpuTracker) &#123; mProcessCpuInitLatch.countDown(); mProcessCpuTracker.init(); &#125; while (true) &#123; try &#123; try &#123; synchronized(this) &#123; final long now = SystemClock.uptimeMillis(); long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now; long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now; //Slog.i(TAG, \"Cpu delay=\" + nextCpuDelay // + \", write delay=\" + nextWriteDelay); if (nextWriteDelay &lt; nextCpuDelay) &#123; nextCpuDelay = nextWriteDelay; &#125; if (nextCpuDelay &gt; 0) &#123; mProcessCpuMutexFree.set(true); this.wait(nextCpuDelay); &#125; &#125; &#125; catch (InterruptedException e) &#123; &#125; updateCpuStatsNow(); &#125; catch (Exception e) &#123; Slog.e(TAG, \"Unexpected exception collecting process stats\", e); &#125; &#125; &#125; &#125;; mHiddenApiBlacklist = new HiddenApiSettings(mHandler, mContext); Watchdog.getInstance().addMonitor(this); Watchdog.getInstance().addThread(mHandler); // bind background threads to little cores // this is expected to fail inside of framework tests because apps can't touch cpusets directly // make sure we've already adjusted system_server's internal view of itself first updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE); try &#123; Process.setThreadGroupAndCpuset(BackgroundThread.get().getThreadId(), Process.THREAD_GROUP_SYSTEM); Process.setThreadGroupAndCpuset( mOomAdjuster.mCachedAppOptimizer.mCachedAppOptimizerThread.getThreadId(), Process.THREAD_GROUP_SYSTEM); &#125; catch (Exception e) &#123; Slog.w(TAG, \"Setting background thread cpuset failed\"); &#125; mInternal = new LocalService(); mPendingStartActivityUids = new PendingStartActivityUids(mContext);&#125; 这里的内容更复杂了，我们注意到AMS将ATMS保存成了自己的一个成员变量，然后调用它的initialize方法进一步初始化 12345678910111213141516171819public void initialize(IntentFirewall intentFirewall, PendingIntentController intentController, Looper looper) &#123; mH = new H(looper); mUiHandler = new UiHandler(); mIntentFirewall = intentFirewall; final File systemDir = SystemServiceManager.ensureSystemDir(); mAppWarnings = createAppWarnings(mUiContext, mH, mUiHandler, systemDir); mCompatModePackages = new CompatModePackages(this, systemDir, mH); mPendingIntentController = intentController; mStackSupervisor = createStackSupervisor(); mTaskChangeNotificationController = new TaskChangeNotificationController(mGlobalLock, mStackSupervisor, mH); mLockTaskController = new LockTaskController(mContext, mStackSupervisor, mH); mActivityStartController = new ActivityStartController(this); setRecentTasks(new RecentTasks(this, mStackSupervisor)); mVrController = new VrController(mGlobalLock); mKeyguardController = mStackSupervisor.getKeyguardController();&#125; 然后同样的，startService方法回调AMS.Lifecycle.onStart方法，调用AMS.start方法 12345678910111213141516171819202122private void start() &#123; removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(); mAppOpsService.publish(); Slog.d(\"AppOps\", \"AppOpsService published\"); LocalServices.addService(ActivityManagerInternal.class, mInternal); //通知ATMS，ActivityManagerInternal被添加到了本地服务中，ATMS那边可以获取到了 mActivityTaskManager.onActivityManagerInternalAdded(); mPendingIntentController.onActivityManagerInternalAdded(); // Wait for the synchronized block started in mProcessCpuThread, // so that any other access to mProcessCpuTracker from main thread // will be blocked during mProcessCpuTracker initialization. try &#123; mProcessCpuInitLatch.await(); &#125; catch (InterruptedException e) &#123; Slog.wtf(TAG, \"Interrupted wait during start\", e); Thread.currentThread().interrupt(); throw new IllegalStateException(\"Interrupted wait during start\"); &#125;&#125; 后续工作后续在SystemServer启动服务的过程中，AMS还参加进行了很多工作，我在这里将其列出来 123456789101112131415161718192021222324252627282930313233/* 阶段0 */mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm);mActivityManagerService.setSystemServiceManager(mSystemServiceManager);mActivityManagerService.setInstaller(installer);mActivityManagerService.initPowerManagement();/* 阶段100 PHASE_WAIT_FOR_DEFAULT_DISPLAY *///注册各种系统服务mActivityManagerService.setSystemProcess();//应用用量统计服务mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class));//加载SettingProvidermActivityManagerService.installSystemProviders();//窗口服务mActivityManagerService.setWindowManager(wm);//进入安全模式if (safeMode) &#123; mActivityManagerService.enterSafeMode();&#125;/* 阶段480 PHASE_LOCK_SETTINGS_READY *//* 阶段500 PHASE_SYSTEM_SERVICES_READY */mActivityManagerService.systemReady(() -&gt; &#123; /* 阶段550 PHASE_ACTIVITY_MANAGER_READY */ ... /* 阶段600 PHASE_THIRD_PARTY_APPS_CAN_START */ ...&#125;, t); 我们拣几个比较重要的方法介绍一下 setSystemProcess123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public void setSystemProcess() &#123; try &#123; //将自己添加到ServiceManager中 ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(\"meminfo\", new MemBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_HIGH); ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(\"cpuinfo\", new CpuBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); &#125; //将权限服务添加到ServiceManager中 ServiceManager.addService(\"permission\", new PermissionController(this)); ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); ServiceManager.addService(\"cacheinfo\", new CacheBinder(this)); //查询包名为android的application，即framework-res.apk的application信息 ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( \"android\", STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY); //设置系统application信息 mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) &#123; //创建一个ProcessRecord对象记录系统application信息 ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName, false, 0, new HostingRecord(\"system\")); app.setPersistent(true); app.pid = MY_PID; app.getWindowProcessController().setPid(MY_PID); app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); //将系统application的ProcessRecord对象也添加进来，让AMS可以管理调度 addPidLocked(app); mProcessList.updateLruProcessLocked(app, false, null); updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException( \"Unable to find android system package\", e); &#125; // Start watching app ops after we and the package manager are up and running. mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, null, new IAppOpsCallback.Stub() &#123; @Override public void opChanged(int op, int uid, String packageName) &#123; if (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != null) &#123; if (getAppOpsManager().checkOpNoThrow(op, uid, packageName) != AppOpsManager.MODE_ALLOWED) &#123; runInBackgroundDisabled(uid); &#125; &#125; &#125; &#125;); final int[] cameraOp = &#123;AppOpsManager.OP_CAMERA&#125;; mAppOpsService.startWatchingActive(cameraOp, new IAppOpsActiveCallback.Stub() &#123; @Override public void opActiveChanged(int op, int uid, String packageName, boolean active) &#123; cameraActiveChanged(uid, active); &#125; &#125;);&#125; 这个方法主要将自己和一些其他系统服务注册到了ServiceManager中，然后通过PMS找到framework-res.apk的application信息，将它配置到系统ActivityThread中，然后根据这个application信息，创建出了一个记录系统application信息的ProcessRecord对象，并将其添加到AMS内部的列表中，这样后续AMS就可以管理调度系统application了 installSystemProviders123456789101112131415161718192021222324252627282930313233343536public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; //这里找到的就是setSystemProcess中创建的framework-res.apk的application信息 ProcessRecord app = mProcessList.mProcessNames.get(\"system\", SYSTEM_UID); //找到所有和framework-res.apk相关的ContentProvider providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; Slog.w(TAG, \"Not installing system proc provider \" + pi.name + \": not system .apk\"); providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; mSystemThread.installSystemProviders(providers); &#125; synchronized (this) &#123; mSystemProvidersInstalled = true; &#125; mConstants.start(mContext.getContentResolver()); mCoreSettingsObserver = new CoreSettingsObserver(this); mActivityTaskManager.installSystemProviders(); mDevelopmentSettingsObserver = new DevelopmentSettingsObserver(); SettingsToPropertiesMapper.start(mContext.getContentResolver()); mOomAdjuster.initSettings(); // Now that the settings provider is published we can consider sending // in a rescue party. RescueParty.onSettingsProviderPublished(mContext);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"}]},{"title":"Android源码分析 - Framework层的Binder（服务端篇）","slug":"android/aosp/Android源码分析-Framework层的Binder（服务端篇）","date":"2022-07-05T10:48:28.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/07/05/android/aosp/Android源码分析-Framework层的Binder（服务端篇）/","link":"","permalink":"http://yoursite.com/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/","excerpt":"","text":"开篇本篇以aosp分支android-11.0.0_r25，kernel分支android-msm-wahoo-4.4-android11作为基础解析 我们在上一片文章Android源码分析 - Framework层的Binder（客户端篇）中，分析了客户端是怎么向服务端通过binder驱动发起请求，然后再接收服务端的返回的。本篇文章，我们将会以服务端的视角，分析服务端是怎么通过binder驱动接收客户端的请求，处理，然后再返回给客户端的。 ServiceManager上篇文章我们是以ServiceManager作为服务端分析的，本篇文章我们还是围绕着它来做分析，它也是一个比较特殊的服务端，我们正好可以顺便分析一下它是怎么成为binder驱动的context_manager的 进程启动ServiceManager是在独立的进程中运行的，它是由init进程从rc文件中解析并启动的，路径为frameworks/native/cmds/servicemanager/servicemanager.rc 123456789101112131415161718service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager class core animation user system group system readproc critical onrestart restart healthd onrestart restart zygote onrestart restart audioserver onrestart restart media onrestart restart surfaceflinger onrestart restart inputflinger onrestart restart drm onrestart restart cameraserver onrestart restart keystore onrestart restart gatekeeperd onrestart restart thermalservice writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks shutdown critical 这个服务的入口函数位于frameworks/native/cmds/servicemanager/main.cpp的main函数中 123456789101112131415161718192021222324252627282930313233343536373839int main(int argc, char** argv) &#123; //根据上面的rc文件，argc == 1, argv[0] == \"/system/bin/servicemanager\" if (argc &gt; 2) &#123; LOG(FATAL) &lt;&lt; \"usage: \" &lt;&lt; argv[0] &lt;&lt; \" [binder driver]\"; &#125; //此时，要使用的binder驱动为/dev/binder const char* driver = argc == 2 ? argv[1] : \"/dev/binder\"; //初始化binder驱动 sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver); ps-&gt;setThreadPoolMaxThreadCount(0); ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); //实例化ServiceManager sp&lt;ServiceManager&gt; manager = new ServiceManager(std::make_unique&lt;Access&gt;()); //将自身作为服务添加 if (!manager-&gt;addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123; LOG(ERROR) &lt;&lt; \"Could not self register servicemanager\"; &#125; //设置服务端Bbinder对象 IPCThreadState::self()-&gt;setTheContextObject(manager); //设置成为binder驱动的context manager ps-&gt;becomeContextManager(nullptr, nullptr); //通过Looper epoll机制处理binder事务 sp&lt;Looper&gt; looper = Looper::prepare(false /*allowNonCallbacks*/); BinderCallback::setupTo(looper); ClientCallbackCallback::setupTo(looper, manager); while(true) &#123; looper-&gt;pollAll(-1); &#125; //正常走不到这里 return EXIT_FAILURE;&#125; 初始化Binder首先读取参数，按照之前的rc文件来看，这里的driver为/dev/binder，然后根据此driver初始化此进程的ProcessState单例，根据我们上一章的分析我们知道此时会执行binder_open和binder_mmap，接着对这个单例做一些配置 123456789101112131415161718192021222324sp&lt;ProcessState&gt; ProcessState::initWithDriver(const char* driver)&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != nullptr) &#123; // Allow for initWithDriver to be called repeatedly with the same // driver. //如果已经被初始化过了，并且传入的driver参数和已初始化的驱动名一样，直接返回之前初始化的单例 if (!strcmp(gProcess-&gt;getDriverName().c_str(), driver)) &#123; return gProcess; &#125; //否则异常退出 LOG_ALWAYS_FATAL(\"ProcessState was already initialized.\"); &#125; //判断指定的driver是否存在并可读 if (access(driver, R_OK) == -1) &#123; ALOGE(\"Binder driver %s is unavailable. Using /dev/binder instead.\", driver); //回滚默认binder驱动 driver = \"/dev/binder\"; &#125; gProcess = new ProcessState(driver); return gProcess;&#125; access文档：https://man7.org/linux/man-pages/man2/access.2.html 原型：int access(const char *pathname, int mode); 这个函数是用来检查调用进程是否可以对指定文件执行某种操作的，成功返回0，失败返回-1并设置error mode参数可以为以下几个值： F_OK：文件存在 R_OK：文件可读 W_OK：文件可写 X_OK：文件可执行 注册成为Binder驱动的context manager接着调用了ProcessState的becomeContextManager函数注册成为Binder驱动的context manager 123456789101112131415161718192021222324bool ProcessState::becomeContextManager()&#123; AutoMutex _l(mLock); flat_binder_object obj &#123; .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX, &#125;; int result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj); // fallback to original method if (result != 0) &#123; android_errorWriteLog(0x534e4554, \"121035042\"); int unused = 0; result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused); &#125; if (result == -1) &#123; ALOGE(\"Binder ioctl to become context manager failed: %s\\n\", strerror(errno)); &#125; return result == 0;&#125; 这里通过binder_ioctl，以BINDER_SET_CONTEXT_MGR_EXT为命令码请求binder驱动 123456789101112131415161718static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; ... switch (cmd) &#123; ... case BINDER_SET_CONTEXT_MGR_EXT: &#123; struct flat_binder_object fbo; if (copy_from_user(&amp;fbo, ubuf, sizeof(fbo))) &#123; ret = -EINVAL; goto err; &#125; ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo); if (ret) goto err; break; &#125; ... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int binder_ioctl_set_ctx_mgr(struct file *filp, struct flat_binder_object *fbo)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; struct binder_context *context = proc-&gt;context; struct binder_node *new_node; kuid_t curr_euid = current_euid(); mutex_lock(&amp;context-&gt;context_mgr_node_lock); //binder的context manager只能设置一次 if (context-&gt;binder_context_mgr_node) &#123; pr_err(\"BINDER_SET_CONTEXT_MGR already set\\n\"); ret = -EBUSY; goto out; &#125; //判断调用进程是否有权限设置context manager ret = security_binder_set_context_mgr(proc-&gt;tsk); if (ret &lt; 0) goto out; //context-&gt;binder_context_mgr_uid != -1 if (uid_valid(context-&gt;binder_context_mgr_uid)) &#123; if (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123; pr_err(\"BINDER_SET_CONTEXT_MGR bad uid %d != %d\\n\", from_kuid(&amp;init_user_ns, curr_euid), from_kuid(&amp;init_user_ns, context-&gt;binder_context_mgr_uid)); ret = -EPERM; goto out; &#125; &#125; else &#123; //设置Binder驱动context manager所在进程的用户ID context-&gt;binder_context_mgr_uid = curr_euid; &#125; //新建binder节点 new_node = binder_new_node(proc, fbo); if (!new_node) &#123; ret = -ENOMEM; goto out; &#125; binder_node_lock(new_node); new_node-&gt;local_weak_refs++; new_node-&gt;local_strong_refs++; new_node-&gt;has_strong_ref = 1; new_node-&gt;has_weak_ref = 1; //设置binder驱动context manager节点 context-&gt;binder_context_mgr_node = new_node; binder_node_unlock(new_node); binder_put_node(new_node);out: mutex_unlock(&amp;context-&gt;context_mgr_node_lock); return ret;&#125; 这里的过程也很简单，首先检查之前是否设置过context manager，然后做权限校验，通过后通过binder_new_node创建出一个新的binder节点，并将它作为context manager节点 Looper循环处理Binder事务这里的Looper和我们平常应用开发所说的Looper是一个东西，本篇就不做过多详解了，只需要知道，可以通过Looper::addFd函数监听文件描述符，通过Looper::pollAll或Looper::pollOnce函数接收消息，消息抵达后会回调LooperCallback::handleEvent函数 了解了这些后我们来看一下BinderCallback这个类 12345678910111213141516171819202122232425262728293031class BinderCallback : public LooperCallback &#123;public: static sp&lt;BinderCallback&gt; setupTo(const sp&lt;Looper&gt;&amp; looper) &#123; sp&lt;BinderCallback&gt; cb = new BinderCallback; int binder_fd = -1; //向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符 IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); LOG_ALWAYS_FATAL_IF(binder_fd &lt; 0, \"Failed to setupPolling: %d\", binder_fd); // Flush after setupPolling(), to make sure the binder driver // knows about this thread handling commands. IPCThreadState::self()-&gt;flushCommands(); //监听binder文件描述符 int ret = looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb, nullptr /*data*/); LOG_ALWAYS_FATAL_IF(ret != 1, \"Failed to add binder FD to Looper\"); return cb; &#125; int handleEvent(int /* fd */, int /* events */, void* /* data */) override &#123; //从binder驱动接收到消息并处理 IPCThreadState::self()-&gt;handlePolledCommands(); return 1; // Continue receiving callbacks. &#125;&#125;; 在servicemanager进程启动的过程中调用了BinderCallback::setupTo函数，这个函数首先想binder驱动发起了一个BC_ENTER_LOOPER事务请求，获得binder设备的文件描述符，然后调用Looper::addFd函数监听binder设备文件描述符，这样当binder驱动发来消息后，就可以通过Looper::handleEvent函数接收并处理了 1234567891011121314151617status_t IPCThreadState::setupPolling(int* fd)&#123; if (mProcess-&gt;mDriverFD &lt; 0) &#123; return -EBADF; &#125; //设置binder请求码 mOut.writeInt32(BC_ENTER_LOOPER); //检查写缓存是否有可写数据，有的话发送给binder驱动 flushCommands(); //赋值binder驱动的文件描述符 *fd = mProcess-&gt;mDriverFD; pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock); mProcess-&gt;mCurrentThreads++; pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock); return 0;&#125; Binder事务处理BinderCallback类重写了handleEvent函数，里面调用了IPCThreadState::handlePolledCommands函数来接收处理binder事务 1234567891011121314status_t IPCThreadState::handlePolledCommands()&#123; status_t result; //当读缓存中数据未消费完时，持续循环 do &#123; result = getAndExecuteCommand(); &#125; while (mIn.dataPosition() &lt; mIn.dataSize()); //当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE processPendingDerefs(); flushCommands(); return result;&#125; 读取并处理响应这个函数的重点在getAndExecuteCommand，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从binder驱动那里读写数据，只会处理剩余读缓存） 12345678910111213141516171819status_t IPCThreadState::getAndExecuteCommand()&#123; status_t result; int32_t cmd; //从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据） result = talkWithDriver(/* true */); if (result &gt;= NO_ERROR) &#123; size_t IN = mIn.dataAvail(); if (IN &lt; sizeof(int32_t)) return result; //读取BR响应码 cmd = mIn.readInt32(); ... result = executeCommand(cmd); ... &#125; return result;&#125; 处理响应这里有很多线程等其他操作，我们不需要关心，我在这里把他们简化掉了，剩余的代码很清晰，首先从binder驱动中读取数据，然后从数据中读取出BR响应码，接着调用executeCommand函数继续往下处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576status_t IPCThreadState::executeCommand(int32_t cmd)&#123; BBinder* obj; RefBase::weakref_type* refs; status_t result = NO_ERROR; switch ((uint32_t)cmd) &#123; ... case BR_TRANSACTION_SEC_CTX: case BR_TRANSACTION: &#123; binder_transaction_data_secctx tr_secctx; binder_transaction_data&amp; tr = tr_secctx.transaction_data; if (cmd == (int) BR_TRANSACTION_SEC_CTX) &#123; result = mIn.read(&amp;tr_secctx, sizeof(tr_secctx)); &#125; else &#123; result = mIn.read(&amp;tr, sizeof(tr)); tr_secctx.secctx = 0; &#125; ALOG_ASSERT(result == NO_ERROR, \"Not enough command data for brTRANSACTION\"); if (result != NO_ERROR) break; //读取数据到缓冲区 Parcel buffer; buffer.ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); ... Parcel reply; status_t error; //对于ServiceManager的binder节点来说，是没有ptr的 if (tr.target.ptr) &#123; // We only have a weak reference on the target object, so we must first try to // safely acquire a strong reference before doing anything else with it. //对于其他binder服务端来说，tr.cookie为本地BBinder对象指针 if (reinterpret_cast&lt;RefBase::weakref_type*&gt;( tr.target.ptr)-&gt;attemptIncStrong(this)) &#123; error = reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this); &#125; else &#123; error = UNKNOWN_TRANSACTION; &#125; &#125; else &#123; //对于ServiceManager来说，使用the_context_object这个BBinder对象 error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags); &#125; if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123; LOG_ONEWAY(\"Sending reply to %d!\", mCallingPid); if (error &lt; NO_ERROR) reply.setError(error); //非TF_ONE_WAY模式下需要Reply sendReply(reply, 0); &#125; else &#123; ... //TF_ONE_WAY模式下不需要Reply，这里只打了些日志 &#125; ... &#125; break; ... &#125; if (result != NO_ERROR) &#123; mLastError = result; &#125; return result;&#125; 我们重点分析这个函数在BR_TRANSACTION下的case，其余的都删减掉 首先，这个函数从读缓存中读取了binder_transaction_data，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个Parcel对象作为缓冲区，从binder_transaction_data中将实际数据读取出来 接着找到本地BBinder对象，对于ServiceManager来说就是之前在main函数中setTheContextObject的ServiceManager对象，而对于其他binder服务端来说，则是通过tr.cookie获取，然后调用BBinder的transact函数 12345678910111213141516171819202122232425262728293031323334status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; //确保从头开始读取数据 data.setDataPosition(0); if (reply != nullptr &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123; //标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全） reply-&gt;markSensitive(); &#125; status_t err = NO_ERROR; //这里的code是由binder客户端请求传递过来的 //是客户端与服务端的一个约定 //它标识了客户端像服务端发起的是哪种请求 switch (code) &#123; ... default: err = onTransact(code, data, reply, flags); break; &#125; // In case this is being transacted on in the same process. if (reply != nullptr) &#123; //设置数据指针偏移为0，这样后续读取数据便会从头开始 reply-&gt;setDataPosition(0); if (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123; ALOGW(\"Large reply transaction of %zu bytes, interface descriptor %s, code %d\", reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code); &#125; &#125; return err;&#125; onTransact这个函数主要调用了onTransact函数，它是一个虚函数，可以被子类重写。我们观察ServiceManager这个类，它继承了BnServiceManager，在BnServiceManager中重写了这个onTransact函数，它们的继承关系如下： ServiceManager -&gt; BnServiceManager -&gt; BnInterface&lt;IServiceManager&gt; -&gt; IServiceManager &amp; BBinder 这里的BnServiceManager是通过AIDL工具生成出来的（AIDL既可以生成Java代码，也可以生成C++代码），我们找到一份生成后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123; ::android::status_t _aidl_ret_status = ::android::OK; switch (_aidl_code) &#123; case BnServiceManager::TRANSACTION_getService: &#123; //参数name ::std::string in_name; ::android::sp&lt;::android::IBinder&gt; _aidl_return; //类型检查 if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; //读取参数name _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; //确认数据已读完 if (auto st = _aidl_data.enforceNoDataAvail(); !st.isOk()) &#123; _aidl_ret_status = st.writeToParcel(_aidl_reply); break; &#125; //执行真正的getService函数 ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return)); //将状态值写入reply _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; //将返回值写入reply _aidl_ret_status = _aidl_reply-&gt;writeStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; ... &#125; if (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123; _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeOverParcel(_aidl_reply); &#125; return _aidl_ret_status;&#125; 生成出的代码格式比较丑，不易阅读，我把它格式化了一下，提取出我们需要的部分。这个函数主要流程就是先从data中读取所需要的参数，然后根据参数执行相对应的函数，然后将状态值写入reply，最后再将返回值写入reply。这里我们将上一章节AIDL生成出的java文件那部分拿过来做对比，我们可以发现，这里Parcel的写入和那里Parcel的读取顺序是严格一一对应的 1234567891011121314151617181920@Override public android.os.IBinder getService(java.lang.String name) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); android.os.IBinder _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); boolean _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, 0); //先读取状态值 _reply.readException(); //再读取返回值 _result = _reply.readStrongBinder(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; 实际功能实现然后我们来看真正功能实现的地方：getService函数，根据之前所说的继承关系，ServiceManager继承自IServiceManager，实现了其中的纯虚函数，其中就包括了getService 12345Status ServiceManager::getService(const std::string&amp; name, sp&lt;IBinder&gt;* outBinder) &#123; *outBinder = tryGetService(name, true); // returns ok regardless of result for legacy reasons return Status::ok();&#125; 1234567891011121314151617181920212223242526272829303132333435363738sp&lt;IBinder&gt; ServiceManager::tryGetService(const std::string&amp; name, bool startIfNotFound) &#123; auto ctx = mAccess-&gt;getCallingContext(); //返回值 sp&lt;IBinder&gt; out; Service* service = nullptr; //从map中寻找相应的服务 if (auto it = mNameToService.find(name); it != mNameToService.end()) &#123; service = &amp;(it-&gt;second); if (!service-&gt;allowIsolated) &#123; uid_t appid = multiuser_get_app_id(ctx.uid); bool isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END; if (isIsolated) &#123; return nullptr; &#125; &#125; //返回值指向对应service的binder对象 out = service-&gt;binder; &#125; if (!mAccess-&gt;canFind(ctx, name)) &#123; return nullptr; &#125; if (!out &amp;&amp; startIfNotFound) &#123; tryStartService(name); &#125; if (out) &#123; // Setting this guarantee each time we hand out a binder ensures that the client-checking // loop knows about the event even if the client immediately drops the service service-&gt;guaranteeClient = true; &#125; return out;&#125; 这里面的实现我们就没必要细看了，只需要注意它返回了相应service的binder对象，根据上面的代码来看，会将其写入到reply中 Reply实际的功能处理完成后，我们回到IPCThreadState::executeCommand中来。对于非TF_ONE_WAY模式，我们要将reply发送给请求方客户端 12345678910status_t IPCThreadState::sendReply(const Parcel&amp; reply, uint32_t flags)&#123; status_t err; status_t statusBuffer; //将binder reply请求打包好写入写缓冲区 err = writeTransactionData(BC_REPLY, flags, -1, 0, reply, &amp;statusBuffer); if (err &lt; NO_ERROR) return err; return waitForResponse(nullptr, nullptr);&#125; writeTransactionData在上一章中已经分析过了，这里就不多做描述了，waitForResponse我们上一章也分析过了，根据我们在上一章所描述的非TF_ONE_WAY的通信过程，在向binder驱动发送BC_REPLY请求后我们会收到BR_TRANSACTION_COMPLETE响应，根据我们传入waitForResponse的两个参数值，会直接跳出函数中的循环，结束此次binder通信 1234567891011121314151617181920212223242526272829303132status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); switch (cmd) &#123; ... case BR_TRANSACTION_COMPLETE: //参数为两个nullptr，直接跳转到finish结束 if (!reply &amp;&amp; !acquireResult) goto finish; break; ... &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; logExtendedError(); &#125; return err;&#125; 至此，binder服务端的一次消息处理到这就结束了，Looper会持续监听着binder驱动fd，等待下一条binder消息的到来 结束经过这么多篇文章的分析，整个Binder架构的大致通信原理、过程，我们应该都了解的差不多了，至于一些边边角角的细节，以后有机会的话我会慢慢再补充","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android源码分析 - Framework层的Binder（客户端篇）","slug":"android/aosp/Android源码分析-Framework层的Binder（客户端篇）","date":"2022-06-27T03:45:00.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/06/27/android/aosp/Android源码分析-Framework层的Binder（客户端篇）/","link":"","permalink":"http://yoursite.com/2022/06/27/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89/","excerpt":"","text":"开篇本篇以aosp分支android-11.0.0_r25作为基础解析 我们在之前的文章中，从驱动层面分析了Binder是怎样工作的，但Binder驱动只涉及传输部分，待传输对象是怎么产生的呢，这就是framework层的工作了。我们要彻底了解Binder的工作原理，不仅要去看驱动层，还得去看framework层以及应用层（AIDL） ServiceManagergetIServiceManager我们还是以第一次见到Binder的地方ServiceManager开始分析，我们选取getService方法来分析（这个方法既有入参也有返回），抛除掉它缓存和log的部分，最核心的代码就一句getIServiceManager().getService(name) 12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager;&#125; BinderInternal.getContextObject我们从BinderInternal.getContextObject()开始看起，这个函数是一个native函数，他被实现在frameworks/base/core/jni/android_util_Binder.cpp中 12345static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125; ProcessState我们在这里可以发现一个比较关键的类ProcessState，它是一个负责打开binder驱动并进行mmap映射的单例对象，这从它的self函数就可以看出来，每个进程只存在一个ProcessState实例 位置：frameworks/native/libs/binder/ProcessState.cpp 123456789sp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != nullptr) &#123; return gProcess; &#125; gProcess = new ProcessState(kDefaultDriver); return gProcess;&#125; 我们来看看它的构造函数 123456789101112131415161718192021ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver)) //打开binder驱动 , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE)&#123; if (mDriverFD &gt;= 0) &#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); ... &#125;&#125; 这里的:后是c++构造函数初始化赋值的一种语法，可以看到其中调用了open_driver函数打开binder驱动 123456789101112131415static int open_driver(const char *driver)&#123; //打开binder驱动 int fd = open(driver, O_RDWR | O_CLOEXEC); int vers = 0; //验证binder版本 status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ... &#125; //设置binder最大线程数 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); return fd;&#125; 这里做了三件事，打开binder驱动、验证binder版本、设置binder最大线程数，接着构造函数调用mmap建立binder映射，这里面的实现我们已经在Android源码分析 - Binder驱动（上）、（中）、（下）中分析过了，感兴趣的同学可以回过头去看一看 ProcessState::self函数执行完后，当前进程的binder初始化工作已经执行完毕，接下来我们回过头来看它的getContextObject函数 1234567891011121314sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; sp&lt;IBinder&gt; context = getStrongProxyForHandle(0); if (context == nullptr) &#123; ALOGW(\"Not able to get context object on %s.\", mDriverName.c_str()); &#125; // The root object is special since we get it directly from the driver, it is never // written by Parcell::writeStrongBinder. internal::Stability::tryMarkCompilationUnit(context.get()); return context;&#125; 我们在binder驱动篇就提到了，handle句柄0代表的就是ServiceManager，所以这里调用getStrongProxyForHandle函数的参数为0 12345678910111213141516171819202122232425262728293031323334sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); //查找或建立handle对应的handle_entry handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) &#123; IBinder* b = e-&gt;binder; if (b == nullptr || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; //当handle为ServiceManager的特殊情况 //需要确保在创建Binder引用之前，context manager已经被binder注册 Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; &#125; //创建BpBinder并保存下来以便后面再次查找 b = BpBinder::create(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; 12345678910111213ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)&#123; const size_t N=mHandleToObject.size(); //新建一个handle_entry并插入到vector中 if (N &lt;= (size_t)handle) &#123; handle_entry e; e.binder = nullptr; e.refs = nullptr; status_t err = mHandleToObject.insertAt(e, N, handle+1-N); if (err &lt; NO_ERROR) return nullptr; &#125; return &amp;mHandleToObject.editItemAt(handle);&#125; 整条链路下来还是比较清晰的，最终获得了一个BpBinder对象，这是native中的类型，需要将它转换成java中的类型，这里调用了javaObjectForIBinder函数，位于frameworks/base/core/jni/android_util_Binder.cpp中 javaObjectForIBinder1234567891011121314151617181920212223242526272829303132333435// If the argument is a JavaBBinder, return the Java object that was used to create it.// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; if (val == NULL) return NULL; //JavaBBinder返回true，其他类均返回flase if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); return object; &#125; BinderProxyNativeData* nativeData = new BinderProxyNativeData(); nativeData-&gt;mOrgue = new DeathRecipientList; nativeData-&gt;mObject = val; jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); if (env-&gt;ExceptionCheck()) &#123; // In the exception case, getInstance still took ownership of nativeData. return NULL; &#125; BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); //如果object是刚刚新建出来的BinderProxy if (actualNativeData == nativeData) &#123; //处理proxy计数 ... &#125; else &#123; delete nativeData; &#125; return object;&#125; 我们先看一看这个gBinderProxyOffsets是什么 123456789101112131415161718192021222324252627static struct binderproxy_offsets_t&#123; // Class state. jclass mClass; jmethodID mGetInstance; jmethodID mSendDeathNotice; // Object state. //指向BinderProxyNativeData的指针 jfieldID mNativeData; // Field holds native pointer to BinderProxyNativeData.&#125; gBinderProxyOffsets;const char* const kBinderProxyPathName = \"android/os/BinderProxy\";static int int_register_android_os_BinderProxy(JNIEnv* env)&#123; ... jclass clazz = FindClassOrDie(env, kBinderProxyPathName); gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz); gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, \"getInstance\", \"(JJ)Landroid/os/BinderProxy;\"); gBinderProxyOffsets.mSendDeathNotice = GetStaticMethodIDOrDie(env, clazz, \"sendDeathNotice\", \"(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V\"); gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, \"mNativeData\", \"J\"); ...&#125; 可以看到，gBinderProxyOffsets实际上是一个用来记录一些java中对应类、方法以及字段的结构体，用于从native层调用java层代码 接下来我们看javaObjectForIBinder函数的具体内容 123456789101112jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; if (val == NULL) return NULL; //JavaBBinder返回true，其他类均返回flase if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It's a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); return object; &#125; ...&#125; 首先有一个IBinder类型检查的判断，我看了一圈发现目前只有当IBinder的实际类型为JavaBBinder的时候会返回true，其他子类均返回false。JavaBBinder类继承自BBinder，里面保存了对java层Binder对象的引用，所以在这种情况下，直接返回里面的object就好了。 从这里可以看出，native层的javaBBinder与java层的Binder是对应关系 我们这里传进来的是BpBinder，会接着往下走 1234567891011jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... BinderProxyNativeData* nativeData = new BinderProxyNativeData(); nativeData-&gt;mOrgue = new DeathRecipientList; nativeData-&gt;mObject = val; jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); ...&#125; 接着实例化一个BinderProxyNativeData，将Binder死亡回调DeathRecipientList和Binder对象（这里为BpBinder）赋值给它，然后调用java层方法。gBinderProxyOffsets之前说过了，类为android.os.BinderProxy，方法为getInstance，所以这里调用的即为android.os.BinderProxy.getInstance(nativeData, iBinder)，BinderProxy的路径为frameworks/base/core/java/android/os/BinderProxy.java 123456789101112131415161718192021private static BinderProxy getInstance(long nativeData, long iBinder) &#123; BinderProxy result; synchronized (sProxyMap) &#123; try &#123; result = sProxyMap.get(iBinder); if (result != null) &#123; return result; &#125; result = new BinderProxy(nativeData); &#125; catch (Throwable e) &#123; // We're throwing an exception (probably OOME); don't drop nativeData. NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer, nativeData); throw e; &#125; NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData); // The registry now owns nativeData, even if registration threw an exception. sProxyMap.set(iBinder, result); &#125; return result;&#125; 这里的逻辑比较简单，以iBinder为 key 尝试从sProxyMap取出BinderProxy，如果取到值了就直接将它返回出去，如果没取到，用之前传进来的BinderProxyNativeData指针为参数实例化一个BinderProxy，并将其设置到sProxyMap中 从这里可以看出每一个服务的BinderProxy都是以单例形式存在的，并且native层的BinderProxyNativeData与java层的BinderProxy是对应关系 123456789101112131415161718BinderProxyNativeData* getBPNativeData(JNIEnv* env, jobject obj) &#123; return (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);&#125;jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... BinderProxyNativeData* actualNativeData = getBPNativeData(env, object); //如果object是刚刚新建出来的BinderProxy if (actualNativeData == nativeData) &#123; //处理proxy计数 ... &#125; else &#123; delete nativeData; &#125; return object;&#125; 接下来判断我们通过BinderProxy.getInstance方法获得的BinderProxy是不是刚刚创建出来的，如果是新建的则需要处理一下proxy计数，这里是通过对比BinderProxy中的mNativeData和我们新建出来的nativeData地址判断的 ServiceManagerNative.asInterface我们将目光放回getIServiceManager方法，现在我们知道BinderInternal.getContextObject()方法返回了ServiceManager对应的BinderProxy，接着会调用Binder.allowBlocking方法，这个方法只是改变了BinderProxy中的一个参数，使其允许阻塞调用，这样的话getIServiceManager就可以被简化成如下代码 12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(/* BinderProxy */); return sServiceManager;&#125; 我们看到asInterface方法实际上是直接实例化了一个ServiceManagerProxy对象 12345678public static IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // ServiceManager is never local return new ServiceManagerProxy(obj);&#125; ServiceManagerProxy从名字就能听出来，ServiceManagerProxy其实是一个代理类，它其实是IServiceManager.Stub.Proxy的代理，实际上是没有什么必要的，可以发现作者也在注释中标注了This class should be deleted and replaced with IServiceManager.Stub whenever mRemote is no longer used，我们看一下它的构造方法 1234public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; mServiceManager = IServiceManager.Stub.asInterface(remote);&#125; ServiceManagerProxy实现了IServiceManager接口，但这个方法的实现都是直接调用mServiceManager，以addService举例 1234public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException &#123; mServiceManager.addService(name, service, allowIsolated, dumpPriority);&#125; 这与直接使用IServiceManager.Stub.asInterface(remote)得到IServiceManager并没有什么区别 IServiceManager我们将重点转到IServiceManager上，我们在源码中搜索不到IServiceManager.java文件，因为实际上这个文件是通过aidl生成的 关于aidl我们到后面再详细分析，现在我们只需要知道它其实是辅助我们进行binder通信的一种工具，aidl文件会在编译过程中生成出与之对应的java文件 IServiceManager的aidl文件路径为frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl 我们来看一下它生成出的IServiceManager.Stub.asInterface方法 1234567891011public static android.os.IServiceManager asInterface(android.os.IBinder obj)&#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof android.os.IServiceManager))) &#123; return ((android.os.IServiceManager) iin); &#125; return new android.os.IServiceManager.Stub.Proxy(obj);&#125; 这里我们传入的IBinder是BinderProxy，它的queryLocalInterface永远返回null，所以这里返回的是IServiceManager.Stub.Proxy对象，我们接着看之前调用的getService方法 123456789101112131415161718@Override public android.os.IBinder getService(java.lang.String name) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); android.os.IBinder _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); boolean _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, 0); _reply.readException(); _result = _reply.readStrongBinder(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; ParcelParcel是一个存放读取数据的容器，它的基本功能和使用相信进阶Android开发应该都懂，我们在这里只介绍一些关键性函数的含义，其他就不多赘述了，有机会的话以后单独开一章分析它 函数 作用 obtain 获取一个新的Parcel对象 ipcData、data 数据区首地址 ipcDataSize、dataSize 数据大小 ipcObjects 偏移数组首地址 ipcObjectsCount IPC对象数量 dataPosition 数据指针当前的位置 dataCapacity 数据区的总容量（始终 &gt;= dataSize） 这里获取了两个Parcel，一个_data用来传递参数数据，一个_reply用来接收回应。接着，_data首先调用writeInterfaceToken方法，这里的token是客户端与服务端的一个协定，服务端会校验我们写入的这个token，然后按照顺序将参数依次写入到_data中（序列化），然后通过binder调用远程服务真正的方法，然后检查异常。 对于无返回值的方法来说，到这一步已经结束了，但我们这个方法是有返回值的，所以我们需要一个_result，从_reply中读取出数据（反序列化），赋给_result，然后返回出去 BinderProxy.transact我们重点看transact这一部分，通过我们之前的分析，我们知道mRemote是一个BinderProxy类型的对象，我们来看他的transact方法 123456789101112131415161718192021222324252627public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; //检查Parcel大小 Binder.checkParcel(this, code, data, \"Unreasonably large binder buffer\"); ... //trace ... //Binder事务处理回调 ... //AppOpsManager信息记录 ... try &#123; final boolean result = transactNative(code, data, reply, flags); if (reply != null &amp;&amp; !warnOnBlocking) &#123; reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT); &#125; return result; &#125; finally &#123; ... &#125;&#125; 我这里简化了一下代码，可以看到，首先就是对Parcel大小的检查 12345678910111213141516171819202122static void checkParcel(IBinder obj, int code, Parcel parcel, String msg) &#123; if (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= 800*1024) &#123; // Trying to send &gt; 800k, this is way too much. StringBuilder sb = new StringBuilder(); sb.append(msg); sb.append(\": on \"); sb.append(obj); sb.append(\" calling \"); sb.append(code); sb.append(\" size \"); sb.append(parcel.dataSize()); sb.append(\" (data: \"); parcel.setDataPosition(0); sb.append(parcel.readInt()); sb.append(\", \"); sb.append(parcel.readInt()); sb.append(\", \"); sb.append(parcel.readInt()); sb.append(\")\"); Slog.wtfStack(TAG, sb.toString()); &#125;&#125; Android默认设置了Parcel数据传输不能超过800k，当然，各个厂商是可以随意改动这里的代码的，如果超过了的话，便会调用Slog.wtfStack打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash 省去中间的一些log、回调，接下来便是调用transactNative方法，这是一个native方法，实现在frameworks/base/core/jni/android_util_Binder.cpp中 12345678910111213141516171819202122232425262728293031323334353637383940static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; if (dataObj == NULL) &#123; jniThrowNullPointerException(env, NULL); return JNI_FALSE; &#125; Parcel* data = parcelForJavaObject(env, dataObj); if (data == NULL) &#123; return JNI_FALSE; &#125; Parcel* reply = parcelForJavaObject(env, replyObj); if (reply == NULL &amp;&amp; replyObj != NULL) &#123; return JNI_FALSE; &#125; IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); if (target == NULL) &#123; jniThrowException(env, \"java/lang/IllegalStateException\", \"Binder has been finalized!\"); return JNI_FALSE; &#125; //log ... status_t err = target-&gt;transact(code, *data, reply, flags); //log ... if (err == NO_ERROR) &#123; return JNI_TRUE; &#125; else if (err == UNKNOWN_TRANSACTION) &#123; return JNI_FALSE; &#125; signalExceptionForError(env, obj, err, true /*canThrowRemoteException*/, data-&gt;dataSize()); return JNI_FALSE;&#125; 这里首先是获得native层对应的Parcel并执行判断，Parcel实际上功能是在native中实现的，java中的Parcel类使用mNativePtr成员变量保存了其对应native中的Parcel的指针 然后调用getBPNativeData函数获得BinderProxy在native中对应的BinderProxyNativeData，再通过里面的mObject域成员变量得到其对应的BpBinder，这个函数在之前分析javaObjectForIBinder的时候已经出现过了 BpBinder.transact之后便是调用BpBinder的transact函数了 12345678910111213141516status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // Once a binder has died, it will never come back to life. //判断binder服务是否存活 if (mAlive) &#123; ... status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 这里有一个Alive判断，可以避免对一个已经死亡的binder服务再发起事务，浪费资源，除此之外便是调用IPCThreadState的transact函数了 IPCThreadState路径：frameworks/native/libs/binder/IPCThreadState.cpp 还记得我们之前提到的ProcessState吗？IPCThreadState和它很像，ProcessState负责打开binder驱动并进行mmap映射，而IPCThreadState则是负责与binder驱动进行具体的交互 IPCThreadState也有一个self函数，与ProcessState的self不同的是，ProcessState是进程单例，而IPCThreadState是线程单例，我们来看看它是怎么实现的 1234567891011121314151617181920212223242526272829303132333435363738IPCThreadState* IPCThreadState::self()&#123; //不是初次调用的情况 if (gHaveTLS.load(std::memory_order_acquire)) &#123;restart: //初次调用，生成线程私有变量key后 const pthread_key_t k = gTLS; //先从线程本地储存空间中尝试获取值 IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; //没有的话就实例化一个 return new IPCThreadState; &#125; //IPCThreadState shutdown后不能再获取 if (gShutdown.load(std::memory_order_relaxed)) &#123; ALOGW(\"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\\n\"); return nullptr; &#125; //首次获取时gHaveTLS为false，会先走这里 pthread_mutex_lock(&amp;gTLSMutex); if (!gHaveTLS.load(std::memory_order_relaxed)) &#123; //创建一个key，作为存放线程本地变量的key int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor); if (key_create_value != 0) &#123; pthread_mutex_unlock(&amp;gTLSMutex); ALOGW(\"IPCThreadState::self() unable to create TLS key, expect a crash: %s\\n\", strerror(key_create_value)); return nullptr; &#125; //创建完毕，gHaveTLS置为true gHaveTLS.store(true, std::memory_order_release); &#125; pthread_mutex_unlock(&amp;gTLSMutex); //回到gHaveTLS为true的case goto restart;&#125; gHaveTLS是一个原子类型的bool值，它在存取过程中需要指定内存序std::memory_order_xxx，在这里我们直接忽略掉，把它当成一个纯粹的bool值就好了 在这里，TLS的全称为Thread Local Storage，表示线程本地储存空间，和java中的ThreadLocal其实是一个作用 当一个线程初次获取IPCThreadState的时候，会先走到gHaveTLS为false的case，此时程序会创建一个key，作为存放线程本地变量的key，创建成功后将gHaveTLS置为true，然后goto到gHaveTLS为true的case，此时线程本地储存空间中暂时还是没有数据的，所以会new一个IPCThreadState出来，在IPCThreadState的构造函数中，会将自己保存到线程本地储存空间中，这样，当线程第二次再获取IPCThreadState的时候，便会直接走到pthread_getspecific这里获取并返回 12345678910111213141516IPCThreadState::IPCThreadState() : mProcess(ProcessState::self()), mServingStackPointer(nullptr), mServingStackPointerGuard(nullptr), mWorkSource(kUnsetWorkSource), mPropagateWorkSource(false), mIsLooper(false), mIsFlushing(false), mStrictModePolicy(0), mLastTransactionBinderFlags(0), mCallRestriction(mProcess-&gt;mCallRestriction) &#123; pthread_setspecific(gTLS, this); clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256);&#125; 我们通过构造函数可以发现，它调用了pthread_setspecific函数将自身保存在了线程本地储存空间中 IPCThreadState中，成员变量mIn用于接收来自binder设备的数据，mOut用于储存发往binder设备的数据，他们的默认容量都为256字节 transact我们接着看它的transact函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; LOG_ALWAYS_FATAL_IF(data.isForRpc(), \"Parcel constructed for RPC, but being used with binder.\"); status_t err; flags |= TF_ACCEPT_FDS; //log ... err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; //binder事务不为TF_ONE_WAY //当线程限制binder事务不为TF_ONE_WAY时 if (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123; if (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123; //这个限制只是log记录 ALOGE(\"Process making non-oneway call (code: %u) but is restricted.\", code); CallStack::logStack(\"non-oneway call\", CallStack::getCurrent(10).get(), ANDROID_LOG_ERROR); &#125; else /* FATAL_IF_NOT_ONEWAY */ &#123; //这个限制会终止线程 LOG_ALWAYS_FATAL(\"Process may not make non-oneway calls (code: %u).\", code); &#125; &#125; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; //log ... &#125; else &#123; err = waitForResponse(nullptr, nullptr); &#125; return err;&#125; 这个函数的重点在于writeTransactionData和waitForResponse，我们依次分析 writeTransactionData1234567891011121314151617181920212223242526272829303132333435363738394041status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ //目标binder句柄值，ServiceManager为0 tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; //数据大小 tr.data_size = data.ipcDataSize(); //数据区起始地址 tr.data.ptr.buffer = data.ipcData(); //传递的偏移数组大小 tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); //偏移数组的起始地址 tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; //这里为BC_TRANSACTION mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 在分析这个函数之前，我们需要先回忆一下在前面binder驱动章节我们所学习的binder结构和通信过程：Android源码分析 - Binder驱动（中） binder_tansaction首先会读取一个请求码cmd，当binder请求码为BC_TRANSACTION/BC_REPLY的时候，binder驱动所接收的参数为binder_transaction_data结构体，所以在这个函数中，我们将binder请求码（这里为BC_TRANSACTION）和binder_transaction_data结构体依次写入到mOut中，为之后binder_tansaction做准备 waitForResponse数据准备好后，接着便来到了waitForResponse函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; err = mIn.errorCheck(); if (err &lt; NO_ERROR) break; if (mIn.dataAvail() == 0) continue; cmd = (uint32_t)mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; \"Processing waitForResponse Command: \" &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; switch (cmd) &#123; case BR_ONEWAY_SPAM_SUSPECT: ... case BR_TRANSACTION_COMPLETE: //当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束 if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: ... case BR_FAILED_REPLY: ... case BR_FROZEN_REPLY: ... case BR_ACQUIRE_RESULT: ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); //失败直接返回 if (err != NO_ERROR) goto finish; if (reply) &#123; //客户端需要接收replay if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //正常reply内容 reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer /*释放缓冲区*/); &#125; else &#123; //内容只是一个32位的状态码 //接收状态码 err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); //释放缓冲区 freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; //客户端不需要接收replay //释放缓冲区 freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; default: //这里是binder服务端部分的处理，现在不需要关注 err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; logExtendedError(); &#125; return err;&#125; 这里有一个循环，正如函数名所描述，会一直等待到一整条binder事务链结束返回后才会退出这个循环，在这个循环的开头，便是talkWithDriver方法 talkWithDriver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; //检查打开的binder设备的fd if (mProcess-&gt;mDriverFD &lt; 0) &#123; return -EBADF; &#125; binder_write_read bwr; // Is the read buffer empty? //dataPosition &gt;= dataSize说明上一次读取到的数据已经消费完 const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // We don't want to write anything if we are still reading // from data left in the input buffer and the caller // has requested to read the next data. //需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容 const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; //将read_size设置为读缓存可用容量 bwr.read_size = mIn.dataCapacity(); //设置读缓存起始地址 bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // Return immediately if there is nothing to do. //没有要读写的数据就直接返回 if ((bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)) return NO_ERROR; bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; //调用binder驱动的ioctl if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno; if (mProcess-&gt;mDriverFD &lt; 0) &#123; err = -EBADF; &#125; &#125; while (err == -EINTR); if (err &gt;= NO_ERROR) &#123; //写数据被消费了 if (bwr.write_consumed &gt; 0) &#123; //写数据没有被消费完 if (bwr.write_consumed &lt; mOut.dataSize()) LOG_ALWAYS_FATAL(\"Driver did not consume write buffer. \" \"err: %s consumed: %zu of %zu\", statusToString(err).c_str(), (size_t)bwr.write_consumed, mOut.dataSize()); else &#123; //写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了 mOut.setDataSize(0); processPostWriteDerefs(); &#125; &#125; //读到了数据 if (bwr.read_consumed &gt; 0) &#123; //设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了 mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; return NO_ERROR; &#125; return err;&#125; 这里的binder_write_read也是一个我们熟悉的结构，我们在之前的文章Android源码分析 - Binder驱动（中）中了解过，关于binder通信的代码，我们需要结合着binder驱动一起看才能理解 在binder驱动层中，binder_ioctl_write_read函数会从用户空间读取一个binder_write_read结构，这个结构体主要描述了数据传输的大小和位置以及消费情况（已读/写数据大小），这么看来，talkWithDriver函数的结构就很清晰了： 创建出binder_write_read结构，根据之前的读取情况，决定是否读写数据，设置写数据内容和大小，设置读数据的空间和容量 调用binder驱动的ioctl 重置写缓存，根据ioctl的结果设置读缓存 这之后，waitForResponse函数就可以从读缓存mIn中读到数据了，我们回到这个函数中，发现它首先从读缓存中读取了一个binder响应码，然后根据这个响应码再处理接下来的工作 处理Reply在此之前，我们先回顾一下一次binder_tansaction的整个过程，根据事务类型，分为两种情况： TF_ONE_WAY 非 TF_ONE_WAY 我们先对照着看TF_ONE_WAY的情况 123456789101112status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; switch (cmd) &#123; ... case BR_TRANSACTION_COMPLETE: //当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束 if (!reply &amp;&amp; !acquireResult) goto finish; break; ... &#125; &#125;&#125; 对于TF_ONE_WAY模式来说，客户端在收到BR_TRANSACTION_COMPLETE响应码后则返回，不会再等待BR_REPLY 而对于非TF_ONE_WAY模式来说，客户端不仅会收到BR_TRANSACTION_COMPLETE响应码，之后还会阻塞等待binder驱动给它发来BR_REPLY响应码，这之后一次binder_transaction才算完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; switch (cmd) &#123; ... case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, \"Not enough command data for brREPLY\"); //失败直接返回 if (err != NO_ERROR) goto finish; if (reply) &#123; //客户端需要接收replay if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //正常reply内容 reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer /*释放缓冲区*/); &#125; else &#123; //内容只是一个32位的状态码 //接收状态码 err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); //释放缓冲区 freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); &#125; &#125; else &#123; //客户端不需要接收replay //释放缓冲区 freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t)); continue; &#125; &#125; goto finish; ... &#125; &#125;&#125; 一般来说，非TF_ONE_WAY模式肯定是需要一个reply来接收的，即reply != null，此时我们来看看接收正常reply的过程（接收32位状态码没什么好说的，直接从读缓冲区中强制类型转换出一个32位的code就完事了） 这里我们就需要看一下Parcel的ipcSetDataReference函数了 12345678910111213141516171819202122232425262728293031323334353637383940void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc) &#123; // this code uses 'mOwner == nullptr' to understand whether it owns memory LOG_ALWAYS_FATAL_IF(relFunc == nullptr, \"must provide cleanup function\"); //先清理重置一下数据和状态 freeData(); auto* kernelFields = maybeKernelFields(); LOG_ALWAYS_FATAL_IF(kernelFields == nullptr); // guaranteed by freeData. mData = const_cast&lt;uint8_t*&gt;(data); mDataSize = mDataCapacity = dataSize; kernelFields-&gt;mObjects = const_cast&lt;binder_size_t*&gt;(objects); kernelFields-&gt;mObjectsSize = kernelFields-&gt;mObjectsCapacity = objectsCount; mOwner = relFunc; //检查数据 binder_size_t minOffset = 0; for (size_t i = 0; i &lt; kernelFields-&gt;mObjectsSize; i++) &#123; binder_size_t offset = kernelFields-&gt;mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(\"%s: bad object offset %\" PRIu64 \" &lt; %\" PRIu64 \"\\n\", __func__, (uint64_t)offset, (uint64_t)minOffset); kernelFields-&gt;mObjectsSize = 0; break; &#125; const flat_binder_object* flat = reinterpret_cast&lt;const flat_binder_object*&gt;(mData + offset); uint32_t type = flat-&gt;hdr.type; //binder类型出现异常 if (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE || type == BINDER_TYPE_FD)) &#123; ... kernelFields-&gt;mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; 其实这个函数也不复杂，我们知道binder_mmap做到了一次拷贝，将数据拷贝到了内核物理内存中，然后将其与用户空间虚拟内存做了映射，所以这个函数此时只需要将数据的地址，大小等等无脑赋值进去，客户端后续便可以用Parcel提供的函数方便的从中读取数据了 freeBuffer最后我们再来看一下freeBuffer这个释放缓冲区的方法， 123456789101112void IPCThreadState::freeBuffer(Parcel* parcel, const uint8_t* data, size_t /*dataSize*/, const binder_size_t* /*objects*/, size_t /*objectsSize*/)&#123; ... if (parcel != nullptr) parcel-&gt;closeFileDescriptors(); IPCThreadState* state = self(); state-&gt;mOut.writeInt32(BC_FREE_BUFFER); state-&gt;mOut.writePointer((uintptr_t)data); state-&gt;flushIfNeeded();&#125; 可以看到，这里向binder驱动发送了一个BC_FREE_BUFFER请求，然后binder驱动会负责回收这块缓冲区内存 我们在Parcel::ipcSetDataReference函数中可以发现，它将freeBuffer函数指针赋值给了mOwner，等到什么时候不需要这个Parcel了，便会调用这个函数进行缓冲区内存回收 结束到这里，我们客户端与binder驱动沟通交互的分析就结束了，相比binder驱动而言，framework层的binder就好理解多了，下一章我们会从服务端的角度来看，它是怎么从binder驱动接收并处理客户端的请求的","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Jetpack Compose入门","slug":"android/jetpack/compose/JetpackCompose入门","date":"2022-04-07T08:54:00.000Z","updated":"2022-11-13T09:55:54.359Z","comments":true,"path":"2022/04/07/android/jetpack/compose/JetpackCompose入门/","link":"","permalink":"http://yoursite.com/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/","excerpt":"","text":"简介Jetpack Compose是用于构建原生Android界面的新工具包。它是一种声明式的UI布局，其官方声称可简化并加快Android上的界面开发，使用更少的代码、强大的工具和直观的Kotlin API，快速让应用生动而精彩。 官网：https://developer.android.com/jetpack/compose?hl=zh-cn 我这里也写了一个Compose的Demo，可以对照着看：https://github.com/dreamgyf/ComposeDemo 这个Demo实现了： Compose替代传统布局 网格列表效果，类似于传统布局中的RecyclerView配合GridLayoutManager 在传统View中使用Compose 在Compose中使用传统View 自定义布局 前置工作使用Jetpack Compose需要先引入一些依赖： 1234567891011dependencies &#123; implementation 'androidx.core:core-ktx:1.7.0' implementation \"androidx.compose.ui:ui:$compose_version\" implementation \"androidx.compose.material:material:$compose_version\" implementation \"androidx.compose.ui:ui-tooling-preview:$compose_version\" implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1' implementation 'androidx.activity:activity-compose:1.3.1' debugImplementation \"androidx.compose.ui:ui-tooling:$compose_version\" //网络图片加载三方库 implementation \"io.coil-kt:coil-compose:1.4.0\"&#125; 可组合函数Jetpack Compose是围绕着可组合函数构建起来的，这些函数以程序化方式定义应用的界面，只需描述应用界面的外观并提供数据依赖项，而不必关注界面的构建过程。此类函数有几个要点： 所有可组合函数必须使用@Composable注解修饰 可组合函数可以像正常函数一样接受参数 1234@Composablefun Demo(name: String) &#123; Text(text = \"Hello, $&#123;name&#125;!\")&#125; 可组合函数内部可以书写正常代码（譬如可以通过if else控制显示的控件） 12345678910@Composablefun Demo(showPic: Boolean) &#123; if (showPic) &#123; Image( painter = painterResource(id = R.drawable.demo), contentDescription = null ) &#125; Text(text = \"Hello, compose!\")&#125; 单位Android常用的单位dp，sp等，在Compose中以类的形式被定义，使用的方式也很简单，Compose借助了kotlin的扩展属性，扩展了Int，Double，Float三个基础类，使用方式如下： 1234//dp1.dp; 2.3f.dp; 4.5.dp//sp1.sp; 2.3f.sp; 4.5.sp 资源如何在Compose中使用资源呢，可以通过xxxResource方法 12345678910//图片资源fun painterResource(@DrawableRes id: Int): Painter//尺寸资源fun dimensionResource(@DimenRes id: Int): Dp//颜色资源fun colorResource(@ColorRes id: Int): Color//字符串资源fun stringResource(@StringRes id: Int): String//字体资源fun fontResource(fontFamily: FontFamily): Typeface ModifierModifier是Compose中的布局修饰符，它控制了布局的大小，padding，对齐，背景，边框，裁切，点击等属性，几乎所有的Compose布局都需求这项参数，是Compose布局中的重中之重 这里介绍一些常用的基本属性，文中没列到的属性可以去官网查看：https://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn 尺寸 fillMaxWidth和fillMaxHeight相当于xml布局中的match_parent fillMaxSize相当于同时设置了fillMaxWidth和fillMaxHeight wrapContentWidth和wrapContentHeight相当于xml布局中的wrapContent wrapContentSize相当于同时设置了wrapContentWidth和wrapContentHeight width和height则是设置固定宽高，单位为Dp size相当于同时设置了width和height weight属性仅在Row或Column的内部作用域中可以使用，相当于传统LinearLayout布局中的weight属性 paddingpadding方法有几个重载，这些API很简单，看参数就很容易能明白意思 对齐align属性，使控件可以在父布局中以一种方式对齐，相当于xml布局中的layout_gravity属性。另外还有alignBy以及alignByBaseline属性可以自行研究 绘图 background设置背景，不过不能设置图片，如果想以图片作为背景可以使用Box布局，在底部垫一个Image控件 alpha设置透明度 clip裁剪内容，这个功能很强大，可以直接将视图裁出圆角，圆形等形状 操作 clickable方法，可以设置控件的点击事件回调 combinedClickable方法，可以设置控件的点击、双击、长按事件回调 selectable方法，将控件配置为可点击，同时可以设置点击事件 滚动 horizontalScroll：使控件支持水平滚动 verticalScroll：使控件支持垂直滚动 注意事项在Modifier中设置属性的前后顺序是很重要的，譬如想要一个背景为蓝色的圆角布局，需要先设置clip，再设置background，反过来background会超出圆角范围 SpacerCompose中没有了margin的概念，可以用Spacer替代，Spacer为留白的意思，使用起来也很简单 12//水平间隔8dpSpacer(modifier = Modifier.width(8.dp)) 基础布局Row &amp; Column这是两个基本布局组件，其中Row为水平布局，Column为垂直布局，他们俩接受的参数相似，其中两个参数为horizontalArrangement和verticalAlignment，他们一个表示水平布局方式，一个表示垂直布局方式，他们默认值为START和TOP，这两个参数用起来就和传统布局的gravity参数一样 BoxBox也是一种基本布局组件，Box布局中的组件是可以叠加的，类似传统布局中的FrameLayout，可以通过contentAlignment参数调整叠加的方式，其默认值为TopStart，叠加到左上角，这个参数也和FrameLayout的gravity参数一样 基础控件Text文本控件，对应传统控件TextView，它有以下一些属性 属性 说明 text 文本内容 color 文字颜色 fontSize 文字大小 fontStyle 文本样式（可以设置斜体） fontWeight 字重（粗体等） fontFamily 字体 letterSpacing 文字间距 textAlign 文本对齐方式 lineHeight 行高 maxLines 最大行数 … … Image图片控件，对应传统控件ImageView，它有以下一些属性 属性 说明 painter 图片内容 contentDescription 无障碍描述（可为null） alignment 对齐方式 contentScale 缩放方式（和scaleType属性类似） alpha 透明度 … … 在开发中经常会面对从网络价值图片的情况，这时候可以借助一些第三方库来解决，这里以coil库为例： 先添加依赖 1implementation \"io.coil-kt:coil-compose:1.4.0\" 使用 12345678Image( modifier = Modifier .size(68.dp, 68.dp) .clip(RoundedCornerShape(6.dp)), contentScale = ContentScale.Crop, painter = rememberImagePainter(picUrl), //使用rememberImagePainter方法填入图片url contentDescription = null) 列表Compose有两种组件LazyRow和LazyColumn，一种水平，一种垂直，对应着传统UI中的RecyclerView，用这些组件可以方便的构建列表视图，它们需要提供一个LazyListScope.()块描述列表项内容 LazyListScope的DSL提供了多种函数来描述列表项： 1234567891011121314//用于添加单个列表项fun item(key: Any? = null, content: @Composable LazyItemScope.() -&gt; Unit)//用于添加多个列表项fun items( count: Int, key: ((index: Int) -&gt; Any)? = null, itemContent: @Composable LazyItemScope.(index: Int) -&gt; Unit )//用于添加多个列表项fun &lt;T&gt; LazyListScope.items( items: List&lt;T&gt;, noinline key: ((item: T) -&gt; Any)? = null, crossinline itemContent: @Composable LazyItemScope.(item: T) -&gt; Unit) 示例： 1234567891011121314151617181920212223val list = mutableListOf(0, 1, 2, 3, 4)LazyColumn &#123; //增加单个列表项 item &#123; Text(text = \"First item\") &#125; //增加5个列表项 items(5) &#123; index -&gt; Text(text = \"Item: $index\") &#125; //增加5个列表项 items(list) &#123; listItem -&gt; Text(text = \"Item: $listItem\") &#125; //增加单个列表项 item &#123; Text(text = \"Last item\") &#125;&#125; 可以使用contentPadding为内容添加内边距，使用verticalArrangement或horizontalArrangement，以Arrangement.spacedBy()为列表项之间添加间距 状态在Compose中，数据的更新和传统命令式UI不同，是通过一种可观察类型对象，当一个可观察类型对象发生改变时，这个对象对应观察的部分会发生重组，从而自动更新UI 可观察类型MutableState&lt;T&gt;通常是通过mutableStateOf()函数创建的，这个对象的value发生变化时，对应UI也会跟着随之变化 123456789101112131415161718192021222324252627//这里使用了kotlin的by关键字，是一种代理模式//如果使用 = 的话，这个对象的类型会发生变化，需要count.value这样使用它的值//var count = mutableStateOf(0)var count by mutableStateOf(0)@Composablefun Demo(count: Int) &#123; Column &#123; Text(text = \"count: $&#123;count&#125;\") Button(onClick = &#123; addCount() &#125;) &#123; Text(text = \"add count\") &#125; &#125;&#125;fun addCount() &#123; //++count.value ++count&#125;@Preview@Composablefun Preview() &#123; //当点击Button时，触发点击事件，更新可观察对象count，触发UI重组 //Demo(count.value) Demo(count)&#125; 关于Context在Compose中可以通过LocalContext.current获得当前Context 在传统View中使用Compose可以在一个传统布局xml中插入一个ComposeView 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:id=\"@+id/hello_world\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Hello from XML layout\" /&gt; &lt;!-- 插入ComposeView --&gt; &lt;androidx.compose.ui.platform.ComposeView android:id=\"@+id/compose_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; 然后在代码中设置这个ComposeView 123findViewById&lt;ComposeView&gt;(R.id.compose_view).setContent &#123; Text(\"Hello Compose!\")&#125; 在Compose中使用传统View可以使用AndroidView这个composable函数，这个函数接受一个factory参数，这个参数接受一个Context，用于构建传统View，要求返回一个继承自View的对象 123456789101112@Composablefun Demo() &#123; Column &#123; Text(text = \"Compose Text\") AndroidView(factory = &#123; context -&gt; //这里也可以使用LayoutInflater从xml中解析出一个View TextView(context).apply &#123; text = \"传统TextView\" &#125; &#125;) &#125;&#125; 自定义UI在Compose中，如果想要自定义一些简单的UI是很简单的，只需要写一个Composable函数就可以了，我们主要学习一下怎么自定义一些复杂的UI 我们先看一下怎么自定义一个布局，对应着传统UI中的ViewGroup，以一个简单的例子来说，我们自定义一个布局，让其中的子布局呈左上到右下依次排列： 123456789101112131415161718192021222324@Composablefun MyLayout(modifier: Modifier = Modifier, content: @Composable () -&gt; Unit) &#123; Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt; //测量每个子布局 val placeables = measurables.map &#123; measurable -&gt; measurable.measure(constraints) &#125; //设置布局大小为最大可容纳大小 layout(constraints.maxWidth, constraints.maxHeight) &#123; var xPosition = 0 var yPosition = 0 //放置每个子View placeables.forEach &#123; placeable -&gt; placeable.placeRelative(x = xPosition, y = yPosition) //下一个子View的坐标为上一个子View的右下角 xPosition += placeable.width yPosition += placeable.height &#125; &#125; &#125;&#125; 我们再看一个使用Canvas自定义View的方式，这个更简单，就是画一条水平线： 12345678@SuppressLint(\"ModifierParameter\")@Composablefun HorizontalLine(modifier: Modifier = Modifier.fillMaxWidth()) &#123; Canvas(modifier = Modifier .then(modifier), onDraw = &#123; drawLine(color = Color.Black, Offset(0f, 0f), Offset(size.width, 0f), 2f) &#125;)&#125; 我们将两者一起用一下看看效果 123456789@Preview(showBackground = true)@Composablefun Preview() &#123; MyLayout &#123; Text(text = \"Text1\") HorizontalLine(Modifier.width(50.dp)) Text(text = \"Text2\") &#125;&#125; 其实Compose中的自定义UI的思路和传统自定义View是一样的，只不过需要熟悉Compose中的各种Api才能灵活运用它","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Jetpack Compose","slug":"Android/Jetpack-Compose","permalink":"http://yoursite.com/categories/Android/Jetpack-Compose/"}],"tags":[{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"http://yoursite.com/tags/Jetpack-Compose/"}]},{"title":"Linux信号机制及其原理分析","slug":"linux/Linux信号机制及其原理分析","date":"2022-03-31T09:11:00.000Z","updated":"2022-11-13T09:55:54.362Z","comments":true,"path":"2022/03/31/linux/Linux信号机制及其原理分析/","link":"","permalink":"http://yoursite.com/2022/03/31/linux/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/","excerpt":"","text":"前言在最近在工作中，使用到了信号的相关知识，之前我们在分析Android系统init进程的时候也提到了信号，但并没有对信号这个机制做出深入的理解，借此机会，我们深入分析一下Linux信号机制是怎样实现的 简介信号（signal），是Unix系统中的一种古老的进程间通信机制，而Linux作为类Unix系统，早期也是模仿了Unix系统，自然也保留下了这个机制。信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟 注：本篇文章基于glibc版本2.35，Linux内核版本5.17，x86_64架构 信号的产生信号可以由内核产生，也可以由用户产生，这边举几个例子： 用户在终端输入ctrl + c时，会产生一个SIGINT信号 在程序中对一个数除0，会产生一个异常，最终由内核产生一个SIGFPE信号 在程序中非法访问一段内存，会由内核产生一个SIGBUS信号 在终端或程序中手动发送一个信号 终端：比如说kill -9 [pid] 程序：调用kill函数，raise函数等 信号种类在Linux中，信号被分为不可靠信号和可靠信号，一共64种，可以通过kill -l命令来查看 不可靠信号：也称为非实时信号，不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，信号值取值区间为1~31 可靠信号：也称为实时信号，支持排队，信号不会丢失，发多少次，就可以收到多少次，信号值取值区间为32~64 在早期的Linux中，只定义了前面的不可靠信号，随着时间的发展，发现有必要对信号机制加以改进和扩充，又由于原先定义的信号已有应用，出于兼容性考虑，不能再做改动，于是又新增了一部分信号，这些信号被定义为可靠信号。 在arch/x86/include/uapi/asm/signal.h中，我们可以发现这些信号的定义，在文末的附录中，我们也详细介绍了每个信号的含义和默认动作 如何使用我一向认为，如果想要理解一个技术原理，首先我们必须要会使用这个技术 发送信号之前提过，用户是可以手动向一个进程发送信号的，我们可以使用以下一些函数： kill原型： 123#include &lt;signal.h&gt;int kill(pid_t pid, int sig); 文档：https://man7.org/linux/man-pages/man2/kill.2.html 这个函数的作用是向指定进程（或进程组）发送一个信号，成功返回0，失败返回-1 其中的pid参数： 当pid &gt; 0时，发送信号给pid对应的进程 当pid = 0时，发送信号给本进程组中的所有进程 当pid = -1时，发送信号给所有调用进程有权给其发送信号的进程，除了init进程 当pid &lt; -1时，发送信号给进程组id为-pid的所有进程 当sig参数为0时，不会发送任何信号，但仍然会进行参数检测，我们可以用这种方法检查pid对应进程是否存在或允许发送信号 raise原型： 123#include &lt;signal.h&gt;int raise(int sig); 文档：https://man7.org/linux/man-pages/man3/raise.3.html 这个函数的作用是向本进程或线程发送信号，成功返回0，失败返回-1 这个函数对于主线程来说，相当于kill(getpid(), sig)，对于子线程来说，相当于pthread_kill(pthread_self(), sig) sigqueue原型： 123#include &lt;signal.h&gt;int sigqueue(pid_t pid, int sig, const union sigval value); 文档：https://man7.org/linux/man-pages/man3/sigqueue.3.html 这个函数的作用是向一个进程发送信号，同时可以传递一些额外数据，成功返回0，失败返回-1 这个函数和kill不同的地方是，它只能向一个进程发送信号，不能发送给信号组，当sig为0时，行为和kill一致 abort原型： 123#include &lt;stdlib.h&gt;noreturn void abort(void); 文档：https://man7.org/linux/man-pages/man3/abort.3.html 这个函数的作用是向本进程发送SIGABRT信号 需要注意的有两点： abort函数会首先解除进程对SIGABRT信号的阻塞 无论SIGABRT信号是否注册了自定义处理器，最后都会终止进程，因为abort函数会在SIGABRT信号处理完后恢复默认信号处理方式，然后重发这个信号 alarm原型： 123#include &lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); 文档：https://man7.org/linux/man-pages/man2/alarm.2.html 这个函数的作用是在seconds秒后向本进程发送SIGALRM信号 参数seconds为时间，单位为秒 返回值，如果以前没有设置过alarm或超时，则返回0，如果以前没有设置过alarm，则返回剩余的时间 处理信号我们是可以自定义一些信号的处理方式，需要注意的是，SIGKILL和SIGSTOP是两个特殊的信号，它们不允许被忽略、处理和阻塞 sigaction原型： 1234#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *restrict act, struct sigaction *restrict oldact); 文档：https://man7.org/linux/man-pages/man2/sigaction.2.html 这是较新的一个信号处理函数，它的作用是，对一个信号注册一个新的信号处理方式，并获取以前的信号处理方式，成功返回0，失败返回-1 第一个参数signum，用来指定信号的编号（需要设置哪个信号） 第二个参数act用来指定注册的新的信号处理方式 第三个参数oldact不为null时，可以用来获取该信号原来的处理方式 当参数act为null，oldact不为null时，这个函数可以用来只获取信号当前的处理方式 sigaction结构体123456789101112131415struct sigaction &#123; union &#123; __sighandler_t _sa_handler; void (*_sa_sigaction)(int, struct siginfo *, void *); &#125; _u; sigset_t sa_mask; unsigned long sa_flags; void (*sa_restorer)(void);&#125;;typedef void __signalfn_t(int);typedef __signalfn_t __user *__sighandler_t;#define sa_handler _u._sa_handler#define sa_sigaction _u._sa_sigaction 可以看到，其中有一个联合，它是用来兼容旧版本函数的，当参数sa_mask中含有SA_SIGINFO的时候，回调的是_sa_sigaction函数，当没有这个参数时，回调的是_sa_handler这个旧版本函数 _sa_sigaction函数相对于_sa_handler函数而言，多携带了一些信号信息，譬如说发送信号的进程pid _sa_handler可以被赋值成SIG_DFL或SIG_IGN，它们分别对应着默认处理和忽略信号，需要注意的时，它们只是一个int值，是不能被直接调用的 12#define SIG_DFL ((__force __sighandler_t)0) /* default signal handling */#define SIG_IGN ((__force __sighandler_t)1) /* ignore signal */ 这个结构体中的sa_mask域为一个信号集，表示当正在执行信号处理函数的时候，阻塞一些信号，只有这个信号处理完了，这些信号才会被处理 这个结构体中的sa_flags域，有如下一些标志： SA_NOCLDSTOP：当signum为SIGCHLD的时候才生效，当子进程暂停或恢复时，父进程不会收到SIGCHLD信号 SA_NOCLDWAIT：当signum为SIGCHLD的时候才生效，当子进程退出时，父进程不会收到SIGCHLD信号，子进程也不会成为僵尸进程 SA_NODEFER：一般情况下，当信号处理函数运行时，内核将阻塞对应的信号。但是如果设置了SA_NODEFER标记，那么在该信号处理函数运行时，内核将不会阻塞该信号 SA_ONSTACK：表示使用一个备用栈，当发生栈溢出时，内核会发出SIGILL信号，如果此时在原来的栈上调用信号处理函数，也会发生栈溢出，导致死循环，此时就需要准备一个备用栈，在备用栈上处理信号 SA_RESETHAND：表示设置的信号处理行为只生效一次，当触发我们设置的信号处理函数后，内核会将信号处理行为重置（SA_ONESHOT作用相同，但它是一个过时的，非标准的flag） SA_RESTART：当执行系统调用时，如果收到一个信号，系统默认将中断这个系统调用，转而执行信号处理函数，结束后让这个被中断的系统调用失败，设置了SA_RESTART标志后，当信号处理函数执行完后，会自动恢复执行这个被中断的系统调用 SA_SIGINFO：设置这个标志后，会回调_sa_sigaction作为信号处理函数，会携带更多的信号信息 signal原型： 123#include &lt;signal.h&gt;sighandler_t signal(int signum, sighandler_t handler); 文档：https://man7.org/linux/man-pages/man2/signal.2.html 这个函数的作用是，设置下一次的信号处理函数（只生效一次），成功返回上一次设置的信号处理函数，失败返回SIG_ERR 这个函数在新版本中实际上是通过sigaction函数实现的，推荐使用更加强大的sigaction函数 阻塞信号信号有几种状态，首先是信号的产生 (Genertion)，而实际执行信号处理动作时，状态为递达 (Delivery)，信号在产生到递达中的状态被称为未决 (Pending) 进程可以选择阻塞 (Blocking)某些信号，被阻塞的信号在产生后将保持在未决状态，直到进程解除对该信号的阻塞，才执行递达的动作 信号集函数我们可以用信号集函数改变当前进程的信号屏蔽字（Signal Mask），控制信号的阻塞与否 信号集设置函数12345678910111213141516171819#include &lt;signal.h&gt;//信号集数据类型typedef unsigned long sigset_t;//清空一个信号集（将这个sigset_t置0）//文档：https://man7.org/linux/man-pages/man3/sigemptyset.3p.htmlvoid sigemptyset(sigset_t *set);//填充满一个信号集（将这个sigset_t的每一位都置1）//文档：https://man7.org/linux/man-pages/man3/sigfillset.3p.htmlvoid sigfillset(sigset_t *set);//将指定的信号添加到信号集中（将这个sigset_t的对应信号位置1）//文档：https://man7.org/linux/man-pages/man3/sigaddset.3p.htmlint sigaddset(sigset_t *set, int signo);//将指定的信号从信号集中移除（将这个sigset_t的对应信号位置0）//文档：https://man7.org/linux/man-pages/man3/sigdelset.3p.htmlint sigdelset(sigset_t *set, int signo);//判断一个信号是否在这个信号集中（判断这个sigset_t的对应信号位是否为1）//文档：https://man7.org/linux/man-pages/man3/sigismember.3p.htmlint sigismember(const sigset_t *set, int signo); sigpromask原型： 123#include &lt;signal.h&gt; int sigpromask(int how, const sigset_t *set, sigset_t *oldset); 文档：https://man7.org/linux/man-pages/man2/sigprocmask.2.html 这个函数通过指定的方法和信号集修改进程的信号屏蔽字，成功返回0，失败返回-1 第一个参数how有3种取值： SIG_BLOCK：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置） SIG_UNBLOCK：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置） SIG_SETMASK：使用set中的信号直接代替原有信号屏蔽字中的信号 第二个参数set是一个信号集，怎么使用和参数how相关 第三个参数oldset，如果不为null，会将原有信号屏蔽字的信号集保存进去 sigpending原型： 123#include &lt;signal.h&gt;int sigpending(sigset_t *set); 这个函数的作用是获得当前进程的信号屏蔽字，将结果保存到传入的set中，成功返回0，失败返回-1 信号原理我们已经了解了信号的产生和处理，现在我们可以具体的看看一个信号从产生到响应处理，它经历了什么，它的原理是什么 我们在简介中说过：信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟，该怎么理解这句话呢？ 当我们对一个进程发送信号后，会将这个信号暂时存放到这个进程所对应的task_struct的pending队列中，此时，进程并不知道有新的信号过来了，这也就是异步的意思。那么进程什么时候才能得知并处理这个信号呢？有两个时机，一个是进程从内核态返回到用户态时，一个是进程从睡眠状态被唤醒。让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的，所以信号能很快的得到执行 下图为信号相关的一些结构 信号的发送我们以kill函数为例，看看信号是如何发送的，它被定义在tools/include/nolibc/nolibc.h中 1234567891011121314151617static __attribute__((unused))int kill(pid_t pid, int signal)&#123; int ret = sys_kill(pid, signal); if (ret &lt; 0) &#123; SET_ERRNO(-ret); ret = -1; &#125; return ret;&#125;static __attribute__((unused))int sys_kill(pid_t pid, int signal)&#123; return my_syscall2(__NR_kill, pid, signal);&#125; 可以看到，这里使用了系统调用，在Linux内核中，每个syscall都对应着唯一的系统调用号，kill函数的系统调用号为__NR_kill，它被定义在tools/include/uapi/asm-generic/unistd.h中 123/* kernel/signal.c */#define __NR_kill 129__SYSCALL(__NR_kill, sys_kill) 在x86_64架构的机器上，my_syscall2是这样被定义的 12345678910111213141516#define my_syscall2(num, arg1, arg2) \\(&#123; \\ long _ret; \\ register long _num asm(\"rax\") = (num); \\ register long _arg1 asm(\"rdi\") = (long)(arg1); \\ register long _arg2 asm(\"rsi\") = (long)(arg2); \\ \\ asm volatile ( \\ \"syscall\\n\" \\ : \"=a\"(_ret) \\ : \"r\"(_arg1), \"r\"(_arg2), \\ \"0\"(_num) \\ : \"rcx\", \"r11\", \"memory\", \"cc\" \\ ); \\ _ret; \\&#125;) 这里涉及到了扩展内联汇编，syscall指令需要一个系统调用号和一些参数，在x86_64架构中，系统调用号需要存放在rax寄存器中，参数依次存放在rdi, rsi, rdx, r10, r8, r9寄存器中，执行syscall指令后，内核会通过系统调用号去从系统调用表找到对应函数的入口 我们之前在找系统调用号__NR_kill的时候可以发现，上面标了注释，表明这个函数的实现在kernel/signal.c中，但我们在这个文件中并没有找到sys_kill这个函数，实际上这里隐藏了一个宏定义 在include/linux/syscalls.h中，我们可以找到这样一些宏定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#ifndef SYSCALL_DEFINE0#define SYSCALL_DEFINE0(sname) \\ SYSCALL_METADATA(_##sname, 0); \\ asmlinkage long sys_##sname(void); \\ ALLOW_ERROR_INJECTION(sys_##sname, ERRNO); \\ asmlinkage long sys_##sname(void)#endif /* SYSCALL_DEFINE0 */#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)#define SYSCALL_DEFINE_MAXARGS 6#define SYSCALL_DEFINEx(x, sname, ...) \\ SYSCALL_METADATA(sname, x, __VA_ARGS__) \\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)#define __PROTECT(...) asmlinkage_protect(__VA_ARGS__)/* * The asmlinkage stub is aliased to a function named __se_sys_*() which * sign-extends 32-bit ints to longs whenever needed. The actual work is * done within __do_sys_*(). */#ifndef __SYSCALL_DEFINEx#define __SYSCALL_DEFINEx(x, name, ...) \\ __diag_push(); \\ __diag_ignore(GCC, 8, \"-Wattribute-alias\", \\ \"Type aliasing is used to sanitize syscall arguments\");\\ asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \\ __attribute__((alias(__stringify(__se_sys##name)))); \\ ALLOW_ERROR_INJECTION(sys##name, ERRNO); \\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\\ asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)); \\ asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \\ &#123; \\ long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\\ __MAP(x,__SC_TEST,__VA_ARGS__); \\ __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); \\ return ret; \\ &#125; \\ __diag_pop(); \\ static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))#endif /* __SYSCALL_DEFINEx */ SYSCALL_DEFINEx中的x表示接受x个参数，这个宏定义根据传入的name参数，以sys_name为名定义了一个函数，也就是说SYSCALL_DEFINE2(kill, ...)这个宏展开后基本相当于sys_kill函数，在kernel/signal.c中我们可以找到这段代码 1234567891011/** * sys_kill - send a signal to a process * @pid: the PID of the process * @sig: signal to be sent */SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)&#123; struct kernel_siginfo info; prepare_kill_siginfo(sig, &amp;info); return kill_something_info(sig, &amp;info, pid);&#125; 这里就是kill函数的真正实现，我们这里主要关注信号的发送，就屏蔽一些细节，只看发送部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)&#123; int ret; //这里我们就只看对一个进程发送信号 if (pid &gt; 0) return kill_proc_info(sig, info, pid); ...&#125;static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)&#123; ... kill_pid_info(sig, info, find_vpid(pid)); ...&#125;int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)&#123; struct task_struct *p; for (;;) &#123; ... //获取pid对应进程的task_struct p = pid_task(pid, PIDTYPE_PID); if (p) //PIDTYPE_TGID表示类型是线程组id，对于同一进程中的所有线程，tgid都是一致的，为该进程的进程id group_send_sig_info(sig, info, p, PIDTYPE_TGID); ... &#125;&#125;int group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p, enum pid_type type)&#123; int ret; ... if (!ret &amp;&amp; sig) ret = do_send_sig_info(sig, info, p, type); return ret;&#125;int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p, enum pid_type type)&#123; ... send_signal(sig, info, p, type); ...&#125;static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t, enum pid_type type)&#123; /* Should SIGKILL or SIGSTOP be received by a pid namespace init? */ ... return __send_signal(sig, info, t, type, force);&#125;static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t, enum pid_type type, bool force)&#123; struct sigpending *pending; struct sigqueue *q; int override_rlimit; int ret = 0, result; result = TRACE_SIGNAL_IGNORED; //判断是否可以忽略信号 if (!prepare_signal(sig, t, force)) goto ret; //选择信号pending队列 //线程组共享队列(t-&gt;signal-&gt;shared_pending) 或 进程私有队列(t-&gt;pending) pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending; result = TRACE_SIGNAL_ALREADY_PENDING; //如果该信号是不可靠信号，且已经在padding队列中，则忽略这个信号 if (legacy_queue(pending, sig)) goto ret; result = TRACE_SIGNAL_DELIVERED; //对SIGKILL信号和内核进程跳过信号的pending if ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD)) goto out_set; //实时信号可以突破队列大小限制，否则丢弃信号 if (sig &lt; SIGRTMIN) override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= 0); else override_rlimit = 0; //新分配一个sigqueue，并将其加入pending队尾 q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0); if (q) &#123; list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list); switch ((unsigned long) info) &#123; case (unsigned long) SEND_SIG_NOINFO: clear_siginfo(&amp;q-&gt;info); q-&gt;info.si_signo = sig; q-&gt;info.si_errno = 0; q-&gt;info.si_code = SI_USER; q-&gt;info.si_pid = task_tgid_nr_ns(current, task_active_pid_ns(t)); rcu_read_lock(); q-&gt;info.si_uid = from_kuid_munged(task_cred_xxx(t, user_ns), current_uid()); rcu_read_unlock(); break; case (unsigned long) SEND_SIG_PRIV: clear_siginfo(&amp;q-&gt;info); q-&gt;info.si_signo = sig; q-&gt;info.si_errno = 0; q-&gt;info.si_code = SI_KERNEL; q-&gt;info.si_pid = 0; q-&gt;info.si_uid = 0; break; default: copy_siginfo(&amp;q-&gt;info, info); break; &#125; &#125; else if (!is_si_special(info) &amp;&amp; sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123; ... &#125; else &#123; ... &#125;out_set: signalfd_notify(t, sig); sigaddset(&amp;pending-&gt;signal, sig); ... //唤醒进程 complete_signal(sig, t, type);ret: return ret;&#125; 从代码里我们可以看出来，和我们之前说的原理是一样的，新分配了一个sigqueue，并将其加入到对应进程task_struct的pending队列队尾 设置信号处理之前我们介绍了怎么自定义信号处理行为，如何设置信号屏蔽字，实际上都能在进程的task_struct中体现出来，信号处理行为保存在其中的sighand域中，而信号屏蔽字保存在其中的blocked域中 信号的响应x86_64架构系统调用会经历do_syscall_64这么一个函数，它被实现在arch/x86/entry/common.c中 123456789101112131415__visible noinstr void do_syscall_64(struct pt_regs *regs, int nr)&#123; add_random_kstack_offset(); nr = syscall_enter_from_user_mode(regs, nr); instrumentation_begin(); if (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != -1) &#123; /* Invalid system call, but still a system call. */ regs-&gt;ax = __x64_sys_ni_syscall(regs); &#125; instrumentation_end(); syscall_exit_to_user_mode(regs);&#125; 从代码我们可以看出来，当进程从内核空间返回用户空间时，会调用syscall_exit_to_user_mode函数 最终经历一系列调用，会走到exit_to_user_mode_loop函数中，它们被定义在kernel/entry/common.c中 1234567891011static unsigned long exit_to_user_mode_loop(struct pt_regs *regs, unsigned long ti_work)&#123; while (ti_work &amp; EXIT_TO_USER_MODE_WORK) &#123; ... if (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL)) handle_signal_work(regs, ti_work); ... &#125; return ti_work;&#125; 可以看到，如果当前线程包含_TIF_SIGPENDING或_TIF_NOTIFY_SIGNAL，表明该线程可能有信号需要处理，会调用到handle_signal_work函数处理，接着调用到arch_do_signal_or_restart函数中，它被实现在arch/x86/kernel/signal.c中 12345678910111213141516171819202122232425262728293031//has_signal的值为 (ti_work &amp; _TIF_SIGPENDING)void arch_do_signal_or_restart(struct pt_regs *regs, bool has_signal)&#123; struct ksignal ksig; if (has_signal &amp;&amp; get_signal(&amp;ksig)) &#123; handle_signal(&amp;ksig, regs); return; &#125; //如果该进程没有对这个信号设置处理程序，这里会自动重启这个系统调用 /* Did we come from a system call? */ if (syscall_get_nr(current, regs) != -1) &#123; /* Restart the system call - no handlers present */ switch (syscall_get_error(current, regs)) &#123; case -ERESTARTNOHAND: case -ERESTARTSYS: case -ERESTARTNOINTR: regs-&gt;ax = regs-&gt;orig_ax; regs-&gt;ip -= 2; break; case -ERESTART_RESTARTBLOCK: regs-&gt;ax = get_nr_restart_syscall(regs); regs-&gt;ip -= 2; break; &#125; &#125; restore_saved_sigmask();&#125; 这个函数中的if语句体，看上去是如果有信号，则处理这个信号，其实不完全是这样的。如果该进程没有对这个信号设置处理程序，则会执行默认的信号处理，这里的处理过程是在get_signal中完成的，我当时在看这块源码的时候还在疑惑为什么找不到信号默认处理的地方，结果是这个函数的名字误导了我。如果该进程没有对这个信号设置处理程序，则会自动重启这个系统调用，这里就不展开说了，我们首先看一下get_signal函数是怎么实现的，它被实现在kernel/signal.c中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122bool get_signal(struct ksignal *ksig)&#123; struct sighand_struct *sighand = current-&gt;sighand; struct signal_struct *signal = current-&gt;signal; int signr; ...relock: spin_lock_irq(&amp;sighand-&gt;siglock); //如果子进程的状态发生变化，发送SIGCHLD信号给父进程 if (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123; int why; if (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED) why = CLD_CONTINUED; else why = CLD_STOPPED; signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK; spin_unlock_irq(&amp;sighand-&gt;siglock); read_lock(&amp;tasklist_lock); do_notify_parent_cldstop(current, false, why); if (ptrace_reparented(current-&gt;group_leader)) do_notify_parent_cldstop(current-&gt;group_leader, true, why); read_unlock(&amp;tasklist_lock); goto relock; &#125; for (;;) &#123; struct k_sigaction *ka; enum pid_type type; ... //从进程task_struct的pending队列中取出一个信号 type = PIDTYPE_PID; signr = dequeue_synchronous_signal(&amp;ksig-&gt;info); if (!signr) signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info, &amp;type); if (!signr) break; /* will return 0 */ ... //从信号处理数组中，取出对应信号的处理动作 ka = &amp;sighand-&gt;action[signr-1]; if (ka-&gt;sa.sa_handler == SIG_IGN) /* Do nothing. */ continue; if (ka-&gt;sa.sa_handler != SIG_DFL) &#123; /* Run the handler. */ ksig-&gt;ka = *ka; //如果设置了SA_RESETHAND或者SA_ONESHOT标志（这俩标志的值是一样的），将其信号处理函数重设为默认 if (ka-&gt;sa.sa_flags &amp; SA_ONESHOT) ka-&gt;sa.sa_handler = SIG_DFL; break; /* will return non-zero \"signr\" value */ &#125; //下面为默认信号处理 //部分信号的默认动作为忽略（具体可以查看SIG_KERNEL_IGNORE_MASK这个宏定义） if (sig_kernel_ignore(signr)) /* Default is nothing. */ continue; ... //部分信号的默认动作为停止进程（具体可以查看SIG_KERNEL_STOP_MASK这个宏定义） if (sig_kernel_stop(signr)) &#123; if (signr != SIGSTOP) &#123; spin_unlock_irq(&amp;sighand-&gt;siglock); //当前为孤儿进程组 if (is_current_pgrp_orphaned()) goto relock; spin_lock_irq(&amp;sighand-&gt;siglock); &#125; //默认动作为停止当前线程组里的所有线程 if (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123; goto relock; &#125; continue; &#125; fatal: spin_unlock_irq(&amp;sighand-&gt;siglock); ... current-&gt;flags |= PF_SIGNALED; //部分信号的默认动作为dump core，然后终止进程（具体可以查看SIG_KERNEL_COREDUMP_MASK这个宏定义） if (sig_kernel_coredump(signr)) &#123; if (print_fatal_signals) print_fatal_signal(ksig-&gt;info.si_signo); proc_coredump_connector(current); do_coredump(&amp;ksig-&gt;info); &#125; if (current-&gt;flags &amp; PF_IO_WORKER) goto out; //剩下来的信号的默认操作为终止进程 do_group_exit(ksig-&gt;info.si_signo); &#125; spin_unlock_irq(&amp;sighand-&gt;siglock);out: ksig-&gt;sig = signr; if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_EXPOSE_TAGBITS)) hide_si_addr_tag_bits(ksig); //当当前进程对此信号设置了自定义信号处理动作后，返回true return ksig-&gt;sig &gt; 0;&#125; likely &amp; unlikely这里的likely和unlikely为两个宏，指向__builtin_expect函数，是gcc编译器提供给程序员优化的一种方式，likely表示表达式为真的可能性更大，unlikely表示表达式为假的可能性更大，这样gcc编译器可以在编译过程中，将可能性更大的代码紧跟前面的代码，减少指令跳转带来的性能开销 我们接着看，当用户自定义了信号处理函数后，内核是怎么处理的。从上面的代码看来，当用户自定义了信号处理函数，get_signal函数会返回true，紧接着就会进入到handle_signal函数中，这里的处理比较特殊，我们要先了解信号处理的一些过程 用户自定义信号处理函数实际上是在用户空间执行的，目的是为了防止用户利用内核空间的ring 0特权等级做一些意想不到的事，处理过程如下两图所示： 整个过程如图中所见，进程由于系统调用或中断进入内核空间，在内核空间完成工作后返回用户空间的前夕，检查信号队列，如果检查有信号并且有自定义的信号处理函数，返回到用户空间执行信号处理函数，处理完后再返回内核空间，最后再回到用户空间之前代码执行到的地方继续运行 可以看到，这一套流程经历了4次用户态与内核态的切换，比较复杂，那么内核是如何做到的呢？为什么信号处理函数执行完后还要返回内核空间呢？ 用户态与内核态的切换在Linux中，在用户态和内核态运行的进程使用的是不同的栈，分别为用户栈和内核栈，当一个进程陷入内核态时，需要将用户栈的信息保存到内核栈中，具体的，会将ss, sp, flags, cs, ip等值依次压入栈中，保存为pt_regs结构，然后设置CPU堆栈寄存器的地址为内核栈顶，这样，后续使用的栈便变成了内核栈，当系统调用结束，需要从内核态切换到用户态时，再将之前压入栈中的寄存器值弹出，将pt_regs中保存的值恢复到相应的寄存器中，这里改变了sp寄存器的值，即完成了换栈，cs:ip这两个寄存器分别指向用户态代码段以及用户态指令指针，后续CPU便会执行之前用户态的代码了 pt_regs结构体pt_regs结构体位于arch/x86/include/asm/ptrace.h中 12345678910111213141516171819202122232425262728293031323334struct pt_regs &#123;/* * C ABI says these regs are callee-preserved. They aren't saved on kernel entry * unless syscall needs a complete, fully filled \"struct pt_regs\". */ unsigned long r15; unsigned long r14; unsigned long r13; unsigned long r12; unsigned long bp; unsigned long bx;/* These regs are callee-clobbered. Always saved on kernel entry. */ unsigned long r11; unsigned long r10; unsigned long r9; unsigned long r8; unsigned long ax; unsigned long cx; unsigned long dx; unsigned long si; unsigned long di;/* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it's IRQ number: */ unsigned long orig_ax;/* Return frame for iretq */ unsigned long ip; unsigned long cs; unsigned long flags; unsigned long sp; unsigned long ss;/* top of stack page */&#125;; 我们从理论角度上大概理解了内核是怎么在用户态与内核态之间切换的，接下来我们去源码里验证一下是不是我们所想的这样，syscall的入口函数为entry_SYSCALL_64，位于arch/x86/entry/entry_64.S中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980SYM_CODE_START(entry_SYSCALL_64) UNWIND_HINT_EMPTY /* 切换gs寄存器至内核态 */ swapgs /* tss.sp2为用户栈 */ movq %rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2) /* 切换页表 */ SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp /* 切换至内核栈 */ movq PER_CPU_VAR(cpu_current_top_of_stack), %rspSYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL) /* 保存用户栈寄存器值至pt_regs结构中 */ pushq $__USER_DS /* pt_regs-&gt;ss */ pushq PER_CPU_VAR(cpu_tss_rw + TSS_sp2) /* pt_regs-&gt;sp */ /* 当执行syscall指令时，cpu会将rflags的值保存在r11寄存器中 */ pushq %r11 /* pt_regs-&gt;flags */ pushq $__USER_CS /* pt_regs-&gt;cs */ /* 当执行syscall指令时，cpu会将syscall指令的下一条指令的地址传给rcx寄存器 */ pushq %rcx /* pt_regs-&gt;ip */SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL) pushq %rax /* pt_regs-&gt;orig_ax */ /* 保存并清除寄存器 */ PUSH_AND_CLEAR_REGS rax=$-ENOSYS /* 此时，rsp指向的栈顶地址即为pt_regs的地址 */ movq %rsp, %rdi /* 设置系统调用号 */ movslq %eax, %rsi /* 以rdi, rsi作为参数，调用do_syscall_64函数 */ call do_syscall_64 /* returns with IRQs disabled */ ... cmpq %rcx, %r11 jne swapgs_restore_regs_and_return_to_usermode cmpq $__USER_CS, CS(%rsp) /* CS must match SYSRET */ jne swapgs_restore_regs_and_return_to_usermode movq R11(%rsp), %r11 cmpq %r11, EFLAGS(%rsp) /* R11 == RFLAGS */ jne swapgs_restore_regs_and_return_to_usermode testq $(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11 jnz swapgs_restore_regs_and_return_to_usermode cmpq $__USER_DS, SS(%rsp) /* SS must match SYSRET */ jne swapgs_restore_regs_and_return_to_usermode /* * 这个标签实际上只是为了便于理解，并没有地方跳转它 * 实际工作是在swapgs_restore_regs_and_return_to_usermode中完成的 */syscall_return_via_sysret: /* 恢复寄存器 */ POP_REGS pop_rdi=0 skip_r11rcx=1 movq %rsp, %rdi /* 保存内核栈 */ movq PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp UNWIND_HINT_EMPTY pushq RSP-RDI(%rdi) /* RSP */ pushq (%rdi) /* RDI */ STACKLEAK_ERASE_NOCLOBBER /* 切换页表 */ SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi popq %rdi popq %rsp /* 切换gs寄存器至用户态 */ swapgs /* 恢复rip, rflags等寄存器，使cpu接下来要执行指令指向syscall的下一条指令 */ sysretqSYM_CODE_END(entry_SYSCALL_64) 信号处理函数的跳转方式但是在系统调用完后，回到的将是syscall后的下一条指令，那么如何才能让程序去执行信号处理函数呢？信号处理函数执行完后，又如何回到之前所执行到的代码呢？我们很容易就能想到，先将pt_regs中的值备份一下，然后改变pt_regs中一些寄存器值，比如说将cs:ip修改成信号处理函数对应地址，这样从内核态返回后，就会自动跳转到信号处理函数了，等到信号处理函数执行完，再进入内核态，恢复pt_regs中的值后回到用户态，这样cpu又会从用户调用syscall后的指令开始正常执行了 我们具体的看一下内核代码是怎么做的，这里的逻辑在arch/x86/kernel/signal.c中的handle_signal函数里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147static voidhandle_signal(struct ksignal *ksig, struct pt_regs *regs)&#123; ... failed = (setup_rt_frame(ksig, regs) &lt; 0); ... signal_setup_done(failed, ksig, stepping);&#125;static intsetup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)&#123; int usig = ksig-&gt;sig; sigset_t *set = sigmask_to_save(); compat_sigset_t *cset = (compat_sigset_t *) set; /* Perform fixup for the pre-signal frame. */ rseq_signal_deliver(ksig, regs); //设置栈帧 if (is_ia32_frame(ksig)) &#123; if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) return ia32_setup_rt_frame(usig, ksig, cset, regs); else return ia32_setup_frame(usig, ksig, cset, regs); &#125; else if (is_x32_frame(ksig)) &#123; return x32_setup_rt_frame(ksig, cset, regs); &#125; else &#123; return __setup_rt_frame(ksig-&gt;sig, ksig, set, regs); &#125;&#125;//x86_64执行的应该是这个函数static int __setup_rt_frame(int sig, struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)&#123; struct rt_sigframe __user *frame; void __user *fp = NULL; unsigned long uc_flags; /* x86-64 should always use SA_RESTORER. */ if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER)) return -EFAULT; //获取一个栈帧 frame = get_sigframe(&amp;ksig-&gt;ka, regs, sizeof(struct rt_sigframe), &amp;fp); uc_flags = frame_uc_flags(regs); if (!user_access_begin(frame, sizeof(*frame))) return -EFAULT; /* Create the ucontext. */ unsafe_put_user(uc_flags, &amp;frame-&gt;uc.uc_flags, Efault); unsafe_put_user(0, &amp;frame-&gt;uc.uc_link, Efault); unsafe_save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp, Efault); /* Set up to return from userspace. If provided, use a stub already in userspace. */ //设置执行完信号处理函数后，要跳回的地址，即sa_restorer unsafe_put_user(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode, Efault); //将原本的pt_regs备份保存至frame.uc.uc_mcontext中 unsafe_put_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, set, Efault); unsafe_put_sigmask(set, frame, Efault); user_access_end(); if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) &#123; if (copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info)) return -EFAULT; &#125; //信号处理函数的第1个参数 regs-&gt;di = sig; /* In case the signal handler was declared without prototypes */ regs-&gt;ax = 0; /* 设置了SA_SIGINFO标志位，需要带一些额外的信号信息 */ //信号处理函数的第2个参数 regs-&gt;si = (unsigned long)&amp;frame-&gt;info; //信号处理函数的第3个参数 regs-&gt;dx = (unsigned long)&amp;frame-&gt;uc; //设置指令指针指向信号处理函数 //sigaction结构体中的第一个域是一个联合，所以这里 //sa_handler和sa_sigaction的地址是相同的 regs-&gt;ip = (unsigned long) ksig-&gt;ka.sa.sa_handler; //设置栈顶地址 regs-&gt;sp = (unsigned long)frame; //设置用户代码段 regs-&gt;cs = __USER_CS; if (unlikely(regs-&gt;ss != __USER_DS)) force_valid_ss(regs); return 0;Efault: user_access_end(); return -EFAULT;&#125;#define unsafe_put_sigcontext(sc, fp, regs, set, label) \\do &#123; \\ if (__unsafe_setup_sigcontext(sc, fp, regs, set-&gt;sig[0])) \\ goto label; \\&#125; while(0);static __always_inline int__unsafe_setup_sigcontext(struct sigcontext __user *sc, void __user *fpstate, struct pt_regs *regs, unsigned long mask)&#123; unsafe_put_user(regs-&gt;di, &amp;sc-&gt;di, Efault); unsafe_put_user(regs-&gt;si, &amp;sc-&gt;si, Efault); unsafe_put_user(regs-&gt;bp, &amp;sc-&gt;bp, Efault); unsafe_put_user(regs-&gt;sp, &amp;sc-&gt;sp, Efault); unsafe_put_user(regs-&gt;bx, &amp;sc-&gt;bx, Efault); unsafe_put_user(regs-&gt;dx, &amp;sc-&gt;dx, Efault); unsafe_put_user(regs-&gt;cx, &amp;sc-&gt;cx, Efault); unsafe_put_user(regs-&gt;ax, &amp;sc-&gt;ax, Efault); unsafe_put_user(regs-&gt;r8, &amp;sc-&gt;r8, Efault); unsafe_put_user(regs-&gt;r9, &amp;sc-&gt;r9, Efault); unsafe_put_user(regs-&gt;r10, &amp;sc-&gt;r10, Efault); unsafe_put_user(regs-&gt;r11, &amp;sc-&gt;r11, Efault); unsafe_put_user(regs-&gt;r12, &amp;sc-&gt;r12, Efault); unsafe_put_user(regs-&gt;r13, &amp;sc-&gt;r13, Efault); unsafe_put_user(regs-&gt;r14, &amp;sc-&gt;r14, Efault); unsafe_put_user(regs-&gt;r15, &amp;sc-&gt;r15, Efault); unsafe_put_user(current-&gt;thread.trap_nr, &amp;sc-&gt;trapno, Efault); unsafe_put_user(current-&gt;thread.error_code, &amp;sc-&gt;err, Efault); unsafe_put_user(regs-&gt;ip, &amp;sc-&gt;ip, Efault); unsafe_put_user(regs-&gt;flags, &amp;sc-&gt;flags, Efault); unsafe_put_user(regs-&gt;cs, &amp;sc-&gt;cs, Efault); unsafe_put_user(0, &amp;sc-&gt;gs, Efault); unsafe_put_user(0, &amp;sc-&gt;fs, Efault); unsafe_put_user(regs-&gt;ss, &amp;sc-&gt;ss, Efault); unsafe_put_user(fpstate, (unsigned long __user *)&amp;sc-&gt;fpstate, Efault); /* non-iBCS2 extensions.. */ unsafe_put_user(mask, &amp;sc-&gt;oldmask, Efault); unsafe_put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2, Efault); return 0;Efault: return -EFAULT;&#125; 这里实际上是这么做的，首先，内核默认在用户栈上分配了一个栈帧（如果设置了备用栈的话，则会在备用栈上分配），将pt_regs备份到这个栈帧上，用于后续恢复，然后设置pt_regs，改变其sp, cs, ip等值，使程序从内核态返回时，可以跳转到信号处理函数对应的栈和代码指令地址，当信号处理函数返回时会执行sigreturn系统调用再进入内核态，将之前备份到栈帧中的寄存器值重新恢复到pt_regs中，然后再从内核态回到用户态就可以正常继续执行syscall后面的代码了 其中sa_restorer是在glibc里的__libc_sigaction函数中被设置的 1234567891011121314151617181920212223242526272829303132333435363738394041int__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)&#123; int result; struct kernel_sigaction kact, koact; if (act) &#123; kact.k_sa_handler = act-&gt;sa_handler; memcpy (&amp;kact.sa_mask, &amp;act-&gt;sa_mask, sizeof (sigset_t)); kact.sa_flags = act-&gt;sa_flags; //设置sa_restorer SET_SA_RESTORER (&amp;kact, act); &#125; ... return result;&#125;extern void restore_rt (void) asm (\"__restore_rt\") attribute_hidden;#define SET_SA_RESTORER(kact, act) \\ (kact)-&gt;sa_flags = (act)-&gt;sa_flags | SA_RESTORER; \\ (kact)-&gt;sa_restorer = &amp;restore_rt RESTORE (restore_rt, __NR_rt_sigreturn)#define RESTORE(name, syscall) RESTORE2 (name, syscall)#define RESTORE2(name, syscall) \\asm \\ ( \\ /* `nop' for debuggers assuming `call' should not disalign the code. */ \\ \" nop\\n\" \\ \".align 16\\n\" \\ \".LSTART_\" #name \":\\n\" \\ \" .type __\" #name \",@function\\n\" \\ \"__\" #name \":\\n\" \\ \" movq $\" #syscall \", %rax\\n\" \\ \" syscall\\n\" \\ ... ); 可以看到，这里也是一个系统调用，和上面所说的规则一样，它最终会调用sys_rt_sigreturn函数，具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SYSCALL_DEFINE0(rt_sigreturn)&#123; struct pt_regs *regs = current_pt_regs(); struct rt_sigframe __user *frame; sigset_t set; unsigned long uc_flags; frame = (struct rt_sigframe __user *)(regs-&gt;sp - sizeof(long)); if (!access_ok(frame, sizeof(*frame))) goto badframe; if (__get_user(*(__u64 *)&amp;set, (__u64 __user *)&amp;frame-&gt;uc.uc_sigmask)) goto badframe; if (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags)) goto badframe; set_current_blocked(&amp;set); //frame.uc.uc_mcontext中恢复pt_regs if (!restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags)) goto badframe; if (restore_altstack(&amp;frame-&gt;uc.uc_stack)) goto badframe; return regs-&gt;ax;badframe: signal_fault(regs, frame, \"rt_sigreturn\"); return 0;&#125;static bool restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *usc, unsigned long uc_flags)&#123; struct sigcontext sc; /* Always make any pending restarted system calls return -EINTR */ current-&gt;restart_block.fn = do_no_restart_syscall; if (copy_from_user(&amp;sc, usc, CONTEXT_COPY_SIZE)) return false; regs-&gt;bx = sc.bx; regs-&gt;cx = sc.cx; regs-&gt;dx = sc.dx; regs-&gt;si = sc.si; regs-&gt;di = sc.di; regs-&gt;bp = sc.bp; regs-&gt;ax = sc.ax; regs-&gt;sp = sc.sp; regs-&gt;ip = sc.ip; regs-&gt;r8 = sc.r8; regs-&gt;r9 = sc.r9; regs-&gt;r10 = sc.r10; regs-&gt;r11 = sc.r11; regs-&gt;r12 = sc.r12; regs-&gt;r13 = sc.r13; regs-&gt;r14 = sc.r14; regs-&gt;r15 = sc.r15; /* Get CS/SS and force CPL3 */ regs-&gt;cs = sc.cs | 0x03; regs-&gt;ss = sc.ss | 0x03; regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (sc.flags &amp; FIX_EFLAGS); /* disable syscall checks */ regs-&gt;orig_ax = -1; ... return fpu__restore_sig((void __user *)sc.fpstate, IS_ENABLED(CONFIG_X86_32));&#125; 从上面代码还是可以比较清楚的看出来，和我们之前描述的原理基本一致，到这一步时，恢复pt_regs中的值，这样后续返回用户态后便可以正常继续运行后面的用户代码了 总结Linux信号的原理分析到这基本上也就结束了，其实整个信号原理分析对现阶段的我来说，还是一件相当具有挑战性的事情，不过在此过程中，还是收获了很多知识，也发现了一些之前文章里错漏的地方，由于我对Linux内核以及汇编并不熟悉，所以难免会有一些分析错误或者不到位的地方，欢迎大家指正 附录信号表取值 | 名称 | 解释 | 默认动作 || – | ——— | —————- | ———– || 1 | SIGHUP | 挂起 | 终止进程 || 2 | SIGINT | 中断 | 终止进程 || 4 | SIGILL | 非法指令 | coredump后终止进程 || 5 | SIGTRAP | 断点或陷阱指令 | coredump后终止进程 || 6 | SIGABRT/SIGIOT | abort发出的信号 | coredump后终止进程 || 7 | SIGBUS | 非法内存访问 | coredump后终止进程 || 8 | SIGFPE | 浮点异常 | coredump后终止进程 || 9 | SIGKILL | kill信号 | 不能被忽略、处理和阻塞 || 10 | SIGUSR1 | 用户自定义信号1 | 终止进程 || 11 | SIGSEGV | 无效内存访问 | coredump后终止进程 || 12 | SIGUSR2 | 用户自定义信号2 | 终止进程 || 13 | SIGPIPE | 管道破损，没有读端的管道写数据 | 终止进程 || 14 | SIGALRM | alarm发出的信号 | 终止进程 || 15 | SIGTERM | 终止信号 | 终止进程 || 16 | SIGSTKFLT | 栈溢出 | 终止进程 || 17 | SIGCHLD | 子进程退出 | 忽略信号 || 18 | SIGCONT | 进程继续 | 忽略信号 || 19 | SIGSTOP | 进程停止 | 不能被忽略、处理和阻塞 || 20 | SIGTSTP | 进程停止 | 停止进程 || 21 | SIGTTIN | 进程停止，后台进程从终端读数据时 | 停止进程 || 22 | SIGTTOU | 进程停止，后台进程想终端写数据时 | 停止进程 || 23 | SIGURG | I/O有紧急数据到达当前进程 | 忽略信号 || 24 | SIGXCPU | 进程的CPU时间片到期 | coredump后终止进程 || 25 | SIGXFSZ | 文件大小的超出上限 | coredump后终止进程 || 26 | SIGVTALRM | 虚拟时钟超时 | 终止进程 || 27 | SIGPROF | profile时钟超时 | 终止进程 || 28 | SIGWINCH | 窗口大小改变 | 忽略信号 || 29 | SIGPOLL/SIGIO | I/O相关 | 终止进程 || 30 | SIGPWR | 关机 | 默认忽略 || 31 | SIGSYS/SIGUNUSED | 系统调用异常 | coredump后终止进程 | 参考文献 Linux信号 阻塞信号 Linux Signal Linux信号(signal)机制 linux 信号处理机制简介 [内核源码] Linux 系统调用（x86_64） Linux操作系统学习笔记（十六）进程间通信之信号 X86_64处理器系统调用机制在linux上的实现 linux kernel signal机制（X86_64）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"信号","slug":"信号","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"}]},{"title":"B站Android面试小记","slug":"interview/B站Android面试小记","date":"2022-03-22T11:09:00.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2022/03/22/interview/B站Android面试小记/","link":"","permalink":"http://yoursite.com/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"起因看着我同学最近也在到处投简历，我想着我也投一下看看行情，于是在2022-02-28号，我向B站投出了第一封简历，说实话当初只是想练练手，没想到最后接了B站的offer，也是造化弄人了 一面技术面，45min左右，基本围绕你简历上写的亮点和你的工作经历展开 自我介绍 你在项目中负责什么 用过什么设计模式，或在Android中常常会碰见的设计模式 单例模式，策略模式，责任链模式（问了一下使用场景），工厂模式等 Android中的观察者模式，适配器模式等 有没有做过什么比较有难度的模块 camera2，自定义照片裁剪View 你对自定义View有什么了解 回答了一些Path绘制以及触摸事件的处理 Android动画 属性动画，ObjectAnimator 多线程并发（锁、信号量、syncnorized），syncnorized对象和class有什么区别 ConcurrentHashMap线程安全的原理 1.8之前用的分段式锁，1.8之后用的synchronized，至于具体的细节没有答上来，因为确实也没看过这边源码 jni，如何定位jni崩溃 这个我当时回答的是打log，因为项目中用到jni的地方确实不多，当然jni也是可以断点调试的 你所开发的应用有多进程吗？进程间是怎么通信的 这个我当时只回答了mmap，稍微聊了一下mmap原理和binder性能对比，后来复盘想起来项目中用到的Broadcast和aidl binder通信都没有回答 Webview和native怎么交互的 onUrlLoading拦截Schema 注册js方法（addJavascriptInterface） Android编译打包过程 aapt -&gt; class -&gt; dex -&gt; 签名 插桩 ASM插桩，字节码操作 性能监控 因为我之前做过一个性能监控库，cpu和mem使用TOP命令解析，Anr通过给MainLooper设置Printer LeakCanary原理 WeakReference + ReferenceQueue，加了一些改进点：new一个弱引用的Object，等这个Object确认被回收后再确认Activity是否正常被回收 Jetpack Compose 稍微谈了一下看法，是否在项目中用过 算法题：最长公共前缀 LeetCode 14题，easy难度：https://leetcode-cn.com/problems/longest-common-prefix/ 二面一面结束后5min左右，B站HR就给我打电话过来约了二面 二面也是技术面，20min左右，因为是晚上8点面的，估计人家急着想下班（笑） 自我介绍 工作职责 工作中有什么亮点 拍照裁剪业务 单元测试库 性能监控 内存泄漏检测 单元测试的库是怎么做的 基于Mockito和Robolectric: 封装了一个反射库用来方便测试 做了一个AutoCloser类用来自动关闭释放mock的资源，这里提到了使用MockedStatic，如果在使用完后没有释放，那在下一次使用到同一个类的MockedStatic的时候会报错，这里我自定义了一个注解@MockedStatic用来自动mock和释放资源 针对kotlin做了一些mock工具，比如说顶层函数的mock（这个在我以前的文章Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数中介绍过） 开发模式（流程规范）： 开发规范参考了阿里的Java规范和Android规范，选取了一些比较重要的条例和一些自己长时间开发的经验做成了一篇文档 崩溃率的优化，做了哪些事情 感觉这里没答好，有点答非所问的意思，我就说了说目前处理bug的一个流程，没有谈到怎么解决一个bug 数据打点是怎么做的 我们用的是神策第三方服务 内存泄漏工具是怎么做的 这部分同一面LeakCanary原理 看你之前做过一个MQTT协议的客户端，是出于个人兴趣吗 是的，当时是想要做一个IM应用 在项目中有遇到需要3D渲染展示的内容吗 目前没有 两个Activity跳转时方法执行的顺序 一个Activity创建是：onCreate -&gt; onStart -&gt; onResume（之后便在屏幕上显示了） 假设从A Activity跳转到B Activity：A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop 从B返回到A：B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory 两个Activity传递数据可以通过什么方式 Intent 如果是同一个进程的话，可以用全局变量或者单例等 SharedPreference 文件 什么时候使用Service 后台任务，比如说后台播放音乐等，这里提了一下IntentService是开了一个子线程的 Service怎么启动，怎么停止 startService &lt;—&gt; stopService bindService &lt;—&gt; unbindService 包体积优化 清理资源（字体、图片、代码等） HR面二面结束后过了2-3天，HR发微信过来恭喜我进入下一轮面试，我问她接下来是还有三面和HR面吗，她回答我说后面就直接是HR面了，说实话我还是挺惊讶的 HR面15min左右，大概就问了一下，为什么要从上家公司离职，我们是一个新部门，处于项目初期，有什么看法之类的，然后问了一下目前的薪资和期望薪资，over~ 总结说实话感觉这次面试太简单了，有点白瞎了我准备了那么多，还做了查漏补缺 ㄟ( ▔, ▔ )ㄏ ，最后祝大家都能找到心仪的工作 (๑•̀ㅂ•́)و✧","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"面试","slug":"Android/面试","permalink":"http://yoursite.com/categories/Android/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Android源码分析 - Binder驱动（下）","slug":"android/aosp/Android源码分析-Binder驱动（下）","date":"2022-03-11T10:13:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/03/11/android/aosp/Android源码分析-Binder驱动（下）/","link":"","permalink":"http://yoursite.com/2022/03/11/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"开篇本篇以aosp分支android-11.0.0_r25，kernel分支android-msm-wahoo-4.4-android11作为基础解析 上一篇文章Android源码分析 - Binder驱动（中），我们分析了binder_ioctl中的写操作binder_thread_write部分，了解了binder请求的发起与调度，接下来我们就进行binder驱动的最后一部分分析，binder_thread_read binder_ioctl_write_read我们还是先从binder_ioctl后的BINDER_WRITE_READ命令码开始 1234567891011121314151617181920212223242526272829303132333435363738static int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; ... //将用户空间ubuf拷贝至内核空间bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125; ... //当读缓存中有数据，执行binder读操作 if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); trace_binder_read_done(ret); //如果todo队列中有未处理的任务，唤醒等待状态下的线程 binder_inner_proc_lock(proc); if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; ...out: return ret;&#125; binder_thread_read这是进行binder读操作的函数，这个函数也是比较长，我们同样将它分成几个部分： 等待可用的binder_work 循环获取todo队列中的binder_work，并根据binder_work的type，执行一定的处理 处理binder_transaction以及binder_transaction_data，并将binder_transaction_data拷贝回用户空间 第一部分：等待工作binder_thread.looper在此之前我们需要先看一下之前提到的，在binder_thread中的域成员looper，前面我们只是注释了这个域表示线程状态，这里我们介绍一下它有哪些取值： BINDER_LOOPER_STATE_REGISTERED：表示该binder线程是非主binder线程 BINDER_LOOPER_STATE_ENTERED：表示该binder线程是主binder线程 BINDER_LOOPER_STATE_EXITED：表示该binder线程马上就要退出了 BINDER_LOOPER_STATE_INVALID：表示该binder线程是无效的（比如原来是binder主线程，后续用户又发送了一个BC_REGISTER_LOOPER请求） BINDER_LOOPER_STATE_WAITING：表示当前binder线程正在等待请求 BINDER_LOOPER_STATE_NEED_RETURN：表示该binder线程在处理完transaction后需要返回到用户态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //用户空间传进来的需要将数据读到的地址 //实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体 //真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了 void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //起始地址 = 读数据的首地址 + 已读数据大小 void __user *ptr = buffer + *consumed; //结束地址 = 读数据的首地址 + 读数据的总大小 void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; if (*consumed == 0) &#123; //向用户空间写一个binder响应码，该响应码不做任何操作 if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: binder_inner_proc_lock(proc); //检查是否有可用的工作需要处理 wait_for_proc_work = binder_available_for_proc_work_ilocked(thread); binder_inner_proc_unlock(proc); //将线程的状态置为等待中 thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING; //如果没有可用的工作，可以等待进程todo队列中的工作 if (wait_for_proc_work) &#123; //这个binder线程既不是主线程，也没有被注册成binder子线程 //这里条件在binder_available_for_proc_work_ilocked中已经做了判断 //似乎永远不会进入到这个case中？ if (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED))) &#123; binder_user_error(\"%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\\n\", proc-&gt;pid, thread-&gt;pid, thread-&gt;looper); //进程进入休眠状态，等待唤醒 wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); &#125; //恢复优先级 binder_restore_priority(current, proc-&gt;default_priority); &#125; if (non_block) &#123; //如果是非阻塞模式（这里似乎不会执行到） //线程和进程的todo队列中都没有工作 if (!binder_has_work(thread, wait_for_proc_work)) ret = -EAGAIN; &#125; else &#123; //如果是阻塞模式 //等待binder工作到来 ret = binder_wait_for_work(thread, wait_for_proc_work); &#125; //将线程的等待中状态解除 thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING; if (ret) return ret; ...&#125; 这一部分先检查是否有可用的binder_work待处理，如果有的话进入到下一部分，如果没有的话则需要等待 具体的，我们先看这个函数中的wait_for_proc_work变量，这个变量表示是否需要等待binder_proc中的工作，当在binder_thread中找不到事务栈并且todo队列为空时，此变量值为true 1234567static bool binder_available_for_proc_work_ilocked(struct binder_thread *thread)&#123; return !thread-&gt;transaction_stack &amp;&amp; binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp; (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED | BINDER_LOOPER_STATE_REGISTERED)); //这个binder线程既不是主线程，也没有被注册成binder子线程&#125; 在上一篇文章Android源码分析 - Binder驱动（中），我们分析过是有分支会将binder_work直接添加到binder_proc的todo队列中的，当binder_thread中找不到工作的话，可能就需要从binder_proc中找了 然后会将当前线程的状态置为等待中，等到有可处理的binder_work后再解除这个状态 之后会判断传入的参数是否为阻塞模式，这个是由framework层执行ioctl时传入的flags所决定的，根据framework中的binder代码，这里应该恒为阻塞模式，在阻塞模式下，会调用binder_wait_for_work函数，等待存在可用的binder_work 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int binder_wait_for_work(struct binder_thread *thread, bool do_proc_work)&#123; //定义一个等待队列项 DEFINE_WAIT(wait); struct binder_proc *proc = thread-&gt;proc; int ret = 0; freezer_do_not_count(); binder_inner_proc_lock(proc); for (;;) &#123; //准备睡眠等待 prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE); //检查确认是否有binder_work可以处理 if (binder_has_work_ilocked(thread, do_proc_work)) break; //可以处理binder_proc.todo中的工作的话 if (do_proc_work) //将该binder线程加入到binder_proc中的等待线程中 list_add(&amp;thread-&gt;waiting_thread_node, &amp;proc-&gt;waiting_threads); binder_inner_proc_unlock(proc); //睡眠 schedule(); binder_inner_proc_lock(proc); //将该binder线程从binder_proc中的等待线程中移除 list_del_init(&amp;thread-&gt;waiting_thread_node); //检查当前系统调用进程是否有信号处理 if (signal_pending(current)) &#123; ret = -ERESTARTSYS; break; &#125; &#125; //结束等待 finish_wait(&amp;thread-&gt;wait, &amp;wait); binder_inner_proc_unlock(proc); freezer_count(); return ret;&#125;static bool binder_has_work_ilocked(struct binder_thread *thread, bool do_proc_work)&#123; //thread-&gt;process_todo为false时会延时执行 return thread-&gt;process_todo || thread-&gt;looper_need_return || (do_proc_work &amp;&amp; !binder_worklist_empty_ilocked(&amp;thread-&gt;proc-&gt;todo));&#125; 这个函数的结构和Linux函数wait_event_interruptible非常相似，我们先来看看它是怎么做到阻塞等待的 Linux进程调度DEFINE_WAIT这是一个宏，它定义了一个wait_queue_t结构体 12345678#define DEFINE_WAIT_FUNC(name, function) \\ wait_queue_t name = &#123; \\ .private = current, \\ .func = function, \\ .task_list = LIST_HEAD_INIT((name).task_list), \\ &#125;#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function) 这个结构体中的private域指向的即是当前执行系统调用所在进程的描述结构体，func域指向唤醒这个队列项进程所执行的函数 prepare_to_wait这个函数将我们刚刚定义的wait队列项加入到一个等待队列中（在binder中即是加入到thread-&gt;wait中），然后将进程的状态设置为我们指定的状态，在这里为TASK_INTERRUPTIBLE（可中断的睡眠状态） scheduleschedule是真正执行进程调度的地方，由于之前进程状态已经被设置成TASK_INTERRUPTIBLE状态，在调用schedule后，该进程就会让出CPU，不再调度运行，直到该进程恢复TASK_RUNNING状态 wake_up_interruptible我们在上一篇文章Android源码分析 - Binder驱动（中）中提到过，当binder_transaction工作处理完后，会调用wake_up_interruptible函数唤醒目标binder线程的等待队列 这个函数会唤醒TASK_INTERRUPTIBLE状态下的进程，它会循环遍历等待队列中的每个元素，分别执行其唤醒函数，也就对应着我们DEFINE_WAIT定义出来的结构体中的func域，即autoremove_wake_function，它最终会调用try_to_wake_up函数将进程置为TASK_RUNNING状态，这样后面的进程调度便会调度到该进程，从而唤醒该进程继续执行 signal_pending这个函数是用来检查当前系统调用进程是否有信号需要处理的，当一个进程陷入系统调用并处于等待状态时，如果此时产生了一个信号，仅仅是在该进程的thread_info中标识了一下，所以我们唤醒进程后需要检查一下是否有信号需要处理，如果有的话，返回-ERESTARTSYS，先处理信号，后续Linux上层库函数会根据-ERESTARTSYS此返回值重新执行这个系统调用 finish_wait最后一步，当进程被唤醒后，调用finish_wait函数执行清理工作，将当前进程置为TASK_RUNNING状态，并把当前wait队列项从等待队列中移除 了解了上面这些知识，我们再看binder_wait_for_work函数应该比较清晰了，这里有一点需要注意，我们在上一篇文章Android源码分析 - Binder驱动（中）提到，在没有TF_ONE_WAY标志的情况下，会使用binder_enqueue_deferred_thread_work_ilocked函数将tcomplete插入到事务发起binder线程的todo队列中，这个函数区别于binder_enqueue_thread_work_ilocked函数，它没有将thread-&gt;process_todo设为true，所以结合着binder_has_work_ilocked函数看，我们可以发现，当thread-&gt;process_todo为false时，整个binder_has_work_ilocked返回false，即会进入到睡眠状态，延迟执行BINDER_WORK_TRANSACTION_COMPLETE，这么设计可以让binder接收端优先处理事务，提高了性能 第二部分：获取工作，根据type做一定的处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //用户空间传进来的需要将数据读到的地址 //实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体 //真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了 void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //起始地址 = 读数据的首地址 + 已读数据大小 void __user *ptr = buffer + *consumed; //结束地址 = 读数据的首地址 + 读数据的总大小 void __user *end = buffer + size; ...retry: ... //循环处理todo队列中的工作 while (1) &#123; uint32_t cmd; struct binder_transaction_data_secctx tr; struct binder_transaction_data *trd = &amp;tr.transaction_data; struct binder_work *w = NULL; struct list_head *list = NULL; struct binder_transaction *t = NULL; struct binder_thread *t_from; size_t trsize = sizeof(*trd); binder_inner_proc_lock(proc); //找到需要处理的todo队列 if (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo)) list = &amp;thread-&gt;todo; else if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) list = &amp;proc-&gt;todo; else &#123; binder_inner_proc_unlock(proc); /* no data added */ //只跳过了数据头部的命令码，没有读取任何数据 if (ptr - buffer == 4 &amp;&amp; !thread-&gt;looper_need_return) goto retry; break; &#125; //传输过来的数据大小不符合 if (end - ptr &lt; sizeof(tr) + 4) &#123; binder_inner_proc_unlock(proc); break; &#125; //从todo队列中出队一项binder_work w = binder_dequeue_work_head_ilocked(list); if (binder_worklist_empty_ilocked(&amp;thread-&gt;todo)) thread-&gt;process_todo = false; switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; binder_inner_proc_unlock(proc); //根据binder_work找到binder_transaction结构 t = container_of(w, struct binder_transaction, work); &#125; break; case BINDER_WORK_RETURN_ERROR: &#123; ... &#125; break; case BINDER_WORK_TRANSACTION_COMPLETE: &#123; binder_inner_proc_unlock(proc); cmd = BR_TRANSACTION_COMPLETE; //回复给用户进程BR_TRANSACTION_COMPLETE响应码 if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); //更新统计数据 binder_stat_br(proc, thread, cmd); //释放 kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; case BINDER_WORK_NODE: &#123; ... &#125; break; case BINDER_WORK_DEAD_BINDER: case BINDER_WORK_DEAD_BINDER_AND_CLEAR: case BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123; ... &#125; break; &#125; ... &#125;done: ...&#125; 这里先创建了一个binder_transaction_data_secctx结构体，后续会将它拷贝到用户空间去，然后创建了一个指针trd指向tr.transaction_data的地址，这样后续操作trd就相当于操作tr.transaction_data了 当进程从睡眠中唤醒，意味着有可用的binder_work了，这时候理论上来说，binder_thread和binder_proc其中总有一个todo队列不为空，这里优先处理binder_thread的todo队列，如果两者都为空，且还未读取过任何数据，重新goto到retry处等待 接着就是将binder_work从相应的todo队列中出队，再根据其类型执行不同的处理操作，这里我们只针对BINDER_WORK_TRANSACTION和BINDER_WORK_TRANSACTION_COMPLETE这两种最重要的类型分析 当类型为BINDER_WORK_TRANSACTION时，表示是别的进程向自己发起binder请求，此时，我们根据binder_work找到对应的binder_transaction结构 当类型为BINDER_WORK_TRANSACTION_COMPLETE时，表示发起的请求BC_TRANSACTION已经完成了，此时将回复给用户空间BR_TRANSACTION_COMPLETE响应码，然后更新统计数据，释放资源 第三部分：处理binder_transaction，拷贝回用户空间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed, int non_block)&#123; //用户空间传进来的需要将数据读到的地址 //实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体 //真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了 void __user *buffer = (void __user *)(uintptr_t)binder_buffer; //起始地址 = 读数据的首地址 + 已读数据大小 void __user *ptr = buffer + *consumed; //结束地址 = 读数据的首地址 + 读数据的总大小 void __user *end = buffer + size; ...retry: ... //循环处理todo队列中的工作 while (1) &#123; uint32_t cmd; struct binder_transaction_data_secctx tr; struct binder_transaction_data *trd = &amp;tr.transaction_data; struct binder_work *w = NULL; struct list_head *list = NULL; struct binder_transaction *t = NULL; struct binder_thread *t_from; size_t trsize = sizeof(*trd); ... //只有在type == BINDER_WORK_TRANSACTION的情况下，t才会被赋值 if (!t) continue; if (t-&gt;buffer-&gt;target_node) &#123; //binder实体不为NULL，对应着BC_TRANSACTION请求 struct binder_node *target_node = t-&gt;buffer-&gt;target_node; struct binder_priority node_prio; //binder实体在用户空间中的地址 trd-&gt;target.ptr = target_node-&gt;ptr; //携带的额外数据 trd-&gt;cookie = target_node-&gt;cookie; //优先级 node_prio.sched_policy = target_node-&gt;sched_policy; node_prio.prio = target_node-&gt;min_priority; binder_transaction_priority(current, t, node_prio, target_node-&gt;inherit_rt); //设置响应码 cmd = BR_TRANSACTION; &#125; else &#123; //binder实体为NULL，对应着BC_REPLY请求 trd-&gt;target.ptr = 0; trd-&gt;cookie = 0; //设置响应码 cmd = BR_REPLY; &#125; //表示要对目标对象请求的命令代码 trd-&gt;code = t-&gt;code; //事务标志，详见enum transaction_flags trd-&gt;flags = t-&gt;flags; //请求发起进程的uid trd-&gt;sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid); //获取发起请求的binder线程 t_from = binder_get_txn_from(t); if (t_from) &#123; struct task_struct *sender = t_from-&gt;proc-&gt;tsk; //设置发起请求的进程pid trd-&gt;sender_pid = task_tgid_nr_ns(sender, task_active_pid_ns(current)); &#125; else &#123; trd-&gt;sender_pid = 0; &#125; //数据大小 trd-&gt;data_size = t-&gt;buffer-&gt;data_size; //偏移数组大小 trd-&gt;offsets_size = t-&gt;buffer-&gt;offsets_size; //设置数据区首地址（这里通过内核空间地址和user_buffer_offset计算得出用户空间地址） trd-&gt;data.ptr.buffer = (binder_uintptr_t) ((uintptr_t)t-&gt;buffer-&gt;data + binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc)); //偏移数组紧挨着数据区，所以它的首地址就为数据区地址加上数据大小 trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); tr.secctx = t-&gt;security_ctx; if (t-&gt;security_ctx) &#123; cmd = BR_TRANSACTION_SEC_CTX; trsize = sizeof(tr); &#125; //回复给用户进程对应的响应码 if (put_user(cmd, (uint32_t __user *)ptr)) &#123; ... //Error &#125; ptr += sizeof(uint32_t); //将binder_transaction_data拷贝至用户空间 if (copy_to_user(ptr, &amp;tr, trsize)) &#123; ... //Error &#125; ptr += trsize; //更新数据统计 binder_stat_br(proc, thread, cmd); //临时引用计数减1 if (t_from) binder_thread_dec_tmpref(t_from); //允许释放这个buffer t-&gt;buffer-&gt;allow_user_free = 1; if (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; //非异步处理 binder_inner_proc_lock(thread-&gt;proc); //将这个事务插入到事务栈中 t-&gt;to_parent = thread-&gt;transaction_stack; //设置目标处理线程 t-&gt;to_thread = thread; thread-&gt;transaction_stack = t; binder_inner_proc_unlock(thread-&gt;proc); &#125; else &#123; binder_free_transaction(t); &#125; break; &#125;done: //更新已读数据大小 *consumed = ptr - buffer; binder_inner_proc_lock(proc); //请求线程数为0且没有等待线程，已启动线程数小于最大线程数 //且这个binder线程既不是主线程，也没有被注册成binder子线程 if (proc-&gt;requested_threads == 0 &amp;&amp; list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp; proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp; (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) /* the user-space code fails to */ /*spawn a new thread if we leave this out */) &#123; //向用户空间发送BR_SPAWN_LOOPER响应码，创建新binder线程 proc-&gt;requested_threads++; binder_inner_proc_unlock(proc); if (put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)) return -EFAULT; //更新统计信息 binder_stat_br(proc, thread, BR_SPAWN_LOOPER); &#125; else binder_inner_proc_unlock(proc); return 0;&#125; 只有当type == BINDER_WORK_TRANSACTION的情况下，才会走后面的这些逻辑，这一部分主要做的工作是，将处理事务所需要的信息（命令码、PID等）和数据（数据区首地址和偏移数组地址）准备好，拷贝到用户空间，交给用户空间处理这个事务，还有一些细节都在上面代码注释中标出来了，应该还是比较清晰的 结束到这里，从client向binder驱动发起请求，到binder驱动找到server并将请求传递给server这一整个流程我们基本上是看完了，对于被TF_ONE_WAY标记的事务（无需返回），在server中处理完，这一整条binder进程通信流程也就结束了，而对于需要返回的事务，则还需要server向binder驱动发起BC_REPLY事务请求，进行一次进程间通信，将处理后的返回值传给client进程 总结我们已经将binder驱动所承担的工作分析的七七八八了，但肯定还有很多地方大家云里雾里（实际上我也是这样的），这是因为binder进程间通信不仅需要binder驱动的处理，还需要framework层的协助，很多事情，比如说binder对象的压扁打包就是在framework层做的，我们在binder驱动层只关注了传输，但却不知道传输的是什么，结构是怎样的，当然会产生各种各样的疑惑，后面我们就将会对framework层对binder提供的支持接着做分析","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android ASM插桩","slug":"android/stub/AndroidASM插桩","date":"2022-03-01T07:32:00.000Z","updated":"2022-11-13T09:55:54.359Z","comments":true,"path":"2022/03/01/android/stub/AndroidASM插桩/","link":"","permalink":"http://yoursite.com/2022/03/01/android/stub/AndroidASM%E6%8F%92%E6%A1%A9/","excerpt":"","text":"简介ASM插桩在网上其实已经有很多资料了，我之所以再写这篇文章呢，一是因为好久前学习的ASM，现在已经忘的差不多了，需要再回顾一下，二来是记录一下学习过程，以后如果再有细节记不清楚可以很方便的就能查到，三来再学习的过程中也踩了一些坑，收获了一些心得，这些也需要一个地方记录一下。 好了，废话就说到这里，接下来开始正文。 插桩技术指在保证原有程序逻辑完整性的基础上，在程序中插入探针，通过探针采集代码中的信息（方法本身、方法参数值、返回值等）在特定的位置插入代码段，从而收集程序运行时的动态上下文信息。 插桩技术大体可以分为两类： APT（Annotation Process Tools），在编译的时候，动态生成 Java 文件，之后编译器将生成的 Java 文件编译成 class 文件，像 ButterKnife、Dagger 就是通过 APT 的方式生成代码的。 代表工具：ButterKnife AOP（Aspect Oriented Programming），生成 class 文件后，修改 class 文件的字节码，达到修改代码的目的。 代表工具：听云 工具我们这次选用AOP技术，我们看看有哪些工具可以帮助我们完成插桩工作： AspectJ，成熟稳定，使用者不需要对字节码文件有深入的理解，使用简单。但是其切入点相对固定，对于字节码文件的操作自由度以及开发的掌控度就大打折扣。并且，他会额外生成一些包装代码，对性能以及包大小有一定影响。 ASM，可以修改现有的字节码文件，也可以动态生成字节码文件，完全从字节码去操作字节码的框架，更加灵活，功能更加强大，可以根据需求自定义修改、插入、删除，性能也十分出色，但是要对字节码文件有比较深入的了解，上手也更难。 我们使用ASM来完成插桩，在介绍Android字节码插桩之前，需要先了解一下Java字节码的概念和Android程序打包过程。 字节码我们知道，Java程序是运行在JVM（Java虚拟机）上的，Java源代码首先会由编译器（Java Compiler）编译成包含了Bytecode（字节码）的.class文件，程序执行时，由类加载器(class loader)将该类的字节码加载到JVM中，JVM会解释执行相应的Bytecode。如下图所示： 为什么不直接彻底编译成机器码，而需要字节码这个中间产物呢？Java是一门跨平台的语言，为了实现一份源码，处处运行的效果，每个平台都有对应不同的JVM，它会将源码对应的指令翻译成对应平台能够理解的机器指令。那为什么不从源码直接解释执行呢，我个人认为这是因为直接从源码开始的编译，速度非常慢，出于性能的考虑，先将源码做一些预处理，处理为字节码，来减轻运行前的编译的性能开销。 在做插桩之前，我们先要记住一点：Java 字节码指令是基于堆栈操作的，因为大部分的Java虚拟机对字节码的执行是基于堆栈的（Android的Dalvik虚拟机是基于寄存器的，不过不影响我们的插桩，因为在我们对java字节码插完桩后，才会执行从java字节码转换到dex文件的过程） Android打包过程 Android插桩过程 实战这次，我们模仿听云，做一个Activity生命周期执行时间检测的插件。 我们先梳理一下功能点： 针对Activity类 针对生命周期方法 支持插件自定义配置 我们用Java代码把我们想要插入的逻辑写一遍： 1234567891011121314151617181920public class Test &#123; //这里取这个名字是为了防止和代码本身的成员变量产生冲突 private long _$_timeRecorder; public void onCreate(Bundle savedInstanceState) &#123; //向实际代码前插入代码 _$_timeRecorder = -System.currentTimeMillis(); ... //这里是实际代码 //向实际代码后插入代码 _$_timeRecorder += System.currentTimeMillis(); System.err.println(\"Time spent: \" + _$_timeRecorder + \"ms, when \" + className + \".onCreate\"); StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace(); for (StackTraceElement element : stackTraceElements) &#123; System.err.println(element.getClassName() + \".\" + element.getMethodName() + \":\" + element.getLineNumber()); &#125; &#125;&#125; 接下来正式开始编写插件 新建插件工程由于Android Studio没有新建gradle脚本的选项，我们先新建一个Empty Activity Project，在此基础上进行改造。 新建module 更改module的build.gradle文件 新建groovy源代码目录 新建groovy类实现Plugin&lt;Project&gt;接口 新建resource/META_INF/xxx.properites文件（xxx为插件的id名） 在properites文件中声明插件的实现类 为插件提供可配置的功能 新建一个实体类用来保存配置信息 12345678910111213141516public class AsmConfigModel &#123; /** * 以此参数为开头的类（全限定类名）才插桩 * 如果不配此参数则代表所有类都可插桩 */ public List&lt;String&gt; startWithPatterns; /** * 排除列表（全限定类名） */ public List&lt;String&gt; excludes; /** * 排除列表（全限定类名） * 以文件形式 */ public File excludesByFile;&#125; 在插件apply的时候创建这个配置类，以提供给使用者配置 12345@Overridevoid apply(Project project) &#123; println 'apply AsmPlugin' mConfig = project.extensions.create(\"asmConfig\", AsmConfigModel.class)&#125; 在使用该插件的module下的build.gradle文件中配置 1234asmConfig &#123; startWithPatterns = ['com.shanbay'] excludesByFile = new File(projectDir, \"asm-excludes.txt\")&#125; 新建asm-excludes.txt文件，配置exclude信息 1com&#x2F;xxx&#x2F;xxx&#x2F;BaseActivity 这里是举个例子，在工程中很有可能有的Activity继承自一些基类Activity，对这些类插桩就重复了 使用Transform Api根据官网介绍，Transform Api允许第三方 Plugin 在打包 dex 文件之前的编译过程中操作.class 文件，下图是Transform Api的工作流程 可以看到，一次App的编译打包可能会经历多次Transform，Transform将输入进行处理，然后写入到指定的目录下作为下一个 Transform 的输入源。 使用插桩工具，我们需要借助于Transform Api实现 首先，我们需要让我们的插件继承自Transform 然后，我们要在插件apply时注册Transform 1234567@Overridevoid apply(Project project) &#123; println 'apply AsmPlugin' def android = project.extensions.getByType(AppExtension.class) android.registerTransform(this) mConfig = project.extensions.create(\"asmConfig\", AsmConfigModel.class)&#125; 最后，需要实现Transform类中的抽象方法 getName 这个方法是指定这个Transform的名称 1234@OverrideString getName() &#123; return 'AsmPlugin'&#125; getInputTypes 这个方法是指定输入类型 这里，我们选用TransformManager.CONTENT_CLASS就可以了 getScopes 这个方法是指定插桩的作用域 这里我们选择TransformManager.SCOPE_FULL_PROJECT，代表插桩范围包括此工程和它依赖的所有包 isIncremental 这个方法代表是否开启增量编译 如果开启的话可以减少编译时间，但需要增加额外的判断条件，所以这里就先不开启了 transform 这个方法是核心方法，我们要对输入内容进行处理然后输出 transform()方法的参数 TransformInvocation 是一个接口，提供了一些关于输入输出的一些基本信息。下图是transform中我们需要走的流程 这里以directoryInputs举例，directoryInputs就是本地源码编译后产生的class文件 12345678910111213141516171819202122232425262728293031323334353637private void handleDirectory(DirectoryInput input, TransformOutputProvider outputProvider) &#123; File file = input.file if (file.isDirectory()) &#123; //递归遍历该文件夹下面所有的子文件夹以及子文件 file.eachFileRecurse &#123; subFile -&gt; def fileName = subFile.name //初步判断这个文件（或文件夹）是否可插桩 if (fileName.endsWith(\".class\") &amp;&amp; !fileName.startsWith(\"R$\") &amp;&amp; \"R.class\" != fileName &amp;&amp; \"BuildConfig.class\" != fileName) &#123; //ClassReader: 字节码的读取与分析引擎 ClassReader classReader = new ClassReader(subFile.bytes) //ClassWriter: 它实现了ClassVisitor接口，用于拼接字节码 //COMPUTE_MAXS: 自动计算栈的最大值以及本地变量的最大数量 //COMPUTE_FRAMES: 包含COMPUTE_MAXS，且会自动计算方法的栈桢 ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS) //ClassVisitor: 定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等 ClassVisitor cv = new AsmClassVisitor(api, classWriter, mConfig) //使给定的ClassVisitor访问传递给此构造函数的jvm类文件结构 //EXPAND_FRAMES: 展开栈帧的标志位 classReader.accept(cv, ClassReader.EXPAND_FRAMES) FileOutputStream fos = new FileOutputStream( subFile.parentFile.absolutePath + File.separator + fileName) fos.write(classWriter.toByteArray()) fos.close() &#125; &#125; &#125; def dest = outputProvider.getContentLocation( input.name, input.contentTypes, input.scopes, Format.DIRECTORY ) FileUtils.copyDirectoryToDirectory(file, dest)&#125; 可以用以下流程图大概描述一下一个class文件的修改过程 自定义ClassVisitor我们开始继承ClassVisitor来实现我们对类的修改 读取配置 访问类 通过这个方法我们可以获得这个类的访问控制，全限定类名，父类名，实现的接口名等信息 这里，我们通过全限定类名和读取出的配置做比对，进一步验证是否需要对此类进行插桩 访问类内方法 通过这个方法我们可以获得这个类的所有方法的名称和描述符，我们通过它们来判断该方法是否需要插桩 如果有需要插桩的方法，就将mNeedStubClass标志位置为true，这个标识是为了我们后续判断是否要在该类中插入成员变量，然后使用我们自定义的MethodVisitor替换原始的MethodVisitor。 插入成员变量 在最后，如果有需要插桩的方法，我们需要将private long _$_timeRecorder这个成员变量插入到类中去 自定义MethodVisitor之前说了，Java 字节码指令是基于栈操作的，基本上任何操作都会改变栈状态 在方法执行之前插入代码12345678910111213141516171819202122232425262728293031323334353637383940414243/*** 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底* 示例：[栈顶 &lt;------------------&gt; 栈底]* [this, StringBuilder, System.out]* 此时，this为栈顶，System.out为栈底*/@Overridepublic void visitCode() &#123; /* 假设此时栈为空 */ //aload_0: 将this压入栈顶 mv.visitVarInsn(Opcodes.ALOAD, 0); /* 此时栈内容: [this] */ //invokestatic: 调用静态方法System.currentTimeMillis()，返回值为基础类型long //第二个参数代表类的全限定名，第三个参数代表方法名，第四个参数代表函数签名，()J的意思是不接受参数，返回值为J (J在字节码里代表基础类型long) mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); /* 此时栈内容: [System.currentTimeMillis()的结果值, this] */ //lneg: 将栈顶的long类型取负并将结果压入栈顶 mv.visitInsn(Opcodes.LNEG); /* 此时栈内容: [System.currentTimeMillis()的结果值取负, this] */ //putfield: 为该类的此实例变量赋值 //以(栈顶 - 1)为执行对象，为其赋值为栈顶值 (this._$_timeRecorder = -System.currentTimeMillis()) mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, \"J\"); super.visitCode();&#125; 在方法return之前插入代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453/*** 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底* 示例：[栈顶 &lt;------------------&gt; 栈底]* [this, StringBuilder, System.out]* this为栈顶，System.out为栈底*/@Overridepublic void visitInsn(int opcode) &#123; if (opcode == Opcodes.RETURN) &#123; Label labelEnd = new Label(); /* 假设此时栈为空 */ //aload_0: 将this压入栈顶 mv.visitVarInsn(Opcodes.ALOAD, 0); //dup: 将栈顶的值复制一份压入栈顶 mv.visitInsn(Opcodes.DUP); /* 此时栈内容: [this, this] */ //以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long //相当于this._$_timeRecorder mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, \"J\"); /* 此时栈内容: [this._$_timeRecorder, this] */ //执行System.currentTimeMillis()，并将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); /* 此时栈内容: [System.currentTimeMillis()执行后的结果值, this._$_timeRecorder, this] */ //将栈顶两long值相加，并将结果压入栈顶 //即this._$_timeRecorder + System.currentTimeMillis mv.visitInsn(Opcodes.LADD); /* 此时栈内容: [System.currentTimeMillis() + this._$_timeRecorder, this] */ //将栈顶的值存入(栈顶 - 1)._$_timeRecorder中 //即this._$_timeRecorder = this._$_timeRecorder + System.currentTimeMillis mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, \"J\"); /* 此时栈为空 */ //L: 对象类型，以分号结尾，如Ljava/lang/Object; mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\"); /* 此时栈内容: [System.out] */ //构建字符串 //创建一个StringBuilder对象，此时还并没有执行构造方法 mv.visitTypeInsn(Opcodes.NEW, \"java/lang/StringBuilder\"); //因为执行构造函数会将栈顶的StringBuilder对象弹出，为了后续能继续使用这个对象，所以这里需要先复制一份 mv.visitInsn(Opcodes.DUP); /* 此时栈内容: [StringBuilder, StringBuilder, System.out] */ //以栈顶的StringBuilder调用构造方法 mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); /* 此时栈内容: [StringBuilder, System.out] */ //将常量压入栈顶 mv.visitLdcInsn(\"Time spent: \"); /* 此时栈内容: [\"Time spent: \", StringBuilder, System.out] */ //以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] */ //将this压入栈顶 mv.visitVarInsn(Opcodes.ALOAD, 0); /* 此时栈内容: [this, StringBuilder, System.out] */ //以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long //相当于this._$_timeRecorder mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, \"J\"); /* 此时栈内容: [this._$_timeRecorder, StringBuilder, System.out] */ //以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(J)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] */ //将常量压入栈顶 mv.visitLdcInsn(\"ms, when \" + mFormatClassName + \".\" + mMethodName + \":\" + mMethodDescriptor); /* 此时栈内容: [字符串常量, StringBuilder, System.out] */ //以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] */ //以栈顶的值为主体，执行StringBuilder.toString()方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); /* 此时栈内容: [String, System.out] */ //以栈顶的值为参数，(栈顶 - 1)的引用为主体执行PrintStream.println()方法 //相当于System.out.println(String) mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false); /* 此时栈为空 */ //执行Thread.currentThread()，并将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java/lang/Thread\", \"currentThread\", \"()Ljava/lang/Thread;\", false); /* 此时栈内容: [Thread.currentThread()执行的结果] */ //以栈顶的值为主体，执行getStackTrace()方法，将返回值压入栈顶 //相当于Thread.currentThread().getStackTrace() mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/Thread\", \"getStackTrace\", \"()[Ljava/lang/StackTraceElement;\", false); /* 此时栈内容: [StackTraceElement数组] */ //astore: 将一个引用类型对象保存到局部变量表index为2的位置（index1: this, index2: onCreate方法的参数） //使用一个临时变量保存StackTraceElement数组 mv.visitVarInsn(Opcodes.ASTORE, 2); //将局部变量表index2处的引用对象压入栈顶 mv.visitVarInsn(Opcodes.ALOAD, 2); /* 此时栈内容: [StackTraceElement数组] 此时局部变量表中: [ 0 1 2 ] [this | Bundle | StackTraceElement数组] */ //StackTraceElement数组备份 mv.visitVarInsn(Opcodes.ASTORE, 3); mv.visitVarInsn(Opcodes.ALOAD, 3); /* 此时栈内容: [StackTraceElement数组] 此时局部变量表中: [ 0 1 2 3 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组] */ //获得栈顶位置数组的长度 mv.visitInsn(Opcodes.ARRAYLENGTH); /* 此时栈内容: [StackTraceElement数组长度] 此时局部变量表中: [ 0 1 2 3 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组] */ //将数组length保存至局部变量表index4的位置 mv.visitVarInsn(Opcodes.ISTORE, 4); /* 此时栈为空 此时局部变量表中: [ 0 1 2 3 4 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度] */ //将int常量0压入栈顶 mv.visitInsn(Opcodes.ICONST_0); //将栈顶的0取出保存（用作循环下标index） mv.visitVarInsn(Opcodes.ISTORE, 5); /* 此时栈为空 此时局部变量表中: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index] */ //循环开始处 //插入一个label用来做后续循环跳转的标志 Label labelLoop = new Label(); mv.visitLabel(labelLoop); //将循环标志位的值压入栈顶 mv.visitVarInsn(Opcodes.ILOAD, 5); //将数组长度值压入栈顶 mv.visitVarInsn(Opcodes.ILOAD, 4); /* 此时栈内容: [循环标志位, 数组长度] 此时局部变量表中: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index] */ //if_icmpge: 比较栈顶两int型数值大小, 当结果大于等于0时跳转 mv.visitJumpInsn(Opcodes.IF_ICMPGE, labelEnd); /* 此时栈为空 此时局部变量表中: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index] */ //将StackTraceElement数组压入栈顶 mv.visitVarInsn(Opcodes.ALOAD, 3); //将循环index的值压入栈顶 mv.visitVarInsn(Opcodes.ILOAD, 5); /* 此时栈内容: [循环index, StackTraceElement数组] 此时局部变量表中: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index] */ //将引用类型数组指定索引的值推送至栈顶（var3[var5]） mv.visitInsn(Opcodes.AALOAD); /* 此时栈内容: [StackTraceElement数组中的某个值(以循环index作为下标)] 此时局部变量表中: [ 0 1 2 3 4 5 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index] */ //将该索引下的值保存 mv.visitVarInsn(Opcodes.ASTORE, 6); /* 此时栈为空 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //将System.out入栈 mv.visitFieldInsn(Opcodes.GETSTATIC, \"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\"); /* 此时栈内容: [System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //new StringBuilder() mv.visitTypeInsn(Opcodes.NEW, \"java/lang/StringBuilder\"); mv.visitInsn(Opcodes.DUP); mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java/lang/StringBuilder\", \"&lt;init&gt;\", \"()V\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //取出StackTraceElement数组中的某个值(以循环index作为下标) mv.visitVarInsn(Opcodes.ALOAD, 6); /* 此时栈内容: [StackTraceElement数组中的某个值(以循环index作为下标), StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //使用栈顶对象，执行getClassName方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getClassName\", \"()Ljava/lang/String;\", false); /* 此时栈内容: [ClassName, StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //以ClassName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶 //即StringBuilder.append(ClassName) mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //将常量入栈 mv.visitLdcInsn(\".\"); //以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //将StackTraceElement数组中的某个值(以循环index作为下标)入栈 mv.visitVarInsn(Opcodes.ALOAD, 6); //调用它的getMethodName方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getMethodName\", \"()Ljava/lang/String;\", false); /* 此时栈内容: [MethodName, StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //以MethodName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //将常量入栈 mv.visitLdcInsn(\":\"); //以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(Ljava/lang/String;)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //将StackTraceElement数组中的某个值(以循环index作为下标)入栈 mv.visitVarInsn(Opcodes.ALOAD, 6); //调用它的getLineNumber方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getLineNumber\", \"()I\", false); /* 此时栈内容: [LineNumber, StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //以LineNumber作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"append\", \"(I)Ljava/lang/StringBuilder;\", false); /* 此时栈内容: [StringBuilder, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //调用栈顶对象的toString方法，将返回值压入栈顶 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/lang/StringBuilder\", \"toString\", \"()Ljava/lang/String;\", false); /* 此时栈内容: [String, System.out] 此时局部变量表中: [ 0 1 2 3 4 5 6 ] [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)] */ //以String作为参数，执行(栈顶 - 1)对象System.out的println方法 mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\", false); //iinc: 将指定int型变量增加指定值(index++) mv.visitIincInsn(5, 1); //跳转到labelLoop插入的位置 mv.visitJumpInsn(Opcodes.GOTO, labelLoop); //插入结束Label，作为循环终止的跳转标志 mv.visitLabel(labelEnd); &#125; super.visitInsn(opcode);&#125; 这样我们的方法插桩工作就完成了，接下来我们运行一下看看 运行先clean build，再build，查看控制台信息，build完成后查看class文件 运行App，查看Logcat信息，可以看到打印出来了我们想要的信息。 结语这样我们就通过插桩的方式，实现了一个简单的无任何代码侵入的性能检测工具 通过这一次实践，我对java的编译运行字节码，Android的打包流程有了更深的理解 完整项目地址：https://github.com/dreamgyf/AsmPluginDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"插桩","slug":"Android/插桩","permalink":"http://yoursite.com/categories/Android/%E6%8F%92%E6%A1%A9/"}],"tags":[{"name":"插桩","slug":"插桩","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A1%A9/"}]},{"title":"Android源码分析 - Binder驱动（中）","slug":"android/aosp/Android源码分析-Binder驱动（中）","date":"2022-02-28T08:33:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/02/28/android/aosp/Android源码分析-Binder驱动（中）/","link":"","permalink":"http://yoursite.com/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/","excerpt":"","text":"开篇本篇以aosp分支android-11.0.0_r25，kernel分支android-msm-wahoo-4.4-android11作为基础解析 上一篇文章Android源码分析 - Binder驱动（上），我们已经了解了binder驱动设备是如何注册的，并且分析了binder_open和binder_mmap操作函数，接下来我们继续分析binder驱动中最重要的部分binder_ioctl ioctl我们先简单介绍一下ioctl函数，这个函数是用来控制设备的，函数原型如下： 1int ioctl(int fd , unsigned long cmd , .../* args */); 第一个参数fd为设备的文件描述符 第二个参数cmd为命令码，它由驱动方自定义，用户通过命令码告诉设备驱动想要它做什么 后面为可选参数，具体内容和cmd有关，是传入驱动层的参数 命令码Linux内核是这么定义一个命令码的 设备类型 序列号 方向 数据尺寸 8 bit 8 bit 2 bit 8~14 bit 这样，一个命令就变成了一个整数形式的命令码了，为了使用起来方便，Linux定义了一些生成命令码的宏： 1234_IO(type,nr) //没有参数的命令_IOR(type,nr,size) //从驱动中读数据_IOW(type,nr,size) //写数据到驱动中_IOWR(type,nr,size) //双向读写 binder驱动命令码了解了ioctl和它的命令码后，我们来看看binder驱动定义了哪些命令码，以及它们分别有什么作用 binder驱动命令码被定义在include/uapi/linux/android/binder.h中，其中有几个貌似未使用，我就不列出来了 12345678#define BINDER_WRITE_READ _IOWR('b', 1, struct binder_write_read)#define BINDER_SET_MAX_THREADS _IOW('b', 5, __u32)#define BINDER_SET_CONTEXT_MGR _IOW('b', 7, __s32)#define BINDER_THREAD_EXIT _IOW('b', 8, __s32)#define BINDER_VERSION _IOWR('b', 9, struct binder_version)#define BINDER_GET_NODE_DEBUG_INFO _IOWR('b', 11, struct binder_node_debug_info)#define BINDER_GET_NODE_INFO_FOR_REF _IOWR('b', 12, struct binder_node_info_for_ref)#define BINDER_SET_CONTEXT_MGR_EXT _IOW('b', 13, struct flat_binder_object) BINDER_WRITE_READ：读写命令，用于数据传输，binder IPC通信中的核心 BINDER_SET_MAX_THREADS：设置最大线程数 BINDER_SET_CONTEXT_MGR：设置成为binder上下文管理者 BINDER_THREAD_EXIT：binder线程退出命令，释放相关资源 BINDER_VERSION：获取binder驱动版本号 BINDER_GET_NODE_DEBUG_INFO：获得binder节点的debug信息 BINDER_GET_NODE_INFO_FOR_REF：从binder引用获得binder节点信息 BINDER_SET_CONTEXT_MGR_EXT：和BINDER_SET_CONTEXT_MGR作用相同，携带额外参数 了解了这些binder驱动命令码，我们就可以开始正式分析binder_ioctl binder_ioctl这个函数位于drivers/android/binder.c文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; //从命令参数中解析出用户数据大小 unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; ... //进入休眠状态，等待被唤醒 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; //根据请求系统调用的线程的pid，查找对应的binder_thread，没有则新建一个 thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; case BINDER_WRITE_READ: ... break; case BINDER_SET_MAX_THREADS: &#123; ... break; &#125; case BINDER_SET_CONTEXT_MGR_EXT: &#123; ... break; &#125; case BINDER_SET_CONTEXT_MGR: ... break; case BINDER_VERSION: &#123; ... break; &#125; case BINDER_GET_NODE_INFO_FOR_REF: &#123; ... break; &#125; case BINDER_GET_NODE_DEBUG_INFO: &#123; ... break; &#125; default: ret = -EINVAL; goto err; &#125; ret = 0;err: ... return ret;&#125; 从整体上来看还是比较清晰的，我们对一些点做一下详解 __user__user是一个宏，它告诉编译器不应该解除这个指针的引用（因为在当前地址空间中它是没有意义的），(void __user *)arg表示arg是一个用户空间的地址，不能直接进行拷贝等，要使用copy_from_user，copy_to_user等函数。 wait_event_interruptiblewait_event_interruptible(wq, condition)是一个宏，它是用来挂起进程直到满足判断条件的 binder_stop_on_user_error是一个全局变量，它的初始值为0，binder_user_error_wait是一个等待队列 在正常情况下，binder_stop_on_user_error &lt; 2这个条件是成立的，所以不会进入挂起状态，而当binder因为错误而停止后，调用binder_ioctl，则会挂起进程，直到其他进程通过wake_up_interruptible来唤醒binder_user_error_wait队列，并且满足binder_stop_on_user_error &lt; 2这个条件，binder_ioctl才会继续往后运行 binder_thread结构体我们需要关注一个重要的结构体binder_thread，它在后续的代码中会频繁的出现，这个结构体描述了进程中的工作线程 123456789101112131415161718192021222324252627282930313233struct binder_thread &#123; //binder线程所属的进程 struct binder_proc *proc; //红黑树节点 struct rb_node rb_node; //链表节点 struct list_head waiting_thread_node; //进程pid int pid; //描述了线程当前的状态 int looper; /* only modified by this thread */ bool looper_need_return; /* can be written by other thread */ //binder事务栈（链表形式，内部存在前后节点） struct binder_transaction *transaction_stack; //todo队列，为需要处理的工作的链表 struct list_head todo; //binder_thread_write后是否立即执行完成binder_thread_read //false的情况下会在binder_thread_read中休眠，延迟执行BINDER_WORK_TRANSACTION_COMPLETE bool process_todo; struct binder_error return_error; struct binder_error reply_error; //等待队列，当处理binder事务需要依赖别的binder事务的时候，则会以此等待队列睡眠 //直到它所依赖的binder事务完成后唤醒 wait_queue_head_t wait; //统计信息 struct binder_stats stats; //临时引用计数 atomic_t tmp_ref; //是否死亡 bool is_dead; //线程信息结构体 struct task_struct *task;&#125;; binder_get_thread接下来我们看一下binder_ioctl是怎么获得binder_thread的 1234567891011121314151617181920static struct binder_thread *binder_get_thread(struct binder_proc *proc)&#123; struct binder_thread *thread; struct binder_thread *new_thread; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, NULL); binder_inner_proc_unlock(proc); if (!thread) &#123; new_thread = kzalloc(sizeof(*thread), GFP_KERNEL); if (new_thread == NULL) return NULL; binder_inner_proc_lock(proc); thread = binder_get_thread_ilocked(proc, new_thread); binder_inner_proc_unlock(proc); if (thread != new_thread) kfree(new_thread); &#125; return thread;&#125; 我们可以看到里面有锁操作，使用的就是上一章Android源码分析 - Binder驱动（上）中所介绍过的spinlock，使用的是binder_proc结构体中的inner_lock 简单浏览一下代码我们就可以知道，binder_get_thread首先试着从binder_proc获得binder_thread，如果没能获得，就新建一个，这两种情况都调用了binder_get_thread_ilocked函数 12345678910111213141516171819202122232425262728293031323334353637383940414243static struct binder_thread *binder_get_thread_ilocked( struct binder_proc *proc, struct binder_thread *new_thread)&#123; struct binder_thread *thread = NULL; struct rb_node *parent = NULL; struct rb_node **p = &amp;proc-&gt;threads.rb_node; while (*p) &#123; parent = *p; thread = rb_entry(parent, struct binder_thread, rb_node); if (current-&gt;pid &lt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_left; else if (current-&gt;pid &gt; thread-&gt;pid) p = &amp;(*p)-&gt;rb_right; else return thread; &#125; if (!new_thread) return NULL; thread = new_thread; //binder_thread对象创建计数加1 binder_stats_created(BINDER_STAT_THREAD); thread-&gt;proc = proc; thread-&gt;pid = current-&gt;pid; //引用计数加1 get_task_struct(current); thread-&gt;task = current; atomic_set(&amp;thread-&gt;tmp_ref, 0); init_waitqueue_head(&amp;thread-&gt;wait); //初始化todo队列 INIT_LIST_HEAD(&amp;thread-&gt;todo); //插入红黑树 rb_link_node(&amp;thread-&gt;rb_node, parent, p); rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads); thread-&gt;looper_need_return = true; thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR; thread-&gt;return_error.cmd = BR_OK; thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR; thread-&gt;reply_error.cmd = BR_OK; INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node); return thread;&#125; 这个函数分为前后两个部分，前半部分通过binder_proc-&gt;threads这个红黑树查找当前系统调用进程pid所对应的binder_thread，后半部分初始化了传入的new_thread，并将其插入到红黑树中（binder_proc-&gt;threads） 接下来就是判断命令码cmd，来执行相应的工作了，我们只分析比较重要的几个命令码 BINDER_WRITE_READbinder驱动中最重要的命令码肯定非BINDER_WRITE_READ莫属了，这个命令用来进行binder读写交互 12345678910111213141516171819static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; ... switch (cmd) &#123; case BINDER_WRITE_READ: ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; ... default: ret = -EINVAL; goto err; &#125; ret = 0;err: ... return ret;&#125; switch case命令码后，直接调用了binder_ioctl_write_read函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; //校验用户传入arg数据大小 if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto out; &#125; //将用户空间ubuf拷贝至内核空间bwr if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125; ... //当写缓存中有数据，执行binder写操作 if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); trace_binder_write_done(ret); if (ret &lt; 0) &#123; //有错误发生，将已读数据大小设为0 bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; //当读缓存中有数据，执行binder读操作 if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); trace_binder_read_done(ret); //如果todo队列中有未处理的任务，唤醒等待状态下的线程 binder_inner_proc_lock(proc); if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; ... //将内核空间修改后的bwr拷贝至用户空间ubuf if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125;out: return ret;&#125; binder_write_read结构体BINDER_WRITE_READ命令码所接受的参数为一个binder_write_read结构体，我们先来了解一下它 12345678struct binder_write_read &#123; binder_size_t write_size; /* bytes to write */ binder_size_t write_consumed; /* bytes consumed by driver */ binder_uintptr_t write_buffer; binder_size_t read_size; /* bytes to read */ binder_size_t read_consumed; /* bytes consumed by driver */ binder_uintptr_t read_buffer;&#125;; write_size：写数据的总大小 write_consumed：已写数据大小 write_buffer：写数据的虚拟内存地址 read_size：读数据的总大小 read_consumed：已读数据大小 read_buffer：读数据的虚拟内存地址 整个binder_ioctl_write_read函数结构是比较简单的，首先校验了一下用户空间所传的参数arg为binder_write_read结构体，接着将其从用户空间拷贝至内核空间bwr，接下来便是分别检查写缓存读缓存中是否有数据，有的话则执行相应的写读操作。这里需要注意的是，读写操作所传入的write_consumed和read_consumed是以地址的形式，即会对这两个值进行修改，不管读写操作是否执行，成功或者失败，最后都会调用copy_to_user将bwr从内核空间复制到用户空间ubuf 看到这里，可能有些同学会觉得有些奇怪，说好binder只进行一次复制的呢？其实是这样的没错，这里的copy_from_user或者copy_to_user只是复制了binder_write_read结构体，得到了需要IPC数据的虚拟内存地址而已，真正的复制操作是在binder读写操作中进行的 binder_thread_write先看binder写操作，这个函数首先从传入的参数中，计算出待写的起始地址和结束地址，因为可能数据中含有多个命令和对应数据要处理，所以这里开了一个循环，在循环中，首先调用get_user，从用户空间读取一个值到内核空间中来，这个值就是binder请求码，然后将指针向后移动32位，使其指向对应请求码的数据头，接着根据binder请求码去完成不同的工作，处理完后修改已写数据大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed)&#123; uint32_t cmd; struct binder_context *context = proc-&gt;context; void __user *buffer = (void __user *)(uintptr_t)binder_buffer; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; //可能含有多个命令和对应数据要处理 while (ptr &lt; end &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123; int ret; //获得binder请求码 if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; //使指针指向数据头 ptr += sizeof(uint32_t); trace_binder_command(cmd); //记录binder数据信息 if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123; atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]); atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]); atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]); &#125; //根据binder请求码，执行不同工作 switch (cmd) &#123; case BC_INCREFS: case BC_ACQUIRE: case BC_RELEASE: case BC_DECREFS: &#123; ... break; &#125; case BC_INCREFS_DONE: case BC_ACQUIRE_DONE: &#123; ... break; &#125; case BC_ATTEMPT_ACQUIRE: pr_err(\"BC_ATTEMPT_ACQUIRE not supported\\n\"); return -EINVAL; case BC_ACQUIRE_RESULT: pr_err(\"BC_ACQUIRE_RESULT not supported\\n\"); return -EINVAL; case BC_FREE_BUFFER: &#123; ... break; &#125; case BC_TRANSACTION_SG: case BC_REPLY_SG: &#123; ... break; &#125; case BC_TRANSACTION: case BC_REPLY: &#123; ... break; &#125; case BC_REGISTER_LOOPER: ... break; case BC_ENTER_LOOPER: ... break; case BC_EXIT_LOOPER: ... break; case BC_REQUEST_DEATH_NOTIFICATION: case BC_CLEAR_DEATH_NOTIFICATION: &#123; ... &#125; break; case BC_DEAD_BINDER_DONE: &#123; ... &#125; break; default: pr_err(\"%d:%d unknown command %d\\n\", proc-&gt;pid, thread-&gt;pid, cmd); return -EINVAL; &#125; //设置已写数据大小 *consumed = ptr - buffer; &#125; return 0;&#125; binder请求码binder请求码用于用户空间程序向binder驱动发送请求消息，以BC开头，被定义在enum binder_driver_command_protocol中（include/uapi/linux/android/binder.h） 命令 | 说明 | 参数类型 || —————————– | —————————- | ——————– || BC_TRANSACTION | Binder事务，即：Client对于Server的请求 | binder_transaction_data || BC_REPLY | 事务的应答，即：Server对于Client的回复 | binder_transaction_data || BC_FREE_BUFFER | 通知驱动释放Buffer | binder_uintptr_t || BC_ACQUIRE | 强引用计数+1 | __u32 || BC_RELEASE | 强引用计数-1 | __u32 || BC_INCREFS | 弱引用计数+1 | __u32 || BC_DECREFS | 弱引用计数-1 | __u32 || BC_ACQUIRE_DONE | BR_ACQUIRE的回复 | binder_ptr_cookie || BC_INCREFS_DONE | BR_INCREFS的回复 | binder_ptr_cookie || BC_ENTER_LOOPER | 通知驱动主线程ready | void || BC_REGISTER_LOOPER | 通知驱动子线程ready | void || BC_EXIT_LOOPER | 通知驱动线程已经退出 | void || BC_REQUEST_DEATH_NOTIFICATION | 请求接收死亡通知 | binder_handle_cookie || BC_CLEAR_DEATH_NOTIFICATION | 去除接收死亡通知 | binder_handle_cookie || BC_DEAD_BINDER_DONE | 已经处理完死亡通知 | binder_uintptr_t || BC_ATTEMPT_ACQUIRE | 暂不支持 | - || BC_ACQUIRE_RESULT | 暂不支持 | - | 其中，最重要且最频繁的操作为BC_TRANSACTION/BC_REPLY，我们就只分析一下这两个请求码做了什么事 binder_transaction12345678910111213141516171819202122232425static int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, binder_uintptr_t binder_buffer, size_t size, binder_size_t *consumed)&#123; ... while (...) &#123; ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY, 0); break; &#125; ... &#125; ...&#125; 对于这两个请求码，首先从用户空间中复制了一份binder_transaction_data到内核空间，接着就调用binder_transaction函数继续处理 binder_transaction_data结构体在分析binder_transaction函数前，我们需要先了解一些结构体 binder_transaction_data结构体就是BC_TRANSACTION/BC_REPLY所对应的参数类型，它被定义在include/uapi/linux/android/binder.h中 1234567891011121314151617181920212223242526272829303132333435struct binder_transaction_data &#123; union &#123; //当BINDER_WRITE_READ命令的目标对象非本地binder实体时，用handle表示对目标binder的引用 __u32 handle; //当BINDER_WRITE_READ命令的目标对象是本地binder实体时，用此域成员变量表示这个对象在本进程中的内存地址 binder_uintptr_t ptr; &#125; target; //目标binder实体所带的附加数据 binder_uintptr_t cookie; //表示要对目标对象请求的命令代码 __u32 code; //事务标志，详见enum transaction_flags __u32 flags; //发起请求的进程pid pid_t sender_pid; //发起请求的进程uid uid_t sender_euid; //真正要传输的数据的大小 binder_size_t data_size; //偏移数组大小，这个偏移数组是用来描述数据区中，每一个binder对象的位置的 binder_size_t offsets_size; union &#123; struct &#123; //数据区的首地址 binder_uintptr_t buffer; //偏移数组的首地址，这个偏移数组是用来描述数据区中，每一个binder对象的位置的 //数组的每一项为一个binder_size_t，这个值对应着每一个binder对象相对buffer首地址的偏移 binder_uintptr_t offsets; &#125; ptr; //数据较小的时候可以直接装在这个数组里 __u8 buf[8]; &#125; data;&#125;; 可以看到，真正需要拷贝的数据的地址是保存在data域中的，可能文字描述的data结构不是特别清晰，可以结合下图理解： 这里我用一个例子来解释一下binder_transaction_data传输的数据是什么样子的 小伙伴们应该都了解Parcel吧，它是一个存放读取数据的容器，我们binder_transaction_data中实际传输的数据就是通过它组合而成的，它可以传输基本数据类型，Parcelable类型和binder类型 其中基本数据类型就不用说了，每种基本类型所占用的大小是固定的，Parcelable类型实际上也是传输基本数据类型，它是通过实现Parcelable接口将一个复杂对象中的成员序列化成了一个个基本数据类型传输，而binder类型的传输有点特别，它会将这个binder对象 “压扁” 成一个flat_binder_object结构体传输 假设我们有一个客户端client，一个服务端server，client想要向binder驱动发起一个事物，调用server的某个方法，我们该怎么构建binder_transaction_data的数据区呢？ 一般来说，我们需要先写一个token，这个token是为了进行校验的，两端需要保持一致。接着我们需要按顺序依次写入参数，假设我们想要调用server的callMe(int, Parcelable, IBinder)函数，那我们就需要先写入一个int，再写入一个Parcelable，最后再将IBinder “压扁” 成一个flat_binder_object写入。 此时数据布局如下图所示： 从图中我们可以看出来，offsets指示出了buffer中传输的binder对象的位置，有几个binder对象，就会有几个offset与之对应 transaction_flags我们再看一下有哪些事务标志，他们分别代表什么意思 12345678910enum transaction_flags &#123; //单向调用，异步操作，无返回 TF_ONE_WAY = 0x01, //reply内容是一个组件的根对象，对应类型为本地binder TF_ROOT_OBJECT = 0x04, //reply内容是一个32位的状态码，对应类型为远程binder引用的句柄 TF_STATUS_CODE = 0x08, //可以接收一个文件描述符，对应的类型为文件（BINDER_TYPE_FD），即handle中存储的为文件描述符 TF_ACCEPT_FDS = 0x10,&#125;; binder_transaction结构体binder_transaction结构体用来描述进程间通信过程（事务），它被定义在drivers/android/binder.c中 123456789101112131415161718192021222324252627282930313233struct binder_transaction &#123; int debug_id; //用来描述需要处理的工作事项 struct binder_work work; //发起事务的线程 struct binder_thread *from; //事务所依赖的另一个事务 struct binder_transaction *from_parent; //处理该事务的进程 struct binder_proc *to_proc; //处理该事务的线程 struct binder_thread *to_thread; //目标线程下一个需要处理的事务 struct binder_transaction *to_parent; //1: 表示同步事务，需要等待对方回复 //0: 表示异步事务 unsigned need_reply:1; //指向为该事务分配的内核缓冲区 struct binder_buffer *buffer; unsigned int code; unsigned int flags; //发起事务线程的优先级 struct binder_priority priority; //线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求 //在修改之前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级 struct binder_priority saved_priority; bool set_priority_called; kuid_t sender_euid; binder_uintptr_t security_ctx; spinlock_t lock;&#125;; binder_work结构体binder_work结构体用来描述需要处理的工作事项，它被定义在drivers/android/binder.c中 123456789101112131415struct binder_work &#123; //双向链表中的一个节点，这个链表储存了所有的binder_work struct list_head entry; //工作项类型 enum binder_work_type &#123; BINDER_WORK_TRANSACTION = 1, BINDER_WORK_TRANSACTION_COMPLETE, BINDER_WORK_RETURN_ERROR, BINDER_WORK_NODE, BINDER_WORK_DEAD_BINDER, BINDER_WORK_DEAD_BINDER_AND_CLEAR, BINDER_WORK_CLEAR_DEATH_NOTIFICATION, &#125; type;&#125;; 简单看完了一些必要的结构体后，我们把目光转回binder_transaction函数上 binder_transaction函数的代码很长，我们精简一下，然后再分段来看，从整体上，我们可以将它分为几个部分： 获得目标进程/线程信息 将数据拷贝到目标进程所映射的内存中（此时会建立实际的映射关系） 将待处理的任务加入todo队列，唤醒目标线程 第一部分：获得目标进程/线程信息这里根据是否为reply，分成了两种情况 BC_TRANSACTION我们先看BC_TRANSACTION的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; uint32_t return_error = 0; struct binder_context *context = proc-&gt;context; if (reply) &#123; ... &#125; else &#123; if (tr-&gt;target.handle) &#123; struct binder_ref *ref; binder_proc_lock(proc); //查找binder引用 ref = binder_get_ref_olocked(proc, tr-&gt;target.handle, true); //通过目标binder实体获取目标进程信息 target_node = binder_get_node_refs_for_txn( ref-&gt;node, &amp;target_proc, &amp;return_error); binder_proc_unlock(proc); &#125; else &#123; //handle为0代表目标target是ServiceManager mutex_lock(&amp;context-&gt;context_mgr_node_lock); //ServiceManager为binder驱动的context，所以可以直接从context中获取binder实体 target_node = context-&gt;binder_context_mgr_node; if (target_node) //通过目标binder实体获取目标进程信息 target_node = binder_get_node_refs_for_txn( target_node, &amp;target_proc, &amp;return_error); else return_error = BR_DEAD_REPLY; mutex_unlock(&amp;context-&gt;context_mgr_node_lock); if (target_node &amp;&amp; target_proc == proc) &#123; ... //error &#125; &#125; ... //使用LSM进行安全检查 if (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; 0) &#123; ... //error &#125; binder_inner_proc_lock(proc); //flags不带TF_ONE_WAY（即需要reply）并且当前线程存在binder事务栈 if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123; struct binder_transaction *tmp; tmp = thread-&gt;transaction_stack; if (tmp-&gt;to_thread != thread) &#123; ... //error &#125; //寻找一个合适的目标binder线程 while (tmp) &#123; struct binder_thread *from; spin_lock(&amp;tmp-&gt;lock); from = tmp-&gt;from; if (from &amp;&amp; from-&gt;proc == target_proc) &#123; atomic_inc(&amp;from-&gt;tmp_ref); target_thread = from; spin_unlock(&amp;tmp-&gt;lock); break; &#125; spin_unlock(&amp;tmp-&gt;lock); tmp = tmp-&gt;from_parent; &#125; &#125; binder_inner_proc_unlock(proc); &#125; ...&#125; 可以看到，虽然整个函数很长很复杂，但经过我们的拆分精简，逻辑就清晰很多了 binder_transaction_data.target.handle用一个int值表示目标binder引用，当它不为0时，调用binder_get_ref_olocked函数查找binder_ref binder_get_ref_olocked12345678910111213141516171819202122static struct binder_ref *binder_get_ref_olocked(struct binder_proc *proc, u32 desc, bool need_strong_ref)&#123; struct rb_node *n = proc-&gt;refs_by_desc.rb_node; struct binder_ref *ref; while (n) &#123; ref = rb_entry(n, struct binder_ref, rb_node_desc); if (desc &lt; ref-&gt;data.desc) &#123; n = n-&gt;rb_left; &#125; else if (desc &gt; ref-&gt;data.desc) &#123; n = n-&gt;rb_right; &#125; else if (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123; binder_user_error(\"tried to use weak ref as strong ref\\n\"); return NULL; &#125; else &#123; return ref; &#125; &#125; return NULL;&#125; 可以看到，这个函数就是从binder_proc.refs_by_desc这个红黑树中，通过desc句柄查找到对应的binder引用binder_ref，这样就可以通过binder_ref.node获得到binder实体binder_node 接着再调用binder_get_node_refs_for_txn函数通过目标binder实体获取目标进程信息 binder_get_node_refs_for_txn123456789101112131415161718192021222324static struct binder_node *binder_get_node_refs_for_txn( struct binder_node *node, struct binder_proc **procp, uint32_t *error)&#123; struct binder_node *target_node = NULL; binder_node_inner_lock(node); if (node-&gt;proc) &#123; target_node = node; //binder_node强引用计数加1 binder_inc_node_nilocked(node, 1, 0, NULL); //binder_node临时引用计数加1 binder_inc_node_tmpref_ilocked(node); //binder_proc临时引用计数加1 atomic_inc(&amp;node-&gt;proc-&gt;tmp_ref); //使外部传入的proc指针指向binder_proc地址 *procp = node-&gt;proc; &#125; else *error = BR_DEAD_REPLY; binder_node_inner_unlock(node); return target_node;&#125; 这个函数第二个参数接受一个binder_proc **类型，即指向指针的指针，调用方对proc取地址，即指向proc指针分配在栈上的地址，这样函数中对procp解引用就得到了proc指针本身的地址，即可使proc指针指向binder_proc的地址 当binder_transaction_data.target.handle为0时，表示目标是ServiceManager，而ServiceManager是binder驱动的context，所以可以直接从context中获取binder实体，关于ServiceManager是怎么成为binder驱动的context的，我们会在后面的章节进行分析 接下来做一下安全检查，当flags不带TF_ONE_WAY（即需要reply）并且当前线程存在binder事务栈时，寻找一个合适的目标binder工作线程用来处理此事务（线程复用） 这里client端可能是第一次请求服务，此时binder_thread里是不存在binder事务栈，所以是没法找到目标binder线程的 BC_REPLY接着，我们再看BC_REPLY的情况 123456789101112131415161718192021222324252627282930313233343536static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_transaction *in_reply_to = NULL; if (reply) &#123; binder_inner_proc_lock(proc); //这个事务是发起事务，也就是说我们需要对这个事务做应答 in_reply_to = thread-&gt;transaction_stack; if (in_reply_to == NULL) &#123; ... //error &#125; if (in_reply_to-&gt;to_thread != thread) &#123; ... //error &#125; //改指向下一个需要处理的事务，即将这个事务移出链表 thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; binder_inner_proc_unlock(proc); //目标线程即为需要回应的事务的发起线程 target_thread = binder_get_txn_from_and_acq_inner(in_reply_to); if (target_thread-&gt;transaction_stack != in_reply_to) &#123; ... //error &#125; //通过binder_thread获得binder_proc target_proc = target_thread-&gt;proc; atomic_inc(&amp;target_proc-&gt;tmp_ref); binder_inner_proc_unlock(target_thread-&gt;proc); &#125; else &#123; ... &#125; ...&#125; 123456789101112131415161718static struct binder_thread *binder_get_txn_from_and_acq_inner( struct binder_transaction *t)&#123; struct binder_thread *from; //相当于 from = t-&gt;from; 内部加了锁和引用计数操作 from = binder_get_txn_from(t); if (!from) return NULL; binder_inner_proc_lock(from-&gt;proc); if (t-&gt;from) &#123; BUG_ON(from != t-&gt;from); return from; &#125; binder_inner_proc_unlock(from-&gt;proc); binder_thread_dec_tmpref(from); return NULL;&#125; BC_REPLY获取目标进程/线程信息就更简单了，BC_TRANSACTION中我们还需要根据binder句柄来获取各种信息，BC_REPLY我们只需要找到需要回应的那个事务，那个事务所在的线程和进程即为reply事务的目标线程和目标进程 第二部分：数据拷贝，建立映射123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; int ret; struct binder_transaction *t; struct binder_work *tcomplete; binder_size_t *offp, *off_end, *off_start; binder_size_t off_min; u8 *sg_bufp, *sg_buf_end; struct binder_proc *target_proc = NULL; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL u32 secctx_sz = 0; ... //为目标进程binder事务分配空间（后续会加到目标进程/线程的todo队列中，由目标进程/线程处理这个事务） t = kzalloc(sizeof(*t), GFP_KERNEL); spin_lock_init(&amp;t-&gt;lock); tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); t-&gt;debug_id = t_debug_id; //设置事务发起线程 if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; t-&gt;sender_euid = task_euid(proc-&gt;tsk); //设置事务处理进程 t-&gt;to_proc = target_proc; //设置事务处理线程 t-&gt;to_thread = target_thread; t-&gt;code = tr-&gt;code; t-&gt;flags = tr-&gt;flags; //设置优先级 if (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; binder_supported_policy(current-&gt;policy)) &#123; /* Inherit supported policies for synchronous transactions */ t-&gt;priority.sched_policy = current-&gt;policy; t-&gt;priority.prio = current-&gt;normal_prio; &#125; else &#123; /* Otherwise, fall back to the default priority */ t-&gt;priority = target_proc-&gt;default_priority; &#125; //安全相关 if (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123; ... &#125; //分配缓存，建立映射 t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size, tr-&gt;offsets_size, extra_buffers_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; t-&gt;buffer-&gt;transaction = t; t-&gt;buffer-&gt;target_node = target_node; off_start = (binder_size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); offp = off_start; //这里就是真正的一次复制 copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t) tr-&gt;data.ptr.buffer, tr-&gt;data_size); copy_from_user(offp, (const void __user *)(uintptr_t) tr-&gt;data.ptr.offsets, tr-&gt;offsets_size); //检查数据对齐 if (!IS_ALIGNED(tr-&gt;offsets_size, sizeof(binder_size_t))) &#123; ... //error &#125; if (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) &#123; ... //error &#125; off_end = (void *)off_start + tr-&gt;offsets_size; sg_bufp = (u8 *)(PTR_ALIGN(off_end, sizeof(void *))); sg_buf_end = sg_bufp + extra_buffers_size - ALIGN(secctx_sz, sizeof(u64)); off_min = 0; //循环遍历每一个binder对象 for (; offp &lt; off_end; offp++) &#123; struct binder_object_header *hdr; size_t object_size = binder_validate_object(t-&gt;buffer, *offp); if (object_size == 0 || *offp &lt; off_min) &#123; ... //error &#125; hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp); off_min = *offp + object_size; switch (hdr-&gt;type) &#123; //需要对binder类型进行转换 //因为在A进程中为本地binder对象，对于B进程则为远程binder对象，反之亦然 case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct flat_binder_object *fp; fp = to_flat_binder_object(hdr); ret = binder_translate_binder(fp, t, thread); &#125; break; case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; struct flat_binder_object *fp; fp = to_flat_binder_object(hdr); ret = binder_translate_handle(fp, t, thread); &#125; break; case BINDER_TYPE_FD: &#123; ... &#125; break; case BINDER_TYPE_FDA: &#123; ... &#125; break; case BINDER_TYPE_PTR: &#123; ... &#125; break; default: ... //error &#125; &#125; //设置工作类型 tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; //设置目标进程的事务类型 t-&gt;work.type = BINDER_WORK_TRANSACTION; ...&#125; 我们可以将这一部分再细分成几个部分： 分配缓存，建立映射 数据拷贝 binder类型转换 分配缓存，建立映射我们首先看分配缓存，建立映射是怎么做的，它调用了binder_alloc_new_buf函数，这个函数定义在drivers/android/binder_alloc.c中，内部加了锁后调用了binder_alloc_new_buf_locked函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103static struct binder_buffer *binder_alloc_new_buf_locked( struct binder_alloc *alloc, size_t data_size, size_t offsets_size, size_t extra_buffers_size, int is_async)&#123; struct rb_node *n = alloc-&gt;free_buffers.rb_node; struct binder_buffer *buffer; size_t buffer_size; struct rb_node *best_fit = NULL; void *has_page_addr; void *end_page_addr; size_t size, data_offsets_size; int ret; if (alloc-&gt;vma == NULL) &#123; ... //error &#125; //计算需要的缓冲区大小 //这里需要将size对齐void *（32位下占用4字节，64位下占用8字节） data_offsets_size = ALIGN(data_size, sizeof(void *)) + ALIGN(offsets_size, sizeof(void *)); size = data_offsets_size + ALIGN(extra_buffers_size, sizeof(void *)); size = max(size, sizeof(void *)); //从binder_alloc的空闲缓冲红黑树中找到一个大小最合适的binder_buffer while (n) &#123; //当找到一个需求大小和缓存区大小刚好相同的空闲缓存区时 //此时buffer就正好指向这个空闲缓存区 buffer = rb_entry(n, struct binder_buffer, rb_node); BUG_ON(!buffer-&gt;free); buffer_size = binder_alloc_buffer_size(alloc, buffer); //当只找到一个比需求大小稍大一点的空闲缓存区时 //此时buffer指向的是这个空闲缓存区所在节点的父节点 //然后n指向NULL if (size &lt; buffer_size) &#123; best_fit = n; n = n-&gt;rb_left; &#125; else if (size &gt; buffer_size) n = n-&gt;rb_right; else &#123; best_fit = n; break; &#125; &#125; if (best_fit == NULL) &#123; ... //error &#125; //此时buffer指向的是所需求的空闲缓存区所在红黑树节点的父节点 //需要让其指向真正需求的那个空闲缓存区 if (n == NULL) &#123; buffer = rb_entry(best_fit, struct binder_buffer, rb_node); buffer_size = binder_alloc_buffer_size(alloc, buffer); &#125; //计算出buffer的终点，向下对齐（不能超过可用的buffer_size） has_page_addr = (void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK); WARN_ON(n &amp;&amp; buffer_size != size); //计算出实际上我们接收数据需要的空间的终点，向上映射 end_page_addr = (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + size); //如果超出了可用的buffer_size，恢复到正常可用的结束地址 if (end_page_addr &gt; has_page_addr) end_page_addr = has_page_addr; //分配物理页，建立映射 ret = binder_update_page_range(alloc, 1, (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr); if (ret) return ERR_PTR(ret); //有空余空间的话，分隔这个buffer，剩余的buffer加入到空闲缓存区红黑树中（合理利用空间） if (buffer_size != size) &#123; struct binder_buffer *new_buffer; new_buffer = kzalloc(sizeof(*buffer), GFP_KERNEL); new_buffer-&gt;data = (u8 *)buffer-&gt;data + size; list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry); new_buffer-&gt;free = 1; binder_insert_free_buffer(alloc, new_buffer); &#125; //我们已经使用了这个buffer，要将其从空闲缓存区红黑树中移除 rb_erase(best_fit, &amp;alloc-&gt;free_buffers); //标记为非空闲 buffer-&gt;free = 0; buffer-&gt;allow_user_free = 0; //插入到已分配缓存区红黑树中 binder_insert_allocated_buffer_locked(alloc, buffer); buffer-&gt;data_size = data_size; buffer-&gt;offsets_size = offsets_size; buffer-&gt;async_transaction = is_async; buffer-&gt;extra_buffers_size = extra_buffers_size; //如果是异步事件, 那么更新binder_alloc的异步事件空闲buffer if (is_async) &#123; alloc-&gt;free_async_space -= size + sizeof(struct binder_buffer); &#125; return buffer; ...&#125; 这个函数的整体逻辑分为三个部分： 找到可用的空闲内核缓存区，计算我们需要分配的大小 分配物理页，建立映射 初始化新分配的buffer 其中1、3部分已经用注释标出来了，应该还是比较好理解的，我们终点看一下第2部分：怎么分配物理页，建立映射 我们在上一章Android源码分析 - Binder驱动（上）中说到，binder_mmap并没有立即将内核虚拟内存和进程虚拟内存与物理内存做映射，实际上这个映射操作是在binder_update_page_range这里做的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static int binder_update_page_range(struct binder_alloc *alloc, int allocate, void *start, void *end)&#123; void *page_addr; unsigned long user_page_addr; struct binder_lru_page *page; struct vm_area_struct *vma = NULL; struct mm_struct *mm = NULL; bool need_mm = false; if (end &lt;= start) return 0; if (allocate == 0) goto free_range; //检查是否有页框需要分配 for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;buffer) / PAGE_SIZE]; if (!page-&gt;page_ptr) &#123; need_mm = true; break; &#125; &#125; //指向目标用户进程的内存空间描述体 if (need_mm &amp;&amp; atomic_inc_not_zero(&amp;alloc-&gt;vma_vm_mm-&gt;mm_users)) mm = alloc-&gt;vma_vm_mm; if (mm) &#123; //获取mm_struct的读信号量 down_read(&amp;mm-&gt;mmap_sem); //检查mm是否有效 if (!mmget_still_valid(mm)) &#123; //释放 if (allocate == 0) goto free_range; //错误 goto err_no_vma; &#125; vma = alloc-&gt;vma; &#125; if (!vma &amp;&amp; need_mm) &#123; ... //error &#125; for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; int ret; bool on_lru; size_t index; //指向对应页框地址，为后面赋值做准备 index = (page_addr - alloc-&gt;buffer) / PAGE_SIZE; page = &amp;alloc-&gt;pages[index]; //page-&gt;page_ptr不为NULL说明之前已经分配并映射过了 if (page-&gt;page_ptr) &#123; on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru); continue; &#125; //分配一个页的物理内存 page-&gt;page_ptr = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO); //未分配成功 if (!page-&gt;page_ptr) &#123; ... //error &#125; page-&gt;alloc = alloc; INIT_LIST_HEAD(&amp;page-&gt;lru); //将物理内存空间映射到内核虚拟内存空间 ret = map_kernel_range_noflush((unsigned long)page_addr, PAGE_SIZE, PAGE_KERNEL, &amp;page-&gt;page_ptr); flush_cache_vmap((unsigned long)page_addr, (unsigned long)page_addr + PAGE_SIZE); //根据之前计算的user_buffer_offset可以直接得到目标用户空间进程虚拟内存地址 user_page_addr = (uintptr_t)page_addr + alloc-&gt;user_buffer_offset; //将物理内存空间映射到目标用户进程虚拟内存空间 ret = vm_insert_page(vma, user_page_addr, page[0].page_ptr); if (index + 1 &gt; alloc-&gt;pages_high) alloc-&gt;pages_high = index + 1; &#125; if (mm) &#123; //释放mm_struct的读信号量 up_read(&amp;mm-&gt;mmap_sem); mmput(mm); &#125; return 0; ... //错误处理&#125; 代码中的注释写的应该比较清楚了，总之就是先分配物理内存，再将这块物理内存分别映射到内核虚拟空间和用户进程虚拟空间，这样内核虚拟空间与用户进程虚拟空间相当于也间接的建立了映射关系 关于物理内存的分配以及映射，就是Linux内核层的事情了，感兴趣的同学可以再深入往里看看，这里就不再多说了 数据拷贝关于数据拷贝这部分就不用多说了，物理内存已经分配好了，映射也建立了，接下来直接调用copy_from_user将数据从用户空间拷贝至映射的那块内存就可以了 binder类型转换最后循环遍历每一个binder对象，对其中每一个binder对象类型做转换，因为在一个进程中为本地binder对象，对于另一个进程则为远程binder对象，反之亦然 flat_binder_object结构体这里就是我们之前提到的，binder对象在传输过程中会被 “压扁” 的结构 123456789101112131415161718struct flat_binder_object &#123; //描述了binder对象的类型 struct binder_object_header hdr; //和binder_transaction_data中flags含义相同 __u32 flags; /* 8 bytes of data. */ union &#123; //当hdr.type == BINDER_TYPE_BINDER时，表示是一个binder实体对象，指向binder实体在用户空间的地址 binder_uintptr_t binder; /* local object */ //当hdr.type == BINDER_TYPE_HANDLE，表示是一个binder引用句柄 __u32 handle; /* remote object */ &#125;; ////当hdr.type == BINDER_TYPE_BINDER时才有值，表示携带的额外数据 /* extra data associated with local object */ binder_uintptr_t cookie;&#125;; binder_translate_binderBINDER_TYPE_BINDER表示是一个binder实体对象，需要将它转换成binder引用句柄 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int binder_translate_binder(struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread)&#123; struct binder_node *node; struct binder_proc *proc = thread-&gt;proc; struct binder_proc *target_proc = t-&gt;to_proc; struct binder_ref_data rdata; int ret = 0; //通过proc-&gt;nodes.rb_node红黑树查找binder_node node = binder_get_node(proc, fp-&gt;binder); //如果没有找到，新建一个binder_node并将其插入红黑树 if (!node) &#123; node = binder_new_node(proc, fp); if (!node) return -ENOMEM; &#125; if (fp-&gt;cookie != node-&gt;cookie) &#123; ... //error &#125; //安全检查 if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123; ret = -EPERM; goto done; &#125; //查找binder_ref并将其引用计数加1，如果没有查找到则创建一个，并将其插入红黑树 ret = binder_inc_ref_for_node(target_proc, node, fp-&gt;hdr.type == BINDER_TYPE_BINDER, &amp;thread-&gt;todo, &amp;rdata); if (ret) goto done; //转换binder类型 if (fp-&gt;hdr.type == BINDER_TYPE_BINDER) fp-&gt;hdr.type = BINDER_TYPE_HANDLE; else fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;binder = 0; //binder引用句柄赋值 fp-&gt;handle = rdata.desc; fp-&gt;cookie = 0;done: //binder_node临时引用计数减1 binder_put_node(node); return ret;&#125; binder_translate_handleBINDER_TYPE_HANDLE表示是一个binder引用句柄，，需要将它转换成binder实体对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int binder_translate_handle(struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread)&#123; struct binder_proc *proc = thread-&gt;proc; struct binder_proc *target_proc = t-&gt;to_proc; struct binder_node *node; struct binder_ref_data src_rdata; int ret = 0; //从proc-&gt;refs_by_desc.rb_node红黑树中查找binder_node，并将其临时引用计数加1 node = binder_get_node_from_ref(proc, fp-&gt;handle, fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata); //安全检查 if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123; ret = -EPERM; goto done; &#125; binder_node_lock(node); //如果binder实体所在的进程为事务处理进程 if (node-&gt;proc == target_proc) &#123; //binder类型转换 if (fp-&gt;hdr.type == BINDER_TYPE_HANDLE) fp-&gt;hdr.type = BINDER_TYPE_BINDER; else fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER; fp-&gt;binder = node-&gt;ptr; fp-&gt;cookie = node-&gt;cookie; if (node-&gt;proc) binder_inner_proc_lock(node-&gt;proc); //binder强引用计数加1 binder_inc_node_nilocked(node, fp-&gt;hdr.type == BINDER_TYPE_BINDER, 0, NULL); if (node-&gt;proc) binder_inner_proc_unlock(node-&gt;proc); binder_node_unlock(node); &#125; else &#123; //重新查找binder_ref struct binder_ref_data dest_rdata; binder_node_unlock(node); ret = binder_inc_ref_for_node(target_proc, node, fp-&gt;hdr.type == BINDER_TYPE_HANDLE, NULL, &amp;dest_rdata); if (ret) goto done; fp-&gt;binder = 0; fp-&gt;handle = dest_rdata.desc; fp-&gt;cookie = 0; &#125;done: //binder_node临时引用计数减1 binder_put_node(node); return ret;&#125; 第三部分：加入todo队列，唤醒目标线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; struct binder_transaction *t; struct binder_work *tcomplete; struct binder_thread *target_thread = NULL; struct binder_transaction *in_reply_to = NULL; ... if (reply) &#123; //如果请求码为BC_REPLY //将tcomplete插入到事务发起binder线程的todo队列中 binder_enqueue_thread_work(thread, tcomplete); binder_inner_proc_lock(target_proc); if (target_thread-&gt;is_dead) &#123; binder_inner_proc_unlock(target_proc); goto err_dead_proc_or_thread; &#125; //将发起事务从目标binder线程的事务链表中移除 binder_pop_transaction_ilocked(target_thread, in_reply_to); //将t-&gt;work插入到目标binder线程的todo队列中 binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work); binder_inner_proc_unlock(target_proc); //唤醒目标binder线程的等待队列 wake_up_interruptible_sync(&amp;target_thread-&gt;wait); //恢复发起事务的优先级 binder_restore_priority(current, in_reply_to-&gt;saved_priority); //释放发起事务 binder_free_transaction(in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; //如果请求码为BC_TRANSACTION并且不为异步操作，需要返回 binder_inner_proc_lock(proc); //将tcomplete插入到事务发起binder线程的todo队列中（这里会延迟执行BINDER_WORK_TRANSACTION_COMPLETE） binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete); //设置为需要回应 t-&gt;need_reply = 1; //插入事务链表中 t-&gt;from_parent = thread-&gt;transaction_stack; thread-&gt;transaction_stack = t; binder_inner_proc_unlock(proc); //将t-&gt;work插入目标线程的todo队列中并唤醒目标进程 if (!binder_proc_transaction(t, target_proc, target_thread)) &#123; binder_inner_proc_lock(proc); //出错后，移除该事务 binder_pop_transaction_ilocked(thread, t); binder_inner_proc_unlock(proc); goto err_dead_proc_or_thread; &#125; &#125; else &#123; //如果请求码为BC_TRANSACTION并且为异步操作，不需要返回 //将tcomplete插入到事务发起binder线程的todo队列中 binder_enqueue_thread_work(thread, tcomplete); //将t-&gt;work插入目标进程的某个线程（或目标进程）的todo队列中并唤醒目标进程 if (!binder_proc_transaction(t, target_proc, NULL)) goto err_dead_proc_or_thread; &#125; //减临时引用计数 if (target_thread) binder_thread_dec_tmpref(target_thread); binder_proc_dec_tmpref(target_proc); if (target_node) binder_dec_node_tmpref(target_node); return; ... //错误处理&#125; 这一块的代码基本上格式都是一样的，都是将tcomplete插入到事务发起binder线程的todo队列中，t-&gt;work插入到目标binder线程的todo队列中，最后唤醒目标进程 这里需要注意的是，在BC_TRANSACTION的情况下，需要区分事务的flags中是否包含TF_ONE_WAY，这意味着这个事务是否需要回应 在没有TF_ONE_WAY的情况下，会使用binder_enqueue_deferred_thread_work_ilocked函数将tcomplete插入到事务发起binder线程的todo队列中，这个函数区别于binder_enqueue_thread_work_ilocked函数，它没有将thread-&gt;process_todo设为true，这个标记在之前介绍binder_thread结构体的时候提到了，当其为false的情况下会在binder_thread_read中休眠，延迟执行BINDER_WORK_TRANSACTION_COMPLETE，具体是怎么操作的，我们会在后续的binder_thread_read函数中进行分析 在TF_ONE_WAY的情况下，我们是没有去寻找合适的目标处理binder线程的，关于这一点，我们需要看一下binder_proc_transaction函数是怎么处理没有传入binder_thread的情况的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static bool binder_proc_transaction(struct binder_transaction *t, struct binder_proc *proc, struct binder_thread *thread)&#123; struct binder_node *node = t-&gt;buffer-&gt;target_node; struct binder_priority node_prio; bool oneway = !!(t-&gt;flags &amp; TF_ONE_WAY); bool pending_async = false; binder_node_lock(node); node_prio.prio = node-&gt;min_priority; node_prio.sched_policy = node-&gt;sched_policy; //如果设置了TF_ONE_WAY标志 if (oneway) &#123; if (node-&gt;has_async_transaction) &#123; //如果binder实体对象正在处理一个异步事务，做一个标记 pending_async = true; &#125; else &#123; //如果binder实体对象没有正在处理一个异步事务，将has_async_transaction置为true，表示接下来要处理一个异步任务 node-&gt;has_async_transaction = true; &#125; &#125; binder_inner_proc_lock(proc); //如果目标进程死亡或者目标线程不为NULL且死亡 if (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123; binder_inner_proc_unlock(proc); binder_node_unlock(node); return false; &#125; //如果没有传入目标线程，且目标binder实体对象没有正在处理一个异步事务 if (!thread &amp;&amp; !pending_async) //从proc-&gt;waiting_threads链表中取出第一个节点元素（没有的话则为NULL） thread = binder_select_thread_ilocked(proc); if (thread) &#123; //当找到了合适的binder线程 //设置事务优先级 binder_transaction_priority(thread-&gt;task, t, node_prio, node-&gt;inherit_rt); //将t-&gt;work插入到目标binder线程的todo队列中 binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work); &#125; else if (!pending_async) &#123; //没有找到合适的binder线程，且目标binder实体对象没有正在处理一个异步事务 //将t-&gt;work加入到目标binder进程的todo队列中 binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo); &#125; else &#123; //没有找到合适的binder线程，且目标binder实体对象正在处理一个异步事务 //将t-&gt;work加入到目标binder实体的async_todo队列中 binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo); &#125; //目标binder实体对象没有正在处理一个异步事务 if (!pending_async) //唤醒目标binder线程的等待队列 binder_wakeup_thread_ilocked(proc, thread, !oneway /* sync */); binder_inner_proc_unlock(proc); binder_node_unlock(node); return true;&#125; 当没有传入目标binder线程时，从目标进程的等待线程链表中取出第一个binder_thread作为处理线程处理该事务，如果没找到合适的空闲线程，分为两种情况： 目标binder实体对象正在处理一个异步事务：将相应的binder_work插入到目标binder实体的async_todo队列中 目标binder实体对象没有正在处理一个异步事务：将相应的binder_work插入到目标binder进程的todo队列中 关于binder驱动是怎么从这些todo队列取出binder_work并处理的，我们马上在后面binder_thread_read里分析，这里我们最后再看一下如何唤醒目标binder线程的等待队列 123456789101112131415161718192021static void binder_wakeup_thread_ilocked(struct binder_proc *proc, struct binder_thread *thread, bool sync)&#123; assert_spin_locked(&amp;proc-&gt;inner_lock); if (thread) &#123; if (sync) wake_up_interruptible_sync(&amp;thread-&gt;wait); else wake_up_interruptible(&amp;thread-&gt;wait); return; &#125; //没有找到一个可用的等待线程，可能在两种情况下发生： //1. 所有线程都忙于处理事务 //在这种情况下，这些线程中的一个应该很快回调到内核驱动程序并执行这项工作 //2. 线程正在使用epoll轮询，在这种情况下，它们可能在没有被添加到waiting_threads的情况下被阻塞在等待队列上 //对于这种情况，我们只循环获取所有不处理事务工作的线程，并将它们全部唤醒 binder_wakeup_poll_threads_ilocked(proc, sync);&#125; 这个函数也有可能binder_thread参数传入NULL，在这种情况下，我们需要循环获取目标进程下的所有binder线程，对所有不处理事务工作的线程全部执行唤醒操作 1234567891011121314151617static void binder_wakeup_poll_threads_ilocked(struct binder_proc *proc, bool sync)&#123; struct rb_node *n; struct binder_thread *thread; for (n = rb_first(&amp;proc-&gt;threads); n != NULL; n = rb_next(n)) &#123; thread = rb_entry(n, struct binder_thread, rb_node); if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_POLL &amp;&amp; binder_available_for_proc_work_ilocked(thread)) &#123; if (sync) wake_up_interruptible_sync(&amp;thread-&gt;wait); else wake_up_interruptible(&amp;thread-&gt;wait); &#125; &#125;&#125; 总结到这里，我们已经分析了binder_ioctl函数的一半binder_thread_write，了解了一些相关的数据结构，并且补充了binder_mmap篇未完成的内存映射的分析，大家应该对binder请求的发起与调度有了一个初步的认识了 本来这一篇是打算把整个binder_ioctl分析完的，但没想到写到后面内容这么多，只好再分一篇，下一篇我们将分析binder_thread_read，将binder驱动篇完结","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android源码分析 - Binder驱动（上）","slug":"android/aosp/Android源码分析-Binder驱动（上）","date":"2022-02-09T10:29:00.000Z","updated":"2022-11-13T09:55:54.354Z","comments":true,"path":"2022/02/09/android/aosp/Android源码分析-Binder驱动（上）/","link":"","permalink":"http://yoursite.com/2022/02/09/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"开篇本篇以aosp分支android-11.0.0_r25，kernel分支android-msm-wahoo-4.4-android11作为基础解析 上一篇文章Android源码分析 - Binder概述我们大概了解了一下Android选用Binder的原因，以及Binder的基本结构和通信过程。今天，我们便开始从Binder驱动层代码开始分析Binder的机制 提示Binder驱动部分代码不在AOSP项目中，所以我们需要单独clone一份驱动代码 由于我的开发设备是pixel2，查了Linux内核版本号为4.4.223，对应的分支为android-msm-wahoo-4.4-android11，所以今天的分析我们也是基于此分支 我是从清华大学镜像站clone的代码，高通的设备，所以地址为：https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git 初始化binder驱动的源码位于drivers/android目录下，我们从binder.c文件看起 Linux initcall机制在binder.c的最底下，我们可以看到这一行代码 1device_initcall(binder_init); 在Linux内核中，驱动程序通常是用xxx_initcall(fn)启动的，这实际上是一个宏定义，被定义在平台对应的init.h文件中 1234567891011121314151617#define early_initcall(fn) __define_initcall(fn, early)#define pure_initcall(fn) __define_initcall(fn, 0) #define core_initcall(fn) __define_initcall(fn, 1) #define core_initcall_sync(fn) __define_initcall(fn, 1s) #define postcore_initcall(fn) __define_initcall(fn, 2) #define postcore_initcall_sync(fn) __define_initcall(fn, 2s) #define arch_initcall(fn) __define_initcall(fn, 3) #define arch_initcall_sync(fn) __define_initcall(fn, 3s) #define subsys_initcall(fn) __define_initcall(fn, 4)#define subsys_initcall_sync(fn) __define_initcall(fn, 4s) #define fs_initcall(fn) __define_initcall(fn, 5) #define fs_initcall_sync(fn) __define_initcall(fn, 5s) #define rootfs_initcall(fn) __define_initcall(fn, rootfs) #define device_initcall(fn) __define_initcall(fn, 6) #define device_initcall_sync(fn) __define_initcall(fn, 6s) #define late_initcall(fn) __define_initcall(fn, 7) #define late_initcall_sync(fn) __define_initcall(fn, 7s) 可以看到，实际上调用的是__define_initcall()函数，这个函数的第二个参数表示优先级，数字越小，优先级越高，带s的优先级低于不带s的优先级 在Linux内核启动过程中，需要调用各种函数，在底层实现是通过在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可，而__define_initcall()函数，就是将自定义的init函数添加到上述段中 binder_init了解了以上函数定义后，我们再回头看device_initcall(binder_init)就可以知道，在Linux内核启动时，会调用binder_init这么一个函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static int __init binder_init(void)&#123; int ret; char *device_name, *device_names, *device_tmp; struct binder_device *device; struct hlist_node *tmp; //初始化binder内存回收 ret = binder_alloc_shrinker_init(); if (ret) return ret; ... //创建一个单线程工作队列，用于处理异步任务 binder_deferred_workqueue = create_singlethread_workqueue(\"binder\"); if (!binder_deferred_workqueue) return -ENOMEM; //创建binder/proc目录 binder_debugfs_dir_entry_root = debugfs_create_dir(\"binder\", NULL); if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(\"proc\", binder_debugfs_dir_entry_root); //在binder目录下创建5个文件 if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(\"state\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); debugfs_create_file(\"stats\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); debugfs_create_file(\"transactions\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); debugfs_create_file(\"transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); debugfs_create_file(\"failed_transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); &#125; //\"binder,hwbinder,vndbinder\" device_names = kzalloc(strlen(binder_devices_param) + 1, GFP_KERNEL); if (!device_names) &#123; ret = -ENOMEM; goto err_alloc_device_names_failed; &#125; strcpy(device_names, binder_devices_param); device_tmp = device_names; //用binder,hwbinder,vndbinder分别调用init_binder_device函数 while ((device_name = strsep(&amp;device_tmp, \",\"))) &#123; ret = init_binder_device(device_name); if (ret) goto err_init_binder_device_failed; &#125; return ret;err_init_binder_device_failed: ...err_alloc_device_names_failed: ...&#125; 我们将重点放在init_binder_device函数上 init_binder_device123456789101112131415161718192021222324252627282930static int __init init_binder_device(const char *name)&#123; int ret; struct binder_device *binder_device; binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL); if (!binder_device) return -ENOMEM; //binder注册虚拟字符设备所对应的file_operations binder_device-&gt;miscdev.fops = &amp;binder_fops; //动态分配次设备号 binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR; binder_device-&gt;miscdev.name = name; binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID; binder_device-&gt;context.name = name; //初始化互斥锁 mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock); //注册misc设备 ret = misc_register(&amp;binder_device-&gt;miscdev); if (ret &lt; 0) &#123; kfree(binder_device); return ret; &#125; //将binder设备加入链表（头插法） hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices); return ret;&#125; 先构造了一个结构体用来存放binder参数，然后通过misc_register函数，以misc设备进行注册binder，作为虚拟字符设备 注册misc设备我们先学习一下在Linux中如何注册一个misc设备 在Linux驱动中把无法归类的五花八门的设备定义为misc设备，Linux内核所提供的misc设备有很强的包容性，各种无法归结为标准字符设备的类型都可以定义为misc设备，譬如NVRAM，看门狗，实时时钟，字符LCD等 在Linux内核里把所有的misc设备组织在一起，构成了一个子系统(subsys)，统一进行管理。在这个子系统里的所有miscdevice类型的设备共享一个主设备号MISC_MAJOR(10)，但次设备号不同 在内核中用miscdevice结构体表示misc设备，具体的定义在include/linux/miscdevice.h中 1234567891011struct miscdevice &#123; int minor; const char *name; const struct file_operations *fops; struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode;&#125;; 我们自己注册misc设备时只需要填入前3项即可： minor：次设备号，如果填充MISC_DYNAMIC_MINOR，则由内核动态分配次设备号 name：设备名 fops：file_operations结构体，用于定义自己misc设备的文件操作函数，如果不填此项则会使用默认的misc_fops file_operations结构体被定义在include/linux/fs.h中 123456789101112131415161718192021222324252627282930313233struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); unsigned int (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif&#125;; file_operation是把系统调用和驱动程序关联起来的关键结构，这个结构的每一个成员都对应着一个系统调用，Linux系统调用通过读取file_operation中相应的函数指针，接着把控制权转交给函数，从而完成Linux设备驱动程序的工作 最后调用misc_register函数注册misc设备，函数原型如下： 1234//注册misc设备extern int misc_register(struct miscdevice *misc);//卸载misc设备extern void misc_deregister(struct miscdevice *misc); 注册binder设备了解了misc设备的注册，我们就可以看一下binder的注册过程了，代码中先构建了一个binder_device结构体，我们先观察一下这个结构体长什么样子 12345struct binder_device &#123; struct hlist_node hlist; struct miscdevice miscdev; struct binder_context context;&#125;; 其中的hlist_node是链表中的一个节点，miscdevice就是上文所描述的注册misc所必要的结构体参数，binder_context用于保存binder上下文管理者的信息 回到代码中，首先给miscdevice赋了值，指定了file_operation，设置了minor动态分配次设备号，binder_context则是简单初始化了一下，然后便调用misc_register函数注册misc设备，最后将这个binder设备使用头插法加入到一个全局链表中 我们看一下它指定的file_operation 12345678910static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 可以看到，binder驱动支持以上7种系统调用，接下来，我们就逐一分析这些系统调用 binder_proc在分析这些系统调用前，我们有必要先了解一下在binder中非常重要的结构体binder_proc，它是用来描述进程上下文信息以及管理IPC的一个结构体，被定义在drivers/android/binder.c中，是一个私有的结构体 1234567891011121314151617181920212223242526272829303132333435363738struct binder_proc &#123; //hash链表中的一个节点 struct hlist_node proc_node; //处理用户请求的线程组成的红黑树 struct rb_root threads; //binder实体组成的红黑树 struct rb_root nodes; //binder引用组成的红黑树，以句柄来排序 struct rb_root refs_by_desc; //binder引用组成的红黑树，以它对应的binder实体的地址来排序 struct rb_root refs_by_node; struct list_head waiting_threads; //进程id int pid; //进程描述符 struct task_struct *tsk; //进程打开的所有文件数据 struct files_struct *files; struct mutex files_lock; struct hlist_node deferred_work_node; int deferred_work; bool is_dead; //待处理事件队列 struct list_head todo; struct binder_stats stats; struct list_head delivered_death; int max_threads; int requested_threads; int requested_threads_started; atomic_t tmp_ref; struct binder_priority default_priority; struct dentry *debugfs_entry; //用来记录mmap分配的用户虚拟地址空间和内核虚拟地址空间等信息 struct binder_alloc alloc; struct binder_context *context; spinlock_t inner_lock; spinlock_t outer_lock;&#125;; binder_open我们先从打开binder驱动设备开始 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static int binder_open(struct inode *nodp, struct file *filp)&#123; //管理IPC和保存进程信息的结构体 struct binder_proc *proc; struct binder_device *binder_dev; ... proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; //初始化内核同步自旋锁 spin_lock_init(&amp;proc-&gt;inner_lock); spin_lock_init(&amp;proc-&gt;outer_lock); //原子操作赋值 atomic_set(&amp;proc-&gt;tmp_ref, 0); //使执行当前系统调用进程的task_struct.usage加1 get_task_struct(current-&gt;group_leader); //使binder_proc中的tsk指向执行当前系统调用的进程 proc-&gt;tsk = current-&gt;group_leader; //初始化文件锁 mutex_init(&amp;proc-&gt;files_lock); //初始化todo列表 INIT_LIST_HEAD(&amp;proc-&gt;todo); //设置优先级 if (binder_supported_policy(current-&gt;policy)) &#123; proc-&gt;default_priority.sched_policy = current-&gt;policy; proc-&gt;default_priority.prio = current-&gt;normal_prio; &#125; else &#123; proc-&gt;default_priority.sched_policy = SCHED_NORMAL; proc-&gt;default_priority.prio = NICE_TO_PRIO(0); &#125; //找到binder_device结构体的首地址 binder_dev = container_of(filp-&gt;private_data, struct binder_device, miscdev); //使binder_proc的上下文指向binder_device的上下文 proc-&gt;context = &amp;binder_dev-&gt;context; //初始化binder缓冲区 binder_alloc_init(&amp;proc-&gt;alloc); //全局binder_stats结构体中，BINDER_STAT_PROC类型的对象创建数量加1 binder_stats_created(BINDER_STAT_PROC); //设置当前进程id proc-&gt;pid = current-&gt;group_leader-&gt;pid; //初始化已分发的死亡通知列表 INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); //初始化等待线程列表 INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads); //保存binder_proc数据 filp-&gt;private_data = proc; //因为binder支持多线程，所以需要加锁 mutex_lock(&amp;binder_procs_lock); //将binder_proc添加到binder_procs全局链表中 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); //释放锁 mutex_unlock(&amp;binder_procs_lock); //在binder/proc目录下创建文件，以执行当前系统调用的进程id为名 if (binder_debugfs_dir_entry_proc) &#123; char strbuf[11]; snprintf(strbuf, sizeof(strbuf), \"%u\", proc-&gt;pid); proc-&gt;debugfs_entry = debugfs_create_file(strbuf, 0444, binder_debugfs_dir_entry_proc, (void *)(unsigned long)proc-&gt;pid, &amp;binder_proc_fops); &#125; return 0;&#125; binder_open函数创建了binder_proc结构体，并把初始化并将当前进程等信息保存到binder_proc结构体中，然后将binder_proc结构体保存到文件指针filp的private_data中，再将binder_proc加入到全局链表binder_procs中 这里面有一些关于Linux的知识需要解释一下 spinlockspinlock是内核中提供的一种自旋锁机制。在Linux内核实现中，常常会碰到共享数据被中断上下文和进程上下文访问的场景，如果只有进程上下文的话，我们可以使用互斥锁或者信号量解决，将未获得锁的进程置为睡眠状态等待，但由于中断上下文不是一个进程，它不存在task_struct，所以不可被调度，当然也就不可睡眠，这时候就可以通过spinlock自旋锁的忙等待机制来达成睡眠同样的效果 current在Linux内核中，定义了一个叫current的宏，它被定义在asm/current.h中 123456static inline struct task_struct *get_current(void)&#123; return(current_thread_info()-&gt;task);&#125;#define current get_current() 它返回一个task_struct指针，指向执行当前这段内核代码的进程 container_ofcontainer_of也是Linux中定义的一个宏，它的作用是根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针 12345#define offsetof(TYPE, MEMBER) ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)#define container_of(ptr, type, member) (&#123; \\ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) fd&amp;filpfilp-&gt;private_data保存了binder_proc结构体，当进程调用open系统函数时，内核会返回一个文件描述符fd，这个fd指向文件指针filp，在后续调用mmap，ioctl等函数与binder驱动交互时，会传入这个fd，内核就会以这个fd指向文件指针filp作为参数调用binder_mmap，binder_ioctl等函数，这样这些函数就可以通过filp-&gt;private_data取出binder_proc结构体 binder_mmapvm_area_struct在分析mmap前，我们需要先了解一下vm_area_struct这个结构体，它被定义在include/linux/mm_types.h中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct vm_area_struct &#123; //当前vma的首地址 unsigned long vm_start; //当前vma的末地址后第一个字节的地址 unsigned long vm_end; //链表 struct vm_area_struct *vm_next, *vm_prev; //红黑树中对应节点 struct rb_node vm_rb; //当前vma前面还有多少空闲空间 unsigned long rb_subtree_gap; //当前vma所属的内存地址空间 struct mm_struct *vm_mm; //访问权限 pgprot_t vm_page_prot; //vma标识集，定义在 include/linux/mm.h 中 unsigned long vm_flags; union &#123; struct &#123; struct rb_node rb; unsigned long rb_subtree_last; &#125; shared; const char __user *anon_name; &#125;; struct list_head anon_vma_chain; struct anon_vma *anon_vma; //当前vma操作函数集指针 const struct vm_operations_struct *vm_ops; //当前vma起始地址在vm_file中的文件偏移，单位为物理页面PAGE_SIZE unsigned long vm_pgoff; //被映射的文件（如果使用文件映射） struct file * vm_file; void * vm_private_data;#ifndef CONFIG_MMU struct vm_region *vm_region; /* NOMMU mapping region */#endif#ifdef CONFIG_NUMA struct mempolicy *vm_policy; /* NUMA policy for the VMA */#endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx;&#125;; vm_area_struct结构体描述了一段虚拟内存空间，通常，进程所使用到的虚拟内存空间不连续，且各部分虚存空间的访问属性也可能不同，所以一个进程的虚拟内存空间需要多个vm_area_struct结构来描述（后面简称vma） 每个进程都有一个对应的task_struct结构描述，这个task_struct结构中有一个mm_struct结构用于描述进程的内存空间，mm_struct结构中有两个域成员变量分别指向了vma链表头和红黑树根 vma所描述的虚拟内存空间范围由vm_start和vm_end表示，vm_start代表当前vma的首地址，vm_end代表当前vma的末地址后第一个字节的地址，即虚拟内存空间范围为[vm_start, vm_end) vm_operations_struct和上文中的file_operations类似，用来定义虚拟内存的操作函数 介绍完vma，接下来我们便看一下binder_mmap函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; //校验进程信息 if (proc-&gt;tsk != current-&gt;group_leader) return -EINVAL; //将虚拟内存地址大小限制在4M if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; ... //检查用户空间是否可写（FORBIDDEN_MMAP_FLAGS == VM_WRITE） if (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; //VM_DONTCOPY表示此vma不可被fork所复制 vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP; //用户空间不可设置该vma的VM_WRITE标志 vma-&gt;vm_flags &amp;= ~VM_MAYWRITE; //设置此vma操作函数集 vma-&gt;vm_ops = &amp;binder_vm_ops; //指向binder_proc vma-&gt;vm_private_data = proc; //处理进程虚拟内存空间与内核虚拟地址空间的映射关系 ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma); if (ret) return ret; mutex_lock(&amp;proc-&gt;files_lock); //获取进程的打开文件信息结构体files_struct，并将引用计数加1 proc-&gt;files = get_files_struct(current); mutex_unlock(&amp;proc-&gt;files_lock); return 0;err_bad_arg: pr_err(\"%s: %d %lx-%lx %s failed %d\\n\", __func__, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret); return ret;&#125; 首先从filp中获取对应的binder_proc信息 将它的进程task_struct和执行当前这段内核代码的进程task_struct对比校验 限制了用户空间虚拟内存的大小在4M以内 检查用户空间是否可写（binder驱动为进程分配的缓冲区在用户空间中只可以读，不可以写） 设置vm_flags，令vma不可写，不可复制 设置vma的操作函数集 将vm_area_struct中的成员变量vm_private_data指向binder_proc，使得vma设置的操作函数中可以拿到binder_proc 处理进程虚拟内存空间与内核虚拟地址空间的映射关系 获取进程的打开文件信息结构体files_struct，令binder_proc的files指向它，并将引用计数加1 binder_alloc_mmap_handlerbinder_alloc_mmap_handler将进程虚拟内存空间与内核虚拟地址空间做映射，它被实现在drivers/android/binder_alloc.c中 这里先介绍一下vm_struct，之前我们已经了解了vm_area_struct表示用户进程中的虚拟地址空间，而相对应的，vm_struct则表示内核中的虚拟地址空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int binder_alloc_mmap_handler(struct binder_alloc *alloc, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; const char *failure_string; struct binder_buffer *buffer; mutex_lock(&amp;binder_alloc_mmap_lock); //检查是否已经分配过内核缓冲区 if (alloc-&gt;buffer) &#123; ret = -EBUSY; failure_string = \"already mapped\"; goto err_already_mapped; &#125; //获得一个内核虚拟空间 area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; //alloc-&gt;buffer指向内核虚拟内存空间地址 alloc-&gt;buffer = area-&gt;addr; //计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量 alloc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)alloc-&gt;buffer; mutex_unlock(&amp;binder_alloc_mmap_lock); ... //申请内存 alloc-&gt;pages = kzalloc(sizeof(alloc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (alloc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; //buffer大小等于vma大小 alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; buffer = kzalloc(sizeof(*buffer), GFP_KERNEL); if (!buffer) &#123; ret = -ENOMEM; failure_string = \"alloc buffer struct\"; goto err_alloc_buf_struct_failed; &#125; //指向内核虚拟空间地址 buffer-&gt;data = alloc-&gt;buffer; //将buffer添加到链表中 list_add(&amp;buffer-&gt;entry, &amp;alloc-&gt;buffers); buffer-&gt;free = 1; //将此内核缓冲区加入到binder_alloc的空闲缓冲红黑树中 binder_insert_free_buffer(alloc, buffer); //设置进程最大可用异步事务缓冲区大小（防止异步事务消耗过多内核缓冲区，影响同步事务） alloc-&gt;free_async_space = alloc-&gt;buffer_size / 2; //内存屏障，保证指令顺序执行 barrier(); //设置binder_alloc alloc-&gt;vma = vma; alloc-&gt;vma_vm_mm = vma-&gt;vm_mm; //引用计数+1 atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count); return 0; ... //错误处理&#125; 检查是否已经分配过内核缓冲区 从内核中寻找一块可用的虚拟内存地址 将此内核虚拟内存空间地址保存至binder_alloc 计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量（这样就可以非常方便的在用户虚拟内存空间与内核虚拟内存空间间切换） 为alloc-&gt;pages数组申请内存，申请的大小等于vma能分配多少个页框 设置buffer大小等于vma大小 为binder_buffer申请内存，填充参数，使其指向内核虚拟空间地址，并将其添加到链表和红黑树中 设置binder_alloc其他参数 这里要注意，虽然我们计算出了用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量，但并没有建立映射关系。在旧版内核中，这里会调用binder_update_page_range函数分别将内核虚拟内存和进程虚拟内存与物理内存做映射，这样内核虚拟内存和进程虚拟内存也相当于间接建立了映射关系，而在4.4.223中，这件事将会延迟到binder_ioctl后 当完成物理内存的映射后，以32位系统，缓冲区大小4M为例，效果应该如下图所示： 总结到这里，我们已经了解了binder驱动设备是如何注册的，并且分析了binder_open和binder_mmap操作函数，了解了一些重要的结构体，明白了mmap是如何映射用户空间和内核空间的，由于篇幅原因，下一章我们会分析binder驱动中最重要的部分binder_ioctl 参考文献 linux中的misc设备 内存映射与VMA Android 重学系列 Binder驱动的初始化 映射原理(二) Binder系列1—Binder Driver初探 Linux 4.16 Binder驱动学习笔记——–接口简析","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android源码分析 - Binder概述","slug":"android/aosp/Android源码分析-Binder概述","date":"2022-02-01T05:03:00.000Z","updated":"2022-11-13T09:55:54.353Z","comments":true,"path":"2022/02/01/android/aosp/Android源码分析-Binder概述/","link":"","permalink":"http://yoursite.com/2022/02/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E6%A6%82%E8%BF%B0/","excerpt":"","text":"开篇本篇无源码分析，只对Binder做通信过程和基础架构的介绍 Binder是Android中最重要的一种进程间通信机制，基于开源的OpenBinder George Hoffman当时任Be公司的工程师，他启动了一个名为OpenBinder的项目，在Be公司被ParmSource公司收购后，OpenBinder由Dinnie Hackborn继续开发，后来成为管理ParmOS6 Cobalt OS的进程的基础。在Hackborn加入谷歌后，他在OpenBinder的基础上开发出了Android Binder(以下简称Binder)，用来完成Android的进程通信。 为什么需要学习Binder作为一名Android开发，我们每天都在和Binder打交道，虽然可能有的时候不会注意到，譬如： startActivity的时候，会获取AMS服务，调用AMS服务的startActivity方法 startActivity传递的对象为什么需要序列化 bindService为什么回调的是一个Ibinder对象 多进程应用，各个进程之间如何通信 AIDL的使用 … 它们都和Binder有着莫切关系，当碰到上面的场景，或者一些疑难问题的时候，理解Binder机制是非常有必要的 为什么Android选择Binder这就要从进程间通信开始说起了，我们先看看比较常见的几种进程间通信方式 常见进程间通信共享内存共享内存是进程间通信中最简单的方式之一，共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改，它的原理如下图所示： 因为共享内存是访问同一块内存，所以数据不需要进行任何复制，是IPC几种方式中最快，性能最好的方式。但相对应的，共享内存未提供同步机制，需要我们手动控制内存间的互斥操作，较容易发生问题。同时共享内存由于能任意的访问和修改内存中的数据，如果有恶意程序去针对某个程序设计代码，很可能导致隐私泄漏或者程序崩溃，所以安全性较差。 管道管道分为命名管道和无名管道，它是以一种特殊的文件作为中间介质，我们称为管道文件，它具有固定的读端和写端，写进程通过写段向管道文件里写入数据，读进程通过读段从读进程中读出数据，构成一条数据传递的流水线，它的原理如下图所示： 管道一次通信需要经历2次数据复制（进程A -&gt; 管道文件，管道文件 -&gt; 进程B）。管道的读写分阻塞和非阻塞，管道创建会分配一个缓冲区，而这个缓冲区是有限的，如果传输的数据大小超过缓冲区上限，或者在阻塞模式下没有安排好数据的读写，会出现阻塞的情况。管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式。 消息队列消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列允许多个进程同时读写消息，发送方与接收方要约定好，消息体的数据类型与大小。消息队列克服了信号承载信息量少、管道只能承载无格式字节流等缺点，消息队列一次通信同样需要经历2次数据复制（进程A -&gt; 消息队列，消息队列 -&gt; 进程B），它的原理如下图所示： SocketSocket原本是为了网络设计的，但也可以通过本地回环地址 (127.0.0.1) 进行进程间通信，后来在Socket的框架上更是发展出一种IPC机制，名叫UNIX Domain Socket。Socket是一种典型的C/S架构，一个Socket会拥有两个缓冲区，一读一写，由于发送/接收消息需要将一个Socket缓冲区中的内容拷贝至另一个Socket缓冲区，所以Socket一次通信也是需要经历2次数据复制，它的原理如下图所示： Binder了解了常见进程间通信的方式，我们再来看一下Binder的原理 Binder是基于内存映射mmap设计实现的，我们需要先了解一下mmap的概念 mmapmmap是一种内存映射的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 Linux内核不会主动将mmap修改后的内容同步到磁盘文件中，有4个时机会触发mmap映射同步到磁盘： 调用 msync 函数主动进行数据同步（主动） 调用 munmap 函数对文件进行解除映射关系时（主动） 进程退出时（被动） 系统关机时（被动） 通过这种方式，直接操作映射的这一部分内存，可以避免一些数据复制，从而获得更好的性能 原理一次Binder IPC通信的过程分为以下几个步骤： 首先，Binder驱动在内核空间中开辟出一个数据接收缓冲区 接着，在内核空间中开辟出一个内核缓冲区 将内核缓冲区与数据接收缓冲区建立映射关系 将数据接收缓冲区与接收进程的用户空间地址建立映射关系 发送方进程通过copy_from_user将数据从用户空间复制到内核缓冲区 由于内核缓冲区与数据接收缓冲区有映射关系，同时数据接收缓冲区与接收进程的用户空间地址有映射关系，所以在接收进程中可以直接获取到这段数据 这样便完成了一次Binder IPC通信，它的原理如下图所示： 可以看到，通过mmap，Binder通信时，只需要经历一次数据复制，性能要优于管道/消息队列/socket等方式，在安全性，易用性方面又优于共享内存。鉴于上述原因，Android选择了这种折中的IPC方式，来满足系统对稳定性、传输性能和安全性方面的要求 Binder架构Binder也是一种C/S架构，分为BpBinder（客户端）和BBinder（服务端），他们都派生自IBinder。其中BpBinder中的p表示proxy，即代理。BpBinder通过transact来发送事务请求，BBinder通过onTransact来接收相应的事务 Binder一次通信的时序图如下： Binder采用分层架构设计 总结至此，我们大概了解了一下Android选用Binder的原因，以及Binder的基本结构和通信过程，为之后深入源码层分析Binder做了准备 参考文献 写给 Android 应用工程师的 Binder 原理剖析 Binder系列—开篇 Android Binder原理图解 Binder和AIDL实例及原理解析","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"Android源码分析 - SystemServer（下）","slug":"android/aosp/Android源码分析-SystemServer（下）","date":"2022-01-29T08:36:00.000Z","updated":"2022-11-13T09:55:54.356Z","comments":true,"path":"2022/01/29/android/aosp/Android源码分析-SystemServer（下）/","link":"","permalink":"http://yoursite.com/2022/01/29/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8B%EF%BC%89/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 上一篇文章Android源码分析 - SystemServer（上）我们分析了SystemServer进程是怎么被启动起来的，今天这篇，我们来分析SystemServer进程启动后做了什么 main我们上一章中讲到，Zygote进程fork出子进程后，最终调用了SystemServer.main方法，SystemServer源代码在frameworks/base/services/java/com/android/server/SystemServer.java中，我们来看看做了什么 123public static void main(String[] args) &#123; new SystemServer().run();&#125; 构造方法非常简单，就是先new了一个SystemServer对象，然后调用它的run方法，我们先看一下构造方法 123456789public SystemServer() &#123; //工厂模式 mFactoryTestMode = FactoryTest.getMode(); ... //记录启动信息 //记录是否经历过重启 mRuntimeRestart = \"1\".equals(SystemProperties.get(\"sys.boot_completed\"));&#125; 工厂模式首先，先从系统属性中获取工厂模式级别，有三种属性： FACTORY_TEST_OFF：正常模式 FACTORY_TEST_LOW_LEVEL：低级别工厂模式，在此模式下，很多Service不会启动 FACTORY_TEST_HIGH_LEVEL：高级别工厂模式，此模式与正常模式基本相同，略有区别 它们被定义在frameworks/base/core/java/android/os/FactoryTest.java中 run紧接着便开始执行run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private void run() &#123; ... //记录启动信息 //如果没有设置时区，将时区设置为GMT String timezoneProperty = SystemProperties.get(\"persist.sys.timezone\"); if (timezoneProperty == null || timezoneProperty.isEmpty()) &#123; Slog.w(TAG, \"Timezone not set; setting to GMT.\"); SystemProperties.set(\"persist.sys.timezone\", \"GMT\"); &#125; //设置区域与语言 if (!SystemProperties.get(\"persist.sys.language\").isEmpty()) &#123; final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(\"persist.sys.locale\", languageTag); SystemProperties.set(\"persist.sys.language\", \"\"); SystemProperties.set(\"persist.sys.country\", \"\"); SystemProperties.set(\"persist.sys.localevar\", \"\"); &#125; //Binder事务发生阻塞时发出警告 Binder.setWarnOnBlocking(true); //PackageManager相关 PackageItemInfo.forceSafeLabels(); ... //设置虚拟机库文件libart.so SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); //清除虚拟机内存增长上限，以获得更多内存 VMRuntime.getRuntime().clearGrowthLimit(); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); //设置在访问环境变量前，需要明确指定用户 Environment.setUserRequired(true); //设置标记，当发生BadParcelableException异常时保守处理，不要抛出异常 BaseBundle.setShouldDefuse(true); //设置异常跟踪 Parcel.setStackTraceParceling(true); //确保Binder调用优先级总为前台优先级 BinderInternal.disableBackgroundScheduling(true); //设置Binder线程池最大数量 BinderInternal.setMaxThreads(sMaxBinderThreads); //设置进程优先级为前台进程 // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); //以当前线程作为MainLooper准备 Looper.prepareMainLooper(); Looper.getMainLooper().setSlowLogThresholdMs( SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS); SystemServiceRegistry.sEnableServiceNotFoundWtf = true; //加载android_servers.so库 System.loadLibrary(\"android_servers\"); //标记该进程的堆可分析 initZygoteChildHeapProfiling(); //Debug选项 - 开启一个线程用来监测FD泄漏 if (Build.IS_DEBUGGABLE) &#123; spawnFdLeakCheckThread(); &#125; //检查上次关机过程中是否失败 performPendingShutdown(); //初始化System Context createSystemContext(); //创建并设置一些每个进程启动时都需要的一些模块 (TelephonyServiceManager, StatsServiceManager) ActivityThread.initializeMainlineModules(); //创建SystemServiceManager（管理所有的系统Service） mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); //将SystemServiceManager作为本地进程Service使用 LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); //为初始化任务准备线程池 SystemServerInitThreadPool.start(); ... //设置默认异常处理程序 RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf); ... //启动引导服务 startBootstrapServices(t); //启动核心服务 startCoreServices(t); //启动其他服务 startOtherServices(t); ... //严格模式初始化虚拟机策略 StrictMode.initVmDefaults(null); ... //进入Looper死循环，等待Handler事件 Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 可以看到，run方法主要做了以下工作 检查并设置各种参数handler 创建SystemContext 创建SystemServiceManager 启动服务 Looper循环 其中，创建SystemContext这一步是由ContextImpl完成的，等后面分析到的时候在详细去看，Looper也是，我们将重点放在启动服务上 启动服务启动服务分为三步，首先是启动引导服务，其次是启动核心服务，最后是启动其他服务，我们先从引导服务开始 由于启动的服务太多了，我们只介绍一些我们比较熟悉的服务 startBootstrapServices1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private void startBootstrapServices(@NonNull TimingsTraceAndSlog t) &#123; ... //看门狗 final Watchdog watchdog = Watchdog.getInstance(); watchdog.start(); ... final String TAG_SYSTEM_CONFIG = \"ReadingSystemConfig\"; //读取系统配置 SystemServerInitThreadPool.submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG); ... //Installer服务（实际上是与installd跨进程通信） Installer installer = mSystemServiceManager.startService(Installer.class); ... //创建 ATMS &amp; AMS ActivityTaskManagerService atm = mSystemServiceManager.startService( ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); mWindowManagerGlobalLock = atm.getGlobalLock(); ... //电源管理服务，后面有其他服务依赖它，所以需要较早启动 mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); ... mActivityManagerService.initPowerManagement(); ... //灯光服务 mSystemServiceManager.startService(LightsService.class); ... //显示管理服务 mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); ... //阶段100 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); ... //创建PMS try &#123; Watchdog.getInstance().pauseWatchingCurrentThread(\"packagemanagermain\"); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); &#125; finally &#123; Watchdog.getInstance().resumeWatchingCurrentThread(\"packagemanagermain\"); &#125; //捕获dex load行为 SystemServerDexLoadReporter.configureSystemServerDexReporter(mPackageManagerService); //是否首次启动 mFirstBoot = mPackageManagerService.isFirstBoot(); //获取PMS mPackageManager = mSystemContext.getPackageManager(); ... //用户管理服务 mSystemServiceManager.startService(UserManagerService.LifeCycle.class); ... //初始化属性缓存 AttributeCache.init(mSystemContext); ... //注册各种系统服务 mActivityManagerService.setSystemProcess(); ... //使用AMS完成看门狗的设置，并监听重新启动 watchdog.init(mSystemContext, mActivityManagerService); ... //设置调度策略 mDisplayManagerService.setupSchedulerPolicies(); ... //在单独线程中启动传感器服务 mSensorServiceStart = SystemServerInitThreadPool.submit(() -&gt; &#123; TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog(); traceLog.traceBegin(START_SENSOR_SERVICE); startSensorService(); traceLog.traceEnd(); &#125;, START_SENSOR_SERVICE); ...&#125; startCoreServices1234567891011private void startCoreServices(@NonNull TimingsTraceAndSlog t) &#123; ... //电池电量服务，依赖LightsService mSystemServiceManager.startService(BatteryService.class); ... //应用统计服务 mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); ...&#125; startOtherServices123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123; ... //AccountManagerService - 账户管理 mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS); ... //ContentService - 内容服务 mSystemServiceManager.startService(CONTENT_SERVICE_CLASS); ... //加载SettingProvider mActivityManagerService.installSystemProviders(); ... //DropBox日志服务 mSystemServiceManager.startService(DropBoxManagerService.class); ... //震动服务 vibrator = new VibratorService(context); ServiceManager.addService(\"vibrator\", vibrator); ... //时钟/闹钟服务 mSystemServiceManager.startService(new AlarmManagerService(context)); //输入服务 inputManager = new InputManagerService(context); ... //等待传感器服务准备完毕 ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE); mSensorServiceStart = null; //启动WindowManagerService wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); ... mActivityManagerService.setWindowManager(wm); ... wm.onInitReady(); ... //HIDL services SystemServerInitThreadPool.submit(() -&gt; &#123; startHidlServices(); &#125;, START_HIDL_SERVICES); ... //关联WMS，启动输入服务 inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback()); inputManager.start(); ... mDisplayManagerService.windowManagerAndInputReady(); ... //有蓝牙功能且非低级工厂模式，启动蓝牙服务 if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; ... &#125; else if (!context.getPackageManager().hasSystemFeature (PackageManager.FEATURE_BLUETOOTH)) &#123; ... &#125; else &#123; mSystemServiceManager.startService(BluetoothService.class); &#125; ... //输入法/无障碍服务 if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; if (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) &#123; mSystemServiceManager.startService( MultiClientInputMethodManagerService.Lifecycle.class); &#125; else &#123; mSystemServiceManager.startService(InputMethodManagerService.Lifecycle.class); &#125; mSystemServiceManager.startService(ACCESSIBILITY_MANAGER_SERVICE_CLASS); &#125; wm.displayReady(); //存储相关服务 if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; if (!\"0\".equals(SystemProperties.get(\"system_init.startmountservice\"))) &#123; mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS); storageManager = IStorageManager.Stub.asInterface( ServiceManager.getService(\"mount\")); mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS); &#125; &#125; //UIMode服务（夜间模式，驾驶模式等） mSystemServiceManager.startService(UiModeManagerService.class); ... //执行磁盘清理工作，释放磁盘空间 mPackageManagerService.performFstrimIfNeeded(); if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; ... final boolean hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(\"\"); ... if (hasPdb || OemLockService.isHalPresent()) &#123; //OEM锁服务 mSystemServiceManager.startService(OemLockService.class); &#125; ... if (!isWatch) &#123; //状态栏管理服务 statusBar = new StatusBarManagerService(context); ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar); &#125; //网络相关服务 ConnectivityModuleConnector.getInstance().init(context); NetworkStackClient.getInstance().init(); networkManagement = NetworkManagementService.create(context); ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement); ipSecService = IpSecService.create(context, networkManagement); ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService); //文本服务 mSystemServiceManager.startService(TextServicesManagerService.Lifecycle.class); mSystemServiceManager .startService(TextClassificationManagerService.Lifecycle.class); //网络相关服务 mSystemServiceManager.startService(NetworkScoreService.Lifecycle.class); networkStats = NetworkStatsService.create(context, networkManagement); ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats); networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, networkManagement); ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy); if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); mSystemServiceManager.startServiceFromJar( WIFI_SCANNING_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_RTT)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_RTT_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_AWARE)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_AWARE_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_WIFI_DIRECT)) &#123; mSystemServiceManager.startServiceFromJar( WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH); &#125; if (context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_LOWPAN)) &#123; mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS); &#125; if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123; mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS); &#125; connectivity = new ConnectivityService( context, networkManagement, networkStats, networkPolicy); ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL); networkPolicy.bindConnectivityManager(connectivity); ... //系统更新服务 ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE, new SystemUpdateManagerService(context)); ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context)); //通知服务 mSystemServiceManager.startService(NotificationManagerService.class); SystemNotificationChannels.removeDeprecated(context); SystemNotificationChannels.createAll(context); notification = INotificationManager.Stub.asInterface( ServiceManager.getService(Context.NOTIFICATION_SERVICE)); ... //位置服务 mSystemServiceManager.startService(LocationManagerService.Lifecycle.class); ... //墙纸服务 if (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) &#123; mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS); &#125; else &#123; ... &#125; //音频服务 if (!isArc) &#123; mSystemServiceManager.startService(AudioService.Lifecycle.class); &#125; else &#123; String className = context.getResources() .getString(R.string.config_deviceSpecificAudioService); mSystemServiceManager.startService(className + \"$Lifecycle\"); &#125; ... //ADB服务 mSystemServiceManager.startService(ADB_SERVICE_CLASS); //USB服务 if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature( PackageManager.FEATURE_USB_ACCESSORY) || isEmulator) &#123; mSystemServiceManager.startService(USB_SERVICE_CLASS); &#125; //微件（小组件）服务 if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS) || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) &#123; mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS); &#125; ... //Android10新增，用于报告来自运行时模块的信息 ServiceManager.addService(\"runtime\", new RuntimeService(context)); ... //App后台Dex优化 BackgroundDexOptService.schedule(context); ... &#125; ... //相机服务 if (!disableCameraService) &#123; mSystemServiceManager.startService(CameraServiceProxy.class); &#125; //进入安全模式 if (safeMode) &#123; mActivityManagerService.enterSafeMode(); &#125; //短信服务 mmsService = mSystemServiceManager.startService(MmsServiceBroker.class); ... //剪贴板服务 mSystemServiceManager.startService(ClipboardService.class); ... //调用各大服务的systemReady方法 vibrator.systemReady(); lockSettings.systemReady(); //阶段480 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_LOCK_SETTINGS_READY); //阶段500 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_SYSTEM_SERVICES_READY); wm.systemReady(); ... //手动更新Context Configuration final Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY); DisplayMetrics metrics = new DisplayMetrics(); context.getDisplay().getMetrics(metrics); context.getResources().updateConfiguration(config, metrics); final Theme systemTheme = context.getTheme(); if (systemTheme.getChangingConfigurations() != 0) &#123; systemTheme.rebase(); &#125; mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService()); ... mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(safeMode, mOnlyCore); mSystemServiceManager.setSafeMode(safeMode); //阶段520 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY); ... //最后运行AMS.systemReady mActivityManagerService.systemReady(() -&gt; &#123; //阶段550 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //阶段600 mSystemServiceManager.startBootPhase(t, SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); ... &#125;, t);&#125; 服务的启动是分阶段完成的，从0-100-480-500-520-550-600-1000，最后的阶段1000，是在AMS调用finishBooting方法后进入 可以看到，启动的服务非常之多，不可能全看得完，其中最重要的几个：ActivityManagerService、WindowManagerService、PackageManagerService和InputManagerService，后面我们会慢慢看过去，在此之前，我们还是先看看服务启动的方式 SystemServiceManager绝大部分的服务是通过SystemServiceManager启动的，它的源码路径为frameworks/base/services/core/java/com/android/server/SystemServiceManager.java startService我们来看看这个类里的启动服务方法 这个类中有三个方法用于启动Serivce，分别是： public SystemService startService(String className) public SystemService startServiceFromJar(String className, String path) public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) public void startService(@NonNull final SystemService service) 实际上最后都是调用了最后一个方法 先看参数为String的startService方法 12345public SystemService startService(String className) &#123; final Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, this.getClass().getClassLoader()); return startService(serviceClass);&#125; 12345678private static Class&lt;SystemService&gt; loadClassFromLoader(String className, ClassLoader classLoader) &#123; try &#123; return (Class&lt;SystemService&gt;) Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; ... &#125;&#125; 实际上就是通过反射拿到类名对应的Class，再调用Class为参的startService方法 startServiceFromJar实际上也是一样，只不过是先通过PathClassLoader加载了jar而已 1234567891011public SystemService startServiceFromJar(String className, String path) &#123; PathClassLoader pathClassLoader = mLoadedPaths.get(path); if (pathClassLoader == null) &#123; // NB: the parent class loader should always be the system server class loader. // Changing it has implications that require discussion with the mainline team. pathClassLoader = new PathClassLoader(path, this.getClass().getClassLoader()); mLoadedPaths.put(path, pathClassLoader); &#125; final Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, pathClassLoader); return startService(serviceClass);&#125; 接着我们看看Class为参数的startService方法 12345678910111213141516171819public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) &#123; final String name = serviceClass.getName(); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) &#123; throw new RuntimeException(\"Failed to create \" + name + \": service must extend \" + SystemService.class.getName()); &#125; final T service; try &#123; Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); &#125; catch (...) &#123; ... &#125; startService(service); return service;&#125; 看函数泛型我们就可以知道，这个方法只接受SystemService的子类，并且在方法的开头，还使用了isAssignableFrom方法做了类型校验，避免通过String反射获取的Class非SystemService的子类 之后的逻辑也很简单，反射实例化对象，然后调用另一个以SystemService对象为参数的重载方法 123456789public void startService(@NonNull final SystemService service) &#123; mServices.add(service); try &#123; service.onStart(); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(\"Failed to start service \" + service.getClass().getName() + \": onStart threw an exception\", ex); &#125;&#125; 这个方法会将SystemService对象加入一个List中，然后调用它的onStart方法，通知SystemService自行处理启动 startBootPhase因为各种服务之间是存在依赖关系的，所以Android将服务的启动划分了8个阶段：0-100-480-500-520-550-600-1000，而startBootPhase方法便是用来通知各个服务进行到哪一阶段了 12345678910111213141516public void startBootPhase(@NonNull TimingsTraceAndSlog t, int phase) &#123; if (phase &lt;= mCurrentPhase) &#123; throw new IllegalArgumentException(\"Next phase must be larger than previous\"); &#125; mCurrentPhase = phase; final int serviceLen = mServices.size(); for (int i = 0; i &lt; serviceLen; i++) &#123; final SystemService service = mServices.get(i); service.onBootPhase(mCurrentPhase); &#125; if (phase == SystemService.PHASE_BOOT_COMPLETED) &#123; SystemServerInitThreadPool.shutdown(); &#125;&#125; 每进入到一个阶段，便会调用Service List中所有SystemService的onBootPhase方法，通知SystemService阶段变换，而当阶段达到1000 (PHASE_BOOT_COMPLETED) 时，就代表着所有的服务都已准备完毕，关闭SystemServerInitThreadPool线程池 ServiceManager当服务被创建出来后，会调用ServiceManager.addService方法添加服务，以供其他地方使用这些服务 addService有三个重载，最终调用的为： 12345678public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) &#123; try &#123; getIServiceManager().addService(name, service, allowIsolated, dumpPriority); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in addService\", e); &#125;&#125; 12345678910private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager;&#125; 12345678public static IServiceManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; // ServiceManager is never local return new ServiceManagerProxy(obj);&#125; 12345678910111213141516171819class ServiceManagerProxy implements IServiceManager &#123; public ServiceManagerProxy(IBinder remote) &#123; mRemote = remote; mServiceManager = IServiceManager.Stub.asInterface(remote); &#125; public IBinder asBinder() &#123; return mRemote; &#125; ... public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException &#123; mServiceManager.addService(name, service, allowIsolated, dumpPriority); &#125; ... private IBinder mRemote; private IServiceManager mServiceManager;&#125; 从这里就能看出来ServiceManager实际上是一个单独的进程，名为servicemanager，它负责管理所有服务，使用了Binder IPC机制，我们调用addService方法实际上是调用了Binder Proxy的方法，他向/dev/binder中写入消息，在servicemanager进程中接收到了这个消息并处理这个请求 关于Binder机制，我们随后便会分析它 最终调用了frameworks/native/cmds/servicemanager/ServiceManager.cpp中的addService函数 12345678910111213141516171819202122Status ServiceManager::addService(const std::string&amp; name, const sp&lt;IBinder&gt;&amp; binder, bool allowIsolated, int32_t dumpPriority) &#123; auto ctx = mAccess-&gt;getCallingContext(); ... //添加服务 auto entry = mNameToService.emplace(name, Service &#123; .binder = binder, .allowIsolated = allowIsolated, .dumpPriority = dumpPriority, .debugPid = ctx.debugPid, &#125;); auto it = mNameToRegistrationCallback.find(name); if (it != mNameToRegistrationCallback.end()) &#123; for (const sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123; entry.first-&gt;second.guaranteeClient = true; // permission checked in registerForNotifications cb-&gt;onRegistration(name, binder); &#125; &#125; return Status::ok();&#125; 可以看到，最终通过service name和传过来的binder对象构造出一个Service结构体，并将其保存至mNameToService这个Map中，以供后面使用 关于进程SystemServer启动的服务大多都运行在systemserver进程中，但也有一些例外 譬如Installer服务，便是从init进程单独fork出了一个installd进程 下面是它的rc文件，frameworks/native/cmds/installd/installd.rc 123service installd &#x2F;system&#x2F;bin&#x2F;installdclass main... 而在SystemServer进程中start的Installer，便是通过binder连接到installd进程提供服务 源码路径frameworks/base/services/core/java/com/android/server/pm/Installer.java 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onStart() &#123; if (mIsolated) &#123; mInstalld = null; &#125; else &#123; connect(); &#125;&#125;private void connect() &#123; IBinder binder = ServiceManager.getService(\"installd\"); if (binder != null) &#123; try &#123; binder.linkToDeath(new DeathRecipient() &#123; @Override public void binderDied() &#123; Slog.w(TAG, \"installd died; reconnecting\"); connect(); &#125; &#125;, 0); &#125; catch (RemoteException e) &#123; binder = null; &#125; &#125; if (binder != null) &#123; mInstalld = IInstalld.Stub.asInterface(binder); try &#123; invalidateMounts(); &#125; catch (InstallerException ignored) &#123; &#125; &#125; else &#123; Slog.w(TAG, \"installd not found; trying again\"); BackgroundThread.getHandler().postDelayed(() -&gt; &#123; connect(); &#125;, DateUtils.SECOND_IN_MILLIS); &#125;&#125; 结束SystemServer启动了非常多的服务，并将这些服务添加到了ServiceManager中，我们又从中引申出了Binder机制，我们下一章便开始分析Binder","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"}]},{"title":"Android源码分析 - SystemServer（上）","slug":"android/aosp/Android源码分析-SystemServer（上）","date":"2022-01-17T12:42:00.000Z","updated":"2022-11-13T09:55:54.355Z","comments":true,"path":"2022/01/17/android/aosp/Android源码分析-SystemServer（上）/","link":"","permalink":"http://yoursite.com/2022/01/17/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 上一篇文章Android源码分析 - Zygote进程，我们分析了Android Zygote进程的启动和之后是如何接收消息创建App进程的 在上一章中，我们说了，Zygote的一大作用就是启动SystemServer，那么SystemServer是怎么启动的呢？启动后又做了些什么呢？我们分上下两篇来分析，本篇介绍SystemServer是如何启动的 介绍SystemServer主要是用来创建系统服务的，譬如我们熟知的ActivityManagerService，PackageManagerService都是由它创建的 启动SystemServer我们从上一篇文章的ZygoteInit开始，ZygoteInit类的源码路径为frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 123456789101112131415161718192021222324public static void main(String argv[]) &#123; ... boolean startSystemServer = false; ... for (int i = 1; i &lt; argv.length; i++) &#123; //参数中有start-system-server if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; ... &#125; ... //启动SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); //子进程中才会满足r != null if (r != null) &#123; //此时执行这个Runnable r.run(); return; &#125; &#125;&#125; 之前在c++代码中JNI调用Java函数的时候，带了参数start-system-server，在这里就会通过这个参数判断是否启动SystemServer，接下来调用forkSystemServer方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; //设置Linux capabilities long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_IPC_LOCK, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_PTRACE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG, OsConstants.CAP_WAKE_ALARM, OsConstants.CAP_BLOCK_SUSPEND ); //移除一些当前线程都不可用的特权 StructCapUserHeader header = new StructCapUserHeader( OsConstants._LINUX_CAPABILITY_VERSION_3, 0); StructCapUserData[] data; try &#123; data = Os.capget(header); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to capget()\", ex); &#125; //data[0].effective为当前线程所可用的特权，data[1].effective貌似为0 capabilities &amp;= ((long) data[0].effective) | (((long) data[1].effective) &lt;&lt; 32); //设置fork参数 String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,\" + \"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"--target-sdk-version=\" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, \"com.android.server.SystemServer\", &#125;; ZygoteArguments parsedArgs = null; int pid; try &#123; //解析设置的参数 parsedArgs = new ZygoteArguments(args); ... //进一步设置参数 pid = Zygote.forkSystemServer( parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, null, parsedArgs.mPermittedCapabilities, parsedArgs.mEffectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //SystemServer子进程 if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //关闭zygote server socket zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null;&#125; Capabilities这里需要先了解一下Linux Capabilities机制：Linux Capabilities机制 这里先定义了SystemServer进程的Permitted和Effective能力集合 123456789101112private static long posixCapabilitiesAsBits(int... capabilities) &#123; long result = 0; for (int capability : capabilities) &#123; //非法capability，直接抛出异常 if ((capability &lt; 0) || (capability &gt; OsConstants.CAP_LAST_CAP)) &#123; throw new IllegalArgumentException(String.valueOf(capability)); &#125; //为或操作，构建capabilities集合 result |= (1L &lt;&lt; capability); &#125; return result;&#125; 检查一下有无非法capability，然后做位或运算，构建出一个capabilities集合 然后通过Os.capget方法获取当前线程的capabilities集合，上一篇文章中我们已经分析过了Os的作用，最终通过Linux_capgetJNI函数调用Linuxcapget函数，通过返回回来的值，剔除一些当前线程不支持的特权 Fork接着设置一些fork参数，通过ZygoteArguments去解析它 然后调用Zygote.forkSystemServer方法，这个和上一章里说的fork App的过程差不多 123456789101112131415static int forkSystemServer(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; //停止其他线程 ZygoteHooks.preFork(); int pid = nativeForkSystemServer( uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities); //设置默认线程优先级 Thread.currentThread().setPriority(Thread.NORM_PRIORITY); //恢复其他线程 ZygoteHooks.postForkCommon(); return pid;&#125; 先把子线程都停止掉，fork完后再恢复，调用native函数nativeForkSystemServer，路径为frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223242526272829303132333435363738static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) &#123; ... pid_t pid = ForkCommon(env, true, fds_to_close, fds_to_ignore, true); if (pid == 0) &#123; // System server prcoess does not need data isolation so no need to // know pkg_data_info_list. SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, permitted_capabilities, effective_capabilities, MOUNT_EXTERNAL_DEFAULT, nullptr, nullptr, true, false, nullptr, nullptr, /* is_top_app= */ false, /* pkg_data_info_list */ nullptr, /* whitelisted_data_info_list */ nullptr, false, false); &#125; else if (pid &gt; 0) &#123; ... gSystemServerPid = pid; //检查SystemServer进程状态 int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //如果SystemServer进程死亡，重启整个Zygote ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\"); &#125; //如果是低内存设备，限制SystemServer进程使用内存大小 if (UsePerAppMemcg()) &#123; if (!SetTaskProfiles(pid, std::vector&lt;std::string&gt;&#123;\"SystemMemoryProcess\"&#125;)) &#123; ALOGE(\"couldn't add process %d into system memcg group\", pid); &#125; &#125; &#125; return pid;&#125; ForkCommon我们先看ForkCommon函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static pid_t ForkCommon(JNIEnv* env, bool is_system_server, const std::vector&lt;int&gt;&amp; fds_to_close, const std::vector&lt;int&gt;&amp; fds_to_ignore, bool is_priority_fork) &#123; //设置子进程信号处理器 SetSignalHandlers(); //C++中的一种可调用对象，ZygoteFailure函数接收4个参数，前三个参数都已提供，最后一个参数占位等待调用方填入 auto fail_fn = std::bind(ZygoteFailure, env, is_system_server ? \"system_server\" : \"zygote\", nullptr, _1); //在fork期间阻塞住SIGCHLD信号，避免在SIGCHLD信号处理函数中打印log，导致后面关闭的日志fd重新被打开 BlockSignal(SIGCHLD, fail_fn); //关闭所有日志相关fd __android_log_close(); AStatsSocket_close(); //SystemServer是Zygote进程起来后第一个fork的出来进程，创建打开的文件描述符表 if (gOpenFdTable == nullptr) &#123; gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn); &#125; else &#123; gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn); &#125; android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level(); //立即清除任何未使用的内存 mallopt(M_PURGE, 0); pid_t pid = fork(); if (pid == 0) &#123; //fork SystemServer时，此参数为true if (is_priority_fork) &#123; //设置最高进程优先级 setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MAX); &#125; else &#123; setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_MIN); &#125; // The child process. PreApplicationInit(); //清除所有需要立即关闭的fd DetachDescriptors(env, fds_to_close, fail_fn); //USAP机制我们现在不关注 ClearUsapTable(); //重新打开剩余打开的文件描述符，避免文件描述符通过fork在SystemServer和Zygote之间共享 gOpenFdTable-&gt;ReopenOrDetach(fail_fn); //Sanitizer机制，用来检测程序异常 android_fdsan_set_error_level(fdsan_error_level); // Reset the fd to the unsolicited zygote socket gSystemServerSocketFd = -1; &#125; else &#123; ALOGD(\"Forked child process %d\", pid); &#125; //取消之前阻塞的SIGCHLD信号 UnblockSignal(SIGCHLD, fail_fn); return pid;&#125; 处理子进程信号先设置子进程信号处理器 12345678910111213static void SetSignalHandlers() &#123; struct sigaction sig_chld = &#123;.sa_flags = SA_SIGINFO, .sa_sigaction = SigChldHandler&#125;; if (sigaction(SIGCHLD, &amp;sig_chld, nullptr) &lt; 0) &#123; ALOGW(\"Error setting SIGCHLD handler: %s\", strerror(errno)); &#125; struct sigaction sig_hup = &#123;&#125;; sig_hup.sa_handler = SIG_IGN; if (sigaction(SIGHUP, &amp;sig_hup, nullptr) &lt; 0) &#123; ALOGW(\"Error setting SIGHUP handler: %s\", strerror(errno)); &#125;&#125; 关于信号的处理，我们在Android源码分析 - init进程中已经了解过一次，SA_SIGINFO这个flag代表调用信号处理函数sa_sigaction的时候，会将信号的信息通过参数siginfo_t传入 SIGHUP表示终端断开信号，SIG_IGN表示忽略信号，即忽略终端断开信号 我们看一下Zygote是怎么处理其子进程信号的 1234567891011121314151617181920static void SigChldHandler(int /*signal_number*/, siginfo_t* info, void* /*ucontext*/) &#123; pid_t pid; int status; ... int saved_errno = errno; while ((pid = waitpid(-1, &amp;status, WNOHANG)) &gt; 0) &#123; //通知SystemServer，Zygote收到了一个SIGCHLD信号 sendSigChildStatus(pid, info-&gt;si_uid, status); ... //打印子进程状态日志 //如果崩溃的进程是SystemServer，整个Zygote都会退出，再通过init进程重启 if (pid == gSystemServerPid) &#123; async_safe_format_log(ANDROID_LOG_ERROR, LOG_TAG, \"Exit zygote because system server (pid %d) has terminated\", pid); kill(getpid(), SIGKILL); &#125; &#125; ... errno = saved_errno;&#125; 如果检测到有子进程退出，通知SystemServer，如果这个进程是SystemServer进程，杀掉Zygote进程重启 ZygoteFailure这里先需要理解一下C++11 中的std::function和std::bind 简单来说，std::bind返回了一个std::function对象，它是一个可调用对象，实际调用的就是传入的第一个参数：ZygoteFailure函数，这个函数接受4个参数，前三个参数都在std::bind时提供好了，第四个参数以_1占位符替代（std::placeholders::_1） 实际上调用fail_fn(msg)就相当于调用函数ZygoteFailure(env, &quot;system_server&quot;, nullptr, msg) 123456789101112131415161718static void ZygoteFailure(JNIEnv* env, const char* process_name, jstring managed_process_name, const std::string&amp; msg) &#123; std::unique_ptr&lt;ScopedUtfChars&gt; scoped_managed_process_name_ptr = nullptr; if (managed_process_name != nullptr) &#123; scoped_managed_process_name_ptr.reset(new ScopedUtfChars(env, managed_process_name)); if (scoped_managed_process_name_ptr-&gt;c_str() != nullptr) &#123; process_name = scoped_managed_process_name_ptr-&gt;c_str(); &#125; &#125; const std::string&amp; error_msg = (process_name == nullptr) ? msg : StringPrintf(\"(%s) %s\", process_name, msg.c_str()); //抛出异常 env-&gt;FatalError(error_msg.c_str()); __builtin_unreachable();&#125; 当发生错误后，最终向Java层抛出了一个异常 BlockSignal &amp; UnblockSignal在fork期间需要阻塞住SIGCHLD信号，避免在SIGCHLD信号处理函数中打印log，导致后面关闭的日志fd重新被打开 123456789static void BlockSignal(int signum, fail_fn_t fail_fn) &#123; sigset_t sigs; sigemptyset(&amp;sigs); sigaddset(&amp;sigs, signum); if (sigprocmask(SIG_BLOCK, &amp;sigs, nullptr) == -1) &#123; fail_fn(CREATE_ERROR(\"Failed to block signal %s: %s\", strsignal(signum), strerror(errno))); &#125;&#125; 等fork结束，取消阻塞SIGCHLD信号 123456789static void UnblockSignal(int signum, fail_fn_t fail_fn) &#123; sigset_t sigs; sigemptyset(&amp;sigs); sigaddset(&amp;sigs, signum); if (sigprocmask(SIG_UNBLOCK, &amp;sigs, nullptr) == -1) &#123; fail_fn(CREATE_ERROR(\"Failed to un-block signal %s: %s\", strsignal(signum), strerror(errno))); &#125;&#125; 信号集函数我们之前已经在Android源码分析 - init进程中介绍过了，很简单，就是将SIGCHLD信号添加到屏蔽集中，fork完后再将这个信号从屏蔽集中移除 SpecializeCommon至此，fork操作结束，我们看一下在SystemServer进程中执行的SpecializeCommon函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities, jint mount_external, jstring managed_se_info, jstring managed_nice_name, bool is_system_server, bool is_child_zygote, jstring managed_instruction_set, jstring managed_app_data_dir, bool is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, bool mount_data_dirs, bool mount_storage_dirs) &#123; //process_name = \"system_server\" const char* process_name = is_system_server ? \"system_server\" : \"zygote\"; auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1); auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1); //均为nullptr auto se_info = extract_fn(managed_se_info); auto nice_name = extract_fn(managed_nice_name); auto instruction_set = extract_fn(managed_instruction_set); auto app_data_dir = extract_fn(managed_app_data_dir); //当UID发生改变时（root-&gt;非root）保留capabilities if (uid != 0) &#123; EnableKeepCapabilities(fail_fn); &#125; //设置Inheritable集合 SetInheritable(permitted_capabilities, fail_fn); //从Bounding集合中移除调用线程相关能力 DropCapabilitiesBoundingSet(fail_fn); ... //创建私有挂载命名空间，挂载虚拟存储 MountEmulatedStorage(uid, mount_external, need_pre_initialize_native_bridge, fail_fn); ... //设置GroupId SetGids(env, gids, is_child_zygote, fail_fn); //设置资源Limit SetRLimits(env, rlimits, fail_fn); ... //设置gid及访问权限 if (setresgid(gid, gid, gid) == -1) &#123; fail_fn(CREATE_ERROR(\"setresgid(%d) failed: %s\", gid, strerror(errno))); &#125; //capabilities集合中仍然存在CAP_SYS_ADMIN，需要过滤系统调用 SetUpSeccompFilter(uid, is_child_zygote); //设置调度策略 SetSchedulerPolicy(fail_fn, is_top_app); //设置uid及访问权限 if (setresuid(uid, uid, uid) == -1) &#123; fail_fn(CREATE_ERROR(\"setresuid(%d) failed: %s\", uid, strerror(errno))); &#125; ... //设置Capabilities SetCapabilities(permitted_capabilities, effective_capabilities, permitted_capabilities, fail_fn); //关闭所有日志相关fd __android_log_close(); AStatsSocket_close(); ... //设置线程名 if (nice_name.has_value()) &#123; SetThreadName(nice_name.value()); &#125; else if (is_system_server) &#123; //nice_name为nullptr, 进入此分支 SetThreadName(\"system_server\"); &#125; //取消掉之前设置的SIGCHID信号处理函数 UnsetChldSignalHandler(); if (is_system_server) &#123; //调用ZygoteHooks.postForkSystemServer(runtime_flags); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork system server hooks.\"); &#125; ... &#125; ... //调用ZygoteHooks.postForkChild(runtime_flags, true, false, null); env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set); //设置默认进程优先级 setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_DEFAULT); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork hooks.\"); &#125;&#125; 这里做了很多工作，有Capabilities相关，selinux相关，权限相关等等，有点太多了，我标了注释，就不再一一分析了 接下来回到nativeForkSystemServer中，在Zygote进程中继续执行 123456789101112131415161718192021222324252627static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities) &#123; ... if (pid == 0) &#123; ... &#125; else if (pid &gt; 0) &#123; ... gSystemServerPid = pid; //检查SystemServer进程状态 int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //如果SystemServer进程死亡，重启整个Zygote ALOGE(\"System server process %d has died. Restarting Zygote!\", pid); RuntimeAbort(env, __LINE__, \"System server process has died. Restarting Zygote!\"); &#125; //如果是低内存设备，限制SystemServer进程使用内存大小 if (UsePerAppMemcg()) &#123; if (!SetTaskProfiles(pid, std::vector&lt;std::string&gt;&#123;\"SystemMemoryProcess\"&#125;)) &#123; ALOGE(\"couldn't add process %d into system memcg group\", pid); &#125; &#125; &#125; return pid;&#125; 通过Linux函数waitpid检查SystemServer进程状态，这个函数和之前在Android源码分析 - init进程中提过的waitid函数类似，WNOHANG表示非阻塞等待 如果SystemServer进程死亡，重启整个Zygote 12345678910111213141516private static Runnable forkSystemServer(String abiList, String socketName, ZygoteServer zygoteServer) &#123; ... //SystemServer子进程 if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; //关闭zygote server socket zygoteServer.closeServerSocket(); return handleSystemServerProcess(parsedArgs); &#125; return null;&#125; cgroups如果是小内存设备，使用Linux的cgroups机制，限制SystemServer进程使用内存大小 1234bool UsePerAppMemcg() &#123; bool low_ram_device = GetBoolProperty(\"ro.config.low_ram\", false); return GetBoolProperty(\"ro.config.per_app_memcg\", low_ram_device);&#125; 关于Linux的cgroups机制，可以查看这篇文档：cgroups(7) — Linux manual page 关于Android的Cgroups机制，可以看这篇官方文档：Cgroup 抽象层 运行初始化12345678910111213141516171819202122232425262728293031private static Runnable handleSystemServerProcess(ZygoteArguments parsedArgs) &#123; //将umask设置为0077，这样新的文件和目录将默认为仅属于所有者的权限 Os.umask(S_IRWXG | S_IRWXO); //设置进程名 if (parsedArgs.mNiceName != null) &#123; Process.setArgV0(parsedArgs.mNiceName); &#125; //对classpath中的apk，分别进行dex优化操作，由installd真正执行 final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; performSystemServerDexOpt(systemServerClasspath); ... &#125; if (parsedArgs.mInvokeWith != null) &#123; ... &#125; else &#123; //SystemServer进入这个分支 ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, cl); &#125;&#125; 处理一些初始化操作，然后调用ZygoteInit.zygoteInit方法 12345678910public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... //通用初始化 RuntimeInit.commonInit(); //开启binder线程池 ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);&#125; RuntimeInit的路径为frameworks/base/core/java/com/android/internal/os/RuntimeInit.java，先执行通用初始化 12345678910111213141516171819202122protected static final void commonInit() &#123; //设置默认线程异常处理器 LoggingHandler loggingHandler = new LoggingHandler(); RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler); Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); //设置时区 RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(\"persist.sys.timezone\")); //重置Log配置 LogManager.getLogManager().reset(); new AndroidConfig(); //设置网络UA信息 String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); //初始化网络流量统计 NetworkManagementSocketTagger.install(); ... initialized = true;&#125; 接着执行RuntimeInit.applicationInit 12345678910111213protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; //如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数 nativeSetExitWithoutCleanup(true); //设置虚拟机参数 VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges); //解析参数 final Arguments args = new Arguments(argv); ... //查找startClass中的main方法 return findStaticMain(args.startClass, args.startArgs, classLoader);&#125; 参数解析我们看一下它是怎么解析参数的 1234567891011121314151617181920212223242526Arguments(String args[]) throws IllegalArgumentException &#123; parseArgs(args);&#125;private void parseArgs(String args[]) throws IllegalArgumentException &#123; int curArg = 0; for (; curArg &lt; args.length; curArg++) &#123; String arg = args[curArg]; if (arg.equals(\"--\")) &#123; curArg++; break; &#125; else if (!arg.startsWith(\"--\")) &#123; break; &#125; &#125; if (curArg == args.length) &#123; throw new IllegalArgumentException(\"Missing classname argument to RuntimeInit!\"); &#125; startClass = args[curArg++]; startArgs = new String[args.length - curArg]; System.arraycopy(args, curArg, startArgs, 0, startArgs.length);&#125; 循环读参数直到有一项参数为”–”或者不以”–”开头，然后以下一个参数作为startClass，用再下一个参数到args数组结尾生成一个新的数组作为startArgs，我们观察一下forkSystemServer方法中设置的args 1234567891011String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,\" + \"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"--target-sdk-version=\" + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT, \"com.android.server.SystemServer\", &#125;; 可以看出，startClass应该为com.android.server.SystemServer，startArgs数组为空 反射执行接着调用findStaticMain方法 12345678910111213141516171819202122232425262728293031323334353637protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv);&#125; 这里使用了Java中的反射，找到了SystemServer中对应的main方法，并用其创建了一个Runnable对象MethodAndArgsCaller 1234567891011121314151617181920212223242526static class MethodAndArgsCaller implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; //执行SystemServer.main方法 mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; 我们最后再回到ZygoteInit的main方法中 1234567891011121314public static void main(String argv[]) &#123; ... //启动SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); //子进程中才会满足r != null if (r != null) &#123; //此时执行这个Runnable r.run(); return; &#125; &#125;&#125; 执行这个在子进程中返回出去的Runnable：MethodAndArgsCaller，反射调用SystemServer.main方法 结束至此，SystemServer的启动我们就分析完了，下一篇我们将分析SystemServer启动后做了什么","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"}]},{"title":"Linux Capabilities机制","slug":"linux/LinuxCapabilities机制","date":"2022-01-14T05:43:00.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2022/01/14/linux/LinuxCapabilities机制/","link":"","permalink":"http://yoursite.com/2022/01/14/linux/LinuxCapabilities%E6%9C%BA%E5%88%B6/","excerpt":"","text":"介绍传统的Linux权限控制粒度太粗，以passwd命令为例，修改用户密码是需要root权限的，但普通用户应该是能够修改自己密码的才对，这时候Linux就使用了SUID、EUID机制，使passwd进程以它的所有者root权限运行这样就可以以root权限修改密码了 SUID机制是有安全隐患的，passwd进程只需要修改密码的就可以了，却在整个运行周期内获得了root权限，一旦出现漏洞，很有可能会被利用 所以，Linux内核在2.2后引入了Capabilities机制，细粒度化了权限控制，可以做到按需授权 这里是文档：https://man7.org/linux/man-pages/man7/capabilities.7.html 如何使用首先，Capabilities是有一个集合的概念的，即一个进程或可执行文件，它可以拥有哪些特权的集合 可执行文件可执行文件有三种Capabilities集合： Permitted当文件执行时，这个集合的内容会被添加到进程的Permitted集合中 Inheritable当文件执行后，这个集合会与进程的Inheritable集合做位与操作(&amp;)，以确定进程在执行execve函数后哪些capabilites可以被继承 Effective这不是一个集合，而是一个位(bit)，如果此bit设为1，则Permitted集合中新增的capabilites会在执行execve函数后添加到进程的Effective集合中 命令 设置capabilites 12345setcap [capability,capability,...]+[ep] [文件]# orsetcap [capability+ep capability+ep ...] [文件] capability就是某个特权值，+ep代表加入Effective和Permitted集合中 获取capabilites 1getcap [文件] 线程（进程）线程（进程）有五种Capabilities集合： Permitted这个集合定义了线程所能够拥有的特权的上限，是Inheritable和Effective集合的的超集 Inheritable包含了当执行execve 函数时，能够被新的可执行文件继承的capabilities（执行execve 函数后会被添加到Permitted集合中） Effective内核检查特权操作时，实际检查的集合（可以通过执行操作前增/删Effective中的capabilities，以达到临时开/关权限的功能） Bounding (内核2.6.25以后)这个集合是 Inheritable 集合的超集，如果某个capability不在Bounding集合中，即使它在Permitted集合中，该线程也不能将该capability添加到它的Inheritable集合中，该集合在execve后不可再添加capabilities Ambient (内核4.3以后)这个集合是Permitted和Inheritable的子集，当Permitted和Inheritable删除某个capability时，也会自动删除该集合中对应的capability，子进程会自动继承这个集合中的capabilities，子进程的Permitted、Effective和Ambient都会拥有这些capabilities 函数capset原型： 1int capset(cap_user_header_t hdrp, const cap_user_data_t datap); 文档：https://linux.die.net/man/2/capset capget原型： 1int capget(cap_user_header_t hdrp , cap_user_data_t datap); 文档：https://linux.die.net/man/2/capget 结构体12345678910typedef struct __user_cap_header_struct &#123; __u32 version; int pid; &#125; *cap_user_header_t;typedef struct __user_cap_data_struct &#123; __u32 effective; __u32 permitted; __u32 inheritable; &#125; *cap_user_data_t; 计算公式我们用 P 代表执行 execve() 前线程的 capabilities，P&#39; 代表执行 execve() 后线程的 capabilities，F 代表可执行文件的 capabilities，那么： P’(ambient) = (file is privileged) ? 0 : P(ambient) P’(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding))) | P’(ambient) P’(effective) = F(effective) ? P’(permitted) : P’(ambient) P’(inheritable) = P(inheritable) [i.e., unchanged] P’(bounding) = P(bounding) [i.e., unchanged] 我们一条一条来解释： 如果用户是 root 用户，那么执行 execve() 后线程的 Ambient 集合是空集；如果是普通用户，那么执行 execve() 后线程的 Ambient 集合将会继承执行 execve() 前线程的 Ambient 集合。 执行 execve() 前线程的 Inheritable 集合与可执行文件的 Inheritable 集合取交集，会被添加到执行 execve() 后线程的 Permitted 集合；可执行文件的 capability bounding 集合与可执行文件的 Permitted 集合取交集，也会被添加到执行 execve() 后线程的 Permitted 集合；同时执行 execve() 后线程的 Ambient 集合中的 capabilities 会被自动添加到该线程的 Permitted 集合中。 如果可执行文件开启了 Effective 标志位，那么在执行完 execve() 后，线程 Permitted 集合中的 capabilities 会自动添加到它的 Effective 集合中。 执行 execve() 前线程的 Inheritable 集合会继承给执行 execve() 后线程的 Inheritable 集合。 这里有几点需要着重强调： 上面的公式是针对系统调用 execve() 的，如果是 fork()，那么子线程的 capabilities 信息完全复制父进程的 capabilities 信息。 可执行文件的 Inheritable 集合与线程的 Inheritable 集合并没有什么关系，可执行文件 Inheritable 集合中的 capabilities 不会被添加到执行 execve() 后线程的 Inheritable 集合中。如果想让新线程的 Inheritable 集合包含某个 capability，只能通过 capset() 将该 capability 添加到当前线程的 Inheritable 集合中（因为 P’(inheritable) = P(inheritable)）。 如果想让当前线程 Inheritable 集合中的 capabilities 传递给新的可执行文件，该文件的 Inheritable 集合中也必须包含这些 capabilities（因为 P’(permitted) = (P(inheritable) &amp; F(inheritable))|…）。 将当前线程的 capabilities 传递给新的可执行文件时，仅仅只是传递给新线程的 Permitted 集合。如果想让其生效，新线程必须通过 capset() 将 capabilities 添加到 Effective 集合中。或者开启新的可执行文件的 Effective 标志位（因为 P’(effective) = F(effective) ? P’(permitted) : P’(ambient)）。 在没有 Ambient 集合之前，如果某个脚本不能调用 capset()，但想让脚本中的线程都能获得该脚本的 Permitted 集合中的 capabilities，只能将 Permitted 集合中的 capabilities 添加到 Inheritable 集合中（P’(permitted) = P(inheritable) &amp; F(inheritable)|…），同时开启 Effective 标志位（P’(effective) = F(effective) ? P’(permitted) : P’(ambient)）。有 有 Ambient 集合之后，事情就变得简单多了，后续的文章会详细解释。 如果某个 UID 非零（普通用户）的线程执行了 execve()，那么 Permitted 和 Effective 集合中的 capabilities 都会被清空。 从 root 用户切换到普通用户，那么 Permitted 和 Effective 集合中的 capabilities 都会被清空，除非设置了 SECBIT_KEEP_CAPS 或者更宽泛的 SECBIT_NO_SETUID_FIXUP。 附录Capabilities表 Capability 描述 CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则 CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志 CAP_AUDIT_WRITE 将记录写入内核审计日志 CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性 CAP_BPF (5.8) 从CAP_SYS_ADMIN分离一部分BFP功能，控制了一些BPF特定的操作，包括创建BPF maps、使用一些高级的BPF程序功能、访问BPF type format（BTF）数据等 CAP_CHECKPOINT_RESTORE (5.9) 允许更新/proc/sys/kernel/ns_last_pid，使用set_tid特性，读其他进程的/proc/[pid]/map_files CAP_CHOWN 修改文件所有者的权限 CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制 CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制 CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制 CAP_FSETID 允许设置文件的 setuid 位 CAP_IPC_LOCK 允许锁定共享内存片段 CAP_IPC_OWNER 忽略 IPC 所有权检查 CAP_KILL 允许对不属于自己的进程发送信号 CAP_LEASE 允许修改文件锁的 FL_LEASE 标志 CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志 CAP_MAC_ADMIN 允许 MAC 配置或状态更改 CAP_MAC_OVERRIDE 忽略文件的 DAC 访问限制 CAP_MKNOD 允许使用 mknod() 系统调用 CAP_NET_ADMIN 允许执行网络管理任务 CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口 CAP_NET_BROADCAST 允许网络广播和多播访问 CAP_NET_RAW 允许使用原始套接字 CAP_PERFMON (5.8) 管理性能监控task CAP_SETGID 允许改变进程的 GID CAP_SETFCAP 允许为文件设置任意的 capabilities CAP_SETPCAP 允许设置其他进程的 capabilities CAP_SETUID 允许改变进程的 UID CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等 CAP_SYS_BOOT 允许重新启动系统 CAP_SYS_CHROOT 允许使用 chroot() 系统调用 CAP_SYS_MODULE 允许插入和删除内核模块 CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级 CAP_SYS_PACCT 允许执行进程的 BSD 式审计 CAP_SYS_PTRACE 允许跟踪任何进程 CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备 CAP_SYS_RESOURCE 忽略资源限制 CAP_SYS_TIME 允许改变系统时钟 CAP_SYS_TTY_CONFIG 允许配置 TTY 设备 CAP_SYSLOG 允许使用 syslog() 系统调用 CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器) 参考文献Linux Capabilities 简介 Linux的capabilities机制 Linux Capabilities 入门教程：概念篇","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Capabilities","slug":"Capabilities","permalink":"http://yoursite.com/tags/Capabilities/"}]},{"title":"Android源码分析 - Zygote进程","slug":"android/aosp/Android源码分析-Zygote进程","date":"2022-01-10T09:30:00.000Z","updated":"2022-11-13T09:55:54.356Z","comments":true,"path":"2022/01/10/android/aosp/Android源码分析-Zygote进程/","link":"","permalink":"http://yoursite.com/2022/01/10/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Zygote%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 上一篇文章Android源码分析 - init进程，我们分析了Android第一个用户进程init进程的启动过程和之后的守护服务 init进程启动了很多服务，例如Zygote，ServiceManager，MediaServer，SurfaceFlinger等，我们平常写Android应用都是使用Java语言，这次我们就先从Java世界的半边天：Zygote进程 开始分析 介绍Zygote意为受精卵，它有两大作用，一是启动SystemServer，二是孵化启动App 启动服务我们已经知道了init进程会从init.rc文件中解析并启动服务，那zygote是在哪定义的呢，init.rc的头几行就有一个import：import /system/etc/init/hw/init.${ro.zygote}.rc 我们在init.rc同目录下就能找到几个对应的文件：init.zygote32_64.rc init.zygote32.rc init.zygote64_32.rc init.zygote64.rc，具体import哪个文件与具体设备硬件有关，现在64位手机这么普及了，我们就以init.zygote64.rc为目标分析 123456789101112131415service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse onrestart write &#x2F;sys&#x2F;power&#x2F;state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks 下面的子项我们暂时不用关心，先记住app_process64的启动参数-Xzygote /system/bin --zygote --start-system-server即可 Zygote启动的源文件为frameworks/base/cmds/app_process/app_main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111int main(int argc, char* const argv[])&#123; ... //创建了一个AppRuntime，继承自AndroidRuntime，重写了一些回调方法 AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] //在启动服务时，传进来的参数是包含文件路径的 //我们不需要这个参数，就减一下个数，移一下指针 argc--; argv++; ... //处理参数，这里只添加了一个-Xzygote参数 int i; for (i = 0; i &lt; argc; i++) &#123; ... if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); ... &#125; // Parse runtime arguments. Stop at first unrecognized option. bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; //跳过参数/system/bin，这个参数目前没有被使用 ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; //有--zygote参数 zygote = true; //ZYGOTE_NICE_NAME在64位下为zygote64，32位下为zygote niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; //有-start-system-server参数 startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; //这个分支不会进入Zygote模式 ... &#125; else &#123; // We're in zygote mode. //新建Dalvik缓存目录 maybeCreateDalvikCache(); //添加启动参数 if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. //Zygote模式下没有其他参数了 for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; if (!niceName.isEmpty()) &#123; //设置程序名以及进程名 runtime.setArgv0(niceName.string(), true /* setProcName */); &#125; if (zygote) &#123; //执行AndroidRuntime::start方法 runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); &#125;&#125; 整体结构还是比较简单的，就是处理一下参数，进入zygote对应的分支，执行AndroidRuntime::start方法，第一个参数传的是ZygoteInit在Java中的类名，第二个参数传了一些选项（start-system-server和abi-list），第三个参数传了true，代表启动虚拟机的时候需要额外添加一些JVM参数 AndroidRuntime::start12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... static const String8 startSystemServer(\"start-system-server\"); // Whether this is the primary zygote, meaning the zygote which will fork system server. //64_32位兼容设备上会启动两个Zygote，一个叫zygote，一个叫zygote_secondary bool primary_zygote = false; //有start-system-server选项则代表是主Zygote for (size_t i = 0; i &lt; options.size(); ++i) &#123; if (options[i] == startSystemServer) &#123; primary_zygote = true; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125; &#125; //检查和配置一些环境变量 ... /* start the virtual machine */ //加载libart.so JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; //启动JVM if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; return; &#125; //回调AppRuntime中重写的方法 onVmCreated(env); /* * Register android functions. */ //注册Android JNI函数 if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; //创建一个Java层的String数组用来装参数 jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //第一个参数是类名com.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); //剩下来参数分别是start-system-server和abi-list for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //将Java类名中的\".\"替换成\"/\"，这是JNI中的类名规则 char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //获取ZygoteInit中的main方法，参数为String类型，返回值为void jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //执行ZygoteInit的main方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //后面的代码除非JVM挂了，否则不会执行 ... &#125; &#125; ...&#125; 首先判断选项中是否携带参数start-system-server，如有，则将它视为主Zygote，接着就开始启动JVM了 启动JVMJniInvocation使用JniInvocation初始化Android ART虚拟机环境，它的路径是libnativehelper/include_platform/nativehelper/JniInvocation.h，我们来看一下它是怎么做的 我们首先看一下它的构造函数 123456789101112/* libnativehelper/include_platform/nativehelper/JniInvocation.h */class JniInvocation final &#123; public: JniInvocation() &#123; impl_ = JniInvocationCreate(); &#125; ~JniInvocation() &#123; JniInvocationDestroy(impl_); &#125; ...&#125; 调用JniInvocationCreate方法创建了一个JniInvocationImpl实例对象 123JniInvocationImpl* JniInvocationCreate() &#123; return new JniInvocationImpl();&#125; 接着调用JniInvocation::Init方法 1234567bool Init(const char* library) &#123; return JniInvocationInit(impl_, library) != 0;&#125;int JniInvocationInit(JniInvocationImpl* instance, const char* library) &#123; return instance-&gt;Init(library) ? 1 : 0;&#125; 可以看到，JniInvocation实际上是个代理类，内部实现是交给JniInvocationImpl的，路径为libnativehelper/JniInvocation.cpp 12345678910111213141516171819202122232425262728293031323334353637bool JniInvocationImpl::Init(const char* library) &#123; ... //非debug一律为libart.so library = GetLibrary(library, buffer); //加载libart.so库 handle_ = OpenLibrary(library); if (handle_ == NULL) &#123; //如果是加载libart.so库失败，直接返回false if (strcmp(library, kLibraryFallback) == 0) &#123; // Nothing else to try. ALOGE(\"Failed to dlopen %s: %s\", library, GetError().c_str()); return false; &#125; ... //如果是加载其他库失败，尝试回退加载libart.so库 library = kLibraryFallback; handle_ = OpenLibrary(library); if (handle_ == NULL) &#123; ALOGE(\"Failed to dlopen %s: %s\", library, GetError().c_str()); return false; &#125; &#125; //从libart.so库获得三个JVM相关的函数地址 if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_), \"JNI_GetDefaultJavaVMInitArgs\")) &#123; return false; &#125; if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_CreateJavaVM_), \"JNI_CreateJavaVM\")) &#123; return false; &#125; if (!FindSymbol(reinterpret_cast&lt;FUNC_POINTER*&gt;(&amp;JNI_GetCreatedJavaVMs_), \"JNI_GetCreatedJavaVMs\")) &#123; return false; &#125; return true;&#125; 加载libart.so库我们先看GetLibrary方法 12345678910111213141516171819202122232425static const char* kLibraryFallback = \"libart.so\";const char* JniInvocationImpl::GetLibrary(const char* library, char* buffer, bool (*is_debuggable)(), int (*get_library_system_property)(char* buffer)) &#123;#ifdef __ANDROID__ const char* default_library; if (!is_debuggable()) &#123; library = kLibraryFallback; default_library = kLibraryFallback; &#125; else &#123; ... &#125;#else ... const char* default_library = kLibraryFallback;#endif if (library == NULL) &#123; library = default_library; &#125; return library;&#125; 可以看到，在debug模式或library参数为NULL的情况下都是直接返回的libart.so 而OpenLibrary方法是使用了dlopen函数，加载libart.so库 123456void* OpenLibrary(const char* filename) &#123; ... const int kDlopenFlags = RTLD_NOW | RTLD_NODELETE; return dlopen(filename, kDlopenFlags); ...&#125; dlopen原型：void *dlopen(const char *filename, int flags); 文档：https://man7.org/linux/man-pages/man3/dlopen.3.html 这是一个Linux函数，用来加载一个动态链接库，当加载成功时，会返回一个句柄 上面的这两个参数，RTLD_NOW代表立即计算库的依赖性，RTLD_NODELETE代表不要再dlclose期间卸载库，这样当再次加载库的时候不会重新初始化对象的静态全局变量，使用这个flag是为了确保libart.so在关闭时不会被取消映射。因为即使在 JNI_DeleteJavaVM 调用之后，某些线程仍可能尚未完成退出，如果卸载该库，则可能导致段错误 从libart.so库中寻找函数地址接着调用FindSymbol函数查找函数地址 1234567891011121314151617181920#define FUNC_POINTER void*bool JniInvocationImpl::FindSymbol(FUNC_POINTER* pointer, const char* symbol) &#123; //获得函数地址 *pointer = GetSymbol(handle_, symbol); //获取失败，卸载libart.so库 if (*pointer == NULL) &#123; ALOGE(\"Failed to find symbol %s: %s\\n\", symbol, GetError().c_str()); CloseLibrary(handle_); handle_ = NULL; return false; &#125; return true;&#125;FUNC_POINTER GetSymbol(void* handle, const char* symbol) &#123; ... return dlsym(handle, symbol); ...&#125; dlsym原型：void *dlsym(void *restrict handle , const char *restrict symbol); 文档：https://man7.org/linux/man-pages/man3/dlsym.3.html 也是一个Linux函数，用来从已加载的动态链接库中获取一个函数的地址 传入的第一个参数为之前加载库时返回的句柄，第二个参数为函数名 总结回顾一下全局，JniInvocationImpl::Init的作用是，加载libart.so库，并从中获取三个函数指针： JNI_GetDefaultJavaVMInitArgs：获取虚拟机的默认初始化参数 JNI_CreateJavaVM：创建虚拟机实例 JNI_GetCreatedJavaVMs：获取创建的虚拟机实例 这几个函数被定义在jni.h中，后面我们创建JVM的时候会用到这些函数 AndroidRuntime::startVm12345678910111213141516171819int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote, bool primary_zygote)&#123; JavaVMInitArgs initArgs; ... //配置了一大堆JVM选项 initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; //创建并初始化JVM if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125; JNI_CreateJavaVM方法就是我们之前从libart.so里获得的方法，被编译进libart.so前，源码的路径为art/runtime/jni/java_vm_ext.cc，接下来属于ART虚拟机的工作，我们就不再往下深究了 后面有一个onVmCreated回调，但在zygote模式下没做任何事 注册JNI函数接着调用startReg函数注册Android JNI函数 12345678910111213141516171819202122232425/* * Register android native functions with the VM. *//*static*/ int AndroidRuntime::startReg(JNIEnv* env)&#123; ... //设置Native创建线程的函数，通过javaCreateThreadEtc这个函数创建的线程 //会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码 androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); ALOGV(\"--- registering native functions ---\\n\"); //创建局部引用栈帧 env-&gt;PushLocalFrame(200); //注册jni函数 if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; //将当前栈帧出栈，释放其中所有局部引用 env-&gt;PopLocalFrame(NULL); return 0;&#125; 首先hook了Native创建线程的函数，之后创建线程便会调用我们设置的javaCreateThreadEtc函数，会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码。这个等之后看到Android线程创建的时候再分析 PushLocalFrame和PopLocalFrame是一对函数，它们是用来管理JNI的局部引用的 首先，PushLocalFrame会创建出一个局部引用栈帧，之后JNI创建出来的局部引用都会放在这个栈帧里，等使用结束后调用PopLocalFrame函数，会将当前栈帧出栈，并且释放其中所有的局部引用 接下来我们看register_jni_procs函数 1234567891011121314struct RegJNIRec &#123; int (*mProc)(JNIEnv*);&#125;; static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; ... return -1; &#125; &#125; return 0;&#125; 很简单，就是循环执行gRegJNI数组中所有的函数 12345678910#define REG_JNI(name) &#123; name &#125;static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_com_android_internal_os_RuntimeInit), REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit), REG_JNI(register_android_os_SystemClock), REG_JNI(register_android_util_EventLog), REG_JNI(register_android_util_Log), ...&#125;; gRegJNI数组中存放着很多Java类注册JNI函数的函数，后面大家如果阅读源码看到了Android中的native方法可以来这边找它所对应的c++实现 这边注册的类非常多，我们就取第一个register_com_android_internal_os_RuntimeInit为例分析一下 1234567891011121314151617typedef struct &#123; const char* name; const char* signature; void* fnPtr;&#125; JNINativeMethod;int register_com_android_internal_os_RuntimeInit(JNIEnv* env)&#123; const JNINativeMethod methods[] = &#123; &#123;\"nativeFinishInit\", \"()V\", (void*)com_android_internal_os_RuntimeInit_nativeFinishInit&#125;, &#123;\"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup&#125;, &#125;; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", methods, NELEM(methods));&#125; 创建了一个JNINativeMethod结构体，第一个成员是Java中的方法名，第二个成员是Java中对应方法的签名，第三个成员是Java方法对应native函数的函数指针，然后调用jniRegisterNativeMethods函数 123456789101112131415161718int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)&#123; JNIEnv* e = reinterpret_cast&lt;JNIEnv*&gt;(env); ALOGV(\"Registering %s's %d native methods...\", className, numMethods); scoped_local_ref&lt;jclass&gt; c(env, findClass(env, className)); ALOG_ALWAYS_FATAL_IF(c.get() == NULL, \"Native registration unable to find class '%s'; aborting...\", className); int result = e-&gt;RegisterNatives(c.get(), gMethods, numMethods); ALOG_ALWAYS_FATAL_IF(result &lt; 0, \"RegisterNatives failed for '%s'; aborting...\", className); return 0;&#125; 这个函数先通过Java类名获得一个jclass对象，接着调用JNIEnv::RegisterNatives函数，这个函数定义在jni.h中，实现在libart.so库中，我们在平时开发jni的时候，动态注册native方法的时候就会使用到它，这里就不再往下分析了 进入JAVA世界JVM启动好了，JNI函数也注册完毕了，接下来就该进入到JAVA世界了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... //创建一个Java层的String数组用来装参数 jclass stringClass; jobjectArray strArray; jstring classNameStr; stringClass = env-&gt;FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //第一个参数是类名com.android.internal.os.ZygoteInit classNameStr = env-&gt;NewStringUTF(className); assert(classNameStr != NULL); env-&gt;SetObjectArrayElement(strArray, 0, classNameStr); //剩下来参数分别是start-system-server和abi-list for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr); &#125; /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //将Java类名中的\".\"替换成\"/\"，这是JNI中的类名规则 char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; //获取ZygoteInit中的main方法，参数为String类型，返回值为void jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; //执行ZygoteInit的main方法 env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //后面的代码除非JVM挂了，否则不会执行 ... &#125; &#125; ...&#125; 这里看不懂的自己先补一下JNI知识，总之就是调用了com.android.internal.os.ZygoteInit类的静态方法main，以com.android.internal.os.ZygoteInit，start-system-server和abi-list作为参数 ZygoteInitZygoteInit类的源码路径为frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 我们这就开始分析它的main方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public static void main(String argv[]) &#123; ZygoteServer zygoteServer = null; // Mark zygote start. This ensures that thread creation will throw // an error. //标记着zygote开始启动，不允许创建线程（Zygote必须保证单线程） ZygoteHooks.startZygoteNoThreadCreation(); // Zygote goes into its own process group. //设置进程组id try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to setpgid(0,0)\", ex); &#125; Runnable caller; try &#123; ... //配置参数 boolean startSystemServer = false; String zygoteSocketName = \"zygote\"; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (\"--enable-lazy-preload\".equals(argv[i])) &#123; enableLazyPreload = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; //public static final String PRIMARY_SOCKET_NAME = \"zygote\"; final boolean isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME); ... if (!enableLazyPreload) &#123; ... //预加载 preload(bootTimingsTraceLog); ... &#125; ... //调用Java层的垃圾回收 gcAndFinalize(); ... //回调AppRRuntime中的onZygoteInit函数 Zygote.initNativeState(isPrimaryZygote); //解除创建线程限制（马上就要执行fork了，子进程要有能力创建线程） ZygoteHooks.stopZygoteNoThreadCreation(); //创建socket zygoteServer = new ZygoteServer(isPrimaryZygote); //启动SystemServer if (startSystemServer) &#123; Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; r.run(); return; &#125; &#125; Log.i(TAG, \"Accepting command socket connections\"); // The select loop returns early in the child process after a fork and // loops forever in the zygote. //执行死循环监听socket，负责接收事件，启动App caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, \"System zygote died with exception\", ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // We're in the child process and have exited the select loop. Proceed to execute the // command. //接收到AMS的启动App请求后，fork出子进程，处理App启动 if (caller != null) &#123; caller.run(); &#125;&#125; 先调用ZygoteHooks.startZygoteNoThreadCreation()禁止创建线程，Zygote必须保证单线程，这和fork机制有关，fork函数只会将当前线程复制到子进程，同时，fork会将锁也复制到子进程中，如果在fork之前，有一个线程持有了锁，但是fork的时候没把这个线程复制到子进程中，这把锁就被永久持有了，会造成死锁 android.system.Os我们看一下Os是什么，根据import我们知道它的全限定类名为android.system.Os，它的源码路径为libcore/luni/src/main/java/android/system/Os.java 123456789...import libcore.io.Libcore;public final class Os &#123; private Os() &#123;&#125; ... public static void setpgid(int pid, int pgid) throws ErrnoException &#123; Libcore.os.setpgid(pid, pgid); &#125; ...&#125; 它里面全是这种形式的静态代理方法，实际调用Libcore.os执行，我们就以setpgid方法去追踪一下 Libcore位于libcore/luni/src/main/java/libcore/io/Libcore.java，os是其中的一个静态变量 1234567891011121314151617181920212223public final class Libcore &#123; private Libcore() &#123; &#125; /** * Direct access to syscalls. Code should strongly prefer using &#123;@link #os&#125; * unless it has a strong reason to bypass the helpful checks/guards that it * provides. */ public static final Os rawOs = new Linux(); /** * Access to syscalls with helpful checks/guards. * For read access only; the only supported way to update this field is via * &#123;@link #compareAndSetOs&#125;. */ @UnsupportedAppUsage public static volatile Os os = new BlockGuardOs(rawOs); public static Os getOs() &#123; return os; &#125; ...&#125; os的类型为BlockGuardOs，以Linux类型的常量rawOs作为构造方法参数实例化，它继承自ForwardingOs 12345678910111213public class ForwardingOs implements Os &#123; @UnsupportedAppUsage private final Os os; @UnsupportedAppUsage @libcore.api.CorePlatformApi protected ForwardingOs(Os os) &#123; this.os = Objects.requireNonNull(os); &#125; ... public void setpgid(int pid, int pgid) throws ErrnoException &#123; os.setpgid(pid, pgid); &#125; ...&#125; 可以看到，这其实又是一个代理类，实际上是直接调用了Linux类的方法，至于BlockGuardOs，它在部分方法上做了一些回调监听，除此之外也是直接调用了Linux类的方法 1234567public final class Linux implements Os &#123; Linux() &#123; &#125; ... public native int getpgid(int pid); ...&#125; 里面基本上都是JNI调用native方法，对应的c++源码路径为libcore/luni/src/main/native/libcore_io_Linux.cpp，下面是注册JNI函数的函数 12345678910111213141516171819202122232425262728293031323334#define NATIVE_METHOD(className, functionName, signature) \\ MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName) #define MAKE_JNI_NATIVE_METHOD(name, signature, function) \\ _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function) #define _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \\ MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn) #define MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \\ ([]() &#123; \\ using namespace nativehelper::detail; /* NOLINT(google-build-using-namespace) */ \\ static_assert( \\ MatchJniDescriptorWithFunctionType&lt;native_kind, \\ decltype(fn), \\ fn, \\ sizeof(signature_)&gt;(signature_),\\ \"JNI signature doesn't match C++ function type.\"); \\ /* Suppress implicit cast warnings by explicitly casting. */ \\ return JNINativeMethod &#123; \\ const_cast&lt;decltype(JNINativeMethod::name)&gt;(name_), \\ const_cast&lt;decltype(JNINativeMethod::signature)&gt;(signature_), \\ reinterpret_cast&lt;void*&gt;(&amp;(fn))&#125;; \\ &#125;)()static JNINativeMethod gMethods[] = &#123; ... NATIVE_METHOD(Linux, setpgid, \"(II)V\"), ...&#125;;void register_libcore_io_Linux(JNIEnv* env) &#123; ... jniRegisterNativeMethods(env, \"libcore/io/Linux\", gMethods, NELEM(gMethods));&#125; 可以看到，Java层方法对应native方法的格式为Linux_方法名，我们通过这种规则找到setpgid方法对应的函数 123static void Linux_setpgid(JNIEnv* env, jobject, jint pid, int pgid) &#123; throwIfMinusOne(env, \"setpgid\", TEMP_FAILURE_RETRY(setpgid(pid, pgid)));&#125; 可以看到是直接调用了Linux系统层函数 总结综上所述，android.system.Os类存在的意义是可以使Java层能够方便的调用Linux系统方法 预加载接下来就是一些参数配置工作，然后调用preload预加载 12345678910111213141516171819202122232425262728static void preload(TimingsTraceLog bootTimingsTraceLog) &#123; ... //预加载Java类 preloadClasses(); ... //加载三个jar文件 /* /system/framework/android.hidl.base-V1.0-java.jar */ /* /system/framework/android.hidl.manager-V1.0-java.jar */ /* /system/framework/android.test.base.jar */ cacheNonBootClasspathClassLoaders(); ... //预加载系统资源 preloadResources(); ... //预加载硬件抽象层？ nativePreloadAppProcessHALs(); ... //预加载opengl maybePreloadGraphicsDriver(); ... //预加载动态库 preloadSharedLibraries(); //TextView预加载Font preloadTextResources(); //预加载webviewchromium WebViewFactory.prepareWebViewInZygote(); ...&#125; preloadClasses我们看看Java类的预加载 1234567891011121314151617181920212223242526272829303132333435363738394041private static final String PRELOADED_CLASSES = \"/system/etc/preloaded-classes\";private static void preloadClasses() &#123; final VMRuntime runtime = VMRuntime.getRuntime(); InputStream is; try &#123; is = new FileInputStream(PRELOADED_CLASSES); &#125; catch (FileNotFoundException e) &#123; Log.e(TAG, \"Couldn't find \" + PRELOADED_CLASSES + \".\"); return; &#125; ... try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE); int count = 0; String line; while ((line = br.readLine()) != null) &#123; // Skip comments and blank lines. line = line.trim(); if (line.startsWith(\"#\") || line.equals(\"\")) &#123; continue; &#125; ... //Java类加载器加载类 Class.forName(line, true, null); count++; ... &#125; Log.i(TAG, \"...preloaded \" + count + \" classes in \" + (SystemClock.uptimeMillis() - startTime) + \"ms.\"); &#125; catch (IOException e) &#123; Log.e(TAG, \"Error reading \" + PRELOADED_CLASSES + \".\", e); &#125; finally &#123; ... &#125;&#125; 主要的代码就是从/system/etc/preloaded-classes这个文件中读取出需要预加载的类，再通过Class.forName使用类加载器加载一遍，编译前的路径为frameworks/base/config/preloaded-classes 为什么需要预加载Zygote进程的一大作用就是孵化App，那是怎么孵化的呢？这过程中肯定要使用到fork，我们知道，fork后，父子进程是可以共享资源的，既然我们每启动一个App，都需要使用虚拟机、加载一些View等必要的类等等，那为何不在父进程中加载好这些，fork后子进程不就可以直接使用它们了吗？这就是Zygote进程预加载的原因 启动binder线程池预加载结束后，会先清理一下Java层的垃圾，然后调用Zygote.initNativeState(isPrimaryZygote)方法，这个方法调用了native方法nativeInitNativeState，这个方法是在AndroidRuntime中注册的，同时也实现在AndroidRuntime中， 1234static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; gCurRuntime-&gt;onZygoteInit();&#125; 我们之前分析过，执行的是AndroidRuntime的子类AppRuntime的onZygoteInit函数 123456virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); ALOGV(\"App process: starting thread pool.\\n\"); proc-&gt;startThreadPool();&#125; 通过这个函数启动Binder线程池，至于Binder的细节，我们留到以后再分析 启动SystemServerZygote进程孵化的第一个进程便是SystemServer，具体怎么孵化的，孵化后SystemServer又做了什么，留在下一节我们再分析 ZygoteServer构造方法我们知道，我们App都是从Zygote孵化而来的，App启动是从ActivityManagerService的startActivity方法开始的，那么AMS是怎么和Zygote通信的呢，答案是通过socket 我们先从ZygoteServer的构造方法开始看起 12345678910ZygoteServer(boolean isPrimaryZygote) &#123; ... if (isPrimaryZygote) &#123; mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME); ... &#125; else &#123; ... &#125; ...&#125; 其中有一些东西是和USAP机制有关的，但在AOSP中默认是关闭的，关于USAP机制我们以后再分析，现在只需要关注mZygoteSocket就可以了，它是通过调用Zygote.createManagedSocketFromInitSocket赋值的 12345678910111213141516171819202122static LocalServerSocket createManagedSocketFromInitSocket(String socketName) &#123; int fileDesc; //ANDROID_SOCKET_zygote final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; //获得文件描述符 String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; throw new RuntimeException(\"Socket unset or invalid: \" + fullSocketName, ex); &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); return new LocalServerSocket(fd); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"Error building socket from file descriptor: \" + fileDesc, ex); &#125;&#125; 很简单，就是从系统属性中获取一个fd，然后实例化LocalServerSocket，路径为frameworks/base/core/java/android/net/LocalServerSocket.java 123456public LocalServerSocket(FileDescriptor fd) throws IOException&#123; impl = new LocalSocketImpl(fd); impl.listen(LISTEN_BACKLOG); localAddress = impl.getSockAddress();&#125; 在内部创建了一个LocalSocketImpl，然后调用了listen方法声明开始监听这个fd，内部调用了Linux的listen函数 runSelectLoop然后我们来看在ZygoteInit中调用的runSelectLoop方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192Runnable runSelectLoop(String abiList) &#123; ArrayList&lt;FileDescriptor&gt; socketFDs = new ArrayList&lt;&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;&gt;(); //将server socket fd加到列表头（后面需要判断是否为server socket） socketFDs.add(mZygoteSocket.getFileDescriptor()); peers.add(null); ... while (true) &#123; ... StructPollfd[] pollFDs; ... pollFDs = new StructPollfd[socketFDs.size()]; int pollIndex = 0; for (FileDescriptor socketFD : socketFDs) &#123; pollFDs[pollIndex] = new StructPollfd(); pollFDs[pollIndex].fd = socketFD; pollFDs[pollIndex].events = (short) POLLIN; ++pollIndex; &#125; ... //上面一大段都与USAP机制有关，这里先不关注 int pollReturnValue; try &#123; //等待文件描述符上的事件 pollReturnValue = Os.poll(pollFDs, pollTimeoutMs); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"poll failed\", ex); &#125; if (pollReturnValue == 0) &#123; //没有接收到事件（超时），从循环开头重新开始等待事件 ... &#125; else &#123; ... while (--pollIndex &gt;= 0) &#123; //没有要读取的数据，跳过 if ((pollFDs[pollIndex].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (pollIndex == 0) &#123; //pollIndex == 0说明这个fd是ZygoteServer socket的fd //接受并建立一个socket连接 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); //将client socket fd加入列表 socketFDs.add(newPeer.getFileDescriptor()); &#125; else if (pollIndex &lt; usapPoolEventFDIndex) &#123; //不使用USAP机制的话，pollIndex &lt; usapPoolEventFDIndex条件一定成立 //进入这边说明是client socket try &#123; //内部执行fork，返回一个待执行Runnable用于处理子进程后续任务 ZygoteConnection connection = peers.get(pollIndex); final Runnable command = connection.processOneCommand(this); //fork后，在子进程中会将这个变量设为true if (mIsForkChild) &#123; //子进程中 if (command == null) &#123; throw new IllegalStateException(\"command == null\"); &#125; //return出去，由ZygoteInit执行这个Runnable return command; &#125; else &#123; //父进程中 if (command != null) &#123; throw new IllegalStateException(\"command != null\"); &#125; //读取完了，关闭这个socket，清理列表 if (connection.isClosedByPeer()) &#123; connection.closeSocket(); peers.remove(pollIndex); socketFDs.remove(pollIndex); &#125; &#125; &#125; catch (Exception e) &#123; ... &#125; finally &#123; mIsForkChild = false; &#125; &#125; else &#123; ... //不开启USAP机制不会走到这个分支 &#125; &#125; ... &#125; ... &#125;&#125; 创建两个列表，socketFDs和peers的下标是一一对应的，首先将server socket fd添加到列表头，方便后续判断事件是来自client或是server socker，peers列表也要添加一个null作为socketFDs的对应 接着就开始执行死循环，Zygote进程永远不会退出这个循环，只有fork出子进程后，子进程会主动return poll为了理解后面的内容，我们先要学习一下poll函数 poll是Linux中的字符设备驱动中的一个函数，它的作用是等待文件描述符上的某个事件 原型：int poll(struct pollfd * fds , nfds_t nfds , int timeout ); 文档：https://man7.org/linux/man-pages/man2/poll.2.html 第一个参数是一个pollfd结构体指针 12345struct pollfd &#123; int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */&#125;; fd不用多说，就是文件描述符 event代表关注哪些事件，POLLIN代表可读，POLLOUT代表可写等等 revents是由内核通知的，函数返回的时候，会设置对应的fd实际发生的事件，比如fd有可读的事件，设置POLLIN 第二个参数nfds表示fd的个数，即pollfd数组的size 第三个参数表示超时时间 返回值： 大于0：表示有fd事件产生，值为有产生事件的fd的个数 等于0：表示超时 小于0：表示有错误产生 StructPollfd &amp; pollfd弄懂poll是干嘛的后，我们再来接着看runSelectLoop方法 死循环中首先创建了一个StructPollfd数组，它根据socketFDs依次创建出一个个StructPollfd对象，并将他们的事件都设为POLLIN可读 StructPollfd和c中的结构体pollfd是对应的，目的是为了方便Java层调用Linux的poll函数 StructPollfd的路径为libcore/luni/src/main/java/android/system/StructPollfd.java 1234567public final class StructPollfd &#123; public FileDescriptor fd; public short events; public short revents; public Object userData; ...&#125; 调用然后调用Os.poll方法 关于Os我们上面刚分析过，知道他调用了JNI函数，native函数命名格式为Linux_函数名，我们去libcore/luni/src/main/native/libcore_io_Linux.cpp中找一下 123456789101112131415161718static jint Linux_poll(JNIEnv* env, jobject, jobjectArray javaStructs, jint timeoutMs) &#123; ... //把Java对象StructPollfd数组转换成c中的struct pollfd数组 int rc; while (true) &#123; ... rc = poll(fds.get(), count, timeoutMs); if (rc &gt;= 0 || errno != EINTR) &#123; break; &#125; ... &#125; if (rc == -1) &#123; throwErrnoException(env, \"poll\"); return -1; &#125; ... //设置Java对象StructPollfd的revents值 return rc;&#125; 简单看一下，就是把传进去的StructPollfd数组转换成了struct pollfd数组，然后调用Linux poll函数，再把revents写进StructPollfd对象中，最后返回 再看回runSelectLoop方法，如果poll执行返回值为-1，会直接引发一个Java异常，其他情况先判断一下poll的返回值，如果为0，则没有事件产生，否则会从后向前依次判断pollFDs的revents，如果为POLLIN可读，则处理，不可读则跳过 建立连接我们先看第一次poll到事件的情况，这时候，pollFDs中只有一个zygote socket fd，收到可读事件，说明有客户端socket向zygote socket请求发起连接，这时候我们调用acceptCommandPeer方法建立新连接 12345678private ZygoteConnection acceptCommandPeer(String abiList) &#123; try &#123; return createNewConnection(mZygoteSocket.accept(), abiList); &#125; catch (IOException ex) &#123; throw new RuntimeException( \"IOException during accept()\", ex); &#125;&#125; 调用了mZygoteSocket.accept方法 12345678public LocalSocket accept() throws IOException&#123; LocalSocketImpl acceptedImpl = new LocalSocketImpl(); impl.accept(acceptedImpl); return LocalSocket.createLocalSocketForAccept(acceptedImpl);&#125; 新建了一个LocalSocketImpl(client socket) 实例，然后调用LocalSocketImpl(zygote socket) 的accept方法 123456789101112protected void accept(LocalSocketImpl s) throws IOException &#123; if (fd == null) &#123; throw new IOException(\"socket not created\"); &#125; try &#123; s.fd = Os.accept(fd, null /* address */); s.mFdCreatedInternally = true; &#125; catch (ErrnoException e) &#123; throw e.rethrowAsIOException(); &#125;&#125; 调用了Linux的accept函数，接受建立连接，并返回了一个新的client socket fd，将LocalSocketImpl中的fd变量设置为这个fd，接着调用LocalSocket.createLocalSocketForAccept将LocalSocketImpl包装成LocalSocket 1234567891011static LocalSocket createLocalSocketForAccept(LocalSocketImpl impl) &#123; return createConnectedLocalSocket(impl, SOCKET_UNKNOWN);&#125;private static LocalSocket createConnectedLocalSocket(LocalSocketImpl impl, int sockType) &#123; LocalSocket socket = new LocalSocket(impl, sockType); socket.isConnected = true; socket.isBound = true; socket.implCreated = true; return socket;&#125; 然后使用这个LocalSocket创建了一个ZygoteConnection包装socket连接 1234protected ZygoteConnection createNewConnection(LocalSocket socket, String abiList) throws IOException &#123; return new ZygoteConnection(socket, abiList);&#125; 我们看一下构造方法做了什么 1234567891011ZygoteConnection(LocalSocket socket, String abiList) throws IOException &#123; mSocket = socket; this.abiList = abiList; mSocketOutStream = new DataOutputStream(socket.getOutputStream()); mSocketReader = new BufferedReader( new InputStreamReader(socket.getInputStream()), Zygote.SOCKET_BUFFER_SIZE); ... isEof = false;&#125; 打开了client socket的输入输出流，准备读写数据了 然后将这个连接和fd分别添加进peers和socketFDs 执行client socket命令在第二次循环中pollFDs数组中便包括了新建立连接的client socket了，这时调用Os.poll，可以获得到这个client socket的可读事件，此时调用connection.processOneCommand方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Runnable processOneCommand(ZygoteServer zygoteServer) &#123; String[] args; try &#123; //读取从client socket传来的参数 args = Zygote.readArgumentList(mSocketReader); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"IOException on command socket\", ex); &#125; ... int pid; FileDescriptor childPipeFd = null; FileDescriptor serverPipeFd = null; //解析参数 ZygoteArguments parsedArgs = new ZygoteArguments(args); ... //一系列参数校验工作 //创建子进程 pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids, parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo, parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote, parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp, parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList, parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs); try &#123; if (pid == 0) &#123; //子进程中 //设置mIsForkChild = true zygoteServer.setForkChild(); //子进程中关闭fork复制来的zygote socket zygoteServer.closeServerSocket(); IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; return handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote); &#125; else &#123; //父进程中 IoUtils.closeQuietly(childPipeFd); childPipeFd = null; handleParentProc(pid, serverPipeFd); return null; &#125; &#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd); &#125;&#125; 启动APP进程首先读取从client socket传来的参数，然后校验这些参数，完毕后调用Zygote.forkAndSpecialize方法fork出子进程 12345678910111213141516171819static int forkAndSpecialize(int uid, int gid, int[] gids, int runtimeFlags, int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose, int[] fdsToIgnore, boolean startChildZygote, String instructionSet, String appDataDir, boolean isTopApp, String[] pkgDataInfoList, String[] whitelistedDataInfoList, boolean bindMountAppDataDirs, boolean bindMountAppStorageDirs) &#123; //停止其他线程 ZygoteHooks.preFork(); //fork进程 int pid = nativeForkAndSpecialize( uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose, fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp, pkgDataInfoList, whitelistedDataInfoList, bindMountAppDataDirs, bindMountAppStorageDirs); ... //恢复其他线程 ZygoteHooks.postForkCommon(); return pid;&#125; Zygote进程启动了4个线程： HeapTaskDaemon ReferenceQueueDaemon FinalizerDaemon FinalizerWatchdogDaemon 之前上面也分析过了多线程对fork会产生影响，所以这里先把其他线程停了，等fork完了再重新启动 然后执行native函数nativeForkAndSpecialize，路径为frameworks/base/core/jni/com_android_internal_os_Zygote.cpp 1234567891011121314151617181920212223static jint com_android_internal_os_Zygote_nativeForkAndSpecialize( JNIEnv* env, jclass, jint uid, jint gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jint mount_external, jstring se_info, jstring nice_name, jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote, jstring instruction_set, jstring app_data_dir, jboolean is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, jboolean mount_data_dirs, jboolean mount_storage_dirs) &#123; ... pid_t pid = ForkCommon(env, false, fds_to_close, fds_to_ignore, true); if (pid == 0) &#123; SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits, capabilities, capabilities, mount_external, se_info, nice_name, false, is_child_zygote == JNI_TRUE, instruction_set, app_data_dir, is_top_app == JNI_TRUE, pkg_data_info_list, whitelisted_data_info_list, mount_data_dirs == JNI_TRUE, mount_storage_dirs == JNI_TRUE); &#125; return pid;&#125; 先调用ForkCommon，再在子进程调用SpecializeCommon 123456789101112131415161718static pid_t ForkCommon(JNIEnv* env, bool is_system_server, const std::vector&lt;int&gt;&amp; fds_to_close, const std::vector&lt;int&gt;&amp; fds_to_ignore, bool is_priority_fork) &#123; //设置子进程信号处理函数 SetSignalHandlers(); ... //fork前先阻塞SIGCHLD信号 BlockSignal(SIGCHLD, fail_fn); ... //执行fork pid_t pid = fork(); ... //恢复SIGCHLD信号 UnblockSignal(SIGCHLD, fail_fn); return pid;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static void SpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids, jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities, jlong effective_capabilities, jint mount_external, jstring managed_se_info, jstring managed_nice_name, bool is_system_server, bool is_child_zygote, jstring managed_instruction_set, jstring managed_app_data_dir, bool is_top_app, jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list, bool mount_data_dirs, bool mount_storage_dirs) &#123; const char* process_name = is_system_server ? \"system_server\" : \"zygote\"; ... //创建进程组 if (!is_system_server &amp;&amp; getuid() == 0) &#123; const int rc = createProcessGroup(uid, getpid()); if (rc == -EROFS) &#123; ALOGW(\"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?\"); &#125; else if (rc != 0) &#123; ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, /* pid= */ 0, strerror(-rc)); &#125; &#125; //设置GroupId SetGids(env, gids, is_child_zygote, fail_fn); //设置资源Limit SetRLimits(env, rlimits, fail_fn); ... //设置调度策略 SetSchedulerPolicy(fail_fn, is_top_app); ... //设置线程名 if (nice_name.has_value()) &#123; SetThreadName(nice_name.value()); &#125; else if (is_system_server) &#123; SetThreadName(\"system_server\"); &#125; //子进程中不再处理SIGCHLD信号 UnsetChldSignalHandler(); ... if (is_child_zygote) &#123; initUnsolSocketToSystemServer(); &#125; //调用Zygote.callPostForkChildHooks方法 env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags, is_system_server, is_child_zygote, managed_instruction_set); //设置默认进程优先级 setpriority(PRIO_PROCESS, 0, PROCESS_PRIORITY_DEFAULT); if (env-&gt;ExceptionCheck()) &#123; fail_fn(\"Error calling post fork hooks.\"); &#125;&#125; 子进程创建完成后，ZygoteConnection在子进程中会返回handleChildProc，在父进程中会返回null 在ZygoteServer中做了判断，如果为子进程且command不为null，返回common到ZygoteInit，如果是父进程，继续socket poll循环 在ZygoteInit.runSelectLoop后，如果返回值caller（对应ZygoteServer中的command）不为null，则执行这个Runnable 我们看一下handleChildProc做了什么 1234567891011121314151617181920212223242526272829private Runnable handleChildProc(ZygoteArguments parsedArgs, FileDescriptor pipeFd, boolean isZygote) &#123; //在子进程中关闭发起启动App请求的client socket closeSocket(); //设置进程名 Zygote.setAppProcessName(parsedArgs, TAG); ... if (parsedArgs.mInvokeWith != null) &#123; //和进程内存泄露或溢出有关？ WrapperInit.execApplication(parsedArgs.mInvokeWith, parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion, VMRuntime.getCurrentInstructionSet(), pipeFd, parsedArgs.mRemainingArgs); // Should not get here. throw new IllegalStateException(\"WrapperInit.execApplication unexpectedly returned\"); &#125; else &#123; if (!isZygote) &#123; //根据参数，执行这个方法 return ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mDisabledCompatChanges, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; else &#123; return ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion, parsedArgs.mRemainingArgs, null /* classLoader */); &#125; &#125;&#125; 执行ZygoteInit.zygoteInit 123456789101112public static final Runnable zygoteInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; ... //重定向Log RuntimeInit.redirectLogStreams(); //通用初始化 RuntimeInit.commonInit(); //之前有提到，开启binder线程池 ZygoteInit.nativeZygoteInit(); return RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv, classLoader);&#125; RuntimeInit的路径为frameworks/base/core/java/com/android/internal/os/RuntimeInit.java，先执行通用初始化 12345678910111213141516171819202122protected static final void commonInit() &#123; //设置默认线程异常处理器 LoggingHandler loggingHandler = new LoggingHandler(); RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler); Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)); //设置时区 RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(\"persist.sys.timezone\")); //重置Log配置 LogManager.getLogManager().reset(); new AndroidConfig(); //设置网络UA信息 String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); //初始化网络流量统计 NetworkManagementSocketTagger.install(); ... initialized = true;&#125; 然后执行RuntimeInit.applicationInit 12345678910111213protected static Runnable applicationInit(int targetSdkVersion, long[] disabledCompatChanges, String[] argv, ClassLoader classLoader) &#123; //如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数 nativeSetExitWithoutCleanup(true); //设置虚拟机参数 VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges); //解析参数 final Arguments args = new Arguments(argv); ... //查找startClass中的main方法 return findStaticMain(args.startClass, args.startArgs, classLoader);&#125; 这里的startClass为android.app.ActivityThread 12345678910111213141516171819202122232425262728293031323334353637protected static Runnable findStaticMain(String className, String[] argv, ClassLoader classLoader) &#123; Class&lt;?&gt; cl; try &#123; cl = Class.forName(className, true, classLoader); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( \"Missing class when invoking static main \" + className, ex); &#125; Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; throw new RuntimeException( \"Missing static main on \" + className, ex); &#125; catch (SecurityException ex) &#123; throw new RuntimeException( \"Problem getting static main on \" + className, ex); &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; throw new RuntimeException( \"Main method is not public and static on \" + className); &#125; /* * This throw gets caught in ZygoteInit.main(), which responds * by invoking the exception's run() method. This arrangement * clears up all the stack frames that were required in setting * up the process. */ return new MethodAndArgsCaller(m, argv);&#125; 这里使用了Java中的反射，找到了ActivityThread中对应的main方法，并用其创建了一个Runnable对象MethodAndArgsCaller 1234567891011121314151617181920212223242526static class MethodAndArgsCaller implements Runnable &#123; private final Method mMethod; private final String[] mArgs; public MethodAndArgsCaller(Method method, String[] args) &#123; mMethod = method; mArgs = args; &#125; public void run() &#123; try &#123; //执行ActivityThread.main方法 mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; 之前说了，在ZygoteInit.runSelectLoop后，如果返回值caller不为null，则执行这个Runnable，即执行MethodAndArgsCaller的run方法，反射调用ActivityThread.main方法 结束至此，Zygote进程部分的分析就到此为止了，后面fork出App进程那段讲的很粗糙，后面写到App启动那块的时候，我会重新梳理一遍这里的逻辑，补充上去","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"Zygote","slug":"Zygote","permalink":"http://yoursite.com/tags/Zygote/"}]},{"title":"Android源码分析 - init进程","slug":"android/aosp/Android源码分析-init进程","date":"2022-01-04T09:19:00.000Z","updated":"2022-11-13T09:55:54.357Z","comments":true,"path":"2022/01/04/android/aosp/Android源码分析-init进程/","link":"","permalink":"http://yoursite.com/2022/01/04/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-init%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"开篇本篇以android-11.0.0_r25作为基础解析 PC启动会通过BIOS引导，从0x7c00处找到以0xaa55为结尾的引导程序启动。而Android通常使用在移动设备上，没有PC的BIOS，取而代之的是BootLoader。 BootLoader在CPU上电复位完成后，会从一个固定的地址加载一段程序，即BootLoader，不同的CPU可能这个地址不同。BootLoader是一段引导程序，其中最为常见的为U-boot，它一般会先检测用户是否按下某些特别按键，这些特别按键是uboot在编译时预先被约定好的，用于进入调试模式。如果用户没有按这些特别的按键，则uboot会从NAND Flash中装载Linux内核，装载的地址是在编译uboot时预先约定好的。 进程idleLinux内核启动后，便会创建第一个进程idle。idle进程是Linux中的第一个进程，pid为0，是唯一一个没有通过fork产生的进程，它的优先级非常低，用于CPU没有任务的时候进行空转。 initinit进程由idle进程创建，是Linux系统的第一个用户进程，pid为1，是系统所有用户进程的直接或间接父进程，本篇重点讲的就是它。 kthreaddkthreadd进程同样由idle进程创建，pid为2，它始终运行在内核空间，负责所有内核线程的调度与管理。 init进程Android的init进程代码在system/core/init/main.cpp中，以main方法作为入口，分为几个阶段： 12345678910111213141516171819202122232425262728int main(int argc, char** argv) &#123;#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#endif if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; if (!strcmp(argv[1], \"subcontext\")) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], \"selinux_setup\")) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], \"second_stage\")) &#123; return SecondStageMain(argc, argv); &#125; &#125; return FirstStageMain(argc, argv);&#125; 这里的ueventd和subcontext，都是在各自守护进程中执行的，不在init进程中执行，这里就不多介绍了 FirstStageMain默认不加任何参数启动init的话，便会开始init第一阶段，进入到FirstStageMain函数中，代码在system/core/init/first_stage_init.cpp中 umask文档：https://man7.org/linux/man-pages/man2/umask.2.html 原型：mode_t umask(mode_t mask); 这个方法是用来设置创建目录或文件时所应该赋予权限的掩码 Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755 在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高 创建目录、设备节点，挂载1234567891011121314151617181920212223242526272829303132333435363738394041424344int FirstStageMain(int argc, char** argv) &#123; ...#define CHECKCALL(x) \\ if ((x) != 0) errors.emplace_back(#x \" failed\", errno); // Clear the umask. umask(0); CHECKCALL(clearenv()); CHECKCALL(setenv(\"PATH\", _PATH_DEFPATH, 1)); CHECKCALL(mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\")); CHECKCALL(mkdir(\"/dev/pts\", 0755)); CHECKCALL(mkdir(\"/dev/socket\", 0755)); CHECKCALL(mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL));#define MAKE_STR(x) __STRING(x) CHECKCALL(mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)));#undef MAKE_STR CHECKCALL(chmod(\"/proc/cmdline\", 0440)); std::string cmdline; android::base::ReadFileToString(\"/proc/cmdline\", &amp;cmdline); gid_t groups[] = &#123;AID_READPROC&#125;; CHECKCALL(setgroups(arraysize(groups), groups)); CHECKCALL(mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL)); CHECKCALL(mount(\"selinuxfs\", \"/sys/fs/selinux\", \"selinuxfs\", 0, NULL)); CHECKCALL(mknod(\"/dev/kmsg\", S_IFCHR | 0600, makedev(1, 11))); if constexpr (WORLD_WRITABLE_KMSG) &#123; CHECKCALL(mknod(\"/dev/kmsg_debug\", S_IFCHR | 0622, makedev(1, 11))); &#125; CHECKCALL(mknod(\"/dev/random\", S_IFCHR | 0666, makedev(1, 8))); CHECKCALL(mknod(\"/dev/urandom\", S_IFCHR | 0666, makedev(1, 9))); CHECKCALL(mknod(\"/dev/ptmx\", S_IFCHR | 0666, makedev(5, 2))); CHECKCALL(mknod(\"/dev/null\", S_IFCHR | 0666, makedev(1, 3))); CHECKCALL(mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV, \"mode=0755,uid=0,gid=1000\")); CHECKCALL(mkdir(\"/mnt/vendor\", 0755)); CHECKCALL(mkdir(\"/mnt/product\", 0755)); CHECKCALL(mount(\"tmpfs\", \"/debug_ramdisk\", \"tmpfs\", MS_NOEXEC | MS_NOSUID | MS_NODEV, \"mode=0755,uid=0,gid=0\"));#undef CHECKCALL ...&#125; 初始化日志SetStdioToDevNull由于Linux内核打开了/dev/console作为标准输入输出流（stdin/stdout/stderr）的文件描述符，而init进程在用户空间，无权访问/dev/console，后续如果执行printf的话可能会导致错误，所以先调用SetStdioToDevNull函数来将标准输入输出流（stdin/stdout/stderr）用/dev/null文件描述符替换 /dev/null被称为空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，读取它会立即得到一个EOF InitKernelLogging接着调用InitKernelLogging函数，初始化了一个简单的kernel日志系统 创建设备，挂载分区12345678910111213141516171819202122232425262728293031int FirstStageMain(int argc, char** argv) &#123; ... auto want_console = ALLOW_FIRST_STAGE_CONSOLE ? FirstStageConsole(cmdline) : 0; if (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline), want_console)) &#123; if (want_console != FirstStageConsoleParam::DISABLED) &#123; LOG(ERROR) &lt;&lt; \"Failed to load kernel modules, starting console\"; &#125; else &#123; LOG(FATAL) &lt;&lt; \"Failed to load kernel modules\"; &#125; &#125; if (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123; StartConsole(); &#125; if (ForceNormalBoot(cmdline)) &#123; mkdir(\"/first_stage_ramdisk\", 0755); // SwitchRoot() must be called with a mount point as the target, so we bind mount the // target directory to itself here. if (mount(\"/first_stage_ramdisk\", \"/first_stage_ramdisk\", nullptr, MS_BIND, nullptr) != 0) &#123; LOG(FATAL) &lt;&lt; \"Could not bind mount /first_stage_ramdisk to itself\"; &#125; SwitchRoot(\"/first_stage_ramdisk\"); &#125; ... if (!DoFirstStageMount()) &#123; LOG(FATAL) &lt;&lt; \"Failed to mount required partitions early ...\"; &#125; ...&#125; 结束至此，第一阶段的init结束，通过execv函数带参执行init文件，进入SetupSelinux 1234567891011const char* path = \"/system/bin/init\";const char* args[] = &#123;path, \"selinux_setup\", nullptr&#125;;auto fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);dup2(fd, STDOUT_FILENO);dup2(fd, STDERR_FILENO);close(fd);execv(path, const_cast&lt;char**&gt;(args));// execv() only returns if an error happened, in which case we// panic and never fall through this conditional.PLOG(FATAL) &lt;&lt; \"execv(\\\"\" &lt;&lt; path &lt;&lt; \"\\\") failed\"; exec系列函数用exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。 这里在末尾直接打log是因为，exec系列函数如果执行正常是不会返回的，所以只要执行到下面就代表exec执行出错了 SetupSelinux启动Selinux安全机制，初始化selinux，加载SELinux规则，配置SELinux相关log输出，并启动第二阶段：SecondStageMain 123456789101112131415161718192021222324252627282930313233343536int SetupSelinux(char** argv) &#123; SetStdioToDevNull(argv); InitKernelLogging(argv); if (REBOOT_BOOTLOADER_ON_PANIC) &#123; InstallRebootSignalHandlers(); &#125; boot_clock::time_point start_time = boot_clock::now(); MountMissingSystemPartitions(); // Set up SELinux, loading the SELinux policy. SelinuxSetupKernelLogging(); SelinuxInitialize(); // We're in the kernel domain and want to transition to the init domain. File systems that // store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here, // but other file systems do. In particular, this is needed for ramdisks such as the // recovery image for A/B devices. if (selinux_android_restorecon(\"/system/bin/init\", 0) == -1) &#123; PLOG(FATAL) &lt;&lt; \"restorecon failed of /system/bin/init failed\"; &#125; setenv(kEnvSelinuxStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(), 1); const char* path = \"/system/bin/init\"; const char* args[] = &#123;path, \"second_stage\", nullptr&#125;; execv(path, const_cast&lt;char**&gt;(args)); // execv() only returns if an error happened, in which case we // panic and never return from this function. PLOG(FATAL) &lt;&lt; \"execv(\\\"\" &lt;&lt; path &lt;&lt; \"\\\") failed\"; return 1;&#125; SecondStageMain使用second_stage参数启动init的话，便会开始init第二阶段，进入到SecondStageMain函数中，代码在system/core/init/init.cpp中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127int SecondStageMain(int argc, char** argv) &#123; ... //和第一阶段一样，初始化日志 SetStdioToDevNull(argv); InitKernelLogging(argv); LOG(INFO) &lt;&lt; \"init second stage started!\"; ... // Set init and its forked children's oom_adj. //设置init进程和以后fork出来的进程的OOM等级，这里的值为-1000，保证进程不会因为OOM被杀死 if (auto result = WriteFile(\"/proc/1/oom_score_adj\", StringPrintf(\"%d\", DEFAULT_OOM_SCORE_ADJUST)); !result.ok()) &#123; LOG(ERROR) &lt;&lt; \"Unable to write \" &lt;&lt; DEFAULT_OOM_SCORE_ADJUST &lt;&lt; \" to /proc/1/oom_score_adj: \" &lt;&lt; result.error(); &#125; ... // Indicate that booting is in progress to background fw loaders, etc. //设置一个标记，代表正在启动过程中 close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); ... //初始化系统属性 PropertyInit(); ... // Mount extra filesystems required during second stage init //挂载额外的文件系统 MountExtraFilesystems(); // Now set up SELinux for second stage. //设置SELinux SelinuxSetupKernelLogging(); SelabelInitialize(); SelinuxRestoreContext(); //使用epoll，注册信号处理函数，守护进程服务 Epoll epoll; if (auto result = epoll.Open(); !result.ok()) &#123; PLOG(FATAL) &lt;&lt; result.error(); &#125; InstallSignalFdHandler(&amp;epoll); InstallInitNotifier(&amp;epoll); //启动系统属性服务 StartPropertyService(&amp;property_fd); ... //设置commands指令所对应的函数map const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); Action::set_function_map(&amp;function_map); ... //解析init.rc脚本 ActionManager&amp; am = ActionManager::GetInstance(); ServiceList&amp; sm = ServiceList::GetInstance(); LoadBootScripts(am, sm); ... //构建了一些Action，Trigger等事件对象加入事件队列中 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueEventTrigger(\"early-init\"); // Queue an action that waits for coldboot done so we know ueventd has set up all of /dev... am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\"); // ... so that we can start queuing up actions that require stuff from /dev. am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\"); am.QueueBuiltinAction(SetMmapRndBitsAction, \"SetMmapRndBits\"); Keychords keychords; am.QueueBuiltinAction( [&amp;epoll, &amp;keychords](const BuiltinArguments&amp; args) -&gt; Result&lt;void&gt; &#123; for (const auto&amp; svc : ServiceList::GetInstance()) &#123; keychords.Register(svc-&gt;keycodes()); &#125; keychords.Start(&amp;epoll, HandleKeychord); return &#123;&#125;; &#125;, \"KeychordInit\"); // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random // wasn't ready immediately after wait_for_coldboot_done am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, \"MixHwrngIntoLinuxRng\"); // Don't mount filesystems or start core system services in charger mode. std::string bootmode = GetProperty(\"ro.bootmode\", \"\"); if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\"); &#125; else &#123; am.QueueEventTrigger(\"late-init\"); &#125; // Run all property triggers based on current state of the properties. am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\"); //死循环，等待事件处理 while (true) &#123; // By default, sleep until something happens. auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;; ... //执行从init.rc脚本解析出来的每条指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; am.ExecuteOneCommand(); &#125; ... if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; // If there's more work to do, wake up again immediately. if (am.HasMoreCommands()) epoll_timeout = 0ms; &#125; auto pending_functions = epoll.Wait(epoll_timeout); if (!pending_functions.ok()) &#123; LOG(ERROR) &lt;&lt; pending_functions.error(); &#125; else if (!pending_functions-&gt;empty()) &#123; // We always reap children before responding to the other pending functions. This is to // prevent a race where other daemons see that a service has exited and ask init to // start it again via ctl.start before init has reaped it. //处理子进程退出后的相关事项 ReapAnyOutstandingChildren(); for (const auto&amp; function : *pending_functions) &#123; (*function)(); &#125; &#125; ... &#125; return 0;&#125; Linux OOM Killer机制Linux下有一种 OOM KILLER 的机制，它会在系统内存耗尽的情况下，启用自己算法有选择性的杀掉一些进程，这个算法和三个值有关： /proc/PID/oom_score ,OOM 最终得分，值越大越有可能被杀掉 /proc/PID/oom_score_adj ，取值范围为-1000到1000，计算oom_score时会加上该参数 /proc/PID/oom_adj ，取值是-17到+15，该参数主要是为兼容旧版内核 在init过程中，代码设置了init进程和以后fork出来的进程的OOM等级，这里的值为-1000，设置为这个值就可以保证进程永远不会因为OOM被杀死 解析init.rc脚本Android Init Languagerc文件，是用Android Init Language编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀 它的语法说明可以在aosp源码system/core/init/README.md中找到，这里就简单说明一下语法规则 ActionsActions是一系列命令的开始，一个Action会有一个触发器，用于确定Action何时执行。当一个与Action的触发器匹配的事件发生时，该动作被添加到待执行队列的尾部 格式如下： 1234on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* &lt;command&gt; &lt;command&gt; &lt;command&gt; Triggers（触发器）触发器作用于Actions，可用于匹配某些类型的事件，并用于导致操作发生 CommandsCommands就是一个个命令的集合了 Action, Triggers, Commands共同组成了一个单元，举个例子： 1234567on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted # A&#x2F;B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start statsd start netd start zygote start zygote_secondary ServicesServices是对一些程序的定义，格式如下： 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... 其中： name：定义的服务名 pathname：这个程序的路径 argument：程序运行的参数 option：服务选项，后文将介绍 OptionsOptions是对Services的修饰，它们影响着服务运行的方式和时间 Services, Options组成了一个单元，举个例子： 123456789101112131415service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server --socket-name&#x3D;zygote class main priority -20 user root group root readproc reserved_disk socket zygote stream 660 root system socket usap_pool_primary stream 660 root system onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse onrestart write &#x2F;sys&#x2F;power&#x2F;state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd onrestart restart wificond task_profiles ProcessCapacityHigh MaxPerformance Imports导入其他的rc文件或目录解析，如果path是一个目录，目录中的每个文件都被解析为一个rc文件。它不是递归的，嵌套的目录将不会被解析。 格式如下： 1import &lt;path&gt; Imports的内容会放到最后解析 上文所述的Commands，Options等具体命令，可以网上搜索一下，或者自己看system/core/init/README.md Commands的定义可以在system/core/init/builtins.cpp中找到 Options的定义可以在system/core/init/service_parser.cpp中找到 解析12345678910111213141516171819202122232425static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123; Parser parser = CreateParser(action_manager, service_list); std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); if (bootscript.empty()) &#123; parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) &#123; late_import_paths.emplace_back(\"/system/etc/init\"); &#125; // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/product/etc/init\")) &#123; late_import_paths.emplace_back(\"/product/etc/init\"); &#125; if (!parser.ParseConfig(\"/odm/etc/init\")) &#123; late_import_paths.emplace_back(\"/odm/etc/init\"); &#125; if (!parser.ParseConfig(\"/vendor/etc/init\")) &#123; late_import_paths.emplace_back(\"/vendor/etc/init\"); &#125; &#125; else &#123; parser.ParseConfig(bootscript); &#125;&#125; 这个函数会从这些地方寻找rc文件解析，/system/etc/init/hw/init.rc是主rc文件，剩下的目录，如果system分区尚未挂载的话，就把它们加入到late_import_paths中，等到后面mount_all时再加载 主rc文件在编译前的位置为system/core/rootdir/init.rc 简单分析一下： 首先，以ActionManager和ServiceList作为参数创建了一个Parser解析器，解析后的结果会存放在ActionManager和ServiceList中，这里的两个传进来的参数都是单例模式 12345678910Parser CreateParser(ActionManager&amp; action_manager, ServiceList&amp; service_list) &#123; Parser parser; parser.AddSectionParser(\"service\", std::make_unique&lt;ServiceParser&gt;( &amp;service_list, GetSubcontext(), std::nullopt)); parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext())); parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;(&amp;parser)); return parser;&#125; 先创建了一个Parser对象，然后往里面添加了ServiceParser、ActionParser以及ImportParser，这三个类都是继承自ServiceParser，这里的std::make_unique是new了一个对象，并用其原始指针构造出了一个智能指针 接着走到Parser::ParseConfig方法中： 123456bool Parser::ParseConfig(const std::string&amp; path) &#123; if (is_dir(path.c_str())) &#123; return ParseConfigDir(path); &#125; return ParseConfigFile(path);&#125; 判断是否是目录，如果是目录，就把目录中的所有文件加入容器中排序后依次解析 1234567891011121314151617181920212223242526bool Parser::ParseConfigDir(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing directory \" &lt;&lt; path &lt;&lt; \"...\"; std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir); if (!config_dir) &#123; PLOG(INFO) &lt;&lt; \"Could not import directory '\" &lt;&lt; path &lt;&lt; \"'\"; return false; &#125; dirent* current_file; std::vector&lt;std::string&gt; files; while ((current_file = readdir(config_dir.get()))) &#123; // Ignore directories and only process regular files. if (current_file-&gt;d_type == DT_REG) &#123; std::string current_path = android::base::StringPrintf(\"%s/%s\", path.c_str(), current_file-&gt;d_name); files.emplace_back(current_path); &#125; &#125; // Sort first so we load files in a consistent order (bug 31996208) std::sort(files.begin(), files.end()); for (const auto&amp; file : files) &#123; if (!ParseConfigFile(file)) &#123; LOG(ERROR) &lt;&lt; \"could not import file '\" &lt;&lt; file &lt;&lt; \"'\"; &#125; &#125; return true;&#125; 可以看到，最终都调用了Parser::ParseConfigFile方法 1234567891011121314bool Parser::ParseConfigFile(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing file \" &lt;&lt; path &lt;&lt; \"...\"; android::base::Timer t; auto config_contents = ReadFile(path); if (!config_contents.ok()) &#123; LOG(INFO) &lt;&lt; \"Unable to read config file '\" &lt;&lt; path &lt;&lt; \"': \" &lt;&lt; config_contents.error(); return false; &#125; ParseData(path, &amp;config_contents.value()); LOG(VERBOSE) &lt;&lt; \"(Parsing \" &lt;&lt; path &lt;&lt; \" took \" &lt;&lt; t &lt;&lt; \".)\"; return true;&#125; 从文件中读取出字符串，并继续调用Parser::ParseData方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788void Parser::ParseData(const std::string&amp; filename, std::string* data) &#123; data-&gt;push_back('\\n'); // TODO: fix tokenizer data-&gt;push_back('\\0'); parse_state state; state.line = 0; state.ptr = data-&gt;data(); state.nexttoken = 0; SectionParser* section_parser = nullptr; int section_start_line = -1; std::vector&lt;std::string&gt; args; // If we encounter a bad section start, there is no valid parser object to parse the subsequent // sections, so we must suppress errors until the next valid section is found. bool bad_section_found = false; auto end_section = [&amp;] &#123; bad_section_found = false; if (section_parser == nullptr) return; if (auto result = section_parser-&gt;EndSection(); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; section_start_line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; section_parser = nullptr; section_start_line = -1; &#125;; for (;;) &#123; switch (next_token(&amp;state)) &#123; case T_EOF: end_section(); for (const auto&amp; [section_name, section_parser] : section_parsers_) &#123; section_parser-&gt;EndFile(); &#125; return; case T_NEWLINE: &#123; state.line++; if (args.empty()) break; // If we have a line matching a prefix we recognize, call its callback and unset any // current section parsers. This is meant for /sys/ and /dev/ line entries for // uevent. auto line_callback = std::find_if( line_callbacks_.begin(), line_callbacks_.end(), [&amp;args](const auto&amp; c) &#123; return android::base::StartsWith(args[0], c.first); &#125;); if (line_callback != line_callbacks_.end()) &#123; end_section(); if (auto result = line_callback-&gt;second(std::move(args)); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; &#125; else if (section_parsers_.count(args[0])) &#123; end_section(); section_parser = section_parsers_[args[0]].get(); section_start_line = state.line; if (auto result = section_parser-&gt;ParseSection(std::move(args), filename, state.line); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); section_parser = nullptr; bad_section_found = true; &#125; &#125; else if (section_parser) &#123; if (auto result = section_parser-&gt;ParseLineSection(std::move(args), state.line); !result.ok()) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": \" &lt;&lt; result.error(); &#125; &#125; else if (!bad_section_found) &#123; parse_error_count_++; LOG(ERROR) &lt;&lt; filename &lt;&lt; \": \" &lt;&lt; state.line &lt;&lt; \": Invalid section keyword found\"; &#125; args.clear(); break; &#125; case T_TEXT: args.emplace_back(state.text); break; &#125; &#125;&#125; 这里新建了一个parse_state结构体，用来以行为单位，分割整个文件字符串，根据分割出来的结果返回相应的TYPE，Parser::ParseData方法再通过TYPE来做逐行解析 这个结构体以及TPYE和分割分割方法的定义在system/core/init/tokenizer.h中，在system/core/init/tokenizer.cpp中实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122int next_token(struct parse_state *state)&#123; char *x = state-&gt;ptr; char *s; if (state-&gt;nexttoken) &#123; int t = state-&gt;nexttoken; state-&gt;nexttoken = 0; return t; &#125; for (;;) &#123; switch (*x) &#123; case 0: state-&gt;ptr = x; return T_EOF; case '\\n': x++; state-&gt;ptr = x; return T_NEWLINE; case ' ': case '\\t': case '\\r': x++; continue; case '#': while (*x &amp;&amp; (*x != '\\n')) x++; if (*x == '\\n') &#123; state-&gt;ptr = x+1; return T_NEWLINE; &#125; else &#123; state-&gt;ptr = x; return T_EOF; &#125; default: goto text; &#125; &#125;textdone: state-&gt;ptr = x; *s = 0; return T_TEXT;text: state-&gt;text = s = x;textresume: for (;;) &#123; switch (*x) &#123; case 0: goto textdone; case ' ': case '\\t': case '\\r': x++; goto textdone; case '\\n': state-&gt;nexttoken = T_NEWLINE; x++; goto textdone; case '\"': x++; for (;;) &#123; switch (*x) &#123; case 0: /* unterminated quoted thing */ state-&gt;ptr = x; return T_EOF; case '\"': x++; goto textresume; default: *s++ = *x++; &#125; &#125; break; case '\\\\': x++; switch (*x) &#123; case 0: goto textdone; case 'n': *s++ = '\\n'; x++; break; case 'r': *s++ = '\\r'; x++; break; case 't': *s++ = '\\t'; x++; break; case '\\\\': *s++ = '\\\\'; x++; break; case '\\r': /* \\ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */ if (x[1] != '\\n') &#123; x++; continue; &#125; x++; FALLTHROUGH_INTENDED; case '\\n': /* \\ &lt;lf&gt; -&gt; line continuation */ state-&gt;line++; x++; /* eat any extra whitespace */ while((*x == ' ') || (*x == '\\t')) x++; continue; default: /* unknown escape -- just copy */ *s++ = *x++; &#125; continue; default: *s++ = *x++; &#125; &#125; return T_EOF;&#125; 简单来说就是先看看有没有遇到结束符（换行 \\n 或者EOF \\0）或者注释（#）如果遇到了就返回T_NEWLINE或者T_EOF代表这上一行结束了或者整个文件读取完了，没有遇到的话说明读取的是可解析的正文，跳到text段，将文本内容写到state.text中，直到碰到换行符或空格等分割标志（以空格或换行等作为分隔符，一小段一小段的进行分割），将读取到的最后一个正文的位置+1处的字符置为\\0，state.text里的内容便称为了完整一段的内容，接着返回T_TEXT表示已读入一段文本 接着回到Parser::ParseData方法中，如果读到的TYPE是T_TEXT，就将这一段内容先添加到容器中，当读到T_NEWLINE时，解析之前读入的一整行内容，先用args[0]（一行的开头）去寻找我们之前添加的SectionParser，如果能找到，说明这一行是service、on或者import，将section_parser赋值为相应SectionParser子类的指针，调用其ParseSection方法解析，如果读入的一行里，不是以service、on或者import开头，并且之前定义的section_parser不为空指针，说明是service或者on参数的子参数，调用ParseLineSection方法解析子参数，并加入到父参数中。 最后，每次读取完都会执行args.clear()清楚这一行的数据，当读取到新的service、on或者import时，需要先执行EndSection方法，将之前解析好的结构添加到列表中 执行任务回到SecondStageMain中，可以看到，最后有一个死循环，用来等待事件处理 12345678910111213141516171819202122232425262728293031323334int SecondStageMain(int argc, char** argv) &#123; ... while (true) &#123; // By default, sleep until something happens. auto epoll_timeout = std::optional&lt;std::chrono::milliseconds&gt;&#123;&#125;; ... //执行从init.rc脚本解析出来的每条指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; am.ExecuteOneCommand(); &#125; ... if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123; // If there's more work to do, wake up again immediately. if (am.HasMoreCommands()) epoll_timeout = 0ms; &#125; auto pending_functions = epoll.Wait(epoll_timeout); if (!pending_functions.ok()) &#123; LOG(ERROR) &lt;&lt; pending_functions.error(); &#125; else if (!pending_functions-&gt;empty()) &#123; // We always reap children before responding to the other pending functions. This is to // prevent a race where other daemons see that a service has exited and ask init to // start it again via ctl.start before init has reaped it. //处理子进程退出后的相关事项 ReapAnyOutstandingChildren(); for (const auto&amp; function : *pending_functions) &#123; (*function)(); &#125; &#125; ... &#125; return 0;&#125; 其中am.ExecuteOneCommand()方法便是执行从rc文件中解析出来的指令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void ActionManager::ExecuteOneCommand() &#123; &#123; auto lock = std::lock_guard&#123;event_queue_lock_&#125;; // Loop through the event queue until we have an action to execute //当前正在执行的action队列为空，但等待执行的事件队列不为空 while (current_executing_actions_.empty() &amp;&amp; !event_queue_.empty()) &#123; for (const auto&amp; action : actions_) &#123; //从等待执行的事件队列头取出一个元素event， //然后调用action的CheckEvent检查此event是否匹配当前action //如果匹配，将这个action加入到正在执行的actions队列的队尾 if (std::visit([&amp;action](const auto&amp; event) &#123; return action-&gt;CheckEvent(event); &#125;, event_queue_.front())) &#123; current_executing_actions_.emplace(action.get()); &#125; &#125; event_queue_.pop(); &#125; &#125; if (current_executing_actions_.empty()) &#123; return; &#125; //从队列头取一个action（front不会使元素出队） auto action = current_executing_actions_.front(); //如果是第一次执行这个action if (current_command_ == 0) &#123; std::string trigger_name = action-&gt;BuildTriggersString(); LOG(INFO) &lt;&lt; \"processing action (\" &lt;&lt; trigger_name &lt;&lt; \") from (\" &lt;&lt; action-&gt;filename() &lt;&lt; \":\" &lt;&lt; action-&gt;line() &lt;&lt; \")\"; &#125; //这个current_command_是个成员变量，标志着执行到了哪一行 action-&gt;ExecuteOneCommand(current_command_); // If this was the last command in the current action, then remove // the action from the executing list. // If this action was oneshot, then also remove it from actions_. ++current_command_; //current_command_等于action的commands数量，说明这个action以及全部执行完了 if (current_command_ == action-&gt;NumCommands()) &#123; //此action出队 current_executing_actions_.pop(); //重置计数器 current_command_ = 0; if (action-&gt;oneshot()) &#123; auto eraser = [&amp;action](std::unique_ptr&lt;Action&gt;&amp; a) &#123; return a.get() == action; &#125;; actions_.erase(std::remove_if(actions_.begin(), actions_.end(), eraser), actions_.end()); &#125; &#125;&#125; 里面会执行Action::ExecuteOneCommand方法 123456void Action::ExecuteOneCommand(std::size_t command) const &#123; // We need a copy here since some Command execution may result in // changing commands_ vector by importing .rc files through parser Command cmd = commands_[command]; ExecuteCommand(cmd);&#125; 接着调用到了Action::ExecuteCommand方法 123456789101112131415161718void Action::ExecuteCommand(const Command&amp; command) const &#123; android::base::Timer t; //这一行是具体的执行 auto result = command.InvokeFunc(subcontext_); auto duration = t.duration(); // Any action longer than 50ms will be warned to user as slow operation //失败、超时或者debug版本都需要打印结果 if (!result.has_value() || duration &gt; 50ms || android::base::GetMinimumLogSeverity() &lt;= android::base::DEBUG) &#123; std::string trigger_name = BuildTriggersString(); std::string cmd_str = command.BuildCommandString(); LOG(INFO) &lt;&lt; \"Command '\" &lt;&lt; cmd_str &lt;&lt; \"' action=\" &lt;&lt; trigger_name &lt;&lt; \" (\" &lt;&lt; filename_ &lt;&lt; \":\" &lt;&lt; command.line() &lt;&lt; \") took \" &lt;&lt; duration.count() &lt;&lt; \"ms and \" &lt;&lt; (result.ok() ? \"succeeded\" : \"failed: \" + result.error().message()); &#125;&#125; 接着会调用Command::InvokeFunc方法 12345678910111213141516171819Result&lt;void&gt; Command::InvokeFunc(Subcontext* subcontext) const &#123; //从 /vendor 或 /oem 解析出来的rc文件都会走这里 //涉及到selinux权限问题，Google为了保证安全 //队对厂商定制的rc文件中的命令执行，以及由此启动的服务的权限都会有一定限制 if (subcontext) &#123; if (execute_in_subcontext_) &#123; return subcontext-&gt;Execute(args_); &#125; auto expanded_args = subcontext-&gt;ExpandArgs(args_); if (!expanded_args.ok()) &#123; return expanded_args.error(); &#125; return RunBuiltinFunction(func_, *expanded_args, subcontext-&gt;context()); &#125; //系统原生的rc文件命令都会走这里 return RunBuiltinFunction(func_, args_, kInitContext);&#125; 系统原生的rc文件命令都会走到RunBuiltinFunction方法中 12345678910111213141516Result&lt;void&gt; RunBuiltinFunction(const BuiltinFunction&amp; function, const std::vector&lt;std::string&gt;&amp; args, const std::string&amp; context) &#123; auto builtin_arguments = BuiltinArguments(context); builtin_arguments.args.resize(args.size()); builtin_arguments.args[0] = args[0]; for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; return expanded_arg.error(); &#125; builtin_arguments.args[i] = std::move(*expanded_arg); &#125; return function(builtin_arguments);&#125; 这里的function是一个以BuiltinArguments为参数的std::function函数包装器模板，可以包装函数、函数指针、类成员函数指针或任意类型的函数对象，在Command对象new出来的时候构造函数就指定了这个func_，我们可以看一下Action::AddCommand方法： 123456789101112131415Result&lt;void&gt; Action::AddCommand(std::vector&lt;std::string&gt;&amp;&amp; args, int line) &#123; if (!function_map_) &#123; return Error() &lt;&lt; \"no function map available\"; &#125; //从function_map_中进行键值对查找 auto map_result = function_map_-&gt;Find(args); if (!map_result.ok()) &#123; return Error() &lt;&lt; map_result.error(); &#125; commands_.emplace_back(map_result-&gt;function, map_result-&gt;run_in_subcontext, std::move(args), line); return &#123;&#125;;&#125; 可以看到，是通过rc文件中的字符串去一个function_map_常量中查找得到的，而这个function_map_是在哪赋值的呢，答案是在SecondStageMain函数中 1234567int SecondStageMain(int argc, char** argv) &#123; ... //设置commands指令所对应的函数map const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); Action::set_function_map(&amp;function_map); ...&#125; 这个在前文代码中有提及，map的定义在system/core/init/builtins.cpp中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const BuiltinFunctionMap&amp; GetBuiltinFunctionMap() &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); // clang-format off static const BuiltinFunctionMap builtin_functions = &#123; &#123;\"bootchart\", &#123;1, 1, &#123;false, do_bootchart&#125;&#125;&#125;, &#123;\"chmod\", &#123;2, 2, &#123;true, do_chmod&#125;&#125;&#125;, &#123;\"chown\", &#123;2, 3, &#123;true, do_chown&#125;&#125;&#125;, &#123;\"class_reset\", &#123;1, 1, &#123;false, do_class_reset&#125;&#125;&#125;, &#123;\"class_reset_post_data\", &#123;1, 1, &#123;false, do_class_reset_post_data&#125;&#125;&#125;, &#123;\"class_restart\", &#123;1, 1, &#123;false, do_class_restart&#125;&#125;&#125;, &#123;\"class_start\", &#123;1, 1, &#123;false, do_class_start&#125;&#125;&#125;, &#123;\"class_start_post_data\", &#123;1, 1, &#123;false, do_class_start_post_data&#125;&#125;&#125;, &#123;\"class_stop\", &#123;1, 1, &#123;false, do_class_stop&#125;&#125;&#125;, &#123;\"copy\", &#123;2, 2, &#123;true, do_copy&#125;&#125;&#125;, &#123;\"domainname\", &#123;1, 1, &#123;true, do_domainname&#125;&#125;&#125;, &#123;\"enable\", &#123;1, 1, &#123;false, do_enable&#125;&#125;&#125;, &#123;\"exec\", &#123;1, kMax, &#123;false, do_exec&#125;&#125;&#125;, &#123;\"exec_background\", &#123;1, kMax, &#123;false, do_exec_background&#125;&#125;&#125;, &#123;\"exec_start\", &#123;1, 1, &#123;false, do_exec_start&#125;&#125;&#125;, &#123;\"export\", &#123;2, 2, &#123;false, do_export&#125;&#125;&#125;, &#123;\"hostname\", &#123;1, 1, &#123;true, do_hostname&#125;&#125;&#125;, &#123;\"ifup\", &#123;1, 1, &#123;true, do_ifup&#125;&#125;&#125;, &#123;\"init_user0\", &#123;0, 0, &#123;false, do_init_user0&#125;&#125;&#125;, &#123;\"insmod\", &#123;1, kMax, &#123;true, do_insmod&#125;&#125;&#125;, &#123;\"installkey\", &#123;1, 1, &#123;false, do_installkey&#125;&#125;&#125;, &#123;\"interface_restart\", &#123;1, 1, &#123;false, do_interface_restart&#125;&#125;&#125;, &#123;\"interface_start\", &#123;1, 1, &#123;false, do_interface_start&#125;&#125;&#125;, &#123;\"interface_stop\", &#123;1, 1, &#123;false, do_interface_stop&#125;&#125;&#125;, &#123;\"load_persist_props\", &#123;0, 0, &#123;false, do_load_persist_props&#125;&#125;&#125;, &#123;\"load_system_props\", &#123;0, 0, &#123;false, do_load_system_props&#125;&#125;&#125;, &#123;\"loglevel\", &#123;1, 1, &#123;false, do_loglevel&#125;&#125;&#125;, &#123;\"mark_post_data\", &#123;0, 0, &#123;false, do_mark_post_data&#125;&#125;&#125;, &#123;\"mkdir\", &#123;1, 6, &#123;true, do_mkdir&#125;&#125;&#125;, // TODO: Do mount operations in vendor_init. // mount_all is currently too complex to run in vendor_init as it queues action triggers, // imports rc scripts, etc. It should be simplified and run in vendor_init context. // mount and umount are run in the same context as mount_all for symmetry. &#123;\"mount_all\", &#123;0, kMax, &#123;false, do_mount_all&#125;&#125;&#125;, &#123;\"mount\", &#123;3, kMax, &#123;false, do_mount&#125;&#125;&#125;, &#123;\"perform_apex_config\", &#123;0, 0, &#123;false, do_perform_apex_config&#125;&#125;&#125;, &#123;\"umount\", &#123;1, 1, &#123;false, do_umount&#125;&#125;&#125;, &#123;\"umount_all\", &#123;0, 1, &#123;false, do_umount_all&#125;&#125;&#125;, &#123;\"update_linker_config\", &#123;0, 0, &#123;false, do_update_linker_config&#125;&#125;&#125;, &#123;\"readahead\", &#123;1, 2, &#123;true, do_readahead&#125;&#125;&#125;, &#123;\"remount_userdata\", &#123;0, 0, &#123;false, do_remount_userdata&#125;&#125;&#125;, &#123;\"restart\", &#123;1, 1, &#123;false, do_restart&#125;&#125;&#125;, &#123;\"restorecon\", &#123;1, kMax, &#123;true, do_restorecon&#125;&#125;&#125;, &#123;\"restorecon_recursive\", &#123;1, kMax, &#123;true, do_restorecon_recursive&#125;&#125;&#125;, &#123;\"rm\", &#123;1, 1, &#123;true, do_rm&#125;&#125;&#125;, &#123;\"rmdir\", &#123;1, 1, &#123;true, do_rmdir&#125;&#125;&#125;, &#123;\"setprop\", &#123;2, 2, &#123;true, do_setprop&#125;&#125;&#125;, &#123;\"setrlimit\", &#123;3, 3, &#123;false, do_setrlimit&#125;&#125;&#125;, &#123;\"start\", &#123;1, 1, &#123;false, do_start&#125;&#125;&#125;, &#123;\"stop\", &#123;1, 1, &#123;false, do_stop&#125;&#125;&#125;, &#123;\"swapon_all\", &#123;0, 1, &#123;false, do_swapon_all&#125;&#125;&#125;, &#123;\"enter_default_mount_ns\", &#123;0, 0, &#123;false, do_enter_default_mount_ns&#125;&#125;&#125;, &#123;\"symlink\", &#123;2, 2, &#123;true, do_symlink&#125;&#125;&#125;, &#123;\"sysclktz\", &#123;1, 1, &#123;false, do_sysclktz&#125;&#125;&#125;, &#123;\"trigger\", &#123;1, 1, &#123;false, do_trigger&#125;&#125;&#125;, &#123;\"verity_update_state\", &#123;0, 0, &#123;false, do_verity_update_state&#125;&#125;&#125;, &#123;\"wait\", &#123;1, 2, &#123;true, do_wait&#125;&#125;&#125;, &#123;\"wait_for_prop\", &#123;2, 2, &#123;false, do_wait_for_prop&#125;&#125;&#125;, &#123;\"write\", &#123;2, 2, &#123;true, do_write&#125;&#125;&#125;, &#125;; // clang-format on return builtin_functions;&#125; 启动服务以下面一段rc脚本为例，我们看一下一个服务是怎么启动的 12on zygote-start start zygote 首先这是一个action，当init进程在死循环中执行到ActionManager::ExecuteOneCommand方法时，检查到这个action刚好符合event_queue_队首的EventTrigger，便会执行这个action下面的commands。commands怎么执行在上面已经分析过了，我们去system/core/init/builtins.cpp里的map中找key-value对应关系，发现start对应着do_start函数： 12345678static Result&lt;void&gt; do_start(const BuiltinArguments&amp; args) &#123; Service* svc = ServiceList::GetInstance().FindService(args[1]); if (!svc) return Error() &lt;&lt; \"service \" &lt;&lt; args[1] &lt;&lt; \" not found\"; if (auto result = svc-&gt;Start(); !result.ok()) &#123; return ErrorIgnoreEnoent() &lt;&lt; \"Could not start service: \" &lt;&lt; result.error(); &#125; return &#123;&#125;;&#125; ServiceList通过args[1]即定义的服务名去寻找之前解析好的service，并执行Service::Start方法： 123456789101112131415161718192021222324252627282930313233Result&lt;void&gt; Service::Start() &#123; ... //上面基本上是一些检查和准备工作，这里先忽略 pid_t pid = -1; //通过namespaces_.flags判断使用哪种方式创建进程 if (namespaces_.flags) &#123; pid = clone(nullptr, nullptr, namespaces_.flags | SIGCHLD, nullptr); &#125; else &#123; pid = fork(); &#125; if (pid == 0) &#123; //设置权限掩码 umask(077); ... //内部调用execv函数启动文件 if (!ExpandArgsAndExecv(args_, sigstop_)) &#123; PLOG(ERROR) &lt;&lt; \"cannot execv('\" &lt;&lt; args_[0] &lt;&lt; \"'). See the 'Debugging init' section of init's README.md for tips\"; &#125; _exit(127); &#125; if (pid &lt; 0) &#123; pid_ = 0; return ErrnoError() &lt;&lt; \"Failed to fork\"; &#125; ... return &#123;&#125;;&#125; 123456789101112131415161718192021222324static bool ExpandArgsAndExecv(const std::vector&lt;std::string&gt;&amp; args, bool sigstop) &#123; std::vector&lt;std::string&gt; expanded_args; std::vector&lt;char*&gt; c_strings; expanded_args.resize(args.size()); //将要执行的文件路径先加入容器 c_strings.push_back(const_cast&lt;char*&gt;(args[0].data())); for (std::size_t i = 1; i &lt; args.size(); ++i) &#123; auto expanded_arg = ExpandProps(args[i]); if (!expanded_arg.ok()) &#123; LOG(FATAL) &lt;&lt; args[0] &lt;&lt; \": cannot expand arguments': \" &lt;&lt; expanded_arg.error(); &#125; expanded_args[i] = *expanded_arg; c_strings.push_back(expanded_args[i].data()); &#125; c_strings.push_back(nullptr); if (sigstop) &#123; kill(getpid(), SIGSTOP); &#125; //调用execv函数，带参执行文件 return execv(c_strings[0], c_strings.data()) == 0;&#125; 这里先fork（或clone）出了一个子进程，再在这个子进程中调用execv函数执行文件 到此为止，一个服务便被启动起来了 守护服务当服务启动起来后，init进程也要负责服务的守护，为什么呢？ 假设zygote进程挂了，那zygote进程下的所有子进程都可能会被杀，整个Android系统会出现大问题，那怎么办呢？得把zygote进程重启起来呀。init进程守护服务做的就是这些事，当接收到子进程退出信号，就会触发对应的函数进行处理，去根据这个进程所对应的服务，处理后事（重启等） 代码在这个位置： 123456789int SecondStageMain(int argc, char** argv) &#123; Epoll epoll; if (auto result = epoll.Open(); !result.ok()) &#123; PLOG(FATAL) &lt;&lt; result.error(); &#125; InstallSignalFdHandler(&amp;epoll); InstallInitNotifier(&amp;epoll);&#125; 先创建出来一个epoll句柄，再用它去InstallSignalFdHandler装载信号handler： 12345678910111213141516171819202122232425262728293031323334353637383940static void InstallSignalFdHandler(Epoll* epoll) &#123; // Applying SA_NOCLDSTOP to a defaulted SIGCHLD handler prevents the signalfd from receiving // SIGCHLD when a child process stops or continues (b/77867680#comment9). //设置SIGCHLD信号的处理方式 const struct sigaction act &#123; .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;; sigaction(SIGCHLD, &amp;act, nullptr); //在init进程中屏蔽SIGCHLD、SIGTERM信号 sigset_t mask; sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); if (!IsRebootCapable()) &#123; // If init does not have the CAP_SYS_BOOT capability, it is running in a container. // In that case, receiving SIGTERM will cause the system to shut down. sigaddset(&amp;mask, SIGTERM); &#125; if (sigprocmask(SIG_BLOCK, &amp;mask, nullptr) == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to block signals\"; &#125; // Register a handler to unblock signals in the child processes. //在子进程中取消SIGCHLD、SIGTERM信号屏蔽 const int result = pthread_atfork(nullptr, nullptr, &amp;UnblockSignals); if (result != 0) &#123; LOG(FATAL) &lt;&lt; \"Failed to register a fork handler: \" &lt;&lt; strerror(result); &#125; //创建用于接受信号的文件描述符 signal_fd = signalfd(-1, &amp;mask, SFD_CLOEXEC); if (signal_fd == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to create signalfd\"; &#125; //注册信号处理器 if (auto result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) &#123; LOG(FATAL) &lt;&lt; result.error(); &#125;&#125; sigaction函数先介绍一下sigaction函数，它是用来检查和设置一个信号的处理方式的 文档：https://man7.org/linux/man-pages/man2/sigaction.2.html 第一个参数signum，定义在signal.h中，用来指定信号的编号（需要设置哪个信号） 第二个参数act是一个结构体： 1234567struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void);&#125;; 其中，sa_handler表示信号的处理方式，sa_flags用来设置信号处理的其他相关操作 第三个参数oldact，如果不为null，会将此信号原来的处理方式保存进去 对应一下InstallSignalFdHandler里的调用，.sa_handler = SIG_DFL表示使用默认的信号处理，.sa_flags = SA_NOCLDSTOP当参数signum为SIGCHLD的时候生效，表示当子进程暂停时不会通知父进程 信号集函数接下来InstallSignalFdHandler函数调用了一些信号集函数 sigemptyset原型：int sigemptyset(sigset_t *set); 文档：https://man7.org/linux/man-pages/man3/sigemptyset.3p.html 该函数的作用是将信号集初始化为空 sigaddset原型：int sigaddset(sigset_t *set, int signo); 文档：https://man7.org/linux/man-pages/man3/sigaddset.3p.html 该函数的作用是把信号signo添加到信号集set中 sigpromask原型：int sigpromask(int how, const sigset_t *set, sigset_t *oldset); 文档：https://man7.org/linux/man-pages/man2/sigprocmask.2.html 该函数可以根据参数指定的方法修改进程的信号屏蔽字 第一个参数how有3种取值： SIG_BLOCK：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置） SIG_UNBLOCK：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置） SIG_SETMASK：使用set中的信号直接代替原有信号屏蔽字中的信号 第二个参数set是一个信号集，怎么使用和参数how相关 第三个参数oldset，如果不为null，会将原有信号屏蔽字的信号集保存进去 为什么init进程要屏蔽这些信号呢？因为它后面会特殊处理这些信号 pthread_atfork这也是一个Linux函数，用来注册fork的handlers 原型：int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); 调用这个函数后，当进程再调用fork时，内部创建子进程钱会先在父进程中调用prepare函数，创建子进程成功后，会在父进程中调用parent函数，子进程中调用child函数 对应到InstallSignalFdHandler里来，即当init进程fork出子进程后调用UnblockSignals函数 12345678910111213static void UnblockSignals() &#123; const struct sigaction act &#123; .sa_handler = SIG_DFL &#125;; sigaction(SIGCHLD, &amp;act, nullptr); sigset_t mask; sigemptyset(&amp;mask); sigaddset(&amp;mask, SIGCHLD); sigaddset(&amp;mask, SIGTERM); if (sigprocmask(SIG_UNBLOCK, &amp;mask, nullptr) == -1) &#123; PLOG(FATAL) &lt;&lt; \"failed to unblock signals for PID \" &lt;&lt; getpid(); &#125;&#125; 也就是，先在init进程中屏蔽了SIGCHLD、SIGTERM信号，再在子进程中解除了这两个信号的屏蔽 signalfd函数同样也是Linux函数，用来创建用于接受信号的文件描述符 原型：int signalfd(int fd, const sigset_t *mask, int flags); 参数fd如果为-1，则该函数会创建一个新的文件描述符与mask信号集相关联，如果不为-1，则该函数会用mask替换之前与这个fd相关联的信号集 flags： SFD_NONBLOCK：给新打开的文件描述符设置O_NONBLOCK标志，非阻塞I/O模式 SFD_CLOEXEC：给新打开的文件描述符设置O_CLOEXEC标志，当exec函数执行成功后，会自动关闭这个文件描述符 对应到InstallSignalFdHandler中，它创建了一个用于接受SIGCHLD、SIGTERM信号的文件描述符。回忆一下之前对启动服务的分析，是先调用fork创建进程，在exec执行文件，将flags设置为SFD_CLOEXEC，这样就可以保证在子进程中关闭由fork得到的接收信号的文件描述符 注册信号处理器 最后调用Epoll::RegisterHandler方法注册处理器，内部调用了epoll_ctl函数，感兴趣可以自己看一下，文档：https://man7.org/linux/man-pages/man2/epoll_ctl.2.html 这样，当init进程接收到SIGCHLD、SIGTERM信号时便会调用HandleSignalFd方法： 123456789101112131415161718192021static void HandleSignalFd() &#123; signalfd_siginfo siginfo; //从信号集文件描述符中读取信息 ssize_t bytes_read = TEMP_FAILURE_RETRY(read(signal_fd, &amp;siginfo, sizeof(siginfo))); if (bytes_read != sizeof(siginfo)) &#123; PLOG(ERROR) &lt;&lt; \"Failed to read siginfo from signal_fd\"; return; &#125; switch (siginfo.ssi_signo) &#123; case SIGCHLD: ReapAnyOutstandingChildren(); break; case SIGTERM: HandleSigtermSignal(siginfo); break; default: PLOG(ERROR) &lt;&lt; \"signal_fd: received unexpected signal \" &lt;&lt; siginfo.ssi_signo; break; &#125;&#125; 我们这里主要看SIGCHLD，当子进程退出，init进程便会捕获到SIGCHLD，执行ReapAnyOutstandingChildren方法： 1234void ReapAnyOutstandingChildren() &#123; while (ReapOneProcess() != 0) &#123; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static pid_t ReapOneProcess() &#123; siginfo_t siginfo = &#123;&#125;; // This returns a zombie pid or informs us that there are no zombies left to be reaped. // It does NOT reap the pid; that is done below. //获取一个已经退出的子进程，但暂时先不销毁 if (TEMP_FAILURE_RETRY(waitid(P_ALL, 0, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != 0) &#123; PLOG(ERROR) &lt;&lt; \"waitid failed\"; return 0; &#125; auto pid = siginfo.si_pid; if (pid == 0) return 0; // At this point we know we have a zombie pid, so we use this scopeguard to reap the pid // whenever the function returns from this point forward. // We do NOT want to reap the zombie earlier as in Service::Reap(), we kill(-pid, ...) and we // want the pid to remain valid throughout that (and potentially future) usages. //最后，销毁这个子进程 auto reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, nullptr, WNOHANG)); &#125;); std::string name; std::string wait_string; Service* service = nullptr; if (SubcontextChildReap(pid)) &#123; name = \"Subcontext\"; &#125; else &#123; //通过pid获得service service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid); ... &#125; ... if (!service) return pid; //处理service后事 service-&gt;Reap(siginfo); if (service-&gt;flags() &amp; SVC_TEMPORARY) &#123; ServiceList::GetInstance().RemoveService(*service); &#125; return pid;&#125; waitid函数Linux函数，用于等待一个子进程状态的改变 原型：int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options); 文档：https://man7.org/linux/man-pages/man3/waitid.3p.html 第一个参数idtype： P_PID：等待的子进程的pid必须和参数id匹配 P_GID：等待的子进程的组id必须和参数id匹配 P_ADD：等待所有子进程，此时，参数id被忽略 这个函数会将执行的结果保存在第三个参数infop中 options： WCONTINUED：等待那些由SIGCONT重新启动的子进程 WEXITED：等待那些已经退出的子进程 WSTOPPED：等待那些被信号暂停的子进程 WNOHANG：非阻塞等待 WNOWAIT：保持返回的子进程处于可等待状态（后续可以再对这个子进程进行wait） 回到ReapOneProcess函数中来，它先调用waitid函数，获得一个状态发生改变的子进程（options设置了WEXITED，即已退出的子进程），使用了WNOWAIT参数，也就是暂时先不销毁子进程，使用非阻塞的方式获取 ScopeGuard ScopeGuard的意思是，出作用域后，自动执行某段代码 函数中那段make_scope_guard的意思是，当这个函数执行完后，使用waitpid函数销毁子进程 之后会从ServiceList中通过pid去查找service，查到后调用Service::Reap处理后事 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void Service::Reap(const siginfo_t&amp; siginfo) &#123; //当service的参数没有oneshot或者restart时，kill整个进程组 if (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123; KillProcessGroup(SIGKILL, false); &#125; else &#123; // Legacy behavior from ~2007 until Android R: this else branch did not exist and we did not // kill the process group in this case. if (SelinuxGetVendorAndroidVersion() &gt;= __ANDROID_API_R__) &#123; // The new behavior in Android R is to kill these process groups in all cases. The // 'true' parameter instructions KillProcessGroup() to report a warning message where it // detects a difference in behavior has occurred. KillProcessGroup(SIGKILL, true); &#125; &#125; // Remove any socket resources we may have created. //移除已创建的sockets for (const auto&amp; socket : sockets_) &#123; auto path = ANDROID_SOCKET_DIR \"/\" + socket.name; unlink(path.c_str()); &#125; //执行回调 for (const auto&amp; f : reap_callbacks_) &#123; f(siginfo); &#125; //如果进程接收信号异常或被终止的状态异常，并且包含reboot_on_failure标志，重启系统 if ((siginfo.si_code != CLD_EXITED || siginfo.si_status != 0) &amp;&amp; on_failure_reboot_target_) &#123; LOG(ERROR) &lt;&lt; \"Service with 'reboot_on_failure' option failed, shutting down system.\"; trigger_shutdown(*on_failure_reboot_target_); &#125; //当service参数为exec时，释放相应服务资源 if (flags_ &amp; SVC_EXEC) UnSetExec(); if (flags_ &amp; SVC_TEMPORARY) return; pid_ = 0; flags_ &amp;= (~SVC_RUNNING); start_order_ = 0; // Oneshot processes go into the disabled state on exit, // except when manually restarted. //当service参数有oneshot，没有restart和reset时，将service状态置为disable if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123; flags_ |= SVC_DISABLED; &#125; // Disabled and reset processes do not get restarted automatically. //禁用和重置的服务，都不能自动重启 if (flags_ &amp; (SVC_DISABLED | SVC_RESET)) &#123; NotifyStateChange(\"stopped\"); return; &#125; ... //将标志置为重启中 flags_ &amp;= (~SVC_RESTART); flags_ |= SVC_RESTARTING; // Execute all onrestart commands for this service. //执行该service下的所有onrestart命令 onrestart_.ExecuteAllCommands(); NotifyStateChange(\"restarting\"); return;&#125; service相关的参数可以去system/core/init/README.md中自行查看 这个函数检查了一堆service的标志和状态，判断如何处理这个service，如果需要重启，则调用onrestart_.ExecuteAllCommands()执行该service下的所有onrestart命令，具体的执行过程之前在启动服务那边已经分析过了，这里就不再往下看了 总结至此，整个init进程的启动过程最重要的部分基本都已分析完成，我也是一边从网上搜集资料一边对照着源码磕磕绊绊看过来的，有什么错误或者遗漏的部分欢迎指正，谢谢～","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"init进程","slug":"init进程","permalink":"http://yoursite.com/tags/init%E8%BF%9B%E7%A8%8B/"}]},{"title":"各厂商Android系统碰到的奇奇怪怪问题的记录","slug":"android/common/各厂商Android系统碰到的奇奇怪怪问题的记录","date":"2021-12-23T02:39:00.000Z","updated":"2022-11-13T09:55:54.358Z","comments":true,"path":"2021/12/23/android/common/各厂商Android系统碰到的奇奇怪怪问题的记录/","link":"","permalink":"http://yoursite.com/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/","excerpt":"","text":"小米MIUICamera2CaptureRequest.Builder的set方法，对部分key不生效 12// MIUI中，CaptureRequest.Builder设置图片方向不生效captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,getJpegOrientation(deviceRotation)); 解决方法：获得拍摄好的照片Bitmap后，再对其进行旋转 12345public Bitmap rotateBitmap(Bitmap bitmap, int angle) &#123; Matrix matrix = new Matrix(); matrix.setRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125; 华为HarmonyOsTextureView华为ROM（EMUI不确定有没有这种情况）计算TextureView边界的代码似乎有bug 现象： 相机预览和拍摄时有概率画面畸形 渲染超过一屏的文本会渲染空白 解决方法：手动管理TextureView的销毁和创建 第一步：在对TextureView设置TextureView.SurfaceTextureListener时，另onSurfaceTextureDestroyed返回false 1234567891011121314151617181920mTextureView.setSurfaceTextureListener(new TextureView.SurfaceTextureListener() &#123; @Override public void onSurfaceTextureAvailable(@NonNull SurfaceTexture surface, int width, int height) &#123; ... &#125; @Override public void onSurfaceTextureSizeChanged(@NonNull SurfaceTexture surface, int width, int height) &#123; &#125; @Override public boolean onSurfaceTextureDestroyed(@NonNull SurfaceTexture surface) &#123; // 这里默认是返回true，代表系统自动管理，我们把它设为false手动管理 return false; &#125; @Override public void onSurfaceTextureUpdated(@NonNull SurfaceTexture surface) &#123; &#125;&#125;); 第二步：在TextureView不渲染的时候手动release掉其中的SurfaceTexture，后面再渲染时，系统调用draw方法后，会自动重新new一个SurfaceTexture出来 1234SurfaceTexture surfaceTexture = mTextureView.getSurfaceTexture();if (surfaceTexture != null) &#123; surfaceTexture.release();&#125; VIVOOriginOS字体OriginOS中，TextView设置了android:fontFamily后，不能在设置android:textStyle属性，否则会导致使用的字体被系统默认字体覆盖","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"常见问题","slug":"Android/常见问题","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"AOSP的编译及刷机","slug":"android/aosp/AOSP的编译及刷机","date":"2021-12-18T06:13:00.000Z","updated":"2023-02-26T10:34:30.144Z","comments":true,"path":"2021/12/18/android/aosp/AOSP的编译及刷机/","link":"","permalink":"http://yoursite.com/2021/12/18/android/aosp/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA/","excerpt":"","text":"简介众所周知，Android是开源的，AOSP（Android Open Source Project）为Android开源项目的缩写。作为一名Android开发，掌握Android系统的工作机制是技术成长中的必经之路，第一步就是自己编译Android系统。 准备工作 一台可以解BL锁（BootLoader），并且厂商提供了硬件驱动的设备，这里推荐使用Google亲儿子手机（Nexus、Pixel系列），可以解BL锁，Google官方会提供硬件驱动，并且AOSP里会提供对应机型的配置 一块剩余空间至少大于300GB的硬盘（Android11源码-150GB左右，编译产物-150GB左右） 系统最好为Linux，MacOS也可（Windows可以用WSL） 系统需要使用Ubuntu（我不确定别的Linux发行版可不可用），自2021年6月22日起，AOSP不再支持在Windows或MacOS上构建（Windows可以使用WSL，详见WSL编译AOSP必要的几个前置工作） 内存至少要16GB，过小的内存会导致生成build.ninja文件失败 这里是Google官方的推荐要求：https://source.android.com/setup/build/requirements?hl=zh-cN 环境搭建参考文档：https://source.android.com/source/initializing?hl=zh-cn 主要就是下载各种编译工具，像jdk，gcc，g++等，还有各种动态库以及辅助工具 注：此文档中部分环境安装有误，缺失了一些必要的库安装，可能会编译中途报错，可以参考下文的环境安装，如果编译还是出现了依赖缺失，安装好继续编译即可 安装JDK以Ubuntu系统为例： 12sudo apt-get updatesudo apt-get install openjdk-11-jdk 注：现在AOSP编译要求JDK版本&gt;=9 安装其他程序包1sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5 注：官方文档中缺失了libncurses5，会导致编译中途找不到libncurses.so.5库 下载源码Android源码是由非常多的Git仓库组成的，为了可以统一管理这么多个Git仓库，Google出了一款工具，叫Repo 参考文档：https://source.android.com/source/downloading?hl=zh-cn 因为Google在国内访问的问题，建议使用镜像下载源码，下面提供几个镜像地址： 清华大学 https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest 中科大 git://mirrors.ustc.edu.cn/aosp/platform/manifest repo init的时候可以指定分支：https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds 在这里可以找到对应系统分支所支持的设备，比如说我的设备是Pixel2，在这张表上可以看到android-11.0.0_r25这个分支下的代码支持我的设备，所以可以执行以下命令： 1repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r25 然后开始进行同步： 1repo sync -j8 #j8代表使用8个线程 AOSP代码下载是个漫长的过程，需要耐心等待 下载驱动在https://developers.google.com/android/drivers?hl=zh-cn这个网站可以找到Nexus、Pixel系列的驱动，要注意每个驱动后面会有一串代号，需要和你下载的AOSP源码的build号相对应 将他们解压后会得到两个shell文件 将他们复制到下载好的aosp源码的根目录 注：网上很多教程说终端要选用bash不要使用zsh，我亲测使用zsh没有问题，如果在编译过程中出现问题，可以尝试切换shell 先将shell切换到aosp源码根目录 执行两个解压出来的驱动shell，记得要同意License 执行source build/envsetup.sh，这会向shell中写入一些环境变量 先make clean一下 使用lunch命令选择构建目标 这里是该命令的规则：https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target 1lunch aosp_walleye-userdebug 后面跟随的的参数可以在这里找到：https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build 你也可以在lunch后不加参数，这样会弹出一个菜单提示您选择目标 指定完成后会弹出这样一个信息提示 开始编译构建部分的文档在这里：https://source.android.com/setup/build/building?hl=zh-cn#build-the-code如果是初次编译，我们就直接使用m命令就可以了 1m -j8 #开启8线程编译 注意事项： 现在直接使用make命令会提示Calling make directly is no longer supported然后退出编译，所以使用m命令替代make 不能使用root账号编译 刷机 先将手机的BL锁解开（每个机型都不同，网上会有对应的教程），进入fastboot模式\\ 配置fastboot工具（现在Google好像推出了在线刷写工具https://flash.android.com/，可以尝试使用），可以在aosp目录下通过make fastboot命令编译出来，也可以直接从网上下载：https://developer.android.com/studio/releases/platform-tools 进入编译后产生的镜像的目录…./aosp/out/target/product/walleye(这个是你机型的代号，每种机器都不一样) 执行命令 1fastboot flashall -w 重启即可看到，我们编译的Android系统已经运行到了手机上 1fastboot reboot #重启命令 常见问题MacOS上找不到SDK 去这里https://github.com/phracker/MacOSX-SDKs/releases下载对应版本的sdk，然后将它放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs目录下，然后重新编译 除此之外，也可以在Finder中查看 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 这个目录下存在哪个版本的sdk，确定后去修改…./aosp/build/soong/cc/config/x86_darwin_host.go文件，在darwinSupportedSdkVersions这个数组中加上你使用的sdk的版本 保存后重新编译，这个方式可能当前编译脚本不支持你所用的sdk，可能会编译报错，所以还是推荐使用第一种方式 too many open files在Linux系统下有打开文件数的限制，可以使用以下命令设置最大可打开文件数 12# ulimit -a 可以查看当前限制ulimit -n 2048","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"}],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"}]},{"title":"走马灯式横向滚动的TextView","slug":"android/view/走马灯式横向滚动的TextView","date":"2021-05-26T10:01:00.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2021/05/26/android/view/走马灯式横向滚动的TextView/","link":"","permalink":"http://yoursite.com/2021/05/26/android/view/%E8%B5%B0%E9%A9%AC%E7%81%AF%E5%BC%8F%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84TextView/","excerpt":"","text":"简介我们可以设置TextView的android:ellipsize=&quot;marquee&quot;属性，来做到当文字超出一行的时候呈现跑马灯效果。但TextView的这个走马灯效果需要获取焦点，而同一时间只有一个控件可以获得焦点，更重要的是产品要求无论文字内容是否超出一行，都要滚动效果。 这里先贴一下最后实现的Github地址和效果图 https://github.com/dreamgyf/MarqueeTextView 思路思路其实很简单，我们只要将单行的TextView截成一张Bitmap，然后我们再自定义一个View，重写它的onDraw方法，每隔一段时间，将这张Bitmap画在不同的坐标上（左右两边各draw一次），这样连续起来看起来就是走马灯效果了。 后来和同事讨论，他提出能不能通过Canvas的平移配合drawText实现这个功能，我想应该也是可以的，但我没有做尝试，各位看官感兴趣的可是试一下这种方案。 实现我们先自定义一个View继承自AppCompatTextView，再在初始化的时候new一个TextView，并重写onMeasure和onLayout方法 1234567891011121314151617181920private void init() &#123; mTextView = new TextView(getContext(), attrs); //TextView如果没有设置LayoutParams，当setText的时候会引发NPE导致崩溃 mTextView.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)); mTextView.setMaxLines(1);&#125;@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //宽度不设限制 mTextView.measure(MeasureSpec.UNSPECIFIED, heightMeasureSpec);&#125;@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); //保证布局包含完整的Text内容 mTextView.layout(left, top, left + mTextView.getMeasuredWidth(), bottom);&#125; 这样做是为了利用这个内部TextView生成我们需要的Bitmap，同时借用TextView写好的onMeasure方法，这样我们就不用再那么复杂的重写onMeasure方法了 接下来是生成Bitmap 12345private void updateBitmap() &#123; mBitmap = Bitmap.createBitmap(mTextView.getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(mBitmap); mTextView.draw(canvas);&#125; 这个很简单，需要注意的是长度要使用内部持有的TextView的getMeasuredWidth，如果使用getWidth的话，最大值为屏幕的宽度，很可能导致生成出的Bitmap不全，高度用谁的倒是无所谓 在每次setText或setTextSize的时候都需要更新Bitmap并重新布局绘制 1234567891011121314151617181920212223242526272829private void init() &#123; mTextView.addOnLayoutChangeListener(new OnLayoutChangeListener() &#123; @Override public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; updateBitmap(); restartScroll(); &#125; &#125;);&#125;@Overridepublic void setText(CharSequence text, BufferType type) &#123; super.setText(text, type); //执行父类构造函数时，如果AttributeSet中有text参数会先调用setText，此时mTextView尚未初始化 if (mTextView != null) &#123; mTextView.setText(text); requestLayout(); &#125;&#125;@Overridepublic void setTextSize(int unit, float size) &#123; super.setTextSize(unit, size); //执行父类构造函数时，如果AttributeSet中有textSize参数会先调用setTextSize，此时mTextView尚未初始化 if (mTextView != null) &#123; mTextView.setTextSize(size); requestLayout(); &#125;&#125; 接下来，我给这个MarqueeTextView定义了一些参数，一个是space（文字滚动时，头尾的最小间隔距离），另一个是speed（文字滚动的速度） 先看一下onDraw的实现吧 123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected void onDraw(Canvas canvas) &#123; if (mBitmap != null) &#123; //当文字内容不超过一行 if (mTextView.getMeasuredWidth() &lt;= getWidth()) &#123; //计算头尾需要间隔的宽度 int space = mSpace - (getWidth() - mTextView.getMeasuredWidth()); if (space &lt; 0) &#123; space = 0; &#125; //当左边的drawBitmap的坐标超过了显示宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置 if (mLeftX &lt; -getWidth() - space) &#123; mLeftX += getWidth() + space; &#125; //画左边的bitmap canvas.drawBitmap(mBitmap, mLeftX, 0, getPaint()); if (mLeftX &lt; 0) &#123; //画右边的bitmap，位置为最右边的坐标-左边bitmap已消失的宽度+间隔宽度 canvas.drawBitmap(mBitmap, getWidth() + mLeftX + space, 0, getPaint()); &#125; &#125; else &#123; //当文字内容超过一行 //当左边的drawBitmap的坐标超过了内容宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置 if (mLeftX &lt; -mTextView.getMeasuredWidth() - mSpace) &#123; mLeftX += mTextView.getMeasuredWidth() + mSpace; &#125; //画左边的bitmap canvas.drawBitmap(mBitmap, mLeftX, 0, getPaint()); //当尾部已经显示出来的时候 if (mLeftX + (mTextView.getMeasuredWidth() - getWidth()) &lt; 0) &#123; //画右边的bitmap，位置为尾部的坐标+间隔宽度 canvas.drawBitmap(mBitmap, mTextView.getMeasuredWidth() + mLeftX + mSpace, 0, getPaint()); &#125; &#125; &#125;&#125; 这就是基本的绘制思路 接下来需要让他动起来，我这里使用的是Handler，每隔一段时间更新一下坐标并重绘 1234567891011121314151617181920212223242526private final Runnable mMarqueeRunnable = new Runnable() &#123; @Override public void run() &#123; invalidate(); mLeftX -= mSpeed; mHandler.postDelayed(this, 15); &#125;&#125;;public void startScroll() &#123; mHandler.post(mMarqueeRunnable);&#125;public void pauseScroll() &#123; mHandler.removeCallbacks(mMarqueeRunnable);&#125;public void stopScroll() &#123; mLeftX = 0; mHandler.removeCallbacks(mMarqueeRunnable);&#125;public void restartScroll() &#123; stopScroll(); startScroll();&#125; 最后，在View移除Window时，把HandlerMessage取消掉 12345@Overrideprotected void onDetachedFromWindow() &#123; super.onDetachedFromWindow(); mHandler.removeCallbacksAndMessages(null);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"}]},{"title":"Android开发常见问题总结（持续更新）","slug":"android/common/Android开发常见问题总结（持续更新）","date":"2021-04-19T08:47:00.000Z","updated":"2023-01-11T12:05:53.178Z","comments":true,"path":"2021/04/19/android/common/Android开发常见问题总结（持续更新）/","link":"","permalink":"http://yoursite.com/2021/04/19/android/common/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"滑动 滑动嵌套 滑动组件的嵌套可能会产生以下一些问题： 滑动冲突 解决方法：使用NestedScrollView替代ScrollView，RecyclerView可以设置属性android:nestedScrollingEnabled=&quot;false&quot;或代码里setNestedScrollingEnabled(false);来禁用组件自身的滑动 注意：如果RecyclerView只能显示一个Item的话，需要设置NestedScrollView的属性android:fillViewport=&quot;true&quot; 滑动失效 ScrollView设置fillViewport=&quot;true&quot;的情况下，如果对ScrollView的直接子view设置上下margin，在超出内容的高度小于设置的margin的情况下，可能会导致整个ScrollView滑动失效 焦点抢占 ScrollView、RecyclerView等滑动组件可能会抢占焦点，导致界面显示时直接滑动到对应组件的位置，而不是顶部 解决方法：在顶部View(或者其他你所期望的初始位置)加上属性android:focusable=&quot;true&quot;和android:focusableInTouchMode=&quot;true&quot; 新解决方法：在顶部View上加android:descendantFocusability属性，该属性是用来定义父布局与子布局之间的关系的，它有三种值： beforeDescendants：父布局会优先其子类控件而获取到焦点 afterDescendants：父布局只有当其子类控件不需要获取焦点时才获取焦点 blocksDescendants：父布局会覆盖子类控件而直接获得焦点 使用blocksDescendants覆盖子布局焦点以解决焦点抢占问题 RecyclerViewAdapter 在onBindViewHolder中设置子View回调时需要注意 如果回调的参数包括position时，需要注意有没有地方会调用notifyItemRemoved或notifyItemRangeRemoved，如果有，需要使用holder.getAdapterPosition()来代替onBindViewHolder方法的position参数 原因：notifyItemRemoved不会对其他的Item重新调用onBindViewHolder，这样可能会导致position错位。holder.getAdapterPosition()方法会返回数据在 Adapter 中的位置（即使位置的变化还未刷新到布局中） 如何在更新数据后重新定位到顶部 1234567891011//重写父类方法，获得绑定的RecyclerView@Overridepublic void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); mRecyclerView = recyclerView;&#125;//当数据更新后调用if (mRecyclerView != null &amp;&amp; mRecyclerView.getChildCount() &gt; 0) &#123; mRecyclerView.scrollToPosition(0);&#125; 之前尝试过mRecyclerView.scrollTo(0, 0);但没有起效，不清楚为什么 动态部分更新数据时 如果RecyclerView需要动态更新部分数据，并且在onBindViewHolder时对某些view设置了事件或者回调等，如果此时使用到了position参数需要注意，如果你只notify了部分数据更新，可能会导致更新后部分ViewHolder中的回调里的position不正确，建议： 使用notifyDataSetChanged() 使用notifyItem，但是在onBindViewHolder中设置回调时不要使用position参数，而是使用holder.getAdapterPosition()替代（注意这个方法在ViewHolder没有和RecyclerView绑定时会返回-1 NO_POSITION） ItemDecoration StaggeredGridLayoutManager下ItemDecoration的offset计算错误 主要是因为RecyclerView动态更新数据时，会执行多次measure，但只会在第一次measure的时候调用ItemDecoration.getItemOffsets（因为LP里的mInsetsDirty变量），此时获得的spanIndex是一个错误值 这个问题的具体分析可以看这篇文章，暂时没有什么好的解决方案，不建议大家使用反射，毕竟你不知道Android会不会更改这个变量 Dialog 生命周期 初始化时需要注意 Dialog在第一次调用show()方法后才会执行onCreate(Bundle savedInstanceState)方法，因此建议自定义Dialog时将findViewById等初始化操作放在构造函数中进行，避免外部使用时因在show()之前设置视图数据导致NPE PopupWindow 点击没反应 PopupWindow如果不设置背景的话，在某些5.x以下系统机型上会出现点击没反应的问题 解决方法：给PopupWindow设置一个空背景popupWindow.setBackgroundDrawable(new BitmapDrawable(mContext.getResources(), (Bitmap) null)); 详见：https://juejin.cn/post/6844903761488379912 广播 隐式广播 在Android8.0以上的系统，大部分的隐式广播都被限制不可使用。 解决方法： 使用动态广播 使用显示广播1234567891011121314151617181920// 方式一: 设置ComponentIntent intent = new Intent(SOME_ACTION);intent.setComponent(new ComponentName(context, SomeReceiver.class));context.sendBroadcast(intent);// 方式二: 设置PackageIntent intent = new Intent(SOME_ACTION);intent.setPackage(\"com.dreamgyf.xxx\");context.sendBroadcast(intent);// 不知道包名的话可以通过PackageManager获取所有注册了指定action的广播的packageIntent actionIntent = new Intent(SOME_ACTION);PackageManager pm = context.getPackageManager();List&lt;ResolveInfo&gt; matches = pm.queryBroadcastReceivers(actionIntent, 0);for (ResolveInfo resolveInfo : matches) &#123; Intent intent = new Intent(actionIntent); intent.setPackage(resolveInfo.activityInfo.applicationInfo.packageName); intent.setAction(SOME_ACTION); context.sendBroadcast(intent); &#125; 软键盘 弹起软键盘 网上大部分文章所写的弹起软键盘的方法并不完美，大部分文章让你在onResume时再弹起，有的文章甚至让你postDelayed，非常不靠谱，经过本人分析，软键盘的弹起需要满足以下几个条件： 控件为EditText或其子类 控件所在的window要获得焦点 控件本身要获得焦点 根据以上几个条件，我写了一个完美弹起软键盘的方法，onCreate时也可以照常使用： 1234567891011121314151617fun View.showKeyboard() &#123; val ims = context.getSystemService(Context.INPUT_METHOD_SERVICE) as? InputMethodManager ?: return if (hasWindowFocus()) &#123; requestFocus() ims.showSoftInput(this, 0) &#125; else &#123; viewTreeObserver.addOnWindowFocusChangeListener(object : OnWindowFocusChangeListener &#123; override fun onWindowFocusChanged(hasFocus: Boolean) &#123; if (hasFocus) &#123; viewTreeObserver.removeOnWindowFocusChangeListener(this) requestFocus() ims.showSoftInput(this@showKeyboard, 0) &#125; &#125; &#125;) &#125;&#125; 实体键盘 EditText有焦点时会拦截键盘的数字键 解决方法：使用TextWatcher等监听EditText输入 内存泄漏 动画 在Activity销毁之前如果没有cancel掉，会导致这个Activity内存泄漏 ClickableSpan 使用SpannableString.setSpan方法设置ClickableSpan可能导致内存泄漏 原因：TextView在onSaveInstanceState时会将ClickableSpan复制一份，由于某些原因，SpannableString不会删除这个ClickableSpan，从而导致内存泄漏，详见：StackOverflow 解决方法：自定义一个抽象类同时继承ClickableSpan和实现NoCopySpan接口，外部setSpan时使用这个抽象类 Fragment Fragment尽量不要使用带参构造函数，一定要保证有一个不含参的构造函数，否则在Activity重建时尝试反射newInstance恢复Fragment时会抛出Could not find Fragment constructor异常 混淆 反射 如果使用到了反射，需要特别注意需不需要在proguard-rules中加入keep规则 module混淆 如果是多module项目，想要在module中增加混淆规则，proguardFiles属性是无效的，应该使用consumerProguardFiles属性 1234567891011121314android &#123; compileSdkVersion 28 defaultConfig &#123; minSdkVersion 21 targetSdkVersion 28 versionName repo.version testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\" consumerProguardFiles 'proguard-rules.pro' //这里 &#125; ...&#125; 相机开发 拍照角度 相机的方向一般是以手机横向作为正方向，这样如果我们以竖屏的方式拍照，拍出来的照片可能会出现旋转了90度的情况，这时候就需要在拍照完后处理一下图片，旋转到正确位置。 具体介绍与算法在Android SDK中CaptureRequest.JPEG_ORIENTATION的注释中 12345678910111213141516171819private int getJpegOrientation(CameraCharacteristics c, int deviceOrientation) &#123; if (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN) return 0; //获得相机方向与设备方向间的夹角 int sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION); // Round device orientation to a multiple of 90 deviceOrientation = (deviceOrientation + 45) / 90 * 90; // Reverse device orientation for front-facing cameras boolean facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT; if (facingFront) deviceOrientation = -deviceOrientation; // Calculate desired JPEG orientation relative to camera orientation to make // the image upright relative to the device orientation int jpegOrientation = (sensorOrientation + deviceOrientation + 360) % 360; return jpegOrientation;&#125; 计算好角度后就可以对图片做旋转了，网上有很多文章都说使用这种方式做旋转 1captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getJpegOrientation(deviceRotation)); 但实际上在某些系统上 (MIUI)，设置的这个参数并不会生效，所以我的方案是，获得拍摄好的照片Bitmap后，再对其进行旋转 12345public Bitmap rotateBitmap(Bitmap bitmap, int angle) &#123; Matrix matrix = new Matrix(); matrix.setRotate(angle); return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"常见问题","slug":"Android/常见问题","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"常见问题","slug":"常见问题","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"Android对Java的修改-SimpleDateFormat类","slug":"android/common/Android对Java的修改-SimpleDateFormat类","date":"2021-03-01T09:06:00.000Z","updated":"2022-11-13T09:55:54.357Z","comments":true,"path":"2021/03/01/android/common/Android对Java的修改-SimpleDateFormat类/","link":"","permalink":"http://yoursite.com/2021/03/01/android/common/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB/","excerpt":"","text":"简介Android会对部分OpenJDK中的代码进行一些修改，本篇记录一下因为这些修改而踩过的一些坑。 问题描述一个在线上运行良好的Date工具类在写单元测试时一直报ParseException，代码如下： 1234567891011121314151617public static String utc2Local(String utcTime) &#123; String utcTimePatten = \"yyyy-MM-dd'T'HH:mm:ssZZZZZ\"; String localTimePatten = \"yyyy.MM.dd\"; SimpleDateFormat utcFormater = new SimpleDateFormat(utcTimePatten); utcFormater.setTimeZone(TimeZone.getTimeZone(\"UTC\"));//时区定义并进行时间获取 Date gpsUTCDate = null; try &#123; gpsUTCDate = utcFormater.parse(formatTimeStr(utcTime)); &#125; catch (Exception e) &#123; e.printStackTrace(); return utcTime; &#125; SimpleDateFormat localFormater = new SimpleDateFormat(localTimePatten); localFormater.setTimeZone(TimeZone.getDefault()); String localTime = localFormater.format(gpsUTCDate.getTime()); return localTime;&#125; 这里传入的参数utcTime为”2020-01-01 08:00:00+08:00” 这段代码在Android环境下运行良好，但在单元测试下一直报错 原因Android对OpenJDK中的SimpleDateFormat进行了修改，具体在subParseNumericZone方法中： 可以看到，OpenJDK原本是不支持带冒号的写法的，而在Android中修改了subParseNumericZone方法，使其可以解析带冒号的写法。 解决解决方法也很简单，在测试时直接修改入参，去掉入参中的冒号就好了： 12345678910111213141516try (MockedStatic&lt;DateUtils&gt; mockedDateUtils = Mockito.mockStatic(DateUtils.class, new CallsRealMethods())) &#123; mockedDateUtils.when(() -&gt; &#123; DateUtils.utc2Local(argThat((argument) -&gt; &#123; int index = argument.length() - 3; return argument.charAt(index) == ':'; )); &#125;).then((invocation) -&gt; &#123; String utcTime = invocation.getArgument(0, String.class); String fixedDate = formatDate; int index = formatDate.length() - 3; if (formatDate.charAt(index) == ':') &#123; fixedDate = formatDate.substring(0, index) + formatDate.substring(index + 1); &#125; return DateUtils.utc2Local(fixedDate); &#125;);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://yoursite.com/tags/SimpleDateFormat/"}]},{"title":"Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数","slug":"android/unit-test/Android-Kotlin单元测试之如何配合Mockito模拟顶层函数","date":"2021-02-24T08:05:00.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2021/02/24/android/unit-test/Android-Kotlin单元测试之如何配合Mockito模拟顶层函数/","link":"","permalink":"http://yoursite.com/2021/02/24/android/unit-test/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0/","excerpt":"","text":"简介随着Kotlin语言在Android开发中越来越流行，自然也会遇到各种各样的问题。 本篇主要是针对我个人在Android单元测试Kotlin类时遇到的一些问题的思考和解决方案。 遇到的问题我们都知道Kotlin给开发者提供了很多语法糖，其中之一就是顶层函数，我们可以直接把函数放在代码文件的顶层，让它不从属于任何类。 它的使用很简单，直接在kotlin代码的任意位置直接当作一个普通函数调用就行了，而在java中，需要像使用静态方法一样，以文件名+Kt为类名调用 (默认配置) 在java单元测试中，如果想mock这个顶层函数，只需要像对待一个静态方法一样，使用mockStatic方法即可 而在kotlin单元测试中，我们却无法找到这个class 确定路线我们先建立一个文件来写一个顶层函数，再建立一个单元测试类去测试它: 其实从上文中已经可以看出，kotlin的顶层函数在编译之后实际上就变成了一个被class包起来的static方法。对此，我们可以简单验证一下: 在Android Studio中点击菜单中的Tools-&gt;Kotlin-&gt;Show Kotlin ByteCode，会弹出对应类的字节码，再点击Decompile按钮，我们会看到确实被编译成了一个类中的静态方法 确定了这一点后，我们只需要在kotlin中拿到这个顶层函数的所属类，就可以像java里一样使用mockStatic来模拟了。 分析过程既然涉及到了运行时类型分析，自然而然就想到了反射，我们先引入kotlin的反射库 implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot; 其实我对kotlin的反射并不熟悉，去文档里查阅了一下发现了::sampleTopFun这种写法，它的返回值为一个叫KFunction的接口类，我们先看看它有哪些方法可以供我们调用 从字面上看好像没有什么方法和我们的需求有关，怎么办呢？那我们再看一下它的实现类吧，说不定会有一些私有变量保存了我们需要的信息。 那么怎么找到它的实现类呢？直接分析源码错综复杂的关系是很耗时且低效的，这里我采取了了一种取巧的方法，利用Android Studio的Debug功能: 和预料的不同，为什么这里拿到的类型是这么个奇葩玩意儿呢？我们看一下这个文件的字节码 再往下看 我们发现，这个奇葩的类型是在kotlin编译后自动生成的，它继承自FunctionReference，同时，在Debugger里，我们获得了一个重要的信息: KFunctionImpl 根据名字猜测，它应该才是KFunction真正功能实现的地方，我们将它的信息展开 可以发现，我们已经找到我们想要的那个类了，只要拿到它，后续的mock工作就很简单了~ 开始Mock根据上文，我们已经得知了我们需要获取的jClass的路径 我们先从FunctionReference去获取被reflected引用的KFunctionImpl，这个reflected实际是被FunctionReference继承的CallableReference中的一个变量，在FunctionReference提供了一个getReflected方法，我们通过反射调用这个方法即可得到这个对象，当然，我们也可以通过反射Field获得它，但注意到getReflected方法处理了一些空对象的情况，为了保险起见，我们还是采取反射调用getReflected的方法获取KFunctionImpl 反射调用getReflected方法获取KFunctionImpl 第一步没问题，接下来开始反射获取container 第二步也没什么问题，接下来就是反射获取jClass了 ok，一切正常，接下来和java一样，让我们试试用这个我们获取到的类mockStatic吧 可以看到，测试成功通过，至此，我们成功解决了Mockito模拟顶层函数的问题。为了方便使用，可以将以上代码封装成一个函数，这里就不再赘述了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"单元测试","slug":"Android/单元测试","permalink":"http://yoursite.com/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"汇编指令笔记","slug":"common/汇编指令笔记","date":"2020-12-31T08:18:37.000Z","updated":"2022-11-13T09:55:54.361Z","comments":true,"path":"2020/12/31/common/汇编指令笔记/","link":"","permalink":"http://yoursite.com/2020/12/31/common/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"寄存器数据寄存器AX: AH-AL (数据累加器, 可用于乘、 除、输入/输出等操作) BX: BH-BL (基址寄存器, 可作为存储器指针来使用) CX: CH-CL (计数寄存器, 可用来控制循环次数) DX: DH-DL (数据寄存器, 在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址) 变址寄存器 主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。 ESI: 32bit == SI: 16bit (源变址寄存器, 与DS联用, 指示数据段中某操作的偏移量. 在做串处理时, SI指示源操作数地址, 并有自动增量或自动减量的功能。 变址寻址时, SI与某一位移量共同构成操作数的偏移量) EDI: 32bit == DI: 16bit (与DS联用, 指示数据段中某操作数的偏移量, 或与某一位移量共同构成操作数的偏移量. 串处理操作时, DI指示附加段中目的地址, 并有自动增量或减量的功能) 指针寄存器 主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。 EBP: 32bit == BP: 16bit (基指针寄存器, 用它可直接存取堆栈中的数据) ESP: 32bit == SP: 16bit (堆栈指针寄存器, 始终只是栈顶的位置, 与SS寄存器一起组成栈顶数据的物理地址) 段寄存器 段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。 16位 CS——代码段寄存器，存放当前程序的指令代码 DS——数据段寄存器，存放程序所涉及的源数据或结果 ES——附加段寄存器，辅助数据区, 存放串或其他数据 SS——堆栈段寄存器，其值为堆栈段的段值 32位 FS——附加段寄存器，其值为附加数据段的段值 GS——附加段寄存器，其值为附加数据段的段值 指令cmp (配合jz, jnz)算数运算指令，比较两个值，如果相等则设置ZF(零标志)为1, 可用jz(jump if zero)或jnz(jump if not zero)指令检查ZF位, jz(ZF零标志为1)即相等, jnz(ZF零标志为1)即不相等 12345678910111213例:compare: mov $0x1000, %ax cmp $0x1000, %ax ;判断ax寄存器中的值是否为0x1000 jz is_equal ;如果相等，则跳转到代码段is_equal jnz is_not_equal ;如果不相等，则跳转到代码段is_not_equalis_equal: ;do somethingis_not_equal: ;do something rep重复执行后面的指令，直到cx寄存器中的值为0 12345例:example: mov $0, %ax //将ax寄存器置0 mov $0x1000, %cx rep add $1, %ax //使ax寄存器加1，执行1000次","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"自定义EditView时踩过的坑","slug":"android/view/自定义EditView时踩过的坑","date":"2020-10-19T04:05:34.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/10/19/android/view/自定义EditView时踩过的坑/","link":"","permalink":"http://yoursite.com/2020/10/19/android/view/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/","excerpt":"","text":"简介这次的需求是一个单词拼写的输入框，要求每个字母分割开来输入，每个字母下面有一个下划线，就类似于验证码输入或者支付密码输入的效果 最终成品是一个自定义View，实现参考了VercodeEditText EditView还是TextView？刚开始的时候，我选择了继承AppCompatEditText，但在我试着draw on canvas的时候，奇怪的发现绘制的东西并没有在界面上显示，然后我尝试将视图的高度调大，当到达了一个临界点后，内容突然显示出来了。 为了得知这个问题的成因，我试着画一个占满整个画布的矩形，打开开发者选项里的显示布局边界后发现，这个矩形并没有占满整个布局。一开始猜想可能是因为画布的高度小于视图的高度，于是打开debug调试断点发现，两者是一致的；然后猜测是不是画布因为什么原因产生了偏移？但怎么尝试都没有得到确定性的结论，直到某次我打开了EditText的背景，并随便滑动了几下发现，在向下滑动的时候，原本绘制的内容便从视图最上方滚动了下来。原来是因为当EditText高度小于1行时，EditText会自动适配并滚动到最下方。 既然知道了问题的成因，那就开始着手解决他，最直接的办法就是禁止EditText的滚动。为此，我尝试了setMinHeight()，setMinLines()都没有用。然后我退而求其次，尝试使用scrollTo(0, 0)，将视图固定滑动到最顶部，发现效果并不是很理想。然后在查资料的过程中我发现了MovementMethod这么一个东西。 网上关于MovementMethod的资料比较少，我查询了一下Google的官方文档里面介绍： Provides cursor positioning, scrolling and text selection functionality in a TextView.即：在 TextView提供了光标定位，滚动和文本选择功能。 找到了产生滚动的元凶，那问题就好办了，在源码里可以看到，EditText的getDefaultMovementMethod()返回了一个ArrowKeyMovementMethod，我们直接setMovementMethod(null)或者重写父类的getDefaultMovementMethod()使其返回值为null，滚动的问题便解决了。 解决完这一步后，又发现了一个新问题，EditText的上下左右有一定的padding，点击到这部分padding的区域是不会触发EditText的获取焦点弹出输入法的，当然也可以直接重写onTouchEvent方法加上requestFocus()方法解决，但考虑到继承EditText要重设背景，又要setMovementMethod，还要处理边缘点击事件，感觉太麻烦，不如直接继承TextView，处理的事情会稍微少一些。 于是我选择继承AppCompatTextView，重写getDefaultEditable()使其返回true以打开编辑功能，setFocusableInTouchMode(true)使其能获取焦点，重写onTouchEvent方法加上requestFocus()方法使其点击能够直接获取焦点，setCursorVisible(false)隐藏光标，setLongClickable(false)禁止长按弹出编辑菜单，到这一步，基本难点已经解决了。 onTextChanged多次调用？为了监听文本改变的事件，我一开始选择了自定义View直接implements TextWatcher，然后addTextChangedListener(this)，这样在断点调试的时候发现，onTextChanged()方法被执行了多次，但beforeTextChanged()和afterTextChanged()执行次数却是正常的。原来，在TextView内部已经有了一个可重写的onTextChanged()方法，和TextWatcher里的onTextChanged()一模一样，当addTextChangedListener(this)后，TextView会先执行TextWatcher的onTextChanged()，再执行自己内部的onTextChanged()。解决方法很简单，将implements TextWatcher去掉，改为addTextChangedListener一个匿名内部类就好了。 长度超过限制了怎么办？刚开始，我在onTextChanged()里增加了对Text长度的判断，如果长度超长，就把原Text截断到最大长度，然后重新setText进去。这样做有一个问题，这样并不能保证afterTextChanged()回调里的Text参数长度合法。当这么做后，TextView首先会触发截断Text的afterTextChanged()，然后再触发超长Text的afterTextChanged()。后来在搜索资料的时候发现，TextView内部持有了一个InputFilter数组，这个接口可以很好的帮助我们在触发回调之前对输入的字符串进行过滤操作。 InputFilter接口方法 public CharSequence filter(CharSequence source, int start, int end,Spanned dest, int dstart, int dend); 其中，InputFilter已经内置实现了长度过滤功能，只需要在设置新answer的时候，重新setFilters()就行了 1234InputFilter[] filters = new InputFilter[]&#123; new InputFilter.LengthFilter(answer.length())&#125;;setFilters(filters); 具体的绘制实现？计算预留位置我定义了一个变量String ALL_CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;用来计算用户输入的预留宽高。 123456789101112private void measureChar() &#123; int width = 0, height = 0; Rect rect = new Rect(); for (int i = 0; i &lt; ALL_CHARS.length(); i++) &#123; mTextPaint.getTextBounds(ALL_CHARS, i, i + 1, rect); width = Math.max(width, rect.width()); height = Math.max(height, rect.height()); &#125; mCharWidth = width; mCharHeight = height;&#125; 在onMeasure()里计算好布局宽高后，根据宽高和间隔距离平均分配一下每个字母的坐标。 自适应宽度这次的需求还要求当布局的宽度超过父布局时，自动缩小字体大小以适应父布局宽度。这个其实也很简单，计算一下绘制需要的宽度，如果超过父布局宽度，就减小字号，循环一下即可。 123456int answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - 1);while (answerWidth &gt; width - getPaddingLeft() - getPaddingRight()) &#123; mTextPaint.setTextSize(--mTextSize); measureChar(); answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - 1);&#125; 用户输入文字的绘制由于每个字母的宽高可能不同，所以不能直接使用之前计算好的坐标绘制，需要使用之前测量好的预留的宽度减去用户实际输入字母的宽度除以2，然后加上这个预留位置的起始坐标。 12345private float computeCharX(CharCoordinate coordinate, char letter) &#123; mTextPaint.getTextBounds(String.valueOf(letter), 0, 1, mTempRect); int realCharWidth = mTempRect.width(); return coordinate.start + (float) (mCharWidth - realCharWidth) / 2 - mTempRect.left;&#125; 这里减去mTempRect.left是因为绘制出来的字符有些向右偏离 绘制光标TextView原本的光标不符合我们的需求，我们需要绘制一下自定义的光标。 先定义一下光标闪烁时间： 12private final static int DEFAULT_CURSOR_DURATION = 800;private int mCursorDuration = DEFAULT_CURSOR_DURATION; 再定义一个Handler和Runnable用来间隔执行任务 12345678910private Runnable mCursorRunnable = new Runnable() &#123; @Override public void run() &#123; if (mNeedCursorShow) &#123; mIsCursorShowing = !mIsCursorShowing; invalidate(); &#125; mHandler.postDelayed(mCursorRunnable, mCursorDuration); &#125;&#125;; 这样通过设置一个bool值和定时任务每隔一段时间刷新一下视图就可以轻松实现光标的闪烁。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"EditView","slug":"EditView","permalink":"http://yoursite.com/tags/EditView/"}]},{"title":"Git命令简介","slug":"common/Git命令简介","date":"2020-08-01T08:58:57.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/08/01/common/Git命令简介/","link":"","permalink":"http://yoursite.com/2020/08/01/common/Git%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/","excerpt":"","text":"配置12git config --global user.name 'dreamgyf' //设置用户名git config --global user.email g2409197994@gmail.com //设置邮箱 基本命令12345678910git init //在当前目录创建版本库git add README.md //将文件添加到暂存区git commit //提交暂存区中的修改 -m\"xxx\":本次提交的说明 -a:相当多加了一步于git add .git branch 分支名 //创建分支，不加分支名可以查看所有分支 -d:删除指定分支git checkout 分支名 //切换分支 -b:创建并切换分支，相当于多加了一步git branch 分支名git remote add https://github.com/xxx/xxx.git //添加远程仓库，一般支持https和ssh两种协议git fetch //将远程主机的更新全部取回本地，后面加分支名的话只会取回指定分支git merge 分支名 //将选中分支合并到当前分支git pull 分支名 //相当于git fetch 分支名 + git merge 分支名git push //将当前本地分支推送至远程分支，如果是第一次推送则需要-u参数指定远程分支并建立联系，如git push -u origin master，下一次便可不加参数直接推送 -f:强制推送，会覆盖远程分支 Rebase 合并commit记录 1git rebase -i [startpoint] [endpoint] 其中-i的意思是--interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint]则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。 命令可以按如下方式： 1git rebase -i [commit id] 或 1git rebase -i HEAD~3 然后会出现一个vi编辑器界面，会提供给我们一个命令列表： pick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：丢弃该commit（缩写:d） 然后我们就可以在里面修改提交了，例如: 123pick d2cf1f9 fix: 第一次提交s 47971f6 第二次提交s fb28c8d 第三次提交 将第二、三次的commit合并到第一次上 编辑完保存退出vi就可以完成对commit的合并了 如果保存时出现错误，输入git rebase --edit-todo便会回到编辑模式里，修改完后保存，git rebase --continue 参考链接 合并分支 rebase和merge都是合并分支的操作 merge会在合并分支时产生一个新的commit记录，而rebase会以指定分支作为基础分支，之前所做的改动全部会在指定分支的基础上提交，不会产生新的commit记录。 12git checkout devgit rebase master 分析一下上面命令进行的操作： 首先，切换到dev分支上； 然后，git 会把 dev 分支里面的每个 commit 取消掉； 其次，把之前的commit临时保存成 patch 文件，存在 .git/rebase 目录下； 然后，把dev分支更新到最新的 master 分支； 最后，把上面保存的 patch 文件应用到 dev 分支上； 使用场景 想要干净简洁的分支树 在一个过时的分支上面开发的时候，执行 rebase 以同步 master 分支最新变动 注意：当同一个分支有多个人使用的情况下，谨慎使用rebase，因为它改变了历史，可能会出现丢失commit的情况 参考链接","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Markdown语法","slug":"common/Markdown语法","date":"2020-06-26T15:31:57.000Z","updated":"2022-11-13T09:55:54.360Z","comments":true,"path":"2020/06/26/common/Markdown语法/","link":"","permalink":"http://yoursite.com/2020/06/26/common/Markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown是一种轻量级标记语言，它以纯文本形式编写文档，并最终以HTML格式发布。 先推荐一款Markdown编辑器Typora，支持 Windows、OS X 和 Linux，支持即时渲染技术，所见即所得，界面简洁大方，非常好用。 注：因为本站使用了主题，所以部分Markdown呈现的效果与原来不同 标题文字前加几个#即为几级标题 注：#与文字之间需要有空格 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 字体在文字两侧加上特殊符号 1234*倾斜***加粗*****倾斜加粗***~~删除线~~ 倾斜加粗倾斜加粗删除线 特殊符号在特殊符号之前加上\\转义字符 12345\\\\ 反斜杠\\* 星号\\_ 下划线\\&#123;\\&#125; \\[\\] \\(\\) 括号\\+ 加号 \\ 反斜杠* 星号_ 下划线{} [] () 括号+ 加号 换行连续两个以上的空格+回车，或两个以上的回车 分割线在一行中用三个以上的星号、减号、底线 123456**************--------------______________ 可在中间插入空格，效果相同 引用在引用文字前加 &gt; 1&gt; 这是一行引用文字 这是一行引用文字 引用可以嵌套 123&gt; 这是一行引用文字&gt;&gt; 这是一行引用文字&gt;&gt;&gt; 这是一行引用文字 这是一行引用文字 这是一行引用文字 这是一行引用文字 列表无序列表在文字前加入- + * 任意一个符号 注：符号与文字之间需要有空格 123- 列表1+ 列表2* 列表3 列表1 列表2 列表3 有序列表在文字前加入数字和点 1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 图片格式 ![图片alt](图片地址 &quot;图片title&quot;) Title可选 1![Fate](/images/cover.jpg \"Fate\") 超链接Markdown的超链接支持三种写法 行内式格式 [超链接名](超链接地址 &quot;超链接title&quot;) 其中Title可选 123[始终都是梦的Github-1](https://github.com/dreamgyf \"始终都是梦的Github\")超链接名也可以嵌套图片如 [![始终都是梦的Github-1](/images/avatar.jpeg)](https://github.com/dreamgyf) 始终都是梦的Github 1 参考式可以对一个链接进行多次引用 使用 [超链接名][超链接标记] 定义 [超链接标记]:超链接地址 &quot;超链接title&quot; 其中Title可选,可定义在任意位置 12[始终都是梦的Github-2][2][2]:https://github.com/dreamgyf 始终都是梦的Github-2 自动链接将链接直接用&lt;&gt;包裹起来 1&lt;https://github.com/dreamgyf&gt; https://github.com/dreamgyf 脚注 在需要添加注脚的文字后加上[^脚注名] 在文本的任意位置(一般在最后)定义脚注 [^脚注名]:脚注内容 12示例文本[^1][^1]:我是示例文本的脚注 由于本站主题原因不做演示 代码单行代码将代码用特殊字符`包裹(一般为Esc下面的键) 1`printf(\"hello world\");` printf(&quot;hello world&quot;); 代码块使用两组三个特殊字符`包裹代码块 可以在第一组```后添加语言名 12345678​```c++#include &lt;iostream&gt;int main(void) &#123; std::cout &gt;&gt; \"hello world\" &gt;&gt; endl; return 0;&#125;​``` 123456#include &lt;iostream&gt;int main(void) &#123; std::cout &gt;&gt; \"hello world\" &gt;&gt; endl; return 0;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}],"categories":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/categories/AI/"},{"name":"AI人声","slug":"AI/AI人声","permalink":"http://yoursite.com/categories/AI/AI%E4%BA%BA%E5%A3%B0/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"动画","slug":"Android/动画","permalink":"http://yoursite.com/categories/Android/%E5%8A%A8%E7%94%BB/"},{"name":"权限","slug":"Android/权限","permalink":"http://yoursite.com/categories/Android/%E6%9D%83%E9%99%90/"},{"name":"源码分析","slug":"Android/源码分析","permalink":"http://yoursite.com/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"ActivityManagerService","slug":"Android/ActivityManagerService","permalink":"http://yoursite.com/categories/Android/ActivityManagerService/"},{"name":"ActivityThread","slug":"Android/ActivityThread","permalink":"http://yoursite.com/categories/Android/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"Android/ActivityTaskManagerService","permalink":"http://yoursite.com/categories/Android/ActivityTaskManagerService/"},{"name":"AOSP","slug":"Android/AOSP","permalink":"http://yoursite.com/categories/Android/AOSP/"},{"name":"沉浸式","slug":"Android/沉浸式","permalink":"http://yoursite.com/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"状态栏","slug":"Android/状态栏","permalink":"http://yoursite.com/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"导航栏","slug":"Android/导航栏","permalink":"http://yoursite.com/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"Android/StatusBar","permalink":"http://yoursite.com/categories/Android/StatusBar/"},{"name":"NavigationBar","slug":"Android/NavigationBar","permalink":"http://yoursite.com/categories/Android/NavigationBar/"},{"name":"交叉编译","slug":"Android/交叉编译","permalink":"http://yoursite.com/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"Android/NDK","permalink":"http://yoursite.com/categories/Android/NDK/"},{"name":"编译","slug":"编译","permalink":"http://yoursite.com/categories/%E7%BC%96%E8%AF%91/"},{"name":"Binder","slug":"Android/Binder","permalink":"http://yoursite.com/categories/Android/Binder/"},{"name":"Jetpack Compose","slug":"Android/Jetpack-Compose","permalink":"http://yoursite.com/categories/Android/Jetpack-Compose/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"},{"name":"面试","slug":"Android/面试","permalink":"http://yoursite.com/categories/Android/%E9%9D%A2%E8%AF%95/"},{"name":"插桩","slug":"Android/插桩","permalink":"http://yoursite.com/categories/Android/%E6%8F%92%E6%A1%A9/"},{"name":"常见问题","slug":"Android/常见问题","permalink":"http://yoursite.com/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"单元测试","slug":"Android/单元测试","permalink":"http://yoursite.com/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://yoursite.com/tags/AI/"},{"name":"AIGC","slug":"AIGC","permalink":"http://yoursite.com/tags/AIGC/"},{"name":"AI人声","slug":"AI人声","permalink":"http://yoursite.com/tags/AI%E4%BA%BA%E5%A3%B0/"},{"name":"Sovits","slug":"Sovits","permalink":"http://yoursite.com/tags/Sovits/"},{"name":"动画","slug":"动画","permalink":"http://yoursite.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"AnimationDrawable","slug":"AnimationDrawable","permalink":"http://yoursite.com/tags/AnimationDrawable/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"权限","slug":"权限","permalink":"http://yoursite.com/tags/%E6%9D%83%E9%99%90/"},{"name":"Android源码","slug":"Android源码","permalink":"http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"},{"name":"ActivityManagerService","slug":"ActivityManagerService","permalink":"http://yoursite.com/tags/ActivityManagerService/"},{"name":"ActivityThread","slug":"ActivityThread","permalink":"http://yoursite.com/tags/ActivityThread/"},{"name":"ActivityTaskManagerService","slug":"ActivityTaskManagerService","permalink":"http://yoursite.com/tags/ActivityTaskManagerService/"},{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/tags/AOSP/"},{"name":"沉浸式","slug":"沉浸式","permalink":"http://yoursite.com/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/"},{"name":"状态栏","slug":"状态栏","permalink":"http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/"},{"name":"导航栏","slug":"导航栏","permalink":"http://yoursite.com/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/"},{"name":"StatusBar","slug":"StatusBar","permalink":"http://yoursite.com/tags/StatusBar/"},{"name":"NavigationBar","slug":"NavigationBar","permalink":"http://yoursite.com/tags/NavigationBar/"},{"name":"Android交叉编译","slug":"Android交叉编译","permalink":"http://yoursite.com/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"NDK","slug":"NDK","permalink":"http://yoursite.com/tags/NDK/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://yoursite.com/tags/OpenCV/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"http://yoursite.com/tags/FFmpeg/"},{"name":"x264","slug":"x264","permalink":"http://yoursite.com/tags/x264/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"},{"name":"Jetpack Compose","slug":"Jetpack-Compose","permalink":"http://yoursite.com/tags/Jetpack-Compose/"},{"name":"信号","slug":"信号","permalink":"http://yoursite.com/tags/%E4%BF%A1%E5%8F%B7/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"插桩","slug":"插桩","permalink":"http://yoursite.com/tags/%E6%8F%92%E6%A1%A9/"},{"name":"SystemServer","slug":"SystemServer","permalink":"http://yoursite.com/tags/SystemServer/"},{"name":"Capabilities","slug":"Capabilities","permalink":"http://yoursite.com/tags/Capabilities/"},{"name":"Zygote","slug":"Zygote","permalink":"http://yoursite.com/tags/Zygote/"},{"name":"init进程","slug":"init进程","permalink":"http://yoursite.com/tags/init%E8%BF%9B%E7%A8%8B/"},{"name":"常见问题","slug":"常见问题","permalink":"http://yoursite.com/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"TextView","slug":"TextView","permalink":"http://yoursite.com/tags/TextView/"},{"name":"SimpleDateFormat","slug":"SimpleDateFormat","permalink":"http://yoursite.com/tags/SimpleDateFormat/"},{"name":"单元测试","slug":"单元测试","permalink":"http://yoursite.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/%E6%B1%87%E7%BC%96/"},{"name":"EditView","slug":"EditView","permalink":"http://yoursite.com/tags/EditView/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]}