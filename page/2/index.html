<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/01/07/android/common/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5/">史上最完美的Android沉浸式状态导航栏攻略</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-01-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%B2%89%E6%B5%B8%E5%BC%8F/">沉浸式</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E7%8A%B6%E6%80%81%E6%A0%8F/">状态栏</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%AF%BC%E8%88%AA%E6%A0%8F/">导航栏</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/StatusBar/">StatusBar</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/NavigationBar/">NavigationBar</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android/">Android</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%B2%89%E6%B5%B8%E5%BC%8F/">沉浸式</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E7%8A%B6%E6%80%81%E6%A0%8F/">状态栏</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%AF%BC%E8%88%AA%E6%A0%8F/">导航栏</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/StatusBar/">StatusBar</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NavigationBar/">NavigationBar</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近我在小破站开发一款新App，叫<strong>高能链</strong>。我是一个完美主义者，所以不管对架构还是UI，我都是比较抠细节的，在状态栏和导航栏沉浸式这一块，我还是踩了挺多坑，费了挺多精力的。这次我将我踩坑，适配各机型总结出来的史上最完美的Android沉浸式状态导航栏攻略分享给大家，大家也可以去 <strong><a href="https://www.upowerchain.com/" target="_blank" rel="noopener">高能链官网</a></strong> 下载体验一下我们的App，实际感受一下沉浸式状态导航栏的效果（登录，实名等账号相关页面由于不是我开发的，就没有适配沉浸式导航栏啦，嘻嘻）</p>
<p><strong>注：此攻略只针对 Android 5.0 及以上机型，即 minSdkVersion &gt;= 21</strong></p>
<h1 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h1><p>在开始攻略之前，我们先看看完美的沉浸式状态导航栏效果</p>
<h2 id="传统三键式导航栏"><a href="#传统三键式导航栏" class="headerlink" title="传统三键式导航栏"></a>传统三键式导航栏</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E5%88%97%E8%A1%A8%E9%A1%B5_%E4%B8%89%E9%94%AE%E5%BC%8F.jpg" alt="客态列表页_三键式"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E8%AF%A6%E6%83%85%E9%A1%B5_%E4%B8%89%E9%94%AE%E5%BC%8F.jpg" alt="客态详情页_三键式"></p>
<h2 id="全面屏导航条"><a href="#全面屏导航条" class="headerlink" title="全面屏导航条"></a>全面屏导航条</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E5%88%97%E8%A1%A8%E9%A1%B5_%E5%AF%BC%E8%88%AA%E6%9D%A1.jpg" alt="客态列表页_导航条"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84Android%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%94%BB%E7%95%A5_%E5%AE%A2%E6%80%81%E8%AF%A6%E6%83%85%E9%A1%B5_%E5%AF%BC%E8%88%AA%E6%9D%A1.jpg" alt="客态详情页_导航条"></p>
<h1 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h1><p>在上具体实现代码之前，我们先分析一下，实现沉浸式状态导航栏需要几步</p>
<ol>
<li><p>状态栏导航栏底色透明</p>
</li>
<li><p>根据当前页面的背景色，给状态栏字体和导航栏按钮（或导航条）设置亮色或暗色</p>
</li>
<li><p>状态栏导航栏设置透明后，我们页面的布局会延伸到原本状态栏导航栏的位置，这时候需要一些手段将我们需要显示的正文内容回缩到其正确的显示范围内</p>
<p> 这里我给大家提供以下几种思路，大家可以根据实际情况自行选择：</p>
<ul>
<li>设置<code>fitsSystemWindows</code>属性</li>
<li>根据状态栏导航栏的高度，给根布局设置相应的<code>paddingTop</code>和<code>paddingBottom</code></li>
<li>根据状态栏导航栏的高度，给需要移位的控件设置相应的<code>marginTop</code>和<code>marginBottom</code></li>
<li>在顶部和底部增加两个占位的<code>View</code>，高度分别设置成状态栏和导航栏的高度</li>
<li>针对滑动视图，巧用<code>clipChildren</code>和<code>clipToPadding</code>属性（可参照高能链藏品详情页样式）</li>
</ul>
</li>
</ol>
<h1 id="沉浸式状态栏"><a href="#沉浸式状态栏" class="headerlink" title="沉浸式状态栏"></a>沉浸式状态栏</h1><p>思路说完了，我们现在开始进入实战，沉浸式状态栏比较简单，没什么坑</p>
<h2 id="状态栏透明"><a href="#状态栏透明" class="headerlink" title="状态栏透明"></a>状态栏透明</h2><p>首先第一步，我们需要将状态栏的背景设置为透明，这里我直接放代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transparentStatusBar</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)</span><br><span class="line">    <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">    systemUiVisibility =</span><br><span class="line">        systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE</span><br><span class="line">    window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    window.statusBarColor = Color.TRANSPARENT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置状态栏文字颜色</span></span><br><span class="line">    setStatusBarTextColor(window, NightMode.isNightMode(window.context))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们需要将<code>FLAG_TRANSLUCENT_STATUS</code>这个<code>windowFlag</code>换成<code>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</code>，否则状态栏不会完全透明，会有一个半透明的灰色蒙层</p>
<p><code>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</code>这个<code>flag</code>表示系统<code>Bar</code>的背景将交给当前<code>window</code>绘制</p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code>这个<code>flag</code>表示<code>Activity</code>全屏显示，但状态栏不会被隐藏，依然可见</p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_STABLE</code>这个<code>flag</code>表示保持整个<code>View</code>稳定，使<code>View</code>不会因为系统UI的变化而重新<code>layout</code></p>
<p><code>SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code>和<code>SYSTEM_UI_FLAG_LAYOUT_STABLE</code>这两个<code>flag</code>通常是一起使用的，我们设置这两个<code>flag</code>，然后再将<code>statusBarColor</code>设置为透明，就达成了状态栏背景透明的效果</p>
<h2 id="状态栏文字颜色"><a href="#状态栏文字颜色" class="headerlink" title="状态栏文字颜色"></a>状态栏文字颜色</h2><p>接着我们就该设置状态栏文字颜色了，细心的小伙伴们应该已经注意到了，我在<code>transparentStatusBar</code>方法的末尾加了一个<code>setStatusBarTextColor</code>的方法调用，一般情况下，如果是日间模式，页面背景通常都是亮色，所以此时状态栏文字颜色设置为黑色比较合理，而在夜间模式下，页面背景通常都是暗色，此时状态栏文字颜色设置为白色比较合理，对应代码如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setStatusBarTextColor</span><span class="params">(window: <span class="type">Window</span>, light: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">        systemUiVisibility = <span class="keyword">if</span> (light) &#123; <span class="comment">//白色文字</span></span><br><span class="line">            systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑色文字</span></span><br><span class="line">            systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</span><br><span class="line">        &#125;</span><br><span class="line">        window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android 8.0</code>以上才支持导航栏文字颜色的修改，<code>SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</code>这个<code>flag</code>表示亮色状态栏，即黑色状态栏文字，所以如果希望状态栏文字为黑色，就设置这个<code>flag</code>，如果希望状态栏文字为白色，就将这个<code>flag</code>从<code>systemUiVisibility</code>中剔除</p>
<p>可能有小伙伴不太了解<code>kotlin</code>中的位运算，<code>kotlin</code>中的<code>or</code>、<code>and</code>、<code>inv</code>分别对应着或、与、取反运算</p>
<p>所以</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR.inv()</span><br></pre></td></tr></table></figure>

<p>翻译成<code>java</code>即为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemUiVisibility &amp; ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</span><br></pre></td></tr></table></figure>

<p>在原生系统上，这么设置就可以成功设置状态栏文字颜色，但我发现，在某些系统上，这样设置后的效果是不可预期的，譬如<code>MIUI</code>系统的状态栏文字颜色似乎是根据状态栏背景颜色自适应的，且日间模式和黑夜模式下的自适应策略还略有不同。不过在大多数情况下，它自适应的颜色都是正常的，我们就按照我们希望的结果设置就可以了。</p>
<h2 id="矫正显示区域"><a href="#矫正显示区域" class="headerlink" title="矫正显示区域"></a>矫正显示区域</h2><h3 id="fitsSystemWindows"><a href="#fitsSystemWindows" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>矫正状态栏显示区域最简单的办法就是设置<code>fitsSystemWindows</code>属性，设置了该属性的<code>View</code>的所有<code>padding</code>属性都将失效，并且系统会自动为其添加<code>paddingTop</code>（设置了透明状态栏的情况下）和<code>paddingBottom</code>（设置了透明导航栏的情况下）</p>
<p>我个人是不用这种方式的，首先它会覆盖你设置的<code>padding</code>，其次，如果你同时设置了透明状态栏和透明导航栏，这个属性没有办法分开来处理，很不灵活</p>
<h3 id="获取状态栏高度"><a href="#获取状态栏高度" class="headerlink" title="获取状态栏高度"></a>获取状态栏高度</h3><p>除了<code>fitsSystemWindows</code>这种方法外，其他的方法都得依靠获取状态栏高度了，这里直接上代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStatusBarHeight</span><span class="params">(context: <span class="type">Context</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> resId = context.resources.getIdentifier(</span><br><span class="line">        <span class="string">"status_bar_height"</span>, <span class="string">"dimen"</span>, <span class="string">"android"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> context.resources.getDimensionPixelSize(resId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态栏不像导航栏那样多变，所以直接这样获取高度就可以了，导航栏的高度飘忽不定才是真正的噩梦</p>
<p>这里再给两个设置<code>View</code> <code>margin</code>或<code>padding</code>的工具方法吧，帮助大家快速使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fixStatusBarMargin</span><span class="params">(<span class="keyword">vararg</span> views: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    views.forEach &#123; view -&gt;</span><br><span class="line">        (view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123; lp -&gt;</span><br><span class="line">            lp.topMargin = lp.topMargin + getStatusBarHeight(view.context)</span><br><span class="line">            view.requestLayout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">paddingByStatusBar</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    view.setPadding(</span><br><span class="line">        view.paddingLeft,</span><br><span class="line">        view.paddingTop + getStatusBarHeight(view.context),</span><br><span class="line">        view.paddingRight,</span><br><span class="line">        view.paddingBottom</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="沉浸式导航栏"><a href="#沉浸式导航栏" class="headerlink" title="沉浸式导航栏"></a>沉浸式导航栏</h1><p>沉浸式导航栏相比沉浸式状态栏坑会多很多，具体原因我们后面再说</p>
<h2 id="导航栏透明"><a href="#导航栏透明" class="headerlink" title="导航栏透明"></a>导航栏透明</h2><p>和沉浸式状态栏一样，第一步我们需要将导航栏的背景设置为透明</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">transparentNavigationBar</span><span class="params">(window: <span class="type">Window</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        window.isNavigationBarContrastEnforced = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION)</span><br><span class="line">    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)</span><br><span class="line">    <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">    systemUiVisibility =</span><br><span class="line">        systemUiVisibility or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span><br><span class="line">    window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    window.navigationBarColor = Color.TRANSPARENT</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置导航栏按钮或导航条颜色</span></span><br><span class="line">    setNavigationBarBtnColor(window, NightMode.isNightMode(window.context))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Android 10</code>以上，当设置了导航栏栏背景为透明时，<code>isNavigationBarContrastEnforced</code>如果为<code>true</code>，则系统会自动绘制一个半透明背景来提供对比度，所以我们要将这个属性设为<code>false</code></p>
<p>ps：状态栏其实也有对应的属性<code>isStatusBarContrastEnforced</code>，只不过这个属性默认即为<code>false</code>，我们不需要特意去设置</p>
<h2 id="导航栏按钮或导航条颜色"><a href="#导航栏按钮或导航条颜色" class="headerlink" title="导航栏按钮或导航条颜色"></a>导航栏按钮或导航条颜色</h2><p>和设置状态栏文字颜色一样，我这里就不多介绍了</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setNavigationBarBtnColor</span><span class="params">(window: <span class="type">Window</span>, light: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="keyword">var</span> systemUiVisibility = window.decorView.systemUiVisibility</span><br><span class="line">        systemUiVisibility = <span class="keyword">if</span> (light) &#123; <span class="comment">//白色按钮</span></span><br><span class="line">            systemUiVisibility and View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR.inv()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑色按钮</span></span><br><span class="line">            systemUiVisibility or View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR</span><br><span class="line">        &#125;</span><br><span class="line">        window.decorView.systemUiVisibility = systemUiVisibility</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矫正显示区域-1"><a href="#矫正显示区域-1" class="headerlink" title="矫正显示区域"></a>矫正显示区域</h2><h3 id="fitsSystemWindows-1"><a href="#fitsSystemWindows-1" class="headerlink" title="fitsSystemWindows"></a>fitsSystemWindows</h3><p>和状态栏使用一样，我就不重复说明了</p>
<h3 id="获取导航栏高度"><a href="#获取导航栏高度" class="headerlink" title="获取导航栏高度"></a>获取导航栏高度</h3><p>自从全面屏手势开始流行，导航栏也从原先的三键式，变成了三键式、导航条、全隐藏这三种情况，这三种情况下的高度也是互不相同的</p>
<p>三键式和导航条这两种情况我们都可以通过<code>android.R.dimen.navigation_bar_height</code>这个资源获取到准确高度，但现在很多系统都支持隐藏导航栏的功能，在这种情况下，虽然实际导航栏的高度应该是0，但是通过资源获取到的高度却为三键式或导航条的高度，这就给我们沉浸式导航栏的适配带来了很大困难</p>
<p>经过我的各种尝试，我发现只有一种方式可以准确的获取到当前导航栏的高度，那就是<code>WindowInsets</code>，至于<code>WindowInsets</code>是什么我就不多介绍了，我们直接看代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅当view attach window后生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealNavigationBarHeight</span><span class="params">(view: <span class="type">View</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> insets = ViewCompat.getRootWindowInsets(view)</span><br><span class="line">        ?.getInsets(WindowInsetsCompat.Type.navigationBars())</span><br><span class="line">    <span class="comment">//WindowInsets为null则默认通过资源获取高度</span></span><br><span class="line">    <span class="keyword">return</span> insets?.bottom ?: getNavigationBarHeight(view.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意到我在方法上写的注释，只有当<code>View</code>和<code>Window</code> attach 后，才能获得到<code>WindowInsets</code>，否则为<code>null</code>，所以我一开始的想法是先检查<code>View</code>是否 attach 了<code>Window</code>，如果有的话则直接调用<code>getRealNavigationBarHeight</code>方法，如果没有的话，调用<code>View.addOnAttachStateChangeListener</code>方法，当出发<code>attach</code>回调后，再调用<code>getRealNavigationBarHeight</code>方法获取高度</p>
<p>这种方式在大部分情况下运行良好，但在我一次无意中切换了系统夜间模式后发现，获取到的导航栏高度变成了0，并且这还是一个偶现的问题，于是我尝试使用<code>View.setOnApplyWindowInsetsListener</code>，监听<code>WindowInsets</code>的变化发现，这个回调有可能会触发多次，在触发多次的情况下，前几次的值都为0，只有最后一次的值为真正的导航栏高度</p>
<p>于是我准备用<code>View.setOnApplyWindowInsetsListener</code>代替<code>View.addOnAttachStateChangeListener</code>，但毕竟一个是setListener，一个是addListener，setListener有可能会把之前设置好的Listener覆盖，或者被别的Listener覆盖掉，再考虑到之后会提到的底部<code>Dialog</code>沉浸式导航栏适配的问题，我折中了一下，决定只对<code>Activity</code>下的<code>rootView</code>设置回调</p>
<p>以下是完整代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NavigationViewInfo</span></span>(</span><br><span class="line">    <span class="keyword">val</span> hostRef: WeakReference&lt;View&gt;,</span><br><span class="line">    <span class="keyword">val</span> viewRef: WeakReference&lt;View&gt;,</span><br><span class="line">    <span class="keyword">val</span> rawBottom: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> onNavHeightChangeListener: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> navigationViewInfoList = mutableListOf&lt;NavigationViewInfo&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> onApplyWindowInsetsListener = View.OnApplyWindowInsetsListener &#123; v, insets -&gt;</span><br><span class="line">    <span class="keyword">val</span> windowInsetsCompat = WindowInsetsCompat.toWindowInsetsCompat(insets, v)</span><br><span class="line">    <span class="keyword">val</span> navHeight =</span><br><span class="line">        windowInsetsCompat.getInsets(WindowInsetsCompat.Type.navigationBars()).bottom</span><br><span class="line">    <span class="keyword">val</span> it = navigationViewInfoList.iterator()</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">val</span> info = it.next()</span><br><span class="line">        <span class="keyword">val</span> host = info.hostRef.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">val</span> view = info.viewRef.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || view == <span class="literal">null</span>) &#123;</span><br><span class="line">            it.remove()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == v) &#123;</span><br><span class="line">            info.onNavHeightChangeListener(view, info.rawBottom, navHeight)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insets</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> actionMarginNavigation: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> =</span><br><span class="line">    &#123; view, rawBottomMargin, navHeight -&gt;</span><br><span class="line">        (view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams)?.let &#123;</span><br><span class="line">            it.bottomMargin = rawBottomMargin + navHeight</span><br><span class="line">            view.requestLayout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> actionPaddingNavigation: (View, <span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> =</span><br><span class="line">    &#123; view, rawBottomPadding, navHeight -&gt;</span><br><span class="line">        view.setPadding(</span><br><span class="line">            view.paddingLeft,</span><br><span class="line">            view.paddingTop,</span><br><span class="line">            view.paddingRight,</span><br><span class="line">            rawBottomPadding + navHeight</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fixNavBarMargin</span><span class="params">(<span class="keyword">vararg</span> views: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    views.forEach &#123;</span><br><span class="line">        fixSingleNavBarMargin(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fixSingleNavBarMargin</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lp = view.layoutParams <span class="keyword">as</span>? ViewGroup.MarginLayoutParams ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">val</span> rawBottomMargin = lp.bottomMargin</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> viewForCalculate = getViewForCalculate(view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewForCalculate.isAttachedToWindow) &#123;</span><br><span class="line">        <span class="keyword">val</span> realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate)</span><br><span class="line">        lp.bottomMargin = rawBottomMargin + realNavigationBarHeight</span><br><span class="line">        view.requestLayout()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听</span></span><br><span class="line">    <span class="keyword">val</span> hostRef = WeakReference(viewForCalculate)</span><br><span class="line">    <span class="keyword">val</span> viewRef = WeakReference(view)</span><br><span class="line">    <span class="keyword">val</span> info = NavigationViewInfo(hostRef, viewRef, rawBottomMargin, actionMarginNavigation)</span><br><span class="line">    navigationViewInfoList.add(info)</span><br><span class="line">    viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">paddingByNavBar</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rawBottomPadding = view.paddingBottom</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> viewForCalculate = getViewForCalculate(view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewForCalculate.isAttachedToWindow) &#123;</span><br><span class="line">        <span class="keyword">val</span> realNavigationBarHeight = getRealNavigationBarHeight(viewForCalculate)</span><br><span class="line">        view.setPadding(</span><br><span class="line">            view.paddingLeft,</span><br><span class="line">            view.paddingTop,</span><br><span class="line">            view.paddingRight,</span><br><span class="line">            rawBottomPadding + realNavigationBarHeight</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//isAttachedToWindow方法并不能保证此时的WindowInsets是正确的，仍然需要添加监听</span></span><br><span class="line">    <span class="keyword">val</span> hostRef = WeakReference(viewForCalculate)</span><br><span class="line">    <span class="keyword">val</span> viewRef = WeakReference(view)</span><br><span class="line">    <span class="keyword">val</span> info =</span><br><span class="line">        NavigationViewInfo(hostRef, viewRef, rawBottomPadding, actionPaddingNavigation)</span><br><span class="line">    navigationViewInfoList.add(info)</span><br><span class="line">    viewForCalculate.setOnApplyWindowInsetsListener(onApplyWindowInsetsListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Dialog下的View在低版本机型中获取到的WindowInsets值有误，</span></span><br><span class="line"><span class="comment">* 所以尝试去获得Activity的contentView，通过Activity的contentView获取WindowInsets</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"ContextCast"</span>)</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getViewForCalculate</span><span class="params">(view: <span class="type">View</span>)</span></span>: View &#123;</span><br><span class="line">    <span class="keyword">return</span> (view.context <span class="keyword">as</span>? ContextWrapper)?.let &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@let</span> (it.baseContext <span class="keyword">as</span>? Activity)?.findViewById&lt;View&gt;(android.R.id.content)?.rootView</span><br><span class="line">    &#125; ?: view.rootView</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 仅当view attach window后生效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealNavigationBarHeight</span><span class="params">(view: <span class="type">View</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> insets = ViewCompat.getRootWindowInsets(view)</span><br><span class="line">        ?.getInsets(WindowInsetsCompat.Type.navigationBars())</span><br><span class="line">    <span class="keyword">return</span> insets?.bottom ?: getNavigationBarHeight(view.context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我简单解释一下这段代码：为所有需要沉浸的页面的根<code>View</code>设置同一个回调，并将待适配导航栏高度的<code>View</code>添加到列表中，当<code>WindowInsets</code>回调触发后，遍历这个列表，判断触发回调的<code>View</code>的<code>host</code>是否与待适配导航栏高度的<code>View</code>对应，对应的话则处理<code>View</code>适配导航栏高度</p>
<p>这里需要注意，<code>WindowInsets</code>的分发其实是在<code>dispatchAttachedToWindow</code>之后的，所以<code>isAttachedToWindow</code>方法并不能保证此时的<code>WindowInsets</code>是正确的，具体可以去看<code>ViewRootImpl</code>中的源码，关键方法：<code>dispatchApplyInsets</code>，这里判断<code>isAttachedToWindow</code>并设置高度是为了防止出现<code>View</code>已经完全布局完成，之后再也不会触发<code>OnApplyWindowInsets</code>的情况</p>
<p>这里我也测试了内存泄漏情况，确认无内存泄漏，大家可以放心食用</p>
<h1 id="底部Dialog适配沉浸式"><a href="#底部Dialog适配沉浸式" class="headerlink" title="底部Dialog适配沉浸式"></a>底部Dialog适配沉浸式</h1><p>底部<code>Dialog</code>适配沉浸式要比正常的<code>Activity</code>更麻烦一些，主要问题也是集中在沉浸式导航栏上</p>
<h2 id="获取导航栏高度-1"><a href="#获取导航栏高度-1" class="headerlink" title="获取导航栏高度"></a>获取导航栏高度</h2><p>仔细的小伙伴们可以已经注意到了我在沉浸式导航栏获取高度那里代码中的注释，<code>Dialog</code>下的<code>View</code>在低版本机型（经测试，<code>Android 9</code>一下就会有这个问题）中获取到的<code>WindowInsets</code>值有误，所以尝试去获得<code>Activity</code>的<code>contentView</code>，通过<code>Activity</code>的<code>contentView</code>获取<code>WindowInsets</code></p>
<h2 id="LayoutParams导致的异常"><a href="#LayoutParams导致的异常" class="headerlink" title="LayoutParams导致的异常"></a>LayoutParams导致的异常</h2><p>在某些系统上（比如MIUI），当我<code>window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)</code>时，沉浸式会出现问题，状态栏会被蒙层盖住，<code>Dialog</code>底部的内容也会被一个莫名其妙的东西遮挡住</p>
<p>我的解决方案是，<code>window.setLayout(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)</code>，然后布局最外层全部占满，内部留一个底部容器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_pangu_bottom_wrapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@android:color/transparent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pangu_bottom_dialog_container"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:clickable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:focusable</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在代码中重写<code>setContentView</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> canceledOnTouchOutside = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(layoutResID: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    setContentView(</span><br><span class="line">        LayoutInflater.from(context).inflate(layoutResID, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">    setContentView(</span><br><span class="line">        view,</span><br><span class="line">        ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setContentView</span><span class="params">(view: <span class="type">View</span>, params: <span class="type">ViewGroup</span>.<span class="type">LayoutParams</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> root =</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.dialog_pangu_bottom_wrapper, <span class="literal">null</span>, <span class="literal">false</span>)</span><br><span class="line">    root.setOnClickListener &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceledOnTouchOutside) &#123;</span><br><span class="line">            dismiss()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> container = root.findViewById&lt;ViewGroup&gt;(R.id.pangu_bottom_dialog_container)</span><br><span class="line">    container.addView(view, params)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.setContentView(</span><br><span class="line">        root,</span><br><span class="line">        ViewGroup.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setCanceledOnTouchOutside</span><span class="params">(cancel: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.setCanceledOnTouchOutside(cancel)</span><br><span class="line">    canceledOnTouchOutside = cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话视觉效果就和普通的底部<code>Dialog</code>一样了，为了进一步减小底部<code>Dialog</code>显示隐藏动画之间的差异，我将动画插值器从<code>linear_interpolator</code>换成了<code>decelerate_interpolator</code>和<code>accelerate_interpolator</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_enter_from_bottom_to_top --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYDelta</span>=<span class="string">"100%"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/decelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYDelta</span>=<span class="string">"0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- dialog_exit_from_top_to_bottom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">"300"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYDelta</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">"@android:anim/accelerate_interpolator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYDelta</span>=<span class="string">"100%"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>自此，目前沉浸式遇到的问题全部都解决了，如果以后发现了什么新的问题，我会在这篇文章中补充说明，如果还有什么不明白的地方可以评论，我考虑要不要拿几个具体的场景实战讲解，各位看官老爷麻烦点个赞收个藏不迷路😄</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/12/19/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - Activity启动流程（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-12-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中，我们分析了<code>App</code>进程的启动过程，包括<code>Application</code>是怎么创建并执行<code>onCreate</code>方法的，本篇文章我们将会继续分析<code>App</code>进程启动、<code>Application</code>创建完成后，<code>Activity</code>是如何启动的</p>
<h1 id="两种路径启动Activity"><a href="#两种路径启动Activity" class="headerlink" title="两种路径启动Activity"></a>两种路径启动Activity</h1><p>我们在 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 的末尾分析过，<code>Activity</code>的启动存在两条路径</p>
<h2 id="启动进程，然后启动Activity"><a href="#启动进程，然后启动Activity" class="headerlink" title="启动进程，然后启动Activity"></a>启动进程，然后启动Activity</h2><p>这条路径就是我们在上一篇文章 <a href="https://juejin.cn/post/7172464885492613128" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中分析了前半部分：启动进程</p>
<p>当进程启动后，会执行到<code>AMS.attachApplicationLocked</code>方法，在这个方法的最后，会有一段代码检查是否有<code>Activity</code>等待启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Activity等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用<code>ActivityTaskManagerInternal.attachApplication</code>，<code>ActivityTaskManagerInternal</code>是一个抽象类，被<code>ATMS</code>的内部类<code>LocalService</code>实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController wpc)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLockWithoutBoost) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mRootWindowContainer.attachApplication(wpc);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>RootWindowContainer.attachApplication</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplication</span><span class="params">(WindowProcessController app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        mTmpRemoteException = <span class="keyword">null</span>;</span><br><span class="line">        mTmpBoolean = <span class="keyword">false</span>; <span class="comment">// Set to true if an activity was started.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> areaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; areaNdx &gt;= <span class="number">0</span>; --areaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(areaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack rootTask = taskDisplayArea.getStackAt(taskNdx);</span><br><span class="line">                <span class="keyword">if</span> (rootTask.getVisibility(<span class="keyword">null</span> <span class="comment">/*starting*/</span>) == STACK_VISIBILITY_INVISIBLE) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历ActivityStack下的所有ActivityRecord，</span></span><br><span class="line">                <span class="comment">//以其为参数调用startActivityForAttachedApplicationIfNeeded方法</span></span><br><span class="line">                <span class="keyword">final</span> PooledFunction c = PooledLambda.obtainFunction(</span><br><span class="line">                        RootWindowContainer::startActivityForAttachedApplicationIfNeeded, <span class="keyword">this</span>,</span><br><span class="line">                        PooledLambda.__(ActivityRecord<span class="class">.<span class="keyword">class</span>), <span class="title">app</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">rootTask</span>.<span class="title">topRunningActivity</span>())</span>;</span><br><span class="line">                rootTask.forAllActivities(c);</span><br><span class="line">                c.recycle();</span><br><span class="line">                <span class="keyword">if</span> (mTmpRemoteException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> mTmpRemoteException;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        didSomething |= mTmpBoolean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisible(<span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">false</span> <span class="comment">/* preserve_windows */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两层<code>for</code>循环，可以看出来，这个方法遍历了所有可见的<code>ActivityStack</code>，然后再对每个可见的<code>ActivityStack</code>进行操作</p>
<p>其中，<code>PooledLambda</code>这个类采用了池化技术，用于构造可回收复用的匿名函数，这里<code>PooledLambda.obtainFunction</code>方法得到的结果是一个<code>Function&lt;ActivityRecord, Boolean&gt;</code>，<code>forAllActivities</code>方法被定义在父类<code>WindowContainer</code>中，就是遍历执行所有<code>child</code>的<code>forAllActivities</code>方法，而<code>ActivityRecord</code>中重写了这个方法，直接用自身执行这个<code>Function</code></p>
<p>简单来说，可以将这部分代码看作以下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rootTask.forEachAllActivityRecord((activityRecord) -&gt; &#123;</span><br><span class="line">    startActivityForAttachedApplicationIfNeeded(activityRecord, app, rootTask.topRunningActivity())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接着我们来观察<code>startActivityForAttachedApplicationIfNeeded</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startActivityForAttachedApplicationIfNeeded</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowProcessController app, ActivityRecord top)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Activity是否正在finish，是否应为当前用户显示Activity，忽略锁屏情况，此Activity是否可见</span></span><br><span class="line">    <span class="comment">//对比Activity与发起进程的uid和进程名</span></span><br><span class="line">    <span class="keyword">if</span> (r.finishing || !r.okToShowLocked() || !r.visibleIgnoringKeyguard || r.app != <span class="keyword">null</span></span><br><span class="line">            || app.mUid != r.info.applicationInfo.uid || !app.mName.equals(r.processName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动Activity</span></span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.realStartActivityLocked(r, app,</span><br><span class="line">                top == r &amp;&amp; r.isFocusable() <span class="comment">/*andResume*/</span>, <span class="keyword">true</span> <span class="comment">/*checkConfig*/</span>)) &#123;</span><br><span class="line">            mTmpBoolean = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一系列的判断检查传入的<code>ActivityRecord</code>所对应的<code>Activity</code>是否需要启动，然后调用<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h2 id="已有进程，直接启动Activity"><a href="#已有进程，直接启动Activity" class="headerlink" title="已有进程，直接启动Activity"></a>已有进程，直接启动Activity</h2><p>这条路径我在 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中的末尾也分析过，如果<code>App</code>进程已经启动，则会调用<code>ActivityStackSupervisor.startSpecificActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivity</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    <span class="keyword">final</span> WindowProcessController wpc =</span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> knownToBeDead = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//启动Activity</span></span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">        knownToBeDead = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁屏状态下启动Activity防闪烁机制</span></span><br><span class="line">    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出现异常，重启进程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? <span class="string">"top-activity"</span> : <span class="string">"activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里也调用了<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h1 id="realStartActivityLocked"><a href="#realStartActivityLocked" class="headerlink" title="realStartActivityLocked"></a>realStartActivityLocked</h1><p>最终两条路径都走到了<code>ActivityStackSupervisor.realStartActivityLocked</code>方法中，那我们就来看看这个方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保所有Activity都已暂停</span></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// While there are activities pausing we skipping starting any new activities until</span></span><br><span class="line">        <span class="comment">// pauses are complete. <span class="doctag">NOTE:</span> that we also do this for activities that are starting in</span></span><br><span class="line">        <span class="comment">// the paused state because they will first be resumed then paused on the client side.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Task task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//延迟resume以避免重复resume</span></span><br><span class="line">    <span class="comment">//通过设置标记位mDeferResumeCount，只有当其为0时才能执行resume</span></span><br><span class="line">    beginDeferResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//冻结屏幕（不接收输入、不执行动画，截取屏幕进行显示）</span></span><br><span class="line">        r.startFreezingScreenLocked(proc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        <span class="comment">//收集启动缓慢信息</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        r.setProcess(proc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure activity is allowed to be resumed after process has set.</span></span><br><span class="line">        <span class="comment">//确保Activity允许被resume</span></span><br><span class="line">        <span class="keyword">if</span> (andResume &amp;&amp; !r.canResumeByCompat()) &#123;</span><br><span class="line">            andResume = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁屏状态下启动Activity防闪烁机制</span></span><br><span class="line">        r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of the screen based on the new</span></span><br><span class="line">        <span class="comment">// activity order.  Note that as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that, because the activity is</span></span><br><span class="line">        <span class="comment">// not currently running so we are just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            <span class="comment">// Deferring resume here because we're going to launch new activity shortly.</span></span><br><span class="line">            <span class="comment">// We don't want to perform a redundant launch of the same record while ensuring</span></span><br><span class="line">            <span class="comment">// configurations and trying to resume top activity of focused stack.</span></span><br><span class="line">            <span class="comment">//确保所有Activity的可见性、更新屏幕方向和配置</span></span><br><span class="line">            mRootWindowContainer.ensureVisibilityAndConfig(r, r.getDisplayId(),</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查Activity是否在后台锁屏状态下启动</span></span><br><span class="line">        <span class="keyword">if</span> (r.getRootTask().checkKeyguardVisibility(r, <span class="keyword">true</span> <span class="comment">/* shouldBeVisible */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* isTop */</span>) &amp;&amp; r.allowMoveToFront()) &#123;</span><br><span class="line">            <span class="comment">// We only set the visibility to true if the activity is not being launched in</span></span><br><span class="line">            <span class="comment">// background, and is allowed to be visible based on keyguard state. This avoids</span></span><br><span class="line">            <span class="comment">// setting this into motion in window manager that is later cancelled due to later</span></span><br><span class="line">            <span class="comment">// calls to ensure visible activities that set visibility back to false.</span></span><br><span class="line">            <span class="comment">//只有Activity不是在后台启动，才将其可见性设置为true</span></span><br><span class="line">            r.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//异常情况检查</span></span><br><span class="line"></span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line">        proc.setLastActivityLaunchTime(r.lastLaunchTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//屏幕固定功能</span></span><br><span class="line">        <span class="keyword">final</span> LockTaskController lockTaskController = mService.getLockTaskController();</span><br><span class="line">        <span class="keyword">if</span> (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE</span><br><span class="line">                || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV</span><br><span class="line">                || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED</span><br><span class="line">                        &amp;&amp; lockTaskController.getLockTaskModeState()</span><br><span class="line">                                == LOCK_TASK_MODE_LOCKED)) &#123;</span><br><span class="line">            lockTaskController.startLockTaskMode(task, <span class="keyword">false</span>, <span class="number">0</span> <span class="comment">/* blank UID */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!proc.hasThread()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;ReferrerIntent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                <span class="comment">// We don't need to deliver new intents and/or set results if activity is going</span></span><br><span class="line">                <span class="comment">// to pause immediately after launch.</span></span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是ACTIVITY_TYPE_HOME类型的应用（Launcher）</span></span><br><span class="line">            <span class="keyword">if</span> (r.isActivityTypeHome()) &#123;</span><br><span class="line">                <span class="comment">// Home process is the root process of the task.</span></span><br><span class="line">                updateHomeProcess(task.getBottomMostActivity().app);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//信息记录</span></span><br><span class="line">            mService.getPackageManagerInternalLocked().notifyPackageUse(</span><br><span class="line">                    r.intent.getComponent().getPackageName(), NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            r.setSleeping(<span class="keyword">false</span>);</span><br><span class="line">            r.forceNewConfig = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果有必要的话，显示一些App警告弹窗（不支持的CompileSdk、不支持的TargetSdk、不支持的显示大小）</span></span><br><span class="line">            mService.getAppWarningsLocked().onStartActivity(r);</span><br><span class="line">            <span class="comment">//兼容性信息</span></span><br><span class="line">            r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Because we could be starting an Activity in the system process this may not go</span></span><br><span class="line">            <span class="comment">// across a Binder interface which would create a new Configuration. Consequently</span></span><br><span class="line">            <span class="comment">// we have to always create a new Configuration here.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">                    proc.getConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">            r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">            <span class="comment">//创建或获取一个client事务</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">                    proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">            <span class="comment">//添加一条Activity启动消息</span></span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                    r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">                    dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                    r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set desired final state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置client执行事务后应处于的生命周期状态</span></span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule transaction.</span></span><br><span class="line">            <span class="comment">//调度执行此事务，启动Activity</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理重量级进程</span></span><br><span class="line">            <span class="keyword">if</span> ((proc.mInfo.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">                <span class="comment">// This may be a heavy-weight process! Note that the package manager will ensure</span></span><br><span class="line">                <span class="comment">// that only activity can run in the main process of the .apk, which is the only</span></span><br><span class="line">                <span class="comment">// thing that will be considered heavy-weight.</span></span><br><span class="line">                <span class="keyword">if</span> (proc.mName.equals(proc.mInfo.packageName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mService.mHeavyWeightProcess != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; mService.mHeavyWeightProcess != proc) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Starting new heavy weight process "</span> + proc</span><br><span class="line">                                + <span class="string">" when already running "</span></span><br><span class="line">                                + mService.mHeavyWeightProcess);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mService.setHeavyWeightProcess(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.launchFailed) &#123;</span><br><span class="line">                <span class="comment">// This is the second time we failed -- finish activity and give up.</span></span><br><span class="line">                <span class="comment">//第二次启动失败，finish掉Activity并放弃重试，直接返回false</span></span><br><span class="line">                Slog.e(TAG, <span class="string">"Second failure launching "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString() + <span class="string">", giving up"</span>, e);</span><br><span class="line">                proc.appDied(<span class="string">"2nd-crash"</span>);</span><br><span class="line">                r.finishIfPossible(<span class="string">"2nd-crash"</span>, <span class="keyword">false</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the first time we failed -- restart process and</span></span><br><span class="line">            <span class="comment">// retry.</span></span><br><span class="line">            <span class="comment">//第一次启动失败，尝试重启进程并重试启动Activity</span></span><br><span class="line">            r.launchFailed = <span class="keyword">true</span>;</span><br><span class="line">            proc.removeActivity(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.launchFailed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(lifecycler): Resume or pause requests are done as part of launch transaction,</span></span><br><span class="line">    <span class="comment">// so updating the state should be done accordingly.</span></span><br><span class="line">    <span class="comment">//更新生命周期状态</span></span><br><span class="line">    <span class="keyword">if</span> (andResume &amp;&amp; readyToResume()) &#123;</span><br><span class="line">        <span class="comment">// As part of the process of launching, ActivityThread also performs</span></span><br><span class="line">        <span class="comment">// a resume.</span></span><br><span class="line">        stack.minimalResumeActivityLocked(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity is not starting in the resumed state... which should look like we asked</span></span><br><span class="line">        <span class="comment">// it to pause+stop (but remain visible), and it has done so and reported back the</span></span><br><span class="line">        <span class="comment">// current icicle and other state.</span></span><br><span class="line">        r.setState(PAUSED, <span class="string">"realStartActivityLocked"</span>);</span><br><span class="line">        mRootWindowContainer.executeAppTransitionForAllDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Perform OOM scoring after the activity state is set, so the process can be updated with</span></span><br><span class="line">    <span class="comment">// the latest state.</span></span><br><span class="line">    <span class="comment">//更新进程oom adj，更新进程状态</span></span><br><span class="line">    proc.onStartActivity(mService.mTopProcessState, r.info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></span><br><span class="line">    <span class="comment">// launching the initial activity (that is, home), so that it can have</span></span><br><span class="line">    <span class="comment">// a chance to initialize itself while in the background, making the</span></span><br><span class="line">    <span class="comment">// switch back to it faster and look better.</span></span><br><span class="line">    <span class="keyword">if</span> (mRootWindowContainer.isTopDisplayFocusedStack(stack)) &#123;</span><br><span class="line">        mService.getActivityStartController().startSetupActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">    <span class="comment">// their client may have activities.</span></span><br><span class="line">    <span class="comment">//更新进程绑定的所有服务</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.app.updateServiceConnectionActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中最关键的部分在于创建了<code>ClientTransaction</code>事务，并向里添加了一条启动<code>Activity</code>的消息，然后调用<code>ATMS.getLifecycleManager.scheduleTransaction</code>调度执行这个事务，启动<code>Activity</code></p>
<h1 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a>ClientTransaction</h1><p>我们先来看看<code>ClientTransaction</code>这个对象是怎么创建获取的，我们首先调用了<code>ClientTransaction.obtain</code>方法，并传入了一个<code>ActivityThread</code>内部类<code>ApplicationThread</code>的<code>Binder</code>对象<code>IApplicationThread</code>和一个<code>ActivityRecord.Token</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientTransaction <span class="title">obtain</span><span class="params">(IApplicationThread client, IBinder activityToken)</span> </span>&#123;</span><br><span class="line">    ClientTransaction instance = ObjectPool.obtain(ClientTransaction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> ClientTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    instance.mClient = client;</span><br><span class="line">    instance.mActivityToken = activityToken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，从池子里拿一个实例，或者新创建一个实例对象，将这个实例对象的两个成员变量赋值后返回</p>
<p>然后我们调用了<code>ClientTransaction.addCallback</code>方法将<code>ClientTransactionItem</code>加入到回调队列中，<code>ClientTransactionItem</code>是一条能够被执行的生命周期回调消息，它是一个抽象类，子类需要实现它的<code>preExecute</code>、<code>execute</code>、<code>postExecute</code>方法</p>
<p>我们这里传入的是<code>LaunchActivityItem</code>，这条消息是用来启动<code>Activity</code>的</p>
<p>然后我们调用<code>ClientTransaction.setLifecycleStateRequest</code>设置当事务执行结束后，<code>Activity</code>应该处在一个怎样的生命周期</p>
<p>最后调用<code>ATMS.getLifecycleManager.scheduleTransaction</code>调度执行这个事务，<code>ATMS.getLifecycleManager</code>获得的是一个<code>ClientLifecycleManager</code>对象，我们沿着这个方法继续往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了回收调用<code>recycle</code>之外，我们又回到了<code>ClientTransaction</code>中，调用其<code>schedule</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又跨进程回到了<code>App</code>进程中，调用<code>ApplicationThread.scheduleTransaction</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用<code>ActivityThread.scheduleTransaction</code>执行事务，<code>ActivityThread</code>继承自<code>ClientTransactionHandler</code>，<code>scheduleTransaction</code>方法是在这里面定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，调用<code>ClientTransaction.preExecute</code>方法，然后通过<code>Handler</code>发送执行一条<code>EXECUTE_TRANSACTION</code>消息，我们先看一下<code>preExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(android.app.ClientTransactionHandler clientTransactionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = mActivityCallbacks.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            mActivityCallbacks.get(i).preExecute(clientTransactionHandler, mActivityToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLifecycleStateRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLifecycleStateRequest.preExecute(clientTransactionHandler, mActivityToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，就是遍历整个<code>callback</code>列表，执行<code>preExecute</code>方法，最后再执行<code>LifecycleStateRequest</code>的<code>preExecute</code>方法，对应到<code>Activity</code>启动流程中，就是先执行<code>LaunchActivityItem.preExecute</code>，再执行<code>ResumeActivityItem.preExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaunchActivityItem</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(ClientTransactionHandler client, IBinder token)</span> </span>&#123;</span><br><span class="line">    client.countLaunchingActivities(<span class="number">1</span>);</span><br><span class="line">    client.updateProcessState(mProcState, <span class="keyword">false</span>);</span><br><span class="line">    client.updatePendingConfiguration(mCurConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResumeActivityItem</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preExecute</span><span class="params">(ClientTransactionHandler client, IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里mUpdateProcState为false，不执行</span></span><br><span class="line">    <span class="keyword">if</span> (mUpdateProcState) &#123;</span><br><span class="line">        client.updateProcessState(mProcState, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都是一些状态更新之类的东西，我们就直接跳过，然后我们看<code>ActivityThread</code>在收到<code>EXECUTE_TRANSACTION</code>消息后做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">            mTransactionExecutor.execute(transaction);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，调用了<code>TransactionExecutor</code>对象的<code>execute</code>方法，<code>TransactionExecutor</code>对象在<code>ActivityThread</code>创建时便创建了，内部持有一个<code>ClientTransactionHandler</code>引用，即<code>ActivityThread</code>自身</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="comment">//处理需要销毁的Activities</span></span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Map&lt;IBinder, ClientTransactionItem&gt; activitiesToBeDestroyed =</span><br><span class="line">                mTransactionHandler.getActivitiesToBeDestroyed();</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token);</span><br><span class="line">        <span class="keyword">if</span> (destroyItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (transaction.getLifecycleStateRequest() == destroyItem) &#123;</span><br><span class="line">                <span class="comment">// It is going to execute the transaction that will destroy activity with the</span></span><br><span class="line">                <span class="comment">// token, so the corresponding to-be-destroyed record can be removed.</span></span><br><span class="line">                activitiesToBeDestroyed.remove(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mTransactionHandler.getActivityClient(token) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// The activity has not been created but has been requested to destroy, so all</span></span><br><span class="line">                <span class="comment">// transactions for the token are just like being cancelled.</span></span><br><span class="line">                <span class="comment">//Activity尚未被创建就被请求destroy，直接取消整个事务</span></span><br><span class="line">                Slog.w(TAG, tId(transaction) + <span class="string">"Skip pre-destroyed transaction:\n"</span></span><br><span class="line">                        + transactionToString(transaction, mTransactionHandler));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理需要销毁的<code>Activities</code>这里我们不关注，就直接跳过，然后就是分别执行各个<code>ClientTransactionItem</code>回调消息，最后让其调度执行我们设置的最终的生命周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// No callbacks to execute, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//生命周期转换相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">        ... <span class="comment">//生命周期转换，在Activity启动时不会走进这个case</span></span><br><span class="line"></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Launch activity request will create an activity record.</span></span><br><span class="line">            <span class="comment">//在执行完启动Activity后会新建一个ActivityClientRecord，重新赋值</span></span><br><span class="line">            r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//生命周期转换，在Activity启动时不会走进这个case</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于生命周期转换，由于<code>Activity</code>启动的当前阶段不会进入这些case，所以这里就不提了</p>
<p>经过简化，实际上也就执行了<code>LaunchActivityItem.execute</code>和<code>LaunchActivityItem.postExecute</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用之前在<code>AMS</code>中创建<code>LaunchActivityItem</code>所使用到的信息，创建了一个<code>ActivityClientRecord</code>对象，接着回到<code>ActivityThread</code>，调用其<code>handleLaunchActivity</code>方法</p>
<h1 id="handleLaunchActivity"><a href="#handleLaunchActivity" class="headerlink" title="handleLaunchActivity"></a>handleLaunchActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    <span class="comment">//确保Configuration为最新</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    <span class="comment">//初始化硬件加速</span></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">            &amp;&amp; (r.activityInfo.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">        HardwareRenderer.preload();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确保WMS被初始化</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint the GraphicsEnvironment that an activity is launching on the process.</span></span><br><span class="line">    <span class="comment">//通知有Activity启动</span></span><br><span class="line">    GraphicsEnvironment.hintActivityLaunch();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行启动Activity</span></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置Configuration</span></span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="comment">//设置一些延迟执行的动作（作用域到整个ClientTransaction结束）</span></span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            <span class="comment">//当Activity生命周期走到onStart前，会通过这里设置的值</span></span><br><span class="line">            <span class="comment">//判断是否需要执行onRestoreInstanceState、onPostCreate</span></span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="comment">//出现错误，停止启动Activity</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityTaskManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中，最重要的莫过于<code>performLaunchActivity</code>了，它是创建<code>Activity</code>的核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="comment">//设置LoadedApk</span></span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果启动的Activity是一个activity-alias，将Component设置为真正的Activity组件</span></span><br><span class="line">    <span class="comment">//详见：https://developer.android.com/guide/topics/manifest/activity-alias-element?hl=zh-cn</span></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为Activity创建BaseContext</span></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        <span class="comment">//实例化Activity</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建或获取Application</span></span><br><span class="line">        <span class="comment">//如果该Activity指定在其他的一个新的进程中启动（设置了android:process属性），则会新创建Application</span></span><br><span class="line">        <span class="comment">//正常不涉及多进程，都是直接获取之前创建好的Application</span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Manifest中Activity标签下的label属性</span></span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            <span class="comment">//准备Configuration</span></span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//当relaunch Activity的时候mPreserveWindow才会为true（比如说调用Activity.recreate方法）</span></span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Activity resources must be initialized with the same loaders as the</span></span><br><span class="line">            <span class="comment">// application context.</span></span><br><span class="line">            <span class="comment">//设置Activity Resource的Loaders与Application Resource的Loaders一致</span></span><br><span class="line">            appContext.getResources().addLoaders(</span><br><span class="line">                    app.getResources().getLoaders().toArray(<span class="keyword">new</span> ResourcesLoader[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            <span class="comment">//重要：绑定BaseContext、创建PhoneWindow等一系列初始化工作</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//更新网络状态</span></span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//设置主题</span></span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//调用Activity的onCreate方法</span></span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="comment">//在执行完super.onCreate方法后，mCalled会被置为true</span></span><br><span class="line">                <span class="comment">//如果mCalled为false，说明没有执行super.onCreate方法</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">            mLastReportedWindowingMode.put(activity.getActivityToken(),</span><br><span class="line">                    config.windowConfiguration.getWindowingMode());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置生命周期状态为onCreate</span></span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// updatePendingActivityConfiguration() reads from mActivities to update</span></span><br><span class="line">        <span class="comment">// ActivityClientRecord which runs in a different thread. Protect modifications to</span></span><br><span class="line">        <span class="comment">// mActivities to avoid race.</span></span><br><span class="line">        <span class="comment">//将新建的ActivityClientRecord添加到mActivities中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了以下几个工作：</p>
<ol>
<li><p>准备创建<code>Activity</code>所必要的信息，譬如类名等</p>
</li>
<li><p>为<code>Activity</code>创建<code>BaseContext</code></p>
</li>
<li><p>通过<code>Instrumentation</code>实例化<code>Activity</code></p>
</li>
<li><p>创建或获取<code>Activity</code>进程所对应的<code>Application</code></p>
</li>
<li><p>初始化<code>Activity</code>，执行各种绑定工作，创建<code>PhoneWindow</code>等</p>
</li>
<li><p>执行<code>Activity</code>的<code>onCreate</code>生命周期方法</p>
</li>
<li><p>将<code>ActivityClientRecord</code>生命周期状态设置为<code>onCreate</code></p>
</li>
</ol>
<p>我们重点看一下最主要的实例化、<code>attach</code>和<code>onCreate</code>这三点</p>
<h2 id="Instrumentation-newActivity"><a href="#Instrumentation-newActivity" class="headerlink" title="Instrumentation.newActivity"></a>Instrumentation.newActivity</h2><p>我们在 <a href="https://juejin.cn/post/7172464885492613128/#heading-14" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（中）</a> 中分析了，<code>Application</code>是怎么通过<code>Instrumentation</code>创建的，<code>Activity</code>的创建和它类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    String pkg = intent != <span class="keyword">null</span> &amp;&amp; intent.getComponent() != <span class="keyword">null</span></span><br><span class="line">            ? intent.getComponent().getPackageName() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> getFactory(pkg).instantiateActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的使用了<code>AppComponentFactory</code>创建，我们还是去看一下它的默认实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Activity <span class="title">instantiateActivity</span><span class="params">(@NonNull ClassLoader cl, @NonNull String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Activity) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，也是通过类名反射创建一个<code>Activity</code>的实例</p>
<h2 id="Activity-attach"><a href="#Activity-attach" class="headerlink" title="Activity.attach"></a>Activity.attach</h2><p>紧接着，我们来看<code>Activity.attach</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//绑定BaseContext</span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    <span class="comment">//初始化Fragment控制器</span></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并设置Window用于显示界面</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各成员变量初始化</span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    mInstrumentation = instr;</span><br><span class="line">    mToken = token;</span><br><span class="line">    mAssistToken = assistToken;</span><br><span class="line">    mIdent = ident;</span><br><span class="line">    mApplication = application;</span><br><span class="line">    mIntent = intent;</span><br><span class="line">    mReferrer = referrer;</span><br><span class="line">    mComponent = intent.getComponent();</span><br><span class="line">    mActivityInfo = info;</span><br><span class="line">    mTitle = title;</span><br><span class="line">    mParent = parent;</span><br><span class="line">    mEmbeddedID = id;</span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="keyword">if</span> (voiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mVoiceInteractor = <span class="keyword">new</span> VoiceInteractor(voiceInteractor, <span class="keyword">this</span>, <span class="keyword">this</span>,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置WindowManager、ActivityRecordToken以及是否使用硬件加速</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line"></span><br><span class="line">    mWindow.setColorMode(info.colorMode);</span><br><span class="line">    mWindow.setPreferMinimalPostProcessing(</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_PREFER_MINIMAL_POST_PROCESSING) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置自动填充选项</span></span><br><span class="line">    setAutofillOptions(application.getAutofillOptions());</span><br><span class="line">    <span class="comment">//设置内容捕获功能</span></span><br><span class="line">    setContentCaptureOptions(application.getContentCaptureOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，<code>attach</code>方法主要做了以下几件事：</p>
<ol>
<li><p>绑定<code>BaseContext</code></p>
</li>
<li><p>初始化<code>Fragment</code>控制器</p>
</li>
<li><p>创建并设置<code>Window</code></p>
</li>
<li><p>各种成员变量及其他属性初始化</p>
</li>
</ol>
<p>看完这个方法，我们可以发现，原来<code>Activity</code>的<code>Window</code>是在这个时候创建的，并且<code>Window</code>的具体实现类为<code>PhoneWindow</code></p>
<p>再然后便是通过<code>Instrumentation</code>执行<code>Activity</code>的<code>onCreate</code>生命周期方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>prePerformCreate</code>和<code>postPerformCreate</code>似乎只有在单元测试和CTS测试下才会产生实质性的影响，在正常情况下我们就当作它们不存在，我们接着看<code>performCreate</code>方法</p>
<h2 id="Activity-performCreate"><a href="#Activity-performCreate" class="headerlink" title="Activity.performCreate"></a>Activity.performCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分发PreCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPreCreated回调</span></span><br><span class="line">    dispatchActivityPreCreated(icicle);</span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// initialize mIsInMultiWindowMode and mIsInPictureInPictureMode before onCreate</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> windowingMode = getResources().getConfiguration().windowConfiguration</span><br><span class="line">            .getWindowingMode();</span><br><span class="line">    <span class="comment">//多窗口模式</span></span><br><span class="line">    mIsInMultiWindowMode = inMultiWindowMode(windowingMode);</span><br><span class="line">    <span class="comment">//画中画模式（小窗播放视频等场景）</span></span><br><span class="line">    mIsInPictureInPictureMode = windowingMode == WINDOWING_MODE_PINNED;</span><br><span class="line">    <span class="comment">//恢复请求权限中的标志位</span></span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="comment">//执行onCreate生命周期方法</span></span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//FragmentManager分发ACTIVITY_CREATED状态</span></span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    <span class="comment">//共享元素动画相关</span></span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">    <span class="comment">//分发PostCreated事件，执行所有注册的ActivityLifecycleCallbacks的onActivityPostCreated回调</span></span><br><span class="line">    dispatchActivityPostCreated(icicle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的参数<code>icicle</code>就是我们平时重写<code>Activity.onCreate</code>方法时的第一个入参<code>savedInstanceState</code>，如果<code>Activity</code>发生了重建之类的情况，它会保存一些状态数据，第一次启动<code>Activity</code>时为<code>null</code></p>
<p>无论<code>persistentState</code>是否为<code>null</code>，最终都会进入到单个参数的<code>onCreate</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//恢复LoaderManager</span></span><br><span class="line">    <span class="keyword">if</span> (mLastNonConfigurationInstances != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ActionBar</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityInfo.parentActivityName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mActionBar == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mEnableDefaultActionBarUp = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mActionBar.setDefaultDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//自动填充功能</span></span><br><span class="line">        mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, <span class="keyword">false</span>);</span><br><span class="line">        mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,</span><br><span class="line">                View.LAST_APP_AUTOFILL_ID);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">            getAutofillManager().onCreate(savedInstanceState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复FragmentManager状态</span></span><br><span class="line">        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">        mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">                ? mLastNonConfigurationInstances.fragments : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//FragmentManager分发CREATED状态，执行内部Fragment的生命周期</span></span><br><span class="line">    mFragments.dispatchCreate();</span><br><span class="line">    <span class="comment">//分发Created事件，执行所有注册的ActivityLifecycleCallbacks的onActivityCreated回调</span></span><br><span class="line">    dispatchActivityCreated(savedInstanceState);</span><br><span class="line">    <span class="comment">//语音交互功能</span></span><br><span class="line">    <span class="keyword">if</span> (mVoiceInteractor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mVoiceInteractor.attachActivity(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mRestoredFromBundle = savedInstanceState != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里表示已调用过super.onCreate方法</span></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，<code>Activity</code>的<code>onCreate</code>生命周期就走完了，我们也可以从这整个流程中得到一些新的收获，比如说，原来注册在<code>Application</code>中的<code>ActivityLifecycleCallbacks</code>回调是在这里触发的，<code>FragmentManager</code>状态分发的顺序是这样的，为什么必须要调用<code>super.onCreate</code>方法等等</p>
<p>接着，我们再回到<code>TransactionExecutor</code>中，它接下来执行的是<code>LaunchActivityItem.postExecute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.countLaunchingActivities(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就非常简单了，计数器减一</p>
<p><code>postExecute</code>执行完后，整个<code>LaunchActivityItem</code>的工作就完成了，接下来执行的是<code>TransactionExecutor.executeLifecycleState</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">    <span class="comment">//excludeLastState为true的情况下，推进生命周期直到最终生命周期的上一个生命周期</span></span><br><span class="line">    <span class="comment">//excludeLastState为false的情况下，推进生命周期直到最终生命周期</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>, transaction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">    <span class="comment">//执行最终的生命周期事务</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们目前处在的生命周期为<code>ON_CREATE</code>最终目标要到达的生命周期为<code>ON_RESUME</code>，<code>cycleToPath</code>方法会帮助我们把生命周期推进到<code>ON_RESUME</code>的上一个生命周期也就是<code>ON_START</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">    performLifecycleSequence(r, path, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TransactionExecutorHelper.getLifecyclePath</code>方法会帮我们计算出一个剩余要经过的生命周期路线的一个有序数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//错误判断</span></span><br><span class="line"></span><br><span class="line">    mLifecycleSequence.clear();</span><br><span class="line">    <span class="keyword">if</span> (finish &gt;= start) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == ON_START &amp;&amp; finish == ON_STOP) &#123;</span><br><span class="line">            <span class="comment">// A case when we from start to stop state soon, we don't need to go</span></span><br><span class="line">            <span class="comment">// through the resumed, paused state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_STOP);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// just go there</span></span><br><span class="line">            <span class="comment">//按顺序添加生命周期</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// finish &lt; start, can't just cycle down</span></span><br><span class="line">        <span class="keyword">if</span> (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123;</span><br><span class="line">            <span class="comment">// Special case when we can just directly go to resumed state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESUME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123;</span><br><span class="line">            <span class="comment">// Restart and go to required state.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to stopped state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_STOP; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Restart</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESTART);</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_START; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Relaunch and go to required state</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to destroyed state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_DESTROY; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_CREATE; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class="line">    <span class="keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实从这个方法，我们就能看出<code>Activity</code>生命周期是怎么设计的，代码很简单，我就不解释了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRE_ON_CREATE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_CREATE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_START = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESUME = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_PAUSE = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_STOP = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_DESTROY = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_RESTART = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>我们结合这上面这个生命周期大小来看，<code>start</code>为<code>ON_CREATE</code>，<code>finish</code>为<code>ON_RESUME</code>，<code>excludeLastState</code>为<code>true</code>移除最后一个生命周期，得出的结果便是<code>[ON_START]</code>，然后调用<code>performLifecycleSequence</code>方法执行生命周期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">        state = path.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                mTransactionHandler.handleStartActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* activityOptions */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                mTransactionHandler.handleResumeActivity(r, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        r.isForward, <span class="string">"LIFECYCLER_RESUME_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                mTransactionHandler.handlePauseActivity(r, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* autoEnteringPip */</span>, mPendingActions,</span><br><span class="line">                        <span class="string">"LIFECYCLER_PAUSE_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                mTransactionHandler.handleStopActivity(r, <span class="number">0</span> <span class="comment">/* configChanges */</span>,</span><br><span class="line">                        mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        <span class="string">"LIFECYCLER_STOP_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                mTransactionHandler.handleDestroyActivity(r, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                        <span class="string">"performLifecycleSequence. cycling to:"</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                mTransactionHandler.performRestartActivity(r, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected lifecycle state: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单啊，就是遍历这个数组，依次执行生命周期，结合我们传入的数组<code>[ON_START]</code>，最后便是调用<code>ActivityThread.handleStartActivity</code>方法</p>
<h1 id="handleStartActivity"><a href="#handleStartActivity" class="headerlink" title="handleStartActivity"></a>handleStartActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">final</span> Activity activity = r.activity;</span><br><span class="line">    ... <span class="comment">//检查</span></span><br><span class="line"></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start</span></span><br><span class="line">    <span class="comment">//执行onStart生命周期</span></span><br><span class="line">    activity.performStart(<span class="string">"handleStartActivity"</span>);</span><br><span class="line">    <span class="comment">//设置生命周期状态为onStart</span></span><br><span class="line">    r.setState(ON_START);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No more work to do.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore instance state</span></span><br><span class="line">    <span class="comment">//之前在handleLaunchActivity方法中设置了pendingActions.setRestoreInstanceState(true)</span></span><br><span class="line">    <span class="comment">//这里便会判断是否需要并执行Activity.onRestoreInstanceState</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call postOnCreate()</span></span><br><span class="line">    <span class="comment">//之前在handleLaunchActivity方法中设置了pendingActions.setCallOnPostCreate(true)</span></span><br><span class="line">    <span class="comment">//这里便会执行Activity.onPostCreate，如果不是从onCreate转到onStart，不会进入此case</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//调用Activity.onPostCreate</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">            <span class="comment">//和onCreate一样，onPostCreate也必须要调用super.onPostCreate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新可见性</span></span><br><span class="line">    <span class="comment">//Activity启动时，由于此时mDecor还未赋值，所以不会产生影响</span></span><br><span class="line">    updateVisibility(r, <span class="keyword">true</span> <span class="comment">/* show */</span>);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要注意，我们一般重写<code>Activity</code>的<code>onCreate</code>方法，在其中调用<code>setContentView</code>方法，此时<code>DecorView</code>虽然被创建出来了，但是只在<code>PhoneWindow</code>中持有，尚未给<code>Activity.mDecor</code>赋值，所以此时调用<code>updateVisibility</code>方法并不会将<code>DecorView</code>加入到<code>WindowManager</code>中，也就是目前界面还尚未可见</p>
<p>另外，我们可以注意到，<code>performStart</code>是先于<code>callActivityOnPostCreate</code>，所以<code>Activity</code>中的生命周期回调<code>onPostCreate</code>是在<code>onStart</code>之后触发的，各位在开发App的时候不要弄错了这一点</p>
<p>其他的地方注释都写的都很明白了哈，也没什么必要再看<code>performStart</code>了，无非也就和<code>performCreate</code>一样，执行<code>ActivityLifecycleCallbacks</code>回调，<code>FragmentManager</code>分发<code>STARTED</code>状态，调用<code>onStart</code>方法等</p>
<p>接下来我们再回到<code>TransactionExecutor</code>中，后面便是执行<code>ResumeActivityItem</code>的<code>execute</code>和<code>postExecute</code>方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    client.handleResumeActivity(r, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">            <span class="string">"RESUME_ACTIVITY"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，又执行了<code>ActivityThread.handleResumeActivity</code>方法</p>
<h1 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity"></a>handleResumeActivity</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="comment">//执行onResume生命周期</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We didn't actually resume the activity, so skipping any follow-up actions.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果Activity将被destroy，那就没必要再执行resume了，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mActivitiesToBeDestroyed.containsKey(token)) &#123;</span><br><span class="line">        <span class="comment">// Although the activity is resumed, it is going to be destroyed. So the following</span></span><br><span class="line">        <span class="comment">// UI operations are unnecessary and also prevents exception because its token may</span></span><br><span class="line">        <span class="comment">// be gone that window manager cannot recognize it. All necessary cleanup actions</span></span><br><span class="line">        <span class="comment">// performed below will be done while handling destruction.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityTaskManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置Window</span></span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        <span class="comment">//DecorView暂时不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="comment">//给Activity的mDecor成员变量赋值</span></span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">            <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">            <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">            <span class="comment">// callbacks may have changed.</span></span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果DecorView尚未添加到WindowManager中，将其添加进去，否则更新Window属性</span></span><br><span class="line">        <span class="comment">//Activity启动过程中，第一次resume时，DecorView还尚未添加至WindowManager，所以会走进上面这个case</span></span><br><span class="line">        <span class="comment">//由于我们之前将DecorView的Visibility设置成了INVISIBLE，所以此时界面还是不可见</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class="line">                <span class="comment">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class="line">                <span class="comment">// in this method), so no action will be taken. This call ensures the</span></span><br><span class="line">                <span class="comment">// callback occurs with the decor set.</span></span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">        <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">        <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">    <span class="comment">//清除遗留的东西</span></span><br><span class="line">    cleanUpPendingRemoveWindows(r, <span class="keyword">false</span> <span class="comment">/* force */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="comment">//分发Configuration更新事件</span></span><br><span class="line">        <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">            r.newConfig = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当DecorView add进WindowManager后，ViewRootImpl被创建</span></span><br><span class="line">        ViewRootImpl impl = r.window.getDecorView().getViewRootImpl();</span><br><span class="line">        WindowManager.LayoutParams l = impl != <span class="keyword">null</span></span><br><span class="line">                ? impl.mWindowAttributes : r.window.getAttributes();</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//软键盘相关</span></span><br><span class="line"></span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="comment">//使DecorView可见</span></span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当空闲时，检查处理其他后台Activity状态</span></span><br><span class="line">    <span class="comment">//对处在stopping或finishing的Activity执行onStop或onDestroy生命周期</span></span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有三个重要的地方需要注意：</p>
<ol>
<li><p>执行<code>performResumeActivity</code>，这里和之前分析的两个生命周期类似，我们后面再看</p>
</li>
<li><p>给<code>Activity</code>的<code>mDecor</code>成员变量赋值，将<code>DecorView</code>添加到<code>WindowManager</code>中，使<code>DecorView</code>可见</p>
</li>
<li><p>将上一个活动的<code>ActivityClientRecord</code>以链表的形式串在当前<code>ActivityClientRecord</code>后面，向<code>MessageQueue</code>添加一条闲时处理消息<code>Idler</code>，这条消息会遍历<code>ActivityClientRecord</code>的整条<code>nextIdle</code>链，依次检查是否需要<code>stop</code>或<code>destroy</code> <code>Activity</code>，这一点我会在后面关于<code>Activity</code>其他生命周期的文章中再分析</p>
</li>
</ol>
<p>接下来我们简单过一下<code>performResumeActivity</code>吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//状态检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为最终生命周期状态</span></span><br><span class="line">    <span class="keyword">if</span> (finalStateRequest) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">false</span>;</span><br><span class="line">        r.activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.onStateNotSaved();</span><br><span class="line">        <span class="comment">//标记Fragments状态为未保存</span></span><br><span class="line">        r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">        <span class="comment">//更新网络状态</span></span><br><span class="line">        checkAndBlockForNetworkAccess();</span><br><span class="line">        <span class="keyword">if</span> (r.pendingIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">            r.pendingIntents = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.pendingResults != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverResults(r, r.pendingResults, reason);</span><br><span class="line">            r.pendingResults = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行Activity.onResume生命周期</span></span><br><span class="line">        r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将保存信息的savedInstanceState和persistentState重置为null</span></span><br><span class="line">        r.state = <span class="keyword">null</span>;</span><br><span class="line">        r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//设置生命周期状态</span></span><br><span class="line">        r.setState(ON_RESUME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回调Activity.onTopResumedActivityChanged，报告栈顶活动Activity发生变化</span></span><br><span class="line">        reportTopResumedActivityChanged(r, r.isTopResumedActivity, <span class="string">"topWhenResuming"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">(<span class="keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityPreResumed</span></span><br><span class="line">    dispatchActivityPreResumed();</span><br><span class="line">    <span class="comment">//执行onRestart生命周期</span></span><br><span class="line">    <span class="comment">//内部会判断当前Activity是否为stop状态，是的话才会真正执行onRestart生命周期</span></span><br><span class="line">    <span class="comment">//启动Activity第一次resume时不会进入onRestart生命周期</span></span><br><span class="line">    performRestart(<span class="keyword">true</span> <span class="comment">/* start */</span>, reason);</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动填充功能</span></span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// mResumed is set by the instrumentation</span></span><br><span class="line">    <span class="comment">//执行Activity.onResume回调</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="comment">//必须执行super.onResume方法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invisible activities must be finished before onResume() completes</span></span><br><span class="line">    ... <span class="comment">//异常检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now really resume, and install the current status bar and menu.</span></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FragmentManager分发resume状态</span></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行onPostResume回调</span></span><br><span class="line">    onPostResume();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="comment">//必须要执行super.onPostResume</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onPostResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityPostResumed</span></span><br><span class="line">    dispatchActivityPostResumed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回调ActivityLifecycleCallbacks.onActivityResumed</span></span><br><span class="line">    dispatchActivityResumed();</span><br><span class="line">    <span class="comment">//共享元素动画</span></span><br><span class="line">    mActivityTransitionState.onResume(<span class="keyword">this</span>);</span><br><span class="line">    ... <span class="comment">//自动填充功能</span></span><br><span class="line">    notifyContentCaptureManagerIfNeeded(CONTENT_CAPTURE_RESUME);</span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，基本上和之前的两个生命周期的执行是一个套路，唯一需要注意的是，在执行<code>onResume</code>生命周期之前，会先检查<code>Activity</code>是否处在<code>stop</code>状态，如果是的话，则会先执行<code>onRestart</code>生命周期，其他地方我在注释上标注的应该已经很明白了，这里就不再多讲了</p>
<p>不要忘了，在<code>TransactionExecutor</code>中还有最后一步<code>ResumeActivityItem.postExecute</code>没做</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postExecute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): Use interface callback instead of AMS.</span></span><br><span class="line">        ActivityTaskManager.getService().activityResumed(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>Binder</code>又回到了系统进程调用了<code>ATMS.activityResumed</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityResumed</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ActivityRecord.activityResumedLocked(token);</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">activityResumedLocked</span><span class="params">(IBinder token, <span class="keyword">boolean</span> handleSplashScreenExit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If an app reports resumed after a long delay, the record on server side might have</span></span><br><span class="line">        <span class="comment">// been removed (e.g. destroy timeout), so the token could be null.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//SplashScreen</span></span><br><span class="line">    r.setCustomizeSplashScreenExitAnimation(handleSplashScreenExit);</span><br><span class="line">    <span class="comment">//重置savedState Bundle</span></span><br><span class="line">    r.setSavedState(<span class="keyword">null</span> <span class="comment">/* savedState */</span>);</span><br><span class="line"></span><br><span class="line">    r.mDisplayContent.handleActivitySizeCompatModeIfNeeded(r);</span><br><span class="line">    <span class="comment">//防闪烁功能</span></span><br><span class="line">    r.mDisplayContent.mUnknownAppVisibilityController.notifyAppResumedFinished(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最后也就做了一些收尾工作，到这里，整个<code>Activity</code>的启动流程也就圆满结束了</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此为止，我们<code>Activity</code>启动流程三部连续剧终于是圆满完成了，历时整整半年的时间，我心里压着的这块石头也终于是落地了，后面我应该会再做一些关于<code>Activity</code>其他生命周期变换的分析，比如说<code>Activity</code>是怎样销毁的，欢迎感兴趣的小伙伴点赞、收藏、关注我</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/10/24/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/">Android源码分析 - Activity启动流程（中）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-10-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章 <a href="https://juejin.cn/post/7130182223231188999" target="_blank" rel="noopener">Android源码分析 - Activity启动流程（上）</a> 中，我们分析了<code>Activity</code>启动流程中的一小部分，基本上可以算是<code>Activity</code>启动的前置准备工作，这篇文章我们将会分析App进程启动的主要流程</p>
<h1 id="启动App进程"><a href="#启动App进程" class="headerlink" title="启动App进程"></a>启动App进程</h1><h2 id="准备ProcessRecord"><a href="#准备ProcessRecord" class="headerlink" title="准备ProcessRecord"></a>准备ProcessRecord</h2><p>上篇文章中我们说过了，如果App尚未启动，则会调用<code>ATMS</code>的<code>startProcessAsync</code>方法去启动App进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startProcessAsync</span><span class="params">(ActivityRecord activity, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">boolean</span> isTop,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line">        <span class="comment">// ATMS lock held.</span></span><br><span class="line">        <span class="keyword">final</span> Message m = PooledLambda.obtainMessage(ActivityManagerInternal::startProcess,</span><br><span class="line">                mAmInternal, activity.processName, activity.info.applicationInfo, knownToBeDead,</span><br><span class="line">                isTop, hostingType, activity.intent.getComponent());</span><br><span class="line">        mH.sendMessage(m);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法实际上是通过<code>Hander</code>调用了<code>ActivityManagerInternal (AMS.LocalService)</code>的<code>startProcess</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startProcess</span><span class="params">(String processName, ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isTop, String hostingType, ComponentName hostingName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// If the process is known as top app, set a hint so when the process is</span></span><br><span class="line">        <span class="comment">// started, the top priority can be applied immediately to avoid cpu being</span></span><br><span class="line">        <span class="comment">// preempted by other processes before attaching the process of top app.</span></span><br><span class="line">        startProcessLocked(processName, info, knownToBeDead, <span class="number">0</span> <span class="comment">/* intentFlags */</span>,</span><br><span class="line">                <span class="keyword">new</span> HostingRecord(hostingType, hostingName, isTop),</span><br><span class="line">                ZYGOTE_POLICY_FLAG_LATENCY_SENSITIVE, <span class="keyword">false</span> <span class="comment">/* allowWhileBooting */</span>,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/* isolated */</span>, <span class="keyword">true</span> <span class="comment">/* keepIfLarge */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将进程启动的一些信息封装到了<code>HostingRecord</code>类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName,</span></span></span><br><span class="line"><span class="function"><span class="params">    ApplicationInfo info, <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    HostingRecord hostingRecord, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mProcessList.startProcessLocked(processName, info, knownToBeDead, intentFlags,</span><br><span class="line">        hostingRecord, zygotePolicyFlags, allowWhileBooting, isolated, <span class="number">0</span> <span class="comment">/* isolatedUid */</span>,</span><br><span class="line">        keepIfLarge, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">        <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>, <span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AMS</code>将启动进程的任务转交给了<code>ProcessList</code>，这个类的职责是管理进程，包括管理进程优先级(Adj)、进程OOM等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        <span class="comment">//先通过进程名和uid查找相应App的ProcessRecord</span></span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是由后台进程发起的 startProcess</span></span><br><span class="line">        <span class="comment">//判断启动进程是否为 bad process，如果是，直接启动失败返回</span></span><br><span class="line">        <span class="comment">//这里 bad process 的定义为：短时间内连续崩溃两次以上的进程</span></span><br><span class="line">        <span class="keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are in the background, then check to see if this process</span></span><br><span class="line">            <span class="comment">// is bad.  If so, we will just silently fail.</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When the user is explicitly starting a process, then clear its</span></span><br><span class="line">            <span class="comment">// crash count so that we won't make it bad until they see at</span></span><br><span class="line">            <span class="comment">// least one crash dialog again, and make the process good again</span></span><br><span class="line">            <span class="comment">// if it had been bad.</span></span><br><span class="line">            <span class="comment">//如果是用户显式的要求启动进程，则会清空启动进程的崩溃次数，将启动进程从 bad process 列表中移除</span></span><br><span class="line">            mService.mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            <span class="keyword">if</span> (mService.mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                        UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                        info.processName);</span><br><span class="line">                mService.mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app.bad = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If this is an isolated process, it can't re-use an existing process.</span></span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't have to do anything more if:</span></span><br><span class="line">    <span class="comment">// (1) There is an existing application record; and</span></span><br><span class="line">    <span class="comment">// (2) The caller doesn't think it is dead, OR there is no thread</span></span><br><span class="line">    <span class="comment">//     object attached to it so we know it couldn't have crashed; and</span></span><br><span class="line">    <span class="comment">// (3) There is a pid assigned to it, so it is either starting or</span></span><br><span class="line">    <span class="comment">//     already running.</span></span><br><span class="line">    ProcessRecord precedence = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//如果已经存在了对应App的ProcessRecord，并且分配了pid</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果进程没有死亡或者进程还未绑定binder线程，说明进程是正常运行状态或正在启动中</span></span><br><span class="line">        <span class="keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We already have the app running, or are waiting for it to</span></span><br><span class="line">            <span class="comment">// come up (we have a pid but not yet its thread), so keep it.</span></span><br><span class="line">            <span class="comment">// If this is a new package in the process, add the package to the list</span></span><br><span class="line">            <span class="comment">//将要启动的包信息记录在ProcessRecord中（Android多个App可以运行在同一个进程中）</span></span><br><span class="line">            app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);</span><br><span class="line">            <span class="keyword">return</span> app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// An application record is attached to a previous process,</span></span><br><span class="line">        <span class="comment">// clean it up now.</span></span><br><span class="line">        <span class="comment">//App绑定在之前的一个进程上了，杀死并清理这个进程</span></span><br><span class="line">        ProcessList.killProcessGroup(app.uid, app.pid);</span><br><span class="line"></span><br><span class="line">        Slog.wtf(TAG_PROCESSES, app.toString() + <span class="string">" is attached to a previous process"</span>);</span><br><span class="line">        <span class="comment">// We are not going to re-use the ProcessRecord, as we haven't dealt with the cleanup</span></span><br><span class="line">        <span class="comment">// routine of it yet, but we'd set it as the precedence of the new process.</span></span><br><span class="line">        precedence = app;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到对应的ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//新创建一个ProcessRecord对象</span></span><br><span class="line">        app = newProcessRecordLocked(info, processName, isolated, isolatedUid, hostingRecord);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed making new process record for "</span></span><br><span class="line">                    + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler = crashHandler;</span><br><span class="line">        app.isolatedEntryPoint = entryPoint;</span><br><span class="line">        app.isolatedEntryPointArgs = entryPointArgs;</span><br><span class="line">        <span class="keyword">if</span> (precedence != <span class="keyword">null</span>) &#123;</span><br><span class="line">            app.mPrecedence = precedence;</span><br><span class="line">            precedence.mSuccessor = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//存在对应的ProcessRecord，但进程尚未启动或已被清理</span></span><br><span class="line">        <span class="comment">// If this is a new package in the process, add the package to the list</span></span><br><span class="line">        <span class="comment">//将要启动的包信息记录在ProcessRecord中</span></span><br><span class="line">        app.addPackage(info.packageName, info.longVersionCode, mService.mProcessStats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the system is not ready yet, then hold off on starting this</span></span><br><span class="line">    <span class="comment">// process until it is.</span></span><br><span class="line">    <span class="comment">//如果系统尚未准备好（开机中或system_server进程崩溃重启中），将其先添加到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mProcessesReady</span><br><span class="line">            &amp;&amp; !mService.isAllowedWhileBooting(info)</span><br><span class="line">            &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mService.mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">            mService.mProcessesOnHold.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> success =</span><br><span class="line">            startProcessLocked(app, hostingRecord, zygotePolicyFlags, abiOverride);</span><br><span class="line">    <span class="keyword">return</span> success ? app : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要是处理<code>ProcessRecord</code>对象，如果找不到对应的<code>ProcessRecord</code>或对应的<code>ProcessRecord</code>里的信息表明App进程尚未启动，则会调用另一个<code>startProcessLocked</code>重载方法启动进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(app, hostingRecord, zygotePolicyFlags,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* disableHiddenApiChecks */</span>, <span class="keyword">false</span> <span class="comment">/* disableTestApiChecks */</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* mountExtStorageFull */</span>, abiOverride);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, HostingRecord hostingRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">boolean</span> disableHiddenApiChecks, <span class="keyword">boolean</span> disableTestApiChecks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> mountExtStorageFull, String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进程正在启动中</span></span><br><span class="line">    <span class="keyword">if</span> (app.pendingStart) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从刚才方法中的判断来看，应该不会进入这个case</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">        <span class="comment">//将ProcessRecord的pid从PidMap中移除</span></span><br><span class="line">        mService.removePidLocked(app);</span><br><span class="line">        app.bindMountPending = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//将ProcessRecord的pid重置为0</span></span><br><span class="line">        app.setPid(<span class="number">0</span>);</span><br><span class="line">        app.startSeq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将ProcessRecord从启动等待队列中移除</span></span><br><span class="line">    mService.mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检测当前用户是否可以启动这个App</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">        <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//默认不挂载外置存储</span></span><br><span class="line">        <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">        <span class="keyword">if</span> (!app.isolated) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line">                <span class="comment">//获取GIDS（App申请的权限）</span></span><br><span class="line">                permGids = pm.getPackageGids(app.info.packageName,</span><br><span class="line">                        MATCH_DIRECT_BOOT_AUTO, app.userId);</span><br><span class="line">                <span class="keyword">if</span> (StorageManager.hasIsolatedStorage() &amp;&amp; mountExtStorageFull) &#123;</span><br><span class="line">                    <span class="comment">//挂载外置存储，允许读写</span></span><br><span class="line">                    mountExternal = Zygote.MOUNT_EXTERNAL_FULL;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                            StorageManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    <span class="comment">//获取App对外置存储的读写权限</span></span><br><span class="line">                    mountExternal = storageManagerInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                            app.info.packageName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove any gids needed if the process has been denied permissions.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> eventually we should probably have the package manager pre-compute</span></span><br><span class="line">            <span class="comment">// this for us?</span></span><br><span class="line">            <span class="comment">//从刚刚过去的App申请权限中剔除进程所被拒绝的权限</span></span><br><span class="line">            <span class="keyword">if</span> (app.processInfo != <span class="keyword">null</span> &amp;&amp; app.processInfo.deniedPermissions != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = app.processInfo.deniedPermissions.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">int</span>[] denyGids = mService.mPackageManagerInt.getPermissionGids(</span><br><span class="line">                            app.processInfo.deniedPermissions.valueAt(i), app.userId);</span><br><span class="line">                    <span class="keyword">if</span> (denyGids != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> gid : denyGids) &#123;</span><br><span class="line">                            permGids = ArrayUtils.removeInt(permGids, gid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算得出进程所应拥有的所有权限</span></span><br><span class="line">            gids = computeGidsForProcess(mountExternal, uid, permGids);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挂载模式</span></span><br><span class="line">        app.mountMode = mountExternal;</span><br><span class="line">        <span class="comment">//工厂测试进程</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mAtmInternal.isFactoryTestProcess(app.getWindowProcessController())) &#123;</span><br><span class="line">            uid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进程启动参数（传递到Zygoto）</span></span><br><span class="line">        <span class="keyword">int</span> runtimeFlags = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果manifest中设置了android:debuggable</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_ENABLE_JDWP;</span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_JAVA_DEBUGGABLE;</span><br><span class="line">            <span class="comment">// Also turn on CheckJNI for debuggable apps. It's quite</span></span><br><span class="line">            <span class="comment">// awkward to turn on otherwise.</span></span><br><span class="line">            runtimeFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if the developer does not want ART verification</span></span><br><span class="line">            <span class="keyword">if</span> (android.provider.Settings.Global.getInt(mService.mContext.getContentResolver(),</span><br><span class="line">                    android.provider.Settings.Global.ART_VERIFIER_VERIFY_DEBUGGABLE, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                runtimeFlags |= Zygote.DISABLE_VERIFIER;</span><br><span class="line">                Slog.w(TAG_PROCESSES, app + <span class="string">": ART verification disabled"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//设置各种高进程启动参数</span></span><br><span class="line"></span><br><span class="line">        String invokeWith = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果manifest中设置了android:debuggable</span></span><br><span class="line">        <span class="comment">//使用logwrapper工具捕获stdout信息</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Debuggable apps may include a wrapper script with their library directory.</span></span><br><span class="line">            String wrapperFileName = app.info.nativeLibraryDir + <span class="string">"/wrap.sh"</span>;</span><br><span class="line">            StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(wrapperFileName).exists()) &#123;</span><br><span class="line">                    invokeWith = <span class="string">"/system/bin/logwrapper "</span> + wrapperFileName;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确定App进程使用的abi（有so库的App会通过so库的架构决定，没有so库的使用系统最优先支持的abi）</span></span><br><span class="line">        String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride : app.info.primaryCpuAbi;</span><br><span class="line">        <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将abi转成InstructionSet</span></span><br><span class="line">        String instructionSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (app.info.primaryCpuAbi != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.gids = gids;</span><br><span class="line">        app.setRequiredAbi(requiredAbi);</span><br><span class="line">        app.instructionSet = instructionSet;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String seInfo = app.info.seInfo</span><br><span class="line">                + (TextUtils.isEmpty(app.info.seInfoUser) ? <span class="string">""</span> : app.info.seInfoUser);</span><br><span class="line">        <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">        <span class="comment">//重要：设置进程启动入口</span></span><br><span class="line">        <span class="keyword">final</span> String entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动进程</span></span><br><span class="line">        <span class="keyword">return</span> startProcessLocked(hostingRecord, entryPoint, app, uid, gids,</span><br><span class="line">                runtimeFlags, zygotePolicyFlags, mountExternal, seInfo, requiredAbi,</span><br><span class="line">                instructionSet, invokeWith, startTime);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">"start failure"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这一步位置仍然是在进行准备工作，主要做了以下几件事：</p>
<ol>
<li>权限处理：App安装时会检测<code>manifest</code>里申请的权限，并由此生成出一个<code>GIDS</code>数组</li>
<li>设置挂载模式</li>
<li>设置进程的各种启动参数</li>
<li>设置App进程使用的<code>abi</code></li>
<li>设置进程启动入口</li>
<li>继续调用重载方法启动进程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startProcessLocked</span><span class="params">(HostingRecord hostingRecord, String entryPoint, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">        String seInfo, String requiredAbi, String instructionSet, String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化一些参数</span></span><br><span class="line">    <span class="comment">//标识App进程正在启动</span></span><br><span class="line">    app.pendingStart = <span class="keyword">true</span>;</span><br><span class="line">    app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">    app.removed = <span class="keyword">false</span>;</span><br><span class="line">    app.killed = <span class="keyword">false</span>;</span><br><span class="line">    app.mDisabledCompatChanges = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mPlatformCompat != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.mDisabledCompatChanges = mPlatformCompat.getDisabledChanges(app.info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startSeq = app.startSeq = ++mProcStartSeqCounter;</span><br><span class="line">    app.setStartParams(uid, hostingRecord, seInfo, startTime);</span><br><span class="line">    app.setUsingWrapper(invokeWith != <span class="keyword">null</span></span><br><span class="line">            || Zygote.getWrapProperty(app.processName) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//将ProcessRecord添加到待启动列表中</span></span><br><span class="line">    mPendingStarts.put(startSeq, app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mConstants.FLAG_PROCESS_START_ASYNC) &#123;    <span class="comment">//异步启动进程</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.i(TAG_PROCESSES,</span><br><span class="line">                <span class="string">"Posting procStart msg for "</span> + app.toShortString());</span><br><span class="line">        mService.mProcStartHandler.post(() -&gt; handleProcessStart(</span><br><span class="line">                app, entryPoint, gids, runtimeFlags, zygotePolicyFlags, mountExternal,</span><br><span class="line">                requiredAbi, instructionSet, invokeWith, startSeq));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//同步启动进程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Process.ProcessStartResult startResult = startProcess(hostingRecord,</span><br><span class="line">                    entryPoint, app,</span><br><span class="line">                    uid, gids, runtimeFlags, zygotePolicyFlags, mountExternal, seInfo,</span><br><span class="line">                    requiredAbi, instructionSet, invokeWith, startTime);</span><br><span class="line">            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper,</span><br><span class="line">                    startSeq, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">//出错，将pendingStart标志复位并强行停止进程</span></span><br><span class="line">            app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">            mService.forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid),</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, app.userId, <span class="string">"start failure"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> app.pid &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步模式下，程序会等待<code>ProcessRecord.mPrecedence</code>进程结束才会启动进程（这里对应着最开始的<code>startProcessLocked</code>方法中，已经存在了对应App的<code>ProcessRecord</code>，并且分配了<code>pid</code>，但是进程被标记为死亡这种情况）</p>
<p>最终都会进入到<code>startProcess</code>和<code>handleProcessStartedLocked</code>方法中来</p>
<h2 id="startProcess"><a href="#startProcess" class="headerlink" title="startProcess"></a>startProcess</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startProcess</span><span class="params">(HostingRecord hostingRecord, String entryPoint,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">int</span> uid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> mountExternal, String seInfo, String requiredAbi, String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        String invokeWith, <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isTopApp = hostingRecord.isTopApp();</span><br><span class="line">        <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">            <span class="comment">// Use has-foreground-activities as a temporary hint so the current scheduling</span></span><br><span class="line">            <span class="comment">// group won't be lost when the process is attaching. The actual state will be</span></span><br><span class="line">            <span class="comment">// refreshed when computing oom-adj.</span></span><br><span class="line">            app.setHasForegroundActivities(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理应用目录隔离机制</span></span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; pkgDataInfoMap;</span><br><span class="line">        Map&lt;String, Pair&lt;String, Long&gt;&gt; whitelistedAppDataInfoMap;</span><br><span class="line">        <span class="keyword">boolean</span> bindMountAppStorageDirs = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> bindMountAppsData = mAppDataIsolationEnabled</span><br><span class="line">                &amp;&amp; (UserHandle.isApp(app.uid) || UserHandle.isIsolated(app.uid))</span><br><span class="line">                &amp;&amp; mPlatformCompat.isChangeEnabled(APP_DATA_DIRECTORY_ISOLATION, app.info);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get all packages belongs to the same shared uid. sharedPackages is empty array</span></span><br><span class="line">        <span class="comment">// if it doesn't have shared uid.</span></span><br><span class="line">        <span class="keyword">final</span> PackageManagerInternal pmInt = mService.getPackageManagerInternalLocked();</span><br><span class="line">        <span class="keyword">final</span> String[] sharedPackages = pmInt.getSharedUserPackagesForPackage(</span><br><span class="line">                app.info.packageName, app.userId);</span><br><span class="line">        <span class="keyword">final</span> String[] targetPackagesList = sharedPackages.length == <span class="number">0</span></span><br><span class="line">                ? <span class="keyword">new</span> String[]&#123;app.info.packageName&#125; : sharedPackages;</span><br><span class="line"></span><br><span class="line">        pkgDataInfoMap = getPackageAppDataInfoMap(pmInt, targetPackagesList, uid);</span><br><span class="line">        <span class="keyword">if</span> (pkgDataInfoMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/152760674): Handle inode == 0 case properly, now we just give it a</span></span><br><span class="line">            <span class="comment">// tmp free pass.</span></span><br><span class="line">            bindMountAppsData = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove all packages in pkgDataInfoMap from mAppDataIsolationWhitelistedApps, so</span></span><br><span class="line">        <span class="comment">// it won't be mounted twice.</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; whitelistedApps = <span class="keyword">new</span> ArraySet&lt;&gt;(mAppDataIsolationWhitelistedApps);</span><br><span class="line">        <span class="keyword">for</span> (String pkg : targetPackagesList) &#123;</span><br><span class="line">            whitelistedApps.remove(pkg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        whitelistedAppDataInfoMap = getPackageAppDataInfoMap(pmInt,</span><br><span class="line">                whitelistedApps.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]), uid);</span><br><span class="line">        <span class="keyword">if</span> (whitelistedAppDataInfoMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(b/152760674): Handle inode == 0 case properly, now we just give it a</span></span><br><span class="line">            <span class="comment">// tmp free pass.</span></span><br><span class="line">            bindMountAppsData = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> userId = UserHandle.getUserId(uid);</span><br><span class="line">        StorageManagerInternal storageManagerInternal = LocalServices.getService(</span><br><span class="line">                StorageManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (needsStorageDataIsolation(storageManagerInternal, app)) &#123;</span><br><span class="line">            bindMountAppStorageDirs = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (pkgDataInfoMap == <span class="keyword">null</span> ||</span><br><span class="line">                    !storageManagerInternal.prepareStorageDirs(userId, pkgDataInfoMap.keySet(),</span><br><span class="line">                    app.processName)) &#123;</span><br><span class="line">                <span class="comment">// Cannot prepare Android/app and Android/obb directory or inode == 0,</span></span><br><span class="line">                <span class="comment">// so we won't mount it in zygote, but resume the mount after unlocking device.</span></span><br><span class="line">                app.bindMountPending = <span class="keyword">true</span>;</span><br><span class="line">                bindMountAppStorageDirs = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If it's an isolated process, it should not even mount its own app data directories,</span></span><br><span class="line">        <span class="comment">// since it has no access to them anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (app.isolated) &#123;</span><br><span class="line">            pkgDataInfoMap = <span class="keyword">null</span>;</span><br><span class="line">            whitelistedAppDataInfoMap = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Process.ProcessStartResult startResult;</span><br><span class="line">        <span class="keyword">if</span> (hostingRecord.usesWebviewZygote()) &#123;</span><br><span class="line">            startResult = startWebView(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName, app.mDisabledCompatChanges,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostingRecord.usesAppZygote()) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppZygote appZygote = createAppZygoteForProcessIfNeeded(app);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can't isolate app data and storage data as parent zygote already did that.</span></span><br><span class="line">            startResult = appZygote.getProcess().start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, <span class="keyword">null</span>, app.info.packageName,</span><br><span class="line">                    <span class="comment">/*zygotePolicyFlags=*/</span> ZYGOTE_POLICY_FLAG_EMPTY, isTopApp,</span><br><span class="line">                    app.mDisabledCompatChanges, pkgDataInfoMap, whitelistedAppDataInfoMap,</span><br><span class="line">                    <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//没有特别指定hostingZygote时，进入此case</span></span><br><span class="line">            startResult = Process.start(entryPoint,</span><br><span class="line">                    app.processName, uid, uid, gids, runtimeFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,</span><br><span class="line">                    app.info.dataDir, invokeWith, app.info.packageName, zygotePolicyFlags,</span><br><span class="line">                    isTopApp, app.mDisabledCompatChanges, pkgDataInfoMap,</span><br><span class="line">                    whitelistedAppDataInfoMap, bindMountAppsData, bindMountAppStorageDirs,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;PROC_START_SEQ_IDENT + app.startSeq&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>Android 11</code>开始引入了应用目录隔离机制，使得应用仅可以发现和访问自己的储存目录，不可以访问其他应用的储存目录</p>
<p>这里处理完应用目录隔离机制后，调用了<code>Process.start</code>方法启动进程，最终走到<code>ZygoteProcess.startViaZygote</code>方法</p>
<h3 id="向zygoto发送socket请求"><a href="#向zygoto发送socket请求" class="headerlink" title="向zygoto发送socket请求"></a>向zygoto发送socket请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">startViaZygote</span><span class="params">(@NonNull <span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @NonNull String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> startChildZygote,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">int</span> zygotePolicyFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> isTopApp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            pkgDataInfoMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable Map&lt;String, Pair&lt;String, Long&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            allowlistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> bindMountAppsData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">boolean</span> bindMountAppStorageDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    @Nullable String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                                                    <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">    <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">    argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">    argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">    argsForZygote.add(<span class="string">"--runtime-flags="</span> + runtimeFlags);</span><br><span class="line">    <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_INSTALLER) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-installer"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_PASS_THROUGH) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-pass-through"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_ANDROID_WRITABLE) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--mount-external-android-writable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">    <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(gids[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--invoke-with"</span>);</span><br><span class="line">        argsForZygote.add(invokeWith);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startChildZygote) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--start-child-zygote"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        argsForZygote.add(<span class="string">"--package-name="</span> + packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isTopApp) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.START_AS_TOP_APP_ARG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pkgDataInfoMap != <span class="keyword">null</span> &amp;&amp; pkgDataInfoMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(Zygote.PKG_DATA_INFO_MAP);</span><br><span class="line">        sb.append(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : pkgDataInfoMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            sb.append(entry.getKey());</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().first);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().second);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowlistedDataInfoList != <span class="keyword">null</span> &amp;&amp; allowlistedDataInfoList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(Zygote.ALLOWLISTED_DATA_INFO_MAP);</span><br><span class="line">        sb.append(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Pair&lt;String, Long&gt;&gt; entry : allowlistedDataInfoList.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (started) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">            sb.append(entry.getKey());</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().first);</span><br><span class="line">            sb.append(<span class="string">','</span>);</span><br><span class="line">            sb.append(entry.getValue().second);</span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bindMountAppStorageDirs) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.BIND_MOUNT_APP_STORAGE_DIRS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bindMountAppsData) &#123;</span><br><span class="line">        argsForZygote.add(Zygote.BIND_MOUNT_APP_DATA_DIRS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (disabledCompatChanges != <span class="keyword">null</span> &amp;&amp; disabledCompatChanges.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"--disabled-compat-changes="</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = disabledCompatChanges.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(disabledCompatChanges[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Collections.addAll(argsForZygote, extraArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mLock) &#123;</span><br><span class="line">        <span class="comment">// The USAP pool can not be used if the application will not use the systems graphics</span></span><br><span class="line">        <span class="comment">// driver.  If that driver is requested use the Zygote application start path.</span></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi),</span><br><span class="line">                                            zygotePolicyFlags,</span><br><span class="line">                                            argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的功能就很简单了，就是将各种参数拼装起来，然后调用<code>zygoteSendArgsAndGetResult</code>方法</p>
<p>我们先看<code>openZygoteSocketIfNeeded</code>这个方法，它返回了一个<code>ZygoteState</code>对象，这个类是对与<code>ZygoteServerSocket</code>建立连接后的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//尝试连接主ZygoteServerSocket</span></span><br><span class="line">        attemptConnectionToPrimaryZygote();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主zygote进程支持此abi</span></span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mZygoteSecondarySocketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">            <span class="comment">//尝试连接辅ZygoteServerSocket</span></span><br><span class="line">            attemptConnectionToSecondaryZygote();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//辅zygote进程支持此abi</span></span><br><span class="line">            <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">                <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to zygote"</span>, ioe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>attemptConnectionToxxxZygote</code>方法使用<code>LocalSocket</code>进行连接，并返回一个<code>ZygoteState</code>封装对象</p>
<p>我们之前在 <a href="https://juejin.cn/post/7051507161955827720" target="_blank" rel="noopener">Android源码分析 - Zygote进程</a> 中说过，一般，64位的cpu会启动两个<code>zygoto</code>进程，一个64位（主<code>zygote</code>），一个32位（辅<code>zygote</code>）</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89_zygote.png" alt="zygote"></p>
<p>接下来我们看<code>zygoteSendArgsAndGetResult</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, <span class="keyword">int</span> zygotePolicyFlags, @NonNull ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * See com.android.internal.os.ZygoteArguments.parseArgs()</span></span><br><span class="line"><span class="comment">        * Presently the wire format to the zygote process is:</span></span><br><span class="line"><span class="comment">        * a) a count of arguments (argc, in essence)</span></span><br><span class="line"><span class="comment">        * b) a number of newline-separated argument strings equal to count</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * After the zygote process reads these it will write the pid of</span></span><br><span class="line"><span class="comment">        * the child or -1 on failure, followed by boolean to</span></span><br><span class="line"><span class="comment">        * indicate whether a wrapper process was used.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">//构建出符合zygote解析规则的参数（argc + argv）</span></span><br><span class="line">    String msgStr = args.size() + <span class="string">"\n"</span> + String.join(<span class="string">"\n"</span>, args) + <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//USAP机制</span></span><br><span class="line">    <span class="keyword">if</span> (shouldAttemptUsapLaunch(zygotePolicyFlags, args)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> attemptUsapSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// If there was an IOException using the USAP pool we will log the error and</span></span><br><span class="line">            <span class="comment">// attempt to start the process through the Zygote.</span></span><br><span class="line">            Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with USAP pool - "</span></span><br><span class="line">                    + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attemptZygoteSendArgsAndGetResult(zygoteState, msgStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>USAP</code>机制我们先跳过，这个方法就做了一件事：拼装参数，然后调用<code>attemptZygoteSendArgsAndGetResult</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Process.<span class="function">ProcessStartResult <span class="title">attemptZygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, String msgStr)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter zygoteWriter = zygoteState.mZygoteOutputWriter;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream zygoteInputStream = zygoteState.mZygoteInputStream;</span><br><span class="line"></span><br><span class="line">        zygoteWriter.write(msgStr);</span><br><span class="line">        zygoteWriter.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line">        result.pid = zygoteInputStream.readInt();</span><br><span class="line">        result.usingWrapper = zygoteInputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        Log.e(LOG_TAG, <span class="string">"IO Exception while communicating with Zygote - "</span></span><br><span class="line">                + ex.toString());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很明显就能看出来，这是一次<code>socket</code>通信发送 -&gt; 接收</p>
<p>具体<code>zygote</code>进程接收到<code>socket</code>后做了什么可以回顾我之前写的文章 <a href="https://juejin.cn/post/7051507161955827720#heading-29" target="_blank" rel="noopener">Android源码分析 - Zygote进程</a></p>
<h2 id="handleProcessStartedLocked"><a href="#handleProcessStartedLocked" class="headerlink" title="handleProcessStartedLocked"></a>handleProcessStartedLocked</h2><p>向<code>zygote</code>发送完<code>socket</code>请求后，<code>zygote</code>开始<code>fork</code>App进程，<code>fork</code>完后会将App进程的<code>pid</code>和<code>usingWrapper</code>信息再通过<code>socket</code>传回<code>system_server</code>，此时程序会继续执行<code>handleProcessStartedLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">handleProcessStartedLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> pid, <span class="keyword">boolean</span> usingWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> expectedStartSeq, <span class="keyword">boolean</span> procAttached)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从待启动列表中移除此ProcessRecord</span></span><br><span class="line">    mPendingStarts.remove(expectedStartSeq);</span><br><span class="line">    <span class="keyword">final</span> String reason = isProcStartValidLocked(app, expectedStartSeq);</span><br><span class="line">    <span class="comment">//未通过进程启动验证，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">        killProcessQuiet(pid);</span><br><span class="line">        Process.killProcessGroup(app.uid, app.pid);</span><br><span class="line">        noteAppKill(app, ApplicationExitInfo.REASON_OTHER,</span><br><span class="line">                ApplicationExitInfo.SUBREASON_INVALID_START, reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... <span class="comment">//记录进程启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知看门狗有进程启动</span></span><br><span class="line">    Watchdog.getInstance().processStarted(app.processName, pid);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录进程启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置ProcessRecord</span></span><br><span class="line">    app.setPid(pid);</span><br><span class="line">    app.setUsingWrapper(usingWrapper);</span><br><span class="line">    app.pendingStart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//从PidMap中获取未清理的ProcessRecord</span></span><br><span class="line">    ProcessRecord oldApp;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">        oldApp = mService.mPidsSelfLocked.get(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is already an app occupying that pid that hasn't been cleaned up</span></span><br><span class="line">    <span class="comment">//清理ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (oldApp != <span class="keyword">null</span> &amp;&amp; !app.isolated) &#123;</span><br><span class="line">        mService.cleanUpApplicationRecordLocked(oldApp, <span class="keyword">false</span>, <span class="keyword">false</span>, -<span class="number">1</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将ProcessRecord添加到PidMap中</span></span><br><span class="line">    mService.addPidLocked(app);</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">        <span class="comment">//attach超时检测</span></span><br><span class="line">        <span class="keyword">if</span> (!procAttached) &#123;</span><br><span class="line">            Message msg = mService.mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = app;</span><br><span class="line">            mService.mHandler.sendMessageDelayed(msg, usingWrapper</span><br><span class="line">                    ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法将从<code>zygote</code> <code>fork</code>后得到的信息设置到<code>ProcessRecord</code>中，然后将此<code>ProcessRecord</code>添加到<code>PidMap</code>中（<code>AMS.mPidsSelfLocked</code>），后续当<code>attachApplication</code>时会用到它</p>
<h1 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><p><code>zygote</code>进程将App进程<code>fork</code>出来后，便通过反射调用我们之前设置的<code>entryPoint</code>类的<code>main</code>方法，即<code>android.app.ActivityThread.main(String[] args)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    <span class="comment">//设置拦截器，拦截部分系统调用自行处理</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    <span class="comment">//资源关闭检测器</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化用户环境</span></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="comment">//设置CA证书搜索位置</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    <span class="comment">//初始化主模块各个注册服务</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预设进程名</span></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">    <span class="comment">//查找startSeq参数</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建App进程ActivityThread实例</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置全局Handler</span></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Looper循环处理消息</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>方法中主要做了两件事，一是启动<code>Looper</code>，循环处理消息，保证进程不会退出，二是实例化<code>ActivityThread</code>并执行<code>attach</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mConfigurationController = <span class="keyword">new</span> ConfigurationController(<span class="keyword">this</span>);</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;    <span class="comment">//非系统ActivityThread</span></span><br><span class="line">        <span class="comment">//预设进程名</span></span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        <span class="comment">//处理一些错误异常需要使用ActivityThread，将其传入</span></span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">//AMS代理binder对象</span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行AMS.attachApplication方法</span></span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        <span class="comment">//每次GC时检测内存，如果内存不足则会尝试释放部分不可见的Activity</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">"Dalvik max="</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" total="</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" used="</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityTaskManager.getService().releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//系统ActivityThread</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理ConfigChanged相关逻辑（屏幕旋转之类）</span></span><br><span class="line">    ViewRootImpl.ConfigChangedCallback configChangedCallback = (Configuration globalConfig) -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">            <span class="comment">// We need to apply this change to the resources immediately, because upon returning</span></span><br><span class="line">            <span class="comment">// the view hierarchy will be informed about it.</span></span><br><span class="line">            <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResources(globalConfig,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* compat */</span>)) &#123;</span><br><span class="line">                mConfigurationController.updateLocaleListFromAppContext(</span><br><span class="line">                        mInitialApplication.getApplicationContext());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This actually changed the resources! Tell everyone about it.</span></span><br><span class="line">                <span class="keyword">final</span> Configuration updatedConfig =</span><br><span class="line">                        mConfigurationController.updatePendingConfiguration(globalConfig);</span><br><span class="line">                <span class="keyword">if</span> (updatedConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sendMessage(H.CONFIGURATION_CHANGED, globalConfig);</span><br><span class="line">                    mPendingConfiguration = updatedConfig;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ViewRootImpl.addConfigCallback(configChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>attach</code>方法最重要的一步又是调用了<code>AMS</code>的<code>attachApplication</code>方法</p>
<h1 id="AMS-attachApplication"><a href="#AMS-attachApplication" class="headerlink" title="AMS.attachApplication"></a>AMS.attachApplication</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Invalid application interface"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(@NonNull IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid, <span class="keyword">int</span> callingUid, <span class="keyword">long</span> startSeq)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the application record that is being attached...  either via</span></span><br><span class="line">    <span class="comment">// the pid if we are running in multiple processes, or just pull the</span></span><br><span class="line">    <span class="comment">// next app record if we are emulating process with anonymous threads.</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">long</span> bindApplicationTimeMillis;</span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通过pid查找PidMap中存在的ProcessRecord</span></span><br><span class="line">        <span class="comment">//对应着handleProcessStartedLocked方法中执行的中的mService.addPidLocked方法</span></span><br><span class="line">        <span class="comment">//在进程同步启动模式下，这里应该是必能取到的</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果此ProcessRecord对不上App的ProcessRecord，则将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; (app.startUid != callingUid || app.startSeq != startSeq)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If there is already an app occupying that pid that hasn't been cleaned up</span></span><br><span class="line">            cleanUpApplicationRecordLocked(app, <span class="keyword">false</span>, <span class="keyword">false</span>, -<span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">            removePidLocked(app);</span><br><span class="line">            app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It's possible that process called attachApplication before we got a chance to</span></span><br><span class="line">    <span class="comment">// update the internal state.</span></span><br><span class="line">    <span class="comment">//在进程异步启动模式下，有可能尚未执行到handleProcessStartedLocked方法</span></span><br><span class="line">    <span class="comment">//所以从PidMap中无法取到相应的ProcessRecord</span></span><br><span class="line">    <span class="comment">//这时候从ProcessList.mPendingStarts这个待启动列表中获取ProcessRecord</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; startSeq &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ProcessRecord pending = mProcessList.mPendingStarts.get(startSeq);</span><br><span class="line">        <span class="keyword">if</span> (pending != <span class="keyword">null</span> &amp;&amp; pending.startUid == callingUid &amp;&amp; pending.startSeq == startSeq</span><br><span class="line">                &amp;&amp; mProcessList.handleProcessStartedLocked(pending, pid, pending</span><br><span class="line">                        .isUsingWrapper(),</span><br><span class="line">                        startSeq, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            app = pending;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到相应的ProcessRecord，杀死进程</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span> &amp;&amp; pid != MY_PID) &#123;</span><br><span class="line">            killProcessQuiet(pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.scheduleExit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Ignore exceptions.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this application record is still attached to a previous</span></span><br><span class="line">    <span class="comment">// process, clean it up now.</span></span><br><span class="line">    <span class="comment">//如果ProcessRecord绑定了其他的ApplicationThread，则需要清理这个进程</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//注册App进程死亡回调</span></span><br><span class="line">        AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">        app.deathRecipient = adr;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//如果出现异常则重启进程</span></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        mProcessList.startProcessLocked(app,</span><br><span class="line">                <span class="keyword">new</span> HostingRecord(<span class="string">"link fail"</span>, processName),</span><br><span class="line">                ZYGOTE_POLICY_FLAG_EMPTY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化ProcessRecord各参数</span></span><br><span class="line">    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    mOomAdjuster.setAttachingSchedGroupLocked(app);</span><br><span class="line">    app.forcingToImportant = <span class="keyword">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="keyword">false</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    app.hasShownUi = <span class="keyword">false</span>;</span><br><span class="line">    app.setDebugging(<span class="keyword">false</span>);</span><br><span class="line">    app.setCached(<span class="keyword">false</span>);</span><br><span class="line">    app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">    app.killed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We carefully use the same state that PackageManager uses for</span></span><br><span class="line">    <span class="comment">// filtering, since we use this flag to decide if we need to install</span></span><br><span class="line">    <span class="comment">// providers when user is unlocked later</span></span><br><span class="line">    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除之前在handleProcessStartedLocked中设置的attach超时检测</span></span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通App启动肯定在system_server准备完成后，所以此处为true</span></span><br><span class="line">    <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//设置ContentProvider启动超时检测</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg,</span><br><span class="line">                ContentResolver.CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BackupRecord backupTarget = mBackupTargets.get(app.userId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//对应着开发者模式里的 Select debug app 和 Wait for debugger</span></span><br><span class="line">        <span class="keyword">int</span> testMode = ApplicationThreadConstants.DEBUG_OFF;</span><br><span class="line">        <span class="keyword">if</span> (mDebugApp != <span class="keyword">null</span> &amp;&amp; mDebugApp.equals(processName)) &#123;</span><br><span class="line">            testMode = mWaitForDebugger</span><br><span class="line">                ? ApplicationThreadConstants.DEBUG_WAIT</span><br><span class="line">                : ApplicationThreadConstants.DEBUG_ON;</span><br><span class="line">            app.setDebugging(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (mDebugTransient) &#123;</span><br><span class="line">                mDebugApp = mOrigDebugApp;</span><br><span class="line">                mWaitForDebugger = mOrigWaitForDebugger;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> enableTrackAllocation = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTrackAllocationApp != <span class="keyword">null</span> &amp;&amp; mTrackAllocationApp.equals(processName)) &#123;</span><br><span class="line">            enableTrackAllocation = <span class="keyword">true</span>;</span><br><span class="line">            mTrackAllocationApp = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the app is being launched for restore or full backup, set it up specially</span></span><br><span class="line">        <span class="keyword">boolean</span> isRestrictedBackupMode = <span class="keyword">false</span>;</span><br><span class="line">        ... <span class="comment">//备份相关</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActiveInstrumentation instr;</span><br><span class="line">        ... <span class="comment">//自动化测试相关</span></span><br><span class="line"></span><br><span class="line">        ApplicationInfo appInfo = instr != <span class="keyword">null</span> ? instr.mTargetInfo : app.info;</span><br><span class="line">        app.compat = compatibilityInfoForPackage(appInfo);</span><br><span class="line"></span><br><span class="line">        ProfilerInfo profilerInfo = <span class="keyword">null</span>;</span><br><span class="line">        String preBindAgent = <span class="keyword">null</span>;</span><br><span class="line">        ... <span class="comment">//性能分析相关</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We deprecated Build.SERIAL and it is not accessible to</span></span><br><span class="line">        <span class="comment">// Instant Apps and target APIs higher than O MR1. Since access to the serial</span></span><br><span class="line">        <span class="comment">// is now behind a permission we push down the value.</span></span><br><span class="line">        <span class="comment">//序列号（Android 8.0后不可再通过Build.SERIAL获取序列号）</span></span><br><span class="line">        <span class="keyword">final</span> String buildSerial = (!appInfo.isInstantApp()</span><br><span class="line">                &amp;&amp; appInfo.targetSdkVersion &lt; Build.VERSION_CODES.P)</span><br><span class="line">                        ? sTheRealBuildSerial : Build.UNKNOWN;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        ... <span class="comment">//自动化测试相关</span></span><br><span class="line">        ... <span class="comment">//性能分析相关</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//debug模式</span></span><br><span class="line">        <span class="keyword">if</span> ((app.info.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            thread.attachStartupAgents(app.info.dataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//自动填充功能（账号密码等）</span></span><br><span class="line">        ... <span class="comment">//内容捕获相关（ContentCaptureManager）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动化测试</span></span><br><span class="line">        <span class="keyword">final</span> ActiveInstrumentation instr2 = app.getActiveInstrumentation();</span><br><span class="line">        <span class="keyword">if</span> (mPlatformCompat != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPlatformCompat.resetReporting(app.info);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ProviderInfoList providerList = ProviderInfoList.fromList(providers);</span><br><span class="line">        <span class="comment">//调用ApplicationThread.bindApplication方法</span></span><br><span class="line">        <span class="keyword">if</span> (app.isolatedEntryPoint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This is an isolated process which should just call an entry point instead of</span></span><br><span class="line">            <span class="comment">// being bound to an application.</span></span><br><span class="line">            thread.runIsolatedEntryPoint(app.isolatedEntryPoint, app.isolatedEntryPointArgs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instr2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providerList,</span><br><span class="line">                    instr2.mClass,</span><br><span class="line">                    profilerInfo, instr2.mArguments,</span><br><span class="line">                    instr2.mWatcher,</span><br><span class="line">                    instr2.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                    app.mDisabledCompatChanges);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providerList, <span class="keyword">null</span>, profilerInfo,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.isPersistent(),</span><br><span class="line">                    <span class="keyword">new</span> Configuration(app.getWindowProcessController().getConfiguration()),</span><br><span class="line">                    app.compat, getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, autofillOptions, contentCaptureOptions,</span><br><span class="line">                    app.mDisabledCompatChanges);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make app active after binding application or client may be running requests (e.g</span></span><br><span class="line">        <span class="comment">// starting activities) before it is ready.</span></span><br><span class="line">        <span class="comment">//ProcessRecord保存ApplicationThread代理对象</span></span><br><span class="line">        app.makeActive(thread, mProcessStats);</span><br><span class="line">        <span class="comment">//更新进程使用情况</span></span><br><span class="line">        mProcessList.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//出现错误，杀死进程</span></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        app.kill(<span class="string">"error during bind"</span>, ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this record from the list of starting applications.</span></span><br><span class="line">    <span class="comment">//从persistent启动列表中移除此ProcessRecord</span></span><br><span class="line">    <span class="comment">//persistent是manifest中application标签下的一个属性</span></span><br><span class="line">    <span class="comment">//设置了此属性代表此App会跟随系统启动而启动</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Activity等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find any services that should be running in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有Services等待启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if a next-broadcast receiver is in this process...</span></span><br><span class="line">    <span class="comment">//检查是否有广播接收器需要启动</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//备份相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上几步发生异常，杀死App进程</span></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        <span class="comment">//更新进程OOM等级</span></span><br><span class="line">        updateOomAdjLocked(app, OomAdjuster.OOM_ADJ_REASON_PROCESS_BEGIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下这个方法主要做了哪些事，首先获取<code>ProcessRecord</code>，然后对其做一些初始化设置，然后调用<code>ApplicaionThread.bindApplication</code>方法，最后分别检查处理<code>Activity</code>、<code>Service</code>和<code>BroadcastReceiver</code>的启动</p>
<h2 id="获取ProcessRecord"><a href="#获取ProcessRecord" class="headerlink" title="获取ProcessRecord"></a>获取ProcessRecord</h2><p>我们看一下这个方法是怎么获取<code>ProcessRecord</code>的，我们先回顾一下之前在<code>startProcessLocked</code>方法的最后，会使用同步或异步的方式启动进程，最终两者都会调用<code>startProcess</code>和<code>handleProcessStartedLocked</code>方法</p>
<h3 id="同步启动进程"><a href="#同步启动进程" class="headerlink" title="同步启动进程"></a>同步启动进程</h3><p>我们回顾一下之前讲到的<code>ActivityManagerInternal.startProcess</code>方法，可以发现它内部使用了<code>synchronized (ActivityManagerService.this)</code>加锁，而<code>AMS.attachApplication</code>方法同样也使用了<code>AMS</code>实例对象加了锁，所以在同步启动进程的情况下，必然会先执行<code>handleProcessStartedLocked</code>方法，再执行<code>attachApplication</code>方法，根据之前所分析的，<code>handleProcessStartedLocked</code>方法会将<code>ProcessRecord</code>存到PidMap中，然后<code>attachApplication</code>方法又会从PidMap中去取，此时取出的<code>ProcessRecord</code>必然不为<code>null</code></p>
<h3 id="异步启动进程"><a href="#异步启动进程" class="headerlink" title="异步启动进程"></a>异步启动进程</h3><p>在异步启动进程的情况下，是通过<code>Handler</code>将启动进程的工作插入到任务队列中，这个任务的执行是不在锁的作用域范围内的，在这个任务内没有对<code>startProcess</code>方法加锁，只对<code>handleProcessStartedLocked</code>方法加了锁，所以这里会有两种情况：</p>
<ul>
<li><p>先执行<code>handleProcessStartedLocked</code>方法，再执行<code>attachApplication</code>方法</p>
<p>  这种情况和同步启动进程的执行顺序是一样的，<code>ProcessRecord</code>获取方式也相同</p>
</li>
<li><p>先执行<code>attachApplication</code>方法，再执行<code>handleProcessStartedLocked</code>方法</p>
<p>  这种情况下，PidMap中取不到相应的<code>ProcessRecord</code>，此时<code>ProcessList.mPendingStarts</code>中还没有将<code>ProcessRecord</code>移除，所以会从<code>mPendingStarts</code>这个启动列表中取出<code>ProcessRecord</code>，然后再调用<code>handleProcessStartedLocked</code>方法，等到<code>attachApplication</code>方法走完，锁释放后，在进入到外部的<code>handleProcessStartedLocked</code>重载方法，这个方法会先判断<code>mPendingStarts</code>中是否还存在对应的<code>ProcessRecord</code>，如果不存在，便会直接返回，保证<code>handleProcessStartedLocked</code>方法只执行一次</p>
</li>
</ul>
<h1 id="ApplicationThread-bindApplication"><a href="#ApplicationThread-bindApplication" class="headerlink" title="ApplicationThread.bindApplication"></a>ApplicationThread.bindApplication</h1><p>接着，我们继续看重点方法<code>ApplicationThread.bindApplication</code></p>
<p><code>ApplicationThread</code>是<code>ActivityThread</code>的一个内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProviderInfoList providerList, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span></span></span><br><span class="line"><span class="function"><span class="params">        String buildSerial, AutofillOptions autofillOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentCaptureOptions contentCaptureOptions, <span class="keyword">long</span>[] disabledCompatChanges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (services != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Setup the service cache in the ServiceManager</span></span><br><span class="line">        <span class="comment">//初始化通用系统服务缓存</span></span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providerList.getList();</span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line">    data.buildSerial = buildSerial;</span><br><span class="line">    data.autofillOptions = autofillOptions;</span><br><span class="line">    data.contentCaptureOptions = contentCaptureOptions;</span><br><span class="line">    data.disabledCompatChanges = disabledCompatChanges;</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，只是将参数包装成一个<code>AppBindData</code>，然后通过<code>Handler</code>发送消息处理，根据消息的类型，最终会调用<code>ActivityThread.handleBindApplication</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Register the UI Thread as a sensitive thread to the runtime.</span></span><br><span class="line">    <span class="comment">//将UI线程注册成JIT敏感线程</span></span><br><span class="line">    VMRuntime.registerSensitiveThread();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    ... <span class="comment">//性能分析相关</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send up app name; do this *before* waiting for debugger</span></span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName,</span><br><span class="line">                                            data.appInfo.packageName,</span><br><span class="line">                                            UserHandle.myUserId());</span><br><span class="line">    VMRuntime.setProcessPackageName(data.appInfo.packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass data directory path to ART. This is used for caching information and</span></span><br><span class="line">    <span class="comment">// should be set before any application code is loaded.</span></span><br><span class="line">    <span class="comment">//设置进程数据目录</span></span><br><span class="line">    VMRuntime.setProcessDataDirectory(data.appInfo.dataDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性能分析相关</span></span><br><span class="line">    <span class="keyword">if</span> (mProfiler.profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the app is Honeycomb MR1 or earlier, switch its AsyncTask</span></span><br><span class="line">    <span class="comment">// implementation to use the pool executor.  Normally, we use the</span></span><br><span class="line">    <span class="comment">// serialized executor as the default. This has to happen in the</span></span><br><span class="line">    <span class="comment">// main thread so the main looper is set right.</span></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion小于等于 3.1 (12) 时，AsyncTask使用线程池实现</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the util.*Array classes maintain "undefined" for apps targeting Pie or earlier.</span></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion大于等于 10 (29) 时，针对Android SDK提供的容器（SparseArray等）</span></span><br><span class="line">    <span class="comment">//如果index越界，会主动抛ArrayIndexOutOfBoundsException异常</span></span><br><span class="line">    <span class="comment">//（之前数组越界的行为未被定义）</span></span><br><span class="line">    UtilConfig.setThrowExceptionForUpperArrayOutOfBounds(</span><br><span class="line">            data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.Q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当App的targetSdkVersion大于等于 5.0 (21) 时，回收正在使用的Message会抛出异常</span></span><br><span class="line">    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prior to P, internal calls to decode Bitmaps used BitmapFactory,</span></span><br><span class="line">    <span class="comment">// which may scale up to account for density. In P, we switched to</span></span><br><span class="line">    <span class="comment">// ImageDecoder, which skips the upscale to save memory. ImageDecoder</span></span><br><span class="line">    <span class="comment">// needs to still scale up in older apps, in case they rely on the</span></span><br><span class="line">    <span class="comment">// size of the Bitmap without considering its density.</span></span><br><span class="line">    ImageDecoder.sApiLevel = data.appInfo.targetSdkVersion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Before spawning a new process, reset the time zone to be the system time zone.</span></span><br><span class="line"><span class="comment">    * This needs to be done because the system time zone could have changed after the</span></span><br><span class="line"><span class="comment">    * the spawning of this process. Without doing this this process would have the incorrect</span></span><br><span class="line"><span class="comment">    * system time zone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Set the LocaleList. This may change once we create the App Context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Configuration</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Update the system configuration since its preloaded and might not</span></span><br><span class="line"><span class="comment">        * reflect configuration changes. The configuration object passed</span></span><br><span class="line"><span class="comment">        * in AppBindData can be safely assumed to be up to date</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">        mCurDefaultDisplayDpi = data.config.densityDpi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This calls mResourcesManager so keep it within the synchronized block.</span></span><br><span class="line">        applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadedApk</span></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//性能分析器代理JVM（JVMTI）</span></span><br><span class="line">    <span class="keyword">if</span> (agent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAttachAgent(agent, data.info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Switch this process to density compatibility mode if needed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//在manifest，supports-screens标签中设置了android:anyDensity</span></span><br><span class="line">    <span class="comment">//详见：https://developer.android.com/guide/topics/manifest/supports-screens-element#any</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES)</span><br><span class="line">            == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//指示App包含用于适应任何屏幕密度的资源</span></span><br><span class="line">        mDensityCompatMode = <span class="keyword">true</span>;</span><br><span class="line">        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置默认密度</span></span><br><span class="line">    updateDefaultDensity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置 12/24 小时时间制 */</span></span><br><span class="line">    <span class="keyword">final</span> String use24HourSetting = mCoreSettings.getString(Settings.System.TIME_12_24);</span><br><span class="line">    Boolean is24Hr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (use24HourSetting != <span class="keyword">null</span>) &#123;</span><br><span class="line">        is24Hr = <span class="string">"24"</span>.equals(use24HourSetting) ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// null : use locale default for 12/24 hour formatting,</span></span><br><span class="line">    <span class="comment">// false : use 12 hour format,</span></span><br><span class="line">    <span class="comment">// true : use 24 hour format.</span></span><br><span class="line">    DateFormat.set24HourTimePref(is24Hr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新view debug属性sDebugViewAttributes</span></span><br><span class="line">    <span class="comment">//设置了这个属性，View将会保存它本身的属性</span></span><br><span class="line">    <span class="comment">//和Layout Inspector相关</span></span><br><span class="line">    updateDebugViewAttributeState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化默认线程策略</span></span><br><span class="line">    StrictMode.initThreadDefaults(data.appInfo);</span><br><span class="line">    <span class="comment">//初始化默认VM策略</span></span><br><span class="line">    StrictMode.initVmDefaults(data.appInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//debug模式</span></span><br><span class="line">    <span class="keyword">if</span> (data.debugMode != ApplicationThreadConstants.DEBUG_OFF) &#123;</span><br><span class="line">        <span class="comment">// XXX should have option to change the port.</span></span><br><span class="line">        Debug.changeDebugPort(<span class="number">8100</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.debugMode == ApplicationThreadConstants.DEBUG_WAIT) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                    + <span class="string">" is waiting for the debugger on port 8100..."</span>);</span><br><span class="line"></span><br><span class="line">            IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Debug.waitForDebugger();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                    + <span class="string">" can be debugged on port 8100..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow binder tracing, and application-generated systrace messages if we're profileable.</span></span><br><span class="line">    <span class="comment">//性能分析模式</span></span><br><span class="line">    <span class="keyword">boolean</span> isAppProfileable = data.appInfo.isProfileableByShell();</span><br><span class="line">    <span class="comment">//允许应用程序跟踪</span></span><br><span class="line">    Trace.setAppTracingAllowed(isAppProfileable);</span><br><span class="line">    <span class="keyword">if</span> ((isAppProfileable || Build.IS_DEBUGGABLE) &amp;&amp; data.enableBinderTracking) &#123;</span><br><span class="line">        Binder.enableTracing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize heap profiling.</span></span><br><span class="line">    <span class="comment">//初始化堆分析</span></span><br><span class="line">    <span class="keyword">if</span> (isAppProfileable || Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">        nInitZygoteChildHeapProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow renderer debugging features if we're debuggable.</span></span><br><span class="line">    <span class="keyword">boolean</span> isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//开启硬件加速调试功能</span></span><br><span class="line">    HardwareRenderer.setDebuggingEnabled(isAppDebuggable || Build.IS_DEBUGGABLE);</span><br><span class="line">    HardwareRenderer.setPackageName(data.appInfo.packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the default http proxy in this process for the reasons we set the time zone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//设置默认HTTP代理</span></span><br><span class="line">    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// In pre-boot mode (doing initial launch to collect password), not</span></span><br><span class="line">        <span class="comment">// all system is up.  This includes the connectivity service, so don't</span></span><br><span class="line">        <span class="comment">// crash if we can't get it.</span></span><br><span class="line">        <span class="keyword">final</span> IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Proxy.setHttpProxySystemProperty(service.getProxyForNetwork(<span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instrumentation info affects the class loader, so load it before</span></span><br><span class="line">    <span class="comment">// setting up the app context.</span></span><br><span class="line">    <span class="comment">//准备自动化测试信息</span></span><br><span class="line">    <span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">    <span class="keyword">if</span> (data.instrumentationName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ii = <span class="keyword">new</span> ApplicationPackageManager(</span><br><span class="line">                    <span class="keyword">null</span>, getPackageManager(), getPermissionManager())</span><br><span class="line">                    .getInstrumentationInfo(data.instrumentationName, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to find instrumentation info for: "</span> + data.instrumentationName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Warn of potential ABI mismatches.</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        mInstrumentationPackageName = ii.packageName;</span><br><span class="line">        mInstrumentationAppDir = ii.sourceDir;</span><br><span class="line">        mInstrumentationSplitAppDirs = ii.splitSourceDirs;</span><br><span class="line">        mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);</span><br><span class="line">        mInstrumentedAppDir = data.info.getAppDir();</span><br><span class="line">        mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();</span><br><span class="line">        mInstrumentedLibDir = data.info.getLibDir();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ii = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Context</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    <span class="comment">//更新区域列表</span></span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldMask = StrictMode.allowThreadDiskWritesMask();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            setupGraphicsSupport(appContext);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            StrictMode.setThreadPolicyMask(oldMask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HardwareRenderer.setIsolatedProcess(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the Network Security Config Provider. This must happen before the application</span></span><br><span class="line">    <span class="comment">// code is loaded to prevent issues with instances of TLS objects being created before</span></span><br><span class="line">    <span class="comment">// the provider is installed.</span></span><br><span class="line">    <span class="comment">//网络安全设置</span></span><br><span class="line">    NetworkSecurityConfigProvider.install(appContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue loading instrumentation.</span></span><br><span class="line">    <span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123; <span class="comment">//如果设置了自动化测试，实例化指定的自动化测试类</span></span><br><span class="line">        ApplicationInfo instrApp;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instrApp = getPackageManager().getApplicationInfo(ii.packageName, <span class="number">0</span>,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            instrApp = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (instrApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instrApp = <span class="keyword">new</span> ApplicationInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        ii.copyTo(instrApp);</span><br><span class="line">        instrApp.initForUser(UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">final</span> LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,</span><br><span class="line">                appContext.getClassLoader(), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The test context's op package name == the target app's op package name, because</span></span><br><span class="line">        <span class="comment">// the app ops manager checks the op package name against the real calling UID,</span></span><br><span class="line">        <span class="comment">// which is what the target package name is associated with.</span></span><br><span class="line">        <span class="keyword">final</span> ContextImpl instrContext = ContextImpl.createAppContext(<span class="keyword">this</span>, pi,</span><br><span class="line">                appContext.getOpPackageName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate instrumentation "</span></span><br><span class="line">                + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ComponentName component = <span class="keyword">new</span> ComponentName(ii.packageName, ii.name);</span><br><span class="line">        mInstrumentation.init(<span class="keyword">this</span>, instrContext, appContext, component,</span><br><span class="line">                data.instrumentationWatcher, data.instrumentationUiAutomationConnection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfiler.profileFile != <span class="keyword">null</span> &amp;&amp; !ii.handleProfiling</span><br><span class="line">                &amp;&amp; mProfiler.profileFd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mProfiler.handlingProfiling = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">final</span> File file = <span class="keyword">new</span> File(mProfiler.profileFile);</span><br><span class="line">            file.getParentFile().mkdirs();</span><br><span class="line">            Debug.startMethodTracing(file.toString(), <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//直接实例化Instrumentation</span></span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">        mInstrumentation.basicInit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整应用可用内存上限</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != <span class="number">0</span>) &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Small heap, clamp to the current growth limit and let the heap release</span></span><br><span class="line">        <span class="comment">// pages after the growth limit to the non growth limit capacity. b/18387825</span></span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow disk access during application and provider setup. This could</span></span><br><span class="line">    <span class="comment">// block processing ordered broadcasts, but later processing would</span></span><br><span class="line">    <span class="comment">// probably end up doing the same disk access.</span></span><br><span class="line">    Application app;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy writesAllowedPolicy = StrictMode.getThreadPolicy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">        <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate autofill compat state</span></span><br><span class="line">        <span class="comment">//设置自动填充功能</span></span><br><span class="line">        app.setAutofillOptions(data.autofillOptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate Content Capture options</span></span><br><span class="line">        <span class="comment">//设置内容捕获功能</span></span><br><span class="line">        app.setContentCaptureOptions(data.contentCaptureOptions);</span><br><span class="line"></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">        <span class="comment">// app's custom Application class</span></span><br><span class="line">        <span class="comment">//在非受限模式下启动ContentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">        <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">        <span class="comment">//执行onCreate方法（默认Instrumentation实现为空方法）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行Application的onCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If the app targets &lt; O-MR1, or doesn't change the thread policy</span></span><br><span class="line">        <span class="comment">// during startup, clobber the policy to maintain behavior of b/36951662</span></span><br><span class="line">        <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt; Build.VERSION_CODES.O_MR1</span><br><span class="line">                || StrictMode.getThreadPolicy().equals(writesAllowedPolicy)) &#123;</span><br><span class="line">            StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preload fonts resources</span></span><br><span class="line">    <span class="comment">//预加载字体资源</span></span><br><span class="line">    FontsContract.setApplicationContextForResources(appContext);</span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ApplicationInfo info =</span><br><span class="line">                    getPackageManager().getApplicationInfo(</span><br><span class="line">                            data.appInfo.packageName,</span><br><span class="line">                            PackageManager.GET_META_DATA <span class="comment">/*flags*/</span>,</span><br><span class="line">                            UserHandle.myUserId());</span><br><span class="line">            <span class="keyword">if</span> (info.metaData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> preloadedFontsResource = info.metaData.getInt(</span><br><span class="line">                        ApplicationInfo.METADATA_PRELOADED_FONTS, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (preloadedFontsResource != <span class="number">0</span>) &#123;</span><br><span class="line">                    data.info.getResources().preloadFonts(preloadedFontsResource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很重要，我们先过一下几个重点部分，然后再按着主线继续往下研究：</p>
<ul>
<li><p><code>Debug</code>、<code>Profiler</code>、<code>Layout Inspector</code></p>
<p><code>Android</code>应用开发的同学对这三样肯定不陌生，在<code>Android Studio</code>中我们可以对App进行调试，性能分析和布局检查，在这个方法中，我们可以找到与这三样相关的一些代码</p>
</li>
<li><p>获取<code>LoadedApk</code></p>
<p><code>LoadedApk</code>是<code>Apk</code>文件在内存中的表示，包含了<code>Apk</code>文件中的代码、资源、组件、<code>manifest</code>等信息</p>
</li>
<li><p>创建<code>Context</code></p>
<p>这里通过<code>ActivityThread</code>和<code>LoadedApk</code>创建出了一个<code>ContextImpl</code></p>
</li>
<li><p>实例化<code>Instrumentation</code></p>
<p>这里和自动化测试相关，如果设置了自动化测试，实例化指定的自动化测试类，否则实例化默认的<code>Instrumentation</code></p>
</li>
<li><p>创建<code>Application</code></p>
<p>这里根据<code>LoadedApk</code>创建出相应的<code>Application</code>，需要注意，这里创建的<code>Application</code>并不与上面创建出的<code>ContextImpl</code>绑定，而是在创建<code>Application</code>的过程中，以同样的参数重新创建了一个<code>ContextImpl</code>，然后调用<code>attachBaseContext</code>方法绑定它</p>
</li>
<li><p>设置<code>HTTP</code>代理</p>
<p>App在启动过程中设置<code>HTTP</code>代理，所以我们在开发过程中使用代理抓包等时候需要注意，设置了代理后需要重启App才会生效</p>
</li>
<li><p>启动<code>ContentProvider</code></p>
<p><code>ContentProvider</code>的启动过程以后会新开文章进行分析，这里只需要知道<code>ContentProvider</code>启动的入口在这就行了</p>
</li>
<li><p>执行<code>Application</code>的<code>onCreate</code>方法</p>
<p>当创建完<code>Application</code>，执行<code>attachBaseContext</code>方法后，便会调用<code>onCreate</code>方法</p>
</li>
</ul>
<p>我们拣重点来看，首先是<code>Application</code>的创建过程</p>
<h2 id="LoadedApk-makeApplication"><a href="#LoadedApk-makeApplication" class="headerlink" title="LoadedApk.makeApplication"></a>LoadedApk.makeApplication</h2><p>在上文的方法中，调用了<code>data.info.makeApplication</code>方法创建<code>Application</code>，其中<code>data.info</code>为<code>LoadedApk</code>类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果之前创建过了就可以直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Application类名（App可以自定义Application这个应该所有开发都知道吧）</span></span><br><span class="line">    <span class="comment">//对应AndroidManifest中application标签下的android:name属性</span></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    <span class="comment">//没有设置自定义Application或强制使用默认Application的情况下，使用默认Application</span></span><br><span class="line">    <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化ContextClassLoader</span></span><br><span class="line">        <span class="keyword">final</span> java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rewrite the R 'constants' for all library apks.</span></span><br><span class="line">        <span class="comment">//Android共享库资源ID动态映射</span></span><br><span class="line">        SparseArray&lt;String&gt; packageIdentifiers = getAssets().getAssignedPackageIdentifiers(</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = packageIdentifiers.size(); i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = packageIdentifiers.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0x01</span> || id == <span class="number">0x7f</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rewriteRValues(cl, packageIdentifiers.valueAt(i), id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Context</span></span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// The network security config needs to be aware of multiple</span></span><br><span class="line">        <span class="comment">// applications in the same process to handle discrepancies</span></span><br><span class="line">        <span class="comment">//网络安全设置</span></span><br><span class="line">        NetworkSecurityConfigProvider.handleNewApplication(appContext);</span><br><span class="line">        <span class="comment">//创建Application</span></span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入Application列表中（多个App可以运行在同一个进程中）</span></span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (instrumentation != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用Application的OnCreate方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            instrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法首先尝试取成员变量<code>mApplication</code>，如果不为<code>null</code>，说明曾创建过，直接返回就可以了</p>
<p>然后再去获取<code>Application</code>类名，默认为<code>android.app.Application</code>，开发可以通过设置<code>AndroidManifest</code>中<code>application</code>标签下的<code>android:name</code>属性来选择创建自定义的<code>Application</code></p>
<p>然后对共享库资源ID做动态映射，关于这部分感兴趣的同学可以去搜索<code>Android Dynamic Reference</code></p>
<p>接着创建出<code>ContextImpl</code>作为<code>Application</code>的<code>BaseContext</code>，<code>Application</code>继承自<code>ContextWrapper</code>，而<code>ContextWrapper</code>又继承自<code>Context</code>，<code>ContextWrapper</code>是对<code>Context</code>的包装，里面有一个<code>mBase</code>成员变量，调用任何方法实际上都是调用<code>mBase</code>这个实例的方法，在<code>Application</code>创建后会调用<code>attachBaseContext</code>将刚刚创建出来的<code>ContextImpl</code>赋值给<code>mBase</code>成员变量，所以调用<code>Application</code>中的任何<code>Context</code>方法，实际上最终都是调用<code>ContextImpl</code>的方法</p>
<p>然后创建<code>Application</code>，并将其设置成<code>ContextImpl</code>的<code>OuterContext</code></p>
<p>最后将创建好的<code>Application</code>设置给成员变量<code>mApplication</code>，方便以后获取，然后将其再添加到<code>mActivityThread.mAllApplications</code>列表中，返回</p>
<h3 id="ContextImpl-createAppContext"><a href="#ContextImpl-createAppContext" class="headerlink" title="ContextImpl.createAppContext"></a>ContextImpl.createAppContext</h3><p>我们简单看一下<code>ContextImpl</code>的创建，对于不同的组件，创建<code>ContextImpl</code>对象的方法不同，比如说<code>Activity</code>的<code>Context</code>是通过<code>createActivityContext</code>方法创建的，我们这里是通过<code>createAppContext</code>创建<code>Application</code>的<code>Context</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAppContext(mainThread, packageInfo, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String opPackageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</span><br><span class="line">    ContextImpl context = <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread, packageInfo,</span><br><span class="line">        ContextParams.EMPTY, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, opPackageName);</span><br><span class="line">    context.setResources(packageInfo.getResources());</span><br><span class="line">    <span class="comment">//检查android.permission.STATUS_BAR_SERVICE权限</span></span><br><span class="line">    context.mContextType = isSystemOrSystemUI(context) ? CONTEXT_TYPE_SYSTEM_OR_SYSTEM_UI</span><br><span class="line">            : CONTEXT_TYPE_NON_UI;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看看就好，我们的重点不在这里，这个方法实例化了一个<code>ContextImpl</code>对象，然后通过<code>ResourcesManager</code>获得<code>Apk</code>的<code>Resource</code>，将其设置到<code>ContextImpl</code>中</p>
<h3 id="Instrumentation-newApplication"><a href="#Instrumentation-newApplication" class="headerlink" title="Instrumentation.newApplication"></a>Instrumentation.newApplication</h3><p>接着我们来看一下<code>Application</code>是怎么创建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    Application app = getFactory(context.getPackageName())</span><br><span class="line">            .instantiateApplication(cl, className);</span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>getFactory</code>方法返回的是一个<code>AppComponentFactory</code>对象，这个类是在<code>Android 9</code>之后加入的，它包括一个实例化<code>ClassLoader</code>的方法，一个实例化<code>Application</code>的方法和四个实例化四大组件的方法</p>
<p>我们可以在<code>AndroidManifest</code>中设置<code>application</code>标签的<code>android:appComponentFactory</code>属性，将其设置成我们自定义的<code>AppComponentFactory</code>，从而进行一些监控或别的操作</p>
<p>我们看一下<code>AppComponentFactory</code>的默认实现是怎样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Application <span class="title">instantiateApplication</span><span class="params">(@NonNull ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull String className)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Application) cl.loadClass(className).newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到非常简单，就是通过<code>className</code>反射实例化出一个<code>Application</code></p>
<p>接着我们回到<code>newApplication</code>方法中，我们对新创建的<code>Application</code>调用了<code>attach</code>方法去绑定<code>ContextImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>attachBaseContext</code>调用的是父类<code>ContextWrapper</code>中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mBase = base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，就是将<code>ContextImpl</code>赋值给<code>ContextWrapper</code>中的<code>mBase</code>赋值，这样后面对<code>Application</code>调用<code>Context</code>的方法，实际上就是代理给这个<code>mBase</code>去执行了</p>
<p>到这一步位置，<code>Application</code>就创建完成了，接下来在<code>ActivityThread.handleBindApplication</code>方法中，还有一步重要操作，就是调用<code>Application</code>的<code>onCreate</code>方法</p>
<p>这里是借助了<code>Instrumentation.callApplicationOnCreate</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是简简单单直接调用了<code>Application</code>的<code>onCreate</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里为止，整个<code>Application</code>的工作都做完了，接下来还剩检查并启动<code>Activity</code>、<code>Service</code>和<code>BroadcastReceiver</code>，这些内容就放到下一篇再讲吧</p>
<p>话说回来有点惭愧，这篇文章距离上一篇间隔了三个月，最近在忙一些别的项目，这篇文章断断续续写了一个多月才憋出来，感谢大家的支持，在这里我厚着脸皮<strong>求点赞求收藏</strong>，大家的支持就是我创作的动力</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/09/14/android/compile/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV+FFmpeg+x264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B/">Android交叉编译OpenCV+FFmpeg+x264的艰难历程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-09-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">交叉编译</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/NDK/">NDK</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%BC%96%E8%AF%91/">编译</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">Android交叉编译</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NDK/">NDK</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/OpenCV/">OpenCV</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/FFmpeg/">FFmpeg</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/x264/">x264</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果你没有兴趣看完本文，只想获得可编译的代码或编译后的产物，可以直接点击下面的链接，跟随步骤编译代码或直接下载我编译好的产物</p>
<p><strong>注：编译顺序要按照 x264 -&gt; FFmpeg -&gt; OpenCV 这样来</strong></p>
<p><a href="https://github.com/dreamgyf/x264/releases/tag/v0.164_compilable" target="_blank" rel="noopener">x264</a></p>
<p><a href="https://github.com/dreamgyf/FFmpeg/releases/tag/v5.0_compilable" target="_blank" rel="noopener">FFmpeg</a></p>
<p><a href="https://github.com/dreamgyf/opencv/releases/tag/v4.6.0_compilable" target="_blank" rel="noopener">OpenCV</a></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在做一个视频生成的app，使用<code>OpenCV</code>库实现，用的是C语言，一开始我是在<code>mac_x86</code>上书写代码，<code>fourcc</code>视频编码器选择的是<code>mp4v</code>，视频输出一切正常，然后当我将代码移植到<code>Android</code>上时发现，从<code>OpenCV</code>官网下载的<code>so</code>库它不支持编码<code>mp4v</code>格式，只能编码成<code>mjpg</code>格式，后缀名为<code>avi</code>，尴尬的是<code>Android</code>原生又不支持播放这种格式的视频，所以要想办法让<code>OpenCV</code>支持编码<code>mp4v</code>或<code>h264</code>等格式</p>
<p>我在网上搜索了一下为什么<code>OpenCV</code>默认不支持<code>h264</code>格式，得知<code>OpenCV</code>默认使用<code>FFmpeg</code>做视频处理，<code>FFmpeg</code>使用的是<code>LGPL</code>协议，而<code>x264</code>使用的是<code>GPL</code>协议，<code>GPL</code>协议具有传染性，如果代码中使用了<code>GPL</code>协议的软件，则要求你的代码也必须开源。我猜测是因为这个原因，<code>FFmpeg</code>默认不使用<code>GPL</code>协议的软件，避免产生一些不必要的问题和纠纷，如果想要使用<code>GPL</code>协议的软件，则需要在编译的时候加上<code>--enable-gpl</code>选项</p>
<p>基于此上原因，我开启了我艰难的编译之路</p>
<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>本篇文章只针对<code>Linux</code>系统编译，其他系统不保证可以编译通过</p>
<p>本篇文章使用的<code>NDK</code>版本为<code>21.4.7075529</code>，不同的版本可能会有些差别，需要自行调整</p>
<p>本人对<code>c/c++</code>编译这块并不是很了解，很多东西也是边学习边尝试的，如果有什么错误的话也恳请大佬们指正，谢谢</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备一台<code>Linux</code>系统的电脑或使用虚拟机，安装一些最基本的编译工具（<code>make</code>、<code>cmake</code>等），我使用的是<code>Ubuntu</code>系统，强烈建议在安装的时候选择完整安装，这样这些编译工具应该都会跟随系统自动安装好</p>
<p><code>Android</code>交叉编译肯定是需要<code>NDK</code>的，我使用的是<code>21.4.7075529</code>版本，<code>r19</code>以上版本的NDK都是直接自带了工具链，而<code>r19</code>之前的版本则需要先生成工具链，具体可以参考<a href="https://developer.android.com/ndk/guides/standalone_toolchain?hl=zh-cn" target="_blank" rel="noopener">独立工具链（已弃用）</a>这篇文档</p>
<h1 id="x264"><a href="#x264" class="headerlink" title="x264"></a>x264</h1><p>既然需要依赖<code>x264</code>，那我们肯定是先要编译<code>x264</code>库，各位可以<code>clone</code>我准备好的<code>tag</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v0.164_compilable https://github.com/dreamgyf/x264.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>x264</code>镜像仓库的<code>stable</code>分支切出的，版本为<code>0.164</code>。想知道<code>x264</code>版本的话，可以运行其目录下的<code>version.sh</code>脚本，它会输出三串数字，前面的<code>164</code>是在<code>x264.h</code>中定义的<code>X264_BUILD</code>，第二个<code>3095+4</code>表示<code>master</code>分支的提交数 + <code>master</code>分支到HEAD的提交数，最后的一串数字表示当前分支最新的<code>commit id</code></p>
<p>在构建编译脚本之前，我们先要看看这个库提供了哪些编译选项，我们可以看到在<code>x264</code>根目录下有一个<code>configure</code>文件，这是一个脚本文件，大多数库都提供了这个脚本，用来负责生成<code>Makefile</code>，准备好构建环境，我们可以通过下面这个命令获取帮助文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --help &gt; help.txt</span><br></pre></td></tr></table></figure>

<p>可以看到，里面提供了一些编译选项及其描述，我们可以根据这些选项和描述构建编译脚本</p>
<p>先看一下我写好的脚本吧</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang</span><br><span class="line">    export CFLAGS="-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security  -O0 -DNDEBUG  -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;"</span><br><span class="line"></span><br><span class="line">    ../../configure \</span><br><span class="line">        --host=$&#123;TRIPLE&#125; \</span><br><span class="line">        --prefix=$PREFIX \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --enable-pic \</span><br><span class="line">        --disable-lavf \</span><br><span class="line">        --sysroot=$TOOLCHAIN/sysroot</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这也是我其他库编译脚本的基本结构，首先需要<code>ANDROID_NDK</code>环境变量用来确定<code>NDK</code>的位置</p>
<p><code>OUTPUT_DIR</code>为编译的输出路径，我这里命名为<code>_output_</code>，防止和源码本身的目录重名</p>
<p><code>API</code>为最低支持的<code>Android API</code>版本，我这里写的<code>21</code>，也就是<code>Android 5.0</code></p>
<p><code>TOOLCHAIN</code>为交叉编译工具链的路径，对于<code>r19</code>之前的<code>NDK</code>，需要将其改为你生成出来的工具链的路径，<code>r19</code>之后不需要改动</p>
<p>我这里定义了一个<code>build</code>函数，通过输入的<code>ABI</code>编译出对应架构的产物。<code>ABI</code>总共有四种：<code>armeabi-v7a</code>，<code>arm64-v8a</code>，<code>x86</code>，<code>x86-64</code>，这个决定你的<code>App</code>能在哪些平台架构上运行</p>
<p>这里，我通过不同的<code>ABI</code>定义了不同的<code>TRIPLE</code>变量，这是遵循了<code>NDK</code>工具链的命名规则，可以在 <a href="https://developer.android.com/ndk/guides/other_build_systems?hl=zh-cn" target="_blank" rel="noopener">将 NDK 与其他构建系统配合使用</a> 这篇文档中找到</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_TRIPLE.png" alt="TRIPLE"></p>
<p>在<code>$TOOLCHAIN/bin</code>目录下，我们也能发现这种命名方式</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_TRIPLE2.png" alt="TRIPLE"></p>
<p>我们需要根据其命名规则，指定相应的编译器，设置相应的<code>host</code>，<code>target</code></p>
<p>关于<code>build</code>、<code>host</code>和<code>target</code>的含义可以参阅 <a href="https://www.gnu.org/software/automake/manual/html_node/Cross_002dCompilation.html" target="_blank" rel="noopener">Cross-Compilation</a> 这篇文档</p>
<ul>
<li><p><code>build</code>: 编译该库所使用的平台，不设置的话，编译器会自动推测所在平台</p>
</li>
<li><p><code>host</code>: 编译出的库要运行在哪个平台上，不设置的话，默认为<code>build</code>值，但这样也就不再是交叉编译了</p>
</li>
<li><p><code>target</code>: 该库所处理的目标平台，不设置的话，默认为<code>host</code>值</p>
</li>
</ul>
<p>多数<code>UNIX</code>平台会通过<code>CC</code>调用C语言编译器，而<code>CFLAGS</code>则是C语言编译器的编译选项，根据我们上文所说的命名规则可以发现，工具链中C语言编译器的命名规则为<code>${TRIPLE}${API}-clang</code>，假设我们要编译<code>arm64-v8a ABI</code>，<code>API 21</code>的库，则需要指定<code>CC</code>为<code>aarch64-linux-android21-clang</code></p>
<p>至于<code>CFLAGS</code>这里就不多说了，可以自行查阅 <a href="https://clang.llvm.org/docs/ClangCommandLineReference.html" target="_blank" rel="noopener">Clang编译器参数手册</a> ，这里需要注意的是，必须要指定<code>--gcc-toolchain</code>和<code>--target</code>，否则编译会报错</p>
<p>然后就是<code>configure</code>的选项了，这里必须指定<code>--host</code>和<code>--sysroot</code>，<code>sysroot</code>表示使用这个值作为编译的头文件和库文件的查找目录，该目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sysroot</span><br><span class="line">└── usr</span><br><span class="line">    ├── include</span><br><span class="line">    └── lib</span><br><span class="line">        ├── aarch64-linux-android</span><br><span class="line">        ├── arm-linux-androideabi</span><br><span class="line">        ├── i686-linux-android</span><br><span class="line">        └── x86_64-linux-android</span><br></pre></td></tr></table></figure>

<p><code>--prefix</code>为编译后的安装路径，也就是编译产物的输出路径</p>
<p><code>--enable-static</code>和<code>--enable-shared</code>选项表示生成静态库和动态库，大家可以根据情况自行选择</p>
<p><code>nproc</code>是<code>Linux</code>下的一个命令，表示当前进程可用的<code>CPU</code>核数，一般<code>make</code>使用线程数为<code>CPU</code>核数就可以了，如果编译产生问题，可以尝试调小这个值</p>
<p>到这里基本上整个构建脚本就分析完了，大家调整完编译选项后保存，就可以执行命令<code>./build.sh</code>开始编译了</p>
<h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h1><p>然后我们开始编译FFmpeg</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v5.0_compilable https://github.com/dreamgyf/FFmpeg.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>FFmpeg</code>镜像仓库的<code>n5.0</code>分支切出的，版本为<code>5.0</code>。其实我一开始用的是<code>5.1</code>版本，但当我解决了各种问题编译<code>OpenCV</code>到一半时，提示我<code>FFmpeg</code>的一些符号找不到，然后我去查了一下<code>OpenCV</code>的 Change Log ，发现它的最新版本<code>4.6.0</code>刚刚支持<code>FFmpeg 5.0</code>版本，无奈切到<code>5.0</code>重新编译</p>
<p>还是一样，先看编译脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">ROOT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译出的x264库地址</span></span><br><span class="line">X264_ANDROID_DIR=/home/dreamgyf/compile/x264/_output_/product</span><br><span class="line"></span><br><span class="line">EXTRA_CONFIGURATIONS="--disable-stripping \</span><br><span class="line">    --disable-ffmpeg \</span><br><span class="line">    --disable-doc \</span><br><span class="line">    --disable-appkit \</span><br><span class="line">    --disable-avfoundation \</span><br><span class="line">    --disable-coreimage \</span><br><span class="line">    --disable-amf \</span><br><span class="line">    --disable-audiotoolbox \</span><br><span class="line">    --disable-cuda-llvm \</span><br><span class="line">    --disable-cuvid \</span><br><span class="line">    --disable-d3d11va \</span><br><span class="line">    --disable-dxva2 \</span><br><span class="line">    --disable-ffnvcodec \</span><br><span class="line">    --disable-nvdec \</span><br><span class="line">    --disable-nvenc \</span><br><span class="line">    --disable-vdpau \</span><br><span class="line">    --disable-videotoolbox"</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    export CC=$TOOLCHAIN/bin/$&#123;TRIPLE&#125;$&#123;API&#125;-clang</span><br><span class="line">    export CFLAGS="-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -Wformat -Werror=format-security  -O0 -DNDEBUG  -fPIC --gcc-toolchain=$TOOLCHAIN --target=$&#123;TRIPLE&#125;$&#123;API&#125;"</span><br><span class="line"></span><br><span class="line">    ../../configure \</span><br><span class="line">        --prefix=$PREFIX \</span><br><span class="line">        --enable-cross-compile \</span><br><span class="line">        --sysroot=$TOOLCHAIN/sysroot \</span><br><span class="line">        --cc=$CC \</span><br><span class="line">        --enable-static \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --disable-asm \</span><br><span class="line">        --enable-gpl \</span><br><span class="line">        --enable-libx264 \</span><br><span class="line">        --extra-cflags="-I$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/include" \</span><br><span class="line">        --extra-ldflags="-L$&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib" \</span><br><span class="line">        $EXTRA_CONFIGURATIONS</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd $PREFIX</span><br><span class="line">    `$ROOT_PATH/ffmpeg-config-gen.sh $&#123;X264_ANDROID_DIR&#125;/$&#123;ABI&#125;/lib/libx264.a`</span><br><span class="line">    cd $OUTPUT_PATH</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>这个脚本和<code>x264</code>的编译脚本基本相同，由于我们需要依赖<code>x264</code>库，所以我们要使刚刚编译出来的<code>x264</code>产物参与<code>FFmpeg</code>的编译，为此，需要将<code>X264_ANDROID_DIR</code>改成自己编译出来的<code>x264</code>产物路径</p>
<p>在<code>configure</code>选项中，我们需要<code>--enable-cross-compile</code>选项表示开启交叉编译，我们这里需要设置<code>--cc</code>选择C语言编译器，否则编译时会使用系统默认的编译器，<code>--disable-asm</code>选项我测试是必须要带上的，否则编译会报错，然后就是<code>--enable-libx264</code>开启<code>x264</code>依赖了，根据我在起因中说到的开源协议问题，所以<code>--enable-gpl</code>选项也要开启，最后需要指定<code>x264</code>的头文件和库文件目录，分别使用<code>--extra-cflags</code>和<code>--extra-ldflags</code>加上对应的参数</p>
<p>这里提一下，编译器会优先从<code>-I -L</code>两个参数指定的目录中去查找头文件和库文件，如果没找到的话再会从<code>sysroot</code>目录中查找</p>
<p>最后，我还写了一个<code>ffmpeg-config-gen.sh</code>脚本，它的作用是生成<code>ffmpeg-config.cmake</code>文件，用来给<code>OpenCV</code>编译提供<code>FFmpeg</code>依赖查找，这个等我们后面讲到<code>OpenCV</code>依赖<code>FFmpeg</code>的处理时再说</p>
<p>和<code>x264</code>一样，大家调整完编译选项后保存，就可以执行命令<code>./build.sh</code>开始编译了</p>
<h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><p>最后，我们开始编译<code>OpenCV</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b v4.6.0_compilable https://github.com/dreamgyf/opencv.git</span><br></pre></td></tr></table></figure>

<p>这个版本是从原<code>OpenCV</code>仓库的<code>4.6.0</code>分支切出的，版本为<code>4.6.0</code>，是目前的最新版本。其实前面两个库的编译都挺顺利的，最麻烦的问题都出在<code>OpenCV</code>这里</p>
<p>我们还是先看编译脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux 交叉编译 Android 库脚本</span></span><br><span class="line">if [[ -z $ANDROID_NDK ]]; then</span><br><span class="line">    echo 'Error: Can not find ANDROID_NDK path.'</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo "ANDROID_NDK path: $&#123;ANDROID_NDK&#125;"</span><br><span class="line"></span><br><span class="line">OUTPUT_DIR="_output_"</span><br><span class="line"></span><br><span class="line">mkdir $&#123;OUTPUT_DIR&#125;</span><br><span class="line">cd $&#123;OUTPUT_DIR&#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_PATH=`pwd`</span><br><span class="line"></span><br><span class="line">API=21</span><br><span class="line">TOOLCHAIN=$ANDROID_NDK/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译出的ffmpeg库地址</span></span><br><span class="line">FFMPEG_ANDROID_DIR=/home/dreamgyf/compile/FFmpeg/_output_/product</span><br><span class="line"></span><br><span class="line">EXTRA_ATTRS="-DWITH_CUDA=OFF \</span><br><span class="line">    -DWITH_GTK=OFF \</span><br><span class="line">    -DWITH_1394=OFF \</span><br><span class="line">    -DWITH_GSTREAMER=OFF \</span><br><span class="line">    -DWITH_LIBV4L=OFF \</span><br><span class="line">    -DWITH_TIFF=OFF \</span><br><span class="line">    -DBUILD_OPENEXR=OFF \</span><br><span class="line">    -DWITH_OPENEXR=OFF \</span><br><span class="line">    -DBUILD_opencv_ocl=OFF \</span><br><span class="line">    -DWITH_OPENCL=OFF"</span><br><span class="line"></span><br><span class="line">function build &#123;</span><br><span class="line">    ABI=$1</span><br><span class="line"></span><br><span class="line">    if [[ $ABI == "armeabi-v7a" ]]; then</span><br><span class="line">        ARCH="arm"</span><br><span class="line">        TRIPLE="armv7a-linux-androideabi"</span><br><span class="line">        TOOLCHAIN_NAME="arm-linux-androideabi"</span><br><span class="line">    elif [[ $ABI == "arm64-v8a" ]]; then</span><br><span class="line">        ARCH="arm64"</span><br><span class="line">        TRIPLE="aarch64-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="aarch64-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86" ]]; then</span><br><span class="line">        ARCH="x86"</span><br><span class="line">        TRIPLE="i686-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="i686-linux-android"</span><br><span class="line">    elif [[ $ABI == "x86-64" ]]; then</span><br><span class="line">        ARCH="x86_64"</span><br><span class="line">        TRIPLE="x86_64-linux-android"</span><br><span class="line">        TOOLCHAIN_NAME="x86_64-linux-android"</span><br><span class="line">    else</span><br><span class="line">        echo "Unsupported ABI $&#123;ABI&#125;!"</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo "Build ABI $&#123;ABI&#125;..."</span><br><span class="line"></span><br><span class="line">    rm -rf $&#123;ABI&#125;</span><br><span class="line">    mkdir $&#123;ABI&#125; &amp;&amp; cd $&#123;ABI&#125;</span><br><span class="line"></span><br><span class="line">    PREFIX=$&#123;OUTPUT_PATH&#125;/product/$ABI</span><br><span class="line"></span><br><span class="line">    cmake ../.. \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX=$PREFIX \</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK/build/cmake/android.toolchain.cmake \</span><br><span class="line">        -DANDROID_ABI=$ABI \</span><br><span class="line">        -DANDROID_NDK=$ANDROID_NDK \</span><br><span class="line">        -DANDROID_PLATFORM="android-$&#123;API&#125;" \</span><br><span class="line">        -DANDROID_LINKER_FLAGS="-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API" \</span><br><span class="line">        -DBUILD_ANDROID_PROJECTS=OFF \</span><br><span class="line">        -DBUILD_ANDROID_EXAMPLES=OFF \</span><br><span class="line">        -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS \</span><br><span class="line">        -DWITH_FFMPEG=ON \</span><br><span class="line">        -DOPENCV_GENERATE_PKGCONFIG=ON \</span><br><span class="line">        -DOPENCV_FFMPEG_USE_FIND_PACKAGE=ON \</span><br><span class="line">        -DFFMPEG_DIR=$&#123;FFMPEG_ANDROID_DIR&#125;/$&#123;ABI&#125; \</span><br><span class="line">        $EXTRA_ATTRS</span><br><span class="line"></span><br><span class="line">    make clean &amp;&amp; make -j`nproc` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">    cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo "Select arch:"</span><br><span class="line">select arch in "armeabi-v7a" "arm64-v8a" "x86" "x86-64"</span><br><span class="line">do</span><br><span class="line">    echo "Select build static or shared libs:"</span><br><span class="line">    select type in "static" "shared"</span><br><span class="line">    do</span><br><span class="line">        if [[ $type == "static" ]]; then</span><br><span class="line">            BUILD_SHARED_LIBS=OFF</span><br><span class="line">        elif [[ $type == "shared" ]]; then</span><br><span class="line">            BUILD_SHARED_LIBS=ON</span><br><span class="line">        else</span><br><span class="line">            BUILD_SHARED_LIBS=OFF</span><br><span class="line">        fi</span><br><span class="line">        break</span><br><span class="line">    done</span><br><span class="line">    build $arch</span><br><span class="line">    break</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>上面的准备工作和前面的几个脚本一样，不同的是，<code>OpenCV</code>并没有为我们准备<code>configure</code>脚本，所以这次我们使用<code>cmake</code>生成<code>Makefile</code>，再进行编译</p>
<p>既然使用<code>cmake</code>了，我们就可以不再像之前一样，自己指定编译器等工具链了，<code>NDK</code>为我们提供了交叉编译工具链<code>cmake</code>脚本<code>$ANDROID_NDK/build/cmake/android.toolchain.cmake</code>，我们只需要指定其为<code>CMAKE_TOOLCHAIN_FILE</code>，然后为其提供相关参数即可，具体的使用方式可以参考 <a href="https://developer.android.com/ndk/guides/cmake?hl=zh-cn" target="_blank" rel="noopener">CMake</a> 这篇文档。我们这里只需要提供最低限度的几个参数<code>ANDROID_ABI</code>、<code>ANDROID_NDK</code>、<code>ANDROID_PLATFORM</code>即可</p>
<p>如果需要编译<code>Android</code>示例工程的话，还需要在环境变量中设置<code>ANDROID_HOME</code>和<code>ANDROID_SDK</code>，我这里就直接使用<code>-DBUILD_ANDROID_PROJECTS=OFF</code>和<code>-DBUILD_ANDROID_EXAMPLES=OFF</code>将其关闭了</p>
<p>然后就是如何让<code>OpenCV</code>依赖我们编译的<code>FFmpeg</code>的问题了，到这一步我们就需要去它的<code>CMakeLists.txt</code>中看看它是怎样声明<code>FFmpeg</code>的了</p>
<p>打开<code>CMakeLists.txt</code>文件，搜索<code>FFMPEG</code>关键字，我们可以找到这一段代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WITH_FFMPEG <span class="keyword">OR</span> HAVE_FFMPEG)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN <span class="string">"YES (find_package)"</span>                       <span class="keyword">ELSE</span> <span class="string">"NO (find_package)"</span>)</span><br><span class="line">  <span class="keyword">elseif</span>(WIN32)</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN <span class="string">"YES (prebuilt binaries)"</span>                  <span class="keyword">ELSE</span> NO)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    status(<span class="string">"    FFMPEG:"</span>       HAVE_FFMPEG         THEN YES <span class="keyword">ELSE</span> NO)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  status(<span class="string">"      avcodec:"</span>      FFMPEG_libavcodec_VERSION    THEN <span class="string">"YES ($&#123;FFMPEG_libavcodec_VERSION&#125;)"</span>    <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avformat:"</span>     FFMPEG_libavformat_VERSION   THEN <span class="string">"YES ($&#123;FFMPEG_libavformat_VERSION&#125;)"</span>   <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avutil:"</span>       FFMPEG_libavutil_VERSION     THEN <span class="string">"YES ($&#123;FFMPEG_libavutil_VERSION&#125;)"</span>     <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      swscale:"</span>      FFMPEG_libswscale_VERSION    THEN <span class="string">"YES ($&#123;FFMPEG_libswscale_VERSION&#125;)"</span>    <span class="keyword">ELSE</span> NO)</span><br><span class="line">  status(<span class="string">"      avresample:"</span>   FFMPEG_libavresample_VERSION THEN <span class="string">"YES ($&#123;FFMPEG_libavresample_VERSION&#125;)"</span> <span class="keyword">ELSE</span> NO)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>我们可以发现，要想依赖<code>FFmpeg</code>，我们需要将<code>HAVE_FFMPEG</code>的值设为<code>true</code>，并且要指定<code>FFmpeg libs</code>的版本</p>
<p>我们再看到<code>OPENCV_FFMPEG_USE_FIND_PACKAGE</code>这个参数，表示通过<code>find_package</code>的方式寻找<code>FFmpeg</code>库</p>
<p>这里，我们其实有两种办法依赖<code>FFmpeg</code>库，一是通过<code>find_package</code>，二是通过<code>pkg-config</code>，我两种方式都尝试了后，觉得还是使用<code>find_package</code>这种方式比较容易，侵入性较小，使用<code>pkg-config</code>需要手动修改<code>OpenCV</code>检测<code>FFmpeg</code>的<code>cmake</code>文件源码，不优雅</p>
<p>接着我们去看<code>OpenCV</code>是如何检测<code>FFmpeg</code>是否存在的，这里我们需要找到<code>$OPENCV/modules/videoio/cmake/detect_ffmpeg.cmake</code>这个文件，在开头第一段代码中，我们就可以发现</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> HAVE_FFMPEG <span class="keyword">AND</span> OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"1"</span> <span class="keyword">OR</span> OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"ON"</span>)</span><br><span class="line">    <span class="keyword">set</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="string">"FFMPEG"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">find_package</span>(<span class="variable">$&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;</span>) <span class="comment"># Required components: AVCODEC AVFORMAT AVUTIL SWSCALE</span></span><br><span class="line">  <span class="keyword">if</span>(FFMPEG_FOUND <span class="keyword">OR</span> FFmpeg_FOUND)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>如果<code>OPENCV_FFMPEG_USE_FIND_PACKAGE</code>选项被打开，则会使用<code>find_package(FFMPEG)</code>去查找这个库</p>
<p><code>find_package(&lt;PackageName&gt;)</code>有两种模式，一种是<code>Module</code>模式，一种是<code>Config</code>模式</p>
<p>在<code>Module</code>模式中，<code>cmake</code>需要找到一个名为<code>Find&lt;PackageName&gt;.cmake</code>的文件，这个文件负责找到库所在路径，引入头文件和库文件。<code>cmake</code>会在两个地方查找这个文件，先是我们手动指定的<code>CMAKE_MODULE_PATH</code>目录，搜索不到再搜索<code>$CMAKE/share/cmake-&lt;version&gt;/Modules</code>目录</p>
<p>如果<code>Module</code>模式没找到相应文件，则会转为<code>Config</code>模式，在这个模式下，<code>cmake</code>需要找到<code>&lt;lowercasePackageName&gt;-config.cmake</code>或<code>&lt;PackageName&gt;Config.cmake</code>文件，通过这个文件找到库所在路径，引入头文件和库文件。<code>cmake</code>会优先在<code>&lt;PackageName&gt;_DIR</code>目录下搜索相应文件</p>
<p>关于<code>find_package</code>更详细的解释，可以去查看 <a href="https://cmake.org/cmake/help/latest/command/find_package.html" target="_blank" rel="noopener">官方文档</a></p>
<p>我这里选用了<code>Config</code>模式，再结合之前在<code>CMakeLists.txt</code>和<code>detect_ffmpeg.cmake</code>中的内容，我们可以得出结论：</p>
<p>我们需要在构建脚本中设置<code>WITH_FFMPEG=ON</code>，<code>OPENCV_FFMPEG_USE_FIND_PACKAGE=ON</code>，<code>FFMPEG_DIR</code>并且<code>FFMPEG_DIR</code>目录下需要有<code>ffmpeg-config.cmake</code>或<code>FFMPEGConfig.cmake</code>文件</p>
<p>这里就衔接了上文，我为什么要写一个<code>ffmpeg-config-gen.sh</code>脚本，脚本的内容很简单，我们直接看它生成出来的<code>ffmpeg-config.cmake</code>文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(FFMPEG_PATH <span class="string">"$&#123;CMAKE_CURRENT_LIST_DIR&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_EXEC_DIR <span class="string">"$&#123;FFMPEG_PATH&#125;/bin"</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBDIR <span class="string">"$&#123;FFMPEG_PATH&#125;/lib"</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_INCLUDE_DIRS <span class="string">"$&#123;FFMPEG_PATH&#125;/include"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBRARIES</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavformat.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavdevice.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavcodec.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavutil.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libswscale.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libswresample.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libavfilter.a</span><br><span class="line">    <span class="variable">$&#123;FFMPEG_LIBDIR&#125;</span>/libpostproc.a</span><br><span class="line">    /home/dreamgyf/compile/x264/_output_/product/arm64-v8a/lib/libx264.a</span><br><span class="line">    z</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavformat_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavdevice_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavcodec_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavutil_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswscale_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswresample_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavfilter_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libpostproc_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavcodec_VERSION <span class="number">59.18</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavdevice_VERSION <span class="number">59.4</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavfilter_VERSION <span class="number">8.24</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavformat_VERSION <span class="number">59.16</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libavutil_VERSION <span class="number">57.17</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libpostproc_VERSION <span class="number">56.3</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswresample_VERSION <span class="number">4.3</span>.<span class="number">100</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_libswscale_VERSION <span class="number">6.4</span>.<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(FFMPEG_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">set</span>(FFMPEG_LIBS <span class="variable">$&#123;FFMPEG_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这里主要为<code>cmake</code>提供了三个变量</p>
<ul>
<li><p><code>FFMPEG_INCLUDE_DIRS</code>：提供头文件目录</p>
</li>
<li><p><code>FFMPEG_LIBRARIES</code>：提供库文件链接</p>
</li>
<li><p><code>FFMPEG_FOUND</code>：告诉<code>cmake</code>找到了<code>FFmpeg</code>库</p>
</li>
</ul>
<p>这里还有几个点要说，首先，<code>cmake</code>中的库文件链接顺序符合<code>gcc</code>链接顺序规则，所以说库的书写顺序也是有严格要求的，被依赖的库要放在依赖它的库的后面，正如这个文件，<code>FFmpeg</code>需要依赖<code>x264</code>，所以我需要将<code>x264</code>放在所有<code>FFmpeg</code>库的最后面</p>
<p><code>FFmpeg</code>需要依赖<code>zlib</code>库，所以我在后面增加了一个<code>z</code>表示依赖<code>zlib</code>库</p>
<p><code>FFmpeg</code>这些库的版本定义是从<code>$FFMPEG_PRODUCT/$ABI/lib/pkgconfig</code>目录下各个文件读出来的</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_pkgconfig.png" alt="pkgconfig"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_version.png" alt="version"></p>
<p><code>ffmpeg-config.cmake</code>文件写完，我们再回过头来看一下<code>detect_ffmpeg.cmake</code></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> HAVE_FFMPEG <span class="keyword">AND</span> OPENCV_FFMPEG_USE_FIND_PACKAGE)</span><br><span class="line">  <span class="keyword">if</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"1"</span> <span class="keyword">OR</span> OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="keyword">STREQUAL</span> <span class="string">"ON"</span>)</span><br><span class="line">    <span class="keyword">set</span>(OPENCV_FFMPEG_USE_FIND_PACKAGE <span class="string">"FFMPEG"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">find_package</span>(<span class="variable">$&#123;OPENCV_FFMPEG_USE_FIND_PACKAGE&#125;</span>) <span class="comment"># Required components: AVCODEC AVFORMAT AVUTIL SWSCALE</span></span><br><span class="line">  <span class="keyword">if</span>(FFMPEG_FOUND <span class="keyword">OR</span> FFmpeg_FOUND)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>可以看到最后的 if 中，如果<code>FFMPEG_FOUND</code>为<code>true</code>，则设置<code>HAVE_FFMPEG</code>为<code>true</code>，正好对应了我们在<code>ffmpeg-config.cmake</code>中的行为，这下，<code>CMakeLists.txt</code>就可以找到我们的<code>FFmpeg</code>库了</p>
<p>这里还有一点，<code>detect_ffmpeg.cmake</code>中有一段用来测试的代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(HAVE_FFMPEG <span class="keyword">AND</span> <span class="keyword">NOT</span> HAVE_FFMPEG_WRAPPER <span class="keyword">AND</span> <span class="keyword">NOT</span> OPENCV_FFMPEG_SKIP_BUILD_CHECK)</span><br><span class="line">  <span class="keyword">try_compile</span>(__VALID_FFMPEG</span><br><span class="line">      <span class="string">"$&#123;OpenCV_BINARY_DIR&#125;"</span></span><br><span class="line">      <span class="string">"$&#123;OpenCV_SOURCE_DIR&#125;/cmake/checks/ffmpeg_test.cpp"</span></span><br><span class="line">      CMAKE_FLAGS <span class="string">"-DINCLUDE_DIRECTORIES:STRING=$&#123;FFMPEG_INCLUDE_DIRS&#125;"</span></span><br><span class="line">                  <span class="string">"-DLINK_LIBRARIES:STRING=$&#123;FFMPEG_LIBRARIES&#125;"</span></span><br><span class="line">      OUTPUT_VARIABLE TRY_OUT</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">NOT</span> __VALID_FFMPEG)</span><br><span class="line">    <span class="keyword">message</span>(FATAL_ERROR <span class="string">"FFMPEG: test check build log:\n$&#123;TRY_OUT&#125;"</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"WARNING: Can't build ffmpeg test code"</span>)</span><br><span class="line">    <span class="keyword">set</span>(HAVE_FFMPEG <span class="keyword">FALSE</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>其中的<code>message(FATAL_ERROR &quot;FFMPEG: test check build log:\n${TRY_OUT}&quot;)</code>原本是被注释了的，我强烈建议各位将其打开，这样如果哪里有误，一开始就可以报错并附带详细信息，免得到时候编到一半才报错，浪费时间</p>
<p>到这里，我本以为万事大吉了，于是开始编译，这里我使用了<code>BUILD_SHARED_LIBS=ON</code>选项编译动态库，<code>armeabi-v7a</code>顺利编译通过，但当<code>arm64-v8a</code>编译到一半时突然报错，提示<code>libz.so, needed by ../../lib/arm64-v8a/libopencv_core.so, not found (try using -rpath or -rpath-link)</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91OpenCV%2BFFmpeg%2Bx264%E7%9A%84%E8%89%B0%E9%9A%BE%E5%8E%86%E7%A8%8B_rpath_error.png" alt="rpath_error"></p>
<p>我观察了一下<code>NDK</code>目录结构，发现<code>libz.so</code>动态库文件可以在<code>$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API</code>下找到，需要注意的是，这里的<code>TOOLCHAIN_NAME</code>和<code>TRIPLE</code>很相似，但在<code>armeabi-v7a</code>情况下又有些细微的不同，所以我又新定义了这个变量</p>
<p>然后我开始尝试加入<code>-rpath-link</code>选项，首先，我尝试添加了一项<code>cmake</code>选项<code>CMAKE_SHARED_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;</code>，发现，虽然在编译开头的输出中可以看出，这个参数确实被加上生效了，但在编译到同样的地方时，仍然会报相同的错误，这里我不太清楚，难道参数的顺序也会对编译造成影响吗？</p>
<p>于是我去查看了<code>android.toolchain.cmake</code>文件，看他是怎么添加这些选项的，发现了这么一行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="string">"$&#123;ANDROID_LINKER_FLAGS&#125; $&#123;CMAKE_SHARED_LINKER_FLAGS&#125;"</span>)</span><br></pre></td></tr></table></figure>

<p>于是我在这行代码前加了这么一行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND ANDROID_LINKER_FLAGS -Wl,-rpath-link=<span class="variable">$&#123;ANDROID_TOOLCHAIN_ROOT&#125;</span>/sysroot/usr/lib/<span class="variable">$&#123;ANDROID_TOOLCHAIN_NAME&#125;</span>/<span class="variable">$&#123;ANDROID_PLATFORM_LEVEL&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>让<code>-rpath-link</code>这个选项提前一点，果不其然，编译顺利通过了，但这样做有点麻烦，还得改<code>NDK</code>里的配置，于是我在构建脚本里加了一个参数<code>ANDROID_LINKER_FLAGS=&quot;-Wl,-rpath-link=$TOOLCHAIN/sysroot/usr/lib/$TOOLCHAIN_NAME/$API&quot;</code>，这样的话，<code>-rpath-link</code>选项会被提到<code>Linker flags</code>的最前面，经过测试，这样也可以编译通过，于是<code>OpenCV</code>的编译脚本也就这么完成了</p>
<p>当然这里还剩一个疑点，为什么不加<code>-rpath-link</code>的时候，<code>arm64-v8a</code>编译报错但<code>armeabi-v7a</code>却编译通过，希望有大佬可以指点一下</p>
<h1 id="FreeType"><a href="#FreeType" class="headerlink" title="FreeType"></a>FreeType</h1><p>我的App中还用到了<code>FreeType</code>库渲染字体，在这里顺便也把它的编译方式放出来吧</p>
<p>直接去 <a href="https://github.com/dreamgyf/freetype/releases/tag/v2.12.1_compilable" target="_blank" rel="noopener">FreeType</a> 这里下载我编译好的版本或者源码，根据我写的步骤进行编译就可以了</p>
<h1 id="在Android中使用"><a href="#在Android中使用" class="headerlink" title="在Android中使用"></a>在Android中使用</h1><p>在Android中使用时需要注意，如果你使用静态库的方式的话，需要将<code>OpenCV</code>编译出来的第三方库也加入到链接中，放在<code>OpenCV</code>的后面，另外<code>FFmpeg</code>还需要<code>mediandk</code>和<code>zlib</code>这两个依赖，具体可以参考下面的代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        textvideo</span><br><span class="line"></span><br><span class="line">        freetype</span><br><span class="line"></span><br><span class="line">        <span class="comment"># opencv</span></span><br><span class="line">        opencv_videoio</span><br><span class="line">        opencv_photo</span><br><span class="line">        opencv_highgui</span><br><span class="line">        opencv_imgproc</span><br><span class="line">        opencv_imgcodecs</span><br><span class="line">        opencv_dnn</span><br><span class="line">        opencv_core</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ffmpeg</span></span><br><span class="line">        ffmpeg_avformat</span><br><span class="line">        ffmpeg_avdevice</span><br><span class="line">        ffmpeg_avcodec</span><br><span class="line">        ffmpeg_avutil</span><br><span class="line">        ffmpeg_swscale</span><br><span class="line">        ffmpeg_swresample</span><br><span class="line">        ffmpeg_avfilter</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ffmpeg依赖</span></span><br><span class="line">        mediandk</span><br><span class="line">        z</span><br><span class="line"></span><br><span class="line">        <span class="comment"># x264</span></span><br><span class="line">        x264</span><br><span class="line"></span><br><span class="line">        <span class="comment"># opencv第三方支持库</span></span><br><span class="line">        ade</span><br><span class="line">        cpufeatures</span><br><span class="line">        ittnotify</span><br><span class="line">        libjpeg-turbo</span><br><span class="line">        libopenjp2</span><br><span class="line">        libpng</span><br><span class="line">        libprotobuf</span><br><span class="line">        libwebp</span><br><span class="line">        quirc</span><br><span class="line">        tegra_hal</span><br><span class="line"></span><br><span class="line">        <span class="comment"># android jni库</span></span><br><span class="line">        jnigraphics</span><br><span class="line">        android</span><br><span class="line">        log)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然我这篇文章写的看起来编译的过程很简单，根本不像标题所说的那么艰难，但实际上我前前后后弄了大概有一个多星期才真正完整编出可用版本，前前后后编译失败了不说一百次也有几十次，对我这种不懂c语言编译的简直是折磨。因为我是在全部弄完后才开始写的文章，所以基本上坑都踩的差不多了，其中有些坑印象也没那么清楚了，我也没那么多精力再去复现出那些坑了，怎么说呢，能成功就万事大吉吧 😭</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/08/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - Activity启动流程（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityThread/">ActivityThread</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityThread/">ActivityThread</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>作为一名<code>Android</code>开发，我们最熟悉并且最常打交道的当然非四大组件中的<code>Activity</code>莫属，这次我们就来讲讲一个<code>Activity</code>是怎样启动起来的</p>
<p>本来本篇想要讲<code>ActivityManagerService</code>的，但<code>AMS</code>中的内容过多过于繁杂，不如用这种以线及面的方式，通过<code>Activity</code>的启动流程这一条线，去了解<code>ActivityThread</code>，<code>AMS</code>等是怎么工作的</p>
<h1 id="Android窗口结构关系"><a href="#Android窗口结构关系" class="headerlink" title="Android窗口结构关系"></a>Android窗口结构关系</h1><p>在开始正式深入代码之前，我们需要先理一下<code>Android</code>的窗口结构关系，以免后面看到源码里各种<code>parent</code>、<code>child</code>头晕，我画了一张树状关系图来描述它</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89-Android%E7%AA%97%E5%8F%A3%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="Android窗口结构关系"></p>
<p>上图中的所有类都是<code>WindowContainer</code>的子类，<code>WindowContainer</code>是一个窗口容器，它的<code>child</code>也是<code>WindowContainer</code>，它是用来管理窗口子容器的</p>
<p>可以先不用纠结理解这张图中的关系，顺着源码往下看，碰到不理解的地方回头看一下就可以了</p>
<h1 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h1><p>作为<code>Android</code>开发，<code>startActivity</code>这个方法一定非常熟悉，我们以这个函数作为入口来分析<code>Activity</code>的启动流程</p>
<p><code>Activity</code>和<code>ContextImpl</code>的<code>startActivity</code>方法实现不太一样，但最终都调用了<code>Instrumentation.execStartActivity</code>方法</p>
<h1 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><p>路径：<code>frameworks/base/core/java/android/app/Instrumentation.java</code></p>
<p>以下是Google官方对这个类功能的注释</p>
<p><em>Base class for implementing application instrumentation code.  When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application.  An Instrumentation implementation is described to the system through an AndroidManifest.xml’s &lt;instrumentation&gt; tag.</em></p>
<p>简单翻译一下，就是这个类是用于监控系统与应用的交互的（<code>onCreate</code>等生命周期会经历<code>Instrumentation</code>这么一环），它会在任何<code>App</code>代码执行前被初始化。</p>
<p>本人猜测，这个类主要存在的意义是为了给自动化测试提供一个切入点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">//记录调用者</span></span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//自动化测试相关</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//迁移额外的URI数据流到剪贴板（处理Intent使用ACTION_SEND或ACTION_SEND_MULTIPLE共享数据的情况）</span></span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        <span class="comment">//处理离开当前App进程的情况</span></span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">//请求ATMS启动Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        <span class="comment">//检查异常情况，抛出对应异常</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数调用了<code>ActivityTaskManager.getService.startActivity</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityTaskManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>这里<code>getService</code>出来的很明显的是一个远程<code>binder</code>对象，我们之前已经分析过那么多<code>binder</code>知识了，以后就不再过多啰嗦了，这里实际上调用的是<code>ActivityTaskManagerSerivce</code>（以下简称<code>ATMS</code>）的<code>startActivity</code>方法</p>
<h1 id="ActivityTaskManagerSerivce"><a href="#ActivityTaskManagerSerivce" class="headerlink" title="ActivityTaskManagerSerivce"></a>ActivityTaskManagerSerivce</h1><p><code>ATMS</code>是<code>Android 10</code>以后新加的一个服务，用来专门处理<code>Activity</code>相关工作，分担<code>AMS</code>的工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*validateIncomingUser*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断言发起startActivity请求方的UID和callingPackage指向的是同一个App</span></span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    <span class="comment">//确认请求方没有被隔离</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查并获取当前用户ID（多用户模式）</span></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用ActivityStarter启动Activity</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller) <span class="comment">//调用方ApplicationThread</span></span><br><span class="line">            .setCallingPackage(callingPackage) <span class="comment">//调用方包名</span></span><br><span class="line">            .setCallingFeatureId(callingFeatureId) <span class="comment">// Context.getAttributionTag()</span></span><br><span class="line">            .setResolvedType(resolvedType) <span class="comment">//设置Intent解析类型</span></span><br><span class="line">            .setResultTo(resultTo) <span class="comment">//设置目标Activity Token（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setResultWho(resultWho) <span class="comment">//设置目标Activity（ContextImpl.startActivity传入参数为null）</span></span><br><span class="line">            .setRequestCode(requestCode) <span class="comment">//设置requestCode</span></span><br><span class="line">            .setStartFlags(startFlags) <span class="comment">// startFlags == 0</span></span><br><span class="line">            .setProfilerInfo(profilerInfo) <span class="comment">// null</span></span><br><span class="line">            .setActivityOptions(bOptions) <span class="comment">//设置Activity Options Bundle</span></span><br><span class="line">            .setUserId(userId) <span class="comment">//设置用户ID</span></span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分内容都是检查，最重要的是最后一段使用<code>ActivityStarter</code>启动<code>Activity</code>，首先通过<code>ActivityStartController</code>的<code>obtainStarter</code>方法获取一个<code>ActivityStarter</code>实例，然后调用各种set方法设置参数，最后执行<code>execute</code>方法执行</p>
<h1 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h1><p>这个类从名字就能看出来，就是一个专门处理<code>Activity</code>启动的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">        <span class="comment">//校验Intent，不允许其携带fd</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.intent != <span class="keyword">null</span> &amp;&amp; mRequest.intent.hasFileDescriptors()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LaunchingState launchingState;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">//通过Token获取调用方ActivityRecord</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord caller = ActivityRecord.forTokenLocked(mRequest.resultTo);</span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            launchingState = mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(</span><br><span class="line">                    mRequest.intent, caller);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the caller hasn't already resolved the activity, we're willing</span></span><br><span class="line">        <span class="comment">// to do so here. If the caller is already holding the WM lock here,</span></span><br><span class="line">        <span class="comment">// and we need to check dynamic Uri permissions, then we're forced</span></span><br><span class="line">        <span class="comment">// to assume those permissions are denied to avoid deadlocking.</span></span><br><span class="line">        <span class="comment">//通过Intent解析Activity信息</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.activityInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mRequest.resolveActivity(mSupervisor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            ... <span class="comment">//处理Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//清除Binder调用方UID和PID，用当前进程的UID和PID替代，并返回之前的UID和PID（UID：前32位，PID：后32位）</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析成为重量级进程（如果设置了相关flag的话）</span></span><br><span class="line">            <span class="comment">//这里的重量级进程指的是不能保存状态的应用进程</span></span><br><span class="line">            res = resolveToHeavyWeightSwitcherIfNeeded();</span><br><span class="line">            <span class="keyword">if</span> (res != START_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行请求</span></span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//恢复之前的Binder调用方UID和PID</span></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">            ... <span class="comment">//更新Configuration</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify ActivityMetricsLogger that the activity has launched.</span></span><br><span class="line">            <span class="comment">// ActivityMetricsLogger will then wait for the windows to be drawn and populate</span></span><br><span class="line">            <span class="comment">// WaitResult.</span></span><br><span class="line">            <span class="comment">//记录启动状态</span></span><br><span class="line">            mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(launchingState, res,</span><br><span class="line">                    mLastStartActivityRecord);</span><br><span class="line">            <span class="comment">//返回启动结果</span></span><br><span class="line">            <span class="keyword">return</span> getExternalResult(mRequest.waitResult == <span class="keyword">null</span> ? res</span><br><span class="line">                    : waitForResult(res, mLastStartActivityRecord));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//清理回收工作</span></span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数每一步做了什么我都用注释标出来了，大家看看就好，重点在于其中的<code>executeRequest(mRequest)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Executing activity start request and starts the journey of starting an activity. Here</span></span><br><span class="line"><span class="comment">    * begins with performing several preliminary checks. The normally activity launch flow will</span></span><br><span class="line"><span class="comment">    * go through &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125; to &#123;<span class="doctag">@link</span> #startActivityInner&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(request.reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = request.reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IApplicationThread caller = request.caller;</span><br><span class="line">    Intent intent = request.intent;</span><br><span class="line">    NeededUriGrants intentGrants = request.intentGrants;</span><br><span class="line">    String resolvedType = request.resolvedType;</span><br><span class="line">    ActivityInfo aInfo = request.activityInfo;</span><br><span class="line">    ResolveInfo rInfo = request.resolveInfo;</span><br><span class="line">    <span class="keyword">final</span> IVoiceInteractionSession voiceSession = request.voiceSession;</span><br><span class="line">    <span class="keyword">final</span> IBinder resultTo = request.resultTo;</span><br><span class="line">    String resultWho = request.resultWho;</span><br><span class="line">    <span class="keyword">int</span> requestCode = request.requestCode;</span><br><span class="line">    <span class="keyword">int</span> callingPid = request.callingPid;</span><br><span class="line">    <span class="keyword">int</span> callingUid = request.callingUid;</span><br><span class="line">    String callingPackage = request.callingPackage;</span><br><span class="line">    String callingFeatureId = request.callingFeatureId;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = request.realCallingPid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = request.realCallingUid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> startFlags = request.startFlags;</span><br><span class="line">    <span class="keyword">final</span> SafeActivityOptions options = request.activityOptions;</span><br><span class="line">    Task inTask = request.inTask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle =</span><br><span class="line">            options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    WindowProcessController callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方应用进程对应的WindowProcessController</span></span><br><span class="line">        <span class="comment">//这个类是用于和ProcessRecord进行通讯的</span></span><br><span class="line">        callerApp = mService.getProcessController(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//异常情况，startActivity的调用方进程不存在或未启动</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">") when starting: "</span> + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前用户ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = aInfo != <span class="keyword">null</span> &amp;&amp; aInfo.applicationInfo != <span class="keyword">null</span></span><br><span class="line">            ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</span><br><span class="line">                + <span class="string">"&#125; from uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//调用方Activity Token != null</span></span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取调用方ActivityRecord（要求存在任意一个Window栈中，即是RootWindow的子嗣）</span></span><br><span class="line">        sourceRecord = mRootWindowContainer.isInAnyStack(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) &#123;</span><br><span class="line">            Slog.v(TAG_RESULTS, <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//调用方需要response</span></span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line">    <span class="comment">//多Activity传值场景</span></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到可以处理此Intent的组件</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find a class that can handle the given Intent.</span></span><br><span class="line">        <span class="comment">// That's the end of that!</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Intent中解析不出相应的Activity信息</span></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//语言交互相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span></span><br><span class="line">            ? <span class="keyword">null</span> : resultRecord.getRootTask();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查启动Activity的权限</span></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, callingFeatureId,</span><br><span class="line">            request.ignoreTargetSecurity, inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPackage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> restrictedBgActivity = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER,</span><br><span class="line">                    <span class="string">"shouldAbortBackgroundActivityStart"</span>);</span><br><span class="line">            <span class="comment">//检查是否要限制后台启动Activity</span></span><br><span class="line">            restrictedBgActivity = shouldAbortBackgroundActivityStart(callingUid,</span><br><span class="line">                    callingPid, callingPackage, realCallingUid, realCallingPid, callerApp,</span><br><span class="line">                    request.originatingPendingIntent, request.allowBackgroundActivityStart,</span><br><span class="line">                    intent);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two options bundles, while realCallerOptions takes precedence.</span></span><br><span class="line">    <span class="comment">//过渡动画相关</span></span><br><span class="line">    ActivityOptions checkedOptions = options != <span class="keyword">null</span></span><br><span class="line">            ? options.getOptions(intent, aInfo, callerApp, mSupervisor) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        checkedOptions = mService.getActivityStartController()</span><br><span class="line">                .getPendingRemoteAnimationRegistry()</span><br><span class="line">                .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// The Intent we give to the watcher has the extra data stripped off, since it</span></span><br><span class="line">            <span class="comment">// can contain private information.</span></span><br><span class="line">            Intent watchIntent = intent.cloneFilter();</span><br><span class="line">            <span class="comment">//这个方法似乎只打印了一些日志，恒返回true，即abort |= false</span></span><br><span class="line">            abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                    aInfo.applicationInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            mService.mController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化ActivityStartInterceptor</span></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage,</span><br><span class="line">            callingFeatureId);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity start was intercepted, e.g. because the target user is currently in quiet</span></span><br><span class="line">        <span class="comment">// mode (turn off work) or the target application is suspended</span></span><br><span class="line">        <span class="comment">//拦截并转化成其他的启动模式</span></span><br><span class="line">        intent = mInterceptor.mIntent;</span><br><span class="line">        rInfo = mInterceptor.mRInfo;</span><br><span class="line">        aInfo = mInterceptor.mAInfo;</span><br><span class="line">        resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">        inTask = mInterceptor.mInTask;</span><br><span class="line">        callingPid = mInterceptor.mCallingPid;</span><br><span class="line">        callingUid = mInterceptor.mCallingUid;</span><br><span class="line">        checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The interception target shouldn't get any permission grants</span></span><br><span class="line">        <span class="comment">// intended for the original destination</span></span><br><span class="line">        intentGrants = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="comment">//回调给调用方Activity结果</span></span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.sendResult(INVALID_UID, resultWho, requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>, <span class="keyword">null</span> <span class="comment">/* dataGrants */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We pretend to the caller that it was really started, but they will just get a</span></span><br><span class="line">        <span class="comment">// cancel result.</span></span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run, we</span></span><br><span class="line">    <span class="comment">// launch the review activity and pass a pending intent to start the activity</span></span><br><span class="line">    <span class="comment">// we are to launching now after the review is completed.</span></span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果启动的Activity没有相应权限，则需要用户手动确认允许权限后，再进行启动工作</span></span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            <span class="comment">//将原来的Intent包装在新的Intent中，用这个确认权限的新Intent继续后面的启动工作</span></span><br><span class="line">            <span class="keyword">final</span> IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage, callingFeatureId,</span><br><span class="line">                    callingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Intent newIntent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flags = intent.getFlags();</span><br><span class="line">            flags |= Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Prevent reuse of review activity: Each app needs their own review activity. By</span></span><br><span class="line"><span class="comment">                * default activities launched with NEW_TASK or NEW_DOCUMENT try to reuse activities</span></span><br><span class="line"><span class="comment">                * with the same launch parameters (extras are ignored). Hence to avoid possible</span></span><br><span class="line"><span class="comment">                * reuse force a new activity via the MULTIPLE_TASK flag.</span></span><br><span class="line"><span class="comment">                *</span></span><br><span class="line"><span class="comment">                * Activities that are not launched with NEW_TASK or NEW_DOCUMENT are not re-used,</span></span><br><span class="line"><span class="comment">                * hence no need to add the flag in this case.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_NEW_DOCUMENT)) != <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK;</span><br><span class="line">            &#125;</span><br><span class="line">            newIntent.setFlags(flags);</span><br><span class="line"></span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The permissions review target shouldn't get any permission</span></span><br><span class="line">            <span class="comment">// grants intended for the original destination</span></span><br><span class="line">            intentGrants = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, request.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have an ephemeral app, abort the process of launching the resolved intent.</span></span><br><span class="line">    <span class="comment">// Instead, launch the ephemeral installer. Once the installer is finished, it</span></span><br><span class="line">    <span class="comment">// starts either the intent we resolved here [on install error] or the ephemeral</span></span><br><span class="line">    <span class="comment">// app [on install success].</span></span><br><span class="line">    <span class="keyword">if</span> (rInfo != <span class="keyword">null</span> &amp;&amp; rInfo.auxiliaryInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... <span class="comment">//Instant App相关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建启动Activity的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">    mLastStartActivityRecord = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.appTimeTracker == <span class="keyword">null</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller didn't specify an explicit time tracker, we want to continue</span></span><br><span class="line">        <span class="comment">// tracking under any it has.</span></span><br><span class="line">        r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取顶层焦点的Acticity栈</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are starting an activity that is not from the same uid as the currently resumed</span></span><br><span class="line">    <span class="comment">// one, check whether app switches are allowed.</span></span><br><span class="line">    <span class="comment">//当此时栈顶Activity UID != 调用方 UID的时候（比如悬浮窗）</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; stack != <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">        <span class="comment">//检查是否可以直接切换应用</span></span><br><span class="line">        <span class="comment">// 1. 设置的 mAppSwitchesAllowedTime &lt; 当前系统时间（stopAppSwitches）</span></span><br><span class="line">        <span class="comment">// 2. 调用方在最近任务中</span></span><br><span class="line">        <span class="comment">// 3. 调用方具有 STOP_APP_SWITCHES 权限</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">            <span class="comment">//加入到延时启动列表中</span></span><br><span class="line">            <span class="keyword">if</span> (!(restrictedBgActivity &amp;&amp; handleBackgroundActivityAbort(r))) &#123;</span><br><span class="line">                mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                        sourceRecord, startFlags, stack, callerApp, intentGrants));</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调处理延迟应用切换</span></span><br><span class="line">    mService.onStartActivitySetDidAppSwitch();</span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心：进入Activity启动的下一阶段</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.outActivity[<span class="number">0</span>] = mLastStartActivityRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数大部分都是检查工作，这些可以看我标的注释，基本上介绍的比较详细了，然后进入到Activity启动的下一步，<code>startActivityUnchecked</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity while most of preliminary checks has been done and caller has been</span></span><br><span class="line"><span class="comment">    * confirmed that holds necessary permissions to do so.</span></span><br><span class="line"><span class="comment">    * Here also ensures that the starting activity is removed if the start wasn't successful.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack startedActivityStack;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//暂停布局工作，避免重复刷新</span></span><br><span class="line">        mService.deferWindowLayout();</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_WINDOW_MANAGER, <span class="string">"startActivityInner"</span>);</span><br><span class="line">        <span class="comment">//接着把启动Activity工作交给这个方法</span></span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        <span class="comment">//进行一些更新Configuration，清理栈等收尾工作</span></span><br><span class="line">        startedActivityStack = handleStartResult(r, result);</span><br><span class="line">        <span class="comment">//恢复布局工作</span></span><br><span class="line">        mService.continueWindowLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, startedActivityStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也不是主要逻辑所在，我们往下接着看<code>startActivityInner</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Start an activity and determine if the activity should be adding to the top of an existing</span></span><br><span class="line"><span class="comment">    * task or delivered new intent to an existing activity. Also manipulating the activity task</span></span><br><span class="line"><span class="comment">    * onto requested or valid stack/display.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Note: This method should only be called from &#123;<span class="doctag">@link</span> #startActivityUnchecked&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(b/152429287): Make it easier to exercise code paths through startActivityInner</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置初始化参数</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor, restrictedBgActivity);</span><br><span class="line">    <span class="comment">//计算处理Activity启动模式</span></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line">    <span class="comment">//计算调用方Activity任务栈</span></span><br><span class="line">    computeSourceStack();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将flags设置为调整后的LaunchFlags</span></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找是否有可复用的Task</span></span><br><span class="line">    <span class="keyword">final</span> Task reusedTask = getReusableTask();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If requested, freeze the task list</span></span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="keyword">null</span> &amp;&amp; mOptions.freezeRecentTasksReordering()</span><br><span class="line">            &amp;&amp; mSupervisor.mRecentTasks.isCallerRecents(r.launchedFromUid)</span><br><span class="line">            &amp;&amp; !mSupervisor.mRecentTasks.isFreezeTaskListReorderingSet()) &#123;</span><br><span class="line">        mFrozeTaskList = <span class="keyword">true</span>;</span><br><span class="line">        mSupervisor.mRecentTasks.setFreezeTaskListReordering();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute if there is an existing task that should be used for.</span></span><br><span class="line">    <span class="comment">//计算是否存在可使用的现有Task</span></span><br><span class="line">    <span class="keyword">final</span> Task targetTask = reusedTask != <span class="keyword">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newTask = targetTask == <span class="keyword">null</span>;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算启动参数</span></span><br><span class="line">    computeLaunchParams(r, sourceRecord, targetTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if starting activity on given task or on a new task is allowed.</span></span><br><span class="line">    <span class="comment">//检查是否允许在targetTask上或者新建Task启动</span></span><br><span class="line">    <span class="keyword">int</span> startResult = isAllowedToStart(r, newTask, targetTask);</span><br><span class="line">    <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> startResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得栈顶未finish的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord targetTaskTop = newTask</span><br><span class="line">            ? <span class="keyword">null</span> : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    <span class="keyword">if</span> (targetTaskTop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Recycle the target task for this launch.</span></span><br><span class="line">        <span class="comment">//回收，准备复用这个Task</span></span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAddingToTask = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="comment">//处理singleTop启动模式</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mRootWindowContainer.getTopDisplayFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (topStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startResult = deliverToCurrentTopIfNeeded(topStack, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复用或创建Activity栈</span></span><br><span class="line">    <span class="keyword">if</span> (mTargetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTargetStack = getLaunchStack(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123; <span class="comment">//开启新Task</span></span><br><span class="line">        <span class="keyword">final</span> Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">                ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//复用或新建一个Task，并建立Task与ActivityRecord之间的关联</span></span><br><span class="line">        setNewTask(taskToAffiliate);</span><br><span class="line">        <span class="keyword">if</span> (mService.getLockTaskController().isLockTaskModeViolation(</span><br><span class="line">                mStartActivity.getTask())) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempted Lock Task Mode violation mStartActivity="</span> + mStartActivity);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAddingToTask) &#123; <span class="comment">//复用Task</span></span><br><span class="line">        <span class="comment">//将启动Activity添加到targetTask容器顶部或将其父容器替换成targetTask（也会将启动Activity添加到targetTask容器顶部）</span></span><br><span class="line">        addOrReparentStartingActivity(targetTask, <span class="string">"adding to task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAvoidMoveToFront &amp;&amp; mDoResume) &#123;</span><br><span class="line">        mTargetStack.getStack().moveToFront(<span class="string">"reuseOrNewTask"</span>, targetTask);</span><br><span class="line">        <span class="keyword">if</span> (mOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOptions.getTaskAlwaysOnTop()) &#123;</span><br><span class="line">                mTargetStack.setAlwaysOnTop(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopStackInDisplayArea() &amp;&amp; mService.mInternal.isDreaming()) &#123;</span><br><span class="line">            <span class="comment">// Launching underneath dream activity (fullscreen, always-on-top). Run the launch-</span></span><br><span class="line">            <span class="comment">// -behind transition so the Activity gets created and starts in visible state.</span></span><br><span class="line">            mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">            r.mLaunchTaskBehind = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mTargetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mRootWindowContainer.sendPowerHintForLaunchStartIfNeeded(</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* forceSend */</span>, mStartActivity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Task移到ActivityStack容器顶部</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(),</span><br><span class="line">            newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="comment">//启动的Activity不可获得焦点，无法恢复它</span></span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// If the activity is not focusable, we can't resume it, but still would like to</span></span><br><span class="line">            <span class="comment">// make sure it becomes visible as it starts (this will also trigger entry</span></span><br><span class="line">            <span class="comment">// animation). An example of this are PIP activities.</span></span><br><span class="line">            <span class="comment">// Also, we don't want to resume activities in a task that currently has an overlay</span></span><br><span class="line">            <span class="comment">// as the starting activity just needs to be in the visible paused state until the</span></span><br><span class="line">            <span class="comment">// over is removed.</span></span><br><span class="line">            <span class="comment">// Passing &#123;@code null&#125; as the start parameter ensures all activities are made</span></span><br><span class="line">            <span class="comment">// visible.</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisible(<span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                    <span class="number">0</span> <span class="comment">/* configChanges */</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// Go ahead and tell window manager to execute app transition for this activity</span></span><br><span class="line">            <span class="comment">// since the app transition will not be triggered through the resume channel.</span></span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">            <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">            <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">            <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">            <span class="comment">// accordingly.</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityInner"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重点：恢复栈顶Activities</span></span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the recent tasks list immediately when the activity starts</span></span><br><span class="line">    <span class="comment">//当Activity启动后立刻更新最近任务列表</span></span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要做了一些<code>Task</code>和栈的操作，是否可以复用栈，是否需要新栈，处理栈顶复用等相关操作。我们需要注意一下这里关于<code>Task</code>的操作，不管是新建<code>Task</code>（<code>newTask</code>）还是复用<code>Task</code>（<code>mAddingToTask</code>），都会调用到<code>addOrReparentStartingActivity</code>方法将启动<code>ActivityRecord</code>添加到<code>targetTask</code>容器顶部（<code>newTask</code>的情况下会调用<code>setNewTask</code>方法先复用或创建<code>Task</code>，然后再用这个<code>Task</code>调用<code>addOrReparentStartingActivity</code>方法），之后调用<code>mTargetStack.startActivityLocked</code>方法将<code>Task</code>移到<code>mTargetStack</code>容器顶部，此时调用<code>mTargetStack.topRunningActivity</code>便会得到我们将要启动的这个<code>ActivityRecord</code></p>
<p>最后判断目标<code>Activity</code>是否可获得焦点，当可获得焦点的时候，调用<code>RootWindowContainer.resumeFocusedStacksTopActivities</code>方法恢复<code>Activity</code></p>
<p>要注意，从这个方法开始的以后的方法不再只是针对<code>Activity</code>启动的方法，它们有可能被多方调用，所以其中的一些步骤case我们是不会经历的，可以忽略掉这部分</p>
<h1 id="RootWindowContainer"><a href="#RootWindowContainer" class="headerlink" title="RootWindowContainer"></a>RootWindowContainer</h1><p><code>RootWindowContainer</code>是显示窗口的根窗口容器，它主要是用来管理显示屏幕的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStacksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//目标栈在栈顶显示区域</span></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        <span class="comment">//使用目标栈进行恢复</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能存在多显示设备（投屏等）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> resumedOnDisplay = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent display = getChildAt(displayNdx);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tdaNdx = display.getTaskDisplayAreaCount() - <span class="number">1</span>; tdaNdx &gt;= <span class="number">0</span>; --tdaNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = display.getTaskDisplayAreaAt(tdaNdx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sNdx = taskDisplayArea.getStackCount() - <span class="number">1</span>; sNdx &gt;= <span class="number">0</span>; --sNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityStack stack = taskDisplayArea.getStackAt(sNdx);</span><br><span class="line">                <span class="keyword">final</span> ActivityRecord topRunningActivity = stack.topRunningActivity();</span><br><span class="line">                <span class="keyword">if</span> (!stack.isFocusableAndVisible() || topRunningActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stack == targetStack) &#123;</span><br><span class="line">                    <span class="comment">//如果进入到这里，代表着targetStack在上面已经恢复过了，此时只需要记录结果即可</span></span><br><span class="line">                    resumedOnDisplay |= result;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskDisplayArea.isTopStack(stack) &amp;&amp; topRunningActivity.isState(RESUMED)) &#123;</span><br><span class="line">                    <span class="comment">//执行切换效果</span></span><br><span class="line">                    stack.executeAppTransition(targetOptions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使顶部显示的Activity执行Resume、Pause或Start生命周期</span></span><br><span class="line">                    resumedOnDisplay |= topRunningActivity.makeActiveIfNeeded(target);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!resumedOnDisplay) &#123;</span><br><span class="line">            <span class="comment">// In cases when there are no valid activities (e.g. device just booted or launcher</span></span><br><span class="line">            <span class="comment">// crashed) it's possible that nothing was resumed on a display. Requesting resume</span></span><br><span class="line">            <span class="comment">// of top activity in focused stack explicitly will make sure that at least home</span></span><br><span class="line">            <span class="comment">// activity is started and resumed, and no recursion occurs.</span></span><br><span class="line">            <span class="comment">//当没有任何有效的Activity的时候（设备刚启动或Launcher崩溃），可能没有任何东西可被恢复</span></span><br><span class="line">            <span class="comment">//这时候使用DisplayContent中的焦点栈进行恢复</span></span><br><span class="line">            <span class="comment">//如果连存在焦点的栈都没有，则恢复Launcher的Activity</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">"no-focusable-task"</span>,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了几件事：</p>
<ul>
<li><p>如果目标栈在栈顶显示区域，执行Resume</p>
</li>
<li><p>遍历显示设备，从中遍历所有有焦点并且可见的栈，对其栈顶<code>Activity</code>执行相应的切换效果及生命周期</p>
</li>
<li><p>对每个显示设备，如果存在焦点栈，则使用其执行Resume，否则启动<code>Launcher</code></p>
</li>
</ul>
<p>在正常情况下，我们会走进<code>ActivityStack.resumeTopActivityUncheckedLocked</code>这个方法</p>
<h1 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h1><p><code>Activity</code>栈，用于管理栈中的<code>Activity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        <span class="comment">//防止递归</span></span><br><span class="line">        mInResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">        <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">        <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">        <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">        <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">        <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">        <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            <span class="comment">//准备休眠</span></span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了一个防止递归调用的措施，接下来调用了<code>resumeTopActivityInnerLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="comment">//ATMS服务尚未准备好</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="comment">//在之前我们已经把要启动的ActivityRecord加到了栈顶</span></span><br><span class="line">    ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let's look somewhere else.</span></span><br><span class="line">        <span class="keyword">return</span> resumeNextFocusableActivityWhenStackIsEmpty(prev, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskDisplayArea taskDisplayArea = getDisplayArea();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">    <span class="comment">//如果需要Resume的已在顶部且状态为Resume，不需要做任何事</span></span><br><span class="line">    <span class="comment">//启动Activity不会碰到这种case</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!next.canResumeByCompat()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">    <span class="comment">//如果有正在Pause的Activity，在它Pause完成前不要做任何事</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> allPausedComplete = mRootWindowContainer.allPausedActivitiesComplete();</span><br><span class="line">    <span class="keyword">if</span> (!allPausedComplete) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line">    <span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line">    <span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line">    <span class="comment">//确保拥有此Activity的用户已启动</span></span><br><span class="line">    <span class="keyword">if</span> (!mAtmService.mAmInternal.hasStartedUserState(next.mUserId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">    <span class="comment">// appropriate for it.</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">    next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里似乎重复检查了，我去查看了一下master分支的代码，已经没有这一段了</span></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置启动Activity UID，获取WakeLock，保证在显示Activity的过程中，系统不会进行休眠状态</span></span><br><span class="line">    mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    ActivityRecord lastResumed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//上一个具有焦点的ActivityStack（目前仍是屏幕上正在显示的那个Activity的栈）</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack lastFocusedStack = taskDisplayArea.getLastFocusedStack();</span><br><span class="line">    <span class="keyword">if</span> (lastFocusedStack != <span class="keyword">null</span> &amp;&amp; lastFocusedStack != <span class="keyword">this</span>) &#123;</span><br><span class="line">        lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pause掉其他ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">boolean</span> pausing = taskDisplayArea.pauseBackStacks(userLeaving, next);</span><br><span class="line">    <span class="comment">//Pause掉当前ActivityStack中的栈顶状态为Resume的Activity</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span> <span class="comment">/* uiSleeping */</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing) &#123; <span class="comment">//有Activity执行了Pause</span></span><br><span class="line">        <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">        <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">        <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">        <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">        <span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line">            <span class="comment">//将启动的Activity进程信息移至lru列表的头部</span></span><br><span class="line">            <span class="comment">//因为很快就会使用它启动Activity</span></span><br><span class="line">            next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                    <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">false</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">            <span class="comment">// Since the start-process is asynchronous, if we already know the process of next</span></span><br><span class="line">            <span class="comment">// activity isn't running, we can start the process earlier to save the time to wait</span></span><br><span class="line">            <span class="comment">// for the current activity to be paused.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isTop = <span class="keyword">this</span> == taskDisplayArea.getFocusedStack();</span><br><span class="line">            <span class="comment">//启动App进程</span></span><br><span class="line">            mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">                    isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//这里会先结束掉启动Activity的流程，等待onPause生命周期走完后</span></span><br><span class="line">        <span class="comment">//再重新调用这个方法执行下一步操作，避免Activity生命周期紊乱</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; taskDisplayArea.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">        <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">        <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        <span class="comment">//不需要等待其他的Activity onPause完成</span></span><br><span class="line">        <span class="comment">//执行完切换效果后就没有什么其他需要做的了</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动Activity流程不会进入这个case</span></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev != next &amp;&amp; next.nowVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改启动Activity的package的状态</span></span><br><span class="line">    mAtmService.getPackageManager().setPackageStoppedState(</span><br><span class="line">                next.packageName, <span class="keyword">false</span>, next.mUserId);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//Activity转场动画准备</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next.attachedToProcess()) &#123; <span class="comment">//对于将要启动的ActivityRecord来说，此时尚未完成和Process的绑定，返回false</span></span><br><span class="line">        ...</span><br><span class="line">        ActivityRecord lastResumedActivity =</span><br><span class="line">                lastFocusedStack == <span class="keyword">null</span> ? <span class="keyword">null</span> : lastFocusedStack.mResumedActivity;</span><br><span class="line">        <span class="comment">//保存状态以做后面恢复使用</span></span><br><span class="line">        <span class="keyword">final</span> ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">        mAtmService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新ActivityRecord状态</span></span><br><span class="line">        next.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新启动Activity的进程信息并将其移至lru列表的头部</span></span><br><span class="line">        next.app.updateProcessInfo(<span class="keyword">false</span> <span class="comment">/* updateServiceConnectionActivities */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* activityChange */</span>, <span class="keyword">true</span> <span class="comment">/* updateOomAdj */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* addPendingTopUid */</span>);</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">//更新Activity显示、方向和Configuration</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ClientTransaction transaction =</span><br><span class="line">                    ClientTransaction.obtain(next.app.getThread(), next.appToken);</span><br><span class="line">            <span class="comment">// Deliver all pending results.</span></span><br><span class="line">            ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                            <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                    transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                transaction.addCallback(</span><br><span class="line">                        NewIntentItem.obtain(next.newIntents, <span class="keyword">true</span> <span class="comment">/* resume */</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">            <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">            next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">            EventLogTags.writeWmResumeActivity(next.mUserId, System.identityHashCode(next),</span><br><span class="line">                    next.getTask().mTaskId, next.shortComponentName);</span><br><span class="line"></span><br><span class="line">            next.setSleeping(<span class="keyword">false</span>);</span><br><span class="line">            mAtmService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">            next.app.setPendingUiCleanAndForceProcessStateUpTo(mAtmService.mTopProcessState);</span><br><span class="line">            next.clearOptionsLocked();</span><br><span class="line">            <span class="comment">//设置onResume生命周期请求</span></span><br><span class="line">            transaction.setLifecycleStateRequest(</span><br><span class="line">                    ResumeActivityItem.obtain(next.app.getReportedProcState(),</span><br><span class="line">                            dc.isNextTransitionForward()));</span><br><span class="line">            <span class="comment">//调度执行Activity onResume生命周期</span></span><br><span class="line">            mAtmService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span></span><br><span class="line">                    + next);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">//resume失败需要尝试restart</span></span><br><span class="line">            <span class="comment">//恢复初始状态</span></span><br><span class="line">            next.setState(lastState, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                lastResumedActivity.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//重新启动Activity</span></span><br><span class="line">            mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// From this point on, if something goes wrong there is no way</span></span><br><span class="line">        <span class="comment">// to recover the activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//更新信息</span></span><br><span class="line">            next.completeResumeLocked();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If any exception gets thrown, toss away this</span></span><br><span class="line">            <span class="comment">// activity and try the next one.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</span><br><span class="line">            next.finishIfPossible(<span class="string">"resume-exception"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//尚未绑定Process</span></span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动Activity</span></span><br><span class="line">        mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码很长，其实我们只需要关注三个点：</p>
<ol>
<li><p><code>Pause</code>掉其他<code>Activity</code></p>
</li>
<li><p>如果对应<code>App</code>尚未启动，启动<code>App</code>进程</p>
</li>
<li><p>启动<code>Activity</code></p>
</li>
</ol>
<p>第一步，在启动<code>Activity</code>前，我们需要先<code>Pause</code>掉其他<code>Activity</code>，这一点很好理解，我们可以对照着看<code>Activity</code>生命周期也是这样的，这里会通过<code>ATMS</code>跨进程调用相应<code>Activity</code>的<code>onPause</code>生命周期，等待<code>onPause</code>执行完成后，再跨进程调用回<code>ATMS</code>，经过一系列方法调用，又重新调用<code>resumeTopActivityInnerLocked</code>方法，继续执行下一步操作</p>
<p>第二步，如果<code>App</code>尚未启动，则先去启动<code>App</code>进程，这主要体现在这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!next.isProcessRunning()) &#123; <span class="comment">//App进程未启动</span></span><br><span class="line">    <span class="comment">//启动App进程</span></span><br><span class="line">    mAtmService.startProcessAsync(next, <span class="keyword">false</span> <span class="comment">/* knownToBeDead */</span>, isTop,</span><br><span class="line">            isTop ? <span class="string">"pre-top-activity"</span> : <span class="string">"pre-activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启动完<code>App</code>进程后，会调用<code>ATMS</code>的<code>attachApplication</code>方法，最终调用到<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code>，这个方法后面会讲</p>
<p>第三步，如果<code>App</code>进程已经启动，这时候会调用<code>ActivityStackSupervisor.startSpecificActivity</code>方法，最终殊途同归调用<code>ActivityStackSupervisor.realStartActivityLocked</code>方法启动<code>Activity</code></p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这里篇幅有点过长了，所以我觉得还是分篇比较好，这一章其实重要内容不是很多，最主要的内容，像<code>Activity</code>的生命周期控制，<code>App</code>进程的启动，<code>Activity</code>具体的启动及其后续生命周期执行都会放在下一章来讲</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/">Android源码分析 - Framework层的Binder（服务端篇）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-07-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>我们在上一片文章<a href="https://juejin.cn/post/7113760814409973790" target="_blank" rel="noopener">Android源码分析 - Framework层的Binder（客户端篇）</a>中，分析了客户端是怎么向服务端通过<code>binder</code>驱动发起请求，然后再接收服务端的返回的。本篇文章，我们将会以服务端的视角，分析服务端是怎么通过<code>binder</code>驱动接收客户端的请求，处理，然后再返回给客户端的。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>上篇文章我们是以<code>ServiceManager</code>作为服务端分析的，本篇文章我们还是围绕着它来做分析，它也是一个比较特殊的服务端，我们正好可以顺便分析一下它是怎么成为<code>binder</code>驱动的<code>context_manager</code>的</p>
<h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><p><code>ServiceManager</code>是在独立的进程中运行的，它是由<code>init</code>进程从<code>rc</code>文件中解析并启动的，路径为<code>frameworks/native/cmds/servicemanager/servicemanager.rc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart restart thermalservice</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>这个服务的入口函数位于<code>frameworks/native/cmds/servicemanager/main.cpp</code>的<code>main</code>函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据上面的rc文件，argc == 1, argv[0] == "/system/bin/servicemanager"</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" [binder driver]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时，要使用的binder驱动为/dev/binder</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/dev/binder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder驱动</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver);</span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>);</span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ServiceManager</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = <span class="keyword">new</span> ServiceManager(<span class="built_in">std</span>::make_unique&lt;Access&gt;());</span><br><span class="line">    <span class="comment">//将自身作为服务添加</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">"manager"</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not self register servicemanager"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置服务端Bbinder对象</span></span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(manager);</span><br><span class="line">    <span class="comment">//设置成为binder驱动的context manager</span></span><br><span class="line">    ps-&gt;becomeContextManager(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Looper epoll机制处理binder事务</span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::prepare(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line"></span><br><span class="line">    BinderCallback::setupTo(looper);</span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常走不到这里</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化Binder"><a href="#初始化Binder" class="headerlink" title="初始化Binder"></a>初始化Binder</h3><p>首先读取参数，按照之前的rc文件来看，这里的<code>driver</code>为<code>/dev/binder</code>，然后根据此<code>driver</code>初始化此进程的<code>ProcessState</code>单例，根据我们上一章的分析我们知道此时会执行<code>binder_open</code>和<code>binder_mmap</code>，接着对这个单例做一些配置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::initWithDriver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow for initWithDriver to be called repeatedly with the same</span></span><br><span class="line">        <span class="comment">// driver.</span></span><br><span class="line">        <span class="comment">//如果已经被初始化过了，并且传入的driver参数和已初始化的驱动名一样，直接返回之前初始化的单例</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(gProcess-&gt;getDriverName().c_str(), driver)) &#123;</span><br><span class="line">            <span class="keyword">return</span> gProcess;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则异常退出</span></span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"ProcessState was already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断指定的driver是否存在并可读</span></span><br><span class="line">    <span class="keyword">if</span> (access(driver, R_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder driver %s is unavailable. Using /dev/binder instead."</span>, driver);</span><br><span class="line">        <span class="comment">//回滚默认binder驱动</span></span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(driver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>文档：<a href="https://man7.org/linux/man-pages/man2/access.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/access.2.html</a></p>
<p>原型：<code>int access(const char *pathname, int mode);</code></p>
<p>这个函数是用来检查调用进程是否可以对指定文件执行某种操作的，成功返回0，失败返回-1并设置error</p>
<p><code>mode</code>参数可以为以下几个值：</p>
<ul>
<li><p><code>F_OK</code>：文件存在</p>
</li>
<li><p><code>R_OK</code>：文件可读</p>
</li>
<li><p><code>W_OK</code>：文件可写</p>
</li>
<li><p><code>X_OK</code>：文件可执行</p>
</li>
</ul>
<h3 id="注册成为Binder驱动的context-manager"><a href="#注册成为Binder驱动的context-manager" class="headerlink" title="注册成为Binder驱动的context manager"></a>注册成为Binder驱动的context manager</h3><p>接着调用了<code>ProcessState</code>的<code>becomeContextManager</code>函数注册成为<code>Binder</code>驱动的<code>context manager</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProcessState::becomeContextManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    flat_binder_object obj &#123;</span><br><span class="line">        .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback to original method</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"121035042"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> unused = <span class="number">0</span>;</span><br><span class="line">        result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to become context manager failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>binder_ioctl</code>，以<code>BINDER_SET_CONTEXT_MGR_EXT</code>为命令码请求<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">fbo</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;fbo, ubuf, <span class="keyword">sizeof</span>(fbo))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct flat_binder_object *fbo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span>;</span></span><br><span class="line">    <span class="keyword">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//binder的context manager只能设置一次</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">        pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断调用进程是否有权限设置context manager</span></span><br><span class="line">    ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//context-&gt;binder_context_mgr_uid != -1</span></span><br><span class="line">    <span class="keyword">if</span> (uid_valid(context-&gt;binder_context_mgr_uid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">            pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR bad uid %d != %d\n"</span>,</span><br><span class="line">                   from_kuid(&amp;init_user_ns, curr_euid),</span><br><span class="line">                   from_kuid(&amp;init_user_ns,</span><br><span class="line">                     context-&gt;binder_context_mgr_uid));</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置Binder驱动context manager所在进程的用户ID</span></span><br><span class="line">        context-&gt;binder_context_mgr_uid = curr_euid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建binder节点</span></span><br><span class="line">    new_node = binder_new_node(proc, fbo);</span><br><span class="line">    <span class="keyword">if</span> (!new_node) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_node_lock(new_node);</span><br><span class="line">    new_node-&gt;local_weak_refs++;</span><br><span class="line">    new_node-&gt;local_strong_refs++;</span><br><span class="line">    new_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    new_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置binder驱动context manager节点</span></span><br><span class="line">    context-&gt;binder_context_mgr_node = new_node;</span><br><span class="line">    binder_node_unlock(new_node);</span><br><span class="line">    binder_put_node(new_node);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的过程也很简单，首先检查之前是否设置过<code>context manager</code>，然后做权限校验，通过后通过<code>binder_new_node</code>创建出一个新的<code>binder</code>节点，并将它作为<code>context manager</code>节点</p>
<h3 id="Looper循环处理Binder事务"><a href="#Looper循环处理Binder事务" class="headerlink" title="Looper循环处理Binder事务"></a>Looper循环处理Binder事务</h3><p>这里的<code>Looper</code>和我们平常应用开发所说的<code>Looper</code>是一个东西，本篇就不做过多详解了，只需要知道，可以通过<code>Looper::addFd</code>函数监听文件描述符，通过<code>Looper::pollAll</code>或<code>Looper::pollOnce</code>函数接收消息，消息抵达后会回调<code>LooperCallback::handleEvent</code>函数</p>
<p>了解了这些后我们来看一下<code>BinderCallback</code>这个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;</span><br><span class="line">        sp&lt;BinderCallback&gt; cb = <span class="keyword">new</span> BinderCallback;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符</span></span><br><span class="line">        IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(binder_fd &lt; <span class="number">0</span>, <span class="string">"Failed to setupPolling: %d"</span>, binder_fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">        <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听binder文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> ret = looper-&gt;addFd(binder_fd,</span><br><span class="line">                                Looper::POLL_CALLBACK,</span><br><span class="line">                                Looper::EVENT_INPUT,</span><br><span class="line">                                cb,</span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(ret != <span class="number">1</span>, <span class="string">"Failed to add binder FD to Looper"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从binder驱动接收到消息并处理</span></span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>servicemanager</code>进程启动的过程中调用了<code>BinderCallback::setupTo</code>函数，这个函数首先想<code>binder</code>驱动发起了一个<code>BC_ENTER_LOOPER</code>事务请求，获得<code>binder</code>设备的文件描述符，然后调用<code>Looper::addFd</code>函数监听<code>binder</code>设备文件描述符，这样当<code>binder</code>驱动发来消息后，就可以通过<code>Looper::handleEvent</code>函数接收并处理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::setupPolling</span><span class="params">(<span class="keyword">int</span>* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置binder请求码</span></span><br><span class="line">    mOut.writeInt32(BC_ENTER_LOOPER);</span><br><span class="line">    <span class="comment">//检查写缓存是否有可写数据，有的话发送给binder驱动</span></span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="comment">//赋值binder驱动的文件描述符</span></span><br><span class="line">    *fd = mProcess-&gt;mDriverFD;</span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    mProcess-&gt;mCurrentThreads++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder事务处理"><a href="#Binder事务处理" class="headerlink" title="Binder事务处理"></a>Binder事务处理</h2><p><code>BinderCallback</code>类重写了<code>handleEvent</code>函数，里面调用了<code>IPCThreadState::handlePolledCommands</code>函数来接收处理<code>binder</code>事务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当读缓存中数据未消费完时，持续循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE</span></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取并处理响应"><a href="#读取并处理响应" class="headerlink" title="读取并处理响应"></a>读取并处理响应</h3><p>这个函数的重点在<code>getAndExecuteCommand</code>，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从<code>binder</code>驱动那里读写数据，只会处理剩余读缓存）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据）</span></span><br><span class="line">    result = talkWithDriver(<span class="comment">/* true */</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//读取BR响应码</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        ...</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><p>这里有很多线程等其他操作，我们不需要关心，我在这里把他们简化掉了，剩余的代码很清晰，首先从binder驱动中读取数据，然后从数据中读取出<code>BR</code>响应码，接着调用<code>executeCommand</code>函数继续往下处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX:</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data_secctx tr_secctx;</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="keyword">int</span>) BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                result = mIn.read(&amp;tr_secctx, <span class="keyword">sizeof</span>(tr_secctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据到缓冲区</span></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            <span class="comment">//对于ServiceManager的binder节点来说，是没有ptr的</span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="comment">//对于其他binder服务端来说，tr.cookie为本地BBinder对象指针</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对于ServiceManager来说，使用the_context_object这个BBinder对象</span></span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                <span class="comment">//非TF_ONE_WAY模式下需要Reply</span></span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ... <span class="comment">//TF_ONE_WAY模式下不需要Reply，这里只打了些日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点分析这个函数在<code>BR_TRANSACTION</code>下的case，其余的都删减掉</p>
<p>首先，这个函数从读缓存中读取了<code>binder_transaction_data</code>，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个<code>Parcel</code>对象作为缓冲区，从<code>binder_transaction_data</code>中将实际数据读取出来</p>
<p>接着找到本地<code>BBinder</code>对象，对于<code>ServiceManager</code>来说就是之前在<code>main</code>函数中<code>setTheContextObject</code>的<code>ServiceManager</code>对象，而对于其他<code>binder</code>服务端来说，则是通过<code>tr.cookie</code>获取，然后调用<code>BBinder</code>的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保从头开始读取数据</span></span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123;</span><br><span class="line">        <span class="comment">//标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全）</span></span><br><span class="line">        reply-&gt;markSensitive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="comment">//这里的code是由binder客户端请求传递过来的</span></span><br><span class="line">    <span class="comment">//是客户端与服务端的一个约定</span></span><br><span class="line">    <span class="comment">//它标识了客户端像服务端发起的是哪种请求</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case this is being transacted on in the same process.</span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//设置数据指针偏移为0，这样后续读取数据便会从头开始</span></span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Large reply transaction of %zu bytes, interface descriptor %s, code %d"</span>,</span><br><span class="line">                  reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onTransact"><a href="#onTransact" class="headerlink" title="onTransact"></a>onTransact</h3><p>这个函数主要调用了<code>onTransact</code>函数，它是一个虚函数，可以被子类重写。我们观察<code>ServiceManager</code>这个类，它继承了<code>BnServiceManager</code>，在<code>BnServiceManager</code>中重写了这个<code>onTransact</code>函数，它们的继承关系如下：</p>
<p><code>ServiceManager</code> -&gt; <code>BnServiceManager</code> -&gt; <code>BnInterface&lt;IServiceManager&gt;</code> -&gt; <code>IServiceManager</code> &amp; <code>BBinder</code></p>
<p>这里的<code>BnServiceManager</code>是通过<code>AIDL</code>工具生成出来的（<code>AIDL</code>既可以生成<code>Java</code>代码，也可以生成<code>C++</code>代码），我们找到一份生成后的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">BnServiceManager::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> _aidl_code, <span class="keyword">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="keyword">uint32_t</span> _aidl_flags)</span> </span>&#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _aidl_ret_status = ::android::OK;</span><br><span class="line">    <span class="keyword">switch</span> (_aidl_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> BnServiceManager::TRANSACTION_getService: &#123;</span><br><span class="line">            <span class="comment">//参数name</span></span><br><span class="line">            ::<span class="built_in">std</span>::<span class="built_in">string</span> in_name;</span><br><span class="line">            ::android::sp&lt;::android::IBinder&gt; _aidl_return;</span><br><span class="line">            <span class="comment">//类型检查</span></span><br><span class="line">            <span class="keyword">if</span> (!(_aidl_data.checkInterface(<span class="keyword">this</span>))) &#123;</span><br><span class="line">                _aidl_ret_status = ::android::BAD_TYPE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取参数name</span></span><br><span class="line">            _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确认数据已读完</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> st = _aidl_data.enforceNoDataAvail();</span><br><span class="line">            !st.isOk()) &#123;</span><br><span class="line">                _aidl_ret_status = st.writeToParcel(_aidl_reply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行真正的getService函数</span></span><br><span class="line">            ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return));</span><br><span class="line">            <span class="comment">//将状态值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_aidl_status.isOk()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将返回值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_reply-&gt;writeStrongBinder(_aidl_return);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123;</span><br><span class="line">        _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeOverParcel(_aidl_reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _aidl_ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成出的代码格式比较丑，不易阅读，我把它格式化了一下，提取出我们需要的部分。这个函数主要流程就是先从<code>data</code>中读取所需要的参数，然后根据参数执行相对应的函数，然后将状态值写入<code>reply</code>，最后再将返回值写入<code>reply</code>。这里我们将上一章节<code>AIDL</code>生成出的<code>java</code>文件那部分拿过来做对比，我们可以发现，这里<code>Parcel</code>的写入和那里<code>Parcel</code>的读取顺序是严格一一对应的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//先读取状态值</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">//再读取返回值</span></span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际功能实现"><a href="#实际功能实现" class="headerlink" title="实际功能实现"></a>实际功能实现</h3><p>然后我们来看真正功能实现的地方：<code>getService</code>函数，根据之前所说的继承关系，<code>ServiceManager</code>继承自<code>IServiceManager</code>，实现了其中的纯虚函数，其中就包括了<code>getService</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;</span><br><span class="line">    *outBinder = tryGetService(name, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// returns ok regardless of result for legacy reasons</span></span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ServiceManager::tryGetService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">bool</span> startIfNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    sp&lt;IBinder&gt; out;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//从map中寻找相应的服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = mNameToService.find(name); it != mNameToService.end()) &#123;</span><br><span class="line">        service = &amp;(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!service-&gt;allowIsolated) &#123;</span><br><span class="line">            <span class="keyword">uid_t</span> appid = multiuser_get_app_id(ctx.uid);</span><br><span class="line">            <span class="keyword">bool</span> isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isIsolated) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值指向对应service的binder对象</span></span><br><span class="line">        out = service-&gt;binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAccess-&gt;canFind(ctx, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out &amp;&amp; startIfNotFound) &#123;</span><br><span class="line">        tryStartService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out) &#123;</span><br><span class="line">        <span class="comment">// Setting this guarantee each time we hand out a binder ensures that the client-checking</span></span><br><span class="line">        <span class="comment">// loop knows about the event even if the client immediately drops the service</span></span><br><span class="line">        service-&gt;guaranteeClient = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的实现我们就没必要细看了，只需要注意它返回了相应<code>service</code>的<code>binder</code>对象，根据上面的代码来看，会将其写入到<code>reply</code>中</p>
<h3 id="Reply"><a href="#Reply" class="headerlink" title="Reply"></a>Reply</h3><p>实际的功能处理完成后，我们回到<code>IPCThreadState::executeCommand</code>中来。对于非<code>TF_ONE_WAY</code>模式，我们要将<code>reply</code>发送给请求方客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="keyword">const</span> Parcel&amp; reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">status_t</span> statusBuffer;</span><br><span class="line">    <span class="comment">//将binder reply请求打包好写入写缓冲区</span></span><br><span class="line">    err = writeTransactionData(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeTransactionData</code>在上一章中已经分析过了，这里就不多做描述了，<code>waitForResponse</code>我们上一章也分析过了，根据我们在上一章所描述的非<code>TF_ONE_WAY</code>的通信过程，在向<code>binder</code>驱动发送<code>BC_REPLY</code>请求后我们会收到<code>BR_TRANSACTION_COMPLETE</code>响应，根据我们传入<code>waitForResponse</code>的两个参数值，会直接跳出函数中的循环，结束此次<code>binder</code>通信</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="non_oneway"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//参数为两个nullptr，直接跳转到finish结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>binder</code>服务端的一次消息处理到这就结束了，<code>Looper</code>会持续监听着<code>binder</code>驱动<code>fd</code>，等待下一条<code>binder</code>消息的到来</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>经过这么多篇文章的分析，整个<code>Binder</code>架构的大致通信原理、过程，我们应该都了解的差不多了，至于一些边边角角的细节，以后有机会的话我会慢慢再补充</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/06/27/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89/">Android源码分析 - Framework层的Binder（客户端篇）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以<code>aosp</code>分支<code>android-11.0.0_r25</code>作为基础解析</strong></p>
<p>我们在之前的文章中，从驱动层面分析了<code>Binder</code>是怎样工作的，但<code>Binder</code>驱动只涉及传输部分，待传输对象是怎么产生的呢，这就是<code>framework</code>层的工作了。我们要彻底了解<code>Binder</code>的工作原理，不仅要去看驱动层，还得去看<code>framework</code>层以及应用层（<code>AIDL</code>）</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p>我们还是以第一次见到<code>Binder</code>的地方<code>ServiceManager</code>开始分析，我们选取<code>getService</code>方法来分析（这个方法既有入参也有返回），抛除掉它缓存和<code>log</code>的部分，最核心的代码就一句<code>getIServiceManager().getService(name)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BinderInternal-getContextObject"><a href="#BinderInternal-getContextObject" class="headerlink" title="BinderInternal.getContextObject"></a>BinderInternal.getContextObject</h3><p>我们从<code>BinderInternal.getContextObject()</code>开始看起，这个函数是一个<code>native</code>函数，他被实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h4><p>我们在这里可以发现一个比较关键的类<code>ProcessState</code>，它是一个负责打开<code>binder</code>驱动并进行<code>mmap</code>映射的单例对象，这从它的<code>self</code>函数就可以看出来，每个进程只存在一个<code>ProcessState</code>实例</p>
<p>位置：<code>frameworks/native/libs/binder/ProcessState.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看它的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    <span class="comment">//打开binder驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">nullptr</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">nullptr</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>:</code>后是<code>c++</code>构造函数初始化赋值的一种语法，可以看到其中调用了<code>open_driver</code>函数打开<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开binder驱动</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//验证binder版本</span></span><br><span class="line">    <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置binder最大线程数</span></span><br><span class="line">    <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">    result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了三件事，打开<code>binder</code>驱动、验证<code>binder</code>版本、设置<code>binder</code>最大线程数，接着构造函数调用<code>mmap</code>建立<code>binder</code>映射，这里面的实现我们已经在<a href="https://juejin.cn/post/7062654742329032740" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>、<a href="https://juejin.cn/post/7069675794028560391" target="_blank" rel="noopener">（中）</a>、<a href="https://juejin.cn/post/7073783503791325214" target="_blank" rel="noopener">（下）</a>中分析过了，感兴趣的同学可以回过头去看一看</p>
<p><code>ProcessState::self</code>函数执行完后，当前进程的<code>binder</code>初始化工作已经执行完毕，接下来我们回过头来看它的<code>getContextObject</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; context = getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       ALOGW(<span class="string">"Not able to get context object on %s."</span>, mDriverName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The root object is special since we get it directly from the driver, it is never</span></span><br><span class="line">    <span class="comment">// written by Parcell::writeStrongBinder.</span></span><br><span class="line">    internal::Stability::tryMarkCompilationUnit(context.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>binder</code>驱动篇就提到了，<code>handle</code>句柄<code>0</code>代表的就是<code>ServiceManager</code>，所以这里调用<code>getStrongProxyForHandle</code>函数的参数为<code>0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找或建立handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当handle为ServiceManager的特殊情况</span></span><br><span class="line">                <span class="comment">//需要确保在创建Binder引用之前，context manager已经被binder注册</span></span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建BpBinder并保存下来以便后面再次查找</span></span><br><span class="line">            b = BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N=mHandleToObject.size();</span><br><span class="line">    <span class="comment">//新建一个handle_entry并插入到vector中</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路下来还是比较清晰的，最终获得了一个<code>BpBinder</code>对象，这是<code>native</code>中的类型，需要将它转换成<code>java</code>中的类型，这里调用了<code>javaObjectForIBinder</code>函数，位于<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the argument is a JavaBBinder, return the Java object that was used to create it.</span></span><br><span class="line"><span class="comment">// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the</span></span><br><span class="line"><span class="comment">// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.</span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="comment">// In the exception case, getInstance still took ownership of nativeData.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看一看这个<code>gBinderProxyOffsets</code>是什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binderproxy_offsets_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    <span class="comment">//指向BinderProxyNativeData的指针</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderProxyPathName);</span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, <span class="string">"getInstance"</span>,</span><br><span class="line">            <span class="string">"(JJ)Landroid/os/BinderProxy;"</span>);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice =</span><br><span class="line">            GetStaticMethodIDOrDie(env, clazz, <span class="string">"sendDeathNotice"</span>,</span><br><span class="line">                                   <span class="string">"(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V"</span>);</span><br><span class="line">    gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, <span class="string">"mNativeData"</span>, <span class="string">"J"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>gBinderProxyOffsets</code>实际上是一个用来记录一些<code>java</code>中对应类、方法以及字段的结构体，用于从<code>native</code>层调用<code>java</code>层代码</p>
<p>接下来我们看<code>javaObjectForIBinder</code>函数的具体内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个<code>IBinder</code>类型检查的判断，我看了一圈发现目前只有当<code>IBinder</code>的实际类型为<code>JavaBBinder</code>的时候会返回<code>true</code>，其他子类均返回<code>false</code>。<code>JavaBBinder</code>类继承自<code>BBinder</code>，里面保存了对<code>java</code>层<code>Binder</code>对象的引用，所以在这种情况下，直接返回里面的<code>object</code>就好了。</p>
<p>从这里可以看出，<code>native</code>层的<code>javaBBinder</code>与<code>java</code>层的<code>Binder</code>是对应关系</p>
<p>我们这里传进来的是<code>BpBinder</code>，会接着往下走</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实例化一个<code>BinderProxyNativeData</code>，将<code>Binder</code>死亡回调<code>DeathRecipientList</code>和<code>Binder</code>对象（这里为<code>BpBinder</code>）赋值给它，然后调用<code>java</code>层方法。<code>gBinderProxyOffsets</code>之前说过了，类为<code>android.os.BinderProxy</code>，方法为<code>getInstance</code>，所以这里调用的即为<code>android.os.BinderProxy.getInstance(nativeData, iBinder)</code>，<code>BinderProxy</code>的路径为<code>frameworks/base/core/java/android/os/BinderProxy.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> nativeData, <span class="keyword">long</span> iBinder)</span> </span>&#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">new</span> BinderProxy(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We're throwing an exception (probably OOME); don't drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑比较简单，以<code>iBinder</code>为 <strong>key</strong> 尝试从<code>sProxyMap</code>取出<code>BinderProxy</code>，如果取到值了就直接将它返回出去，如果没取到，用之前传进来的<code>BinderProxyNativeData</code>指针为参数实例化一个<code>BinderProxy</code>，并将其设置到<code>sProxyMap</code>中</p>
<p>从这里可以看出每一个服务的<code>BinderProxy</code>都是以单例形式存在的，并且<code>native</code>层的<code>BinderProxyNativeData</code>与<code>java</code>层的<code>BinderProxy</code>是对应关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来判断我们通过<code>BinderProxy.getInstance</code>方法获得的<code>BinderProxy</code>是不是刚刚创建出来的，如果是新建的则需要处理一下proxy计数，这里是通过对比<code>BinderProxy</code>中的<code>mNativeData</code>和我们新建出来的<code>nativeData</code>地址判断的</p>
<h3 id="ServiceManagerNative-asInterface"><a href="#ServiceManagerNative-asInterface" class="headerlink" title="ServiceManagerNative.asInterface"></a>ServiceManagerNative.asInterface</h3><p>我们将目光放回<code>getIServiceManager</code>方法，现在我们知道<code>BinderInternal.getContextObject()</code>方法返回了<code>ServiceManager</code>对应的<code>BinderProxy</code>，接着会调用<code>Binder.allowBlocking</code>方法，这个方法只是改变了<code>BinderProxy</code>中的一个参数，使其允许阻塞调用，这样的话<code>getIServiceManager</code>就可以被简化成如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(<span class="comment">/* BinderProxy */</span>);</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>asInterface</code>方法实际上是直接实例化了一个<code>ServiceManagerProxy</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceManager is never local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServiceManagerProxy"><a href="#ServiceManagerProxy" class="headerlink" title="ServiceManagerProxy"></a>ServiceManagerProxy</h2><p>从名字就能听出来，<code>ServiceManagerProxy</code>其实是一个代理类，它其实是<code>IServiceManager.Stub.Proxy</code>的代理，实际上是没有什么必要的，可以发现作者也在注释中标注了<code>This class should be deleted and replaced with IServiceManager.Stub whenever mRemote is no longer used</code>，我们看一下它的构造方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    mServiceManager = IServiceManager.Stub.asInterface(remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code>实现了<code>IServiceManager</code>接口，但这个方法的实现都是直接调用<code>mServiceManager</code>，以<code>addService</code>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与直接使用<code>IServiceManager.Stub.asInterface(remote)</code>得到<code>IServiceManager</code>并没有什么区别</p>
<h2 id="IServiceManager"><a href="#IServiceManager" class="headerlink" title="IServiceManager"></a>IServiceManager</h2><p>我们将重点转到<code>IServiceManager</code>上，我们在源码中搜索不到<code>IServiceManager.java</code>文件，因为实际上这个文件是通过<code>aidl</code>生成的</p>
<p>关于<code>aidl</code>我们到后面再详细分析，现在我们只需要知道它其实是辅助我们进行<code>binder</code>通信的一种工具，<code>aidl</code>文件会在编译过程中生成出与之对应的<code>java</code>文件</p>
<p><code>IServiceManager</code>的<code>aidl</code>文件路径为<code>frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl</code></p>
<p>我们来看一下它生成出的<code>IServiceManager.Stub.asInterface</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.os.<span class="function">IServiceManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.os.IServiceManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.os.IServiceManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.os.IServiceManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们传入的<code>IBinder</code>是<code>BinderProxy</code>，它的<code>queryLocalInterface</code>永远返回<code>null</code>，所以这里返回的是<code>IServiceManager.Stub.Proxy</code>对象，我们接着看之前调用的<code>getService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p><code>Parcel</code>是一个存放读取数据的容器，它的基本功能和使用相信进阶<code>Android</code>开发应该都懂，我们在这里只介绍一些关键性函数的含义，其他就不多赘述了，有机会的话以后单独开一章分析它</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>obtain</td>
<td>获取一个新的Parcel对象</td>
</tr>
<tr>
<td>ipcData、data</td>
<td>数据区首地址</td>
</tr>
<tr>
<td>ipcDataSize、dataSize</td>
<td>数据大小</td>
</tr>
<tr>
<td>ipcObjects</td>
<td>偏移数组首地址</td>
</tr>
<tr>
<td>ipcObjectsCount</td>
<td>IPC对象数量</td>
</tr>
<tr>
<td>dataPosition</td>
<td>数据指针当前的位置</td>
</tr>
<tr>
<td>dataCapacity</td>
<td>数据区的总容量（始终 &gt;= dataSize）</td>
</tr>
</tbody></table>
<p>这里获取了两个<code>Parcel</code>，一个<code>_data</code>用来传递参数数据，一个<code>_reply</code>用来接收回应。接着，<code>_data</code>首先调用<code>writeInterfaceToken</code>方法，这里的<code>token</code>是客户端与服务端的一个协定，服务端会校验我们写入的这个<code>token</code>，然后按照顺序将参数依次写入到<code>_data</code>中（序列化），然后通过<code>binder</code>调用远程服务真正的方法，然后检查异常。</p>
<p>对于无返回值的方法来说，到这一步已经结束了，但我们这个方法是有返回值的，所以我们需要一个<code>_result</code>，从<code>_reply</code>中读取出数据（反序列化），赋给<code>_result</code>，然后返回出去</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>我们重点看<code>transact</code>这一部分，通过我们之前的分析，我们知道<code>mRemote</code>是一个<code>BinderProxy</code>类型的对象，我们来看他的<code>transact</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//检查Parcel大小</span></span><br><span class="line">    Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//trace</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Binder事务处理回调</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AppOpsManager信息记录</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result = transactNative(code, data, reply, flags);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span> &amp;&amp; !warnOnBlocking) &#123;</span><br><span class="line">            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里简化了一下代码，可以看到，首先就是对<code>Parcel</code>大小的检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkParcel</span><span class="params">(IBinder obj, <span class="keyword">int</span> code, Parcel parcel, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= <span class="number">800</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">// Trying to send &gt; 800k, this is way too much.</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(msg);</span><br><span class="line">        sb.append(<span class="string">": on "</span>);</span><br><span class="line">        sb.append(obj);</span><br><span class="line">        sb.append(<span class="string">" calling "</span>);</span><br><span class="line">        sb.append(code);</span><br><span class="line">        sb.append(<span class="string">" size "</span>);</span><br><span class="line">        sb.append(parcel.dataSize());</span><br><span class="line">        sb.append(<span class="string">" (data: "</span>);</span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">")"</span>);</span><br><span class="line">        Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android</code>默认设置了<code>Parcel</code>数据传输不能超过<strong>800k</strong>，当然，各个厂商是可以随意改动这里的代码的，如果超过了的话，便会调用<code>Slog.wtfStack</code>打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash</p>
<p>省去中间的一些<code>log</code>、回调，接下来便是调用<code>transactNative</code>方法，这是一个<code>native</code>方法，实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>, data-&gt;dataSize());</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是获得<code>native</code>层对应的<code>Parcel</code>并执行判断，<code>Parcel</code>实际上功能是在<code>native</code>中实现的，<code>java</code>中的<code>Parcel</code>类使用<code>mNativePtr</code>成员变量保存了其对应<code>native</code>中的<code>Parcel</code>的指针</p>
<p>然后调用<code>getBPNativeData</code>函数获得<code>BinderProxy</code>在<code>native</code>中对应的<code>BinderProxyNativeData</code>，再通过里面的<code>mObject</code>域成员变量得到其对应的<code>BpBinder</code>，这个函数在之前分析<code>javaObjectForIBinder</code>的时候已经出现过了</p>
<h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder.transact"></a>BpBinder.transact</h2><p>之后便是调用<code>BpBinder</code>的<code>transact</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>Alive</code>判断，可以避免对一个已经死亡的<code>binder</code>服务再发起事务，浪费资源，除此之外便是调用<code>IPCThreadState</code>的<code>transact</code>函数了</p>
<h2 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h2><p>路径：<code>frameworks/native/libs/binder/IPCThreadState.cpp</code></p>
<p>还记得我们之前提到的<code>ProcessState</code>吗？<code>IPCThreadState</code>和它很像，<code>ProcessState</code>负责打开<code>binder</code>驱动并进行<code>mmap</code>映射，而<code>IPCThreadState</code>则是负责与<code>binder</code>驱动进行具体的交互</p>
<p><code>IPCThreadState</code>也有一个<code>self</code>函数，与<code>ProcessState</code>的<code>self</code>不同的是，<code>ProcessState</code>是进程单例，而<code>IPCThreadState</code>是线程单例，我们来看看它是怎么实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不是初次调用的情况</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="comment">//初次调用，生成线程私有变量key后</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">//先从线程本地储存空间中尝试获取值</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">//没有的话就实例化一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPCThreadState shutdown后不能再获取</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首次获取时gHaveTLS为false，会先走这里</span></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">//创建一个key，作为存放线程本地变量的key</span></span><br><span class="line">        <span class="keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(<span class="string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建完毕，gHaveTLS置为true</span></span><br><span class="line">        gHaveTLS.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">//回到gHaveTLS为true的case</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gHaveTLS</code>是一个原子类型的<code>bool</code>值，它在存取过程中需要指定内存序<code>std::memory_order_xxx</code>，在这里我们直接忽略掉，把它当成一个纯粹的<code>bool</code>值就好了</p>
<p>在这里，<code>TLS</code>的全称为<code>Thread Local Storage</code>，表示线程本地储存空间，和<code>java</code>中的<code>ThreadLocal</code>其实是一个作用</p>
<p>当一个线程初次获取<code>IPCThreadState</code>的时候，会先走到<code>gHaveTLS</code>为<code>false</code>的case，此时程序会创建一个<code>key</code>，作为存放线程本地变量的<code>key</code>，创建成功后将<code>gHaveTLS</code>置为<code>true</code>，然后<code>goto</code>到<code>gHaveTLS</code>为<code>true</code>的case，此时线程本地储存空间中暂时还是没有数据的，所以会<code>new</code>一个<code>IPCThreadState</code>出来，在<code>IPCThreadState</code>的构造函数中，会将自己保存到线程本地储存空间中，这样，当线程第二次再获取<code>IPCThreadState</code>的时候，便会直接走到<code>pthread_getspecific</code>这里获取并返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">      : mProcess(ProcessState::self()),</span><br><span class="line">        mServingStackPointer(<span class="literal">nullptr</span>),</span><br><span class="line">        mServingStackPointerGuard(<span class="literal">nullptr</span>),</span><br><span class="line">        mWorkSource(kUnsetWorkSource),</span><br><span class="line">        mPropagateWorkSource(<span class="literal">false</span>),</span><br><span class="line">        mIsLooper(<span class="literal">false</span>),</span><br><span class="line">        mIsFlushing(<span class="literal">false</span>),</span><br><span class="line">        mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">        mLastTransactionBinderFlags(<span class="number">0</span>),</span><br><span class="line">        mCallRestriction(mProcess-&gt;mCallRestriction) &#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过构造函数可以发现，它调用了<code>pthread_setspecific</code>函数将自身保存在了线程本地储存空间中</p>
<p><code>IPCThreadState</code>中，成员变量<code>mIn</code>用于接收来自<code>binder</code>设备的数据，<code>mOut</code>用于储存发往<code>binder</code>设备的数据，他们的默认容量都为<code>256字节</code></p>
<h3 id="transact"><a href="#transact" class="headerlink" title="transact"></a>transact</h3><p>我们接着看它的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(data.isForRpc(), <span class="string">"Parcel constructed for RPC, but being used with binder."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;    <span class="comment">//binder事务不为TF_ONE_WAY</span></span><br><span class="line">        <span class="comment">//当线程限制binder事务不为TF_ONE_WAY时</span></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123;</span><br><span class="line">                <span class="comment">//这个限制只是log记录</span></span><br><span class="line">                ALOGE(<span class="string">"Process making non-oneway call (code: %u) but is restricted."</span>, code);</span><br><span class="line">                CallStack::logStack(<span class="string">"non-oneway call"</span>, CallStack::getCurrent(<span class="number">10</span>).get(),</span><br><span class="line">                    ANDROID_LOG_ERROR);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* FATAL_IF_NOT_ONEWAY */</span> &#123;</span><br><span class="line">                <span class="comment">//这个限制会终止线程</span></span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Process may not make non-oneway calls (code: %u)."</span>, code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在于<code>writeTransactionData</code>和<code>waitForResponse</code>，我们依次分析</p>
<h4 id="writeTransactionData"><a href="#writeTransactionData" class="headerlink" title="writeTransactionData"></a>writeTransactionData</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    <span class="comment">//目标binder句柄值，ServiceManager为0</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//数据大小</span></span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        <span class="comment">//数据区起始地址</span></span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        <span class="comment">//传递的偏移数组大小</span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//偏移数组的起始地址</span></span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里为BC_TRANSACTION</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析这个函数之前，我们需要先回忆一下在前面<code>binder</code>驱动章节我们所学习的<code>binder</code>结构和通信过程：<a href="https://juejin.cn/post/7069675794028560391#heading-13" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a></p>
<p><code>binder_tansaction</code>首先会读取一个请求码<code>cmd</code>，当<code>binder</code>请求码为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>的时候，<code>binder</code>驱动所接收的参数为<code>binder_transaction_data</code>结构体，所以在这个函数中，我们将<code>binder</code>请求码（这里为<code>BC_TRANSACTION</code>）和<code>binder_transaction_data</code>结构体依次写入到<code>mOut</code>中，为之后<code>binder_tansaction</code>做准备</p>
<h4 id="waitForResponse"><a href="#waitForResponse" class="headerlink" title="waitForResponse"></a>waitForResponse</h4><p>数据准备好后，接着便来到了<code>waitForResponse</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_ONEWAY_SPAM_SUSPECT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FROZEN_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//这里是binder服务端部分的处理，现在不需要关注</span></span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个循环，正如函数名所描述，会一直等待到一整条<code>binder</code>事务链结束返回后才会退出这个循环，在这个循环的开头，便是<code>talkWithDriver</code>方法</p>
<h5 id="talkWithDriver"><a href="#talkWithDriver" class="headerlink" title="talkWithDriver"></a>talkWithDriver</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查打开的binder设备的fd</span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">//dataPosition &gt;= dataSize说明上一次读取到的数据已经消费完</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">//需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">//将read_size设置为读缓存可用容量</span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        <span class="comment">//设置读缓存起始地址</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="comment">//没有要读写的数据就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//调用binder驱动的ioctl</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//写数据被消费了</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//写数据没有被消费完</span></span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Driver did not consume write buffer. "</span></span><br><span class="line">                                 <span class="string">"err: %s consumed: %zu of %zu"</span>,</span><br><span class="line">                                 statusToString(err).c_str(),</span><br><span class="line">                                 (<span class="keyword">size_t</span>)bwr.write_consumed,</span><br><span class="line">                                 mOut.dataSize());</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到了数据</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了</span></span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>binder_write_read</code>也是一个我们熟悉的结构，我们在之前的文章<a href="https://juejin.cn/post/7069675794028560391#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>中了解过，关于<code>binder</code>通信的代码，我们需要结合着<code>binder</code>驱动一起看才能理解</p>
<p>在<code>binder</code>驱动层中，<code>binder_ioctl_write_read</code>函数会从用户空间读取一个<code>binder_write_read</code>结构，这个结构体主要描述了数据传输的大小和位置以及消费情况（已读/写数据大小），这么看来，<code>talkWithDriver</code>函数的结构就很清晰了：</p>
<ol>
<li><p>创建出<code>binder_write_read</code>结构，根据之前的读取情况，决定是否读写数据，设置写数据内容和大小，设置读数据的空间和容量</p>
</li>
<li><p>调用<code>binder</code>驱动的<code>ioctl</code></p>
</li>
<li><p>重置写缓存，根据<code>ioctl</code>的结果设置读缓存</p>
</li>
</ol>
<p>这之后，<code>waitForResponse</code>函数就可以从读缓存<code>mIn</code>中读到数据了，我们回到这个函数中，发现它首先从读缓存中读取了一个<code>binder</code>响应码，然后根据这个响应码再处理接下来的工作</p>
<h5 id="处理Reply"><a href="#处理Reply" class="headerlink" title="处理Reply"></a>处理Reply</h5><p>在此之前，我们先回顾一下一次<code>binder_tansaction</code>的整个过程，根据事务类型，分为两种情况：</p>
<ul>
<li><code>TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_oneway.png" alt="binder_oneway"></p>
<ul>
<li><code>非 TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="binder_non_oneway"></p>
<p>我们先对照着看<code>TF_ONE_WAY</code>的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>TF_ONE_WAY</code>模式来说，客户端在收到<code>BR_TRANSACTION_COMPLETE</code>响应码后则返回，不会再等待<code>BR_REPLY</code></p>
<p>而对于非<code>TF_ONE_WAY</code>模式来说，客户端不仅会收到<code>BR_TRANSACTION_COMPLETE</code>响应码，之后还会阻塞等待<code>binder</code>驱动给它发来<code>BR_REPLY</code>响应码，这之后一次<code>binder_transaction</code>才算完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，非<code>TF_ONE_WAY</code>模式肯定是需要一个<code>reply</code>来接收的，即<code>reply != null</code>，此时我们来看看接收正常<code>reply</code>的过程（接收32位状态码没什么好说的，直接从读缓冲区中强制类型转换出一个32位的code就完事了）</p>
<p>这里我们就需要看一下<code>Parcel</code>的<code>ipcSetDataReference</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize, <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">size_t</span> objectsCount, release_func relFunc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this code uses 'mOwner == nullptr' to understand whether it owns memory</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(relFunc == <span class="literal">nullptr</span>, <span class="string">"must provide cleanup function"</span>);</span><br><span class="line">    <span class="comment">//先清理重置一下数据和状态</span></span><br><span class="line">    freeData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* kernelFields = maybeKernelFields();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(kernelFields == <span class="literal">nullptr</span>); <span class="comment">// guaranteed by freeData.</span></span><br><span class="line"></span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    kernelFields-&gt;mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects);</span><br><span class="line">    kernelFields-&gt;mObjectsSize = kernelFields-&gt;mObjectsCapacity = objectsCount;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kernelFields-&gt;mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = kernelFields-&gt;mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span> PRIu64 <span class="string">" &lt; %"</span> PRIu64 <span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* flat</span><br><span class="line">            = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData + offset);</span><br><span class="line">        <span class="keyword">uint32_t</span> type = flat-&gt;hdr.type;</span><br><span class="line">        <span class="comment">//binder类型出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||</span><br><span class="line">              type == BINDER_TYPE_FD)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个函数也不复杂，我们知道<code>binder_mmap</code>做到了一次拷贝，将数据拷贝到了内核物理内存中，然后将其与用户空间虚拟内存做了映射，所以这个函数此时只需要将数据的地址，大小等等无脑赋值进去，客户端后续便可以用<code>Parcel</code>提供的函数方便的从中读取数据了</p>
<h5 id="freeBuffer"><a href="#freeBuffer" class="headerlink" title="freeBuffer"></a>freeBuffer</h5><p>最后我们再来看一下<code>freeBuffer</code>这个释放缓冲区的方法，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::freeBuffer</span><span class="params">(Parcel* parcel, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*dataSize*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* <span class="comment">/*objects*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*objectsSize*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">nullptr</span>) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state = self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((<span class="keyword">uintptr_t</span>)data);</span><br><span class="line">    state-&gt;flushIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里向<code>binder</code>驱动发送了一个<code>BC_FREE_BUFFER</code>请求，然后<code>binder</code>驱动会负责回收这块缓冲区内存</p>
<p>我们在<code>Parcel::ipcSetDataReference</code>函数中可以发现，它将<code>freeBuffer</code>函数指针赋值给了<code>mOwner</code>，等到什么时候不需要这个<code>Parcel</code>了，便会调用这个函数进行缓冲区内存回收</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里，我们客户端与<code>binder</code>驱动沟通交互的分析就结束了，相比<code>binder</code>驱动而言，<code>framework</code>层的<code>binder</code>就好理解多了，下一章我们会从服务端的角度来看，它是怎么从<code>binder</code>驱动接收并处理客户端的请求的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/">Jetpack Compose入门</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Jetpack-Compose/">Jetpack Compose</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Jetpack-Compose/">Jetpack Compose</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Jetpack Compose</code>是用于构建原生<code>Android</code>界面的新工具包。它是一种声明式的UI布局，其官方声称可简化并加快<code>Android</code>上的界面开发，使用更少的代码、强大的工具和直观的<code>Kotlin API</code>，快速让应用生动而精彩。</p>
<p>官网：<a href="https://developer.android.com/jetpack/compose?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose?hl=zh-cn</a></p>
<p>我这里也写了一个<code>Compose</code>的<code>Demo</code>，可以对照着看：<a href="https://github.com/dreamgyf/ComposeDemo" target="_blank" rel="noopener">https://github.com/dreamgyf/ComposeDemo</a></p>
<p>这个<code>Demo</code>实现了：</p>
<ul>
<li><code>Compose</code>替代传统布局</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E6%9B%BF%E4%BB%A3%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt="Compose替代传统布局"></p>
<ul>
<li>网格列表效果，类似于传统布局中的<code>RecyclerView</code>配合<code>GridLayoutManager</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E7%BD%91%E6%A0%BC%E5%88%97%E8%A1%A8%E6%95%88%E6%9E%9C.png" alt="网格列表"></p>
<ul>
<li><p>在传统View中使用Compose</p>
</li>
<li><p>在Compose中使用传统View</p>
</li>
<li><p>自定义布局</p>
</li>
</ul>
<h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><p>使用<code>Jetpack Compose</code>需要先引入一些依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'androidx.core:core-ktx:1.7.0'</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.ui:ui:$compose_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.material:material:$compose_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.ui:ui-tooling-preview:$compose_version"</span></span><br><span class="line">    implementation <span class="string">'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'</span></span><br><span class="line">    implementation <span class="string">'androidx.activity:activity-compose:1.3.1'</span></span><br><span class="line">    debugImplementation <span class="string">"androidx.compose.ui:ui-tooling:$compose_version"</span></span><br><span class="line">	<span class="comment">//网络图片加载三方库</span></span><br><span class="line">    implementation <span class="string">"io.coil-kt:coil-compose:1.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可组合函数"><a href="#可组合函数" class="headerlink" title="可组合函数"></a>可组合函数</h1><p><code>Jetpack Compose</code>是围绕着可组合函数构建起来的，这些函数以程序化方式定义应用的界面，只需描述应用界面的外观并提供数据依赖项，而不必关注界面的构建过程。此类函数有几个要点：</p>
<ul>
<li>所有可组合函数必须使用<code>@Composable</code>注解修饰</li>
<li>可组合函数可以像正常函数一样接受参数</li>
</ul>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Text(text = <span class="string">"Hello, <span class="subst">$&#123;name&#125;</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可组合函数内部可以书写正常代码（譬如可以通过<code>if else</code>控制显示的控件）</li>
</ul>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(showPic: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (showPic) &#123;</span><br><span class="line">    	Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.demo),</span><br><span class="line">            contentDescription = <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    Text(text = <span class="string">"Hello, compose!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><p><code>Android</code>常用的单位<code>dp</code>，<code>sp</code>等，在<code>Compose</code>中以类的形式被定义，使用的方式也很简单，<code>Compose</code>借助了<code>kotlin</code>的扩展属性，扩展了<code>Int</code>，<code>Double</code>，<code>Float</code>三个基础类，使用方式如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp</span></span><br><span class="line"><span class="number">1</span>.dp; <span class="number">2.3f</span>.dp; <span class="number">4.5</span>.dp</span><br><span class="line"><span class="comment">//sp</span></span><br><span class="line"><span class="number">1</span>.sp; <span class="number">2.3f</span>.sp; <span class="number">4.5</span>.sp</span><br></pre></td></tr></table></figure>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>如何在<code>Compose</code>中使用资源呢，可以通过<code>xxxResource</code>方法</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">painterResource</span><span class="params">(<span class="meta">@DrawableRes</span> id: <span class="type">Int</span>)</span></span>: Painter</span><br><span class="line"><span class="comment">//尺寸资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dimensionResource</span><span class="params">(<span class="meta">@DimenRes</span> id: <span class="type">Int</span>)</span></span>: Dp</span><br><span class="line"><span class="comment">//颜色资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">colorResource</span><span class="params">(<span class="meta">@ColorRes</span> id: <span class="type">Int</span>)</span></span>: Color</span><br><span class="line"><span class="comment">//字符串资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringResource</span><span class="params">(<span class="meta">@StringRes</span> id: <span class="type">Int</span>)</span></span>: String</span><br><span class="line"><span class="comment">//字体资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fontResource</span><span class="params">(fontFamily: <span class="type">FontFamily</span>)</span></span>: Typeface</span><br></pre></td></tr></table></figure>

<h1 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h1><p><code>Modifier</code>是<code>Compose</code>中的布局修饰符，它控制了布局的大小，padding，对齐，背景，边框，裁切，点击等属性，几乎所有的<code>Compose</code>布局都需求这项参数，是<code>Compose</code>布局中的重中之重</p>
<p>这里介绍一些常用的基本属性，文中没列到的属性可以去官网查看：<a href="https://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn</a></p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><ul>
<li><code>fillMaxWidth</code>和<code>fillMaxHeight</code>相当于<code>xml</code>布局中的<code>match_parent</code></li>
<li><code>fillMaxSize</code>相当于同时设置了<code>fillMaxWidth</code>和<code>fillMaxHeight</code></li>
<li><code>wrapContentWidth</code>和<code>wrapContentHeight</code>相当于<code>xml</code>布局中的<code>wrapContent</code></li>
<li><code>wrapContentSize</code>相当于同时设置了<code>wrapContentWidth</code>和<code>wrapContentHeight</code></li>
<li><code>width</code>和<code>height</code>则是设置固定宽高，单位为<code>Dp</code></li>
<li><code>size</code>相当于同时设置了<code>width</code>和<code>height</code></li>
<li><code>weight</code>属性仅在<code>Row</code>或<code>Column</code>的内部作用域中可以使用，相当于传统<code>LinearLayout</code>布局中的<code>weight</code>属性</li>
</ul>
<h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p><code>padding</code>方法有几个重载，这些<code>API</code>很简单，看参数就很容易能明白意思</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p><code>align</code>属性，使控件可以在父布局中以一种方式对齐，相当于<code>xml</code>布局中的layout_gravity属性。另外还有<code>alignBy</code>以及<code>alignByBaseline</code>属性可以自行研究</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ul>
<li><code>background</code>设置背景，不过不能设置图片，如果想以图片作为背景可以使用<code>Box</code>布局，在底部垫一个<code>Image</code>控件</li>
<li><code>alpha</code>设置透明度</li>
<li><code>clip</code>裁剪内容，这个功能很强大，可以直接将视图裁出圆角，圆形等形状</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><code>clickable</code>方法，可以设置控件的点击事件回调</li>
<li><code>combinedClickable</code>方法，可以设置控件的点击、双击、长按事件回调</li>
<li><code>selectable</code>方法，将控件配置为可点击，同时可以设置点击事件</li>
</ul>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><ul>
<li><code>horizontalScroll</code>：使控件支持水平滚动</li>
<li><code>verticalScroll</code>：使控件支持垂直滚动</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在<code>Modifier</code>中设置属性的前后顺序是很重要的，譬如想要一个背景为蓝色的圆角布局，需要先设置<code>clip</code>，再设置<code>background</code>，反过来<code>background</code>会超出圆角范围</p>
<h1 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h1><p><code>Compose</code>中没有了<code>margin</code>的概念，可以用<code>Spacer</code>替代，<code>Spacer</code>为留白的意思，使用起来也很简单</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平间隔8dp</span></span><br><span class="line">Spacer(modifier = Modifier.width(<span class="number">8</span>.dp))</span><br></pre></td></tr></table></figure>

<h1 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h1><h2 id="Row-amp-Column"><a href="#Row-amp-Column" class="headerlink" title="Row &amp; Column"></a>Row &amp; Column</h2><p>这是两个基本布局组件，其中<code>Row</code>为水平布局，<code>Column</code>为垂直布局，他们俩接受的参数相似，其中两个参数为<code>horizontalArrangement</code>和<code>verticalAlignment</code>，他们一个表示水平布局方式，一个表示垂直布局方式，他们默认值为<code>START</code>和<code>TOP</code>，这两个参数用起来就和传统布局的<code>gravity</code>参数一样</p>
<h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p><code>Box</code>也是一种基本布局组件，<code>Box</code>布局中的组件是可以叠加的，类似传统布局中的<code>FrameLayout</code>，可以通过<code>contentAlignment</code>参数调整叠加的方式，其默认值为<code>TopStart</code>，叠加到左上角，这个参数也和<code>FrameLayout</code>的<code>gravity</code>参数一样</p>
<h1 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h1><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>文本控件，对应传统控件TextView，它有以下一些属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>文本内容</td>
</tr>
<tr>
<td>color</td>
<td>文字颜色</td>
</tr>
<tr>
<td>fontSize</td>
<td>文字大小</td>
</tr>
<tr>
<td>fontStyle</td>
<td>文本样式（可以设置斜体）</td>
</tr>
<tr>
<td>fontWeight</td>
<td>字重（粗体等）</td>
</tr>
<tr>
<td>fontFamily</td>
<td>字体</td>
</tr>
<tr>
<td>letterSpacing</td>
<td>文字间距</td>
</tr>
<tr>
<td>textAlign</td>
<td>文本对齐方式</td>
</tr>
<tr>
<td>lineHeight</td>
<td>行高</td>
</tr>
<tr>
<td>maxLines</td>
<td>最大行数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>图片控件，对应传统控件ImageView，它有以下一些属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>painter</td>
<td>图片内容</td>
</tr>
<tr>
<td>contentDescription</td>
<td>无障碍描述（可为null）</td>
</tr>
<tr>
<td>alignment</td>
<td>对齐方式</td>
</tr>
<tr>
<td>contentScale</td>
<td>缩放方式（和scaleType属性类似）</td>
</tr>
<tr>
<td>alpha</td>
<td>透明度</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>在开发中经常会面对从网络价值图片的情况，这时候可以借助一些第三方库来解决，这里以coil库为例：</p>
<ol>
<li>先添加依赖</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"io.coil-kt:coil-compose:1.4.0"</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用</li>
</ol>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">	modifier = Modifier</span><br><span class="line">		.size(<span class="number">68</span>.dp, <span class="number">68</span>.dp)</span><br><span class="line">		.clip(RoundedCornerShape(<span class="number">6</span>.dp)),</span><br><span class="line">	contentScale = ContentScale.Crop,</span><br><span class="line">    painter = rememberImagePainter(picUrl), <span class="comment">//使用rememberImagePainter方法填入图片url</span></span><br><span class="line">    contentDescription = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><code>Compose</code>有两种组件<code>LazyRow</code>和<code>LazyColumn</code>，一种水平，一种垂直，对应着传统UI中的<code>RecyclerView</code>，用这些组件可以方便的构建列表视图，它们需要提供一个<code>LazyListScope.()</code>块描述列表项内容</p>
<p><code>LazyListScope</code>的<code>DSL</code>提供了多种函数来描述列表项：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于添加单个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">item</span><span class="params">(key: <span class="type">Any</span>? = <span class="literal">null</span>, content: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">//用于添加多个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">items</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        count: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        key: ((<span class="type">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Any</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        itemContent: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.(<span class="type">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="comment">//用于添加多个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> LazyListScope.<span class="title">items</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    items: <span class="type">List</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> key: ((<span class="type">item</span>: <span class="type">T</span>) -&gt; <span class="type">Any</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> itemContent: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.(<span class="type">item</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">LazyColumn &#123;</span><br><span class="line">    <span class="comment">//增加单个列表项</span></span><br><span class="line">    item &#123;</span><br><span class="line">        Text(text = <span class="string">"First item"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加5个列表项</span></span><br><span class="line">    items(<span class="number">5</span>) &#123; index -&gt;</span><br><span class="line">        Text(text = <span class="string">"Item: <span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加5个列表项</span></span><br><span class="line">    items(list) &#123; listItem -&gt;</span><br><span class="line">		Text(text = <span class="string">"Item: <span class="variable">$listItem</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加单个列表项</span></span><br><span class="line">    item &#123;</span><br><span class="line">        Text(text = <span class="string">"Last item"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>contentPadding</code>为内容添加内边距，使用<code>verticalArrangement</code>或<code>horizontalArrangement</code>，以<code>Arrangement.spacedBy()</code>为列表项之间添加间距</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>在<code>Compose</code>中，数据的更新和传统命令式UI不同，是通过一种可观察类型对象，当一个可观察类型对象发生改变时，这个对象对应观察的部分会发生重组，从而自动更新UI</p>
<p>可观察类型<code>MutableState&lt;T&gt;</code>通常是通过<code>mutableStateOf()</code>函数创建的，这个对象的<code>value</code>发生变化时，对应UI也会跟着随之变化</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了kotlin的by关键字，是一种代理模式</span></span><br><span class="line"><span class="comment">//如果使用 = 的话，这个对象的类型会发生变化，需要count.value这样使用它的值</span></span><br><span class="line"><span class="comment">//var count = mutableStateOf(0)</span></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">by</span> mutableStateOf(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"count: <span class="subst">$&#123;count&#125;</span>"</span>)</span><br><span class="line">        Button(onClick = &#123; addCount() &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">"add count"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//++count.value</span></span><br><span class="line">    ++count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//当点击Button时，触发点击事件，更新可观察对象count，触发UI重组</span></span><br><span class="line">    <span class="comment">//Demo(count.value)</span></span><br><span class="line">    Demo(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于Context"><a href="#关于Context" class="headerlink" title="关于Context"></a>关于Context</h1><p>在<code>Compose</code>中可以通过<code>LocalContext.current</code>获得当前<code>Context</code></p>
<h1 id="在传统View中使用Compose"><a href="#在传统View中使用Compose" class="headerlink" title="在传统View中使用Compose"></a>在传统View中使用Compose</h1><p>可以在一个传统布局<code>xml</code>中插入一个<code>ComposeView</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/hello_world"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello from XML layout"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插入ComposeView --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.compose.ui.platform.ComposeView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/compose_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在代码中设置这个<code>ComposeView</code></p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;ComposeView&gt;(R.id.compose_view).setContent &#123;</span><br><span class="line">	Text(<span class="string">"Hello Compose!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在Compose中使用传统View"><a href="#在Compose中使用传统View" class="headerlink" title="在Compose中使用传统View"></a>在Compose中使用传统View</h1><p>可以使用<code>AndroidView</code>这个<code>composable</code>函数，这个函数接受一个<code>factory</code>参数，这个参数接受一个<code>Context</code>，用于构建传统<code>View</code>，要求返回一个继承自<code>View</code>的对象</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"Compose Text"</span>)</span><br><span class="line">        AndroidView(factory = &#123; context -&gt;</span><br><span class="line">            <span class="comment">//这里也可以使用LayoutInflater从xml中解析出一个View</span></span><br><span class="line">            TextView(context).apply &#123;</span><br><span class="line">                text = <span class="string">"传统TextView"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h1><p>在<code>Compose</code>中，如果想要自定义一些简单的UI是很简单的，只需要写一个<code>Composable</code>函数就可以了，我们主要学习一下怎么自定义一些复杂的UI</p>
<p>我们先看一下怎么自定义一个布局，对应着传统UI中的<code>ViewGroup</code>，以一个简单的例子来说，我们自定义一个布局，让其中的子布局呈左上到右下依次排列：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyLayout</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">//测量每个子布局</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.measure(constraints)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置布局大小为最大可容纳大小</span></span><br><span class="line">        layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> xPosition = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> yPosition = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//放置每个子View</span></span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(x = xPosition, y = yPosition)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下一个子View的坐标为上一个子View的右下角</span></span><br><span class="line">                xPosition += placeable.width</span><br><span class="line">                yPosition += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一个使用<code>Canvas</code>自定义<code>View</code>的方式，这个更简单，就是画一条水平线：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"ModifierParameter"</span>)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HorizontalLine</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier.fillMaxWidth()</span></span>) &#123;</span><br><span class="line">    Canvas(modifier = Modifier</span><br><span class="line">        .then(modifier), onDraw = &#123;</span><br><span class="line">        drawLine(color = Color.Black, Offset(<span class="number">0f</span>, <span class="number">0f</span>), Offset(size.width, <span class="number">0f</span>), <span class="number">2f</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将两者一起用一下看看效果</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyLayout &#123;</span><br><span class="line">        Text(text = <span class="string">"Text1"</span>)</span><br><span class="line">        HorizontalLine(Modifier.width(<span class="number">50</span>.dp))</span><br><span class="line">        Text(text = <span class="string">"Text2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E8%87%AA%E5%AE%9A%E4%B9%89Layout.png" alt="效果图"></p>
<p>其实<code>Compose</code>中的自定义UI的思路和传统自定义<code>View</code>是一样的，只不过需要熟悉<code>Compose</code>中的各种<code>Api</code>才能灵活运用它</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/31/linux/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Linux信号机制及其原理分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BF%A1%E5%8F%B7/">信号</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最近在工作中，使用到了信号的相关知识，之前我们在分析<code>Android</code>系统<code>init</code>进程的时候也提到了信号，但并没有对信号这个机制做出深入的理解，借此机会，我们深入分析一下<code>Linux</code>信号机制是怎样实现的</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>信号（<code>signal</code>），是<code>Unix</code>系统中的一种古老的进程间通信机制，而<code>Linux</code>作为类<code>Unix</code>系统，早期也是模仿了<code>Unix</code>系统，自然也保留下了这个机制。信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟</p>
<p><strong>注：本篇文章基于glibc版本2.35，Linux内核版本5.17，x86_64架构</strong></p>
<h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>信号可以由内核产生，也可以由用户产生，这边举几个例子：</p>
<ul>
<li><p>用户在终端输入<code>ctrl + c</code>时，会产生一个<code>SIGINT</code>信号</p>
</li>
<li><p>在程序中对一个数除0，会产生一个异常，最终由内核产生一个<code>SIGFPE</code>信号</p>
</li>
<li><p>在程序中非法访问一段内存，会由内核产生一个<code>SIGBUS</code>信号</p>
</li>
<li><p>在终端或程序中手动发送一个信号</p>
<ul>
<li><p>终端：比如说<code>kill -9 [pid]</code></p>
</li>
<li><p>程序：调用<code>kill</code>函数，<code>raise</code>函数等</p>
</li>
</ul>
</li>
</ul>
<h1 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h1><p>在<code>Linux</code>中，信号被分为不可靠信号和可靠信号，一共64种，可以通过<code>kill -l</code>命令来查看</p>
<ul>
<li><p>不可靠信号：也称为非实时信号，不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，信号值取值区间为1~31</p>
</li>
<li><p>可靠信号：也称为实时信号，支持排队，信号不会丢失，发多少次，就可以收到多少次，信号值取值区间为32~64</p>
</li>
</ul>
<p>在早期的<code>Linux</code>中，只定义了前面的不可靠信号，随着时间的发展，发现有必要对信号机制加以改进和扩充，又由于原先定义的信号已有应用，出于兼容性考虑，不能再做改动，于是又新增了一部分信号，这些信号被定义为可靠信号。</p>
<p>在<code>arch/x86/include/uapi/asm/signal.h</code>中，我们可以发现这些信号的定义，在文末的附录中，我们也详细介绍了每个信号的含义和默认动作</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>我一向认为，如果想要理解一个技术原理，首先我们必须要会使用这个技术</p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>之前提过，用户是可以手动向一个进程发送信号的，我们可以使用以下一些函数：</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/kill.2.html</a></p>
<p>这个函数的作用是向指定进程（或进程组）发送一个信号，成功返回0，失败返回-1</p>
<p>其中的<code>pid</code>参数：</p>
<ul>
<li><p>当<code>pid &gt; 0</code>时，发送信号给pid对应的进程</p>
</li>
<li><p>当<code>pid = 0</code>时，发送信号给本进程组中的所有进程</p>
</li>
<li><p>当<code>pid = -1</code>时，发送信号给所有调用进程有权给其发送信号的进程，除了init进程</p>
</li>
<li><p>当<code>pid &lt; -1</code>时，发送信号给进程组id为<code>-pid</code>的所有进程</p>
</li>
</ul>
<p>当<code>sig</code>参数为0时，不会发送任何信号，但仍然会进行参数检测，我们可以用这种方法检查<code>pid</code>对应进程是否存在或允许发送信号</p>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/raise.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/raise.3.html</a></p>
<p>这个函数的作用是向本进程或线程发送信号，成功返回0，失败返回-1</p>
<p>这个函数对于主线程来说，相当于<code>kill(getpid(), sig)</code>，对于子线程来说，相当于<code>pthread_kill(pthread_self(), sig)</code></p>
<h3 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a>sigqueue</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigqueue.3.html</a></p>
<p>这个函数的作用是向一个进程发送信号，同时可以传递一些额外数据，成功返回0，失败返回-1</p>
<p>这个函数和<code>kill</code>不同的地方是，它只能向一个进程发送信号，不能发送给信号组，当<code>sig</code>为0时，行为和<code>kill</code>一致</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">noreturn <span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/abort.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/abort.3.html</a></p>
<p>这个函数的作用是向本进程发送<code>SIGABRT</code>信号</p>
<p>需要注意的有两点：</p>
<ul>
<li><p><code>abort</code>函数会首先解除进程对<code>SIGABRT</code>信号的阻塞</p>
</li>
<li><p>无论<code>SIGABRT</code>信号是否注册了自定义处理器，最后都会终止进程，因为<code>abort</code>函数会在<code>SIGABRT</code>信号处理完后恢复默认信号处理方式，然后重发这个信号</p>
</li>
</ul>
<h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/alarm.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/alarm.2.html</a></p>
<p>这个函数的作用是在<code>seconds</code>秒后向本进程发送<code>SIGALRM</code>信号</p>
<p>参数<code>seconds</code>为时间，单位为秒</p>
<p>返回值，如果以前没有设置过<code>alarm</code>或超时，则返回0，如果以前没有设置过<code>alarm</code>，则返回剩余的时间</p>
<h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>我们是可以自定义一些信号的处理方式，需要注意的是，<code>SIGKILL</code>和<code>SIGSTOP</code>是两个特殊的信号，它们不允许被忽略、处理和阻塞</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct sigaction *<span class="keyword">restrict</span> oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>这是较新的一个信号处理函数，它的作用是，对一个信号注册一个新的信号处理方式，并获取以前的信号处理方式，成功返回0，失败返回-1</p>
<p>第一个参数<code>signum</code>，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>用来指定注册的新的信号处理方式</p>
<p>第三个参数<code>oldact</code>不为<code>null</code>时，可以用来获取该信号原来的处理方式</p>
<p>当参数<code>act</code>为<code>null</code>，<code>oldact</code>不为<code>null</code>时，这个函数可以用来只获取信号当前的处理方式</p>
<h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a>sigaction结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	  <span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line">	  <span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>, struct siginfo *, <span class="keyword">void</span> *);</span><br><span class="line">	&#125; _u;</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">__signalfn_t</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__signalfn_t</span> __user *<span class="keyword">__sighandler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler	_u._sa_handler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_sigaction	_u._sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>可以看到，其中有一个联合，它是用来兼容旧版本函数的，当参数<code>sa_mask</code>中含有<code>SA_SIGINFO</code>的时候，回调的是<code>_sa_sigaction</code>函数，当没有这个参数时，回调的是<code>_sa_handler</code>这个旧版本函数</p>
<p><code>_sa_sigaction</code>函数相对于<code>_sa_handler</code>函数而言，多携带了一些信号信息，譬如说发送信号的进程<code>pid</code></p>
<p><code>_sa_handler</code>可以被赋值成<code>SIG_DFL</code>或<code>SIG_IGN</code>，它们分别对应着默认处理和忽略信号，需要注意的时，它们只是一个<code>int</code>值，是不能被直接调用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL	((__force __sighandler_t)0)	<span class="comment">/* default signal handling */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN	((__force __sighandler_t)1)	<span class="comment">/* ignore signal */</span></span></span><br></pre></td></tr></table></figure>

<p>这个结构体中的<code>sa_mask</code>域为一个信号集，表示当正在执行信号处理函数的时候，阻塞一些信号，只有这个信号处理完了，这些信号才会被处理</p>
<p>这个结构体中的<code>sa_flags</code>域，有如下一些标志：</p>
<ul>
<li><p><code>SA_NOCLDSTOP</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程暂停或恢复时，父进程不会收到<code>SIGCHLD</code>信号</p>
</li>
<li><p><code>SA_NOCLDWAIT</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程退出时，父进程不会收到<code>SIGCHLD</code>信号，子进程也不会成为僵尸进程</p>
</li>
<li><p><code>SA_NODEFER</code>：一般情况下，当信号处理函数运行时，内核将阻塞对应的信号。但是如果设置了<code>SA_NODEFER</code>标记，那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p><code>SA_ONSTACK</code>：表示使用一个备用栈，当发生栈溢出时，内核会发出<code>SIGILL</code>信号，如果此时在原来的栈上调用信号处理函数，也会发生栈溢出，导致死循环，此时就需要准备一个备用栈，在备用栈上处理信号</p>
</li>
<li><p><code>SA_RESETHAND</code>：表示设置的信号处理行为只生效一次，当触发我们设置的信号处理函数后，内核会将信号处理行为重置（<code>SA_ONESHOT</code>作用相同，但它是一个过时的，非标准的<code>flag</code>）</p>
</li>
<li><p><code>SA_RESTART</code>：当执行系统调用时，如果收到一个信号，系统默认将中断这个系统调用，转而执行信号处理函数，结束后让这个被中断的系统调用失败，设置了<code>SA_RESTART</code>标志后，当信号处理函数执行完后，会自动恢复执行这个被中断的系统调用</p>
</li>
<li><p><code>SA_SIGINFO</code>：设置这个标志后，会回调<code>_sa_sigaction</code>作为信号处理函数，会携带更多的信号信息</p>
</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/signal.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/signal.2.html</a></p>
<p>这个函数的作用是，设置下一次的信号处理函数（只生效一次），成功返回上一次设置的信号处理函数，失败返回<code>SIG_ERR</code></p>
<p>这个函数在新版本中实际上是通过<code>sigaction</code>函数实现的，推荐使用更加强大的<code>sigaction</code>函数</p>
<h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><p>信号有几种状态，首先是信号的<code>产生 (Genertion)</code>，而实际执行信号处理动作时，状态为<code>递达 (Delivery)</code>，信号在<code>产生</code>到<code>递达</code>中的状态被称为<code>未决 (Pending)</code></p>
<p>进程可以选择<code>阻塞 (Blocking)</code>某些信号，被<code>阻塞</code>的信号在产生后将保持在<code>未决</code>状态，直到进程解除对该信号的<code>阻塞</code>，才执行<code>递达</code>的动作</p>
<h3 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h3><p>我们可以用信号集函数改变当前进程的<code>信号屏蔽字（Signal Mask）</code>，控制信号的阻塞与否</p>
<h4 id="信号集设置函数"><a href="#信号集设置函数" class="headerlink" title="信号集设置函数"></a>信号集设置函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号集数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">sigset_t</span>;</span><br><span class="line"><span class="comment">//清空一个信号集（将这个sigset_t置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//填充满一个信号集（将这个sigset_t的每一位都置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigfillset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号添加到信号集中（将这个sigset_t的对应信号位置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigaddset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号从信号集中移除（将这个sigset_t的对应信号位置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigdelset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//判断一个信号是否在这个信号集中（判断这个sigset_t的对应信号位是否为1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigismember.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>这个函数通过指定的方法和信号集修改进程的信号屏蔽字，成功返回0，失败返回-1</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是获得当前进程的信号屏蔽字，将结果保存到传入的<code>set</code>中，成功返回0，失败返回-1</p>
<h1 id="信号原理"><a href="#信号原理" class="headerlink" title="信号原理"></a>信号原理</h1><p>我们已经了解了信号的产生和处理，现在我们可以具体的看看一个信号从产生到响应处理，它经历了什么，它的原理是什么</p>
<p>我们在简介中说过：信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟，该怎么理解这句话呢？</p>
<p>当我们对一个进程发送信号后，会将这个信号暂时存放到这个进程所对应的<code>task_struct</code>的<code>pending</code>队列中，此时，进程并不知道有新的信号过来了，这也就是异步的意思。那么进程什么时候才能得知并处理这个信号呢？有两个时机，一个是进程从内核态返回到用户态时，一个是进程从睡眠状态被唤醒。让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的，所以信号能很快的得到执行</p>
<p>下图为信号相关的一些结构</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84.png" alt="task_struct中的信号结构"></p>
<h2 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h2><p>我们以<code>kill</code>函数为例，看看信号是如何发送的，它被定义在<code>tools/include/nolibc/nolibc.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = sys_kill(pid, signal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		SET_ERRNO(-ret);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_syscall2(__NR_kill, pid, signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了系统调用，在<code>Linux</code>内核中，每个<code>syscall</code>都对应着唯一的系统调用号，<code>kill</code>函数的系统调用号为<code>__NR_kill</code>，它被定义在<code>tools/include/uapi/asm-generic/unistd.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/signal.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 129</span></span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>架构的机器上，<code>my_syscall2</code>是这样被定义的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_syscall2(num, arg1, arg2)                                          \</span></span><br><span class="line">(&#123;                                                                            \</span><br><span class="line">	<span class="keyword">long</span> _ret;                                                            \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _num  <span class="keyword">asm</span>(<span class="string">"rax"</span>) = (num);                               \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg1 <span class="keyword">asm</span>(<span class="string">"rdi"</span>) = (<span class="keyword">long</span>)(arg1);                        \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg2 <span class="keyword">asm</span>(<span class="string">"rsi"</span>) = (<span class="keyword">long</span>)(arg2);                        \</span><br><span class="line">									      \</span><br><span class="line">	<span class="keyword">asm</span> <span class="keyword">volatile</span> (                                                        \</span><br><span class="line">		<span class="string">"syscall\n"</span>                                                   \</span><br><span class="line">		: <span class="string">"=a"</span>(_ret)                                                  \</span><br><span class="line">		: <span class="string">"r"</span>(_arg1), <span class="string">"r"</span>(_arg2),                                     \</span><br><span class="line">		  <span class="string">"0"</span>(_num)                                                   \</span><br><span class="line">		: <span class="string">"rcx"</span>, <span class="string">"r11"</span>, <span class="string">"memory"</span>, <span class="string">"cc"</span>                                \</span><br><span class="line">	);                                                                    \</span><br><span class="line">	_ret;                                                                 \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里涉及到了扩展内联汇编，<code>syscall</code>指令需要一个系统调用号和一些参数，在<code>x86_64</code>架构中，系统调用号需要存放在<code>rax</code>寄存器中，参数依次存放在<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code>, <code>r9</code>寄存器中，执行<code>syscall</code>指令后，内核会通过系统调用号去从系统调用表找到对应函数的入口</p>
<p>我们之前在找系统调用号<code>__NR_kill</code>的时候可以发现，上面标了注释，表明这个函数的实现在<code>kernel/signal.c</code>中，但我们在这个文件中并没有找到<code>sys_kill</code>这个函数，实际上这里隐藏了一个宏定义</p>
<p>在<code>include/linux/syscalls.h</code>中，我们可以找到这样一些宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SYSCALL_DEFINE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE0(sname)					\</span></span><br><span class="line">	SYSCALL_METADATA(_##sname, <span class="number">0</span>);				\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void);			\</span></span><br><span class="line">	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);		\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SYSCALL_DEFINE0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE_MAXARGS	6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span><br><span class="line">	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The asmlinkage stub is aliased to a function named __se_sys_*() which</span></span><br><span class="line"><span class="comment"> * sign-extends 32-bit ints to longs whenever needed. The actual work is</span></span><br><span class="line"><span class="comment"> * done within __do_sys_*().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL_DEFINEx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line">	__diag_push();							\</span><br><span class="line">	__diag_ignore(GCC, <span class="number">8</span>, <span class="string">"-Wattribute-alias"</span>,			\</span><br><span class="line">		      <span class="string">"Type aliasing is used to sanitize syscall arguments"</span>);\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line">		__attribute__((alias(__stringify(__se_sys##name))));	\</span><br><span class="line">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line">	&#123;								\</span><br><span class="line">		<span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span><br><span class="line">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span><br><span class="line">		<span class="keyword">return</span> ret;						\</span><br><span class="line">	&#125;								\</span><br><span class="line">	__diag_pop();							\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SYSCALL_DEFINEx */</span></span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINEx</code>中的<code>x</code>表示接受<code>x</code>个参数，这个宏定义根据传入的<code>name</code>参数，以<code>sys_name</code>为名定义了一个函数，也就是说<code>SYSCALL_DEFINE2(kill, ...)</code>这个宏展开后基本相当于<code>sys_kill</code>函数，在<code>kernel/signal.c</code>中我们可以找到这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    prepare_kill_siginfo(sig, &amp;info);</span><br><span class="line">    <span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是<code>kill</code>函数的真正实现，我们这里主要关注信号的发送，就屏蔽一些细节，只看发送部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//这里我们就只看对一个进程发送信号</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> kill_proc_info(sig, info, pid);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_proc_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill_pid_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取pid对应进程的task_struct</span></span><br><span class="line">        p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            <span class="comment">//PIDTYPE_TGID表示类型是线程组id，对于同一进程中的所有线程，tgid都是一致的，为该进程的进程id</span></span><br><span class="line">            group_send_sig_info(sig, info, p, PIDTYPE_TGID);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">        ret = do_send_sig_info(sig, info, p, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    send_signal(sig, info, p, type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">send_signal</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> __send_signal(sig, info, t, type, force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span><br><span class="line">            <span class="keyword">enum</span> pid_type type, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> override_rlimit;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_IGNORED;</span><br><span class="line">    <span class="comment">//判断是否可以忽略信号</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_signal(sig, t, force))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择信号pending队列</span></span><br><span class="line">    <span class="comment">//线程组共享队列(t-&gt;signal-&gt;shared_pending) 或 进程私有队列(t-&gt;pending)</span></span><br><span class="line">    pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">    </span><br><span class="line">    result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line">    <span class="comment">//如果该信号是不可靠信号，且已经在padding队列中，则忽略这个信号</span></span><br><span class="line">    <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对SIGKILL信号和内核进程跳过信号的pending</span></span><br><span class="line">    <span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">        <span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实时信号可以突破队列大小限制，否则丢弃信号</span></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新分配一个sigqueue，并将其加入pending队尾</span></span><br><span class="line">    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_USER;</span><br><span class="line">            q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">                            task_active_pid_ns(t));</span><br><span class="line">            rcu_read_lock();</span><br><span class="line">            q-&gt;info.si_uid =</span><br><span class="line">                from_kuid_munged(task_cred_xxx(t, user_ns),</span><br><span class="line">                         current_uid());</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">            q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info) &amp;&amp;</span><br><span class="line">           sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">    signalfd_notify(t, sig);</span><br><span class="line">    sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//唤醒进程</span></span><br><span class="line">    complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里我们可以看出来，和我们之前说的原理是一样的，新分配了一个<code>sigqueue</code>，并将其加入到对应进程<code>task_struct</code>的<code>pending</code>队列队尾</p>
<h2 id="设置信号处理"><a href="#设置信号处理" class="headerlink" title="设置信号处理"></a>设置信号处理</h2><p>之前我们介绍了怎么自定义信号处理行为，如何设置信号屏蔽字，实际上都能在进程的<code>task_struct</code>中体现出来，信号处理行为保存在其中的<code>sighand</code>域中，而信号屏蔽字保存在其中的<code>blocked</code>域中</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E5%9F%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="task_struct"></p>
<h2 id="信号的响应"><a href="#信号的响应" class="headerlink" title="信号的响应"></a>信号的响应</h2><p><code>x86_64</code>架构系统调用会经历<code>do_syscall_64</code>这么一个函数，它被实现在<code>arch/x86/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__visible noinstr <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(struct pt_regs *regs, <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_random_kstack_offset();</span><br><span class="line">    nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">    instrumentation_begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Invalid system call, but still a system call. */</span></span><br><span class="line">        regs-&gt;ax = __x64_sys_ni_syscall(regs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instrumentation_end();</span><br><span class="line">    syscall_exit_to_user_mode(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码我们可以看出来，当进程从内核空间返回用户空间时，会调用<code>syscall_exit_to_user_mode</code>函数</p>
<p>最终经历一系列调用，会走到<code>exit_to_user_mode_loop</code>函数中，它们被定义在<code>kernel/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">exit_to_user_mode_loop</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">long</span> ti_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ti_work &amp; EXIT_TO_USER_MODE_WORK) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))</span><br><span class="line">            handle_signal_work(regs, ti_work);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ti_work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果当前线程包含<code>_TIF_SIGPENDING</code>或<code>_TIF_NOTIFY_SIGNAL</code>，表明该线程可能有信号需要处理，会调用到<code>handle_signal_work</code>函数处理，接着调用到<code>arch_do_signal_or_restart</code>函数中，它被实现在<code>arch/x86/kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//has_signal的值为 (ti_work &amp; _TIF_SIGPENDING)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_do_signal_or_restart</span><span class="params">(struct pt_regs *regs, <span class="keyword">bool</span> has_signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_signal &amp;&amp; get_signal(&amp;ksig)) &#123;</span><br><span class="line">        handle_signal(&amp;ksig, regs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果该进程没有对这个信号设置处理程序，这里会自动重启这个系统调用</span></span><br><span class="line">    <span class="comment">/* Did we come from a system call? */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall_get_nr(current, regs) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Restart the system call - no handlers present */</span></span><br><span class="line">        <span class="keyword">switch</span> (syscall_get_error(current, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">            regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">            regs-&gt;ax = get_nr_restart_syscall(regs);</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    restore_saved_sigmask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中的<code>if</code>语句体，看上去是如果有信号，则处理这个信号，其实不完全是这样的。如果该进程没有对这个信号设置处理程序，则会执行默认的信号处理，这里的处理过程是在<code>get_signal</code>中完成的，我当时在看这块源码的时候还在疑惑为什么找不到信号默认处理的地方，结果是这个函数的名字误导了我。如果该进程没有对这个信号设置处理程序，则会自动重启这个系统调用，这里就不展开说了，我们首先看一下<code>get_signal</code>函数是怎么实现的，它被实现在<code>kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line">    <span class="keyword">int</span> signr;</span><br><span class="line">    ...</span><br><span class="line">relock:</span><br><span class="line">    spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果子进程的状态发生变化，发送SIGCHLD信号给父进程</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line">        <span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">            why = CLD_CONTINUED;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">        signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">        read_lock(&amp;tasklist_lock);</span><br><span class="line">        do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">            do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line">                        <span class="literal">true</span>, why);</span><br><span class="line">        read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> relock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line">        <span class="keyword">enum</span> pid_type type;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从进程task_struct的pending队列中取出一个信号</span></span><br><span class="line">        type = PIDTYPE_PID;</span><br><span class="line">        signr = dequeue_synchronous_signal(&amp;ksig-&gt;info);</span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            signr = dequeue_signal(current, &amp;current-&gt;blocked,</span><br><span class="line">                           &amp;ksig-&gt;info, &amp;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从信号处理数组中，取出对应信号的处理动作</span></span><br><span class="line">        ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">            <span class="comment">/* Run the handler.  */</span></span><br><span class="line">            ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果设置了SA_RESETHAND或者SA_ONESHOT标志（这俩标志的值是一样的），将其信号处理函数重设为默认</span></span><br><span class="line">            <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">                ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面为默认信号处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//部分信号的默认动作为忽略（具体可以查看SIG_KERNEL_IGNORE_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//部分信号的默认动作为停止进程（具体可以查看SIG_KERNEL_STOP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">                spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前为孤儿进程组</span></span><br><span class="line">                <span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line">                    <span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">                spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认动作为停止当前线程组里的所有线程</span></span><br><span class="line">            <span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> relock;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fatal:</span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">        ...</span><br><span class="line">        current-&gt;flags |= PF_SIGNALED;</span><br><span class="line">        <span class="comment">//部分信号的默认动作为dump core，然后终止进程（具体可以查看SIG_KERNEL_COREDUMP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">                print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">            proc_coredump_connector(current);</span><br><span class="line">            do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_IO_WORKER)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩下来的信号的默认操作为终止进程</span></span><br><span class="line">        do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">out:</span><br><span class="line">    ksig-&gt;sig = signr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_EXPOSE_TAGBITS))</span><br><span class="line">        hide_si_addr_tag_bits(ksig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当当前进程对此信号设置了自定义信号处理动作后，返回true</span></span><br><span class="line">    <span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="likely-amp-unlikely"><a href="#likely-amp-unlikely" class="headerlink" title="likely &amp; unlikely"></a>likely &amp; unlikely</h3><p>这里的<code>likely</code>和<code>unlikely</code>为两个宏，指向<code>__builtin_expect</code>函数，是<code>gcc</code>编译器提供给程序员优化的一种方式，<code>likely</code>表示表达式为真的可能性更大，<code>unlikely</code>表示表达式为假的可能性更大，这样<code>gcc</code>编译器可以在编译过程中，将可能性更大的代码紧跟前面的代码，减少指令跳转带来的性能开销</p>
<hr>
<p>我们接着看，当用户自定义了信号处理函数后，内核是怎么处理的。从上面的代码看来，当用户自定义了信号处理函数，<code>get_signal</code>函数会返回<code>true</code>，紧接着就会进入到<code>handle_signal</code>函数中，这里的处理比较特殊，我们要先了解信号处理的一些过程</p>
<p>用户自定义信号处理函数实际上是在用户空间执行的，目的是为了防止用户利用内核空间的<code>ring 0</code>特权等级做一些意想不到的事，处理过程如下两图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="信号处理过程"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B2.png" alt="信号处理过程"></p>
<p>整个过程如图中所见，进程由于系统调用或中断进入内核空间，在内核空间完成工作后返回用户空间的前夕，检查信号队列，如果检查有信号并且有自定义的信号处理函数，返回到用户空间执行信号处理函数，处理完后再返回内核空间，最后再回到用户空间之前代码执行到的地方继续运行</p>
<p>可以看到，这一套流程经历了4次用户态与内核态的切换，比较复杂，那么内核是如何做到的呢？为什么信号处理函数执行完后还要返回内核空间呢？</p>
<h3 id="用户态与内核态的切换"><a href="#用户态与内核态的切换" class="headerlink" title="用户态与内核态的切换"></a>用户态与内核态的切换</h3><p>在<code>Linux</code>中，在用户态和内核态运行的进程使用的是不同的栈，分别为用户栈和内核栈，当一个进程陷入内核态时，需要将用户栈的信息保存到内核栈中，具体的，会将<code>ss</code>, <code>sp</code>, <code>flags</code>, <code>cs</code>, <code>ip</code>等值依次压入栈中，保存为<code>pt_regs</code>结构，然后设置CPU堆栈寄存器的地址为内核栈顶，这样，后续使用的栈便变成了内核栈，当系统调用结束，需要从内核态切换到用户态时，再将之前压入栈中的寄存器值弹出，将<code>pt_regs</code>中保存的值恢复到相应的寄存器中，这里改变了<code>sp</code>寄存器的值，即完成了换栈，<code>cs:ip</code>这两个寄存器分别指向用户态代码段以及用户态指令指针，后续CPU便会执行之前用户态的代码了</p>
<h4 id="pt-regs结构体"><a href="#pt-regs结构体" class="headerlink" title="pt_regs结构体"></a>pt_regs结构体</h4><p><code>pt_regs</code>结构体位于<code>arch/x86/include/asm/ptrace.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从理论角度上大概理解了内核是怎么在用户态与内核态之间切换的，接下来我们去源码里验证一下是不是我们所想的这样，<code>syscall</code>的入口函数为<code>entry_SYSCALL_64</code>，位于<code>arch/x86/entry/entry_64.S</code>中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line">    </span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至内核态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* tss<span class="number">.</span>sp2为用户栈 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">    /* 切换至内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">    /* 保存用户栈寄存器值至pt_regs结构中 */</span><br><span class="line">    pushq	$__USER_DS				/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">    pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将rflags的值保存在<span class="built_in">r11</span>寄存器中 */</span><br><span class="line">    pushq	%r11					/* pt_regs-&gt;flags */</span><br><span class="line">    pushq	$__USER_CS				/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将<span class="keyword">syscall</span>指令的下一条指令的地址传给<span class="built_in">rcx</span>寄存器 */</span><br><span class="line">    pushq	%rcx					/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">    pushq	%rax					/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">    /* 保存并清除寄存器 */</span><br><span class="line">    PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line">    /* 此时，<span class="built_in">rsp</span>指向的栈顶地址即为pt_regs的地址 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 设置系统调用号 */</span><br><span class="line">    movslq	%eax, %rsi</span><br><span class="line">    /* 以<span class="built_in">rdi</span>, <span class="built_in">rsi</span>作为参数，调用do_syscall_64函数 */</span><br><span class="line">    <span class="keyword">call</span>	do_syscall_64		/* returns with IRQs disabled */</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cmpq	%rcx, %r11</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_CS, <span class="built_in">CS</span>(%rsp)		/* <span class="built_in">CS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	<span class="built_in">R11</span>(%rsp), %r11</span><br><span class="line">    cmpq	%r11, EFLAGS(%rsp)		/* <span class="built_in">R11</span> == RFLAGS */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">    <span class="keyword">jnz</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_DS, <span class="built_in">SS</span>(%rsp)		/* <span class="built_in">SS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这个标签实际上只是为了便于理解，并没有地方跳转它</span><br><span class="line">     * 实际工作是在swapgs_restore_regs_and_return_to_usermode中完成的</span><br><span class="line">     */</span><br><span class="line"><span class="symbol">syscall_return_via_sysret:</span></span><br><span class="line">    /* 恢复寄存器 */</span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 保存内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">    pushq	<span class="built_in">RSP</span>-<span class="built_in">RDI</span>(%rdi)	/* <span class="built_in">RSP</span> */</span><br><span class="line">    pushq	(%rdi)		/* <span class="built_in">RDI</span> */</span><br><span class="line"></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    popq	%rdi</span><br><span class="line">    popq	%rsp</span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至用户态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* 恢复<span class="built_in">rip</span>, rflags等寄存器，使<span class="meta">cpu</span>接下来要执行指令指向<span class="keyword">syscall</span>的下一条指令 */</span><br><span class="line">    sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<h3 id="信号处理函数的跳转方式"><a href="#信号处理函数的跳转方式" class="headerlink" title="信号处理函数的跳转方式"></a>信号处理函数的跳转方式</h3><p>但是在系统调用完后，回到的将是syscall后的下一条指令，那么如何才能让程序去执行信号处理函数呢？信号处理函数执行完后，又如何回到之前所执行到的代码呢？我们很容易就能想到，先将<code>pt_regs</code>中的值备份一下，然后改变<code>pt_regs</code>中一些寄存器值，比如说将<code>cs:ip</code>修改成信号处理函数对应地址，这样从内核态返回后，就会自动跳转到信号处理函数了，等到信号处理函数执行完，再进入内核态，恢复<code>pt_regs</code>中的值后回到用户态，这样<code>cpu</code>又会从用户调用<code>syscall</code>后的指令开始正常执行了</p>
<p>我们具体的看一下内核代码是怎么做的，这里的逻辑在<code>arch/x86/kernel/signal.c</code>中的<code>handle_signal</code>函数里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    failed = (setup_rt_frame(ksig, regs) &lt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    signal_setup_done(failed, ksig, stepping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line">    <span class="keyword">sigset_t</span> *<span class="built_in">set</span> = sigmask_to_save();</span><br><span class="line">    <span class="keyword">compat_sigset_t</span> *cset = (<span class="keyword">compat_sigset_t</span> *) <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform fixup for the pre-signal frame. */</span></span><br><span class="line">    rseq_signal_deliver(ksig, regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置栈帧</span></span><br><span class="line">    <span class="keyword">if</span> (is_ia32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)</span><br><span class="line">            <span class="keyword">return</span> ia32_setup_rt_frame(usig, ksig, cset, regs);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ia32_setup_frame(usig, ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_x32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> x32_setup_rt_frame(ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> __setup_rt_frame(ksig-&gt;sig, ksig, <span class="built_in">set</span>, regs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x86_64执行的应该是这个函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __setup_rt_frame(<span class="keyword">int</span> sig, struct ksignal *ksig,</span><br><span class="line">                <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* x86-64 should always use SA_RESTORER. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个栈帧</span></span><br><span class="line">    frame = get_sigframe(&amp;ksig-&gt;ka, regs, <span class="keyword">sizeof</span>(struct rt_sigframe), &amp;fp);</span><br><span class="line">    uc_flags = frame_uc_flags(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user_access_begin(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the ucontext.  */</span></span><br><span class="line">    unsafe_put_user(uc_flags, &amp;frame-&gt;uc.uc_flags, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;frame-&gt;uc.uc_link, Efault);</span><br><span class="line">    unsafe_save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up to return from userspace.  If provided, use a stub</span></span><br><span class="line"><span class="comment">       already in userspace.  */</span></span><br><span class="line">    <span class="comment">//设置执行完信号处理函数后，要跳回的地址，即sa_restorer</span></span><br><span class="line">    unsafe_put_user(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode, Efault);</span><br><span class="line">    <span class="comment">//将原本的pt_regs备份保存至frame.uc.uc_mcontext中</span></span><br><span class="line">    unsafe_put_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, <span class="built_in">set</span>, Efault);</span><br><span class="line">    unsafe_put_sigmask(<span class="built_in">set</span>, frame, Efault);</span><br><span class="line">    user_access_end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号处理函数的第1个参数</span></span><br><span class="line">    regs-&gt;di = sig;</span><br><span class="line">    <span class="comment">/* In case the signal handler was declared without prototypes */</span></span><br><span class="line">    regs-&gt;ax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置了SA_SIGINFO标志位，需要带一些额外的信号信息 */</span></span><br><span class="line">    <span class="comment">//信号处理函数的第2个参数</span></span><br><span class="line">    regs-&gt;si = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;info;</span><br><span class="line">    <span class="comment">//信号处理函数的第3个参数</span></span><br><span class="line">    regs-&gt;dx = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;uc;</span><br><span class="line">    <span class="comment">//设置指令指针指向信号处理函数</span></span><br><span class="line">    <span class="comment">//sigaction结构体中的第一个域是一个联合，所以这里</span></span><br><span class="line">    <span class="comment">//sa_handler和sa_sigaction的地址是相同的</span></span><br><span class="line">    regs-&gt;ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ksig-&gt;ka.sa.sa_handler;</span><br><span class="line">    <span class="comment">//设置栈顶地址</span></span><br><span class="line">    regs-&gt;sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)frame;</span><br><span class="line">    <span class="comment">//设置用户代码段</span></span><br><span class="line">    regs-&gt;cs = __USER_CS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(regs-&gt;ss != __USER_DS))</span><br><span class="line">        force_valid_ss(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Efault:</span><br><span class="line">    user_access_end();</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsafe_put_sigcontext(sc, fp, regs, set, label)			\</span></span><br><span class="line"><span class="keyword">do</span> &#123;									\</span><br><span class="line">    <span class="keyword">if</span> (__unsafe_setup_sigcontext(sc, fp, regs, <span class="built_in">set</span>-&gt;sig[<span class="number">0</span>]))	\</span><br><span class="line">        <span class="keyword">goto</span> label;						\</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span><br><span class="line">__unsafe_setup_sigcontext(struct sigcontext __user *sc, <span class="keyword">void</span> __user *fpstate,</span><br><span class="line">             struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> mask)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(regs-&gt;di, &amp;sc-&gt;di, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;si, &amp;sc-&gt;si, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bp, &amp;sc-&gt;bp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;sp, &amp;sc-&gt;sp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bx, &amp;sc-&gt;bx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;dx, &amp;sc-&gt;dx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cx, &amp;sc-&gt;cx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ax, &amp;sc-&gt;ax, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;r8, &amp;sc-&gt;r8, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r9, &amp;sc-&gt;r9, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r10, &amp;sc-&gt;r10, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r11, &amp;sc-&gt;r11, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r12, &amp;sc-&gt;r12, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r13, &amp;sc-&gt;r13, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r14, &amp;sc-&gt;r14, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r15, &amp;sc-&gt;r15, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(current-&gt;thread.trap_nr, &amp;sc-&gt;trapno, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.error_code, &amp;sc-&gt;err, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ip, &amp;sc-&gt;ip, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;flags, &amp;sc-&gt;flags, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cs, &amp;sc-&gt;cs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;gs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;fs, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ss, &amp;sc-&gt;ss, Efault);</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(fpstate, (<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *)&amp;sc-&gt;fpstate, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-iBCS2 extensions.. */</span></span><br><span class="line">    unsafe_put_user(mask, &amp;sc-&gt;oldmask, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2, Efault);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Efault:</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际上是这么做的，首先，内核默认在用户栈上分配了一个栈帧（如果设置了备用栈的话，则会在备用栈上分配），将<code>pt_regs</code>备份到这个栈帧上，用于后续恢复，然后设置<code>pt_regs</code>，改变其<code>sp</code>, <code>cs</code>, <code>ip</code>等值，使程序从内核态返回时，可以跳转到信号处理函数对应的栈和代码指令地址，当信号处理函数返回时会执行<code>sigreturn</code>系统调用再进入内核态，将之前备份到栈帧中的寄存器值重新恢复到<code>pt_regs</code>中，然后再从内核态回到用户态就可以正常继续执行<code>syscall</code>后面的代码了</p>
<p>其中<code>sa_restorer</code>是在<code>glibc</code>里的<code>__libc_sigaction</code>函数中被设置的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_sigaction (<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_sigaction</span> <span class="title">kact</span>, <span class="title">koact</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (act)</span><br><span class="line">    &#123;</span><br><span class="line">        kact.k_sa_handler = act-&gt;sa_handler;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;kact.sa_mask, &amp;act-&gt;sa_mask, <span class="keyword">sizeof</span> (<span class="keyword">sigset_t</span>));</span><br><span class="line">        kact.sa_flags = act-&gt;sa_flags;</span><br><span class="line">        <span class="comment">//设置sa_restorer</span></span><br><span class="line">        SET_SA_RESTORER (&amp;kact, act);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">restore_rt</span> <span class="params">(<span class="keyword">void</span>)</span> <span class="title">asm</span> <span class="params">(<span class="string">"__restore_rt"</span>)</span> attribute_hidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SA_RESTORER(kact, act)			\</span></span><br><span class="line">    (kact)-&gt;sa_flags = (act)-&gt;sa_flags | SA_RESTORER;	\</span><br><span class="line">    (kact)-&gt;sa_restorer = &amp;restore_rt</span><br><span class="line">    </span><br><span class="line">RESTORE (restore_rt, __NR_rt_sigreturn)</span><br><span class="line"></span><br><span class="line">#define RESTORE(name, syscall) RESTORE2 (name, syscall)</span><br><span class="line">#define RESTORE2(name, syscall) \</span><br><span class="line"><span class="keyword">asm</span>									\</span><br><span class="line">  (									\</span><br><span class="line">   <span class="comment">/* `nop' for debuggers assuming `call' should not disalign the code.  */</span> \</span><br><span class="line">   <span class="string">"	nop\n"</span>								\</span><br><span class="line">   <span class="string">".align 16\n"</span>							\</span><br><span class="line">   <span class="string">".LSTART_"</span> #name <span class="string">":\n"</span>						\</span><br><span class="line">   <span class="string">"	.type __"</span> #name <span class="string">",@function\n"</span>					\</span><br><span class="line">   <span class="string">"__"</span> #name <span class="string">":\n"</span>							\</span><br><span class="line">   <span class="string">"	movq $"</span> #syscall <span class="string">", %rax\n"</span>					\</span><br><span class="line">   <span class="string">"	syscall\n"</span>							\</span><br><span class="line">   ...</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>可以看到，这里也是一个系统调用，和上面所说的规则一样，它最终会调用<code>sys_rt_sigreturn</code>函数，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(rt_sigreturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> = <span class="title">current_pt_regs</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    frame = (struct rt_sigframe __user *)(regs-&gt;sp - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(*(__u64 *)&amp;<span class="built_in">set</span>, (__u64 __user *)&amp;frame-&gt;uc.uc_sigmask))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    set_current_blocked(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame.uc.uc_mcontext中恢复pt_regs</span></span><br><span class="line">    <span class="keyword">if</span> (!restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (restore_altstack(&amp;frame-&gt;uc.uc_stack))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ax;</span><br><span class="line"></span><br><span class="line">badframe:</span><br><span class="line">    signal_fault(regs, frame, <span class="string">"rt_sigreturn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">restore_sigcontext</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct sigcontext __user *usc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">sc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always make any pending restarted system calls return -EINTR */</span></span><br><span class="line">    current-&gt;restart_block.fn = do_no_restart_syscall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;sc, usc, CONTEXT_COPY_SIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;bx = sc.bx;</span><br><span class="line">    regs-&gt;cx = sc.cx;</span><br><span class="line">    regs-&gt;dx = sc.dx;</span><br><span class="line">    regs-&gt;si = sc.si;</span><br><span class="line">    regs-&gt;di = sc.di;</span><br><span class="line">    regs-&gt;bp = sc.bp;</span><br><span class="line">    regs-&gt;ax = sc.ax;</span><br><span class="line">    regs-&gt;sp = sc.sp;</span><br><span class="line">    regs-&gt;ip = sc.ip;</span><br><span class="line"></span><br><span class="line">    regs-&gt;r8 = sc.r8;</span><br><span class="line">    regs-&gt;r9 = sc.r9;</span><br><span class="line">    regs-&gt;r10 = sc.r10;</span><br><span class="line">    regs-&gt;r11 = sc.r11;</span><br><span class="line">    regs-&gt;r12 = sc.r12;</span><br><span class="line">    regs-&gt;r13 = sc.r13;</span><br><span class="line">    regs-&gt;r14 = sc.r14;</span><br><span class="line">    regs-&gt;r15 = sc.r15;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get CS/SS and force CPL3 */</span></span><br><span class="line">    regs-&gt;cs = sc.cs | <span class="number">0x03</span>;</span><br><span class="line">    regs-&gt;ss = sc.ss | <span class="number">0x03</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (sc.flags &amp; FIX_EFLAGS);</span><br><span class="line">    <span class="comment">/* disable syscall checks */</span></span><br><span class="line">    regs-&gt;orig_ax = <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fpu__restore_sig((<span class="keyword">void</span> __user *)sc.fpstate,</span><br><span class="line">                   IS_ENABLED(CONFIG_X86_32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码还是可以比较清楚的看出来，和我们之前描述的原理基本一致，到这一步时，恢复<code>pt_regs</code>中的值，这样后续返回用户态后便可以正常继续运行后面的用户代码了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Linux</code>信号的原理分析到这基本上也就结束了，其实整个信号原理分析对现阶段的我来说，还是一件相当具有挑战性的事情，不过在此过程中，还是收获了很多知识，也发现了一些之前文章里错漏的地方，由于我对<code>Linux</code>内核以及汇编并不熟悉，所以难免会有一些分析错误或者不到位的地方，欢迎大家指正</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h2><p>取值 | 名称        | 解释               | 默认动作        |<br>| – | ——— | —————- | ———– |<br>| 1  | SIGHUP    | 挂起               | 终止进程    |<br>| 2  | SIGINT    | 中断               | 终止进程    |<br>| 4  | SIGILL    | 非法指令             | coredump后终止进程 |<br>| 5  | SIGTRAP   | 断点或陷阱指令          | coredump后终止进程 |<br>| 6  | SIGABRT/SIGIOT   | abort发出的信号  | coredump后终止进程 |<br>| 7  | SIGBUS    | 非法内存访问           | coredump后终止进程 |<br>| 8  | SIGFPE    | 浮点异常             | coredump后终止进程 |<br>| 9  | SIGKILL   | kill信号           | 不能被忽略、处理和阻塞 |<br>| 10 | SIGUSR1   | 用户自定义信号1            | 终止进程 |<br>| 11 | SIGSEGV   | 无效内存访问           | coredump后终止进程 |<br>| 12 | SIGUSR2   | 用户自定义信号2            | 终止进程 |<br>| 13 | SIGPIPE   | 管道破损，没有读端的管道写数据  | 终止进程 |<br>| 14 | SIGALRM   | alarm发出的信号       | 终止进程 |<br>| 15 | SIGTERM   | 终止信号             | 终止进程 |<br>| 16 | SIGSTKFLT | 栈溢出              | 终止进程 |<br>| 17 | SIGCHLD   | 子进程退出            | 忽略信号 |<br>| 18 | SIGCONT   | 进程继续             | 忽略信号 |<br>| 19 | SIGSTOP   | 进程停止             | 不能被忽略、处理和阻塞 |<br>| 20 | SIGTSTP   | 进程停止             | 停止进程 |<br>| 21 | SIGTTIN   | 进程停止，后台进程从终端读数据时 | 停止进程 |<br>| 22 | SIGTTOU   | 进程停止，后台进程想终端写数据时 | 停止进程 |<br>| 23 | SIGURG    | I/O有紧急数据到达当前进程   | 忽略信号 |<br>| 24 | SIGXCPU   | 进程的CPU时间片到期      | coredump后终止进程 |<br>| 25 | SIGXFSZ   | 文件大小的超出上限        | coredump后终止进程 |<br>| 26 | SIGVTALRM | 虚拟时钟超时           | 终止进程 |<br>| 27 | SIGPROF   | profile时钟超时      | 终止进程 |<br>| 28 | SIGWINCH  | 窗口大小改变           | 忽略信号 |<br>| 29 | SIGPOLL/SIGIO     | I/O相关            | 终止进程 |<br>| 30 | SIGPWR    | 关机               | 默认忽略        |<br>| 31 | SIGSYS/SIGUNUSED    | 系统调用异常 | coredump后终止进程 |</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://tianyu-code.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E4%BF%A1%E5%8F%B7/" target="_blank" rel="noopener">Linux信号</a></li>
<li><a href="https://docs.huihoo.com/c/linux-c-programming/ch33s03.html" target="_blank" rel="noopener">阻塞信号</a></li>
<li><a href="https://kernel.meizu.com/linux-signal.html" target="_blank" rel="noopener">Linux Signal</a></li>
<li><a href="http://gityuan.com/2015/12/20/signal/" target="_blank" rel="noopener">Linux信号(signal)机制</a></li>
<li><a href="https://oilbeater.com/linux/2012/05/09/linux-signal.html" target="_blank" rel="noopener">linux 信号处理机制简介</a></li>
<li><a href="https://wenfh2020.com/2021/09/05/kernel-syscall/" target="_blank" rel="noopener">[内核源码] Linux 系统调用（x86_64）</a></li>
<li><a href="https://ty-chen.github.io/linux-kernel-signal/" target="_blank" rel="noopener">Linux操作系统学习笔记（十六）进程间通信之信号</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117794217" target="_blank" rel="noopener">X86_64处理器系统调用机制在linux上的实现</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117929007" target="_blank" rel="noopener">linux kernel signal机制（X86_64）</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/">B站Android面试小记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>看着我同学最近也在到处投简历，我想着我也投一下看看行情，于是在<strong>2022-02-28</strong>号，我向B站投出了第一封简历，说实话当初只是想练练手，没想到最后接了B站的offer，也是造化弄人了</p>
<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>技术面，45min左右，基本围绕你简历上写的亮点和你的工作经历展开</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>你在项目中负责什么</p>
</li>
<li><p>用过什么设计模式，或在<code>Android</code>中常常会碰见的设计模式</p>
<p>  单例模式，策略模式，责任链模式（问了一下使用场景），工厂模式等</p>
<p>  <code>Android</code>中的观察者模式，适配器模式等</p>
</li>
<li><p>有没有做过什么比较有难度的模块</p>
<p>  <code>camera2</code>，自定义照片裁剪<code>View</code></p>
</li>
<li><p>你对自定义<code>View</code>有什么了解</p>
<p>  回答了一些<code>Path</code>绘制以及触摸事件的处理</p>
</li>
<li><p><code>Android</code>动画</p>
<p>  属性动画，<code>ObjectAnimator</code></p>
</li>
<li><p>多线程并发（锁、信号量、<code>syncnorized</code>），<code>syncnorized</code>对象和class有什么区别</p>
</li>
<li><p><code>ConcurrentHashMap</code>线程安全的原理</p>
<p>  1.8之前用的分段式锁，1.8之后用的<code>synchronized</code>，至于具体的细节没有答上来，因为确实也没看过这边源码</p>
</li>
<li><p><code>jni</code>，如何定位<code>jni</code>崩溃</p>
<p>  这个我当时回答的是打log，因为项目中用到<code>jni</code>的地方确实不多，当然<code>jni</code>也是可以断点调试的</p>
</li>
<li><p>你所开发的应用有多进程吗？进程间是怎么通信的</p>
<p>  这个我当时只回答了<code>mmap</code>，稍微聊了一下<code>mmap</code>原理和<code>binder</code>性能对比，后来复盘想起来项目中用到的<code>Broadcast</code>和<code>aidl binder</code>通信都没有回答</p>
</li>
<li><p><code>Webview</code>和<code>native</code>怎么交互的</p>
<ul>
<li><p><code>onUrlLoading</code>拦截<code>Schema</code></p>
</li>
<li><p>注册js方法（<code>addJavascriptInterface</code>）</p>
</li>
</ul>
</li>
<li><p><code>Android</code>编译打包过程</p>
<p>  aapt -&gt; class -&gt; dex -&gt; 签名</p>
</li>
<li><p>插桩</p>
<p>  ASM插桩，字节码操作</p>
</li>
<li><p>性能监控</p>
<p>  因为我之前做过一个性能监控库，<code>cpu</code>和<code>mem</code>使用<code>TOP</code>命令解析，<code>Anr</code>通过给<code>MainLooper</code>设置<code>Printer</code></p>
</li>
<li><p><code>LeakCanary</code>原理</p>
<p>  <code>WeakReference</code> + <code>ReferenceQueue</code>，加了一些改进点：<code>new</code>一个弱引用的<code>Object</code>，等这个<code>Object</code>确认被回收后再确认<code>Activity</code>是否正常被回收</p>
</li>
<li><p><code>Jetpack Compose</code></p>
<p>  稍微谈了一下看法，是否在项目中用过</p>
</li>
<li><p>算法题：最长公共前缀</p>
<p>  LeetCode 14题，easy难度：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
</li>
</ul>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>一面结束后5min左右，B站HR就给我打电话过来约了二面</p>
<p>二面也是技术面，20min左右，因为是晚上8点面的，估计人家急着想下班（笑）</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>工作职责</p>
</li>
<li><p>工作中有什么亮点</p>
<ul>
<li><p>拍照裁剪业务</p>
</li>
<li><p>单元测试库</p>
</li>
<li><p>性能监控</p>
</li>
<li><p>内存泄漏检测</p>
</li>
</ul>
</li>
<li><p>单元测试的库是怎么做的</p>
<p>  基于<code>Mockito</code>和<code>Robolectric</code>:</p>
<ol>
<li>封装了一个反射库用来方便测试</li>
<li>做了一个<code>AutoCloser</code>类用来自动关闭释放mock的资源，这里提到了使用<code>MockedStatic</code>，如果在使用完后没有释放，那在下一次使用到同一个类的<code>MockedStatic</code>的时候会报错，这里我自定义了一个注解<code>@MockedStatic</code>用来自动mock和释放资源</li>
<li>针对kotlin做了一些mock工具，比如说顶层函数的mock（这个在我以前的文章<a href="https://juejin.cn/post/6932738373522030600" target="_blank" rel="noopener">Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数</a>中介绍过）</li>
</ol>
</li>
<li><p>开发模式（流程规范）：</p>
<p>  开发规范参考了阿里的<code>Java</code>规范和<code>Android</code>规范，选取了一些比较重要的条例和一些自己长时间开发的经验做成了一篇文档</p>
</li>
<li><p>崩溃率的优化，做了哪些事情</p>
<p>  感觉这里没答好，有点答非所问的意思，我就说了说目前处理bug的一个流程，没有谈到怎么解决一个bug</p>
</li>
<li><p>数据打点是怎么做的</p>
<p>  我们用的是神策第三方服务</p>
</li>
<li><p>内存泄漏工具是怎么做的</p>
<p>  这部分同一面<code>LeakCanary</code>原理</p>
</li>
<li><p>看你之前做过一个<code>MQTT</code>协议的客户端，是出于个人兴趣吗</p>
<p>  是的，当时是想要做一个<code>IM</code>应用</p>
</li>
<li><p>在项目中有遇到需要3D渲染展示的内容吗</p>
<p>  目前没有</p>
</li>
<li><p>两个<code>Activity</code>跳转时方法执行的顺序</p>
<p>  一个<code>Activity</code>创建是：onCreate -&gt; onStart -&gt; onResume（之后便在屏幕上显示了）</p>
<p>  假设从<code>A Activity</code>跳转到<code>B Activity</code>：A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop</p>
<p>  从<code>B</code>返回到<code>A</code>：B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory</p>
</li>
<li><p>两个<code>Activity</code>传递数据可以通过什么方式</p>
<ul>
<li><p><code>Intent</code></p>
</li>
<li><p>如果是同一个进程的话，可以用全局变量或者单例等</p>
</li>
<li><p><code>SharedPreference</code></p>
</li>
<li><p>文件</p>
</li>
</ul>
</li>
<li><p>什么时候使用<code>Service</code></p>
<p>  后台任务，比如说后台播放音乐等，这里提了一下<code>IntentService</code>是开了一个子线程的</p>
</li>
<li><p><code>Service</code>怎么启动，怎么停止</p>
<ul>
<li><p><code>startService</code> &lt;—&gt; <code>stopService</code></p>
</li>
<li><p><code>bindService</code> &lt;—&gt; <code>unbindService</code></p>
</li>
</ul>
</li>
<li><p>包体积优化</p>
<p>  清理资源（字体、图片、代码等）</p>
</li>
</ul>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>二面结束后过了2-3天，HR发微信过来恭喜我进入下一轮面试，我问她接下来是还有三面和HR面吗，她回答我说后面就直接是HR面了，说实话我还是挺惊讶的</p>
<p>HR面15min左右，大概就问了一下，为什么要从上家公司离职，我们是一个新部门，处于项目初期，有什么看法之类的，然后问了一下目前的薪资和期望薪资，over~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说实话感觉这次面试太简单了，有点白瞎了我准备了那么多，还做了查漏补缺 ㄟ( ▔, ▔ )ㄏ ，最后祝大家都能找到心仪的工作 (๑•̀ㅂ•́)و✧</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>