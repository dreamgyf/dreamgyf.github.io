<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/07/26/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ActivityManagerService/">Android源码分析-ActivityManagerService</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-07-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/ActivityManagerService/">ActivityManagerService</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManagerService/">ActivityManagerService</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>作为一名<code>Android</code>开发，我们最熟悉并且最常打交道的当然非四大组件中的<code>Activity</code>莫属，这次我们就来讲讲<code>ActivityManagerService</code>这个<code>Android</code>系统核心服务究竟扮演了一个怎样的角色，提供了哪些功能</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>ActivityManagerService</code>（以下简称<code>AMS</code>）是<code>Android</code>系统中最核心的服务之一，主要负责系统中四大组件的调度管理</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>我们在<a href="https://juejin.cn/post/7058543470356463646" target="_blank" rel="noopener">Android源码分析 - SystemServer（下）</a>中提到过<code>AMS</code>的启动，在<code>SystemServer</code>启动的各个阶段，<code>AMS</code>做了一些不同的工作，我们先从它的实例化开始</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建 ATMS &amp; AMS</span></span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">            ActivityTaskManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">            mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityTaskManagerService"><a href="#ActivityTaskManagerService" class="headerlink" title="ActivityTaskManagerService"></a>ActivityTaskManagerService</h2><p>路径：<code>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</code></p>
<p><code>Android 10</code>以后增加了一个<code>ActivityTaskManagerService</code>（以下简称<code>ATMS</code>）来分担<code>AMS</code>的工作</p>
<h3 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line">        <span class="comment">//必须是SystemService的子类</span></span><br><span class="line">        <span class="keyword">if</span> (!SystemService<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">serviceClass</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> T service;</span><br><span class="line">        <span class="comment">//反射调用构造方法实例化</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            service = constructor.newInstance(mContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startService(service);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加到List中</span></span><br><span class="line">    mServices.add(service);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> time = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//回调</span></span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动时间过长会打一个Warnning级别日志</span></span><br><span class="line">    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, <span class="string">"onStart"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ATMS</code>和<code>AMS</code>的启动通过了<code>SystemServiceManager.startService</code>方法，它需要参数为<code>SystemService</code>子类的<code>class</code>，对于<code>ATMS</code>来说，它的内部类<code>Lifecycle</code>继承自<code>SystemService</code></p>
<p><code>SystemServiceManager.startService</code>方法首先通过反射创建了对应传进来类的实例，然后将其添加到<code>SystemServiceManager</code>内部的一个<code>List</code>中，接着回调其<code>onStart</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityTaskManagerService mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mService = <span class="keyword">new</span> ActivityTaskManagerService(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService);</span><br><span class="line">        mService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnlockUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.getGlobalLock()) &#123;</span><br><span class="line">            mService.mStackSupervisor.onUserUnlocked(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCleanupUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.getGlobalLock()) &#123;</span><br><span class="line">            mService.mStackSupervisor.mLaunchParamsPersister.onCleanupUser(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityTaskManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实<code>ATMS.Lifecycle</code>很短，我们看它的构造方法，其实就是实例化了一个<code>ATMS</code>出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityTaskManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mFactoryTest = FactoryTest.getMode();</span><br><span class="line">    mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line">    mUiContext = mSystemThread.getSystemUiContext();</span><br><span class="line">    <span class="comment">//管理Activity生命周期</span></span><br><span class="line">    mLifecycleManager = <span class="keyword">new</span> ClientLifecycleManager();</span><br><span class="line">    mInternal = <span class="keyword">new</span> LocalService();</span><br><span class="line">    GL_ES_VERSION = SystemProperties.getInt(<span class="string">"ro.opengles.version"</span>, GL_ES_VERSION_UNDEFINED);</span><br><span class="line">    mWindowOrganizerController = <span class="keyword">new</span> WindowOrganizerController(<span class="keyword">this</span>);</span><br><span class="line">    mTaskOrganizerController = mWindowOrganizerController.mTaskOrganizerController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面初始化了很多东西，我们暂且跳过，等以后使用到时候在细说，然后<code>startService</code>方法会回调<code>ATMS.Lifecycle.onStart</code>方法，这个方法首先将创建好的<code>ATMS</code>注册到<code>ServiceManager</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishBinderService</span><span class="params">(@NonNull String name, @NonNull IBinder service)</span> </span>&#123;</span><br><span class="line">    publishBinderService(name, service, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishBinderService</span><span class="params">(@NonNull String name, @NonNull IBinder service,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">    publishBinderService(name, service, allowIsolated, DUMP_FLAG_PRIORITY_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishBinderService</span><span class="params">(String name, IBinder service,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    ServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用了<code>ATMS.start</code>方法，将刚创建出来的<code>mInternal</code>添加到本地服务中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalServices.addService(ActivityTaskManagerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">mInternal</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><p>接着我们回到<code>SystemServer.startBootstrapServices</code>中，接下来是对<code>AMS</code>的启动</p>
<h3 id="startService-1"><a href="#startService-1" class="headerlink" title="startService"></a>startService</h3><p><code>AMS</code>的启动和<code>ATMS</code>类似，它们同样是通过内部的一个<code>Lifecycle</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ActivityTaskManagerService sAtm;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mService = <span class="keyword">new</span> ActivityManagerService(context, sAtm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityManagerService <span class="title">startService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            SystemServiceManager ssm, ActivityTaskManagerService atm)</span> </span>&#123;</span><br><span class="line">        sAtm = atm;</span><br><span class="line">        <span class="keyword">return</span> ssm.startService(ActivityManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">        mService.mBootPhase = phase;</span><br><span class="line">        <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">            mService.mBatteryStatsService.systemServicesReady();</span><br><span class="line">            mService.mServices.systemServicesReady();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_ACTIVITY_MANAGER_READY) &#123;</span><br><span class="line">            mService.startBroadcastObservers();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">            mService.mPackageWatchdog.onPackagesReady();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserStopped</span><span class="params">(@NonNull TargetUser user)</span> </span>&#123;</span><br><span class="line">        mService.mBatteryStatsService.onCleanupUser(user.getUserIdentifier());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里将<code>ATMS</code>作为参数参与<code>AMS</code>的实例化，我么看一下它的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext, ActivityTaskManagerService atm)</span> </span>&#123;</span><br><span class="line">    LockGuard.installLock(<span class="keyword">this</span>, LockGuard.INDEX_ACTIVITY);</span><br><span class="line">    mInjector = <span class="keyword">new</span> Injector(systemContext);</span><br><span class="line">    mContext = systemContext;</span><br><span class="line"></span><br><span class="line">    mFactoryTest = FactoryTest.getMode();</span><br><span class="line">    <span class="comment">//获取系统ActivityThread</span></span><br><span class="line">    mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line">    mUiContext = mSystemThread.getSystemUiContext();</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, <span class="string">"Memory class: "</span> + ActivityManager.staticGetMemoryClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程来处理AMS的各种状态</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">            THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line">    mUiHandler = mInjector.getUiHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建proc线程</span></span><br><span class="line">    mProcStartHandlerThread = <span class="keyword">new</span> ServiceThread(TAG + <span class="string">":procStart"</span>,</span><br><span class="line">            THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/* allowIo */</span>);</span><br><span class="line">    mProcStartHandlerThread.start();</span><br><span class="line">    mProcStartHandler = <span class="keyword">new</span> Handler(mProcStartHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取定义常量</span></span><br><span class="line">    mConstants = <span class="keyword">new</span> ActivityManagerConstants(mContext, <span class="keyword">this</span>, mHandler);</span><br><span class="line">    <span class="comment">//记录活跃的进程uid</span></span><br><span class="line">    <span class="keyword">final</span> ActiveUids activeUids = <span class="keyword">new</span> ActiveUids(<span class="keyword">this</span>, <span class="keyword">true</span> <span class="comment">/* postChangesToAtm */</span>);</span><br><span class="line">    mPlatformCompat = (PlatformCompat) ServiceManager.getService(</span><br><span class="line">            Context.PLATFORM_COMPAT_SERVICE);</span><br><span class="line">    <span class="comment">//新建ProcessList对象用来处理进程</span></span><br><span class="line">    mProcessList = mInjector.getProcessList(<span class="keyword">this</span>);</span><br><span class="line">    mProcessList.init(<span class="keyword">this</span>, activeUids, mPlatformCompat);</span><br><span class="line">    <span class="comment">//低内存检测器</span></span><br><span class="line">    mLowMemDetector = <span class="keyword">new</span> LowMemDetector(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//OOM调节器</span></span><br><span class="line">    mOomAdjuster = <span class="keyword">new</span> OomAdjuster(<span class="keyword">this</span>, mProcessList, activeUids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义广播策略参数</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastConstants foreConstants = <span class="keyword">new</span> BroadcastConstants(</span><br><span class="line">            Settings.Global.BROADCAST_FG_CONSTANTS);</span><br><span class="line">    foreConstants.TIMEOUT = BROADCAST_FG_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BroadcastConstants backConstants = <span class="keyword">new</span> BroadcastConstants(</span><br><span class="line">            Settings.Global.BROADCAST_BG_CONSTANTS);</span><br><span class="line">    backConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BroadcastConstants offloadConstants = <span class="keyword">new</span> BroadcastConstants(</span><br><span class="line">            Settings.Global.BROADCAST_OFFLOAD_CONSTANTS);</span><br><span class="line">    offloadConstants.TIMEOUT = BROADCAST_BG_TIMEOUT;</span><br><span class="line">    <span class="comment">// by default, no "slow" policy in this queue</span></span><br><span class="line">    offloadConstants.SLOW_TIME = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    mEnableOffloadQueue = SystemProperties.getBoolean(</span><br><span class="line">            <span class="string">"persist.device_config.activity_manager_native_boot.offload_queue_enabled"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化前台广播队列</span></span><br><span class="line">    mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">"foreground"</span>, foreConstants, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//初始化后台广播队列</span></span><br><span class="line">    mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">"background"</span>, backConstants, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//初始化卸载广播队列</span></span><br><span class="line">    mOffloadBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">"offload"</span>, offloadConstants, <span class="keyword">true</span>);</span><br><span class="line">    mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[<span class="number">2</span>] = mOffloadBroadcastQueue;</span><br><span class="line"></span><br><span class="line">    mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line">    mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);</span><br><span class="line">    mPackageWatchdog = PackageWatchdog.getInstance(mUiContext);</span><br><span class="line">    mAppErrors = <span class="keyword">new</span> AppErrors(mUiContext, <span class="keyword">this</span>, mPackageWatchdog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File systemDir = SystemServiceManager.ensureSystemDir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Move creation of battery stats service outside of activity manager service.</span></span><br><span class="line">    mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemContext, systemDir,</span><br><span class="line">            BackgroundThread.get().getHandler());</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">    mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">            : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mOomAdjProfiler.batteryPowerChanged(mOnBattery);</span><br><span class="line"></span><br><span class="line">    mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">"procstats"</span>));</span><br><span class="line"></span><br><span class="line">    mAppOpsService = mInjector.getAppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">"appops.xml"</span>), mHandler);</span><br><span class="line"></span><br><span class="line">    mUgmInternal = LocalServices.getService(UriGrantsManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mUserController = <span class="keyword">new</span> UserController(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mPendingIntentController = <span class="keyword">new</span> PendingIntentController(</span><br><span class="line">            mHandlerThread.getLooper(), mUserController, mConstants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SystemProperties.getInt(<span class="string">"sys.use_fifo_ui"</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        mUseFifoUiScheduling = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTrackingAssociations = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.track-associations"</span>));</span><br><span class="line">    mIntentFirewall = <span class="keyword">new</span> IntentFirewall(<span class="keyword">new</span> IntentFirewallInterface(), mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ATMS进一步初始化</span></span><br><span class="line">    mActivityTaskManager = atm;</span><br><span class="line">    mActivityTaskManager.initialize(mIntentFirewall, mPendingIntentController,</span><br><span class="line">            DisplayThread.get().getLooper());</span><br><span class="line">    mAtmInternal = LocalServices.getService(ActivityTaskManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">"CpuTracker"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mProcessCpuTracker) &#123;</span><br><span class="line">                mProcessCpuInitLatch.countDown();</span><br><span class="line">                mProcessCpuTracker.init();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                            <span class="keyword">long</span> nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">                            <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">                            <span class="comment">//Slog.i(TAG, "Cpu delay=" + nextCpuDelay</span></span><br><span class="line">                            <span class="comment">//        + ", write delay=" + nextWriteDelay);</span></span><br><span class="line">                            <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                                nextCpuDelay = nextWriteDelay;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                                <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    updateCpuStatsNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">"Unexpected exception collecting process stats"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mHiddenApiBlacklist = <span class="keyword">new</span> HiddenApiSettings(mHandler, mContext);</span><br><span class="line"></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bind background threads to little cores</span></span><br><span class="line">    <span class="comment">// this is expected to fail inside of framework tests because apps can't touch cpusets directly</span></span><br><span class="line">    <span class="comment">// make sure we've already adjusted system_server's internal view of itself first</span></span><br><span class="line">    updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Process.setThreadGroupAndCpuset(BackgroundThread.get().getThreadId(),</span><br><span class="line">                Process.THREAD_GROUP_SYSTEM);</span><br><span class="line">        Process.setThreadGroupAndCpuset(</span><br><span class="line">                mOomAdjuster.mCachedAppOptimizer.mCachedAppOptimizerThread.getThreadId(),</span><br><span class="line">                Process.THREAD_GROUP_SYSTEM);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Setting background thread cpuset failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInternal = <span class="keyword">new</span> LocalService();</span><br><span class="line">    mPendingStartActivityUids = <span class="keyword">new</span> PendingStartActivityUids(mContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的内容更复杂了，我们注意到<code>AMS</code>将<code>ATMS</code>保存成了自己的一个成员变量，然后调用它的<code>initialize</code>方法进一步初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(IntentFirewall intentFirewall, PendingIntentController intentController,</span></span></span><br><span class="line"><span class="function"><span class="params">        Looper looper)</span> </span>&#123;</span><br><span class="line">    mH = <span class="keyword">new</span> H(looper);</span><br><span class="line">    mUiHandler = <span class="keyword">new</span> UiHandler();</span><br><span class="line">    mIntentFirewall = intentFirewall;</span><br><span class="line">    <span class="keyword">final</span> File systemDir = SystemServiceManager.ensureSystemDir();</span><br><span class="line">    mAppWarnings = createAppWarnings(mUiContext, mH, mUiHandler, systemDir);</span><br><span class="line">    mCompatModePackages = <span class="keyword">new</span> CompatModePackages(<span class="keyword">this</span>, systemDir, mH);</span><br><span class="line">    mPendingIntentController = intentController;</span><br><span class="line">    mStackSupervisor = createStackSupervisor();</span><br><span class="line"></span><br><span class="line">    mTaskChangeNotificationController =</span><br><span class="line">            <span class="keyword">new</span> TaskChangeNotificationController(mGlobalLock, mStackSupervisor, mH);</span><br><span class="line">    mLockTaskController = <span class="keyword">new</span> LockTaskController(mContext, mStackSupervisor, mH);</span><br><span class="line">    mActivityStartController = <span class="keyword">new</span> ActivityStartController(<span class="keyword">this</span>);</span><br><span class="line">    setRecentTasks(<span class="keyword">new</span> RecentTasks(<span class="keyword">this</span>, mStackSupervisor));</span><br><span class="line">    mVrController = <span class="keyword">new</span> VrController(mGlobalLock);</span><br><span class="line">    mKeyguardController = mStackSupervisor.getKeyguardController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后同样的，<code>startService</code>方法回调<code>AMS.Lifecycle.onStart</code>方法，调用<code>AMS.start</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllProcessGroups();</span><br><span class="line">    mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">    mBatteryStatsService.publish();</span><br><span class="line">    mAppOpsService.publish();</span><br><span class="line">    Slog.d(<span class="string">"AppOps"</span>, <span class="string">"AppOpsService published"</span>);</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal<span class="class">.<span class="keyword">class</span>, <span class="title">mInternal</span>)</span>;</span><br><span class="line">    <span class="comment">//通知ATMS，ActivityManagerInternal被添加到了本地服务中，ATMS那边可以获取到了</span></span><br><span class="line">    mActivityTaskManager.onActivityManagerInternalAdded();</span><br><span class="line">    mPendingIntentController.onActivityManagerInternalAdded();</span><br><span class="line">    <span class="comment">// Wait for the synchronized block started in mProcessCpuThread,</span></span><br><span class="line">    <span class="comment">// so that any other access to mProcessCpuTracker from main thread</span></span><br><span class="line">    <span class="comment">// will be blocked during mProcessCpuTracker initialization.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mProcessCpuInitLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Interrupted wait during start"</span>, e);</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Interrupted wait during start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><p>后续在<code>SystemServer</code>启动服务的过程中，<code>AMS</code>还参加进行了很多工作，我在这里将其列出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阶段0 */</span></span><br><span class="line">mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">        mSystemServiceManager, atm);</span><br><span class="line">mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">mActivityManagerService.setInstaller(installer);</span><br><span class="line">mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阶段100 PHASE_WAIT_FOR_DEFAULT_DISPLAY */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册各种系统服务</span></span><br><span class="line">mActivityManagerService.setSystemProcess();</span><br><span class="line"><span class="comment">//应用用量统计服务</span></span><br><span class="line">mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"><span class="comment">//加载SettingProvider</span></span><br><span class="line">mActivityManagerService.installSystemProviders();</span><br><span class="line"><span class="comment">//窗口服务</span></span><br><span class="line">mActivityManagerService.setWindowManager(wm);</span><br><span class="line"><span class="comment">//进入安全模式</span></span><br><span class="line"><span class="keyword">if</span> (safeMode) &#123;</span><br><span class="line">    mActivityManagerService.enterSafeMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阶段480 PHASE_LOCK_SETTINGS_READY */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 阶段500 PHASE_SYSTEM_SERVICES_READY */</span></span><br><span class="line"></span><br><span class="line">mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">    <span class="comment">/* 阶段550 PHASE_ACTIVITY_MANAGER_READY */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* 阶段600 PHASE_THIRD_PARTY_APPS_CAN_START */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;, t);</span><br></pre></td></tr></table></figure>

<p>我们拣几个比较重要的方法介绍一下</p>
<h4 id="setSystemProcess"><a href="#setSystemProcess" class="headerlink" title="setSystemProcess"></a>setSystemProcess</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//将自己添加到ServiceManager中</span></span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="keyword">true</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_HIGH);</span><br><span class="line">        ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>),</span><br><span class="line">                    <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将权限服务添加到ServiceManager中</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"processinfo"</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"cacheinfo"</span>, <span class="keyword">new</span> CacheBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//查询包名为android的application，即framework-res.apk的application信息</span></span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                <span class="string">"android"</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line">        <span class="comment">//设置系统application信息</span></span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个ProcessRecord对象记录系统application信息</span></span><br><span class="line">            ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName,</span><br><span class="line">                    <span class="keyword">false</span>,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="keyword">new</span> HostingRecord(<span class="string">"system"</span>));</span><br><span class="line">            app.setPersistent(<span class="keyword">true</span>);</span><br><span class="line">            app.pid = MY_PID;</span><br><span class="line">            app.getWindowProcessController().setPid(MY_PID);</span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            <span class="comment">//将系统application的ProcessRecord对象也添加进来，让AMS可以管理调度</span></span><br><span class="line">            addPidLocked(app);</span><br><span class="line">            mProcessList.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to find android system package"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start watching app ops after we and the package manager are up and running.</span></span><br><span class="line">    mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (getAppOpsManager().checkOpNoThrow(op, uid, packageName)</span><br><span class="line">                                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                            runInBackgroundDisabled(uid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] cameraOp = &#123;AppOpsManager.OP_CAMERA&#125;;</span><br><span class="line">    mAppOpsService.startWatchingActive(cameraOp, <span class="keyword">new</span> IAppOpsActiveCallback.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opActiveChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName, <span class="keyword">boolean</span> active)</span> </span>&#123;</span><br><span class="line">            cameraActiveChanged(uid, active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法主要将自己和一些其他系统服务注册到了<code>ServiceManager</code>中，然后通过<code>PMS</code>找到<code>framework-res.apk</code>的<code>application</code>信息，将它配置到系统<code>ActivityThread</code>中，然后根据这个<code>application</code>信息，创建出了一个记录系统<code>application</code>信息的<code>ProcessRecord</code>对象，并将其添加到<code>AMS</code>内部的列表中，这样后续<code>AMS</code>就可以管理调度系统<code>application</code>了</p>
<h4 id="installSystemProviders"><a href="#installSystemProviders" class="headerlink" title="installSystemProviders"></a>installSystemProviders</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//这里找到的就是setSystemProcess中创建的framework-res.apk的application信息</span></span><br><span class="line">        ProcessRecord app = mProcessList.mProcessNames.get(<span class="string">"system"</span>, SYSTEM_UID);</span><br><span class="line">        <span class="comment">//找到所有和framework-res.apk相关的ContentProvider</span></span><br><span class="line">        providers = generateApplicationProvidersLocked(app);</span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=providers.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                <span class="keyword">if</span> ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Not installing system proc provider "</span> + pi.name</span><br><span class="line">                            + <span class="string">": not system .apk"</span>);</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mSystemProvidersInstalled = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mConstants.start(mContext.getContentResolver());</span><br><span class="line">    mCoreSettingsObserver = <span class="keyword">new</span> CoreSettingsObserver(<span class="keyword">this</span>);</span><br><span class="line">    mActivityTaskManager.installSystemProviders();</span><br><span class="line">    mDevelopmentSettingsObserver = <span class="keyword">new</span> DevelopmentSettingsObserver();</span><br><span class="line">    SettingsToPropertiesMapper.start(mContext.getContentResolver());</span><br><span class="line">    mOomAdjuster.initSettings();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that the settings provider is published we can consider sending</span></span><br><span class="line">    <span class="comment">// in a rescue party.</span></span><br><span class="line">    RescueParty.onSettingsProviderPublished(mContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/07/05/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89/">Android源码分析 - Framework层的Binder（服务端篇）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-07-05</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>我们在上一片文章<a href="https://juejin.cn/post/7113760814409973790" target="_blank" rel="noopener">Android源码分析 - Framework层的Binder（客户端篇）</a>中，分析了客户端是怎么向服务端通过<code>binder</code>驱动发起请求，然后再接收服务端的返回的。本篇文章，我们将会以服务端的视角，分析服务端是怎么通过<code>binder</code>驱动接收客户端的请求，处理，然后再返回给客户端的。</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>上篇文章我们是以<code>ServiceManager</code>作为服务端分析的，本篇文章我们还是围绕着它来做分析，它也是一个比较特殊的服务端，我们正好可以顺便分析一下它是怎么成为<code>binder</code>驱动的<code>context_manager</code>的</p>
<h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><p><code>ServiceManager</code>是在独立的进程中运行的，它是由<code>init</code>进程从<code>rc</code>文件中解析并启动的，路径为<code>frameworks/native/cmds/servicemanager/servicemanager.rc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">    class core animation</span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart restart thermalservice</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;system-background&#x2F;tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>这个服务的入口函数位于<code>frameworks/native/cmds/servicemanager/main.cpp</code>的<code>main</code>函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据上面的rc文件，argc == 1, argv[0] == "/system/bin/servicemanager"</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" [binder driver]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时，要使用的binder驱动为/dev/binder</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">"/dev/binder"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder驱动</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver);</span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>);</span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化ServiceManager</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = <span class="keyword">new</span> ServiceManager(<span class="built_in">std</span>::make_unique&lt;Access&gt;());</span><br><span class="line">    <span class="comment">//将自身作为服务添加</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">"manager"</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Could not self register servicemanager"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置服务端Bbinder对象</span></span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(manager);</span><br><span class="line">    <span class="comment">//设置成为binder驱动的context manager</span></span><br><span class="line">    ps-&gt;becomeContextManager(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Looper epoll机制处理binder事务</span></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::prepare(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line"></span><br><span class="line">    BinderCallback::setupTo(looper);</span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常走不到这里</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化Binder"><a href="#初始化Binder" class="headerlink" title="初始化Binder"></a>初始化Binder</h3><p>首先读取参数，按照之前的rc文件来看，这里的<code>driver</code>为<code>/dev/binder</code>，然后根据此<code>driver</code>初始化此进程的<code>ProcessState</code>单例，根据我们上一章的分析我们知道此时会执行<code>binder_open</code>和<code>binder_mmap</code>，接着对这个单例做一些配置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::initWithDriver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Allow for initWithDriver to be called repeatedly with the same</span></span><br><span class="line">        <span class="comment">// driver.</span></span><br><span class="line">        <span class="comment">//如果已经被初始化过了，并且传入的driver参数和已初始化的驱动名一样，直接返回之前初始化的单例</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(gProcess-&gt;getDriverName().c_str(), driver)) &#123;</span><br><span class="line">            <span class="keyword">return</span> gProcess;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则异常退出</span></span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"ProcessState was already initialized."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断指定的driver是否存在并可读</span></span><br><span class="line">    <span class="keyword">if</span> (access(driver, R_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder driver %s is unavailable. Using /dev/binder instead."</span>, driver);</span><br><span class="line">        <span class="comment">//回滚默认binder驱动</span></span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(driver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>文档：<a href="https://man7.org/linux/man-pages/man2/access.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/access.2.html</a></p>
<p>原型：<code>int access(const char *pathname, int mode);</code></p>
<p>这个函数是用来检查调用进程是否可以对指定文件执行某种操作的，成功返回0，失败返回-1并设置error</p>
<p><code>mode</code>参数可以为以下几个值：</p>
<ul>
<li><p><code>F_OK</code>：文件存在</p>
</li>
<li><p><code>R_OK</code>：文件可读</p>
</li>
<li><p><code>W_OK</code>：文件可写</p>
</li>
<li><p><code>X_OK</code>：文件可执行</p>
</li>
</ul>
<h3 id="注册成为Binder驱动的context-manager"><a href="#注册成为Binder驱动的context-manager" class="headerlink" title="注册成为Binder驱动的context manager"></a>注册成为Binder驱动的context manager</h3><p>接着调用了<code>ProcessState</code>的<code>becomeContextManager</code>函数注册成为<code>Binder</code>驱动的<code>context manager</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProcessState::becomeContextManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    flat_binder_object obj &#123;</span><br><span class="line">        .flags = FLAT_BINDER_FLAG_TXN_SECURITY_CTX,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR_EXT, &amp;obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fallback to original method</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        android_errorWriteLog(<span class="number">0x534e4554</span>, <span class="string">"121035042"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> unused = <span class="number">0</span>;</span><br><span class="line">        result = ioctl(mDriverFD, BINDER_SET_CONTEXT_MGR, &amp;unused);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to become context manager failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过<code>binder_ioctl</code>，以<code>BINDER_SET_CONTEXT_MGR_EXT</code>为命令码请求<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> <span class="title">fbo</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;fbo, ubuf, <span class="keyword">sizeof</span>(fbo))) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_set_ctx_mgr</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct flat_binder_object *fbo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span>;</span></span><br><span class="line">    <span class="keyword">kuid_t</span> curr_euid = current_euid();</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//binder的context manager只能设置一次</span></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;binder_context_mgr_node) &#123;</span><br><span class="line">        pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断调用进程是否有权限设置context manager</span></span><br><span class="line">    ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">//context-&gt;binder_context_mgr_uid != -1</span></span><br><span class="line">    <span class="keyword">if</span> (uid_valid(context-&gt;binder_context_mgr_uid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!uid_eq(context-&gt;binder_context_mgr_uid, curr_euid)) &#123;</span><br><span class="line">            pr_err(<span class="string">"BINDER_SET_CONTEXT_MGR bad uid %d != %d\n"</span>,</span><br><span class="line">                   from_kuid(&amp;init_user_ns, curr_euid),</span><br><span class="line">                   from_kuid(&amp;init_user_ns,</span><br><span class="line">                     context-&gt;binder_context_mgr_uid));</span><br><span class="line">            ret = -EPERM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//设置Binder驱动context manager所在进程的用户ID</span></span><br><span class="line">        context-&gt;binder_context_mgr_uid = curr_euid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建binder节点</span></span><br><span class="line">    new_node = binder_new_node(proc, fbo);</span><br><span class="line">    <span class="keyword">if</span> (!new_node) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_node_lock(new_node);</span><br><span class="line">    new_node-&gt;local_weak_refs++;</span><br><span class="line">    new_node-&gt;local_strong_refs++;</span><br><span class="line">    new_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    new_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//设置binder驱动context manager节点</span></span><br><span class="line">    context-&gt;binder_context_mgr_node = new_node;</span><br><span class="line">    binder_node_unlock(new_node);</span><br><span class="line">    binder_put_node(new_node);</span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的过程也很简单，首先检查之前是否设置过<code>context manager</code>，然后做权限校验，通过后通过<code>binder_new_node</code>创建出一个新的<code>binder</code>节点，并将它作为<code>context manager</code>节点</p>
<h3 id="Looper循环处理Binder事务"><a href="#Looper循环处理Binder事务" class="headerlink" title="Looper循环处理Binder事务"></a>Looper循环处理Binder事务</h3><p>这里的<code>Looper</code>和我们平常应用开发所说的<code>Looper</code>是一个东西，本篇就不做过多详解了，只需要知道，可以通过<code>Looper::addFd</code>函数监听文件描述符，通过<code>Looper::pollAll</code>或<code>Looper::pollOnce</code>函数接收消息，消息抵达后会回调<code>LooperCallback::handleEvent</code>函数</p>
<p>了解了这些后我们来看一下<code>BinderCallback</code>这个类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> sp&lt;BinderCallback&gt; <span class="title">setupTo</span><span class="params">(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper)</span> </span>&#123;</span><br><span class="line">        sp&lt;BinderCallback&gt; cb = <span class="keyword">new</span> BinderCallback;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//向binder驱动发送BC_ENTER_LOOPER事务请求，并获得binder设备的文件描述符</span></span><br><span class="line">        IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(binder_fd &lt; <span class="number">0</span>, <span class="string">"Failed to setupPolling: %d"</span>, binder_fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">        <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听binder文件描述符</span></span><br><span class="line">        <span class="keyword">int</span> ret = looper-&gt;addFd(binder_fd,</span><br><span class="line">                                Looper::POLL_CALLBACK,</span><br><span class="line">                                Looper::EVENT_INPUT,</span><br><span class="line">                                cb,</span><br><span class="line">                                <span class="literal">nullptr</span> <span class="comment">/*data*/</span>);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(ret != <span class="number">1</span>, <span class="string">"Failed to add binder FD to Looper"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从binder驱动接收到消息并处理</span></span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>servicemanager</code>进程启动的过程中调用了<code>BinderCallback::setupTo</code>函数，这个函数首先想<code>binder</code>驱动发起了一个<code>BC_ENTER_LOOPER</code>事务请求，获得<code>binder</code>设备的文件描述符，然后调用<code>Looper::addFd</code>函数监听<code>binder</code>设备文件描述符，这样当<code>binder</code>驱动发来消息后，就可以通过<code>Looper::handleEvent</code>函数接收并处理了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::setupPolling</span><span class="params">(<span class="keyword">int</span>* fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置binder请求码</span></span><br><span class="line">    mOut.writeInt32(BC_ENTER_LOOPER);</span><br><span class="line">    <span class="comment">//检查写缓存是否有可写数据，有的话发送给binder驱动</span></span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="comment">//赋值binder驱动的文件描述符</span></span><br><span class="line">    *fd = mProcess-&gt;mDriverFD;</span><br><span class="line">    pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    mProcess-&gt;mCurrentThreads++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder事务处理"><a href="#Binder事务处理" class="headerlink" title="Binder事务处理"></a>Binder事务处理</h2><p><code>BinderCallback</code>类重写了<code>handleEvent</code>函数，里面调用了<code>IPCThreadState::handlePolledCommands</code>函数来接收处理<code>binder</code>事务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::handlePolledCommands</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当读缓存中数据未消费完时，持续循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们清空执行完所有的命令后，最后处理BR_DECREFS和BR_RELEASE</span></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取并处理响应"><a href="#读取并处理响应" class="headerlink" title="读取并处理响应"></a>读取并处理响应</h3><p>这个函数的重点在<code>getAndExecuteCommand</code>，首先无论如何从binder驱动那里读取并处理一次响应，如果处理完后发现读缓存中还有数据尚未消费完，继续循环这个处理过程（理论来说此时不会再从<code>binder</code>驱动那里读写数据，只会处理剩余读缓存）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::getAndExecuteCommand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder驱动中读写数据（理论来说此时写缓存dataSize为0，也就是只读数据）</span></span><br><span class="line">    result = talkWithDriver(<span class="comment">/* true */</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//读取BR响应码</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        ...</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><p>这里有很多线程等其他操作，我们不需要关心，我在这里把他们简化掉了，剩余的代码很清晰，首先从binder驱动中读取数据，然后从数据中读取出<code>BR</code>响应码，接着调用<code>executeCommand</code>函数继续往下处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ((<span class="keyword">uint32_t</span>)cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION_SEC_CTX:</span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data_secctx tr_secctx;</span><br><span class="line">            binder_transaction_data&amp; tr = tr_secctx.transaction_data;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmd == (<span class="keyword">int</span>) BR_TRANSACTION_SEC_CTX) &#123;</span><br><span class="line">                result = mIn.read(&amp;tr_secctx, <span class="keyword">sizeof</span>(tr_secctx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                tr_secctx.secctx = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ALOG_ASSERT(result == NO_ERROR,</span><br><span class="line">                <span class="string">"Not enough command data for brTRANSACTION"</span>);</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取数据到缓冲区</span></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            <span class="keyword">status_t</span> error;</span><br><span class="line">            <span class="comment">//对于ServiceManager的binder节点来说，是没有ptr的</span></span><br><span class="line">            <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">                <span class="comment">// We only have a weak reference on the target object, so we must first try to</span></span><br><span class="line">                <span class="comment">// safely acquire a strong reference before doing anything else with it.</span></span><br><span class="line">                <span class="comment">//对于其他binder服务端来说，tr.cookie为本地BBinder对象指针</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                    error = <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    <span class="keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="keyword">this</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    error = UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//对于ServiceManager来说，使用the_context_object这个BBinder对象</span></span><br><span class="line">                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOG_ONEWAY(<span class="string">"Sending reply to %d!"</span>, mCallingPid);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                <span class="comment">//非TF_ONE_WAY模式下需要Reply</span></span><br><span class="line">                sendReply(reply, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ... <span class="comment">//TF_ONE_WAY模式下不需要Reply，这里只打了些日志</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们重点分析这个函数在<code>BR_TRANSACTION</code>下的case，其余的都删减掉</p>
<p>首先，这个函数从读缓存中读取了<code>binder_transaction_data</code>，我们知道这个结构体记录了实际数据的地址、大小等信息，然后实例化了一个<code>Parcel</code>对象作为缓冲区，从<code>binder_transaction_data</code>中将实际数据读取出来</p>
<p>接着找到本地<code>BBinder</code>对象，对于<code>ServiceManager</code>来说就是之前在<code>main</code>函数中<code>setTheContextObject</code>的<code>ServiceManager</code>对象，而对于其他<code>binder</code>服务端来说，则是通过<code>tr.cookie</code>获取，然后调用<code>BBinder</code>的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确保从头开始读取数据</span></span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span> &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123;</span><br><span class="line">        <span class="comment">//标记这个Parcel在释放时需要将内存中数据用0覆盖（涉及安全）</span></span><br><span class="line">        reply-&gt;markSensitive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="comment">//这里的code是由binder客户端请求传递过来的</span></span><br><span class="line">    <span class="comment">//是客户端与服务端的一个约定</span></span><br><span class="line">    <span class="comment">//它标识了客户端像服务端发起的是哪种请求</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case this is being transacted on in the same process.</span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">//设置数据指针偏移为0，这样后续读取数据便会从头开始</span></span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (reply-&gt;dataSize() &gt; LOG_REPLIES_OVER_SIZE) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Large reply transaction of %zu bytes, interface descriptor %s, code %d"</span>,</span><br><span class="line">                  reply-&gt;dataSize(), String8(getInterfaceDescriptor()).c_str(), code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="onTransact"><a href="#onTransact" class="headerlink" title="onTransact"></a>onTransact</h3><p>这个函数主要调用了<code>onTransact</code>函数，它是一个虚函数，可以被子类重写。我们观察<code>ServiceManager</code>这个类，它继承了<code>BnServiceManager</code>，在<code>BnServiceManager</code>中重写了这个<code>onTransact</code>函数，它们的继承关系如下：</p>
<p><code>ServiceManager</code> -&gt; <code>BnServiceManager</code> -&gt; <code>BnInterface&lt;IServiceManager&gt;</code> -&gt; <code>IServiceManager</code> &amp; <code>BBinder</code></p>
<p>这里的<code>BnServiceManager</code>是通过<code>AIDL</code>工具生成出来的（<code>AIDL</code>既可以生成<code>Java</code>代码，也可以生成<code>C++</code>代码），我们找到一份生成后的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">::<span class="function">android::<span class="keyword">status_t</span> <span class="title">BnServiceManager::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> _aidl_code, <span class="keyword">const</span> ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, <span class="keyword">uint32_t</span> _aidl_flags)</span> </span>&#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _aidl_ret_status = ::android::OK;</span><br><span class="line">    <span class="keyword">switch</span> (_aidl_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> BnServiceManager::TRANSACTION_getService: &#123;</span><br><span class="line">            <span class="comment">//参数name</span></span><br><span class="line">            ::<span class="built_in">std</span>::<span class="built_in">string</span> in_name;</span><br><span class="line">            ::android::sp&lt;::android::IBinder&gt; _aidl_return;</span><br><span class="line">            <span class="comment">//类型检查</span></span><br><span class="line">            <span class="keyword">if</span> (!(_aidl_data.checkInterface(<span class="keyword">this</span>))) &#123;</span><br><span class="line">                _aidl_ret_status = ::android::BAD_TYPE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取参数name</span></span><br><span class="line">            _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//确认数据已读完</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> st = _aidl_data.enforceNoDataAvail();</span><br><span class="line">            !st.isOk()) &#123;</span><br><span class="line">                _aidl_ret_status = st.writeToParcel(_aidl_reply);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行真正的getService函数</span></span><br><span class="line">            ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return));</span><br><span class="line">            <span class="comment">//将状态值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_aidl_status.isOk()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将返回值写入reply</span></span><br><span class="line">            _aidl_ret_status = _aidl_reply-&gt;writeStrongBinder(_aidl_return);</span><br><span class="line">            <span class="keyword">if</span> (((_aidl_ret_status) != (::android::OK))) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123;</span><br><span class="line">        _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeOverParcel(_aidl_reply);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _aidl_ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成出的代码格式比较丑，不易阅读，我把它格式化了一下，提取出我们需要的部分。这个函数主要流程就是先从<code>data</code>中读取所需要的参数，然后根据参数执行相对应的函数，然后将状态值写入<code>reply</code>，最后再将返回值写入<code>reply</code>。这里我们将上一章节<code>AIDL</code>生成出的<code>java</code>文件那部分拿过来做对比，我们可以发现，这里<code>Parcel</code>的写入和那里<code>Parcel</code>的读取顺序是严格一一对应的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//先读取状态值</span></span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">//再读取返回值</span></span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际功能实现"><a href="#实际功能实现" class="headerlink" title="实际功能实现"></a>实际功能实现</h3><p>然后我们来看真正功能实现的地方：<code>getService</code>函数，根据之前所说的继承关系，<code>ServiceManager</code>继承自<code>IServiceManager</code>，实现了其中的纯虚函数，其中就包括了<code>getService</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::getService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, sp&lt;IBinder&gt;* outBinder)</span> </span>&#123;</span><br><span class="line">    *outBinder = tryGetService(name, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// returns ok regardless of result for legacy reasons</span></span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ServiceManager::tryGetService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">bool</span> startIfNotFound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回值</span></span><br><span class="line">    sp&lt;IBinder&gt; out;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//从map中寻找相应的服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = mNameToService.find(name); it != mNameToService.end()) &#123;</span><br><span class="line">        service = &amp;(it-&gt;second);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!service-&gt;allowIsolated) &#123;</span><br><span class="line">            <span class="keyword">uid_t</span> appid = multiuser_get_app_id(ctx.uid);</span><br><span class="line">            <span class="keyword">bool</span> isIsolated = appid &gt;= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isIsolated) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值指向对应service的binder对象</span></span><br><span class="line">        out = service-&gt;binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAccess-&gt;canFind(ctx, name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!out &amp;&amp; startIfNotFound) &#123;</span><br><span class="line">        tryStartService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out) &#123;</span><br><span class="line">        <span class="comment">// Setting this guarantee each time we hand out a binder ensures that the client-checking</span></span><br><span class="line">        <span class="comment">// loop knows about the event even if the client immediately drops the service</span></span><br><span class="line">        service-&gt;guaranteeClient = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的实现我们就没必要细看了，只需要注意它返回了相应<code>service</code>的<code>binder</code>对象，根据上面的代码来看，会将其写入到<code>reply</code>中</p>
<h3 id="Reply"><a href="#Reply" class="headerlink" title="Reply"></a>Reply</h3><p>实际的功能处理完成后，我们回到<code>IPCThreadState::executeCommand</code>中来。对于非<code>TF_ONE_WAY</code>模式，我们要将<code>reply</code>发送给请求方客户端</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="keyword">const</span> Parcel&amp; reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">status_t</span> statusBuffer;</span><br><span class="line">    <span class="comment">//将binder reply请求打包好写入写缓冲区</span></span><br><span class="line">    err = writeTransactionData(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>writeTransactionData</code>在上一章中已经分析过了，这里就不多做描述了，<code>waitForResponse</code>我们上一章也分析过了，根据我们在上一章所描述的非<code>TF_ONE_WAY</code>的通信过程，在向<code>binder</code>驱动发送<code>BC_REPLY</code>请求后我们会收到<code>BR_TRANSACTION_COMPLETE</code>响应，根据我们传入<code>waitForResponse</code>的两个参数值，会直接跳出函数中的循环，结束此次<code>binder</code>通信</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="non_oneway"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//参数为两个nullptr，直接跳转到finish结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>binder</code>服务端的一次消息处理到这就结束了，<code>Looper</code>会持续监听着<code>binder</code>驱动<code>fd</code>，等待下一条<code>binder</code>消息的到来</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>经过这么多篇文章的分析，整个<code>Binder</code>架构的大致通信原理、过程，我们应该都了解的差不多了，至于一些边边角角的细节，以后有机会的话我会慢慢再补充</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/06/27/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89/">Android源码分析 - Framework层的Binder（客户端篇）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以<code>aosp</code>分支<code>android-11.0.0_r25</code>作为基础解析</strong></p>
<p>我们在之前的文章中，从驱动层面分析了<code>Binder</code>是怎样工作的，但<code>Binder</code>驱动只涉及传输部分，待传输对象是怎么产生的呢，这就是<code>framework</code>层的工作了。我们要彻底了解<code>Binder</code>的工作原理，不仅要去看驱动层，还得去看<code>framework</code>层以及应用层（<code>AIDL</code>）</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><h2 id="getIServiceManager"><a href="#getIServiceManager" class="headerlink" title="getIServiceManager"></a>getIServiceManager</h2><p>我们还是以第一次见到<code>Binder</code>的地方<code>ServiceManager</code>开始分析，我们选取<code>getService</code>方法来分析（这个方法既有入参也有返回），抛除掉它缓存和<code>log</code>的部分，最核心的代码就一句<code>getIServiceManager().getService(name)</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BinderInternal-getContextObject"><a href="#BinderInternal-getContextObject" class="headerlink" title="BinderInternal.getContextObject"></a>BinderInternal.getContextObject</h3><p>我们从<code>BinderInternal.getContextObject()</code>开始看起，这个函数是一个<code>native</code>函数，他被实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProcessState"><a href="#ProcessState" class="headerlink" title="ProcessState"></a>ProcessState</h4><p>我们在这里可以发现一个比较关键的类<code>ProcessState</code>，它是一个负责打开<code>binder</code>驱动并进行<code>mmap</code>映射的单例对象，这从它的<code>self</code>函数就可以看出来，每个进程只存在一个<code>ProcessState</code>实例</p>
<p>位置：<code>frameworks/native/libs/binder/ProcessState.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess = <span class="keyword">new</span> ProcessState(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看它的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))    <span class="comment">//打开binder驱动</span></span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">nullptr</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">nullptr</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">    , mCallRestriction(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>:</code>后是<code>c++</code>构造函数初始化赋值的一种语法，可以看到其中调用了<code>open_driver</code>函数打开<code>binder</code>驱动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打开binder驱动</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//验证binder版本</span></span><br><span class="line">    <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置binder最大线程数</span></span><br><span class="line">    <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">    result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了三件事，打开<code>binder</code>驱动、验证<code>binder</code>版本、设置<code>binder</code>最大线程数，接着构造函数调用<code>mmap</code>建立<code>binder</code>映射，这里面的实现我们已经在<a href="https://juejin.cn/post/7062654742329032740" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>、<a href="https://juejin.cn/post/7069675794028560391" target="_blank" rel="noopener">（中）</a>、<a href="https://juejin.cn/post/7073783503791325214" target="_blank" rel="noopener">（下）</a>中分析过了，感兴趣的同学可以回过头去看一看</p>
<p><code>ProcessState::self</code>函数执行完后，当前进程的<code>binder</code>初始化工作已经执行完毕，接下来我们回过头来看它的<code>getContextObject</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; context = getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       ALOGW(<span class="string">"Not able to get context object on %s."</span>, mDriverName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The root object is special since we get it directly from the driver, it is never</span></span><br><span class="line">    <span class="comment">// written by Parcell::writeStrongBinder.</span></span><br><span class="line">    internal::Stability::tryMarkCompilationUnit(context.get());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>binder</code>驱动篇就提到了，<code>handle</code>句柄<code>0</code>代表的就是<code>ServiceManager</code>，所以这里调用<code>getStrongProxyForHandle</code>函数的参数为<code>0</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找或建立handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当handle为ServiceManager的特殊情况</span></span><br><span class="line">                <span class="comment">//需要确保在创建Binder引用之前，context manager已经被binder注册</span></span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建BpBinder并保存下来以便后面再次查找</span></span><br><span class="line">            b = BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="keyword">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N=mHandleToObject.size();</span><br><span class="line">    <span class="comment">//新建一个handle_entry并插入到vector中</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整条链路下来还是比较清晰的，最终获得了一个<code>BpBinder</code>对象，这是<code>native</code>中的类型，需要将它转换成<code>java</code>中的类型，这里调用了<code>javaObjectForIBinder</code>函数，位于<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<h4 id="javaObjectForIBinder"><a href="#javaObjectForIBinder" class="headerlink" title="javaObjectForIBinder"></a>javaObjectForIBinder</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the argument is a JavaBBinder, return the Java object that was used to create it.</span></span><br><span class="line"><span class="comment">// Otherwise return a BinderProxy for the IBinder. If a previous call was passed the</span></span><br><span class="line"><span class="comment">// same IBinder, and the original BinderProxy is still alive, return the same BinderProxy.</span></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        <span class="comment">// In the exception case, getInstance still took ownership of nativeData.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看一看这个<code>gBinderProxyOffsets</code>是什么</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binderproxy_offsets_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    <span class="comment">//指向BinderProxyNativeData的指针</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderProxyPathName = <span class="string">"android/os/BinderProxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_BinderProxy</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jclass clazz = FindClassOrDie(env, kBinderProxyPathName);</span><br><span class="line">    gBinderProxyOffsets.mClass = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gBinderProxyOffsets.mGetInstance = GetStaticMethodIDOrDie(env, clazz, <span class="string">"getInstance"</span>,</span><br><span class="line">            <span class="string">"(JJ)Landroid/os/BinderProxy;"</span>);</span><br><span class="line">    gBinderProxyOffsets.mSendDeathNotice =</span><br><span class="line">            GetStaticMethodIDOrDie(env, clazz, <span class="string">"sendDeathNotice"</span>,</span><br><span class="line">                                   <span class="string">"(Landroid/os/IBinder$DeathRecipient;Landroid/os/IBinder;)V"</span>);</span><br><span class="line">    gBinderProxyOffsets.mNativeData = GetFieldIDOrDie(env, clazz, <span class="string">"mNativeData"</span>, <span class="string">"J"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>gBinderProxyOffsets</code>实际上是一个用来记录一些<code>java</code>中对应类、方法以及字段的结构体，用于从<code>native</code>层调用<code>java</code>层代码</p>
<p>接下来我们看<code>javaObjectForIBinder</code>函数的具体内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JavaBBinder返回true，其他类均返回flase</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It's a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="keyword">static_cast</span>&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先有一个<code>IBinder</code>类型检查的判断，我看了一圈发现目前只有当<code>IBinder</code>的实际类型为<code>JavaBBinder</code>的时候会返回<code>true</code>，其他子类均返回<code>false</code>。<code>JavaBBinder</code>类继承自<code>BBinder</code>，里面保存了对<code>java</code>层<code>Binder</code>对象的引用，所以在这种情况下，直接返回里面的<code>object</code>就好了。</p>
<p>从这里可以看出，<code>native</code>层的<code>javaBBinder</code>与<code>java</code>层的<code>Binder</code>是对应关系</p>
<p>我们这里传进来的是<code>BpBinder</code>，会接着往下走</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> BinderProxyNativeData();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着实例化一个<code>BinderProxyNativeData</code>，将<code>Binder</code>死亡回调<code>DeathRecipientList</code>和<code>Binder</code>对象（这里为<code>BpBinder</code>）赋值给它，然后调用<code>java</code>层方法。<code>gBinderProxyOffsets</code>之前说过了，类为<code>android.os.BinderProxy</code>，方法为<code>getInstance</code>，所以这里调用的即为<code>android.os.BinderProxy.getInstance(nativeData, iBinder)</code>，<code>BinderProxy</code>的路径为<code>frameworks/base/core/java/android/os/BinderProxy.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> nativeData, <span class="keyword">long</span> iBinder)</span> </span>&#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="keyword">new</span> BinderProxy(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We're throwing an exception (probably OOME); don't drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑比较简单，以<code>iBinder</code>为 <strong>key</strong> 尝试从<code>sProxyMap</code>取出<code>BinderProxy</code>，如果取到值了就直接将它返回出去，如果没取到，用之前传进来的<code>BinderProxyNativeData</code>指针为参数实例化一个<code>BinderProxy</code>，并将其设置到<code>sProxyMap</code>中</p>
<p>从这里可以看出每一个服务的<code>BinderProxy</code>都是以单例形式存在的，并且<code>native</code>层的<code>BinderProxyNativeData</code>与<code>java</code>层的<code>BinderProxy</code>是对应关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    BinderProxyNativeData* actualNativeData = getBPNativeData(env, object);</span><br><span class="line">    <span class="comment">//如果object是刚刚新建出来的BinderProxy</span></span><br><span class="line">    <span class="keyword">if</span> (actualNativeData == nativeData) &#123;</span><br><span class="line">        <span class="comment">//处理proxy计数</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> nativeData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来判断我们通过<code>BinderProxy.getInstance</code>方法获得的<code>BinderProxy</code>是不是刚刚创建出来的，如果是新建的则需要处理一下proxy计数，这里是通过对比<code>BinderProxy</code>中的<code>mNativeData</code>和我们新建出来的<code>nativeData</code>地址判断的</p>
<h3 id="ServiceManagerNative-asInterface"><a href="#ServiceManagerNative-asInterface" class="headerlink" title="ServiceManagerNative.asInterface"></a>ServiceManagerNative.asInterface</h3><p>我们将目光放回<code>getIServiceManager</code>方法，现在我们知道<code>BinderInternal.getContextObject()</code>方法返回了<code>ServiceManager</code>对应的<code>BinderProxy</code>，接着会调用<code>Binder.allowBlocking</code>方法，这个方法只是改变了<code>BinderProxy</code>中的一个参数，使其允许阻塞调用，这样的话<code>getIServiceManager</code>就可以被简化成如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(<span class="comment">/* BinderProxy */</span>);</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>asInterface</code>方法实际上是直接实例化了一个<code>ServiceManagerProxy</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceManager is never local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServiceManagerProxy"><a href="#ServiceManagerProxy" class="headerlink" title="ServiceManagerProxy"></a>ServiceManagerProxy</h2><p>从名字就能听出来，<code>ServiceManagerProxy</code>其实是一个代理类，它其实是<code>IServiceManager.Stub.Proxy</code>的代理，实际上是没有什么必要的，可以发现作者也在注释中标注了<code>This class should be deleted and replaced with IServiceManager.Stub whenever mRemote is no longer used</code>，我们看一下它的构造方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">    mServiceManager = IServiceManager.Stub.asInterface(remote);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceManagerProxy</code>实现了<code>IServiceManager</code>接口，但这个方法的实现都是直接调用<code>mServiceManager</code>，以<code>addService</code>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这与直接使用<code>IServiceManager.Stub.asInterface(remote)</code>得到<code>IServiceManager</code>并没有什么区别</p>
<h2 id="IServiceManager"><a href="#IServiceManager" class="headerlink" title="IServiceManager"></a>IServiceManager</h2><p>我们将重点转到<code>IServiceManager</code>上，我们在源码中搜索不到<code>IServiceManager.java</code>文件，因为实际上这个文件是通过<code>aidl</code>生成的</p>
<p>关于<code>aidl</code>我们到后面再详细分析，现在我们只需要知道它其实是辅助我们进行<code>binder</code>通信的一种工具，<code>aidl</code>文件会在编译过程中生成出与之对应的<code>java</code>文件</p>
<p><code>IServiceManager</code>的<code>aidl</code>文件路径为<code>frameworks/native/libs/binder/aidl/android/os/IServiceManager.aidl</code></p>
<p>我们来看一下它生成出的<code>IServiceManager.Stub.asInterface</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.os.<span class="function">IServiceManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> android.os.IServiceManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.os.IServiceManager) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> android.os.IServiceManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们传入的<code>IBinder</code>是<code>BinderProxy</code>，它的<code>queryLocalInterface</code>永远返回<code>null</code>，所以这里返回的是<code>IServiceManager.Stub.Proxy</code>对象，我们接着看之前调用的<code>getService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">getService</span><span class="params">(java.lang.String name)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    android.os.IBinder _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        _data.writeString(name);</span><br><span class="line">        <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getService, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readStrongBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><p><code>Parcel</code>是一个存放读取数据的容器，它的基本功能和使用相信进阶<code>Android</code>开发应该都懂，我们在这里只介绍一些关键性函数的含义，其他就不多赘述了，有机会的话以后单独开一章分析它</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>obtain</td>
<td>获取一个新的Parcel对象</td>
</tr>
<tr>
<td>ipcData、data</td>
<td>数据区首地址</td>
</tr>
<tr>
<td>ipcDataSize、dataSize</td>
<td>数据大小</td>
</tr>
<tr>
<td>ipcObjects</td>
<td>偏移数组首地址</td>
</tr>
<tr>
<td>ipcObjectsCount</td>
<td>IPC对象数量</td>
</tr>
<tr>
<td>dataPosition</td>
<td>数据指针当前的位置</td>
</tr>
<tr>
<td>dataCapacity</td>
<td>数据区的总容量（始终 &gt;= dataSize）</td>
</tr>
</tbody></table>
<p>这里获取了两个<code>Parcel</code>，一个<code>_data</code>用来传递参数数据，一个<code>_reply</code>用来接收回应。接着，<code>_data</code>首先调用<code>writeInterfaceToken</code>方法，这里的<code>token</code>是客户端与服务端的一个协定，服务端会校验我们写入的这个<code>token</code>，然后按照顺序将参数依次写入到<code>_data</code>中（序列化），然后通过<code>binder</code>调用远程服务真正的方法，然后检查异常。</p>
<p>对于无返回值的方法来说，到这一步已经结束了，但我们这个方法是有返回值的，所以我们需要一个<code>_result</code>，从<code>_reply</code>中读取出数据（反序列化），赋给<code>_result</code>，然后返回出去</p>
<h2 id="BinderProxy-transact"><a href="#BinderProxy-transact" class="headerlink" title="BinderProxy.transact"></a>BinderProxy.transact</h2><p>我们重点看<code>transact</code>这一部分，通过我们之前的分析，我们知道<code>mRemote</code>是一个<code>BinderProxy</code>类型的对象，我们来看他的<code>transact</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">//检查Parcel大小</span></span><br><span class="line">    Binder.checkParcel(<span class="keyword">this</span>, code, data, <span class="string">"Unreasonably large binder buffer"</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//trace</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Binder事务处理回调</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AppOpsManager信息记录</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> result = transactNative(code, data, reply, flags);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="keyword">null</span> &amp;&amp; !warnOnBlocking) &#123;</span><br><span class="line">            reply.addFlags(Parcel.FLAG_IS_REPLY_FROM_BLOCKING_ALLOWED_OBJECT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里简化了一下代码，可以看到，首先就是对<code>Parcel</code>大小的检查</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkParcel</span><span class="params">(IBinder obj, <span class="keyword">int</span> code, Parcel parcel, String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CHECK_PARCEL_SIZE &amp;&amp; parcel.dataSize() &gt;= <span class="number">800</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">// Trying to send &gt; 800k, this is way too much.</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(msg);</span><br><span class="line">        sb.append(<span class="string">": on "</span>);</span><br><span class="line">        sb.append(obj);</span><br><span class="line">        sb.append(<span class="string">" calling "</span>);</span><br><span class="line">        sb.append(code);</span><br><span class="line">        sb.append(<span class="string">" size "</span>);</span><br><span class="line">        sb.append(parcel.dataSize());</span><br><span class="line">        sb.append(<span class="string">" (data: "</span>);</span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">", "</span>);</span><br><span class="line">        sb.append(parcel.readInt());</span><br><span class="line">        sb.append(<span class="string">")"</span>);</span><br><span class="line">        Slog.wtfStack(TAG, sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Android</code>默认设置了<code>Parcel</code>数据传输不能超过<strong>800k</strong>，当然，各个厂商是可以随意改动这里的代码的，如果超过了的话，便会调用<code>Slog.wtfStack</code>打印日志，需要注意的是，在当前进程不是系统进程并且系统也不是工程版本的情况下，这个方法是会结束进程的，所以在应用开发的时候，我们需要注意跨进程数据传输的大小，避免因此引发crash</p>
<p>省去中间的一些<code>log</code>、回调，接下来便是调用<code>transactNative</code>方法，这是一个<code>native</code>方法，实现在<code>frameworks/base/core/jni/android_util_Binder.cpp</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataObj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parcel* data = parcelForJavaObject(env, dataObj);</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply = parcelForJavaObject(env, replyObj);</span><br><span class="line">    <span class="keyword">if</span> (reply == <span class="literal">NULL</span> &amp;&amp; replyObj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="string">"Binder has been finalized!"</span>);</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, <span class="literal">true</span> <span class="comment">/*canThrowRemoteException*/</span>, data-&gt;dataSize());</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先是获得<code>native</code>层对应的<code>Parcel</code>并执行判断，<code>Parcel</code>实际上功能是在<code>native</code>中实现的，<code>java</code>中的<code>Parcel</code>类使用<code>mNativePtr</code>成员变量保存了其对应<code>native</code>中的<code>Parcel</code>的指针</p>
<p>然后调用<code>getBPNativeData</code>函数获得<code>BinderProxy</code>在<code>native</code>中对应的<code>BinderProxyNativeData</code>，再通过里面的<code>mObject</code>域成员变量得到其对应的<code>BpBinder</code>，这个函数在之前分析<code>javaObjectForIBinder</code>的时候已经出现过了</p>
<h2 id="BpBinder-transact"><a href="#BpBinder-transact" class="headerlink" title="BpBinder.transact"></a>BpBinder.transact</h2><p>之后便是调用<code>BpBinder</code>的<code>transact</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="comment">//判断binder服务是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个<code>Alive</code>判断，可以避免对一个已经死亡的<code>binder</code>服务再发起事务，浪费资源，除此之外便是调用<code>IPCThreadState</code>的<code>transact</code>函数了</p>
<h2 id="IPCThreadState"><a href="#IPCThreadState" class="headerlink" title="IPCThreadState"></a>IPCThreadState</h2><p>路径：<code>frameworks/native/libs/binder/IPCThreadState.cpp</code></p>
<p>还记得我们之前提到的<code>ProcessState</code>吗？<code>IPCThreadState</code>和它很像，<code>ProcessState</code>负责打开<code>binder</code>驱动并进行<code>mmap</code>映射，而<code>IPCThreadState</code>则是负责与<code>binder</code>驱动进行具体的交互</p>
<p><code>IPCThreadState</code>也有一个<code>self</code>函数，与<code>ProcessState</code>的<code>self</code>不同的是，<code>ProcessState</code>是进程单例，而<code>IPCThreadState</code>是线程单例，我们来看看它是怎么实现的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不是初次调用的情况</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="comment">//初次调用，生成线程私有变量key后</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">//先从线程本地储存空间中尝试获取值</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">//没有的话就实例化一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPCThreadState shutdown后不能再获取</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首次获取时gHaveTLS为false，会先走这里</span></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">//创建一个key，作为存放线程本地变量的key</span></span><br><span class="line">        <span class="keyword">int</span> key_create_value = pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(<span class="string">"IPCThreadState::self() unable to create TLS key, expect a crash: %s\n"</span>,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建完毕，gHaveTLS置为true</span></span><br><span class="line">        gHaveTLS.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">//回到gHaveTLS为true的case</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gHaveTLS</code>是一个原子类型的<code>bool</code>值，它在存取过程中需要指定内存序<code>std::memory_order_xxx</code>，在这里我们直接忽略掉，把它当成一个纯粹的<code>bool</code>值就好了</p>
<p>在这里，<code>TLS</code>的全称为<code>Thread Local Storage</code>，表示线程本地储存空间，和<code>java</code>中的<code>ThreadLocal</code>其实是一个作用</p>
<p>当一个线程初次获取<code>IPCThreadState</code>的时候，会先走到<code>gHaveTLS</code>为<code>false</code>的case，此时程序会创建一个<code>key</code>，作为存放线程本地变量的<code>key</code>，创建成功后将<code>gHaveTLS</code>置为<code>true</code>，然后<code>goto</code>到<code>gHaveTLS</code>为<code>true</code>的case，此时线程本地储存空间中暂时还是没有数据的，所以会<code>new</code>一个<code>IPCThreadState</code>出来，在<code>IPCThreadState</code>的构造函数中，会将自己保存到线程本地储存空间中，这样，当线程第二次再获取<code>IPCThreadState</code>的时候，便会直接走到<code>pthread_getspecific</code>这里获取并返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">      : mProcess(ProcessState::self()),</span><br><span class="line">        mServingStackPointer(<span class="literal">nullptr</span>),</span><br><span class="line">        mServingStackPointerGuard(<span class="literal">nullptr</span>),</span><br><span class="line">        mWorkSource(kUnsetWorkSource),</span><br><span class="line">        mPropagateWorkSource(<span class="literal">false</span>),</span><br><span class="line">        mIsLooper(<span class="literal">false</span>),</span><br><span class="line">        mIsFlushing(<span class="literal">false</span>),</span><br><span class="line">        mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">        mLastTransactionBinderFlags(<span class="number">0</span>),</span><br><span class="line">        mCallRestriction(mProcess-&gt;mCallRestriction) &#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过构造函数可以发现，它调用了<code>pthread_setspecific</code>函数将自身保存在了线程本地储存空间中</p>
<p><code>IPCThreadState</code>中，成员变量<code>mIn</code>用于接收来自<code>binder</code>设备的数据，<code>mOut</code>用于储存发往<code>binder</code>设备的数据，他们的默认容量都为<code>256字节</code></p>
<h3 id="transact"><a href="#transact" class="headerlink" title="transact"></a>transact</h3><p>我们接着看它的<code>transact</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(data.isForRpc(), <span class="string">"Parcel constructed for RPC, but being used with binder."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//log</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;    <span class="comment">//binder事务不为TF_ONE_WAY</span></span><br><span class="line">        <span class="comment">//当线程限制binder事务不为TF_ONE_WAY时</span></span><br><span class="line">        <span class="keyword">if</span> (UNLIKELY(mCallRestriction != ProcessState::CallRestriction::NONE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallRestriction == ProcessState::CallRestriction::ERROR_IF_NOT_ONEWAY) &#123;</span><br><span class="line">                <span class="comment">//这个限制只是log记录</span></span><br><span class="line">                ALOGE(<span class="string">"Process making non-oneway call (code: %u) but is restricted."</span>, code);</span><br><span class="line">                CallStack::logStack(<span class="string">"non-oneway call"</span>, CallStack::getCurrent(<span class="number">10</span>).get(),</span><br><span class="line">                    ANDROID_LOG_ERROR);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="comment">/* FATAL_IF_NOT_ONEWAY */</span> &#123;</span><br><span class="line">                <span class="comment">//这个限制会终止线程</span></span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Process may not make non-oneway calls (code: %u)."</span>, code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//log</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的重点在于<code>writeTransactionData</code>和<code>waitForResponse</code>，我们依次分析</p>
<h4 id="writeTransactionData"><a href="#writeTransactionData" class="headerlink" title="writeTransactionData"></a>writeTransactionData</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    <span class="comment">//目标binder句柄值，ServiceManager为0</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//数据大小</span></span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        <span class="comment">//数据区起始地址</span></span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        <span class="comment">//传递的偏移数组大小</span></span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        <span class="comment">//偏移数组的起始地址</span></span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里为BC_TRANSACTION</span></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在分析这个函数之前，我们需要先回忆一下在前面<code>binder</code>驱动章节我们所学习的<code>binder</code>结构和通信过程：<a href="https://juejin.cn/post/7069675794028560391#heading-13" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a></p>
<p><code>binder_tansaction</code>首先会读取一个请求码<code>cmd</code>，当<code>binder</code>请求码为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>的时候，<code>binder</code>驱动所接收的参数为<code>binder_transaction_data</code>结构体，所以在这个函数中，我们将<code>binder</code>请求码（这里为<code>BC_TRANSACTION</code>）和<code>binder_transaction_data</code>结构体依次写入到<code>mOut</code>中，为之后<code>binder_tansaction</code>做准备</p>
<h4 id="waitForResponse"><a href="#waitForResponse" class="headerlink" title="waitForResponse"></a>waitForResponse</h4><p>数据准备好后，接着便来到了<code>waitForResponse</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_ONEWAY_SPAM_SUSPECT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_FROZEN_REPLY:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//这里是binder服务端部分的处理，现在不需要关注</span></span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">        logExtendedError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个循环，正如函数名所描述，会一直等待到一整条<code>binder</code>事务链结束返回后才会退出这个循环，在这个循环的开头，便是<code>talkWithDriver</code>方法</p>
<h5 id="talkWithDriver"><a href="#talkWithDriver" class="headerlink" title="talkWithDriver"></a>talkWithDriver</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//检查打开的binder设备的fd</span></span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">//dataPosition &gt;= dataSize说明上一次读取到的数据已经消费完</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">//需要写的数据大小，这里的doReceive默认为true，如果上一次的数据还没读完，则不会写入任何内容</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">//将read_size设置为读缓存可用容量</span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        <span class="comment">//设置读缓存起始地址</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="comment">//没有要读写的数据就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//调用binder驱动的ioctl</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">//写数据被消费了</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//写数据没有被消费完</span></span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                LOG_ALWAYS_FATAL(<span class="string">"Driver did not consume write buffer. "</span></span><br><span class="line">                                 <span class="string">"err: %s consumed: %zu of %zu"</span>,</span><br><span class="line">                                 statusToString(err).c_str(),</span><br><span class="line">                                 (<span class="keyword">size_t</span>)bwr.write_consumed,</span><br><span class="line">                                 mOut.dataSize());</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//写数据消费完了，将数据大小设置为0，这样下次就不会再写数据了</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到了数据</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//设置数据大小及数据指针偏移，这样后面就可以从中读取出来数据了</span></span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>binder_write_read</code>也是一个我们熟悉的结构，我们在之前的文章<a href="https://juejin.cn/post/7069675794028560391#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>中了解过，关于<code>binder</code>通信的代码，我们需要结合着<code>binder</code>驱动一起看才能理解</p>
<p>在<code>binder</code>驱动层中，<code>binder_ioctl_write_read</code>函数会从用户空间读取一个<code>binder_write_read</code>结构，这个结构体主要描述了数据传输的大小和位置以及消费情况（已读/写数据大小），这么看来，<code>talkWithDriver</code>函数的结构就很清晰了：</p>
<ol>
<li><p>创建出<code>binder_write_read</code>结构，根据之前的读取情况，决定是否读写数据，设置写数据内容和大小，设置读数据的空间和容量</p>
</li>
<li><p>调用<code>binder</code>驱动的<code>ioctl</code></p>
</li>
<li><p>重置写缓存，根据<code>ioctl</code>的结果设置读缓存</p>
</li>
</ol>
<p>这之后，<code>waitForResponse</code>函数就可以从读缓存<code>mIn</code>中读到数据了，我们回到这个函数中，发现它首先从读缓存中读取了一个<code>binder</code>响应码，然后根据这个响应码再处理接下来的工作</p>
<h5 id="处理Reply"><a href="#处理Reply" class="headerlink" title="处理Reply"></a>处理Reply</h5><p>在此之前，我们先回顾一下一次<code>binder_tansaction</code>的整个过程，根据事务类型，分为两种情况：</p>
<ul>
<li><code>TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_oneway.png" alt="binder_oneway"></p>
<ul>
<li><code>非 TF_ONE_WAY</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Framework%E5%B1%82%E7%9A%84Binder%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AF%87%EF%BC%89_non_oneway.png" alt="binder_non_oneway"></p>
<p>我们先对照着看<code>TF_ONE_WAY</code>的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="comment">//当TF_ONE_WAY模式下收到BR_TRANSACTION_COMPLETE直接返回，本次binder通信结束</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>TF_ONE_WAY</code>模式来说，客户端在收到<code>BR_TRANSACTION_COMPLETE</code>响应码后则返回，不会再等待<code>BR_REPLY</code></p>
<p>而对于非<code>TF_ONE_WAY</code>模式来说，客户端不仅会收到<code>BR_TRANSACTION_COMPLETE</code>响应码，之后还会阻塞等待<code>binder</code>驱动给它发来<code>BR_REPLY</code>响应码，这之后一次<code>binder_transaction</code>才算完成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="comment">//失败直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;    <span class="comment">//客户端需要接收replay</span></span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;    <span class="comment">//正常reply内容</span></span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer <span class="comment">/*释放缓冲区*/</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//内容只是一个32位的状态码</span></span><br><span class="line">                        <span class="comment">//接收状态码</span></span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="comment">//释放缓冲区</span></span><br><span class="line">                        freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;    <span class="comment">//客户端不需要接收replay</span></span><br><span class="line">                    <span class="comment">//释放缓冲区</span></span><br><span class="line">                    freeBuffer(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，非<code>TF_ONE_WAY</code>模式肯定是需要一个<code>reply</code>来接收的，即<code>reply != null</code>，此时我们来看看接收正常<code>reply</code>的过程（接收32位状态码没什么好说的，直接从读缓冲区中强制类型转换出一个32位的code就完事了）</p>
<p>这里我们就需要看一下<code>Parcel</code>的<code>ipcSetDataReference</code>函数了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize, <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">size_t</span> objectsCount, release_func relFunc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this code uses 'mOwner == nullptr' to understand whether it owns memory</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(relFunc == <span class="literal">nullptr</span>, <span class="string">"must provide cleanup function"</span>);</span><br><span class="line">    <span class="comment">//先清理重置一下数据和状态</span></span><br><span class="line">    freeData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* kernelFields = maybeKernelFields();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(kernelFields == <span class="literal">nullptr</span>); <span class="comment">// guaranteed by freeData.</span></span><br><span class="line"></span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    kernelFields-&gt;mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects);</span><br><span class="line">    kernelFields-&gt;mObjectsSize = kernelFields-&gt;mObjectsCapacity = objectsCount;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kernelFields-&gt;mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = kernelFields-&gt;mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span> PRIu64 <span class="string">" &lt; %"</span> PRIu64 <span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* flat</span><br><span class="line">            = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData + offset);</span><br><span class="line">        <span class="keyword">uint32_t</span> type = flat-&gt;hdr.type;</span><br><span class="line">        <span class="comment">//binder类型出现异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(type == BINDER_TYPE_BINDER || type == BINDER_TYPE_HANDLE ||</span><br><span class="line">              type == BINDER_TYPE_FD)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            kernelFields-&gt;mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个函数也不复杂，我们知道<code>binder_mmap</code>做到了一次拷贝，将数据拷贝到了内核物理内存中，然后将其与用户空间虚拟内存做了映射，所以这个函数此时只需要将数据的地址，大小等等无脑赋值进去，客户端后续便可以用<code>Parcel</code>提供的函数方便的从中读取数据了</p>
<h5 id="freeBuffer"><a href="#freeBuffer" class="headerlink" title="freeBuffer"></a>freeBuffer</h5><p>最后我们再来看一下<code>freeBuffer</code>这个释放缓冲区的方法，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::freeBuffer</span><span class="params">(Parcel* parcel, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*dataSize*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* <span class="comment">/*objects*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> <span class="comment">/*objectsSize*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">nullptr</span>) parcel-&gt;closeFileDescriptors();</span><br><span class="line">    IPCThreadState* state = self();</span><br><span class="line">    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.writePointer((<span class="keyword">uintptr_t</span>)data);</span><br><span class="line">    state-&gt;flushIfNeeded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里向<code>binder</code>驱动发送了一个<code>BC_FREE_BUFFER</code>请求，然后<code>binder</code>驱动会负责回收这块缓冲区内存</p>
<p>我们在<code>Parcel::ipcSetDataReference</code>函数中可以发现，它将<code>freeBuffer</code>函数指针赋值给了<code>mOwner</code>，等到什么时候不需要这个<code>Parcel</code>了，便会调用这个函数进行缓冲区内存回收</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里，我们客户端与<code>binder</code>驱动沟通交互的分析就结束了，相比<code>binder</code>驱动而言，<code>framework</code>层的<code>binder</code>就好理解多了，下一章我们会从服务端的角度来看，它是怎么从<code>binder</code>驱动接收并处理客户端的请求的</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/04/07/android/jetpack/compose/JetpackCompose%E5%85%A5%E9%97%A8/">Jetpack Compose入门</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-07</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Jetpack-Compose/">Jetpack Compose</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Jetpack-Compose/">Jetpack Compose</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Jetpack Compose</code>是用于构建原生<code>Android</code>界面的新工具包。它是一种声明式的UI布局，其官方声称可简化并加快<code>Android</code>上的界面开发，使用更少的代码、强大的工具和直观的<code>Kotlin API</code>，快速让应用生动而精彩。</p>
<p>官网：<a href="https://developer.android.com/jetpack/compose?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose?hl=zh-cn</a></p>
<p>我这里也写了一个<code>Compose</code>的<code>Demo</code>，可以对照着看：<a href="https://github.com/dreamgyf/ComposeDemo" target="_blank" rel="noopener">https://github.com/dreamgyf/ComposeDemo</a></p>
<p>这个<code>Demo</code>实现了：</p>
<ul>
<li><code>Compose</code>替代传统布局</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E6%9B%BF%E4%BB%A3%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80.png" alt="Compose替代传统布局"></p>
<ul>
<li>网格列表效果，类似于传统布局中的<code>RecyclerView</code>配合<code>GridLayoutManager</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E7%BD%91%E6%A0%BC%E5%88%97%E8%A1%A8%E6%95%88%E6%9E%9C.png" alt="网格列表"></p>
<ul>
<li><p>在传统View中使用Compose</p>
</li>
<li><p>在Compose中使用传统View</p>
</li>
<li><p>自定义布局</p>
</li>
</ul>
<h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><p>使用<code>Jetpack Compose</code>需要先引入一些依赖：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'androidx.core:core-ktx:1.7.0'</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.ui:ui:$compose_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.material:material:$compose_version"</span></span><br><span class="line">    implementation <span class="string">"androidx.compose.ui:ui-tooling-preview:$compose_version"</span></span><br><span class="line">    implementation <span class="string">'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'</span></span><br><span class="line">    implementation <span class="string">'androidx.activity:activity-compose:1.3.1'</span></span><br><span class="line">    debugImplementation <span class="string">"androidx.compose.ui:ui-tooling:$compose_version"</span></span><br><span class="line">	<span class="comment">//网络图片加载三方库</span></span><br><span class="line">    implementation <span class="string">"io.coil-kt:coil-compose:1.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可组合函数"><a href="#可组合函数" class="headerlink" title="可组合函数"></a>可组合函数</h1><p><code>Jetpack Compose</code>是围绕着可组合函数构建起来的，这些函数以程序化方式定义应用的界面，只需描述应用界面的外观并提供数据依赖项，而不必关注界面的构建过程。此类函数有几个要点：</p>
<ul>
<li>所有可组合函数必须使用<code>@Composable</code>注解修饰</li>
<li>可组合函数可以像正常函数一样接受参数</li>
</ul>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    Text(text = <span class="string">"Hello, <span class="subst">$&#123;name&#125;</span>!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可组合函数内部可以书写正常代码（譬如可以通过<code>if else</code>控制显示的控件）</li>
</ul>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(showPic: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (showPic) &#123;</span><br><span class="line">    	Image(</span><br><span class="line">            painter = painterResource(id = R.drawable.demo),</span><br><span class="line">            contentDescription = <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    Text(text = <span class="string">"Hello, compose!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h1><p><code>Android</code>常用的单位<code>dp</code>，<code>sp</code>等，在<code>Compose</code>中以类的形式被定义，使用的方式也很简单，<code>Compose</code>借助了<code>kotlin</code>的扩展属性，扩展了<code>Int</code>，<code>Double</code>，<code>Float</code>三个基础类，使用方式如下：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp</span></span><br><span class="line"><span class="number">1</span>.dp; <span class="number">2.3f</span>.dp; <span class="number">4.5</span>.dp</span><br><span class="line"><span class="comment">//sp</span></span><br><span class="line"><span class="number">1</span>.sp; <span class="number">2.3f</span>.sp; <span class="number">4.5</span>.sp</span><br></pre></td></tr></table></figure>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>如何在<code>Compose</code>中使用资源呢，可以通过<code>xxxResource</code>方法</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">painterResource</span><span class="params">(<span class="meta">@DrawableRes</span> id: <span class="type">Int</span>)</span></span>: Painter</span><br><span class="line"><span class="comment">//尺寸资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">dimensionResource</span><span class="params">(<span class="meta">@DimenRes</span> id: <span class="type">Int</span>)</span></span>: Dp</span><br><span class="line"><span class="comment">//颜色资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">colorResource</span><span class="params">(<span class="meta">@ColorRes</span> id: <span class="type">Int</span>)</span></span>: Color</span><br><span class="line"><span class="comment">//字符串资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">stringResource</span><span class="params">(<span class="meta">@StringRes</span> id: <span class="type">Int</span>)</span></span>: String</span><br><span class="line"><span class="comment">//字体资源</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fontResource</span><span class="params">(fontFamily: <span class="type">FontFamily</span>)</span></span>: Typeface</span><br></pre></td></tr></table></figure>

<h1 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h1><p><code>Modifier</code>是<code>Compose</code>中的布局修饰符，它控制了布局的大小，padding，对齐，背景，边框，裁切，点击等属性，几乎所有的<code>Compose</code>布局都需求这项参数，是<code>Compose</code>布局中的重中之重</p>
<p>这里介绍一些常用的基本属性，文中没列到的属性可以去官网查看：<a href="https://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/jetpack/compose/modifiers-list?hl=zh-cn</a></p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><ul>
<li><code>fillMaxWidth</code>和<code>fillMaxHeight</code>相当于<code>xml</code>布局中的<code>match_parent</code></li>
<li><code>fillMaxSize</code>相当于同时设置了<code>fillMaxWidth</code>和<code>fillMaxHeight</code></li>
<li><code>wrapContentWidth</code>和<code>wrapContentHeight</code>相当于<code>xml</code>布局中的<code>wrapContent</code></li>
<li><code>wrapContentSize</code>相当于同时设置了<code>wrapContentWidth</code>和<code>wrapContentHeight</code></li>
<li><code>width</code>和<code>height</code>则是设置固定宽高，单位为<code>Dp</code></li>
<li><code>size</code>相当于同时设置了<code>width</code>和<code>height</code></li>
<li><code>weight</code>属性仅在<code>Row</code>或<code>Column</code>的内部作用域中可以使用，相当于传统<code>LinearLayout</code>布局中的<code>weight</code>属性</li>
</ul>
<h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><p><code>padding</code>方法有几个重载，这些<code>API</code>很简单，看参数就很容易能明白意思</p>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p><code>align</code>属性，使控件可以在父布局中以一种方式对齐，相当于<code>xml</code>布局中的layout_gravity属性。另外还有<code>alignBy</code>以及<code>alignByBaseline</code>属性可以自行研究</p>
<h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><ul>
<li><code>background</code>设置背景，不过不能设置图片，如果想以图片作为背景可以使用<code>Box</code>布局，在底部垫一个<code>Image</code>控件</li>
<li><code>alpha</code>设置透明度</li>
<li><code>clip</code>裁剪内容，这个功能很强大，可以直接将视图裁出圆角，圆形等形状</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul>
<li><code>clickable</code>方法，可以设置控件的点击事件回调</li>
<li><code>combinedClickable</code>方法，可以设置控件的点击、双击、长按事件回调</li>
<li><code>selectable</code>方法，将控件配置为可点击，同时可以设置点击事件</li>
</ul>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><ul>
<li><code>horizontalScroll</code>：使控件支持水平滚动</li>
<li><code>verticalScroll</code>：使控件支持垂直滚动</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在<code>Modifier</code>中设置属性的前后顺序是很重要的，譬如想要一个背景为蓝色的圆角布局，需要先设置<code>clip</code>，再设置<code>background</code>，反过来<code>background</code>会超出圆角范围</p>
<h1 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h1><p><code>Compose</code>中没有了<code>margin</code>的概念，可以用<code>Spacer</code>替代，<code>Spacer</code>为留白的意思，使用起来也很简单</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//水平间隔8dp</span></span><br><span class="line">Spacer(modifier = Modifier.width(<span class="number">8</span>.dp))</span><br></pre></td></tr></table></figure>

<h1 id="基础布局"><a href="#基础布局" class="headerlink" title="基础布局"></a>基础布局</h1><h2 id="Row-amp-Column"><a href="#Row-amp-Column" class="headerlink" title="Row &amp; Column"></a>Row &amp; Column</h2><p>这是两个基本布局组件，其中<code>Row</code>为水平布局，<code>Column</code>为垂直布局，他们俩接受的参数相似，其中两个参数为<code>horizontalArrangement</code>和<code>verticalAlignment</code>，他们一个表示水平布局方式，一个表示垂直布局方式，他们默认值为<code>START</code>和<code>TOP</code>，这两个参数用起来就和传统布局的<code>gravity</code>参数一样</p>
<h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p><code>Box</code>也是一种基本布局组件，<code>Box</code>布局中的组件是可以叠加的，类似传统布局中的<code>FrameLayout</code>，可以通过<code>contentAlignment</code>参数调整叠加的方式，其默认值为<code>TopStart</code>，叠加到左上角，这个参数也和<code>FrameLayout</code>的<code>gravity</code>参数一样</p>
<h1 id="基础控件"><a href="#基础控件" class="headerlink" title="基础控件"></a>基础控件</h1><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>文本控件，对应传统控件TextView，它有以下一些属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>文本内容</td>
</tr>
<tr>
<td>color</td>
<td>文字颜色</td>
</tr>
<tr>
<td>fontSize</td>
<td>文字大小</td>
</tr>
<tr>
<td>fontStyle</td>
<td>文本样式（可以设置斜体）</td>
</tr>
<tr>
<td>fontWeight</td>
<td>字重（粗体等）</td>
</tr>
<tr>
<td>fontFamily</td>
<td>字体</td>
</tr>
<tr>
<td>letterSpacing</td>
<td>文字间距</td>
</tr>
<tr>
<td>textAlign</td>
<td>文本对齐方式</td>
</tr>
<tr>
<td>lineHeight</td>
<td>行高</td>
</tr>
<tr>
<td>maxLines</td>
<td>最大行数</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>图片控件，对应传统控件ImageView，它有以下一些属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>painter</td>
<td>图片内容</td>
</tr>
<tr>
<td>contentDescription</td>
<td>无障碍描述（可为null）</td>
</tr>
<tr>
<td>alignment</td>
<td>对齐方式</td>
</tr>
<tr>
<td>contentScale</td>
<td>缩放方式（和scaleType属性类似）</td>
</tr>
<tr>
<td>alpha</td>
<td>透明度</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>在开发中经常会面对从网络价值图片的情况，这时候可以借助一些第三方库来解决，这里以coil库为例：</p>
<ol>
<li>先添加依赖</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"io.coil-kt:coil-compose:1.4.0"</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用</li>
</ol>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Image(</span><br><span class="line">	modifier = Modifier</span><br><span class="line">		.size(<span class="number">68</span>.dp, <span class="number">68</span>.dp)</span><br><span class="line">		.clip(RoundedCornerShape(<span class="number">6</span>.dp)),</span><br><span class="line">	contentScale = ContentScale.Crop,</span><br><span class="line">    painter = rememberImagePainter(picUrl), <span class="comment">//使用rememberImagePainter方法填入图片url</span></span><br><span class="line">    contentDescription = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><code>Compose</code>有两种组件<code>LazyRow</code>和<code>LazyColumn</code>，一种水平，一种垂直，对应着传统UI中的<code>RecyclerView</code>，用这些组件可以方便的构建列表视图，它们需要提供一个<code>LazyListScope.()</code>块描述列表项内容</p>
<p><code>LazyListScope</code>的<code>DSL</code>提供了多种函数来描述列表项：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于添加单个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">item</span><span class="params">(key: <span class="type">Any</span>? = <span class="literal">null</span>, content: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.() -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">//用于添加多个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">items</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        count: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        key: ((<span class="type">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Any</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        itemContent: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.(<span class="type">index</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br><span class="line"><span class="comment">//用于添加多个列表项</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> LazyListScope.<span class="title">items</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    items: <span class="type">List</span>&lt;<span class="type">T</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> key: ((<span class="type">item</span>: <span class="type">T</span>) -&gt; <span class="type">Any</span>)? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> itemContent: @<span class="type">Composable</span> <span class="type">LazyItemScope</span>.(<span class="type">item</span>: <span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">LazyColumn &#123;</span><br><span class="line">    <span class="comment">//增加单个列表项</span></span><br><span class="line">    item &#123;</span><br><span class="line">        Text(text = <span class="string">"First item"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加5个列表项</span></span><br><span class="line">    items(<span class="number">5</span>) &#123; index -&gt;</span><br><span class="line">        Text(text = <span class="string">"Item: <span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加5个列表项</span></span><br><span class="line">    items(list) &#123; listItem -&gt;</span><br><span class="line">		Text(text = <span class="string">"Item: <span class="variable">$listItem</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加单个列表项</span></span><br><span class="line">    item &#123;</span><br><span class="line">        Text(text = <span class="string">"Last item"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用<code>contentPadding</code>为内容添加内边距，使用<code>verticalArrangement</code>或<code>horizontalArrangement</code>，以<code>Arrangement.spacedBy()</code>为列表项之间添加间距</p>
<h1 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h1><p>在<code>Compose</code>中，数据的更新和传统命令式UI不同，是通过一种可观察类型对象，当一个可观察类型对象发生改变时，这个对象对应观察的部分会发生重组，从而自动更新UI</p>
<p>可观察类型<code>MutableState&lt;T&gt;</code>通常是通过<code>mutableStateOf()</code>函数创建的，这个对象的<code>value</code>发生变化时，对应UI也会跟着随之变化</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了kotlin的by关键字，是一种代理模式</span></span><br><span class="line"><span class="comment">//如果使用 = 的话，这个对象的类型会发生变化，需要count.value这样使用它的值</span></span><br><span class="line"><span class="comment">//var count = mutableStateOf(0)</span></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">by</span> mutableStateOf(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">(count: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"count: <span class="subst">$&#123;count&#125;</span>"</span>)</span><br><span class="line">        Button(onClick = &#123; addCount() &#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">"add count"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addCount</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//++count.value</span></span><br><span class="line">    ++count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Preview</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//当点击Button时，触发点击事件，更新可观察对象count，触发UI重组</span></span><br><span class="line">    <span class="comment">//Demo(count.value)</span></span><br><span class="line">    Demo(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="关于Context"><a href="#关于Context" class="headerlink" title="关于Context"></a>关于Context</h1><p>在<code>Compose</code>中可以通过<code>LocalContext.current</code>获得当前<code>Context</code></p>
<h1 id="在传统View中使用Compose"><a href="#在传统View中使用Compose" class="headerlink" title="在传统View中使用Compose"></a>在传统View中使用Compose</h1><p>可以在一个传统布局<code>xml</code>中插入一个<code>ComposeView</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/hello_world"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Hello from XML layout"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插入ComposeView --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.compose.ui.platform.ComposeView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/compose_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在代码中设置这个<code>ComposeView</code></p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findViewById&lt;ComposeView&gt;(R.id.compose_view).setContent &#123;</span><br><span class="line">	Text(<span class="string">"Hello Compose!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在Compose中使用传统View"><a href="#在Compose中使用传统View" class="headerlink" title="在Compose中使用传统View"></a>在Compose中使用传统View</h1><p>可以使用<code>AndroidView</code>这个<code>composable</code>函数，这个函数接受一个<code>factory</code>参数，这个参数接受一个<code>Context</code>，用于构建传统<code>View</code>，要求返回一个继承自<code>View</code>的对象</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"Compose Text"</span>)</span><br><span class="line">        AndroidView(factory = &#123; context -&gt;</span><br><span class="line">            <span class="comment">//这里也可以使用LayoutInflater从xml中解析出一个View</span></span><br><span class="line">            TextView(context).apply &#123;</span><br><span class="line">                text = <span class="string">"传统TextView"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义UI"><a href="#自定义UI" class="headerlink" title="自定义UI"></a>自定义UI</h1><p>在<code>Compose</code>中，如果想要自定义一些简单的UI是很简单的，只需要写一个<code>Composable</code>函数就可以了，我们主要学习一下怎么自定义一些复杂的UI</p>
<p>我们先看一下怎么自定义一个布局，对应着传统UI中的<code>ViewGroup</code>，以一个简单的例子来说，我们自定义一个布局，让其中的子布局呈左上到右下依次排列：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MyLayout</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier, content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Layout(modifier = modifier, content = content) &#123; measurables, constraints -&gt;</span><br><span class="line">        <span class="comment">//测量每个子布局</span></span><br><span class="line">        <span class="keyword">val</span> placeables = measurables.map &#123; measurable -&gt;</span><br><span class="line">            measurable.measure(constraints)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置布局大小为最大可容纳大小</span></span><br><span class="line">        layout(constraints.maxWidth, constraints.maxHeight) &#123;</span><br><span class="line">            <span class="keyword">var</span> xPosition = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> yPosition = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//放置每个子View</span></span><br><span class="line">            placeables.forEach &#123; placeable -&gt;</span><br><span class="line">                placeable.placeRelative(x = xPosition, y = yPosition)</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下一个子View的坐标为上一个子View的右下角</span></span><br><span class="line">                xPosition += placeable.width</span><br><span class="line">                yPosition += placeable.height</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一个使用<code>Canvas</code>自定义<code>View</code>的方式，这个更简单，就是画一条水平线：</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint(<span class="meta-string">"ModifierParameter"</span>)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">HorizontalLine</span><span class="params">(modifier: <span class="type">Modifier</span> = Modifier.fillMaxWidth()</span></span>) &#123;</span><br><span class="line">    Canvas(modifier = Modifier</span><br><span class="line">        .then(modifier), onDraw = &#123;</span><br><span class="line">        drawLine(color = Color.Black, Offset(<span class="number">0f</span>, <span class="number">0f</span>), Offset(size.width, <span class="number">0f</span>), <span class="number">2f</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将两者一起用一下看看效果</p>
<figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Preview(showBackground = true)</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Preview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    MyLayout &#123;</span><br><span class="line">        Text(text = <span class="string">"Text1"</span>)</span><br><span class="line">        HorizontalLine(Modifier.width(<span class="number">50</span>.dp))</span><br><span class="line">        Text(text = <span class="string">"Text2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Jetpack%20Compose%E5%85%A5%E9%97%A8_%E8%87%AA%E5%AE%9A%E4%B9%89Layout.png" alt="效果图"></p>
<p>其实<code>Compose</code>中的自定义UI的思路和传统自定义<code>View</code>是一样的，只不过需要熟悉<code>Compose</code>中的各种<code>Api</code>才能灵活运用它</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/31/linux/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Linux信号机制及其原理分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E4%BF%A1%E5%8F%B7/">信号</a></span><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在最近在工作中，使用到了信号的相关知识，之前我们在分析<code>Android</code>系统<code>init</code>进程的时候也提到了信号，但并没有对信号这个机制做出深入的理解，借此机会，我们深入分析一下<code>Linux</code>信号机制是怎样实现的</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>信号（<code>signal</code>），是<code>Unix</code>系统中的一种古老的进程间通信机制，而<code>Linux</code>作为类<code>Unix</code>系统，早期也是模仿了<code>Unix</code>系统，自然也保留下了这个机制。信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟</p>
<p><strong>注：本篇文章基于glibc版本2.35，Linux内核版本5.17，x86_64架构</strong></p>
<h1 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h1><p>信号可以由内核产生，也可以由用户产生，这边举几个例子：</p>
<ul>
<li><p>用户在终端输入<code>ctrl + c</code>时，会产生一个<code>SIGINT</code>信号</p>
</li>
<li><p>在程序中对一个数除0，会产生一个异常，最终由内核产生一个<code>SIGFPE</code>信号</p>
</li>
<li><p>在程序中非法访问一段内存，会由内核产生一个<code>SIGBUS</code>信号</p>
</li>
<li><p>在终端或程序中手动发送一个信号</p>
<ul>
<li><p>终端：比如说<code>kill -9 [pid]</code></p>
</li>
<li><p>程序：调用<code>kill</code>函数，<code>raise</code>函数等</p>
</li>
</ul>
</li>
</ul>
<h1 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h1><p>在<code>Linux</code>中，信号被分为不可靠信号和可靠信号，一共64种，可以通过<code>kill -l</code>命令来查看</p>
<ul>
<li><p>不可靠信号：也称为非实时信号，不支持排队，信号可能会丢失，比如发送多次相同的信号，进程只能收到一次，信号值取值区间为1~31</p>
</li>
<li><p>可靠信号：也称为实时信号，支持排队，信号不会丢失，发多少次，就可以收到多少次，信号值取值区间为32~64</p>
</li>
</ul>
<p>在早期的<code>Linux</code>中，只定义了前面的不可靠信号，随着时间的发展，发现有必要对信号机制加以改进和扩充，又由于原先定义的信号已有应用，出于兼容性考虑，不能再做改动，于是又新增了一部分信号，这些信号被定义为可靠信号。</p>
<p>在<code>arch/x86/include/uapi/asm/signal.h</code>中，我们可以发现这些信号的定义，在文末的附录中，我们也详细介绍了每个信号的含义和默认动作</p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>我一向认为，如果想要理解一个技术原理，首先我们必须要会使用这个技术</p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>之前提过，用户是可以手动向一个进程发送信号的，我们可以使用以下一些函数：</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/kill.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/kill.2.html</a></p>
<p>这个函数的作用是向指定进程（或进程组）发送一个信号，成功返回0，失败返回-1</p>
<p>其中的<code>pid</code>参数：</p>
<ul>
<li><p>当<code>pid &gt; 0</code>时，发送信号给pid对应的进程</p>
</li>
<li><p>当<code>pid = 0</code>时，发送信号给本进程组中的所有进程</p>
</li>
<li><p>当<code>pid = -1</code>时，发送信号给所有调用进程有权给其发送信号的进程，除了init进程</p>
</li>
<li><p>当<code>pid &lt; -1</code>时，发送信号给进程组id为<code>-pid</code>的所有进程</p>
</li>
</ul>
<p>当<code>sig</code>参数为0时，不会发送任何信号，但仍然会进行参数检测，我们可以用这种方法检查<code>pid</code>对应进程是否存在或允许发送信号</p>
<h3 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/raise.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/raise.3.html</a></p>
<p>这个函数的作用是向本进程或线程发送信号，成功返回0，失败返回-1</p>
<p>这个函数对于主线程来说，相当于<code>kill(getpid(), sig)</code>，对于子线程来说，相当于<code>pthread_kill(pthread_self(), sig)</code></p>
<h3 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a>sigqueue</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigqueue.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigqueue.3.html</a></p>
<p>这个函数的作用是向一个进程发送信号，同时可以传递一些额外数据，成功返回0，失败返回-1</p>
<p>这个函数和<code>kill</code>不同的地方是，它只能向一个进程发送信号，不能发送给信号组，当<code>sig</code>为0时，行为和<code>kill</code>一致</p>
<h3 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">noreturn <span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man3/abort.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/abort.3.html</a></p>
<p>这个函数的作用是向本进程发送<code>SIGABRT</code>信号</p>
<p>需要注意的有两点：</p>
<ul>
<li><p><code>abort</code>函数会首先解除进程对<code>SIGABRT</code>信号的阻塞</p>
</li>
<li><p>无论<code>SIGABRT</code>信号是否注册了自定义处理器，最后都会终止进程，因为<code>abort</code>函数会在<code>SIGABRT</code>信号处理完后恢复默认信号处理方式，然后重发这个信号</p>
</li>
</ul>
<h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/alarm.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/alarm.2.html</a></p>
<p>这个函数的作用是在<code>seconds</code>秒后向本进程发送<code>SIGALRM</code>信号</p>
<p>参数<code>seconds</code>为时间，单位为秒</p>
<p>返回值，如果以前没有设置过<code>alarm</code>或超时，则返回0，如果以前没有设置过<code>alarm</code>，则返回剩余的时间</p>
<h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>我们是可以自定义一些信号的处理方式，需要注意的是，<code>SIGKILL</code>和<code>SIGSTOP</code>是两个特殊的信号，它们不允许被忽略、处理和阻塞</p>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct sigaction *<span class="keyword">restrict</span> oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>这是较新的一个信号处理函数，它的作用是，对一个信号注册一个新的信号处理方式，并获取以前的信号处理方式，成功返回0，失败返回-1</p>
<p>第一个参数<code>signum</code>，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>用来指定注册的新的信号处理方式</p>
<p>第三个参数<code>oldact</code>不为<code>null</code>时，可以用来获取该信号原来的处理方式</p>
<p>当参数<code>act</code>为<code>null</code>，<code>oldact</code>不为<code>null</code>时，这个函数可以用来只获取信号当前的处理方式</p>
<h4 id="sigaction结构体"><a href="#sigaction结构体" class="headerlink" title="sigaction结构体"></a>sigaction结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">	  <span class="keyword">__sighandler_t</span> _sa_handler;</span><br><span class="line">	  <span class="keyword">void</span> (*_sa_sigaction)(<span class="keyword">int</span>, struct siginfo *, <span class="keyword">void</span> *);</span><br><span class="line">	&#125; _u;</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">__signalfn_t</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__signalfn_t</span> __user *<span class="keyword">__sighandler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_handler	_u._sa_handler</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sa_sigaction	_u._sa_sigaction</span></span><br></pre></td></tr></table></figure>

<p>可以看到，其中有一个联合，它是用来兼容旧版本函数的，当参数<code>sa_mask</code>中含有<code>SA_SIGINFO</code>的时候，回调的是<code>_sa_sigaction</code>函数，当没有这个参数时，回调的是<code>_sa_handler</code>这个旧版本函数</p>
<p><code>_sa_sigaction</code>函数相对于<code>_sa_handler</code>函数而言，多携带了一些信号信息，譬如说发送信号的进程<code>pid</code></p>
<p><code>_sa_handler</code>可以被赋值成<code>SIG_DFL</code>或<code>SIG_IGN</code>，它们分别对应着默认处理和忽略信号，需要注意的时，它们只是一个<code>int</code>值，是不能被直接调用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL	((__force __sighandler_t)0)	<span class="comment">/* default signal handling */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN	((__force __sighandler_t)1)	<span class="comment">/* ignore signal */</span></span></span><br></pre></td></tr></table></figure>

<p>这个结构体中的<code>sa_mask</code>域为一个信号集，表示当正在执行信号处理函数的时候，阻塞一些信号，只有这个信号处理完了，这些信号才会被处理</p>
<p>这个结构体中的<code>sa_flags</code>域，有如下一些标志：</p>
<ul>
<li><p><code>SA_NOCLDSTOP</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程暂停或恢复时，父进程不会收到<code>SIGCHLD</code>信号</p>
</li>
<li><p><code>SA_NOCLDWAIT</code>：当<code>signum</code>为<code>SIGCHLD</code>的时候才生效，当子进程退出时，父进程不会收到<code>SIGCHLD</code>信号，子进程也不会成为僵尸进程</p>
</li>
<li><p><code>SA_NODEFER</code>：一般情况下，当信号处理函数运行时，内核将阻塞对应的信号。但是如果设置了<code>SA_NODEFER</code>标记，那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p><code>SA_ONSTACK</code>：表示使用一个备用栈，当发生栈溢出时，内核会发出<code>SIGILL</code>信号，如果此时在原来的栈上调用信号处理函数，也会发生栈溢出，导致死循环，此时就需要准备一个备用栈，在备用栈上处理信号</p>
</li>
<li><p><code>SA_RESETHAND</code>：表示设置的信号处理行为只生效一次，当触发我们设置的信号处理函数后，内核会将信号处理行为重置（<code>SA_ONESHOT</code>作用相同，但它是一个过时的，非标准的<code>flag</code>）</p>
</li>
<li><p><code>SA_RESTART</code>：当执行系统调用时，如果收到一个信号，系统默认将中断这个系统调用，转而执行信号处理函数，结束后让这个被中断的系统调用失败，设置了<code>SA_RESTART</code>标志后，当信号处理函数执行完后，会自动恢复执行这个被中断的系统调用</p>
</li>
<li><p><code>SA_SIGINFO</code>：设置这个标志后，会回调<code>_sa_sigaction</code>作为信号处理函数，会携带更多的信号信息</p>
</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/signal.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/signal.2.html</a></p>
<p>这个函数的作用是，设置下一次的信号处理函数（只生效一次），成功返回上一次设置的信号处理函数，失败返回<code>SIG_ERR</code></p>
<p>这个函数在新版本中实际上是通过<code>sigaction</code>函数实现的，推荐使用更加强大的<code>sigaction</code>函数</p>
<h2 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h2><p>信号有几种状态，首先是信号的<code>产生 (Genertion)</code>，而实际执行信号处理动作时，状态为<code>递达 (Delivery)</code>，信号在<code>产生</code>到<code>递达</code>中的状态被称为<code>未决 (Pending)</code></p>
<p>进程可以选择<code>阻塞 (Blocking)</code>某些信号，被<code>阻塞</code>的信号在产生后将保持在<code>未决</code>状态，直到进程解除对该信号的<code>阻塞</code>，才执行<code>递达</code>的动作</p>
<h3 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h3><p>我们可以用信号集函数改变当前进程的<code>信号屏蔽字（Signal Mask）</code>，控制信号的阻塞与否</p>
<h4 id="信号集设置函数"><a href="#信号集设置函数" class="headerlink" title="信号集设置函数"></a>信号集设置函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号集数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">sigset_t</span>;</span><br><span class="line"><span class="comment">//清空一个信号集（将这个sigset_t置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//填充满一个信号集（将这个sigset_t的每一位都置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigfillset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号添加到信号集中（将这个sigset_t的对应信号位置1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigaddset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//将指定的信号从信号集中移除（将这个sigset_t的对应信号位置0）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigdelset.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"><span class="comment">//判断一个信号是否在这个信号集中（判断这个sigset_t的对应信号位是否为1）</span></span><br><span class="line"><span class="comment">//文档：https://man7.org/linux/man-pages/man3/sigismember.3p.html</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signo)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpromask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>这个函数通过指定的方法和信号集修改进程的信号屏蔽字，成功返回0，失败返回-1</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<h4 id="sigpending"><a href="#sigpending" class="headerlink" title="sigpending"></a>sigpending</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是获得当前进程的信号屏蔽字，将结果保存到传入的<code>set</code>中，成功返回0，失败返回-1</p>
<h1 id="信号原理"><a href="#信号原理" class="headerlink" title="信号原理"></a>信号原理</h1><p>我们已经了解了信号的产生和处理，现在我们可以具体的看看一个信号从产生到响应处理，它经历了什么，它的原理是什么</p>
<p>我们在简介中说过：信号是一种异步通信机制，它是在软件层面上对中断机制的一种模拟，该怎么理解这句话呢？</p>
<p>当我们对一个进程发送信号后，会将这个信号暂时存放到这个进程所对应的<code>task_struct</code>的<code>pending</code>队列中，此时，进程并不知道有新的信号过来了，这也就是异步的意思。那么进程什么时候才能得知并处理这个信号呢？有两个时机，一个是进程从内核态返回到用户态时，一个是进程从睡眠状态被唤醒。让信号看起来是一个异步中断的关键就是，正常的用户进程是会频繁的在用户态和内核态之间切换的，所以信号能很快的得到执行</p>
<p>下图为信号相关的一些结构</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84.png" alt="task_struct中的信号结构"></p>
<h2 id="信号的发送"><a href="#信号的发送" class="headerlink" title="信号的发送"></a>信号的发送</h2><p>我们以<code>kill</code>函数为例，看看信号是如何发送的，它被定义在<code>tools/include/nolibc/nolibc.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = sys_kill(pid, signal);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		SET_ERRNO(-ret);</span><br><span class="line">		ret = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((unused))</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_syscall2(__NR_kill, pid, signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了系统调用，在<code>Linux</code>内核中，每个<code>syscall</code>都对应着唯一的系统调用号，<code>kill</code>函数的系统调用号为<code>__NR_kill</code>，它被定义在<code>tools/include/uapi/asm-generic/unistd.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/signal.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 129</span></span><br><span class="line">__SYSCALL(__NR_kill, sys_kill)</span><br></pre></td></tr></table></figure>

<p>在<code>x86_64</code>架构的机器上，<code>my_syscall2</code>是这样被定义的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_syscall2(num, arg1, arg2)                                          \</span></span><br><span class="line">(&#123;                                                                            \</span><br><span class="line">	<span class="keyword">long</span> _ret;                                                            \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _num  <span class="keyword">asm</span>(<span class="string">"rax"</span>) = (num);                               \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg1 <span class="keyword">asm</span>(<span class="string">"rdi"</span>) = (<span class="keyword">long</span>)(arg1);                        \</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> _arg2 <span class="keyword">asm</span>(<span class="string">"rsi"</span>) = (<span class="keyword">long</span>)(arg2);                        \</span><br><span class="line">									      \</span><br><span class="line">	<span class="keyword">asm</span> <span class="keyword">volatile</span> (                                                        \</span><br><span class="line">		<span class="string">"syscall\n"</span>                                                   \</span><br><span class="line">		: <span class="string">"=a"</span>(_ret)                                                  \</span><br><span class="line">		: <span class="string">"r"</span>(_arg1), <span class="string">"r"</span>(_arg2),                                     \</span><br><span class="line">		  <span class="string">"0"</span>(_num)                                                   \</span><br><span class="line">		: <span class="string">"rcx"</span>, <span class="string">"r11"</span>, <span class="string">"memory"</span>, <span class="string">"cc"</span>                                \</span><br><span class="line">	);                                                                    \</span><br><span class="line">	_ret;                                                                 \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里涉及到了扩展内联汇编，<code>syscall</code>指令需要一个系统调用号和一些参数，在<code>x86_64</code>架构中，系统调用号需要存放在<code>rax</code>寄存器中，参数依次存放在<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code>, <code>r9</code>寄存器中，执行<code>syscall</code>指令后，内核会通过系统调用号去从系统调用表找到对应函数的入口</p>
<p>我们之前在找系统调用号<code>__NR_kill</code>的时候可以发现，上面标了注释，表明这个函数的实现在<code>kernel/signal.c</code>中，但我们在这个文件中并没有找到<code>sys_kill</code>这个函数，实际上这里隐藏了一个宏定义</p>
<p>在<code>include/linux/syscalls.h</code>中，我们可以找到这样一些宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SYSCALL_DEFINE0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE0(sname)					\</span></span><br><span class="line">	SYSCALL_METADATA(_##sname, <span class="number">0</span>);				\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void);			\</span></span><br><span class="line">	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);		\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys_#<span class="meta">#sname(void)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* SYSCALL_DEFINE0 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINE_MAXARGS	6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)				\</span></span><br><span class="line">	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\</span><br><span class="line">	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The asmlinkage stub is aliased to a function named __se_sys_*() which</span></span><br><span class="line"><span class="comment"> * sign-extends 32-bit ints to longs whenever needed. The actual work is</span></span><br><span class="line"><span class="comment"> * done within __do_sys_*().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SYSCALL_DEFINEx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)					\</span></span><br><span class="line">	__diag_push();							\</span><br><span class="line">	__diag_ignore(GCC, <span class="number">8</span>, <span class="string">"-Wattribute-alias"</span>,			\</span><br><span class="line">		      <span class="string">"Type aliasing is used to sanitize syscall arguments"</span>);\</span><br><span class="line">	asmlinkage <span class="keyword">long</span> sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))	\</span></span><br><span class="line">		__attribute__((alias(__stringify(__se_sys##name))));	\</span><br><span class="line">	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__));\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__));	\</span></span><br><span class="line">	asmlinkage <span class="keyword">long</span> __se_sys#<span class="meta">#name(__MAP(x,__SC_LONG,__VA_ARGS__))	\</span></span><br><span class="line">	&#123;								\</span><br><span class="line">		<span class="keyword">long</span> ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\</span><br><span class="line">		__MAP(x,__SC_TEST,__VA_ARGS__);				\</span><br><span class="line">		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\</span><br><span class="line">		<span class="keyword">return</span> ret;						\</span><br><span class="line">	&#125;								\</span><br><span class="line">	__diag_pop();							\</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">long</span> __do_sys#<span class="meta">#name(__MAP(x,__SC_DECL,__VA_ARGS__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SYSCALL_DEFINEx */</span></span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINEx</code>中的<code>x</code>表示接受<code>x</code>个参数，这个宏定义根据传入的<code>name</code>参数，以<code>sys_name</code>为名定义了一个函数，也就是说<code>SYSCALL_DEFINE2(kill, ...)</code>这个宏展开后基本相当于<code>sys_kill</code>函数，在<code>kernel/signal.c</code>中我们可以找到这段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    prepare_kill_siginfo(sig, &amp;info);</span><br><span class="line">    <span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是<code>kill</code>函数的真正实现，我们这里主要关注信号的发送，就屏蔽一些细节，只看发送部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="comment">//这里我们就只看对一个进程发送信号</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> kill_proc_info(sig, info, pid);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_proc_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill_pid_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct pid *pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取pid对应进程的task_struct</span></span><br><span class="line">        p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            <span class="comment">//PIDTYPE_TGID表示类型是线程组id，对于同一进程中的所有线程，tgid都是一致的，为该进程的进程id</span></span><br><span class="line">            group_send_sig_info(sig, info, p, PIDTYPE_TGID);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">group_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">        ret = do_send_sig_info(sig, info, p, type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_send_sig_info</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *p,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    send_signal(sig, info, p, type);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">send_signal</span><span class="params">(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> __send_signal(sig, info, t, type, force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct kernel_siginfo *info, struct task_struct *t,</span><br><span class="line">            <span class="keyword">enum</span> pid_type type, <span class="keyword">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="keyword">int</span> override_rlimit;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_IGNORED;</span><br><span class="line">    <span class="comment">//判断是否可以忽略信号</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_signal(sig, t, force))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择信号pending队列</span></span><br><span class="line">    <span class="comment">//线程组共享队列(t-&gt;signal-&gt;shared_pending) 或 进程私有队列(t-&gt;pending)</span></span><br><span class="line">    pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">    </span><br><span class="line">    result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line">    <span class="comment">//如果该信号是不可靠信号，且已经在padding队列中，则忽略这个信号</span></span><br><span class="line">    <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对SIGKILL信号和内核进程跳过信号的pending</span></span><br><span class="line">    <span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">        <span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实时信号可以突破队列大小限制，否则丢弃信号</span></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新分配一个sigqueue，并将其加入pending队尾</span></span><br><span class="line">    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_USER;</span><br><span class="line">            q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">                            task_active_pid_ns(t));</span><br><span class="line">            rcu_read_lock();</span><br><span class="line">            q-&gt;info.si_uid =</span><br><span class="line">                from_kuid_munged(task_cred_xxx(t, user_ns),</span><br><span class="line">                         current_uid());</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">            q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info) &amp;&amp;</span><br><span class="line">           sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">    signalfd_notify(t, sig);</span><br><span class="line">    sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//唤醒进程</span></span><br><span class="line">    complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码里我们可以看出来，和我们之前说的原理是一样的，新分配了一个<code>sigqueue</code>，并将其加入到对应进程<code>task_struct</code>的<code>pending</code>队列队尾</p>
<h2 id="设置信号处理"><a href="#设置信号处理" class="headerlink" title="设置信号处理"></a>设置信号处理</h2><p>之前我们介绍了怎么自定义信号处理行为，如何设置信号屏蔽字，实际上都能在进程的<code>task_struct</code>中体现出来，信号处理行为保存在其中的<code>sighand</code>域中，而信号屏蔽字保存在其中的<code>blocked</code>域中</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E5%9F%9F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="task_struct"></p>
<h2 id="信号的响应"><a href="#信号的响应" class="headerlink" title="信号的响应"></a>信号的响应</h2><p><code>x86_64</code>架构系统调用会经历<code>do_syscall_64</code>这么一个函数，它被实现在<code>arch/x86/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__visible noinstr <span class="keyword">void</span> <span class="title">do_syscall_64</span><span class="params">(struct pt_regs *regs, <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add_random_kstack_offset();</span><br><span class="line">    nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">    instrumentation_begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!do_syscall_x64(regs, nr) &amp;&amp; !do_syscall_x32(regs, nr) &amp;&amp; nr != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Invalid system call, but still a system call. */</span></span><br><span class="line">        regs-&gt;ax = __x64_sys_ni_syscall(regs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instrumentation_end();</span><br><span class="line">    syscall_exit_to_user_mode(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码我们可以看出来，当进程从内核空间返回用户空间时，会调用<code>syscall_exit_to_user_mode</code>函数</p>
<p>最终经历一系列调用，会走到<code>exit_to_user_mode_loop</code>函数中，它们被定义在<code>kernel/entry/common.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">exit_to_user_mode_loop</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">unsigned</span> <span class="keyword">long</span> ti_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ti_work &amp; EXIT_TO_USER_MODE_WORK) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ti_work &amp; (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))</span><br><span class="line">            handle_signal_work(regs, ti_work);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ti_work;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果当前线程包含<code>_TIF_SIGPENDING</code>或<code>_TIF_NOTIFY_SIGNAL</code>，表明该线程可能有信号需要处理，会调用到<code>handle_signal_work</code>函数处理，接着调用到<code>arch_do_signal_or_restart</code>函数中，它被实现在<code>arch/x86/kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//has_signal的值为 (ti_work &amp; _TIF_SIGPENDING)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arch_do_signal_or_restart</span><span class="params">(struct pt_regs *regs, <span class="keyword">bool</span> has_signal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_signal &amp;&amp; get_signal(&amp;ksig)) &#123;</span><br><span class="line">        handle_signal(&amp;ksig, regs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果该进程没有对这个信号设置处理程序，这里会自动重启这个系统调用</span></span><br><span class="line">    <span class="comment">/* Did we come from a system call? */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall_get_nr(current, regs) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">/* Restart the system call - no handlers present */</span></span><br><span class="line">        <span class="keyword">switch</span> (syscall_get_error(current, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">            regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">            regs-&gt;ax = get_nr_restart_syscall(regs);</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    restore_saved_sigmask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数中的<code>if</code>语句体，看上去是如果有信号，则处理这个信号，其实不完全是这样的。如果该进程没有对这个信号设置处理程序，则会执行默认的信号处理，这里的处理过程是在<code>get_signal</code>中完成的，我当时在看这块源码的时候还在疑惑为什么找不到信号默认处理的地方，结果是这个函数的名字误导了我。如果该进程没有对这个信号设置处理程序，则会自动重启这个系统调用，这里就不展开说了，我们首先看一下<code>get_signal</code>函数是怎么实现的，它被实现在<code>kernel/signal.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line">    <span class="keyword">int</span> signr;</span><br><span class="line">    ...</span><br><span class="line">relock:</span><br><span class="line">    spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果子进程的状态发生变化，发送SIGCHLD信号给父进程</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line">        <span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">            why = CLD_CONTINUED;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">        signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">        read_lock(&amp;tasklist_lock);</span><br><span class="line">        do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">            do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line">                        <span class="literal">true</span>, why);</span><br><span class="line">        read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> relock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line">        <span class="keyword">enum</span> pid_type type;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从进程task_struct的pending队列中取出一个信号</span></span><br><span class="line">        type = PIDTYPE_PID;</span><br><span class="line">        signr = dequeue_synchronous_signal(&amp;ksig-&gt;info);</span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            signr = dequeue_signal(current, &amp;current-&gt;blocked,</span><br><span class="line">                           &amp;ksig-&gt;info, &amp;type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!signr)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从信号处理数组中，取出对应信号的处理动作</span></span><br><span class="line">        ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">            <span class="comment">/* Run the handler.  */</span></span><br><span class="line">            ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果设置了SA_RESETHAND或者SA_ONESHOT标志（这俩标志的值是一样的），将其信号处理函数重设为默认</span></span><br><span class="line">            <span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">                ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面为默认信号处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//部分信号的默认动作为忽略（具体可以查看SIG_KERNEL_IGNORE_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//部分信号的默认动作为停止进程（具体可以查看SIG_KERNEL_STOP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">                spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当前为孤儿进程组</span></span><br><span class="line">                <span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line">                    <span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">                spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//默认动作为停止当前线程组里的所有线程</span></span><br><span class="line">            <span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> relock;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fatal:</span><br><span class="line">        spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">        ...</span><br><span class="line">        current-&gt;flags |= PF_SIGNALED;</span><br><span class="line">        <span class="comment">//部分信号的默认动作为dump core，然后终止进程（具体可以查看SIG_KERNEL_COREDUMP_MASK这个宏定义）</span></span><br><span class="line">        <span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">                print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">            proc_coredump_connector(current);</span><br><span class="line">            do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_IO_WORKER)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剩下来的信号的默认操作为终止进程</span></span><br><span class="line">        do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">out:</span><br><span class="line">    ksig-&gt;sig = signr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_EXPOSE_TAGBITS))</span><br><span class="line">        hide_si_addr_tag_bits(ksig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当当前进程对此信号设置了自定义信号处理动作后，返回true</span></span><br><span class="line">    <span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="likely-amp-unlikely"><a href="#likely-amp-unlikely" class="headerlink" title="likely &amp; unlikely"></a>likely &amp; unlikely</h3><p>这里的<code>likely</code>和<code>unlikely</code>为两个宏，指向<code>__builtin_expect</code>函数，是<code>gcc</code>编译器提供给程序员优化的一种方式，<code>likely</code>表示表达式为真的可能性更大，<code>unlikely</code>表示表达式为假的可能性更大，这样<code>gcc</code>编译器可以在编译过程中，将可能性更大的代码紧跟前面的代码，减少指令跳转带来的性能开销</p>
<hr>
<p>我们接着看，当用户自定义了信号处理函数后，内核是怎么处理的。从上面的代码看来，当用户自定义了信号处理函数，<code>get_signal</code>函数会返回<code>true</code>，紧接着就会进入到<code>handle_signal</code>函数中，这里的处理比较特殊，我们要先了解信号处理的一些过程</p>
<p>用户自定义信号处理函数实际上是在用户空间执行的，目的是为了防止用户利用内核空间的<code>ring 0</code>特权等级做一些意想不到的事，处理过程如下两图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" alt="信号处理过程"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Linux%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B2.png" alt="信号处理过程"></p>
<p>整个过程如图中所见，进程由于系统调用或中断进入内核空间，在内核空间完成工作后返回用户空间的前夕，检查信号队列，如果检查有信号并且有自定义的信号处理函数，返回到用户空间执行信号处理函数，处理完后再返回内核空间，最后再回到用户空间之前代码执行到的地方继续运行</p>
<p>可以看到，这一套流程经历了4次用户态与内核态的切换，比较复杂，那么内核是如何做到的呢？为什么信号处理函数执行完后还要返回内核空间呢？</p>
<h3 id="用户态与内核态的切换"><a href="#用户态与内核态的切换" class="headerlink" title="用户态与内核态的切换"></a>用户态与内核态的切换</h3><p>在<code>Linux</code>中，在用户态和内核态运行的进程使用的是不同的栈，分别为用户栈和内核栈，当一个进程陷入内核态时，需要将用户栈的信息保存到内核栈中，具体的，会将<code>ss</code>, <code>sp</code>, <code>flags</code>, <code>cs</code>, <code>ip</code>等值依次压入栈中，保存为<code>pt_regs</code>结构，然后设置CPU堆栈寄存器的地址为内核栈顶，这样，后续使用的栈便变成了内核栈，当系统调用结束，需要从内核态切换到用户态时，再将之前压入栈中的寄存器值弹出，将<code>pt_regs</code>中保存的值恢复到相应的寄存器中，这里改变了<code>sp</code>寄存器的值，即完成了换栈，<code>cs:ip</code>这两个寄存器分别指向用户态代码段以及用户态指令指针，后续CPU便会执行之前用户态的代码了</p>
<h4 id="pt-regs结构体"><a href="#pt-regs结构体" class="headerlink" title="pt_regs结构体"></a>pt_regs结构体</h4><p><code>pt_regs</code>结构体位于<code>arch/x86/include/asm/ptrace.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ax;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> dx;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> si;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> di;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_ax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ip;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sp;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们从理论角度上大概理解了内核是怎么在用户态与内核态之间切换的，接下来我们去源码里验证一下是不是我们所想的这样，<code>syscall</code>的入口函数为<code>entry_SYSCALL_64</code>，位于<code>arch/x86/entry/entry_64.S</code>中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">SYM_CODE_START(entry_SYSCALL_64)</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line">    </span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至内核态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* tss<span class="number">.</span>sp2为用户栈 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, PER_CPU_VAR(cpu_tss_rw + TSS_sp2)</span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</span><br><span class="line">    /* 切换至内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_safe_stack, SYM_L_GLOBAL)</span><br><span class="line"></span><br><span class="line">    /* 保存用户栈寄存器值至pt_regs结构中 */</span><br><span class="line">    pushq	$__USER_DS				/* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">    pushq	PER_CPU_VAR(cpu_tss_rw + TSS_sp2)	/* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将rflags的值保存在<span class="built_in">r11</span>寄存器中 */</span><br><span class="line">    pushq	%r11					/* pt_regs-&gt;flags */</span><br><span class="line">    pushq	$__USER_CS				/* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">    /* 当执行<span class="keyword">syscall</span>指令时，<span class="meta">cpu</span>会将<span class="keyword">syscall</span>指令的下一条指令的地址传给<span class="built_in">rcx</span>寄存器 */</span><br><span class="line">    pushq	%rcx					/* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">SYM_INNER_LABEL(entry_SYSCALL_64_after_hwframe, SYM_L_GLOBAL)</span><br><span class="line">    pushq	%rax					/* pt_regs-&gt;orig_ax */</span><br><span class="line"></span><br><span class="line">    /* 保存并清除寄存器 */</span><br><span class="line">    PUSH_AND_CLEAR_REGS <span class="built_in">rax</span>=$-ENOSYS</span><br><span class="line">    /* 此时，<span class="built_in">rsp</span>指向的栈顶地址即为pt_regs的地址 */</span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 设置系统调用号 */</span><br><span class="line">    movslq	%eax, %rsi</span><br><span class="line">    /* 以<span class="built_in">rdi</span>, <span class="built_in">rsi</span>作为参数，调用do_syscall_64函数 */</span><br><span class="line">    <span class="keyword">call</span>	do_syscall_64		/* returns with IRQs disabled */</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    cmpq	%rcx, %r11</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_CS, <span class="built_in">CS</span>(%rsp)		/* <span class="built_in">CS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	<span class="built_in">R11</span>(%rsp), %r11</span><br><span class="line">    cmpq	%r11, EFLAGS(%rsp)		/* <span class="built_in">R11</span> == RFLAGS */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    testq	$(X86_EFLAGS_RF|X86_EFLAGS_TF), %r11</span><br><span class="line">    <span class="keyword">jnz</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    cmpq	$__USER_DS, <span class="built_in">SS</span>(%rsp)		/* <span class="built_in">SS</span> must match <span class="keyword">SYSRET</span> */</span><br><span class="line">    <span class="keyword">jne</span>	swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 这个标签实际上只是为了便于理解，并没有地方跳转它</span><br><span class="line">     * 实际工作是在swapgs_restore_regs_and_return_to_usermode中完成的</span><br><span class="line">     */</span><br><span class="line"><span class="symbol">syscall_return_via_sysret:</span></span><br><span class="line">    /* 恢复寄存器 */</span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span> skip_r11rcx=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">movq</span>	%rsp, %rdi</span><br><span class="line">    /* 保存内核栈 */</span><br><span class="line">    <span class="keyword">movq</span>	PER_CPU_VAR(cpu_tss_rw + TSS_sp0), %rsp</span><br><span class="line">    UNWIND_HINT_EMPTY</span><br><span class="line"></span><br><span class="line">    pushq	<span class="built_in">RSP</span>-<span class="built_in">RDI</span>(%rdi)	/* <span class="built_in">RSP</span> */</span><br><span class="line">    pushq	(%rdi)		/* <span class="built_in">RDI</span> */</span><br><span class="line"></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    /* 切换页表 */</span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    popq	%rdi</span><br><span class="line">    popq	%rsp</span><br><span class="line">    /* 切换<span class="built_in">gs</span>寄存器至用户态 */</span><br><span class="line">    <span class="keyword">swapgs</span></span><br><span class="line">    /* 恢复<span class="built_in">rip</span>, rflags等寄存器，使<span class="meta">cpu</span>接下来要执行指令指向<span class="keyword">syscall</span>的下一条指令 */</span><br><span class="line">    sysretq</span><br><span class="line">SYM_CODE_END(entry_SYSCALL_64)</span><br></pre></td></tr></table></figure>

<h3 id="信号处理函数的跳转方式"><a href="#信号处理函数的跳转方式" class="headerlink" title="信号处理函数的跳转方式"></a>信号处理函数的跳转方式</h3><p>但是在系统调用完后，回到的将是syscall后的下一条指令，那么如何才能让程序去执行信号处理函数呢？信号处理函数执行完后，又如何回到之前所执行到的代码呢？我们很容易就能想到，先将<code>pt_regs</code>中的值备份一下，然后改变<code>pt_regs</code>中一些寄存器值，比如说将<code>cs:ip</code>修改成信号处理函数对应地址，这样从内核态返回后，就会自动跳转到信号处理函数了，等到信号处理函数执行完，再进入内核态，恢复<code>pt_regs</code>中的值后回到用户态，这样<code>cpu</code>又会从用户调用<code>syscall</code>后的指令开始正常执行了</p>
<p>我们具体的看一下内核代码是怎么做的，这里的逻辑在<code>arch/x86/kernel/signal.c</code>中的<code>handle_signal</code>函数里</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    failed = (setup_rt_frame(ksig, regs) &lt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    signal_setup_done(failed, ksig, stepping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">setup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> usig = ksig-&gt;sig;</span><br><span class="line">    <span class="keyword">sigset_t</span> *<span class="built_in">set</span> = sigmask_to_save();</span><br><span class="line">    <span class="keyword">compat_sigset_t</span> *cset = (<span class="keyword">compat_sigset_t</span> *) <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform fixup for the pre-signal frame. */</span></span><br><span class="line">    rseq_signal_deliver(ksig, regs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置栈帧</span></span><br><span class="line">    <span class="keyword">if</span> (is_ia32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO)</span><br><span class="line">            <span class="keyword">return</span> ia32_setup_rt_frame(usig, ksig, cset, regs);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ia32_setup_frame(usig, ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_x32_frame(ksig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> x32_setup_rt_frame(ksig, cset, regs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> __setup_rt_frame(ksig-&gt;sig, ksig, <span class="built_in">set</span>, regs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//x86_64执行的应该是这个函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __setup_rt_frame(<span class="keyword">int</span> sig, struct ksignal *ksig,</span><br><span class="line">                <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* x86-64 should always use SA_RESTORER. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个栈帧</span></span><br><span class="line">    frame = get_sigframe(&amp;ksig-&gt;ka, regs, <span class="keyword">sizeof</span>(struct rt_sigframe), &amp;fp);</span><br><span class="line">    uc_flags = frame_uc_flags(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!user_access_begin(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the ucontext.  */</span></span><br><span class="line">    unsafe_put_user(uc_flags, &amp;frame-&gt;uc.uc_flags, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;frame-&gt;uc.uc_link, Efault);</span><br><span class="line">    unsafe_save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up to return from userspace.  If provided, use a stub</span></span><br><span class="line"><span class="comment">       already in userspace.  */</span></span><br><span class="line">    <span class="comment">//设置执行完信号处理函数后，要跳回的地址，即sa_restorer</span></span><br><span class="line">    unsafe_put_user(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode, Efault);</span><br><span class="line">    <span class="comment">//将原本的pt_regs备份保存至frame.uc.uc_mcontext中</span></span><br><span class="line">    unsafe_put_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, <span class="built_in">set</span>, Efault);</span><br><span class="line">    unsafe_put_sigmask(<span class="built_in">set</span>, frame, Efault);</span><br><span class="line">    user_access_end();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号处理函数的第1个参数</span></span><br><span class="line">    regs-&gt;di = sig;</span><br><span class="line">    <span class="comment">/* In case the signal handler was declared without prototypes */</span></span><br><span class="line">    regs-&gt;ax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置了SA_SIGINFO标志位，需要带一些额外的信号信息 */</span></span><br><span class="line">    <span class="comment">//信号处理函数的第2个参数</span></span><br><span class="line">    regs-&gt;si = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;info;</span><br><span class="line">    <span class="comment">//信号处理函数的第3个参数</span></span><br><span class="line">    regs-&gt;dx = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;frame-&gt;uc;</span><br><span class="line">    <span class="comment">//设置指令指针指向信号处理函数</span></span><br><span class="line">    <span class="comment">//sigaction结构体中的第一个域是一个联合，所以这里</span></span><br><span class="line">    <span class="comment">//sa_handler和sa_sigaction的地址是相同的</span></span><br><span class="line">    regs-&gt;ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ksig-&gt;ka.sa.sa_handler;</span><br><span class="line">    <span class="comment">//设置栈顶地址</span></span><br><span class="line">    regs-&gt;sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)frame;</span><br><span class="line">    <span class="comment">//设置用户代码段</span></span><br><span class="line">    regs-&gt;cs = __USER_CS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(regs-&gt;ss != __USER_DS))</span><br><span class="line">        force_valid_ss(regs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Efault:</span><br><span class="line">    user_access_end();</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsafe_put_sigcontext(sc, fp, regs, set, label)			\</span></span><br><span class="line"><span class="keyword">do</span> &#123;									\</span><br><span class="line">    <span class="keyword">if</span> (__unsafe_setup_sigcontext(sc, fp, regs, <span class="built_in">set</span>-&gt;sig[<span class="number">0</span>]))	\</span><br><span class="line">        <span class="keyword">goto</span> label;						\</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span></span><br><span class="line">__unsafe_setup_sigcontext(struct sigcontext __user *sc, <span class="keyword">void</span> __user *fpstate,</span><br><span class="line">             struct pt_regs *regs, <span class="keyword">unsigned</span> <span class="keyword">long</span> mask)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(regs-&gt;di, &amp;sc-&gt;di, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;si, &amp;sc-&gt;si, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bp, &amp;sc-&gt;bp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;sp, &amp;sc-&gt;sp, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;bx, &amp;sc-&gt;bx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;dx, &amp;sc-&gt;dx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cx, &amp;sc-&gt;cx, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ax, &amp;sc-&gt;ax, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;r8, &amp;sc-&gt;r8, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r9, &amp;sc-&gt;r9, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r10, &amp;sc-&gt;r10, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r11, &amp;sc-&gt;r11, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r12, &amp;sc-&gt;r12, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r13, &amp;sc-&gt;r13, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r14, &amp;sc-&gt;r14, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;r15, &amp;sc-&gt;r15, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(current-&gt;thread.trap_nr, &amp;sc-&gt;trapno, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.error_code, &amp;sc-&gt;err, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ip, &amp;sc-&gt;ip, Efault);</span><br><span class="line">    </span><br><span class="line">    unsafe_put_user(regs-&gt;flags, &amp;sc-&gt;flags, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;cs, &amp;sc-&gt;cs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;gs, Efault);</span><br><span class="line">    unsafe_put_user(<span class="number">0</span>, &amp;sc-&gt;fs, Efault);</span><br><span class="line">    unsafe_put_user(regs-&gt;ss, &amp;sc-&gt;ss, Efault);</span><br><span class="line"></span><br><span class="line">    unsafe_put_user(fpstate, (<span class="keyword">unsigned</span> <span class="keyword">long</span> __user *)&amp;sc-&gt;fpstate, Efault);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-iBCS2 extensions.. */</span></span><br><span class="line">    unsafe_put_user(mask, &amp;sc-&gt;oldmask, Efault);</span><br><span class="line">    unsafe_put_user(current-&gt;thread.cr2, &amp;sc-&gt;cr2, Efault);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Efault:</span><br><span class="line">    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实际上是这么做的，首先，内核默认在用户栈上分配了一个栈帧（如果设置了备用栈的话，则会在备用栈上分配），将<code>pt_regs</code>备份到这个栈帧上，用于后续恢复，然后设置<code>pt_regs</code>，改变其<code>sp</code>, <code>cs</code>, <code>ip</code>等值，使程序从内核态返回时，可以跳转到信号处理函数对应的栈和代码指令地址，当信号处理函数返回时会执行<code>sigreturn</code>系统调用再进入内核态，将之前备份到栈帧中的寄存器值重新恢复到<code>pt_regs</code>中，然后再从内核态回到用户态就可以正常继续执行<code>syscall</code>后面的代码了</p>
<p>其中<code>sa_restorer</code>是在<code>glibc</code>里的<code>__libc_sigaction</code>函数中被设置的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__libc_sigaction (<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oact)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_sigaction</span> <span class="title">kact</span>, <span class="title">koact</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (act)</span><br><span class="line">    &#123;</span><br><span class="line">        kact.k_sa_handler = act-&gt;sa_handler;</span><br><span class="line">        <span class="built_in">memcpy</span> (&amp;kact.sa_mask, &amp;act-&gt;sa_mask, <span class="keyword">sizeof</span> (<span class="keyword">sigset_t</span>));</span><br><span class="line">        kact.sa_flags = act-&gt;sa_flags;</span><br><span class="line">        <span class="comment">//设置sa_restorer</span></span><br><span class="line">        SET_SA_RESTORER (&amp;kact, act);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">restore_rt</span> <span class="params">(<span class="keyword">void</span>)</span> <span class="title">asm</span> <span class="params">(<span class="string">"__restore_rt"</span>)</span> attribute_hidden</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SA_RESTORER(kact, act)			\</span></span><br><span class="line">    (kact)-&gt;sa_flags = (act)-&gt;sa_flags | SA_RESTORER;	\</span><br><span class="line">    (kact)-&gt;sa_restorer = &amp;restore_rt</span><br><span class="line">    </span><br><span class="line">RESTORE (restore_rt, __NR_rt_sigreturn)</span><br><span class="line"></span><br><span class="line">#define RESTORE(name, syscall) RESTORE2 (name, syscall)</span><br><span class="line">#define RESTORE2(name, syscall) \</span><br><span class="line"><span class="keyword">asm</span>									\</span><br><span class="line">  (									\</span><br><span class="line">   <span class="comment">/* `nop' for debuggers assuming `call' should not disalign the code.  */</span> \</span><br><span class="line">   <span class="string">"	nop\n"</span>								\</span><br><span class="line">   <span class="string">".align 16\n"</span>							\</span><br><span class="line">   <span class="string">".LSTART_"</span> #name <span class="string">":\n"</span>						\</span><br><span class="line">   <span class="string">"	.type __"</span> #name <span class="string">",@function\n"</span>					\</span><br><span class="line">   <span class="string">"__"</span> #name <span class="string">":\n"</span>							\</span><br><span class="line">   <span class="string">"	movq $"</span> #syscall <span class="string">", %rax\n"</span>					\</span><br><span class="line">   <span class="string">"	syscall\n"</span>							\</span><br><span class="line">   ...</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>可以看到，这里也是一个系统调用，和上面所说的规则一样，它最终会调用<code>sys_rt_sigreturn</code>函数，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(rt_sigreturn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span> = <span class="title">current_pt_regs</span>();</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags;</span><br><span class="line"></span><br><span class="line">    frame = (struct rt_sigframe __user *)(regs-&gt;sp - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(frame, <span class="keyword">sizeof</span>(*frame)))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(*(__u64 *)&amp;<span class="built_in">set</span>, (__u64 __user *)&amp;frame-&gt;uc.uc_sigmask))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (__get_user(uc_flags, &amp;frame-&gt;uc.uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    set_current_blocked(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//frame.uc.uc_mcontext中恢复pt_regs</span></span><br><span class="line">    <span class="keyword">if</span> (!restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext, uc_flags))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (restore_altstack(&amp;frame-&gt;uc.uc_stack))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ax;</span><br><span class="line"></span><br><span class="line">badframe:</span><br><span class="line">    signal_fault(regs, frame, <span class="string">"rt_sigreturn"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">restore_sigcontext</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct sigcontext __user *usc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">long</span> uc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span> <span class="title">sc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Always make any pending restarted system calls return -EINTR */</span></span><br><span class="line">    current-&gt;restart_block.fn = do_no_restart_syscall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;sc, usc, CONTEXT_COPY_SIZE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;bx = sc.bx;</span><br><span class="line">    regs-&gt;cx = sc.cx;</span><br><span class="line">    regs-&gt;dx = sc.dx;</span><br><span class="line">    regs-&gt;si = sc.si;</span><br><span class="line">    regs-&gt;di = sc.di;</span><br><span class="line">    regs-&gt;bp = sc.bp;</span><br><span class="line">    regs-&gt;ax = sc.ax;</span><br><span class="line">    regs-&gt;sp = sc.sp;</span><br><span class="line">    regs-&gt;ip = sc.ip;</span><br><span class="line"></span><br><span class="line">    regs-&gt;r8 = sc.r8;</span><br><span class="line">    regs-&gt;r9 = sc.r9;</span><br><span class="line">    regs-&gt;r10 = sc.r10;</span><br><span class="line">    regs-&gt;r11 = sc.r11;</span><br><span class="line">    regs-&gt;r12 = sc.r12;</span><br><span class="line">    regs-&gt;r13 = sc.r13;</span><br><span class="line">    regs-&gt;r14 = sc.r14;</span><br><span class="line">    regs-&gt;r15 = sc.r15;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get CS/SS and force CPL3 */</span></span><br><span class="line">    regs-&gt;cs = sc.cs | <span class="number">0x03</span>;</span><br><span class="line">    regs-&gt;ss = sc.ss | <span class="number">0x03</span>;</span><br><span class="line"></span><br><span class="line">    regs-&gt;flags = (regs-&gt;flags &amp; ~FIX_EFLAGS) | (sc.flags &amp; FIX_EFLAGS);</span><br><span class="line">    <span class="comment">/* disable syscall checks */</span></span><br><span class="line">    regs-&gt;orig_ax = <span class="number">-1</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> fpu__restore_sig((<span class="keyword">void</span> __user *)sc.fpstate,</span><br><span class="line">                   IS_ENABLED(CONFIG_X86_32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码还是可以比较清楚的看出来，和我们之前描述的原理基本一致，到这一步时，恢复<code>pt_regs</code>中的值，这样后续返回用户态后便可以正常继续运行后面的用户代码了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Linux</code>信号的原理分析到这基本上也就结束了，其实整个信号原理分析对现阶段的我来说，还是一件相当具有挑战性的事情，不过在此过程中，还是收获了很多知识，也发现了一些之前文章里错漏的地方，由于我对<code>Linux</code>内核以及汇编并不熟悉，所以难免会有一些分析错误或者不到位的地方，欢迎大家指正</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="信号表"><a href="#信号表" class="headerlink" title="信号表"></a>信号表</h2><p>取值 | 名称        | 解释               | 默认动作        |<br>| – | ——— | —————- | ———– |<br>| 1  | SIGHUP    | 挂起               | 终止进程    |<br>| 2  | SIGINT    | 中断               | 终止进程    |<br>| 4  | SIGILL    | 非法指令             | coredump后终止进程 |<br>| 5  | SIGTRAP   | 断点或陷阱指令          | coredump后终止进程 |<br>| 6  | SIGABRT/SIGIOT   | abort发出的信号  | coredump后终止进程 |<br>| 7  | SIGBUS    | 非法内存访问           | coredump后终止进程 |<br>| 8  | SIGFPE    | 浮点异常             | coredump后终止进程 |<br>| 9  | SIGKILL   | kill信号           | 不能被忽略、处理和阻塞 |<br>| 10 | SIGUSR1   | 用户自定义信号1            | 终止进程 |<br>| 11 | SIGSEGV   | 无效内存访问           | coredump后终止进程 |<br>| 12 | SIGUSR2   | 用户自定义信号2            | 终止进程 |<br>| 13 | SIGPIPE   | 管道破损，没有读端的管道写数据  | 终止进程 |<br>| 14 | SIGALRM   | alarm发出的信号       | 终止进程 |<br>| 15 | SIGTERM   | 终止信号             | 终止进程 |<br>| 16 | SIGSTKFLT | 栈溢出              | 终止进程 |<br>| 17 | SIGCHLD   | 子进程退出            | 忽略信号 |<br>| 18 | SIGCONT   | 进程继续             | 忽略信号 |<br>| 19 | SIGSTOP   | 进程停止             | 不能被忽略、处理和阻塞 |<br>| 20 | SIGTSTP   | 进程停止             | 停止进程 |<br>| 21 | SIGTTIN   | 进程停止，后台进程从终端读数据时 | 停止进程 |<br>| 22 | SIGTTOU   | 进程停止，后台进程想终端写数据时 | 停止进程 |<br>| 23 | SIGURG    | I/O有紧急数据到达当前进程   | 忽略信号 |<br>| 24 | SIGXCPU   | 进程的CPU时间片到期      | coredump后终止进程 |<br>| 25 | SIGXFSZ   | 文件大小的超出上限        | coredump后终止进程 |<br>| 26 | SIGVTALRM | 虚拟时钟超时           | 终止进程 |<br>| 27 | SIGPROF   | profile时钟超时      | 终止进程 |<br>| 28 | SIGWINCH  | 窗口大小改变           | 忽略信号 |<br>| 29 | SIGPOLL/SIGIO     | I/O相关            | 终止进程 |<br>| 30 | SIGPWR    | 关机               | 默认忽略        |<br>| 31 | SIGSYS/SIGUNUSED    | 系统调用异常 | coredump后终止进程 |</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://tianyu-code.top/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/Linux%E4%BF%A1%E5%8F%B7/" target="_blank" rel="noopener">Linux信号</a></li>
<li><a href="https://docs.huihoo.com/c/linux-c-programming/ch33s03.html" target="_blank" rel="noopener">阻塞信号</a></li>
<li><a href="https://kernel.meizu.com/linux-signal.html" target="_blank" rel="noopener">Linux Signal</a></li>
<li><a href="http://gityuan.com/2015/12/20/signal/" target="_blank" rel="noopener">Linux信号(signal)机制</a></li>
<li><a href="https://oilbeater.com/linux/2012/05/09/linux-signal.html" target="_blank" rel="noopener">linux 信号处理机制简介</a></li>
<li><a href="https://wenfh2020.com/2021/09/05/kernel-syscall/" target="_blank" rel="noopener">[内核源码] Linux 系统调用（x86_64）</a></li>
<li><a href="https://ty-chen.github.io/linux-kernel-signal/" target="_blank" rel="noopener">Linux操作系统学习笔记（十六）进程间通信之信号</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117794217" target="_blank" rel="noopener">X86_64处理器系统调用机制在linux上的实现</a></li>
<li><a href="https://blog.csdn.net/chengwenyang/article/details/117929007" target="_blank" rel="noopener">linux kernel signal机制（X86_64）</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/">B站Android面试小记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>看着我同学最近也在到处投简历，我想着我也投一下看看行情，于是在<strong>2022-02-28</strong>号，我向B站投出了第一封简历，说实话当初只是想练练手，没想到最后接了B站的offer，也是造化弄人了</p>
<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>技术面，45min左右，基本围绕你简历上写的亮点和你的工作经历展开</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>你在项目中负责什么</p>
</li>
<li><p>用过什么设计模式，或在<code>Android</code>中常常会碰见的设计模式</p>
<p>  单例模式，策略模式，责任链模式（问了一下使用场景），工厂模式等</p>
<p>  <code>Android</code>中的观察者模式，适配器模式等</p>
</li>
<li><p>有没有做过什么比较有难度的模块</p>
<p>  <code>camera2</code>，自定义照片裁剪<code>View</code></p>
</li>
<li><p>你对自定义<code>View</code>有什么了解</p>
<p>  回答了一些<code>Path</code>绘制以及触摸事件的处理</p>
</li>
<li><p><code>Android</code>动画</p>
<p>  属性动画，<code>ObjectAnimator</code></p>
</li>
<li><p>多线程并发（锁、信号量、<code>syncnorized</code>），<code>syncnorized</code>对象和class有什么区别</p>
</li>
<li><p><code>ConcurrentHashMap</code>线程安全的原理</p>
<p>  1.8之前用的分段式锁，1.8之后用的<code>synchronized</code>，至于具体的细节没有答上来，因为确实也没看过这边源码</p>
</li>
<li><p><code>jni</code>，如何定位<code>jni</code>崩溃</p>
<p>  这个我当时回答的是打log，因为项目中用到<code>jni</code>的地方确实不多，当然<code>jni</code>也是可以断点调试的</p>
</li>
<li><p>你所开发的应用有多进程吗？进程间是怎么通信的</p>
<p>  这个我当时只回答了<code>mmap</code>，稍微聊了一下<code>mmap</code>原理和<code>binder</code>性能对比，后来复盘想起来项目中用到的<code>Broadcast</code>和<code>aidl binder</code>通信都没有回答</p>
</li>
<li><p><code>Webview</code>和<code>native</code>怎么交互的</p>
<ul>
<li><p><code>onUrlLoading</code>拦截<code>Schema</code></p>
</li>
<li><p>注册js方法（<code>addJavascriptInterface</code>）</p>
</li>
</ul>
</li>
<li><p><code>Android</code>编译打包过程</p>
<p>  aapt -&gt; class -&gt; dex -&gt; 签名</p>
</li>
<li><p>插桩</p>
<p>  ASM插桩，字节码操作</p>
</li>
<li><p>性能监控</p>
<p>  因为我之前做过一个性能监控库，<code>cpu</code>和<code>mem</code>使用<code>TOP</code>命令解析，<code>Anr</code>通过给<code>MainLooper</code>设置<code>Printer</code></p>
</li>
<li><p><code>LeakCanary</code>原理</p>
<p>  <code>WeakReference</code> + <code>ReferenceQueue</code>，加了一些改进点：<code>new</code>一个弱引用的<code>Object</code>，等这个<code>Object</code>确认被回收后再确认<code>Activity</code>是否正常被回收</p>
</li>
<li><p><code>Jetpack Compose</code></p>
<p>  稍微谈了一下看法，是否在项目中用过</p>
</li>
<li><p>算法题：最长公共前缀</p>
<p>  LeetCode 14题，easy难度：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
</li>
</ul>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>一面结束后5min左右，B站HR就给我打电话过来约了二面</p>
<p>二面也是技术面，20min左右，因为是晚上8点面的，估计人家急着想下班（笑）</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>工作职责</p>
</li>
<li><p>工作中有什么亮点</p>
<ul>
<li><p>拍照裁剪业务</p>
</li>
<li><p>单元测试库</p>
</li>
<li><p>性能监控</p>
</li>
<li><p>内存泄漏检测</p>
</li>
</ul>
</li>
<li><p>单元测试的库是怎么做的</p>
<p>  基于<code>Mockito</code>和<code>Robolectric</code>:</p>
<ol>
<li>封装了一个反射库用来方便测试</li>
<li>做了一个<code>AutoCloser</code>类用来自动关闭释放mock的资源，这里提到了使用<code>MockedStatic</code>，如果在使用完后没有释放，那在下一次使用到同一个类的<code>MockedStatic</code>的时候会报错，这里我自定义了一个注解<code>@MockedStatic</code>用来自动mock和释放资源</li>
<li>针对kotlin做了一些mock工具，比如说顶层函数的mock（这个在我以前的文章<a href="https://juejin.cn/post/6932738373522030600" target="_blank" rel="noopener">Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数</a>中介绍过）</li>
</ol>
</li>
<li><p>开发模式（流程规范）：</p>
<p>  开发规范参考了阿里的<code>Java</code>规范和<code>Android</code>规范，选取了一些比较重要的条例和一些自己长时间开发的经验做成了一篇文档</p>
</li>
<li><p>崩溃率的优化，做了哪些事情</p>
<p>  感觉这里没答好，有点答非所问的意思，我就说了说目前处理bug的一个流程，没有谈到怎么解决一个bug</p>
</li>
<li><p>数据打点是怎么做的</p>
<p>  我们用的是神策第三方服务</p>
</li>
<li><p>内存泄漏工具是怎么做的</p>
<p>  这部分同一面<code>LeakCanary</code>原理</p>
</li>
<li><p>看你之前做过一个<code>MQTT</code>协议的客户端，是出于个人兴趣吗</p>
<p>  是的，当时是想要做一个<code>IM</code>应用</p>
</li>
<li><p>在项目中有遇到需要3D渲染展示的内容吗</p>
<p>  目前没有</p>
</li>
<li><p>两个<code>Activity</code>跳转时方法执行的顺序</p>
<p>  一个<code>Activity</code>创建是：onCreate -&gt; onStart -&gt; onResume（之后便在屏幕上显示了）</p>
<p>  假设从<code>A Activity</code>跳转到<code>B Activity</code>：A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop</p>
<p>  从<code>B</code>返回到<code>A</code>：B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory</p>
</li>
<li><p>两个<code>Activity</code>传递数据可以通过什么方式</p>
<ul>
<li><p><code>Intent</code></p>
</li>
<li><p>如果是同一个进程的话，可以用全局变量或者单例等</p>
</li>
<li><p><code>SharedPreference</code></p>
</li>
<li><p>文件</p>
</li>
</ul>
</li>
<li><p>什么时候使用<code>Service</code></p>
<p>  后台任务，比如说后台播放音乐等，这里提了一下<code>IntentService</code>是开了一个子线程的</p>
</li>
<li><p><code>Service</code>怎么启动，怎么停止</p>
<ul>
<li><p><code>startService</code> &lt;—&gt; <code>stopService</code></p>
</li>
<li><p><code>bindService</code> &lt;—&gt; <code>unbindService</code></p>
</li>
</ul>
</li>
<li><p>包体积优化</p>
<p>  清理资源（字体、图片、代码等）</p>
</li>
</ul>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>二面结束后过了2-3天，HR发微信过来恭喜我进入下一轮面试，我问她接下来是还有三面和HR面吗，她回答我说后面就直接是HR面了，说实话我还是挺惊讶的</p>
<p>HR面15min左右，大概就问了一下，为什么要从上家公司离职，我们是一个新部门，处于项目初期，有什么看法之类的，然后问了一下目前的薪资和期望薪资，over~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说实话感觉这次面试太简单了，有点白瞎了我准备了那么多，还做了查漏补缺 ㄟ( ▔, ▔ )ㄏ ，最后祝大家都能找到心仪的工作 (๑•̀ㅂ•́)و✧</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/11/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - Binder驱动（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7069675794028560391" target="_blank" rel="noopener" title="https://juejin.cn/post/7069675794028560391">Android源码分析 - Binder驱动（中）</a>，我们分析了<code>binder_ioctl</code>中的写操作<code>binder_thread_write</code>部分，了解了<code>binder</code>请求的发起与调度，接下来我们就进行<code>binder</code>驱动的最后一部分分析，<code>binder_thread_read</code></p>
<h1 id="binder-ioctl-write-read"><a href="#binder-ioctl-write-read" class="headerlink" title="binder_ioctl_write_read"></a>binder_ioctl_write_read</h1><p>我们还是先从<code>binder_ioctl</code>后的<code>BINDER_WRITE_READ</code>命令码开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将用户空间ubuf拷贝至内核空间bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//当读缓存中有数据，执行binder读操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="comment">//如果todo队列中有未处理的任务，唤醒等待状态下的线程</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">            binder_wakeup_proc_ilocked(proc);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read"></a>binder_thread_read</h1><p>这是进行<code>binder</code>读操作的函数，这个函数也是比较长，我们同样将它分成几个部分：</p>
<ol>
<li>等待可用的<code>binder_work</code></li>
<li>循环获取<code>todo</code>队列中的<code>binder_work</code>，并根据<code>binder_work</code>的<code>type</code>，执行一定的处理</li>
<li>处理<code>binder_transaction</code>以及<code>binder_transaction_data</code>，并将<code>binder_transaction_data</code>拷贝回用户空间</li>
</ol>
<h2 id="第一部分：等待工作"><a href="#第一部分：等待工作" class="headerlink" title="第一部分：等待工作"></a>第一部分：等待工作</h2><h3 id="binder-thread-looper"><a href="#binder-thread-looper" class="headerlink" title="binder_thread.looper"></a>binder_thread.looper</h3><p>在此之前我们需要先看一下之前提到的，在<code>binder_thread</code>中的域成员<code>looper</code>，前面我们只是注释了这个域表示线程状态，这里我们介绍一下它有哪些取值：</p>
<ul>
<li><code>BINDER_LOOPER_STATE_REGISTERED</code>：表示该<code>binder</code>线程是非主<code>binder</code>线程</li>
<li><code>BINDER_LOOPER_STATE_ENTERED</code>：表示该<code>binder</code>线程是主<code>binder</code>线程</li>
<li><code>BINDER_LOOPER_STATE_EXITED</code>：表示该<code>binder</code>线程马上就要退出了</li>
<li><code>BINDER_LOOPER_STATE_INVALID</code>：表示该<code>binder</code>线程是无效的（比如原来是<code>binder</code>主线程，后续用户又发送了一个<code>BC_REGISTER_LOOPER</code>请求）</li>
<li><code>BINDER_LOOPER_STATE_WAITING</code>：表示当前<code>binder</code>线程正在等待请求</li>
<li><code>BINDER_LOOPER_STATE_NEED_RETURN</code>：表示该<code>binder</code>线程在处理完<code>transaction</code>后需要返回到用户态</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//向用户空间写一个binder响应码，该响应码不做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="comment">//检查是否有可用的工作需要处理</span></span><br><span class="line">    wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程的状态置为等待中</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有可用的工作，可以等待进程todo队列中的工作</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        <span class="comment">//这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">        <span class="comment">//这里条件在binder_available_for_proc_work_ilocked中已经做了判断</span></span><br><span class="line">        <span class="comment">//似乎永远不会进入到这个case中？</span></span><br><span class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">            <span class="comment">//进程进入休眠状态，等待唤醒</span></span><br><span class="line">            wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复优先级</span></span><br><span class="line">        binder_restore_priority(current, proc-&gt;default_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (non_block) &#123;    <span class="comment">//如果是非阻塞模式（这里似乎不会执行到）</span></span><br><span class="line">        <span class="comment">//线程和进程的todo队列中都没有工作</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果是阻塞模式</span></span><br><span class="line">        <span class="comment">//等待binder工作到来</span></span><br><span class="line">        ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程的等待中状态解除</span></span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分先检查是否有可用的<code>binder_work</code>待处理，如果有的话进入到下一部分，如果没有的话则需要等待</p>
<p>具体的，我们先看这个函数中的<code>wait_for_proc_work</code>变量，这个变量表示是否需要等待<code>binder_proc</code>中的工作，当在<code>binder_thread</code>中找不到事务栈并且<code>todo</code>队列为空时，此变量值为<code>true</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_available_for_proc_work_ilocked</span><span class="params">(struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !thread-&gt;transaction_stack &amp;&amp;</span><br><span class="line">        binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED |</span><br><span class="line">                   BINDER_LOOPER_STATE_REGISTERED));    <span class="comment">//这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>，我们分析过是有分支会将<code>binder_work</code>直接添加到<code>binder_proc</code>的<code>todo</code>队列中的，当<code>binder_thread</code>中找不到工作的话，可能就需要从<code>binder_proc</code>中找了</p>
<p>然后会将当前线程的状态置为等待中，等到有可处理的<code>binder_work</code>后再解除这个状态</p>
<p>之后会判断传入的参数是否为阻塞模式，这个是由<code>framework</code>层执行<code>ioctl</code>时传入的<code>flags</code>所决定的，根据<code>framework</code>中的<code>binder</code>代码，这里应该恒为阻塞模式，在阻塞模式下，会调用<code>binder_wait_for_work</code>函数，等待存在可用的<code>binder_work</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_wait_for_work</span><span class="params">(struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> do_proc_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个等待队列项</span></span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    freezer_do_not_count();</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//准备睡眠等待</span></span><br><span class="line">        prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">//检查确认是否有binder_work可以处理</span></span><br><span class="line">        <span class="keyword">if</span> (binder_has_work_ilocked(thread, do_proc_work))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//可以处理binder_proc.todo中的工作的话</span></span><br><span class="line">        <span class="keyword">if</span> (do_proc_work)</span><br><span class="line">            <span class="comment">//将该binder线程加入到binder_proc中的等待线程中</span></span><br><span class="line">            list_add(&amp;thread-&gt;waiting_thread_node,</span><br><span class="line">                 &amp;proc-&gt;waiting_threads);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//睡眠</span></span><br><span class="line">        schedule();</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//将该binder线程从binder_proc中的等待线程中移除</span></span><br><span class="line">        list_del_init(&amp;thread-&gt;waiting_thread_node);</span><br><span class="line">        <span class="comment">//检查当前系统调用进程是否有信号处理</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束等待</span></span><br><span class="line">    finish_wait(&amp;thread-&gt;wait, &amp;wait);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    freezer_count();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_has_work_ilocked</span><span class="params">(struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> do_proc_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//thread-&gt;process_todo为false时会延时执行</span></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;process_todo ||</span><br><span class="line">        thread-&gt;looper_need_return ||</span><br><span class="line">        (do_proc_work &amp;&amp;</span><br><span class="line">         !binder_worklist_empty_ilocked(&amp;thread-&gt;proc-&gt;todo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的结构和<code>Linux</code>函数<code>wait_event_interruptible</code>非常相似，我们先来看看它是怎么做到阻塞等待的</p>
<hr>
<h3 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h3><h4 id="DEFINE-WAIT"><a href="#DEFINE-WAIT" class="headerlink" title="DEFINE_WAIT"></a>DEFINE_WAIT</h4><p>这是一个宏，它定义了一个<code>wait_queue_t</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT_FUNC(name, function)				\</span></span><br><span class="line">	<span class="keyword">wait_queue_t</span> name = &#123;						\</span><br><span class="line">		.<span class="keyword">private</span>	= current,				\</span><br><span class="line">		.func		= function,				\</span><br><span class="line">		.task_list	= LIST_HEAD_INIT((name).task_list),	\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><br></pre></td></tr></table></figure>

<p>这个结构体中的<code>private</code>域指向的即是当前执行系统调用所在进程的描述结构体，<code>func</code>域指向唤醒这个队列项进程所执行的函数</p>
<h4 id="prepare-to-wait"><a href="#prepare-to-wait" class="headerlink" title="prepare_to_wait"></a>prepare_to_wait</h4><p>这个函数将我们刚刚定义的<code>wait</code>队列项加入到一个等待队列中（在<code>binder</code>中即是加入到<code>thread-&gt;wait</code>中），然后将进程的状态设置为我们指定的状态，在这里为<code>TASK_INTERRUPTIBLE</code>（可中断的睡眠状态）</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><p><code>schedule</code>是真正执行进程调度的地方，由于之前进程状态已经被设置成<code>TASK_INTERRUPTIBLE</code>状态，在调用<code>schedule</code>后，该进程就会让出<code>CPU</code>，不再调度运行，直到该进程恢复<code>TASK_RUNNING</code>状态</p>
<h4 id="wake-up-interruptible"><a href="#wake-up-interruptible" class="headerlink" title="wake_up_interruptible"></a>wake_up_interruptible</h4><p>我们在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>中提到过，当<code>binder_transaction</code>工作处理完后，会调用<code>wake_up_interruptible</code>函数唤醒目标<code>binder</code>线程的等待队列</p>
<p>这个函数会唤醒<code>TASK_INTERRUPTIBLE</code>状态下的进程，它会循环遍历等待队列中的每个元素，分别执行其唤醒函数，也就对应着我们<code>DEFINE_WAIT</code>定义出来的结构体中的<code>func</code>域，即<code>autoremove_wake_function</code>，它最终会调用<code>try_to_wake_up</code>函数将进程置为<code>TASK_RUNNING</code>状态，这样后面的进程调度便会调度到该进程，从而唤醒该进程继续执行</p>
<h4 id="signal-pending"><a href="#signal-pending" class="headerlink" title="signal_pending"></a>signal_pending</h4><p>这个函数是用来检查当前系统调用进程是否有信号需要处理的，当一个进程陷入系统调用并处于等待状态时，如果此时产生了一个信号，仅仅是在该进程的<code>thread_info</code>中标识了一下，所以我们唤醒进程后需要检查一下是否有信号需要处理，如果有的话，返回<code>-ERESTARTSYS</code>，先处理信号，后续<code>Linux</code>上层库函数会根据<code>-ERESTARTSYS</code>此返回值重新执行这个系统调用</p>
<h4 id="finish-wait"><a href="#finish-wait" class="headerlink" title="finish_wait"></a>finish_wait</h4><p>最后一步，当进程被唤醒后，调用<code>finish_wait</code>函数执行清理工作，将当前进程置为<code>TASK_RUNNING</code>状态，并把当前<code>wait</code>队列项从等待队列中移除</p>
<hr>
<p>了解了上面这些知识，我们再看<code>binder_wait_for_work</code>函数应该比较清晰了，这里有一点需要注意，我们在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>提到，在没有<code>TF_ONE_WAY</code>标志的情况下，会使用<code>binder_enqueue_deferred_thread_work_ilocked</code>函数将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，这个函数区别于<code>binder_enqueue_thread_work_ilocked</code>函数，它没有将<code>thread-&gt;process_todo</code>设为<code>true</code>，所以结合着<code>binder_has_work_ilocked</code>函数看，我们可以发现，当<code>thread-&gt;process_todo</code>为<code>false</code>时，整个<code>binder_has_work_ilocked</code>返回<code>false</code>，即会进入到睡眠状态，延迟执行<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，这么设计可以让<code>binder</code>接收端优先处理事务，提高了性能</p>
<h2 id="第二部分：获取工作，根据type做一定的处理"><a href="#第二部分：获取工作，根据type做一定的处理" class="headerlink" title="第二部分：获取工作，根据type做一定的处理"></a>第二部分：获取工作，根据type做一定的处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//循环处理todo队列中的工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">trd</span> = &amp;<span class="title">tr</span>.<span class="title">transaction_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> trsize = <span class="keyword">sizeof</span>(*trd);</span><br><span class="line"></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//找到需要处理的todo队列</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">            <span class="built_in">list</span> = &amp;thread-&gt;todo;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp;</span><br><span class="line">               wait_for_proc_work)</span><br><span class="line">            <span class="built_in">list</span> = &amp;proc-&gt;todo;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* no data added */</span></span><br><span class="line">            <span class="comment">//只跳过了数据头部的命令码，没有读取任何数据</span></span><br><span class="line">            <span class="keyword">if</span> (ptr - <span class="built_in">buffer</span> == <span class="number">4</span> &amp;&amp; !thread-&gt;looper_need_return)</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传输过来的数据大小不符合</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span> - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) &#123;</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从todo队列中出队一项binder_work</span></span><br><span class="line">        w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">            thread-&gt;process_todo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">                binder_inner_proc_unlock(proc);</span><br><span class="line">                <span class="comment">//根据binder_work找到binder_transaction结构</span></span><br><span class="line">                t = container_of(w, struct binder_transaction, work);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_RETURN_ERROR: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">                binder_inner_proc_unlock(proc);</span><br><span class="line">                cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">                <span class="comment">//回复给用户进程BR_TRANSACTION_COMPLETE响应码</span></span><br><span class="line">                <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新统计数据</span></span><br><span class="line">                binder_stat_br(proc, thread, cmd);</span><br><span class="line">                <span class="comment">//释放</span></span><br><span class="line">                kfree(w);</span><br><span class="line">                binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_NODE: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先创建了一个<code>binder_transaction_data_secctx</code>结构体，后续会将它拷贝到用户空间去，然后创建了一个指针<code>trd</code>指向<code>tr.transaction_data</code>的地址，这样后续操作<code>trd</code>就相当于操作<code>tr.transaction_data</code>了</p>
<p>当进程从睡眠中唤醒，意味着有可用的<code>binder_work</code>了，这时候理论上来说，<code>binder_thread</code>和<code>binder_proc</code>其中总有一个<code>todo</code>队列不为空，这里优先处理<code>binder_thread</code>的<code>todo</code>队列，如果两者都为空，且还未读取过任何数据，重新<code>goto</code>到<code>retry</code>处等待</p>
<p>接着就是将<code>binder_work</code>从相应的<code>todo</code>队列中出队，再根据其类型执行不同的处理操作，这里我们只针对<code>BINDER_WORK_TRANSACTION</code>和<code>BINDER_WORK_TRANSACTION_COMPLETE</code>这两种最重要的类型分析</p>
<p>当类型为<code>BINDER_WORK_TRANSACTION</code>时，表示是别的进程向自己发起<code>binder</code>请求，此时，我们根据<code>binder_work</code>找到对应的<code>binder_transaction</code>结构</p>
<p>当类型为<code>BINDER_WORK_TRANSACTION_COMPLETE</code>时，表示发起的请求<code>BC_TRANSACTION</code>已经完成了，此时将回复给用户空间<code>BR_TRANSACTION_COMPLETE</code>响应码，然后更新统计数据，释放资源</p>
<h2 id="第三部分：处理binder-transaction，拷贝回用户空间"><a href="#第三部分：处理binder-transaction，拷贝回用户空间" class="headerlink" title="第三部分：处理binder_transaction，拷贝回用户空间"></a>第三部分：处理<code>binder_transaction</code>，拷贝回用户空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//循环处理todo队列中的工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">trd</span> = &amp;<span class="title">tr</span>.<span class="title">transaction_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> trsize = <span class="keyword">sizeof</span>(*trd);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//只有在type == BINDER_WORK_TRANSACTION的情况下，t才会被赋值</span></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;<span class="built_in">buffer</span>-&gt;target_node) &#123;    <span class="comment">//binder实体不为NULL，对应着BC_TRANSACTION请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//binder实体在用户空间中的地址</span></span><br><span class="line">            trd-&gt;target.ptr = target_node-&gt;ptr;</span><br><span class="line">            <span class="comment">//携带的额外数据</span></span><br><span class="line">            trd-&gt;cookie =  target_node-&gt;cookie;</span><br><span class="line">            <span class="comment">//优先级</span></span><br><span class="line">            node_prio.sched_policy = target_node-&gt;sched_policy;</span><br><span class="line">            node_prio.prio = target_node-&gt;min_priority;</span><br><span class="line">            binder_transaction_priority(current, t, node_prio,</span><br><span class="line">                            target_node-&gt;inherit_rt);</span><br><span class="line">            <span class="comment">//设置响应码</span></span><br><span class="line">            cmd = BR_TRANSACTION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//binder实体为NULL，对应着BC_REPLY请求</span></span><br><span class="line">            trd-&gt;target.ptr = <span class="number">0</span>;</span><br><span class="line">            trd-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//设置响应码</span></span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示要对目标对象请求的命令代码</span></span><br><span class="line">        trd-&gt;code = t-&gt;code;</span><br><span class="line">        <span class="comment">//事务标志，详见enum transaction_flags</span></span><br><span class="line">        trd-&gt;flags = t-&gt;flags;</span><br><span class="line">        <span class="comment">//请求发起进程的uid</span></span><br><span class="line">        trd-&gt;sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取发起请求的binder线程</span></span><br><span class="line">        t_from = binder_get_txn_from(t);</span><br><span class="line">        <span class="keyword">if</span> (t_from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t_from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            <span class="comment">//设置发起请求的进程pid</span></span><br><span class="line">            trd-&gt;sender_pid =</span><br><span class="line">                task_tgid_nr_ns(sender,</span><br><span class="line">                        task_active_pid_ns(current));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trd-&gt;sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据大小</span></span><br><span class="line">        trd-&gt;data_size = t-&gt;<span class="built_in">buffer</span>-&gt;data_size;</span><br><span class="line">        <span class="comment">//偏移数组大小</span></span><br><span class="line">        trd-&gt;offsets_size = t-&gt;<span class="built_in">buffer</span>-&gt;offsets_size;</span><br><span class="line">        <span class="comment">//设置数据区首地址（这里通过内核空间地址和user_buffer_offset计算得出用户空间地址）</span></span><br><span class="line">        trd-&gt;data.ptr.<span class="built_in">buffer</span> = (<span class="keyword">binder_uintptr_t</span>)</span><br><span class="line">            ((<span class="keyword">uintptr_t</span>)t-&gt;<span class="built_in">buffer</span>-&gt;data +</span><br><span class="line">            binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc));</span><br><span class="line">        <span class="comment">//偏移数组紧挨着数据区，所以它的首地址就为数据区地址加上数据大小</span></span><br><span class="line">        trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.<span class="built_in">buffer</span> +</span><br><span class="line">                    ALIGN(t-&gt;<span class="built_in">buffer</span>-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        tr.secctx = t-&gt;security_ctx;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;security_ctx) &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_SEC_CTX;</span><br><span class="line">            trsize = <span class="keyword">sizeof</span>(tr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回复给用户进程对应的响应码</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr)) &#123;</span><br><span class="line">            ... <span class="comment">//Error</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="comment">//将binder_transaction_data拷贝至用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, trsize)) &#123;</span><br><span class="line">            ... <span class="comment">//Error</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += trsize;</span><br><span class="line">        <span class="comment">//更新数据统计</span></span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时引用计数减1</span></span><br><span class="line">        <span class="keyword">if</span> (t_from)</span><br><span class="line">            binder_thread_dec_tmpref(t_from);</span><br><span class="line">        <span class="comment">//允许释放这个buffer</span></span><br><span class="line">        t-&gt;<span class="built_in">buffer</span>-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            <span class="comment">//非异步处理</span></span><br><span class="line">            binder_inner_proc_lock(thread-&gt;proc);</span><br><span class="line">            <span class="comment">//将这个事务插入到事务栈中</span></span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="comment">//设置目标处理线程</span></span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">            binder_inner_proc_unlock(thread-&gt;proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            binder_free_transaction(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//更新已读数据大小</span></span><br><span class="line">    *consumed = ptr - <span class="built_in">buffer</span>;</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="comment">//请求线程数为0且没有等待线程，已启动线程数小于最大线程数</span></span><br><span class="line">    <span class="comment">//且这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></span><br><span class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) &#123;</span><br><span class="line">        <span class="comment">//向用户空间发送BR_SPAWN_LOOPER响应码，创建新binder线程</span></span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (<span class="keyword">uint32_t</span> __user *)<span class="built_in">buffer</span>))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">//更新统计信息</span></span><br><span class="line">        binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当<code>type == BINDER_WORK_TRANSACTION</code>的情况下，才会走后面的这些逻辑，这一部分主要做的工作是，将处理事务所需要的信息（命令码、PID等）和数据（数据区首地址和偏移数组地址）准备好，拷贝到用户空间，交给用户空间处理这个事务，还有一些细节都在上面代码注释中标出来了，应该还是比较清晰的</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里，从<code>client</code>向<code>binder</code>驱动发起请求，到<code>binder</code>驱动找到<code>server</code>并将请求传递给<code>server</code>这一整个流程我们基本上是看完了，对于被<code>TF_ONE_WAY</code>标记的事务（无需返回），在<code>server</code>中处理完，这一整条<code>binder</code>进程通信流程也就结束了，而对于需要返回的事务，则还需要<code>server</code>向<code>binder</code>驱动发起<code>BC_REPLY</code>事务请求，进行一次进程间通信，将处理后的返回值传给<code>client</code>进程</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们已经将<code>binder</code>驱动所承担的工作分析的七七八八了，但肯定还有很多地方大家云里雾里（实际上我也是这样的），这是因为<code>binder</code>进程间通信不仅需要<code>binder</code>驱动的处理，还需要<code>framework</code>层的协助，很多事情，比如说<code>binder</code>对象的压扁打包就是在<code>framework</code>层做的，我们在<code>binder</code>驱动层只关注了传输，但却不知道传输的是什么，结构是怎样的，当然会产生各种各样的疑惑，后面我们就将会对<code>framework</code>层对<code>binder</code>提供的支持接着做分析</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/01/android/stub/AndroidASM%E6%8F%92%E6%A1%A9/">Android ASM插桩</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%8F%92%E6%A1%A9/">插桩</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%8F%92%E6%A1%A9/">插桩</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ASM插桩在网上其实已经有很多资料了，我之所以再写这篇文章呢，一是因为好久前学习的ASM，现在已经忘的差不多了，需要再回顾一下，二来是记录一下学习过程，以后如果再有细节记不清楚可以很方便的就能查到，三来再学习的过程中也踩了一些坑，收获了一些心得，这些也需要一个地方记录一下。</p>
<p>好了，废话就说到这里，接下来开始正文。</p>
<p>插桩技术指在保证原有程序逻辑完整性的基础上，在程序中插入探针，通过探针采集代码中的信息（方法本身、方法参数值、返回值等）在特定的位置插入代码段，从而收集程序运行时的动态上下文信息。</p>
<p>插桩技术大体可以分为两类：</p>
<ul>
<li><p><code>APT</code>（Annotation Process Tools），在编译的时候，动态生成 <code>Java</code> 文件，之后编译器将生成的 <code>Java</code> 文件编译成 <code>class</code> 文件，像 <code>ButterKnife</code>、<code>Dagger</code> 就是通过 <code>APT</code> 的方式生成代码的。</p>
<ul>
<li>代表工具：<code>ButterKnife</code></li>
</ul>
</li>
<li><p><code>AOP</code>（Aspect Oriented Programming），生成 <code>class</code> 文件后，修改 <code>class</code> 文件的字节码，达到修改代码的目的。</p>
<ul>
<li>代表工具：听云</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>我们这次选用<code>AOP</code>技术，我们看看有哪些工具可以帮助我们完成插桩工作：</p>
<ul>
<li><p><code>AspectJ</code>，成熟稳定，使用者不需要对字节码文件有深入的理解，使用简单。但是其切入点相对固定，对于字节码文件的操作自由度以及开发的掌控度就大打折扣。并且，他会额外生成一些包装代码，对性能以及包大小有一定影响。</p>
</li>
<li><p><code>ASM</code>，可以修改现有的字节码文件，也可以动态生成字节码文件，完全从字节码去操作字节码的框架，更加灵活，功能更加强大，可以根据需求自定义修改、插入、删除，性能也十分出色，但是要对字节码文件有比较深入的了解，上手也更难。</p>
</li>
</ul>
<p>我们使用<code>ASM</code>来完成插桩，在介绍<code>Android</code>字节码插桩之前，需要先了解一下<code>Java</code>字节码的概念和<code>Android</code>程序打包过程。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>我们知道，<code>Java</code>程序是运行在<code>JVM</code>（<code>Java</code>虚拟机）上的，<code>Java</code>源代码首先会由编译器（<code>Java Compiler</code>）编译成包含了<code>Bytecode</code>（字节码）的<code>.class</code>文件，程序执行时，由类加载器(<code>class loader</code>)将该类的字节码加载到<code>JVM</code>中，<code>JVM</code>会解释执行相应的<code>Bytecode</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="Java编译执行过程"></p>
<p>为什么不直接彻底编译成机器码，而需要字节码这个中间产物呢？<code>Java</code>是一门跨平台的语言，为了实现一份源码，处处运行的效果，每个平台都有对应不同的<code>JVM</code>，它会将源码对应的指令翻译成对应平台能够理解的机器指令。那为什么不从源码直接解释执行呢，我个人认为这是因为直接从源码开始的编译，速度非常慢，出于性能的考虑，先将源码做一些预处理，处理为字节码，来减轻运行前的编译的性能开销。</p>
<p>在做插桩之前，我们先要记住一点：<code>Java</code> 字节码指令是基于堆栈操作的，因为大部分的<code>Java</code>虚拟机对字节码的执行是基于堆栈的（<code>Android</code>的<code>Dalvik</code>虚拟机是基于寄存器的，不过不影响我们的插桩，因为在我们对<code>java</code>字节码插完桩后，才会执行从<code>java</code>字节码转换到<code>dex</code>文件的过程）</p>
<h1 id="Android打包过程"><a href="#Android打包过程" class="headerlink" title="Android打包过程"></a>Android打包过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B.png" alt="Android打包过程"></p>
<h1 id="Android插桩过程"><a href="#Android插桩过程" class="headerlink" title="Android插桩过程"></a>Android插桩过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B.png" alt="Android插桩点"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B2.png" alt="Android插桩点"></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>这次，我们模仿听云，做一个<code>Activity</code>生命周期执行时间检测的插件。</p>
<p>我们先梳理一下功能点：</p>
<ol>
<li>针对<code>Activity</code>类</li>
<li>针对生命周期方法</li>
<li>支持插件自定义配置</li>
</ol>
<p>我们用<code>Java</code>代码把我们想要插入的逻辑写一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里取这个名字是为了防止和代码本身的成员变量产生冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> _$_timeRecorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向实际代码前插入代码</span></span><br><span class="line">	_$_timeRecorder = -System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">	... <span class="comment">//这里是实际代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向实际代码后插入代码</span></span><br><span class="line">	_$_timeRecorder += System.currentTimeMillis();</span><br><span class="line">	System.err.println(<span class="string">"Time spent: "</span> + _$_timeRecorder + <span class="string">"ms, when "</span> + className + <span class="string">".onCreate"</span>);</span><br><span class="line">	StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">	<span class="keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;</span><br><span class="line">		System.err.println(element.getClassName() + <span class="string">"."</span> + element.getMethodName() + <span class="string">":"</span> + element.getLineNumber());</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来正式开始编写插件</p>
<h2 id="新建插件工程"><a href="#新建插件工程" class="headerlink" title="新建插件工程"></a>新建插件工程</h2><p>由于<code>Android Studio</code>没有新建<code>gradle</code>脚本的选项，我们先新建一个<code>Empty Activity Project</code>，在此基础上进行改造。</p>
<ol>
<li>新建<code>module</code></li>
<li>更改<code>module</code>的<code>build.gradle</code>文件</li>
<li>新建<code>groovy</code>源代码目录</li>
<li>新建<code>groovy</code>类实现<code>Plugin&lt;Project&gt;</code>接口</li>
<li>新建<code>resource/META_INF/xxx.properites</code>文件（xxx为插件的id名）</li>
<li>在<code>properites</code>文件中声明插件的实现类</li>
</ol>
<h2 id="为插件提供可配置的功能"><a href="#为插件提供可配置的功能" class="headerlink" title="为插件提供可配置的功能"></a>为插件提供可配置的功能</h2><ol>
<li>新建一个实体类用来保存配置信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsmConfigModel</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以此参数为开头的类（全限定类名）才插桩</span></span><br><span class="line"><span class="comment">	 * 如果不配此参数则代表所有类都可插桩</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; startWithPatterns;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; excludes;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 * 以文件形式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> File excludesByFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在插件<code>apply</code>的时候创建这个配置类，以提供给使用者配置</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    mConfig = project.extensions.create(<span class="string">"asmConfig"</span>, AsmConfigModel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在使用该插件的<code>module</code>下的<code>build.gradle</code>文件中配置</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmConfig &#123;</span><br><span class="line">    startWithPatterns = [<span class="string">'com.shanbay'</span>]</span><br><span class="line">    excludesByFile = <span class="keyword">new</span> <span class="keyword">File</span>(projectDir, <span class="string">"asm-excludes.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新建asm-excludes.txt文件，配置exclude信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;xxx&#x2F;xxx&#x2F;BaseActivity</span><br></pre></td></tr></table></figure>

<p>这里是举个例子，在工程中很有可能有的<code>Activity</code>继承自一些基类<code>Activity</code>，对这些类插桩就重复了</p>
<h2 id="使用Transform-Api"><a href="#使用Transform-Api" class="headerlink" title="使用Transform Api"></a>使用Transform Api</h2><p>根据<a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">官网</a>介绍，<code>Transform Api</code>允许第三方 <code>Plugin</code> 在打包 <code>dex</code> 文件之前的编译过程中操作<code>.class</code> 文件，下图是<code>Transform Api</code>的工作流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E8%BF%87%E7%A8%8B.png" alt="Transform Api工作流程"></p>
<p>可以看到，一次<code>App</code>的编译打包可能会经历多次<code>Transform</code>，<code>Transform</code>将输入进行处理，然后写入到指定的目录下作为下一个 <code>Transform</code> 的输入源。</p>
<p>使用插桩工具，我们需要借助于<code>Transform Api</code>实现</p>
<ol>
<li>首先，我们需要让我们的插件继承自<code>Transform</code></li>
<li>然后，我们要在插件<code>apply</code>时注册<code>Transform</code></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    <span class="keyword">def</span> android = project.extensions.getByType(AppExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">android</span>.<span class="title">registerTransform</span>(<span class="title">this</span>)</span></span><br><span class="line"><span class="class">    <span class="title">mConfig</span> = <span class="title">project</span>.<span class="title">extensions</span>.<span class="title">create</span>("<span class="title">asmConfig</span>", <span class="title">AsmConfigModel</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最后，需要实现<code>Transform</code>类中的抽象方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E7%B1%BB.png" alt="Transform抽象方法"></p>
<ul>
<li><code>getName</code> 这个方法是指定这个<code>Transform</code>的名称</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">String getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'AsmPlugin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getInputTypes</code> 这个方法是指定输入类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes.png" alt="Transform输入类型"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes2.png" alt="Transform输入类型"></p>
<p>这里，我们选用<code>TransformManager.CONTENT_CLASS</code>就可以了</p>
<ul>
<li><code>getScopes</code> 这个方法是指定插桩的作用域</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes.png" alt="Transform作用域"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes2.png" alt="Transform作用域"></p>
<p>这里我们选择<code>TransformManager.SCOPE_FULL_PROJECT</code>，代表插桩范围包括此工程和它依赖的所有包</p>
<ul>
<li><code>isIncremental</code> 这个方法代表是否开启增量编译</li>
</ul>
<p>如果开启的话可以减少编译时间，但需要增加额外的判断条件，所以这里就先不开启了</p>
<ul>
<li><code>transform</code> 这个方法是核心方法，我们要对输入内容进行处理然后输出</li>
</ul>
<p><code>transform()</code>方法的参数 <code>TransformInvocation</code> 是一个接口，提供了一些关于输入输出的一些基本信息。下图是<code>transform</code>中我们需要走的流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_transform%E6%B5%81%E7%A8%8B.png" alt="Transform流程"></p>
<p>这里以<code>directoryInputs</code>举例，<code>directoryInputs</code>就是本地源码编译后产生的<code>class</code>文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> handleDirectory(DirectoryInput input, TransformOutputProvider outputProvider) &#123;</span><br><span class="line">    File file = input.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">//递归遍历该文件夹下面所有的子文件夹以及子文件</span></span><br><span class="line">        file.eachFileRecurse &#123; subFile -&gt;</span><br><span class="line">            <span class="keyword">def</span> fileName = subFile.name</span><br><span class="line">            <span class="comment">//初步判断这个文件（或文件夹）是否可插桩</span></span><br><span class="line">            <span class="keyword">if</span> (fileName.endsWith(<span class="string">".class"</span>) &amp;&amp; !fileName.startsWith(<span class="string">"R$"</span>)</span><br><span class="line">                    &amp;&amp; <span class="string">"R.class"</span> != fileName &amp;&amp; <span class="string">"BuildConfig.class"</span> != fileName) &#123;</span><br><span class="line">                <span class="comment">//ClassReader: 字节码的读取与分析引擎</span></span><br><span class="line">                ClassReader classReader = <span class="keyword">new</span> ClassReader(subFile.bytes)</span><br><span class="line">                <span class="comment">//ClassWriter: 它实现了ClassVisitor接口，用于拼接字节码</span></span><br><span class="line">                <span class="comment">//COMPUTE_MAXS: 自动计算栈的最大值以及本地变量的最大数量</span></span><br><span class="line">                <span class="comment">//COMPUTE_FRAMES: 包含COMPUTE_MAXS，且会自动计算方法的栈桢</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="comment">//ClassVisitor: 定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等</span></span><br><span class="line">                ClassVisitor cv = <span class="keyword">new</span> AsmClassVisitor(api, classWriter, mConfig)</span><br><span class="line">                <span class="comment">//使给定的ClassVisitor访问传递给此构造函数的jvm类文件结构</span></span><br><span class="line">                <span class="comment">//EXPAND_FRAMES: 展开栈帧的标志位</span></span><br><span class="line">                classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        subFile.parentFile.absolutePath + File.separator + fileName)</span><br><span class="line">                fos.write(classWriter.toByteArray())</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = outputProvider.getContentLocation(</span><br><span class="line">            input.name,</span><br><span class="line">            input.contentTypes,</span><br><span class="line">            input.scopes,</span><br><span class="line">            Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectoryToDirectory(file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用以下流程图大概描述一下一个<code>class</code>文件的修改过程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_class%E4%BF%AE%E6%94%B9%E8%BF%87%E7%A8%8B.png" alt="class文件修改流程"></p>
<h2 id="自定义ClassVisitor"><a href="#自定义ClassVisitor" class="headerlink" title="自定义ClassVisitor"></a>自定义ClassVisitor</h2><p>我们开始继承<code>ClassVisitor</code>来实现我们对类的修改</p>
<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE.png" alt="读取配置"></p>
<h3 id="访问类"><a href="#访问类" class="headerlink" title="访问类"></a>访问类</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB.png" alt="访问类方法"></p>
<p>通过这个方法我们可以获得这个类的访问控制，全限定类名，父类名，实现的接口名等信息</p>
<p>这里，我们通过全限定类名和读取出的配置做比对，进一步验证是否需要对此类进行插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB.png" alt="验证类是否可插桩"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB2.png" alt="验证类是否可插桩"></p>
<h3 id="访问类内方法"><a href="#访问类内方法" class="headerlink" title="访问类内方法"></a>访问类内方法</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%86%85%E6%96%B9%E6%B3%95.png" alt="访问类内方法"></p>
<p>通过这个方法我们可以获得这个类的所有方法的名称和描述符，我们通过它们来判断该方法是否需要插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E6%96%B9%E6%B3%95.png" alt="判断方法是否需要插桩"></p>
<p>如果有需要插桩的方法，就将<code>mNeedStubClass</code>标志位置为true，这个标识是为了我们后续判断是否要在该类中插入成员变量，然后使用我们自定义的<code>MethodVisitor</code>替换原始的<code>MethodVisitor</code>。</p>
<h3 id="插入成员变量"><a href="#插入成员变量" class="headerlink" title="插入成员变量"></a>插入成员变量</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E5%85%A5%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="插入成员变量"></p>
<p>在最后，如果有需要插桩的方法，我们需要将<code>private long _$_timeRecorder</code>这个成员变量插入到类中去</p>
<h2 id="自定义MethodVisitor"><a href="#自定义MethodVisitor" class="headerlink" title="自定义MethodVisitor"></a>自定义MethodVisitor</h2><p>之前说了，<code>Java</code> 字节码指令是基于栈操作的，基本上任何操作都会改变栈状态</p>
<h3 id="在方法执行之前插入代码"><a href="#在方法执行之前插入代码" class="headerlink" title="在方法执行之前插入代码"></a>在方法执行之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* 此时，this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设此时栈为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">    mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//invokestatic: 调用静态方法System.currentTimeMillis()，返回值为基础类型long</span></span><br><span class="line">    <span class="comment">//第二个参数代表类的全限定名，第三个参数代表方法名，第四个参数代表函数签名，()J的意思是不接受参数，返回值为J (J在字节码里代表基础类型long)</span></span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lneg: 将栈顶的long类型取负并将结果压入栈顶</span></span><br><span class="line">    mv.visitInsn(Opcodes.LNEG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值取负, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//putfield: 为该类的此实例变量赋值</span></span><br><span class="line">    <span class="comment">//以(栈顶 - 1)为执行对象，为其赋值为栈顶值 (this._$_timeRecorder = -System.currentTimeMillis())</span></span><br><span class="line">    mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在方法return之前插入代码"><a href="#在方法return之前插入代码" class="headerlink" title="在方法return之前插入代码"></a>在方法return之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">        Label labelEnd = <span class="keyword">new</span> Label();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//dup: 将栈顶的值复制一份压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行System.currentTimeMillis()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis()执行后的结果值, this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶两long值相加，并将结果压入栈顶</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitInsn(Opcodes.LADD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis() + this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶的值存入(栈顶 - 1)._$_timeRecorder中</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder = this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//L: 对象类型，以分号结尾，如Ljava/lang/Object;</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建字符串</span></span><br><span class="line">        <span class="comment">//创建一个StringBuilder对象，此时还并没有执行构造方法</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        <span class="comment">//因为执行构造函数会将栈顶的StringBuilder对象弹出，为了后续能继续使用这个对象，所以这里需要先复制一份</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的StringBuilder调用构造方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"Time spent: "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            ["Time spent: ", StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(J)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"ms, when "</span> + mFormatClassName + <span class="string">"."</span> + mMethodName + <span class="string">":"</span> + mMethodDescriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [字符串常量, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行StringBuilder.toString()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行PrintStream.println()方法</span></span><br><span class="line">        <span class="comment">//相当于System.out.println(String)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Thread.currentThread()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/Thread"</span>, <span class="string">"currentThread"</span>, <span class="string">"()Ljava/lang/Thread;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [Thread.currentThread()执行的结果]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行getStackTrace()方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//相当于Thread.currentThread().getStackTrace()</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/Thread"</span>, <span class="string">"getStackTrace"</span>, <span class="string">"()[Ljava/lang/StackTraceElement;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//astore: 将一个引用类型对象保存到局部变量表index为2的位置（index1: this, index2: onCreate方法的参数）</span></span><br><span class="line">        <span class="comment">//使用一个临时变量保存StackTraceElement数组</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//将局部变量表index2处的引用对象压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StackTraceElement数组备份</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">3</span>);</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得栈顶位置数组的长度</span></span><br><span class="line">        mv.visitInsn(Opcodes.ARRAYLENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组length保存至局部变量表index4的位置</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4   ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将int常量0压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">        <span class="comment">//将栈顶的0取出保存（用作循环下标index）</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环开始处</span></span><br><span class="line">        <span class="comment">//插入一个label用来做后续循环跳转的标志</span></span><br><span class="line">        Label labelLoop = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(labelLoop);</span><br><span class="line">        <span class="comment">//将循环标志位的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数组长度值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环标志位, 数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//if_icmpge: 比较栈顶两int型数值大小, 当结果大于等于0时跳转</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.IF_ICMPGE, labelEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将循环index的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环index, StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将引用类型数组指定索引的值推送至栈顶（var3[var5]）</span></span><br><span class="line">        mv.visitInsn(Opcodes.AALOAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该索引下的值保存</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将System.out入栈</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new StringBuilder()</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出StackTraceElement数组中的某个值(以循环index作为下标)</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标), StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用栈顶对象，执行getClassName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getClassName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [ClassName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以ClassName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//即StringBuilder.append(ClassName)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"."</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getMethodName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getMethodName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [MethodName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以MethodName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getLineNumber方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getLineNumber"</span>, <span class="string">"()I"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [LineNumber, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以LineNumber作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(I)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用栈顶对象的toString方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以String作为参数，执行(栈顶 - 1)对象System.out的println方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iinc: 将指定int型变量增加指定值(index++)</span></span><br><span class="line">        mv.visitIincInsn(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//跳转到labelLoop插入的位置</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.GOTO, labelLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入结束Label，作为循环终止的跳转标志</span></span><br><span class="line">        mv.visitLabel(labelEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的方法插桩工作就完成了，接下来我们运行一下看看</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先<code>clean build</code>，再<code>build</code>，查看控制台信息，<code>build</code>完成后查看<code>class</code>文件</p>
<p>运行<code>App</code>，查看<code>Logcat</code>信息，可以看到打印出来了我们想要的信息。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这样我们就通过插桩的方式，实现了一个简单的无任何代码侵入的性能检测工具</p>
<p>通过这一次实践，我对<code>java</code>的编译运行字节码，<code>Android</code>的打包流程有了更深的理解</p>
<p>完整项目地址：<a href="https://github.com/dreamgyf/AsmPluginDemo" target="_blank" rel="noopener">https://github.com/dreamgyf/AsmPluginDemo</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/">Android源码分析 - Binder驱动（中）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="https://juejin.cn/post/7059601252367204365">Android源码分析 - Binder驱动（上）</a>，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，接下来我们继续分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>我们先简单介绍一下<code>ioctl</code>函数，这个函数是用来控制设备的，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd , <span class="keyword">unsigned</span> <span class="keyword">long</span> cmd , ...<span class="comment">/* args */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>fd</code>为设备的文件描述符</p>
<p>第二个参数<code>cmd</code>为命令码，它由驱动方自定义，用户通过命令码告诉设备驱动想要它做什么</p>
<p>后面为可选参数，具体内容和<code>cmd</code>有关，是传入驱动层的参数</p>
<h2 id="命令码"><a href="#命令码" class="headerlink" title="命令码"></a>命令码</h2><p><code>Linux</code>内核是这么定义一个命令码的</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>序列号</th>
<th>方向</th>
<th>数据尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>8 bit</td>
<td>8 bit</td>
<td>2 bit</td>
<td>8~14 bit</td>
</tr>
</tbody></table>
<p>这样，一个命令就变成了一个整数形式的命令码了，为了使用起来方便，<code>Linux</code>定义了一些生成命令码的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO(type,nr)        <span class="comment">//没有参数的命令</span></span><br><span class="line">_IOR(type,nr,<span class="built_in">size</span>)  <span class="comment">//从驱动中读数据</span></span><br><span class="line">_IOW(type,nr,<span class="built_in">size</span>)  <span class="comment">//写数据到驱动中</span></span><br><span class="line">_IOWR(type,nr,<span class="built_in">size</span>) <span class="comment">//双向读写</span></span><br></pre></td></tr></table></figure>

<h1 id="binder驱动命令码"><a href="#binder驱动命令码" class="headerlink" title="binder驱动命令码"></a>binder驱动命令码</h1><p>了解了<code>ioctl</code>和它的命令码后，我们来看看<code>binder</code>驱动定义了哪些命令码，以及它们分别有什么作用</p>
<p><code>binder</code>驱动命令码被定义在<code>include/uapi/linux/android/binder.h</code>中，其中有几个貌似未使用，我就不列出来了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ		_IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS		_IOW(<span class="meta-string">'b'</span>, 5, __u32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR		_IOW(<span class="meta-string">'b'</span>, 7, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT		_IOW(<span class="meta-string">'b'</span>, 8, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION			_IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_DEBUG_INFO	_IOWR(<span class="meta-string">'b'</span>, 11, struct binder_node_debug_info)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_INFO_FOR_REF	_IOWR(<span class="meta-string">'b'</span>, 12, struct binder_node_info_for_ref)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR_EXT	_IOW(<span class="meta-string">'b'</span>, 13, struct flat_binder_object)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>BINDER_WRITE_READ</code>：读写命令，用于数据传输，<code>binder IPC</code>通信中的核心</li>
<li><code>BINDER_SET_MAX_THREADS</code>：设置最大线程数</li>
<li><code>BINDER_SET_CONTEXT_MGR</code>：设置成为<code>binder</code>上下文管理者</li>
<li><code>BINDER_THREAD_EXIT</code>：<code>binder</code>线程退出命令，释放相关资源</li>
<li><code>BINDER_VERSION</code>：获取<code>binder</code>驱动版本号</li>
<li><code>BINDER_GET_NODE_DEBUG_INFO</code>：获得<code>binder</code>节点的<code>debug</code>信息</li>
<li><code>BINDER_GET_NODE_INFO_FOR_REF</code>：从<code>binder</code>引用获得<code>binder</code>节点信息</li>
<li><code>BINDER_SET_CONTEXT_MGR_EXT</code>：和<code>BINDER_SET_CONTEXT_MGR</code>作用相同，携带额外参数</li>
</ul>
<p>了解了这些<code>binder</code>驱动命令码，我们就可以开始正式分析<code>binder_ioctl</code></p>
<h1 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h1><p>这个函数位于<code>drivers/android/binder.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="comment">//从命令参数中解析出用户数据大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//进入休眠状态，等待被唤醒</span></span><br><span class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_unlocked;</span><br><span class="line">    <span class="comment">//根据请求系统调用的线程的pid，查找对应的binder_thread，没有则新建一个</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_DEBUG_INFO: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体上来看还是比较清晰的，我们对一些点做一下详解</p>
<h2 id="user"><a href="#user" class="headerlink" title="__user"></a>__user</h2><p><code>__user</code>是一个宏，它告诉编译器不应该解除这个指针的引用（因为在当前地址空间中它是没有意义的），<code>(void __user *)arg</code>表示<code>arg</code>是一个用户空间的地址，不能直接进行拷贝等，要使用<code>copy_from_user</code>，<code>copy_to_user</code>等函数。</p>
<h2 id="wait-event-interruptible"><a href="#wait-event-interruptible" class="headerlink" title="wait_event_interruptible"></a>wait_event_interruptible</h2><p><code>wait_event_interruptible(wq, condition)</code>是一个宏，它是用来挂起进程直到满足判断条件的</p>
<p><code>binder_stop_on_user_error</code>是一个全局变量，它的初始值为0，<code>binder_user_error_wait</code>是一个等待队列</p>
<p>在正常情况下，<code>binder_stop_on_user_error &lt; 2</code>这个条件是成立的，所以不会进入挂起状态，而当<code>binder</code>因为错误而停止后，调用<code>binder_ioctl</code>，则会挂起进程，直到其他进程通过<code>wake_up_interruptible</code>来唤醒<code>binder_user_error_wait</code>队列，并且满足<code>binder_stop_on_user_error &lt; 2</code>这个条件，<code>binder_ioctl</code>才会继续往后运行</p>
<h2 id="binder-thread结构体"><a href="#binder-thread结构体" class="headerlink" title="binder_thread结构体"></a>binder_thread结构体</h2><p>我们需要关注一个重要的结构体<code>binder_thread</code>，它在后续的代码中会频繁的出现，这个结构体描述了进程中的工作线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="comment">//binder线程所属的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_thread_node</span>;</span></span><br><span class="line">    <span class="comment">//进程pid</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//描述了线程当前的状态</span></span><br><span class="line">    <span class="keyword">int</span> looper;              <span class="comment">/* only modified by this thread */</span></span><br><span class="line">    <span class="keyword">bool</span> looper_need_return; <span class="comment">/* can be written by other thread */</span></span><br><span class="line">    <span class="comment">//binder事务栈（链表形式，内部存在前后节点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">    <span class="comment">//todo队列，为需要处理的工作的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="comment">//binder_thread_write后是否立即执行完成binder_thread_read</span></span><br><span class="line">    <span class="comment">//false的情况下会在binder_thread_read中休眠，延迟执行BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    <span class="keyword">bool</span> process_todo;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">return_error</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">reply_error</span>;</span></span><br><span class="line">    <span class="comment">//等待队列，当处理binder事务需要依赖别的binder事务的时候，则会以此等待队列睡眠</span></span><br><span class="line">    <span class="comment">//直到它所依赖的binder事务完成后唤醒</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="comment">//统计信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="comment">//临时引用计数</span></span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="comment">//是否死亡</span></span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//线程信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="binder-get-thread"><a href="#binder-get-thread" class="headerlink" title="binder_get_thread"></a>binder_get_thread</h2><p>接下来我们看一下<code>binder_ioctl</code>是怎么获得<code>binder_thread</code>的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">new_thread</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">if</span> (!thread) &#123;</span><br><span class="line">        new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (thread != new_thread)</span><br><span class="line">            kfree(new_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到里面有锁操作，使用的就是上一章<a href="https://juejin.cn/post/7062654742329032740#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中所介绍过的<code>spinlock</code>，使用的是<code>binder_proc</code>结构体中的<code>inner_lock</code></p>
<p>简单浏览一下代码我们就可以知道，<code>binder_get_thread</code>首先试着从<code>binder_proc</code>获得<code>binder_thread</code>，如果没能获得，就新建一个，这两种情况都调用了<code>binder_get_thread_ilocked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread_ilocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc *proc, struct binder_thread *new_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!new_thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    thread = new_thread;</span><br><span class="line">    <span class="comment">//binder_thread对象创建计数加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">    thread-&gt;proc = proc;</span><br><span class="line">    thread-&gt;pid = current-&gt;pid;</span><br><span class="line">    <span class="comment">//引用计数加1</span></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    thread-&gt;task = current;</span><br><span class="line">    atomic_set(&amp;thread-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">    <span class="comment">//初始化todo队列</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">//插入红黑树</span></span><br><span class="line">    rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">    thread-&gt;looper_need_return = <span class="literal">true</span>;</span><br><span class="line">    thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">    thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">    INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数分为前后两个部分，前半部分通过<code>binder_proc-&gt;threads</code>这个红黑树查找当前系统调用进程<code>pid</code>所对应的<code>binder_thread</code>，后半部分初始化了传入的<code>new_thread</code>，并将其插入到红黑树中（<code>binder_proc-&gt;threads</code>）</p>
<hr>
<p>接下来就是判断命令码<code>cmd</code>，来执行相应的工作了，我们只分析比较重要的几个命令码</p>
<h1 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h1><p><code>binder</code>驱动中最重要的命令码肯定非<code>BINDER_WRITE_READ</code>莫属了，这个命令用来进行<code>binder</code>读写交互</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch case命令码后，直接调用了<code>binder_ioctl_write_read</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验用户传入arg数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户空间ubuf拷贝至内核空间bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//当写缓存中有数据，执行binder写操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        trace_binder_write_done(ret);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有错误发生，将已读数据大小设为0</span></span><br><span class="line">            bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当读缓存中有数据，执行binder读操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="comment">//如果todo队列中有未处理的任务，唤醒等待状态下的线程</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">            binder_wakeup_proc_ilocked(proc);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将内核空间修改后的bwr拷贝至用户空间ubuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="binder-write-read结构体"><a href="#binder-write-read结构体" class="headerlink" title="binder_write_read结构体"></a>binder_write_read结构体</h2><p><code>BINDER_WRITE_READ</code>命令码所接受的参数为一个<code>binder_write_read</code>结构体，我们先来了解一下它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_size;        <span class="comment">/* bytes to write */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_consumed;    <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     write_buffer;</span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_size;         <span class="comment">/* bytes to read */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_consumed;     <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>write_size</code>：写数据的总大小</li>
<li><code>write_consumed</code>：已写数据大小</li>
<li><code>write_buffer</code>：写数据的虚拟内存地址</li>
<li><code>read_size</code>：读数据的总大小</li>
<li><code>read_consumed</code>：已读数据大小</li>
<li><code>read_buffer</code>：读数据的虚拟内存地址</li>
</ul>
<hr>
<p>整个<code>binder_ioctl_write_read</code>函数结构是比较简单的，首先校验了一下用户空间所传的参数<code>arg</code>为<code>binder_write_read</code>结构体，接着将其从用户空间拷贝至内核空间<code>bwr</code>，接下来便是分别检查写缓存读缓存中是否有数据，有的话则执行相应的写读操作。这里需要注意的是，读写操作所传入的<code>write_consumed</code>和<code>read_consumed</code>是以地址的形式，即会对这两个值进行修改，不管读写操作是否执行，成功或者失败，最后都会调用<code>copy_to_user</code>将<code>bwr</code>从内核空间复制到用户空间<code>ubuf</code></p>
<p>看到这里，可能有些同学会觉得有些奇怪，说好<code>binder</code>只进行一次复制的呢？其实是这样的没错，这里的<code>copy_from_user</code>或者<code>copy_to_user</code>只是复制了<code>binder_write_read</code>结构体，得到了需要IPC数据的虚拟内存地址而已，真正的复制操作是在<code>binder</code>读写操作中进行的</p>
<h2 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write"></a>binder_thread_write</h2><p>先看<code>binder</code>写操作，这个函数首先从传入的参数中，计算出待写的起始地址和结束地址，因为可能数据中含有多个命令和对应数据要处理，所以这里开了一个循环，在循环中，首先调用<code>get_user</code>，从用户空间读取一个值到内核空间中来，这个值就是<code>binder</code>请求码，然后将指针向后移动32位，使其指向对应请求码的数据头，接着根据<code>binder</code>请求码去完成不同的工作，处理完后修改已写数据大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//可能含有多个命令和对应数据要处理</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; <span class="built_in">end</span> &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得binder请求码</span></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">//使指针指向数据头</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        <span class="comment">//记录binder数据信息</span></span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据binder请求码，执行不同工作</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BC_DECREFS: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS_DONE:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_ATTEMPT_ACQUIRE:</span><br><span class="line">            pr_err(<span class="string">"BC_ATTEMPT_ACQUIRE not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_RESULT:</span><br><span class="line">            pr_err(<span class="string">"BC_ACQUIRE_RESULT not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION_SG:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY_SG: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_DEAD_BINDER_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">"%d:%d unknown command %d\n"</span>,</span><br><span class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置已写数据大小</span></span><br><span class="line">        *consumed = ptr - <span class="built_in">buffer</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="binder请求码"><a href="#binder请求码" class="headerlink" title="binder请求码"></a>binder请求码</h3><p><code>binder</code>请求码用于用户空间程序向<code>binder</code>驱动发送请求消息，以<code>BC</code>开头，被定义在<code>enum</code> <code>binder_driver_command_protocol</code>中（<code>include/uapi/linux/android/binder.h</code>）</p>
<p>命令                            | 说明                           | 参数类型                    |<br>| —————————– | —————————- | ——————– |<br>| BC_TRANSACTION                | Binder事务，即：Client对于Server的请求 | binder_transaction_data |<br>| BC_REPLY                      | 事务的应答，即：Server对于Client的回复    | binder_transaction_data |<br>| BC_FREE_BUFFER                | 通知驱动释放Buffer                 | binder_uintptr_t |<br>| BC_ACQUIRE                    | 强引用计数+1                      | __u32             |<br>| BC_RELEASE                    | 强引用计数-1                      | __u32             |<br>| BC_INCREFS                    | 弱引用计数+1                      | __u32             |<br>| BC_DECREFS                    | 弱引用计数-1                      | __u32             |<br>| BC_ACQUIRE_DONE               | BR_ACQUIRE的回复                | binder_ptr_cookie  |<br>| BC_INCREFS_DONE               | BR_INCREFS的回复                | binder_ptr_cookie  |<br>| BC_ENTER_LOOPER               | 通知驱动主线程ready                 | void            |<br>| BC_REGISTER_LOOPER            | 通知驱动子线程ready                 | void            |<br>| BC_EXIT_LOOPER                | 通知驱动线程已经退出                   | void          |<br>| BC_REQUEST_DEATH_NOTIFICATION | 请求接收死亡通知             | binder_handle_cookie    |<br>| BC_CLEAR_DEATH_NOTIFICATION   | 去除接收死亡通知             | binder_handle_cookie    |<br>| BC_DEAD_BINDER_DONE           | 已经处理完死亡通知            | binder_uintptr_t       |<br>| BC_ATTEMPT_ACQUIRE            | 暂不支持                         | -                 |<br>| BC_ACQUIRE_RESULT             | 暂不支持                         | -                 |</p>
<p>其中，最重要且最频繁的操作为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>，我们就只分析一下这两个请求码做了什么事</p>
<h3 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">                       cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个请求码，首先从用户空间中复制了一份<code>binder_transaction_data</code>到内核空间，接着就调用<code>binder_transaction</code>函数继续处理</p>
<h4 id="binder-transaction-data结构体"><a href="#binder-transaction-data结构体" class="headerlink" title="binder_transaction_data结构体"></a>binder_transaction_data结构体</h4><p>在分析<code>binder_transaction</code>函数前，我们需要先了解一些结构体</p>
<p><code>binder_transaction_data</code>结构体就是<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>所对应的参数类型，它被定义在<code>include/uapi/linux/android/binder.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象非本地binder实体时，用handle表示对目标binder的引用</span></span><br><span class="line">        __u32	handle;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象是本地binder实体时，用此域成员变量表示这个对象在本进程中的内存地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span> ptr;</span><br><span class="line">    &#125; target;</span><br><span class="line">    <span class="comment">//目标binder实体所带的附加数据</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">    <span class="comment">//表示要对目标对象请求的命令代码</span></span><br><span class="line">    __u32		code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务标志，详见enum transaction_flags</span></span><br><span class="line">    __u32	        flags;</span><br><span class="line">    <span class="comment">//发起请求的进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span>		sender_pid;</span><br><span class="line">    <span class="comment">//发起请求的进程uid</span></span><br><span class="line">    <span class="keyword">uid_t</span>		sender_euid;</span><br><span class="line">    <span class="comment">//真正要传输的数据的大小</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	data_size;</span><br><span class="line">    <span class="comment">//偏移数组大小，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">//数据区的首地址</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	<span class="built_in">buffer</span>;</span><br><span class="line">            <span class="comment">//偏移数组的首地址，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">            <span class="comment">//数组的每一项为一个binder_size_t，这个值对应着每一个binder对象相对buffer首地址的偏移</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	offsets;</span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">//数据较小的时候可以直接装在这个数组里</span></span><br><span class="line">        __u8	buf[<span class="number">8</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，真正需要拷贝的数据的地址是保存在<code>data</code>域中的，可能文字描述的<code>data</code>结构不是特别清晰，可以结合下图理解：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data.png" alt="data结构"></p>
<p>这里我用一个例子来解释一下<code>binder_transaction_data</code>传输的数据是什么样子的</p>
<p>小伙伴们应该都了解<code>Parcel</code>吧，它是一个存放读取数据的容器，我们<code>binder_transaction_data</code>中实际传输的数据就是通过它组合而成的，它可以传输基本数据类型，<code>Parcelable</code>类型和<code>binder</code>类型</p>
<p>其中基本数据类型就不用说了，每种基本类型所占用的大小是固定的，<code>Parcelable</code>类型实际上也是传输基本数据类型，它是通过实现<code>Parcelable</code>接口将一个复杂对象中的成员序列化成了一个个基本数据类型传输，而<code>binder</code>类型的传输有点特别，它会将这个<code>binder</code>对象 “压扁” 成一个<code>flat_binder_object</code>结构体传输</p>
<p>假设我们有一个客户端<code>client</code>，一个服务端<code>server</code>，<code>client</code>想要向<code>binder</code>驱动发起一个事物，调用<code>server</code>的某个方法，我们该怎么构建<code>binder_transaction_data</code>的数据区呢？</p>
<p>一般来说，我们需要先写一个<code>token</code>，这个<code>token</code>是为了进行校验的，两端需要保持一致。接着我们需要按顺序依次写入参数，假设我们想要调用<code>server</code>的<code>callMe(int, Parcelable, IBinder)</code>函数，那我们就需要先写入一个<code>int</code>，再写入一个<code>Parcelable</code>，最后再将<code>IBinder</code> “压扁” 成一个<code>flat_binder_object</code>写入。</p>
<p>此时数据布局如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data2.png" alt="data结构"></p>
<p>从图中我们可以看出来，<code>offsets</code>指示出了<code>buffer</code>中传输的<code>binder</code>对象的位置，有几个<code>binder</code>对象，就会有几个<code>offset</code>与之对应</p>
<h5 id="transaction-flags"><a href="#transaction-flags" class="headerlink" title="transaction_flags"></a>transaction_flags</h5><p>我们再看一下有哪些事务标志，他们分别代表什么意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> transaction_flags &#123;</span><br><span class="line">    <span class="comment">//单向调用，异步操作，无返回</span></span><br><span class="line">    TF_ONE_WAY	        = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个组件的根对象，对应类型为本地binder</span></span><br><span class="line">    TF_ROOT_OBJECT	= <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个32位的状态码，对应类型为远程binder引用的句柄</span></span><br><span class="line">    TF_STATUS_CODE	= <span class="number">0x08</span>,</span><br><span class="line">    <span class="comment">//可以接收一个文件描述符，对应的类型为文件（BINDER_TYPE_FD），即handle中存储的为文件描述符</span></span><br><span class="line">    TF_ACCEPT_FDS	= <span class="number">0x10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-transaction结构体"><a href="#binder-transaction结构体" class="headerlink" title="binder_transaction结构体"></a>binder_transaction结构体</h4><p><code>binder_transaction</code>结构体用来描述进程间通信过程（事务），它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="comment">//用来描述需要处理的工作事项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="comment">//发起事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line">    <span class="comment">//事务所依赖的另一个事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="comment">//目标线程下一个需要处理的事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="comment">//1: 表示同步事务，需要等待对方回复</span></span><br><span class="line">    <span class="comment">//0: 表示异步事务</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向为该事务分配的内核缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	flags;</span><br><span class="line">    <span class="comment">//发起事务线程的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">priority</span>;</span></span><br><span class="line">    <span class="comment">//线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求</span></span><br><span class="line">    <span class="comment">//在修改之前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">saved_priority</span>;</span></span><br><span class="line">    <span class="keyword">bool</span>    set_priority_called;</span><br><span class="line">    <span class="keyword">kuid_t</span>	sender_euid;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> security_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-work结构体"><a href="#binder-work结构体" class="headerlink" title="binder_work结构体"></a>binder_work结构体</h4><p><code>binder_work</code>结构体用来描述需要处理的工作事项，它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> &#123;</span></span><br><span class="line">    <span class="comment">//双向链表中的一个节点，这个链表储存了所有的binder_work</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作项类型</span></span><br><span class="line">    <span class="keyword">enum</span> binder_work_type &#123;</span><br><span class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</span><br><span class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</span><br><span class="line">        BINDER_WORK_RETURN_ERROR,</span><br><span class="line">        BINDER_WORK_NODE,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</span><br><span class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</span><br><span class="line">    &#125; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>简单看完了一些必要的结构体后，我们把目光转回<code>binder_transaction</code>函数上</p>
<p><code>binder_transaction</code>函数的代码很长，我们精简一下，然后再分段来看，从整体上，我们可以将它分为几个部分：</p>
<ol>
<li>获得目标进程/线程信息</li>
<li>将数据拷贝到目标进程所映射的内存中（此时会建立实际的映射关系）</li>
<li>将待处理的任务加入<code>todo</code>队列，唤醒目标线程</li>
</ol>
<h4 id="第一部分：获得目标进程-线程信息"><a href="#第一部分：获得目标进程-线程信息" class="headerlink" title="第一部分：获得目标进程/线程信息"></a>第一部分：获得目标进程/线程信息</h4><p>这里根据是否为<code>reply</code>，分成了两种情况</p>
<h5 id="BC-TRANSACTION"><a href="#BC-TRANSACTION" class="headerlink" title="BC_TRANSACTION"></a>BC_TRANSACTION</h5><p>我们先看<code>BC_TRANSACTION</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line"></span><br><span class="line">            binder_proc_lock(proc);</span><br><span class="line">            <span class="comment">//查找binder引用</span></span><br><span class="line">            ref = binder_get_ref_olocked(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">            target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                    ref-&gt;node, &amp;target_proc,</span><br><span class="line">                    &amp;return_error);</span><br><span class="line">            binder_proc_unlock(proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//handle为0代表目标target是ServiceManager</span></span><br><span class="line">            mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="comment">//ServiceManager为binder驱动的context，所以可以直接从context中获取binder实体</span></span><br><span class="line">            target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">            <span class="keyword">if</span> (target_node)</span><br><span class="line">                <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">                target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                        target_node, &amp;target_proc,</span><br><span class="line">                        &amp;return_error);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                return_error = BR_DEAD_REPLY;</span><br><span class="line">            mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="keyword">if</span> (target_node &amp;&amp; target_proc == proc) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//使用LSM进行安全检查</span></span><br><span class="line">        <span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk,</span><br><span class="line">                        target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//flags不带TF_ONE_WAY（即需要reply）并且当前线程存在binder事务栈</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找一个合适的目标binder线程</span></span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">                spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">                from = tmp-&gt;from;</span><br><span class="line">                <span class="keyword">if</span> (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">                    atomic_inc(&amp;from-&gt;tmp_ref);</span><br><span class="line">                    target_thread = from;</span><br><span class="line">                    spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然整个函数很长很复杂，但经过我们的拆分精简，逻辑就清晰很多了</p>
<p><code>binder_transaction_data.target.handle</code>用一个<code>int</code>值表示目标<code>binder</code>引用，当它不为0时，调用<code>binder_get_ref_olocked</code>函数查找<code>binder_ref</code></p>
<h6 id="binder-get-ref-olocked"><a href="#binder-get-ref-olocked" class="headerlink" title="binder_get_ref_olocked"></a>binder_get_ref_olocked</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_ref *<span class="title">binder_get_ref_olocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                         u32 desc, <span class="keyword">bool</span> need_strong_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">proc</span>-&gt;<span class="title">refs_by_desc</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"tried to use weak ref as strong ref\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个函数就是从<code>binder_proc.refs_by_desc</code>这个红黑树中，通过<code>desc</code>句柄查找到对应的<code>binder</code>引用<code>binder_ref</code>，这样就可以通过<code>binder_ref.node</code>获得到<code>binder</code>实体<code>binder_node</code></p>
<p>接着再调用<code>binder_get_node_refs_for_txn</code>函数通过目标<code>binder</code>实体获取目标进程信息</p>
<h6 id="binder-get-node-refs-for-txn"><a href="#binder-get-node-refs-for-txn" class="headerlink" title="binder_get_node_refs_for_txn"></a>binder_get_node_refs_for_txn</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_get_node_refs_for_txn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc **procp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_node_inner_lock(node);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc) &#123;</span><br><span class="line">        target_node = node;</span><br><span class="line">        <span class="comment">//binder_node强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//binder_node临时引用计数加1</span></span><br><span class="line">        binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">        <span class="comment">//binder_proc临时引用计数加1</span></span><br><span class="line">        atomic_inc(&amp;node-&gt;proc-&gt;tmp_ref);</span><br><span class="line">        <span class="comment">//使外部传入的proc指针指向binder_proc地址</span></span><br><span class="line">        *procp = node-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *error = BR_DEAD_REPLY;</span><br><span class="line">    binder_node_inner_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数第二个参数接受一个<code>binder_proc **</code>类型，即指向指针的指针，调用方对<code>proc</code>取地址，即指向<code>proc</code>指针分配在栈上的地址，这样函数中对<code>procp</code>解引用就得到了<code>proc</code>指针本身的地址，即可使<code>proc</code>指针指向<code>binder_proc</code>的地址</p>
<p>当<code>binder_transaction_data.target.handle</code>为0时，表示目标是<code>ServiceManager</code>，而<code>ServiceManager</code>是<code>binder</code>驱动的<code>context</code>，所以可以直接从<code>context</code>中获取<code>binder</code>实体，关于<code>ServiceManager</code>是怎么成为<code>binder</code>驱动的<code>context</code>的，我们会在后面的章节进行分析</p>
<p>接下来做一下安全检查，当<code>flags</code>不带<code>TF_ONE_WAY</code>（即需要<code>reply</code>）并且当前线程存在<code>binder</code>事务栈时，寻找一个合适的目标<code>binder</code>工作线程用来处理此事务（线程复用）</p>
<p>这里<code>client</code>端可能是第一次请求服务，此时<code>binder_thread</code>里是不存在<code>binder</code>事务栈，所以是没法找到目标<code>binder</code>线程的</p>
<h5 id="BC-REPLY"><a href="#BC-REPLY" class="headerlink" title="BC_REPLY"></a>BC_REPLY</h5><p>接着，我们再看<code>BC_REPLY</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//这个事务是发起事务，也就是说我们需要对这个事务做应答</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改指向下一个需要处理的事务，即将这个事务移出链表</span></span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//目标线程即为需要回应的事务的发起线程</span></span><br><span class="line">        target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过binder_thread获得binder_proc</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">        atomic_inc(&amp;target_proc-&gt;tmp_ref);</span><br><span class="line">        binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_txn_from_and_acq_inner</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_transaction *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于 from = t-&gt;from; 内部加了锁和引用计数操作</span></span><br><span class="line">    from = binder_get_txn_from(t);</span><br><span class="line">    <span class="keyword">if</span> (!from)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_inner_proc_lock(from-&gt;proc);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">        BUG_ON(from != t-&gt;from);</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_inner_proc_unlock(from-&gt;proc);</span><br><span class="line">    binder_thread_dec_tmpref(from);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BC_REPLY</code>获取目标进程/线程信息就更简单了，<code>BC_TRANSACTION</code>中我们还需要根据<code>binder</code>句柄来获取各种信息，<code>BC_REPLY</code>我们只需要找到需要回应的那个事务，那个事务所在的线程和进程即为<code>reply</code>事务的目标线程和目标进程</p>
<h4 id="第二部分：数据拷贝，建立映射"><a href="#第二部分：数据拷贝，建立映射" class="headerlink" title="第二部分：数据拷贝，建立映射"></a>第二部分：数据拷贝，建立映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> *offp, *off_end, *off_start;</span><br><span class="line">    <span class="keyword">binder_size_t</span> off_min;</span><br><span class="line">    u8 *sg_bufp, *sg_buf_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span></span></span><br><span class="line"><span class="class">    <span class="title">u32</span> <span class="title">secctx_sz</span> = 0;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标进程binder事务分配空间（后续会加到目标进程/线程的todo队列中，由目标进程/线程处理这个事务）</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = t_debug_id;</span><br><span class="line">    <span class="comment">//设置事务发起线程</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">    <span class="comment">//设置事务处理进程</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">//设置事务处理线程</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">        binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        <span class="comment">/* Inherit supported policies for synchronous transactions */</span></span><br><span class="line">        t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">        t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Otherwise, fall back to the default priority */</span></span><br><span class="line">        t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全相关</span></span><br><span class="line">    <span class="keyword">if</span> (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配缓存，建立映射</span></span><br><span class="line">    t-&gt;<span class="built_in">buffer</span> = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">        !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;transaction = t;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;target_node = target_node;</span><br><span class="line">    </span><br><span class="line">    off_start = (<span class="keyword">binder_size_t</span> *)(t-&gt;<span class="built_in">buffer</span>-&gt;data +</span><br><span class="line">                      ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    offp = off_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是真正的一次复制</span></span><br><span class="line">    copy_from_user(t-&gt;<span class="built_in">buffer</span>-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.<span class="built_in">buffer</span>, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据对齐</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(extra_buffers_size, <span class="keyword">sizeof</span>(u64))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">    sg_bufp = (u8 *)(PTR_ALIGN(off_end, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    sg_buf_end = sg_bufp + extra_buffers_size -</span><br><span class="line">        ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    off_min = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环遍历每一个binder对象</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> object_size = binder_validate_object(t-&gt;<span class="built_in">buffer</span>, *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object_size == <span class="number">0</span> || *offp &lt; off_min) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hdr = (struct binder_object_header *)(t-&gt;<span class="built_in">buffer</span>-&gt;data + *offp);</span><br><span class="line">        off_min = *offp + object_size;</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">        <span class="comment">//需要对binder类型进行转换</span></span><br><span class="line">        <span class="comment">//因为在A进程中为本地binder对象，对于B进程则为远程binder对象，反之亦然</span></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_PTR: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置工作类型</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">//设置目标进程的事务类型</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这一部分再细分成几个部分：</p>
<ol>
<li>分配缓存，建立映射</li>
<li>数据拷贝</li>
<li><code>binder</code>类型转换</li>
</ol>
<h5 id="分配缓存，建立映射"><a href="#分配缓存，建立映射" class="headerlink" title="分配缓存，建立映射"></a>分配缓存，建立映射</h5><p>我们首先看分配缓存，建立映射是怎么做的，它调用了<code>binder_alloc_new_buf</code>函数，这个函数定义在<code>drivers/android/binder_alloc.c</code>中，内部加了锁后调用了<code>binder_alloc_new_buf_locked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_buffer *<span class="title">binder_alloc_new_buf_locked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> data_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> offsets_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> extra_buffers_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> is_async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">alloc</span>-&gt;<span class="title">free_buffers</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">best_fit</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *has_page_addr;</span><br><span class="line">    <span class="keyword">void</span> *end_page_addr;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, data_offsets_size;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc-&gt;vma == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要的缓冲区大小</span></span><br><span class="line">    <span class="comment">//这里需要将size对齐void *（32位下占用4字节，64位下占用8字节）</span></span><br><span class="line">    data_offsets_size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</span><br><span class="line">        ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = data_offsets_size + ALIGN(extra_buffers_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">max</span>(<span class="built_in">size</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder_alloc的空闲缓冲红黑树中找到一个大小最合适的binder_buffer</span></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="comment">//当找到一个需求大小和缓存区大小刚好相同的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer就正好指向这个空闲缓存区</span></span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">        BUG_ON(!<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span>);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当只找到一个比需求大小稍大一点的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer指向的是这个空闲缓存区所在节点的父节点</span></span><br><span class="line">        <span class="comment">//然后n指向NULL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; buffer_size) &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &gt; buffer_size)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (best_fit == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时buffer指向的是所需求的空闲缓存区所在红黑树节点的父节点</span></span><br><span class="line">    <span class="comment">//需要让其指向真正需求的那个空闲缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出buffer的终点，向下对齐（不能超过可用的buffer_size）</span></span><br><span class="line">    has_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)(((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">    WARN_ON(n &amp;&amp; buffer_size != <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//计算出实际上我们接收数据需要的空间的终点，向上映射</span></span><br><span class="line">    end_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//如果超出了可用的buffer_size，恢复到正常可用的结束地址</span></span><br><span class="line">    <span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</span><br><span class="line">        end_page_addr = has_page_addr;</span><br><span class="line">    <span class="comment">//分配物理页，建立映射</span></span><br><span class="line">    ret = binder_update_page_range(alloc, <span class="number">1</span>,</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data), end_page_addr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有空余空间的话，分隔这个buffer，剩余的buffer加入到空闲缓存区红黑树中（合理利用空间）</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_size != <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span>;</span></span><br><span class="line"></span><br><span class="line">        new_buffer = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">        new_buffer-&gt;data = (u8 *)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>;</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;<span class="built_in">buffer</span>-&gt;entry);</span><br><span class="line">        new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        binder_insert_free_buffer(alloc, new_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们已经使用了这个buffer，要将其从空闲缓存区红黑树中移除</span></span><br><span class="line">    rb_erase(best_fit, &amp;alloc-&gt;free_buffers);</span><br><span class="line">    <span class="comment">//标记为非空闲</span></span><br><span class="line">    <span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//插入到已分配缓存区红黑树中</span></span><br><span class="line">    binder_insert_allocated_buffer_locked(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;data_size = data_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;offsets_size = offsets_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;async_transaction = is_async;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;extra_buffers_size = extra_buffers_size;</span><br><span class="line">    <span class="comment">//如果是异步事件, 那么更新binder_alloc的异步事件空闲buffer</span></span><br><span class="line">    <span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">        alloc-&gt;free_async_space -= <span class="built_in">size</span> + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的整体逻辑分为三个部分：</p>
<ol>
<li>找到可用的空闲内核缓存区，计算我们需要分配的大小</li>
<li>分配物理页，建立映射</li>
<li>初始化新分配的<code>buffer</code></li>
</ol>
<p>其中1、3部分已经用注释标出来了，应该还是比较好理解的，我们终点看一下第2部分：怎么分配物理页，建立映射</p>
<p>我们在上一章<a href="https://juejin.cn/post/7062654742329032740#heading-16" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中说到，<code>binder_mmap</code>并没有立即将内核虚拟内存和进程虚拟内存与物理内存做映射，实际上这个映射操作是在<code>binder_update_page_range</code>这里做的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_alloc *alloc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_lru_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> need_mm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= start)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_range;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否有页框需要分配</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE];</span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            need_mm = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向目标用户进程的内存空间描述体</span></span><br><span class="line">    <span class="keyword">if</span> (need_mm &amp;&amp; atomic_inc_not_zero(&amp;alloc-&gt;vma_vm_mm-&gt;mm_users))</span><br><span class="line">        mm = alloc-&gt;vma_vm_mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//获取mm_struct的读信号量</span></span><br><span class="line">        down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="comment">//检查mm是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!mmget_still_valid(mm)) &#123;</span><br><span class="line">            <span class="comment">//释放</span></span><br><span class="line">            <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> free_range;</span><br><span class="line">            <span class="comment">//错误</span></span><br><span class="line">            <span class="keyword">goto</span> err_no_vma;</span><br><span class="line">        &#125;</span><br><span class="line">        vma = alloc-&gt;vma;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma &amp;&amp; need_mm) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">bool</span> on_lru;</span><br><span class="line">        <span class="keyword">size_t</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向对应页框地址，为后面赋值做准备</span></span><br><span class="line">        index = (page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE;</span><br><span class="line">        page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//page-&gt;page_ptr不为NULL说明之前已经分配并映射过了</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;page_ptr) &#123;</span><br><span class="line">            on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配一个页的物理内存</span></span><br><span class="line">        page-&gt;page_ptr = alloc_page(GFP_KERNEL |</span><br><span class="line">                        __GFP_HIGHMEM |</span><br><span class="line">                        __GFP_ZERO);</span><br><span class="line">        <span class="comment">//未分配成功</span></span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        page-&gt;alloc = alloc;</span><br><span class="line">        INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将物理内存空间映射到内核虚拟内存空间</span></span><br><span class="line">        ret = map_kernel_range_noflush((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                           PAGE_SIZE, PAGE_KERNEL,</span><br><span class="line">                           &amp;page-&gt;page_ptr);</span><br><span class="line">        flush_cache_vmap((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr + PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据之前计算的user_buffer_offset可以直接得到目标用户空间进程虚拟内存地址</span></span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + alloc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">//将物理内存空间映射到目标用户进程虚拟内存空间</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>].page_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &gt; alloc-&gt;pages_high)</span><br><span class="line">            alloc-&gt;pages_high = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//释放mm_struct的读信号量</span></span><br><span class="line">        up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释写的应该比较清楚了，总之就是先分配<code>物理内存</code>，再将这块<code>物理内存</code>分别映射到<code>内核虚拟空间</code>和<code>用户进程虚拟空间</code>，这样<code>内核虚拟空间</code>与<code>用户进程虚拟空间</code>相当于也间接的建立了映射关系</p>
<p>关于物理内存的分配以及映射，就是<code>Linux</code>内核层的事情了，感兴趣的同学可以再深入往里看看，这里就不再多说了</p>
<h5 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h5><p>关于数据拷贝这部分就不用多说了，物理内存已经分配好了，映射也建立了，接下来直接调用<code>copy_from_user</code>将数据从用户空间拷贝至映射的那块内存就可以了</p>
<h5 id="binder类型转换"><a href="#binder类型转换" class="headerlink" title="binder类型转换"></a>binder类型转换</h5><p>最后循环遍历每一个<code>binder</code>对象，对其中每一个<code>binder</code>对象类型做转换，因为在一个进程中为本地<code>binder</code>对象，对于另一个进程则为远程<code>binder</code>对象，反之亦然</p>
<h6 id="flat-binder-object结构体"><a href="#flat-binder-object结构体" class="headerlink" title="flat_binder_object结构体"></a>flat_binder_object结构体</h6><p>这里就是我们之前提到的，<code>binder</code>对象在传输过程中会被 “压扁” 的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    <span class="comment">//描述了binder对象的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span>	<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="comment">//和binder_transaction_data中flags含义相同</span></span><br><span class="line">    __u32				flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_BINDER时，表示是一个binder实体对象，指向binder实体在用户空间的地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span>	binder;	<span class="comment">/* local object */</span></span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_HANDLE，表示是一个binder引用句柄</span></span><br><span class="line">        __u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////当hdr.type == BINDER_TYPE_BINDER时才有值，表示携带的额外数据</span></span><br><span class="line">    <span class="comment">/* extra data associated with local object */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-binder"><a href="#binder-translate-binder" class="headerlink" title="binder_translate_binder"></a>binder_translate_binder</h6><p><code>BINDER_TYPE_BINDER</code>表示是一个<code>binder</code>实体对象，需要将它转换成<code>binder</code>引用句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过proc-&gt;nodes.rb_node红黑树查找binder_node</span></span><br><span class="line">    node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">    <span class="comment">//如果没有找到，新建一个binder_node并将其插入红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = binder_new_node(proc, fp);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找binder_ref并将其引用计数加1，如果没有查找到则创建一个，并将其插入红黑树</span></span><br><span class="line">    ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">            &amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换binder类型</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//binder引用句柄赋值</span></span><br><span class="line">    fp-&gt;handle = rdata.desc;</span><br><span class="line">    fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-handle"><a href="#binder-translate-handle" class="headerlink" title="binder_translate_handle"></a>binder_translate_handle</h6><p><code>BINDER_TYPE_HANDLE</code>表示是一个<code>binder</code>引用句柄，，需要将它转换成<code>binder</code>实体对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_handle</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">src_rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从proc-&gt;refs_by_desc.rb_node红黑树中查找binder_node，并将其临时引用计数加1</span></span><br><span class="line">    node = binder_get_node_from_ref(proc, fp-&gt;handle,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    <span class="comment">//如果binder实体所在的进程为事务处理进程</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc == target_proc) &#123;</span><br><span class="line">        <span class="comment">//binder类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_HANDLE)</span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">        fp-&gt;binder = node-&gt;ptr;</span><br><span class="line">        fp-&gt;cookie = node-&gt;cookie;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_lock(node-&gt;proc);</span><br><span class="line">        <span class="comment">//binder强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node,</span><br><span class="line">                     fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">                     <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_unlock(node-&gt;proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//重新查找binder_ref</span></span><br><span class="line">        struct binder_ref_data dest_rdata;</span><br><span class="line"></span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">                fp-&gt;hdr.type == BINDER_TYPE_HANDLE,</span><br><span class="line">                <span class="literal">NULL</span>, &amp;dest_rdata);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">        fp-&gt;handle = dest_rdata.desc;</span><br><span class="line">        fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三部分：加入todo队列，唤醒目标线程"><a href="#第三部分：加入todo队列，唤醒目标线程" class="headerlink" title="第三部分：加入todo队列，唤醒目标线程"></a>第三部分：加入todo队列，唤醒目标线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;    <span class="comment">//如果请求码为BC_REPLY</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        binder_inner_proc_lock(target_proc);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">            binder_inner_proc_unlock(target_proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将发起事务从目标binder线程的事务链表中移除</span></span><br><span class="line">        binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">        binder_inner_proc_unlock(target_proc);</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">        <span class="comment">//恢复发起事务的优先级</span></span><br><span class="line">        binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">        <span class="comment">//释放发起事务</span></span><br><span class="line">        binder_free_transaction(in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且不为异步操作，需要返回</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中（这里会延迟执行BINDER_WORK_TRANSACTION_COMPLETE）</span></span><br><span class="line">        binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">        <span class="comment">//设置为需要回应</span></span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//插入事务链表中</span></span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标线程的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">            binder_inner_proc_lock(proc);</span><br><span class="line">            <span class="comment">//出错后，移除该事务</span></span><br><span class="line">            binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且为异步操作，不需要返回</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标进程的某个线程（或目标进程）的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减临时引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread)</span><br><span class="line">        binder_thread_dec_tmpref(target_thread);</span><br><span class="line">    binder_proc_dec_tmpref(target_proc);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_dec_node_tmpref(target_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一块的代码基本上格式都是一样的，都是将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，<code>t-&gt;work</code>插入到目标<code>binder</code>线程的<code>todo</code>队列中，最后唤醒目标进程</p>
<p>这里需要注意的是，在<code>BC_TRANSACTION</code>的情况下，需要区分事务的<code>flags</code>中是否包含<code>TF_ONE_WAY</code>，这意味着这个事务是否需要回应</p>
<p>在没有<code>TF_ONE_WAY</code>的情况下，会使用<code>binder_enqueue_deferred_thread_work_ilocked</code>函数将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，这个函数区别于<code>binder_enqueue_thread_work_ilocked</code>函数，它没有将<code>thread-&gt;process_todo</code>设为<code>true</code>，这个标记在之前介绍<code>binder_thread</code>结构体的时候提到了，当其为<code>false</code>的情况下会在<code>binder_thread_read</code>中休眠，延迟执行<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，具体是怎么操作的，我们会在后续的<code>binder_thread_read</code>函数中进行分析</p>
<p>在<code>TF_ONE_WAY</code>的情况下，我们是没有去寻找合适的目标处理<code>binder</code>线程的，关于这一点，我们需要看一下<code>binder_proc_transaction</code>函数是怎么处理没有传入<code>binder_thread</code>的情况的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_proc_transaction</span><span class="params">(struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    <span class="keyword">bool</span> pending_async = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    node_prio.prio = node-&gt;min_priority;</span><br><span class="line">    node_prio.sched_policy = node-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了TF_ONE_WAY标志</span></span><br><span class="line">    <span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;has_async_transaction) &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象正在处理一个异步事务，做一个标记</span></span><br><span class="line">            pending_async = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象没有正在处理一个异步事务，将has_async_transaction置为true，表示接下来要处理一个异步任务</span></span><br><span class="line">            node-&gt;has_async_transaction = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标进程死亡或者目标线程不为NULL且死亡</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有传入目标线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!thread &amp;&amp; !pending_async)</span><br><span class="line">        <span class="comment">//从proc-&gt;waiting_threads链表中取出第一个节点元素（没有的话则为NULL）</span></span><br><span class="line">        thread = binder_select_thread_ilocked(proc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;    <span class="comment">//当找到了合适的binder线程</span></span><br><span class="line">        <span class="comment">//设置事务优先级</span></span><br><span class="line">        binder_transaction_priority(thread-&gt;task, t, node_prio,</span><br><span class="line">                        node-&gt;inherit_rt);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_async) &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder进程的todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder实体的async_todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!pending_async)</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        binder_wakeup_thread_ilocked(proc, thread, !oneway <span class="comment">/* sync */</span>);</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    binder_node_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有传入目标<code>binder</code>线程时，从目标进程的等待线程链表中取出第一个<code>binder_thread</code>作为处理线程处理该事务，如果没找到合适的空闲线程，分为两种情况：</p>
<ol>
<li>目标<code>binder</code>实体对象正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>实体的<code>async_todo</code>队列中</li>
<li>目标<code>binder</code>实体对象没有正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>进程的<code>todo</code>队列中</li>
</ol>
<p>关于<code>binder</code>驱动是怎么从这些<code>todo</code>队列取出<code>binder_work</code>并处理的，我们马上在后面<code>binder_thread_read</code>里分析，这里我们最后再看一下如何唤醒目标<code>binder</code>线程的等待队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_thread_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert_spin_locked(&amp;proc-&gt;inner_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sync)</span><br><span class="line">            wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有找到一个可用的等待线程，可能在两种情况下发生：</span></span><br><span class="line">    <span class="comment">//1. 所有线程都忙于处理事务</span></span><br><span class="line">    <span class="comment">//在这种情况下，这些线程中的一个应该很快回调到内核驱动程序并执行这项工作</span></span><br><span class="line">    <span class="comment">//2. 线程正在使用epoll轮询，在这种情况下，它们可能在没有被添加到waiting_threads的情况下被阻塞在等待队列上</span></span><br><span class="line">    <span class="comment">//对于这种情况，我们只循环获取所有不处理事务工作的线程，并将它们全部唤醒</span></span><br><span class="line">    binder_wakeup_poll_threads_ilocked(proc, sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数也有可能<code>binder_thread</code>参数传入NULL，在这种情况下，我们需要循环获取目标进程下的所有<code>binder</code>线程，对所有不处理事务工作的线程全部执行唤醒操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_poll_threads_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;threads); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        thread = rb_entry(n, struct binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_POLL &amp;&amp;</span><br><span class="line">            binder_available_for_proc_work_ilocked(thread)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sync)</span><br><span class="line">                wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经分析了<code>binder_ioctl</code>函数的一半<code>binder_thread_write</code>，了解了一些相关的数据结构，并且补充了<code>binder_mmap</code>篇未完成的内存映射的分析，大家应该对<code>binder</code>请求的发起与调度有了一个初步的认识了</p>
<p>本来这一篇是打算把整个<code>binder_ioctl</code>分析完的，但没想到写到后面内容这么多，只好再分一篇，下一篇我们将分析<code>binder_thread_read</code>，将<code>binder</code>驱动篇完结</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/09/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - Binder驱动（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="Android源码分析 - Binder概述">Android源码分析 - Binder概述</a>我们大概了解了一下<code>Android</code>选用<code>Binder</code>的原因，以及<code>Binder</code>的基本结构和通信过程。今天，我们便开始从<code>Binder</code>驱动层代码开始分析<code>Binder</code>的机制</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><code>Binder</code>驱动部分代码不在<code>AOSP</code>项目中，所以我们需要单独<code>clone</code>一份驱动代码</p>
<p>由于我的开发设备是pixel2，查了<code>Linux</code>内核版本号为<code>4.4.223</code>，对应的分支为<code>android-msm-wahoo-4.4-android11</code>，所以今天的分析我们也是基于此分支</p>
<p>我是从清华大学镜像站<code>clone</code>的代码，高通的设备，所以地址为：<a href="https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git" target="_blank" rel="noopener">https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git</a></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p><code>binder</code>驱动的源码位于<code>drivers/android</code>目录下，我们从<code>binder.c</code>文件看起</p>
<h2 id="Linux-initcall机制"><a href="#Linux-initcall机制" class="headerlink" title="Linux initcall机制"></a>Linux initcall机制</h2><p>在<code>binder.c</code>的最底下，我们可以看到这一行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>

<p>在<code>Linux</code>内核中，驱动程序通常是用<code>xxx_initcall(fn)</code>启动的，这实际上是一个宏定义，被定义在平台对应的<code>init.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_initcall(fn) __define_initcall(fn, early)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn) __define_initcall(fn, 0) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn) __define_initcall(fn, 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn) __define_initcall(fn, 1s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn) __define_initcall(fn, 2) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn) __define_initcall(fn, 2s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn) __define_initcall(fn, 3) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn) __define_initcall(fn, 3s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn) __define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn) __define_initcall(fn, 4s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn) __define_initcall(fn, 5) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn) __define_initcall(fn, 5s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn) __define_initcall(fn, rootfs) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn) __define_initcall(fn, 6) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn) __define_initcall(fn, 6s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn) __define_initcall(fn, 7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn) __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，实际上调用的是<code>__define_initcall()</code>函数，这个函数的第二个参数表示优先级，数字越小，优先级越高，带s的优先级低于不带s的优先级</p>
<p>在Linux内核启动过程中，需要调用各种函数，在底层实现是通过在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可，而<code>__define_initcall()</code>函数，就是将自定义的init函数添加到上述段中</p>
<h2 id="binder-init"><a href="#binder-init" class="headerlink" title="binder_init"></a>binder_init</h2><p>了解了以上函数定义后，我们再回头看<code>device_initcall(binder_init)</code>就可以知道，在<code>Linux</code>内核启动时，会调用<code>binder_init</code>这么一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *device_name, *device_names, *device_tmp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder内存回收</span></span><br><span class="line">    ret = binder_alloc_shrinker_init();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个单线程工作队列，用于处理异步任务</span></span><br><span class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建binder/proc目录</span></span><br><span class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>,</span><br><span class="line">                         binder_debugfs_dir_entry_root);</span><br><span class="line">    <span class="comment">//在binder目录下创建5个文件</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">        debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_state_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"stats"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_stats_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transactions"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_transactions_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log_failed,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//"binder,hwbinder,vndbinder"</span></span><br><span class="line">    device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">    device_tmp = device_names;</span><br><span class="line">    <span class="comment">//用binder,hwbinder,vndbinder分别调用init_binder_device函数</span></span><br><span class="line">    <span class="keyword">while</span> ((device_name = strsep(&amp;device_tmp, <span class="string">","</span>))) &#123;</span><br><span class="line">        ret = init_binder_device(device_name);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err_init_binder_device_failed:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">err_alloc_device_names_failed:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将重点放在<code>init_binder_device</code>函数上</p>
<h2 id="init-binder-device"><a href="#init-binder-device" class="headerlink" title="init_binder_device"></a>init_binder_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!binder_device)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder注册虚拟字符设备所对应的file_operations</span></span><br><span class="line">    binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">    <span class="comment">//动态分配次设备号</span></span><br><span class="line">    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">    binder_device-&gt;context.name = name;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//注册misc设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(binder_device);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将binder设备加入链表（头插法）</span></span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造了一个结构体用来存放<code>binder</code>参数，然后通过<code>misc_register</code>函数，以<code>misc</code>设备进行注册<code>binder</code>，作为虚拟字符设备</p>
<h3 id="注册misc设备"><a href="#注册misc设备" class="headerlink" title="注册misc设备"></a>注册misc设备</h3><p>我们先学习一下在<code>Linux</code>中如何注册一个<code>misc</code>设备</p>
<p>在Linux驱动中把无法归类的五花八门的设备定义为<code>misc</code>设备，<code>Linux</code>内核所提供的<code>misc</code>设备有很强的包容性，各种无法归结为标准字符设备的类型都可以定义为<code>misc</code>设备，譬如NVRAM，看门狗，实时时钟，字符LCD等</p>
<p>在<code>Linux</code>内核里把所有的<code>misc</code>设备组织在一起，构成了一个子系统(<code>subsys</code>)，统一进行管理。在这个子系统里的所有<code>miscdevice</code>类型的设备共享一个主设备号<code>MISC_MAJOR</code>(10)，但次设备号不同</p>
<p>在内核中用<code>miscdevice</code>结构体表示<code>misc</code>设备，具体的定义在<code>include/linux/miscdevice.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nodename;</span><br><span class="line">    <span class="keyword">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们自己注册<code>misc</code>设备时只需要填入前3项即可：</p>
<ul>
<li><code>minor</code>：次设备号，如果填充<code>MISC_DYNAMIC_MINOR</code>，则由内核动态分配次设备号</li>
<li><code>name</code>：设备名</li>
<li><code>fops</code>：<code>file_operations</code>结构体，用于定义自己<code>misc</code>设备的文件操作函数，如果不填此项则会使用默认的<code>misc_fops</code></li>
</ul>
<p><code>file_operations</code>结构体被定义在<code>include/linux/fs.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">flush</span>) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>file_operation</code>是把系统调用和驱动程序关联起来的关键结构，这个结构的每一个成员都对应着一个系统调用，<code>Linux</code>系统调用通过读取<code>file_operation</code>中相应的函数指针，接着把控制权转交给函数，从而完成<code>Linux</code>设备驱动程序的工作</p>
<p>最后调用<code>misc_register</code>函数注册<code>misc</code>设备，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">misc_register</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br><span class="line"><span class="comment">//卸载misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">misc_deregister</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="注册binder设备"><a href="#注册binder设备" class="headerlink" title="注册binder设备"></a>注册binder设备</h3><p>了解了<code>misc</code>设备的注册，我们就可以看一下<code>binder</code>的注册过程了，代码中先构建了一个<code>binder_device</code>结构体，我们先观察一下这个结构体长什么样子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>hlist_node</code>是链表中的一个节点，<code>miscdevice</code>就是上文所描述的注册<code>misc</code>所必要的结构体参数，<code>binder_context</code>用于保存<code>binder</code>上下文管理者的信息</p>
<p>回到代码中，首先给<code>miscdevice</code>赋了值，指定了<code>file_operation</code>，设置了<code>minor</code>动态分配次设备号，<code>binder_context</code>则是简单初始化了一下，然后便调用<code>misc_register</code>函数注册<code>misc</code>设备，最后将这个<code>binder</code>设备使用头插法加入到一个全局链表中</p>
<p>我们看一下它指定的<code>file_operation</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .<span class="built_in">open</span> = binder_open,</span><br><span class="line">    .<span class="built_in">flush</span> = binder_flush,</span><br><span class="line">    .<span class="built_in">release</span> = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>binder</code>驱动支持以上7种系统调用，接下来，我们就逐一分析这些系统调用</p>
<h1 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a>binder_proc</h1><p>在分析这些系统调用前，我们有必要先了解一下在<code>binder</code>中非常重要的结构体<code>binder_proc</code>，它是用来描述进程上下文信息以及管理IPC的一个结构体，被定义在<code>drivers/android/binder.c</code>中，是一个私有的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="comment">//hash链表中的一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="comment">//处理用户请求的线程组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="comment">//binder实体组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以句柄来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以它对应的binder实体的地址来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_threads</span>;</span></span><br><span class="line">    <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//进程描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="comment">//进程打开的所有文件数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">files_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> deferred_work;</span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//待处理事件队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;</span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">default_priority</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">    <span class="comment">//用来记录mmap分配的用户虚拟地址空间和内核虚拟地址空间等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_alloc</span> <span class="title">alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> inner_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> outer_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h1><p>我们先从打开<code>binder</code>驱动设备开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//管理IPC和保存进程信息的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//初始化内核同步自旋锁</span></span><br><span class="line">    spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">    <span class="comment">//原子操作赋值</span></span><br><span class="line">    atomic_set(&amp;proc-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使执行当前系统调用进程的task_struct.usage加1</span></span><br><span class="line">    get_task_struct(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">//使binder_proc中的tsk指向执行当前系统调用的进程</span></span><br><span class="line">    proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">//初始化文件锁</span></span><br><span class="line">    mutex_init(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//初始化todo列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">        proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">        proc-&gt;default_priority.prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到binder_device结构体的首地址</span></span><br><span class="line">    binder_dev = container_of(filp-&gt;private_data, struct binder_device,</span><br><span class="line">                  miscdev);</span><br><span class="line">    <span class="comment">//使binder_proc的上下文指向binder_device的上下文</span></span><br><span class="line">    proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">    <span class="comment">//初始化binder缓冲区</span></span><br><span class="line">    binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">//全局binder_stats结构体中，BINDER_STAT_PROC类型的对象创建数量加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">//设置当前进程id</span></span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    <span class="comment">//初始化已分发的死亡通知列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    <span class="comment">//初始化等待线程列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line">    <span class="comment">//保存binder_proc数据</span></span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为binder支持多线程，所以需要加锁</span></span><br><span class="line">    mutex_lock(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">//将binder_proc添加到binder_procs全局链表中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在binder/proc目录下创建文件，以执行当前系统调用的进程id为名</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</span><br><span class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">            binder_debugfs_dir_entry_proc,</span><br><span class="line">            (<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)proc-&gt;pid,</span><br><span class="line">            &amp;binder_proc_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>binder_open</code>函数创建了<code>binder_proc</code>结构体，并把初始化并将当前进程等信息保存到<code>binder_proc</code>结构体中，然后将<code>binder_proc</code>结构体保存到文件指针<code>filp</code>的<code>private_data</code>中，再将<code>binder_proc</code>加入到全局链表<code>binder_procs</code>中</p>
<p>这里面有一些关于<code>Linux</code>的知识需要解释一下</p>
<h2 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h2><p><code>spinlock</code>是内核中提供的一种自旋锁机制。在<code>Linux</code>内核实现中，常常会碰到共享数据被中断上下文和进程上下文访问的场景，如果只有进程上下文的话，我们可以使用互斥锁或者信号量解决，将未获得锁的进程置为睡眠状态等待，但由于中断上下文不是一个进程，它不存在<code>task_struct</code>，所以不可被调度，当然也就不可睡眠，这时候就可以通过<code>spinlock</code>自旋锁的忙等待机制来达成睡眠同样的效果</p>
<h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><p>在<code>Linux</code>内核中，定义了一个叫<code>current</code>的宏，它被定义在<code>asm/current.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(current_thread_info()-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	current	get_current()</span></span><br></pre></td></tr></table></figure>

<p>它返回一个<code>task_struct</code>指针，指向执行当前这段内核代码的进程</p>
<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p><code>container_of</code>也是<code>Linux</code>中定义的一个宏，它的作用是根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER)	((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;              \         </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \         </span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="fd-amp-filp"><a href="#fd-amp-filp" class="headerlink" title="fd&amp;filp"></a>fd&amp;filp</h2><p><code>filp-&gt;private_data</code>保存了<code>binder_proc</code>结构体，当进程调用<code>open</code>系统函数时，内核会返回一个文件描述符<code>fd</code>，这个<code>fd</code>指向文件指针<code>filp</code>，在后续调用<code>mmap</code>，<code>ioctl</code>等函数与<code>binder</code>驱动交互时，会传入这个<code>fd</code>，内核就会以这个<code>fd</code>指向文件指针<code>filp</code>作为参数调用<code>binder_mmap</code>，<code>binder_ioctl</code>等函数，这样这些函数就可以通过<code>filp-&gt;private_data</code>取出<code>binder_proc</code>结构体</p>
<h1 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h1><h2 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h2><p>在分析<code>mmap</code>前，我们需要先了解一下<code>vm_area_struct</code>这个结构体，它被定义在<code>include/linux/mm_types.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//当前vma的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;</span><br><span class="line">    <span class="comment">//当前vma的末地址后第一个字节的地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="comment">//红黑树中对应节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma前面还有多少空闲空间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma所属的内存地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="comment">//vma标识集，定义在 include/linux/mm.h 中</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">        &#125; shared;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *anon_name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma操作函数集指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma起始地址在vm_file中的文件偏移，单位为物理页面PAGE_SIZE</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;</span><br><span class="line">    <span class="comment">//被映射的文件（如果使用文件映射）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vm_area_struct</code>结构体描述了一段虚拟内存空间，通常，进程所使用到的虚拟内存空间不连续，且各部分虚存空间的访问属性也可能不同，所以一个进程的虚拟内存空间需要多个<code>vm_area_struct</code>结构来描述（后面简称<code>vma</code>）</p>
<p>每个进程都有一个对应的<code>task_struct</code>结构描述，这个<code>task_struct</code>结构中有一个<code>mm_struct</code>结构用于描述进程的内存空间，<code>mm_struct</code>结构中有两个域成员变量分别指向了<code>vma</code>链表头和红黑树根</p>
<p><code>vma</code>所描述的虚拟内存空间范围由<code>vm_start</code>和<code>vm_end</code>表示，<code>vm_start</code>代表当前<code>vma</code>的首地址，<code>vm_end</code>代表当前<code>vma</code>的末地址后第一个字节的地址，即虚拟内存空间范围为<code>[vm_start, vm_end)</code></p>
<p><code>vm_operations_struct</code>和上文中的<code>file_operations</code>类似，用来定义虚拟内存的操作函数</p>
<hr>
<p>介绍完<code>vma</code>，接下来我们便看一下<code>binder_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验进程信息</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将虚拟内存地址大小限制在4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检查用户空间是否可写（FORBIDDEN_MMAP_FLAGS == VM_WRITE）</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//VM_DONTCOPY表示此vma不可被fork所复制</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP;</span><br><span class="line">    <span class="comment">//用户空间不可设置该vma的VM_WRITE标志</span></span><br><span class="line">    vma-&gt;vm_flags &amp;= ~VM_MAYWRITE;</span><br><span class="line">    <span class="comment">//设置此vma操作函数集</span></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    <span class="comment">//指向binder_proc</span></span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理进程虚拟内存空间与内核虚拟地址空间的映射关系</span></span><br><span class="line">    ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    mutex_lock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//获取进程的打开文件信息结构体files_struct，并将引用计数加1</span></span><br><span class="line">    proc-&gt;files = get_files_struct(current);</span><br><span class="line">    mutex_unlock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">    pr_err(<span class="string">"%s: %d %lx-%lx %s failed %d\n"</span>, __func__,</span><br><span class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先从<code>filp</code>中获取对应的<code>binder_proc</code>信息</li>
<li>将它的进程<code>task_struct</code>和执行当前这段内核代码的进程<code>task_struct</code>对比校验</li>
<li>限制了用户空间虚拟内存的大小在4M以内</li>
<li>检查用户空间是否可写（<code>binder</code>驱动为进程分配的缓冲区在用户空间中只可以读，不可以写）</li>
<li>设置<code>vm_flags</code>，令<code>vma</code>不可写，不可复制</li>
<li>设置<code>vma</code>的操作函数集</li>
<li>将<code>vm_area_struct</code>中的成员变量<code>vm_private_data</code>指向<code>binder_proc</code>，使得<code>vma</code>设置的操作函数中可以拿到<code>binder_proc</code></li>
<li>处理进程虚拟内存空间与内核虚拟地址空间的映射关系</li>
<li>获取进程的打开文件信息结构体<code>files_struct</code>，令<code>binder_proc</code>的<code>files</code>指向它，并将引用计数加1</li>
</ol>
<h2 id="binder-alloc-mmap-handler"><a href="#binder-alloc-mmap-handler" class="headerlink" title="binder_alloc_mmap_handler"></a>binder_alloc_mmap_handler</h2><p><code>binder_alloc_mmap_handler</code>将进程虚拟内存空间与内核虚拟地址空间做映射，它被实现在<code>drivers/android/binder_alloc.c</code>中</p>
<p>这里先介绍一下<code>vm_struct</code>，之前我们已经了解了<code>vm_area_struct</code>表示用户进程中的虚拟地址空间，而相对应的，<code>vm_struct</code>则表示内核中的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_alloc_mmap_handler</span><span class="params">(struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        <span class="comment">//检查是否已经分配过内核缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//获得一个内核虚拟空间</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC);</span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//alloc-&gt;buffer指向内核虚拟内存空间地址</span></span><br><span class="line">	alloc-&gt;<span class="built_in">buffer</span> = area-&gt;addr;</span><br><span class="line">        <span class="comment">//计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量</span></span><br><span class="line">	alloc-&gt;user_buffer_offset =</span><br><span class="line">		vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">	alloc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]) *</span><br><span class="line">				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//buffer大小等于vma大小</span></span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">buffer</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc buffer struct"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//指向内核虚拟空间地址</span></span><br><span class="line">	<span class="built_in">buffer</span>-&gt;data = alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">        <span class="comment">//将buffer添加到链表中</span></span><br><span class="line">	list_add(&amp;<span class="built_in">buffer</span>-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将此内核缓冲区加入到binder_alloc的空闲缓冲红黑树中</span></span><br><span class="line">	binder_insert_free_buffer(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="comment">//设置进程最大可用异步事务缓冲区大小（防止异步事务消耗过多内核缓冲区，影响同步事务）</span></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//内存屏障，保证指令顺序执行</span></span><br><span class="line">	barrier();</span><br><span class="line">        <span class="comment">//设置binder_alloc</span></span><br><span class="line">	alloc-&gt;vma = vma;</span><br><span class="line">	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">	<span class="comment">//引用计数+1</span></span><br><span class="line">	atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>检查是否已经分配过内核缓冲区</li>
<li>从内核中寻找一块可用的虚拟内存地址</li>
<li>将此内核虚拟内存空间地址保存至<code>binder_alloc</code></li>
<li>计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量（这样就可以非常方便的在用户虚拟内存空间与内核虚拟内存空间间切换）</li>
<li>为<code>alloc-&gt;pages</code>数组申请内存，申请的大小等于<code>vma</code>能分配多少个页框</li>
<li>设置<code>buffer</code>大小等于<code>vma</code>大小</li>
<li>为<code>binder_buffer</code>申请内存，填充参数，使其指向内核虚拟空间地址，并将其添加到链表和红黑树中</li>
<li>设置<code>binder_alloc</code>其他参数</li>
</ol>
<p>这里要注意，虽然我们计算出了用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量，但并没有建立映射关系。在旧版内核中，这里会调用<code>binder_update_page_range</code>函数分别将内核虚拟内存和进程虚拟内存与物理内存做映射，这样内核虚拟内存和进程虚拟内存也相当于间接建立了映射关系，而在<code>4.4.223</code>中，这件事将会延迟到<code>binder_ioctl</code>后</p>
<p>当完成物理内存的映射后，以32位系统，缓冲区大小4M为例，效果应该如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89_mmap.png" alt="binder_mmap"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，了解了一些重要的结构体，明白了<code>mmap</code>是如何映射用户空间和内核空间的，由于篇幅原因，下一章我们会分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://unicornx.github.io/2016/02/14/20160214-lk-drv-miscdevice/" target="_blank" rel="noopener">linux中的misc设备</a></li>
<li><a href="https://blog.csdn.net/u012142460/article/details/90344951" target="_blank" rel="noopener">内存映射与VMA</a></li>
<li><a href="https://www.jianshu.com/p/4399aedb4d42" target="_blank" rel="noopener">Android 重学系列 Binder驱动的初始化 映射原理(二)</a></li>
<li><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></li>
<li><a href="https://segmentfault.com/a/1190000014643994" target="_blank" rel="noopener">Linux 4.16 Binder驱动学习笔记——–接口简析</a></li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>