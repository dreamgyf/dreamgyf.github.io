<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/04/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-init%E8%BF%9B%E7%A8%8B/">Android源码分析 - init进程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/init%E8%BF%9B%E7%A8%8B/">init进程</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>PC启动会通过BIOS引导，从0x7c00处找到以0xaa55为结尾的引导程序启动。而Android通常使用在移动设备上，没有PC的BIOS，取而代之的是BootLoader。</p>
<h1 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h1><p>在CPU上电复位完成后，会从一个固定的地址加载一段程序，即BootLoader，不同的CPU可能这个地址不同。BootLoader是一段引导程序，其中最为常见的为U-boot，它一般会先检测用户是否按下某些特别按键，这些特别按键是uboot在编译时预先被约定好的，用于进入调试模式。如果用户没有按这些特别的按键，则uboot会从NAND Flash中装载Linux内核，装载的地址是在编译uboot时预先约定好的。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h2><p>Linux内核启动后，便会创建第一个进程idle。idle进程是Linux中的第一个进程，pid为0，是唯一一个没有通过fork产生的进程，它的优先级非常低，用于CPU没有任务的时候进行空转。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>init进程由idle进程创建，是Linux系统的第一个用户进程，pid为1，是系统所有用户进程的直接或间接父进程，本篇重点讲的就是它。</p>
<h2 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h2><p>kthreadd进程同样由idle进程创建，pid为2，它始终运行在内核空间，负责所有内核线程的调度与管理。</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><p>Android的init进程代码在<code>system/core/init/main.cpp</code>中，以main方法作为入口，分为几个阶段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"selinux_setup"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"second_stage"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ueventd和subcontext，都是在各自守护进程中执行的，不在init进程中执行，这里就不多介绍了</p>
<h2 id="FirstStageMain"><a href="#FirstStageMain" class="headerlink" title="FirstStageMain"></a>FirstStageMain</h2><p>默认不加任何参数启动init的话，便会开始init第一阶段，进入到FirstStageMain函数中，代码在<code>system/core/init/first_stage_init.cpp</code>中</p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>文档：<a href="https://man7.org/linux/man-pages/man2/umask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/umask.2.html</a></p>
<p>原型：<code>mode_t umask(mode_t mask);</code></p>
<p>这个方法是用来设置创建目录或文件时所应该赋予权限的掩码</p>
<p>Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755</p>
<p>在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高</p>
<h3 id="创建目录、设备节点，挂载"><a href="#创建目录、设备节点，挂载" class="headerlink" title="创建目录、设备节点，挂载"></a>创建目录、设备节点，挂载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKCALL(x) \</span></span><br><span class="line">    <span class="keyword">if</span> ((x) != <span class="number">0</span>) errors.emplace_back(#x <span class="string">" failed"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the umask.</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(<span class="string">"PATH"</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    CHECKCALL(chmod(<span class="string">"/proc/cmdline"</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmdline;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">"/proc/cmdline"</span>, &amp;cmdline);</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"selinuxfs"</span>, <span class="string">"/sys/fs/selinux"</span>, <span class="string">"selinuxfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/kmsg"</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class="line">        CHECKCALL(mknod(<span class="string">"/dev/kmsg_debug"</span>, S_IFCHR | <span class="number">0622</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/random"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">8</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/urandom"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">9</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/ptmx"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">5</span>, <span class="number">2</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/null"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">3</span>)));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/mnt"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=1000"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/vendor"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/product"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/debug_ramdisk"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=0"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CHECKCALL</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><h4 id="SetStdioToDevNull"><a href="#SetStdioToDevNull" class="headerlink" title="SetStdioToDevNull"></a>SetStdioToDevNull</h4><p>由于Linux内核打开了/dev/console作为标准输入输出流（stdin/stdout/stderr）的文件描述符，而init进程在用户空间，无权访问/dev/console，后续如果执行printf的话可能会导致错误，所以先调用<code>SetStdioToDevNull</code>函数来将标准输入输出流（stdin/stdout/stderr）用/dev/null文件描述符替换</p>
<p>/dev/null被称为空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，读取它会立即得到一个EOF</p>
<h4 id="InitKernelLogging"><a href="#InitKernelLogging" class="headerlink" title="InitKernelLogging"></a>InitKernelLogging</h4><p>接着调用<code>InitKernelLogging</code>函数，初始化了一个简单的kernel日志系统</p>
<h3 id="创建设备，挂载分区"><a href="#创建设备，挂载分区" class="headerlink" title="创建设备，挂载分区"></a>创建设备，挂载分区</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> want_console = ALLOW_FIRST_STAGE_CONSOLE ? FirstStageConsole(cmdline) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline), want_console)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (want_console != FirstStageConsoleParam::DISABLED) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to load kernel modules, starting console"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Failed to load kernel modules"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;</span><br><span class="line">        StartConsole();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ForceNormalBoot(cmdline)) &#123;</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/first_stage_ramdisk"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// SwitchRoot() must be called with a mount point as the target, so we bind mount the</span></span><br><span class="line">        <span class="comment">// target directory to itself here.</span></span><br><span class="line">        <span class="keyword">if</span> (mount(<span class="string">"/first_stage_ramdisk"</span>, <span class="string">"/first_stage_ramdisk"</span>, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Could not bind mount /first_stage_ramdisk to itself"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SwitchRoot(<span class="string">"/first_stage_ramdisk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>至此，第一阶段的init结束，通过execv函数带参执行init文件，进入<code>SetupSelinux</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"selinux_setup"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/kmsg"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line"><span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line"><span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>用exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。</p>
<p>这里在末尾直接打log是因为，exec系列函数如果执行正常是不会返回的，所以只要执行到下面就代表exec执行出错了</p>
<h2 id="SetupSelinux"><a href="#SetupSelinux" class="headerlink" title="SetupSelinux"></a>SetupSelinux</h2><p>启动Selinux安全机制，初始化selinux，加载SELinux规则，配置SELinux相关log输出，并启动第二阶段：<code>SecondStageMain</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    MountMissingSystemPartitions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up SELinux, loading the SELinux policy.</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelinuxInitialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class="line">    <span class="comment">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class="line">    <span class="comment">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class="line">    <span class="comment">// recovery image for A/B devices.</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">"/system/bin/init"</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"restorecon failed of /system/bin/init failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, <span class="built_in">std</span>::to_string(start_time.time_since_epoch().count()).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"second_stage"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondStageMain"><a href="#SecondStageMain" class="headerlink" title="SecondStageMain"></a>SecondStageMain</h2><p>使用<code>second_stage</code>参数启动init的话，便会开始init第二阶段，进入到<code>SecondStageMain</code>函数中，代码在<code>system/core/init/init.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//和第一阶段一样，初始化日志</span></span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set init and its forked children's oom_adj.</span></span><br><span class="line">    <span class="comment">//设置init进程和以后fork出来的进程的OOM等级，这里的值为-1000，保证进程不会因为OOM被杀死</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                WriteFile(<span class="string">"/proc/1/oom_score_adj"</span>, StringPrintf(<span class="string">"%d"</span>, DEFAULT_OOM_SCORE_ADJUST));</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Unable to write "</span> &lt;&lt; DEFAULT_OOM_SCORE_ADJUST</span><br><span class="line">                   &lt;&lt; <span class="string">" to /proc/1/oom_score_adj: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    <span class="comment">//设置一个标记，代表正在启动过程中</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">open</span>(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化系统属性</span></span><br><span class="line">    PropertyInit();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Mount extra filesystems required during second stage init</span></span><br><span class="line">    <span class="comment">//挂载额外的文件系统</span></span><br><span class="line">    MountExtraFilesystems();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    <span class="comment">//设置SELinux</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelabelInitialize();</span><br><span class="line">    SelinuxRestoreContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用epoll，注册信号处理函数，守护进程服务</span></span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">    <span class="comment">//启动系统属性服务</span></span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//解析init.rc脚本</span></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构建了一些Action，Trigger等事件对象加入事件队列中</span></span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, <span class="string">"SetupCgroups"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class="string">"SetKptrRestrict"</span>);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, <span class="string">"TestPerfEventSelinux"</span>);</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class="string">"SetMmapRndBits"</span>);</span><br><span class="line">    Keychords keychords;</span><br><span class="line">    am.QueueBuiltinAction(</span><br><span class="line">            [&amp;epoll, &amp;keychords](<span class="keyword">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class="line">                    keychords.Register(svc-&gt;keycodes());</span><br><span class="line">                &#125;</span><br><span class="line">                keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"KeychordInit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环，等待事件处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Linux-OOM-Killer机制"><a href="#Linux-OOM-Killer机制" class="headerlink" title="Linux OOM Killer机制"></a>Linux OOM Killer机制</h3><p>Linux下有一种 OOM KILLER 的机制，它会在系统内存耗尽的情况下，启用自己算法有选择性的杀掉一些进程，这个算法和三个值有关：</p>
<ul>
<li>/proc/PID/oom_score ,OOM 最终得分，值越大越有可能被杀掉</li>
<li>/proc/PID/oom_score_adj ，取值范围为-1000到1000，计算oom_score时会加上该参数</li>
<li>/proc/PID/oom_adj ，取值是-17到+15，该参数主要是为兼容旧版内核</li>
</ul>
<p>在init过程中，代码设置了init进程和以后fork出来的进程的OOM等级，这里的值为-1000，设置为这个值就可以保证进程永远不会因为OOM被杀死</p>
<h3 id="解析init-rc脚本"><a href="#解析init-rc脚本" class="headerlink" title="解析init.rc脚本"></a>解析init.rc脚本</h3><h4 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h4><p>rc文件，是用<code>Android Init Language</code>编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀</p>
<p>它的语法说明可以在aosp源码<code>system/core/init/README.md</code>中找到，这里就简单说明一下语法规则</p>
<h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h5><p><code>Actions</code>是一系列命令的开始，一个<code>Action</code>会有一个触发器，用于确定<code>Action</code>何时执行。当一个与<code>Action</code>的触发器匹配的事件发生时，该动作被添加到待执行队列的尾部</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Triggers（触发器）"><a href="#Triggers（触发器）" class="headerlink" title="Triggers（触发器）"></a>Triggers（触发器）</h5><p>触发器作用于<code>Actions</code>，可用于匹配某些类型的事件，并用于导致操作发生</p>
<h5 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h5><p><code>Commands</code>就是一个个命令的集合了</p>
<p><code>Action</code>, <code>Triggers</code>, <code>Commands</code>共同组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted </span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot. </span><br><span class="line">    exec_start update_verifier_nonencrypted </span><br><span class="line">    start statsd </span><br><span class="line">    start netd </span><br><span class="line">    start zygote </span><br><span class="line">    start zygote_secondary</span><br></pre></td></tr></table></figure>

<h5 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h5><p><code>Services</code>是对一些程序的定义，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>name：定义的服务名</li>
<li>pathname：这个程序的路径</li>
<li>argument：程序运行的参数</li>
<li>option：服务选项，后文将介绍</li>
</ul>
<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p><code>Options</code>是对<code>Services</code>的修饰，它们影响着服务运行的方式和时间</p>
<p><code>Services</code>, <code>Options</code>组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server --socket-name&#x3D;zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    task_profiles ProcessCapacityHigh MaxPerformance</span><br></pre></td></tr></table></figure>

<h5 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h5><p>导入其他的rc文件或目录解析，如果path是一个目录，目录中的每个文件都被解析为一个rc文件。它不是递归的，嵌套的目录将不会被解析。</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;path&gt;</span><br></pre></td></tr></table></figure>

<p><code>Imports</code>的内容会放到最后解析</p>
<p>上文所述的<code>Commands</code>，<code>Options</code>等具体命令，可以网上搜索一下，或者自己看<code>system/core/init/README.md</code></p>
<p><code>Commands</code>的定义可以在<code>system/core/init/builtins.cpp</code>中找到</p>
<p><code>Options</code>的定义可以在<code>system/core/init/service_parser.cpp</code>中找到</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">"ro.boot.init_rc"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        parser.ParseConfig(<span class="string">"/system/etc/init/hw/init.rc"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/system/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/system/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// late_import is available only in Q and earlier release. As we don't</span></span><br><span class="line">        <span class="comment">// have system_ext in those versions, skip late_import for system_ext.</span></span><br><span class="line">        parser.ParseConfig(<span class="string">"/system_ext/etc/init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/product/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/product/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/odm/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/odm/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/vendor/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/vendor/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会从这些地方寻找rc文件解析，<code>/system/etc/init/hw/init.rc</code>是主rc文件，剩下的目录，如果system分区尚未挂载的话，就把它们加入到<code>late_import_paths</code>中，等到后面<code>mount_all</code>时再加载</p>
<p>主rc文件在编译前的位置为<code>system/core/rootdir/init.rc</code></p>
<p>简单分析一下：</p>
<p>首先，以<code>ActionManager</code>和<code>ServiceList</code>作为参数创建了一个Parser解析器，解析后的结果会存放在<code>ActionManager</code>和<code>ServiceList</code>中，这里的两个传进来的参数都是单例模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), <span class="built_in">std</span>::nullopt));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建了一个<code>Parser</code>对象，然后往里面添加了<code>ServiceParser</code>、<code>ActionParser</code>以及<code>ImportParser</code>，这三个类都是继承自<code>ServiceParser</code>，这里的<code>std::make_unique</code>是new了一个对象，并用其原始指针构造出了一个智能指针</p>
<p>接着走到<code>Parser::ParseConfig</code>方法中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否是目录，如果是目录，就把目录中的所有文件加入容器中排序后依次解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigDir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing directory "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir);</span><br><span class="line">    <span class="keyword">if</span> (!config_dir) &#123;</span><br><span class="line">        PLOG(INFO) &lt;&lt; <span class="string">"Could not import directory '"</span> &lt;&lt; path &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* current_file;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files;</span><br><span class="line">    <span class="keyword">while</span> ((current_file = readdir(config_dir.<span class="built_in">get</span>()))) &#123;</span><br><span class="line">        <span class="comment">// Ignore directories and only process regular files.</span></span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> current_path =</span><br><span class="line">                android::base::StringPrintf(<span class="string">"%s/%s"</span>, path.c_str(), current_file-&gt;d_name);</span><br><span class="line">            files.emplace_back(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sort first so we load files in a consistent order (bug 31996208)</span></span><br><span class="line">    <span class="built_in">std</span>::sort(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ParseConfigFile(file)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"could not import file '"</span> &lt;&lt; file &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终都调用了<code>Parser::ParseConfigFile</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing file "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="keyword">auto</span> config_contents = ReadFile(path);</span><br><span class="line">    <span class="keyword">if</span> (!config_contents.ok()) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Unable to read config file '"</span> &lt;&lt; path &lt;&lt; <span class="string">"': "</span> &lt;&lt; config_contents.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; <span class="string">"(Parsing "</span> &lt;&lt; path &lt;&lt; <span class="string">" took "</span> &lt;&lt; t &lt;&lt; <span class="string">".)"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从文件中读取出字符串，并继续调用<code>Parser::ParseData</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="built_in">std</span>::<span class="built_in">string</span>* data)</span> </span>&#123;</span><br><span class="line">    data-&gt;push_back(<span class="string">'\n'</span>);  <span class="comment">// <span class="doctag">TODO:</span> fix tokenizer</span></span><br><span class="line">    data-&gt;push_back(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.<span class="built_in">line</span> = <span class="number">0</span>;</span><br><span class="line">    state.ptr = data-&gt;data();</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> section_start_line = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we encounter a bad section start, there is no valid parser object to parse the subsequent</span></span><br><span class="line">    <span class="comment">// sections, so we must suppress errors until the next valid section is found.</span></span><br><span class="line">    <span class="keyword">bool</span> bad_section_found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_section = [&amp;] &#123;</span><br><span class="line">        bad_section_found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (section_parser == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;EndSection(); !result.ok()) &#123;</span><br><span class="line">            parse_error_count_++;</span><br><span class="line">            LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; section_start_line &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">        section_start_line = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_EOF:</span><br><span class="line">                end_section();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [section_name, section_parser] : section_parsers_) &#123;</span><br><span class="line">                    section_parser-&gt;EndFile();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> T_NEWLINE: &#123;</span><br><span class="line">                state.<span class="built_in">line</span>++;</span><br><span class="line">                <span class="keyword">if</span> (args.empty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// If we have a line matching a prefix we recognize, call its callback and unset any</span></span><br><span class="line">                <span class="comment">// current section parsers.  This is meant for /sys/ and /dev/ line entries for</span></span><br><span class="line">                <span class="comment">// uevent.</span></span><br><span class="line">                <span class="keyword">auto</span> line_callback = <span class="built_in">std</span>::find_if(</span><br><span class="line">                    line_callbacks_.<span class="built_in">begin</span>(), line_callbacks_.<span class="built_in">end</span>(),</span><br><span class="line">                    [&amp;args](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c) &#123; <span class="keyword">return</span> android::base::StartsWith(args[<span class="number">0</span>], c.first); &#125;);</span><br><span class="line">                <span class="keyword">if</span> (line_callback != line_callbacks_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = line_callback-&gt;second(<span class="built_in">std</span>::<span class="built_in">move</span>(args)); !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    section_parser = section_parsers_[args[<span class="number">0</span>]].<span class="built_in">get</span>();</span><br><span class="line">                    section_start_line = state.<span class="built_in">line</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                                section_parser-&gt;ParseSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), filename, state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                        bad_section_found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;ParseLineSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bad_section_found) &#123;</span><br><span class="line">                    parse_error_count_++;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span></span><br><span class="line">                               &lt;&lt; <span class="string">": Invalid section keyword found"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                args.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> T_TEXT:</span><br><span class="line">                args.emplace_back(state.<span class="built_in">text</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里新建了一个<code>parse_state</code>结构体，用来以行为单位，分割整个文件字符串，根据分割出来的结果返回相应的TYPE，<code>Parser::ParseData</code>方法再通过TYPE来做逐行解析</p>
<p>这个结构体以及TPYE和分割分割方法的定义在<code>system/core/init/tokenizer.h</code>中，在<code>system/core/init/tokenizer.cpp</code>中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_token</span><span class="params">(struct parse_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *x = state-&gt;ptr;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;nexttoken) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = state-&gt;nexttoken;</span><br><span class="line">        state-&gt;nexttoken = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_EOF;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">while</span> (*x &amp;&amp; (*x != <span class="string">'\n'</span>)) x++;</span><br><span class="line">            <span class="keyword">if</span> (*x == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                state-&gt;ptr = x+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state-&gt;ptr = x;</span><br><span class="line">                <span class="keyword">return</span> T_EOF;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">text</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">textdone:</span><br><span class="line">    state-&gt;ptr = x;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T_TEXT;</span><br><span class="line"><span class="built_in">text</span>:</span><br><span class="line">    state-&gt;<span class="built_in">text</span> = s = x;</span><br><span class="line">textresume:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            state-&gt;nexttoken = T_NEWLINE;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="comment">/* unterminated quoted thing */</span></span><br><span class="line">                    state-&gt;ptr = x;</span><br><span class="line">                    <span class="keyword">return</span> T_EOF;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">goto</span> textresume;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    *s++ = *x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">goto</span> textdone;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                *s++ = <span class="string">'\n'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                *s++ = <span class="string">'\r'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                *s++ = <span class="string">'\t'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                *s++ = <span class="string">'\\'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                <span class="keyword">if</span> (x[<span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                FALLTHROUGH_INTENDED;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                state-&gt;<span class="built_in">line</span>++;</span><br><span class="line">                x++;</span><br><span class="line">                    <span class="comment">/* eat any extra whitespace */</span></span><br><span class="line">                <span class="keyword">while</span>((*x == <span class="string">' '</span>) || (*x == <span class="string">'\t'</span>)) x++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* unknown escape -- just copy */</span></span><br><span class="line">                *s++ = *x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *s++ = *x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先看看有没有遇到结束符（换行 \n 或者EOF \0）或者注释（#）如果遇到了就返回<code>T_NEWLINE</code>或者<code>T_EOF</code>代表这上一行结束了或者整个文件读取完了，没有遇到的话说明读取的是可解析的正文，跳到text段，将文本内容写到<code>state.text</code>中，直到碰到换行符或空格等分割标志（以空格或换行等作为分隔符，一小段一小段的进行分割），将读取到的最后一个正文的位置+1处的字符置为\0，<code>state.text</code>里的内容便称为了完整一段的内容，接着返回<code>T_TEXT</code>表示已读入一段文本</p>
<p>接着回到<code>Parser::ParseData</code>方法中，如果读到的TYPE是<code>T_TEXT</code>，就将这一段内容先添加到容器中，当读到<code>T_NEWLINE</code>时，解析之前读入的一整行内容，先用args[0]（一行的开头）去寻找我们之前添加的<code>SectionParser</code>，如果能找到，说明这一行是service、on或者import，将<code>section_parser</code>赋值为相应<code>SectionParser</code>子类的指针，调用其<code>ParseSection</code>方法解析，如果读入的一行里，不是以service、on或者import开头，并且之前定义的<code>section_parser</code>不为空指针，说明是service或者on参数的子参数，调用<code>ParseLineSection</code>方法解析子参数，并加入到父参数中。</p>
<p>最后，每次读取完都会执行<code>args.clear()</code>清楚这一行的数据，当读取到新的service、on或者import时，需要先执行<code>EndSection</code>方法，将之前解析好的结构添加到列表中</p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>回到<code>SecondStageMain</code>中，可以看到，最后有一个死循环，用来等待事件处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>am.ExecuteOneCommand()</code>方法便是执行从rc文件中解析出来的指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> lock = <span class="built_in">std</span>::lock_guard&#123;event_queue_lock_&#125;;</span><br><span class="line">        <span class="comment">// Loop through the event queue until we have an action to execute</span></span><br><span class="line">        <span class="comment">//当前正在执行的action队列为空，但等待执行的事件队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> (current_executing_actions_.empty() &amp;&amp; !event_queue_.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">                <span class="comment">//从等待执行的事件队列头取出一个元素event， </span></span><br><span class="line">                <span class="comment">//然后调用action的CheckEvent检查此event是否匹配当前action </span></span><br><span class="line">                <span class="comment">//如果匹配，将这个action加入到正在执行的actions队列的队尾</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">std</span>::visit([&amp;action](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) &#123; <span class="keyword">return</span> action-&gt;CheckEvent(event); &#125;,</span><br><span class="line">                               event_queue_.front())) &#123;</span><br><span class="line">                    current_executing_actions_.emplace(action.<span class="built_in">get</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            event_queue_.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从队列头取一个action（front不会使元素出队）</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是第一次执行这个action</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = action-&gt;BuildTriggersString();</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"processing action ("</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">") from ("</span> &lt;&lt; action-&gt;filename()</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; action-&gt;<span class="built_in">line</span>() &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个current_command_是个成员变量，标志着执行到了哪一行</span></span><br><span class="line">    action-&gt;ExecuteOneCommand(current_command_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this was the last command in the current action, then remove</span></span><br><span class="line">    <span class="comment">// the action from the executing list.</span></span><br><span class="line">    <span class="comment">// If this action was oneshot, then also remove it from actions_.</span></span><br><span class="line">    ++current_command_;</span><br><span class="line">    <span class="comment">//current_command_等于action的commands数量，说明这个action以及全部执行完了</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == action-&gt;NumCommands()) &#123;</span><br><span class="line">        <span class="comment">//此action出队</span></span><br><span class="line">        current_executing_actions_.pop();</span><br><span class="line">        <span class="comment">//重置计数器</span></span><br><span class="line">        current_command_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (action-&gt;oneshot()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> eraser = [&amp;action](<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123; <span class="keyword">return</span> a.<span class="built_in">get</span>() == action; &#125;;</span><br><span class="line">            actions_.erase(<span class="built_in">std</span>::remove_if(actions_.<span class="built_in">begin</span>(), actions_.<span class="built_in">end</span>(), eraser),</span><br><span class="line">                           actions_.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面会执行<code>Action::ExecuteOneCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteOneCommand</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We need a copy here since some Command execution may result in</span></span><br><span class="line">    <span class="comment">// changing commands_ vector by importing .rc files through parser</span></span><br><span class="line">    Command cmd = commands_[command];</span><br><span class="line">    ExecuteCommand(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用到了<code>Action::ExecuteCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="comment">//这一行是具体的执行</span></span><br><span class="line">    <span class="keyword">auto</span> result = command.InvokeFunc(subcontext_);</span><br><span class="line">    <span class="keyword">auto</span> duration = t.duration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any action longer than 50ms will be warned to user as slow operation</span></span><br><span class="line">    <span class="comment">//失败、超时或者debug版本都需要打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (!result.has_value() || duration &gt; <span class="number">50</span>ms ||</span><br><span class="line">        android::base::GetMinimumLogSeverity() &lt;= android::base::DEBUG) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = BuildTriggersString();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> cmd_str = command.BuildCommandString();</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Command '"</span> &lt;&lt; cmd_str &lt;&lt; <span class="string">"' action="</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">" ("</span> &lt;&lt; filename_</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; command.<span class="built_in">line</span>() &lt;&lt; <span class="string">") took "</span> &lt;&lt; duration.count() &lt;&lt; <span class="string">"ms and "</span></span><br><span class="line">                  &lt;&lt; (result.ok() ? <span class="string">"succeeded"</span> : <span class="string">"failed: "</span> + result.error().message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会调用<code>Command::InvokeFunc</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Command::InvokeFunc</span><span class="params">(Subcontext* subcontext)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从 /vendor 或 /oem 解析出来的rc文件都会走这里 </span></span><br><span class="line">    <span class="comment">//涉及到selinux权限问题，Google为了保证安全 </span></span><br><span class="line">    <span class="comment">//队对厂商定制的rc文件中的命令执行，以及由此启动的服务的权限都会有一定限制</span></span><br><span class="line">    <span class="keyword">if</span> (subcontext) &#123;</span><br><span class="line">        <span class="keyword">if</span> (execute_in_subcontext_) &#123;</span><br><span class="line">            <span class="keyword">return</span> subcontext-&gt;Execute(args_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> expanded_args = subcontext-&gt;ExpandArgs(args_);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_args.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_args.error();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RunBuiltinFunction(func_, *expanded_args, subcontext-&gt;context());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//系统原生的rc文件命令都会走这里</span></span><br><span class="line">    <span class="keyword">return</span> RunBuiltinFunction(func_, args_, kInitContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统原生的rc文件命令都会走到<code>RunBuiltinFunction</code>方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">RunBuiltinFunction</span><span class="params">(<span class="keyword">const</span> BuiltinFunction&amp; function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> builtin_arguments = BuiltinArguments(context);</span><br><span class="line"></span><br><span class="line">    builtin_arguments.args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    builtin_arguments.args[<span class="number">0</span>] = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        builtin_arguments.args[i] = <span class="built_in">std</span>::<span class="built_in">move</span>(*expanded_arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function(builtin_arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>function</code>是一个以<code>BuiltinArguments</code>为参数的<code>std::function</code>函数包装器模板，可以包装函数、函数指针、类成员函数指针或任意类型的函数对象，在Command对象new出来的时候构造函数就指定了这个func_，我们可以看一下<code>Action::AddCommand</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Action::AddCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args, <span class="keyword">int</span> <span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_map_) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"no function map available"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从function_map_中进行键值对查找</span></span><br><span class="line">    <span class="keyword">auto</span> map_result = function_map_-&gt;Find(args);</span><br><span class="line">    <span class="keyword">if</span> (!map_result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; map_result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commands_.emplace_back(map_result-&gt;function, map_result-&gt;run_in_subcontext, <span class="built_in">std</span>::<span class="built_in">move</span>(args),</span><br><span class="line">                           <span class="built_in">line</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，是通过rc文件中的字符串去一个<code>function_map_</code>常量中查找得到的，而这个<code>function_map_</code>是在哪赋值的呢，答案是在<code>SecondStageMain</code>函数中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个在前文代码中有提及，map的定义在<code>system/core/init/builtins.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BuiltinFunctionMap&amp; <span class="title">GetBuiltinFunctionMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> BuiltinFunctionMap builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">"bootchart"</span>,               &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_bootchart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chmod"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_chmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chown"</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    &#123;<span class="literal">true</span>,   do_chown&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_restart"</span>,           &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_stop"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"copy"</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_copy&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"domainname"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_domainname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enable"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_enable&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec"</span>,                    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_background"</span>,         &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec_background&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_start"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_exec_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"export"</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_export&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"hostname"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_hostname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ifup"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_ifup&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"init_user0"</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_init_user0&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"insmod"</span>,                  &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_insmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"installkey"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_installkey&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_restart"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_start"</span>,         &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_stop"</span>,          &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_persist_props"</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_persist_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_system_props"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_system_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"loglevel"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_loglevel&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mark_post_data"</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_mark_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mkdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">6</span>,    &#123;<span class="literal">true</span>,   do_mkdir&#125;&#125;&#125;,</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do mount operations in vendor_init.</span></span><br><span class="line">        <span class="comment">// mount_all is currently too complex to run in vendor_init as it queues action triggers,</span></span><br><span class="line">        <span class="comment">// imports rc scripts, etc.  It should be simplified and run in vendor_init context.</span></span><br><span class="line">        <span class="comment">// mount and umount are run in the same context as mount_all for symmetry.</span></span><br><span class="line">        &#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">0</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount"</span>,                   &#123;<span class="number">3</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"perform_apex_config"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_perform_apex_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"update_linker_config"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_update_linker_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"readahead"</span>,               &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_readahead&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"remount_userdata"</span>,        &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_remount_userdata&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restart"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon"</span>,              &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon_recursive"</span>,    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon_recursive&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rm"</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rm&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rmdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rmdir&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setprop"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_setprop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setrlimit"</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    &#123;<span class="literal">false</span>,  do_setrlimit&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"start"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"stop"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"swapon_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_swapon_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enter_default_mount_ns"</span>,  &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_enter_default_mount_ns&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"symlink"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_symlink&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"sysclktz"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_sysclktz&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"trigger"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_trigger&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_update_state"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_verity_update_state&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait"</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_wait&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait_for_prop"</span>,           &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_wait_for_prop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"write"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_write&#125;&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>以下面一段rc脚本为例，我们看一下一个服务是怎么启动的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start </span><br><span class="line">    start zygote</span><br></pre></td></tr></table></figure>

<p>首先这是一个action，当init进程在死循环中执行到<code>ActionManager::ExecuteOneCommand</code>方法时，检查到这个action刚好符合<code>event_queue_</code>队首的<code>EventTrigger</code>，便会执行这个<code>action</code>下面的<code>commands</code>。<code>commands</code>怎么执行在上面已经分析过了，我们去<code>system/core/init/builtins.cpp</code>里的map中找key-value对应关系，发现start对应着<code>do_start</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Result&lt;<span class="keyword">void</span>&gt; <span class="title">do_start</span><span class="params">(<span class="keyword">const</span> BuiltinArguments&amp; args)</span> </span>&#123;</span><br><span class="line">    Service* svc = ServiceList::GetInstance().FindService(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!svc) <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"service "</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">" not found"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = svc-&gt;Start(); !result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorIgnoreEnoent() &lt;&lt; <span class="string">"Could not start service: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceList</code>通过<code>args[1]</code>即定义的服务名去寻找之前解析好的service，并执行<code>Service::Start</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//上面基本上是一些检查和准备工作，这里先忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//通过namespaces_.flags判断使用哪种方式创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (namespaces_.flags) &#123;</span><br><span class="line">        pid = clone(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespaces_.flags | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置权限掩码</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//内部调用execv函数启动文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ExpandArgsAndExecv(args_, sigstop_)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"cannot execv('"</span> &lt;&lt; args_[<span class="number">0</span>]</span><br><span class="line">                        &lt;&lt; <span class="string">"'). See the 'Debugging init' section of init's README.md for tips"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pid_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ErrnoError() &lt;&lt; <span class="string">"Failed to fork"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ExpandArgsAndExecv</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">bool</span> sigstop)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; expanded_args;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; c_strings;</span><br><span class="line"></span><br><span class="line">    expanded_args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//将要执行的文件路径先加入容器</span></span><br><span class="line">    c_strings.push_back(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(args[<span class="number">0</span>].data()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; args[<span class="number">0</span>] &lt;&lt; <span class="string">": cannot expand arguments': "</span> &lt;&lt; expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        expanded_args[i] = *expanded_arg;</span><br><span class="line">        c_strings.push_back(expanded_args[i].data());</span><br><span class="line">    &#125;</span><br><span class="line">    c_strings.push_back(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigstop) &#123;</span><br><span class="line">        kill(getpid(), SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用execv函数，带参执行文件</span></span><br><span class="line">    <span class="keyword">return</span> execv(c_strings[<span class="number">0</span>], c_strings.data()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先<code>fork</code>（或<code>clone</code>）出了一个子进程，再在这个子进程中调用<code>execv</code>函数执行文件</p>
<p>到此为止，一个服务便被启动起来了</p>
<h3 id="守护服务"><a href="#守护服务" class="headerlink" title="守护服务"></a>守护服务</h3><p>当服务启动起来后，<code>init</code>进程也要负责服务的守护，为什么呢？</p>
<p>假设<code>zygote</code>进程挂了，那<code>zygote</code>进程下的所有子进程都可能会被杀，整个<code>Android</code>系统会出现大问题，那怎么办呢？得把<code>zygote</code>进程重启起来呀。<code>init</code>进程守护服务做的就是这些事，当接收到子进程退出信号，就会触发对应的函数进行处理，去根据这个进程所对应的服务，处理后事（重启等）</p>
<p>代码在这个位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建出来一个epoll句柄，再用它去<code>InstallSignalFdHandler</code>装载信号handler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InstallSignalFdHandler</span><span class="params">(Epoll* epoll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Applying SA_NOCLDSTOP to a defaulted SIGCHLD handler prevents the signalfd from receiving</span></span><br><span class="line">    <span class="comment">// SIGCHLD when a child process stops or continues (b/77867680#comment9).</span></span><br><span class="line">    <span class="comment">//设置SIGCHLD信号的处理方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在init进程中屏蔽SIGCHLD、SIGTERM信号</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsRebootCapable()) &#123;</span><br><span class="line">        <span class="comment">// If init does not have the CAP_SYS_BOOT capability, it is running in a container.</span></span><br><span class="line">        <span class="comment">// In that case, receiving SIGTERM will cause the system to shut down.</span></span><br><span class="line">        sigaddset(&amp;mask, SIGTERM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to block signals"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a handler to unblock signals in the child processes.</span></span><br><span class="line">    <span class="comment">//在子进程中取消SIGCHLD、SIGTERM信号屏蔽</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> result = pthread_atfork(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;UnblockSignals);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to register a fork handler: "</span> &lt;&lt; strerror(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建用于接受信号的文件描述符</span></span><br><span class="line">    signal_fd = signalfd(<span class="number">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (signal_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to create signalfd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册信号处理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p>先介绍一下<code>sigaction</code>函数，它是用来检查和设置一个信号的处理方式的</p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>第一个参数<code>signum</code>，定义在<code>signal.h</code>中，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>是一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_handler</code>表示信号的处理方式，<code>sa_flags</code>用来设置信号处理的其他相关操作</p>
<p>第三个参数<code>oldact</code>，如果不为<code>null</code>，会将此信号原来的处理方式保存进去</p>
<p>对应一下<code>InstallSignalFdHandler</code>里的调用，<code>.sa_handler = SIG_DFL</code>表示使用默认的信号处理，<code>.sa_flags = SA_NOCLDSTOP</code>当参数<code>signum</code>为<code>SIGCHLD</code>的时候生效，表示当子进程暂停时不会通知父进程</p>
<h4 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h4><p>接下来<code>InstallSignalFdHandler</code>函数调用了一些信号集函数</p>
<h5 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h5><p>原型：<code>int sigemptyset(sigset_t *set);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigemptyset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</a></p>
<p>该函数的作用是将信号集初始化为空</p>
<h5 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a>sigaddset</h5><p>原型：<code>int sigaddset(sigset_t *set, int signo);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigaddset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigaddset.3p.html</a></p>
<p>该函数的作用是把信号signo添加到信号集set中</p>
<h5 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h5><p>原型：<code>int sigpromask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>该函数可以根据参数指定的方法修改进程的信号屏蔽字</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<p>为什么init进程要屏蔽这些信号呢？因为它后面会特殊处理这些信号</p>
<h4 id="pthread-atfork"><a href="#pthread-atfork" class="headerlink" title="pthread_atfork"></a>pthread_atfork</h4><p>这也是一个Linux函数，用来注册fork的handlers</p>
<p>原型：<code>int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</code></p>
<p>调用这个函数后，当进程再调用fork时，内部创建子进程钱会先在父进程中调用<code>prepare</code>函数，创建子进程成功后，会在父进程中调用<code>parent</code>函数，子进程中调用<code>child</code>函数</p>
<p>对应到<code>InstallSignalFdHandler</code>里来，即当init进程fork出子进程后调用<code>UnblockSignals</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnblockSignals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGTERM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to unblock signals for PID "</span> &lt;&lt; getpid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是，先在init进程中屏蔽了<code>SIGCHLD</code>、<code>SIGTERM</code>信号，再在子进程中解除了这两个信号的屏蔽</p>
<h4 id="signalfd函数"><a href="#signalfd函数" class="headerlink" title="signalfd函数"></a>signalfd函数</h4><p>同样也是Linux函数，用来创建用于接受信号的文件描述符</p>
<p>原型：<code>int signalfd(int fd, const sigset_t *mask, int flags);</code></p>
<p>参数fd如果为-1，则该函数会创建一个新的文件描述符与mask信号集相关联，如果不为-1，则该函数会用mask替换之前与这个fd相关联的信号集</p>
<p>flags：</p>
<ul>
<li>SFD_NONBLOCK：给新打开的文件描述符设置<code>O_NONBLOCK</code>标志，非阻塞I/O模式</li>
<li>SFD_CLOEXEC：给新打开的文件描述符设置<code>O_CLOEXEC</code>标志，当exec函数执行成功后，会自动关闭这个文件描述符</li>
</ul>
<p>对应到<code>InstallSignalFdHandler</code>中，它创建了一个用于接受<code>SIGCHLD</code>、<code>SIGTERM</code>信号的文件描述符。回忆一下之前对启动服务的分析，是先调用fork创建进程，在exec执行文件，将flags设置为<code>SFD_CLOEXEC</code>，这样就可以保证在子进程中关闭由fork得到的接收信号的文件描述符</p>
<p>注册信号处理器</p>
<p>最后调用<code>Epoll::RegisterHandler</code>方法注册处理器，内部调用了<code>epoll_ctl</code>函数，感兴趣可以自己看一下，文档：<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></p>
<p>这样，当init进程接收到<code>SIGCHLD</code>、<code>SIGTERM</code>信号时便会调用<code>HandleSignalFd</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleSignalFd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signalfd_siginfo siginfo;</span><br><span class="line">    <span class="comment">//从信号集文件描述符中读取信息</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(<span class="built_in">read</span>(signal_fd, &amp;siginfo, <span class="keyword">sizeof</span>(siginfo)));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read != <span class="keyword">sizeof</span>(siginfo)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to read siginfo from signal_fd"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            HandleSigtermSignal(siginfo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"signal_fd: received unexpected signal "</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里主要看<code>SIGCHLD</code>，当子进程退出，init进程便会捕获到<code>SIGCHLD</code>，执行<code>ReapAnyOutstandingChildren</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapAnyOutstandingChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ReapOneProcess() != <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ReapOneProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// This returns a zombie pid or informs us that there are no zombies left to be reaped.</span></span><br><span class="line">    <span class="comment">// It does NOT reap the pid; that is done below.</span></span><br><span class="line">    <span class="comment">//获取一个已经退出的子进程，但暂时先不销毁</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class="number">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"waitid failed"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pid = siginfo.si_pid;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we know we have a zombie pid, so we use this scopeguard to reap the pid</span></span><br><span class="line">    <span class="comment">// whenever the function returns from this point forward.</span></span><br><span class="line">    <span class="comment">// We do NOT want to reap the zombie earlier as in Service::Reap(), we kill(-pid, ...) and we</span></span><br><span class="line">    <span class="comment">// want the pid to remain valid throughout that (and potentially future) usages.</span></span><br><span class="line">    <span class="comment">//最后，销毁这个子进程</span></span><br><span class="line">    <span class="keyword">auto</span> reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, <span class="literal">nullptr</span>, WNOHANG)); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wait_string;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class="line">        name = <span class="string">"Subcontext"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过pid获得service</span></span><br><span class="line">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!service) <span class="keyword">return</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理service后事</span></span><br><span class="line">    service-&gt;Reap(siginfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service-&gt;flags() &amp; SVC_TEMPORARY) &#123;</span><br><span class="line">        ServiceList::GetInstance().RemoveService(*service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="waitid函数"><a href="#waitid函数" class="headerlink" title="waitid函数"></a>waitid函数</h5><p>Linux函数，用于等待一个子进程状态的改变</p>
<p>原型：<code>int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/waitid.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/waitid.3p.html</a></p>
<p>第一个参数<code>idtype</code>：</p>
<ul>
<li>P_PID：等待的子进程的pid必须和参数id匹配</li>
<li>P_GID：等待的子进程的组id必须和参数id匹配</li>
<li>P_ADD：等待所有子进程，此时，参数id被忽略</li>
</ul>
<p>这个函数会将执行的结果保存在第三个参数infop中</p>
<p><code>options</code>：</p>
<ul>
<li>WCONTINUED：等待那些由SIGCONT重新启动的子进程</li>
<li>WEXITED：等待那些已经退出的子进程</li>
<li>WSTOPPED：等待那些被信号暂停的子进程</li>
<li>WNOHANG：非阻塞等待</li>
<li>WNOWAIT：保持返回的子进程处于可等待状态（后续可以再对这个子进程进行wait）</li>
</ul>
<p>回到<code>ReapOneProcess</code>函数中来，它先调用<code>waitid</code>函数，获得一个状态发生改变的子进程（options设置了<code>WEXITED</code>，即已退出的子进程），使用了<code>WNOWAIT</code>参数，也就是暂时先不销毁子进程，使用非阻塞的方式获取</p>
<p>ScopeGuard</p>
<p><code>ScopeGuard</code>的意思是，出作用域后，自动执行某段代码</p>
<p>函数中那段<code>make_scope_guard</code>的意思是，当这个函数执行完后，使用<code>waitpid</code>函数销毁子进程</p>
<p>之后会从<code>ServiceList</code>中通过pid去查找service，查到后调用<code>Service::Reap</code>处理后事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Service::Reap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当service的参数没有oneshot或者restart时，kill整个进程组</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        KillProcessGroup(SIGKILL, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Legacy behavior from ~2007 until Android R: this else branch did not exist and we did not</span></span><br><span class="line">        <span class="comment">// kill the process group in this case.</span></span><br><span class="line">        <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &gt;= __ANDROID_API_R__) &#123;</span><br><span class="line">            <span class="comment">// The new behavior in Android R is to kill these process groups in all cases.  The</span></span><br><span class="line">            <span class="comment">// 'true' parameter instructions KillProcessGroup() to report a warning message where it</span></span><br><span class="line">            <span class="comment">// detects a difference in behavior has occurred.</span></span><br><span class="line">            KillProcessGroup(SIGKILL, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any socket resources we may have created.</span></span><br><span class="line">    <span class="comment">//移除已创建的sockets</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; socket : sockets_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> path = ANDROID_SOCKET_DIR <span class="string">"/"</span> + socket.name;</span><br><span class="line">        unlink(path.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : reap_callbacks_) &#123;</span><br><span class="line">        f(siginfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果进程接收信号异常或被终止的状态异常，并且包含reboot_on_failure标志，重启系统</span></span><br><span class="line">    <span class="keyword">if</span> ((siginfo.si_code != CLD_EXITED || siginfo.si_status != <span class="number">0</span>) &amp;&amp; on_failure_reboot_target_) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Service with 'reboot_on_failure' option failed, shutting down system."</span>;</span><br><span class="line">        trigger_shutdown(*on_failure_reboot_target_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当service参数为exec时，释放相应服务资源</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_EXEC) UnSetExec();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_TEMPORARY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pid_ = <span class="number">0</span>;</span><br><span class="line">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line">    start_order_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Oneshot processes go into the disabled state on exit,</span></span><br><span class="line">    <span class="comment">// except when manually restarted.</span></span><br><span class="line">    <span class="comment">//当service参数有oneshot，没有restart和reset时，将service状态置为disable</span></span><br><span class="line">    <span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line">    <span class="comment">//禁用和重置的服务，都不能自动重启</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将标志置为重启中</span></span><br><span class="line">    flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">    flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line">    <span class="comment">//执行该service下的所有onrestart命令</span></span><br><span class="line">    onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">    NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service相关的参数可以去<code>system/core/init/README.md</code>中自行查看</p>
<p>这个函数检查了一堆service的标志和状态，判断如何处理这个service，如果需要重启，则调用<code>onrestart_.ExecuteAllCommands()</code>执行该service下的所有<code>onrestart</code>命令，具体的执行过程之前在启动服务那边已经分析过了，这里就不再往下看了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个init进程的启动过程最重要的部分基本都已分析完成，我也是一边从网上搜集资料一边对照着源码磕磕绊绊看过来的，有什么错误或者遗漏的部分欢迎指正，谢谢～</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/">各厂商Android系统碰到的奇奇怪怪问题的记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><h2 id="MIUI"><a href="#MIUI" class="headerlink" title="MIUI"></a>MIUI</h2><h3 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h3><p><code>CaptureRequest.Builder</code>的<code>set</code>方法，对部分<code>key</code>不生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIUI中，CaptureRequest.Builder设置图片方向不生效</span></span><br><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>解决方法：获得拍摄好的照片<code>Bitmap</code>后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h1><h2 id="HarmonyOs"><a href="#HarmonyOs" class="headerlink" title="HarmonyOs"></a>HarmonyOs</h2><h3 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h3><p>华为ROM（EMUI不确定有没有这种情况）计算<code>TextureView</code>边界的代码似乎有bug</p>
<p>现象：</p>
<ol>
<li>相机预览和拍摄时有概率画面畸形</li>
<li>渲染超过一屏的文本会渲染空白</li>
</ol>
<p>解决方法：手动管理<code>TextureView</code>的销毁和创建</p>
<p>第一步：在对<code>TextureView</code>设置<code>TextureView.SurfaceTextureListener</code>时，另<code>onSurfaceTextureDestroyed</code>返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mTextureView.setSurfaceTextureListener(<span class="keyword">new</span> TextureView.SurfaceTextureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里默认是返回true，代表系统自动管理，我们把它设为false手动管理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二步：在<code>TextureView</code>不渲染的时候手动<code>release</code>掉其中的<code>SurfaceTexture</code>，后面再渲染时，系统调用draw方法后，会自动重新<code>new</code>一个<code>SurfaceTexture</code>出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SurfaceTexture surfaceTexture = mTextureView.getSurfaceTexture();</span><br><span class="line"><span class="keyword">if</span> (surfaceTexture != <span class="keyword">null</span>) &#123;</span><br><span class="line">    surfaceTexture.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VIVO"><a href="#VIVO" class="headerlink" title="VIVO"></a>VIVO</h1><h2 id="OriginOS"><a href="#OriginOS" class="headerlink" title="OriginOS"></a>OriginOS</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>OriginOS中，<code>TextView</code>设置了<code>android:fontFamily</code>后，不能在设置<code>android:textStyle</code>属性，否则会导致使用的字体被系统默认字体覆盖</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/18/android/aosp/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA/">AOSP的编译及刷机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/AOSP/">AOSP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AOSP/">AOSP</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>众所周知，Android是开源的，AOSP（Android Open Source Project）为Android开源项目的缩写。作为一名Android开发，掌握Android系统的工作机制是技术成长中的必经之路，第一步就是自己编译Android系统。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>一台可以解BL锁（BootLoader），并且厂商提供了硬件驱动的设备，这里推荐使用Google亲儿子手机（Nexus、Pixel系列），可以解BL锁，Google官方会提供硬件驱动，并且AOSP里会提供对应机型的配置</li>
<li>一块剩余空间至少大于300GB的硬盘（Android11源码-150GB左右，编译产物-150GB左右）</li>
<li><del>系统最好为Linux，MacOS也可（Windows可以用WSL）</del></li>
<li>系统需要使用Ubuntu（我不确定别的Linux发行版可不可用），自2021年6月22日起，AOSP不再支持在Windows或MacOS上构建（Windows可以使用WSL，详见<a href="https://juejin.cn/post/7196869815596286008" target="_blank" rel="noopener">WSL编译AOSP必要的几个前置工作</a>）</li>
<li>内存至少要16GB，过小的内存会导致生成build.ninja文件失败</li>
</ul>
<p>这里是Google官方的推荐要求：<a href="https://source.android.com/setup/build/requirements?hl=zh-cN" target="_blank" rel="noopener">https://source.android.com/setup/build/requirements?hl=zh-cN</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>参考文档：<a href="https://source.android.com/source/initializing?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/initializing?hl=zh-cn</a></p>
<p>主要就是下载各种编译工具，像jdk，gcc，g++等，还有各种动态库以及辅助工具</p>
<p>注：此文档中部分环境安装有误，缺失了一些必要的库安装，可能会编译中途报错，可以参考下文的环境安装，如果编译还是出现了依赖缺失，安装好继续编译即可</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>以Ubuntu系统为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<p>注：现在AOSP编译要求JDK版本&gt;=9</p>
<h2 id="安装其他程序包"><a href="#安装其他程序包" class="headerlink" title="安装其他程序包"></a>安装其他程序包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5</span><br></pre></td></tr></table></figure>

<p>注：官方文档中缺失了libncurses5，会导致编译中途找不到libncurses.so.5库</p>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>Android源码是由非常多的Git仓库组成的，为了可以统一管理这么多个Git仓库，Google出了一款工具，叫Repo</p>
<p>参考文档：<a href="https://source.android.com/source/downloading?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/downloading?hl=zh-cn</a></p>
<p>因为Google在国内访问的问题，建议使用镜像下载源码，下面提供几个镜像地址：</p>
<ul>
<li>清华大学</li>
</ul>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</a></p>
<ul>
<li>中科大</li>
</ul>
<p>git://mirrors.ustc.edu.cn/aosp/platform/manifest</p>
<p>repo init的时候可以指定分支：<a href="https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds</a> 在这里可以找到对应系统分支所支持的设备，比如说我的设备是Pixel2，在这张表上可以看到android-11.0.0_r25这个分支下的代码支持我的设备，所以可以执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r25</span><br></pre></td></tr></table></figure>

<p>然后开始进行同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync -j8 #j8代表使用8个线程</span><br></pre></td></tr></table></figure>

<p>AOSP代码下载是个漫长的过程，需要耐心等待</p>
<h1 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h1><p>在<a href="https://developers.google.com/android/drivers?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/android/drivers?hl=zh-cn</a>这个网站可以找到Nexus、Pixel系列的驱动，要注意每个驱动后面会有一串代号，需要和你下载的AOSP源码的build号相对应</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A82.png" alt=""></p>
<p>将他们解压后会得到两个shell文件</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E8%A7%A3%E5%8E%8B.png" alt=""></p>
<p>将他们复制到下载好的aosp源码的根目录</p>
<p>注：网上很多教程说终端要选用bash不要使用zsh，我亲测使用zsh没有问题，如果在编译过程中出现问题，可以尝试切换shell</p>
<ol>
<li>先将shell切换到aosp源码根目录</li>
<li>执行两个解压出来的驱动shell，记得要同意License</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.png" alt=""></p>
<ol start="3">
<li>执行source build/envsetup.sh，这会向shell中写入一些环境变量</li>
<li>先make clean一下</li>
<li>使用lunch命令选择构建目标</li>
</ol>
<p>这里是该命令的规则：<a href="https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch aosp_walleye-userdebug</span><br></pre></td></tr></table></figure>

<p>后面跟随的的参数可以在这里找到：<a href="https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build" target="_blank" rel="noopener">https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build</a></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>你也可以在lunch后不加参数，这样会弹出一个菜单提示您选择目标</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>指定完成后会弹出这样一个信息提示</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E5%AE%8C%E6%88%90.png" alt=""></p>
<h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>构建部分的文档在这里：<a href="https://source.android.com/setup/build/building?hl=zh-cn#build-the-code" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#build-the-code</a><br>如果是初次编译，我们就直接使用<code>m</code>命令就可以了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -j8 #开启8线程编译</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>现在直接使用<code>make</code>命令会提示<code>Calling make directly is no longer supported</code>然后退出编译，所以使用<code>m</code>命令替代<code>make</code></li>
<li>不能使用root账号编译</li>
</ul>
<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><ol>
<li>先将手机的BL锁解开（每个机型都不同，网上会有对应的教程），进入fastboot模式\</li>
<li>配置fastboot工具（现在Google好像推出了在线刷写工具<a href="https://flash.android.com/" target="_blank" rel="noopener">https://flash.android.com/</a>，可以尝试使用），可以在aosp目录下通过make fastboot命令编译出来，也可以直接从网上下载：<a href="https://developer.android.com/studio/releases/platform-tools" target="_blank" rel="noopener">https://developer.android.com/studio/releases/platform-tools</a></li>
<li>进入编译后产生的镜像的目录…./aosp/out/target/product/walleye(这个是你机型的代号，每种机器都不一样)</li>
<li>执行命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启即可看到，我们编译的Android系统已经运行到了手机上</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot #重启命令</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="MacOS上找不到SDK"><a href="#MacOS上找不到SDK" class="headerlink" title="MacOS上找不到SDK"></a>MacOS上找不到SDK</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_MacOS%E6%89%BE%E4%B8%8D%E5%88%B0SDK.png" alt=""></p>
<p>去这里<a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a>下载对应版本的sdk，然后将它放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs目录下，然后重新编译</p>
<p>除此之外，也可以在Finder中查看</p>
<p>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p>
<p>这个目录下存在哪个版本的sdk，确定后去修改…./aosp/build/soong/cc/config/x86_darwin_host.go文件，在darwinSupportedSdkVersions这个数组中加上你使用的sdk的版本</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>保存后重新编译，这个方式可能当前编译脚本不支持你所用的sdk，可能会编译报错，所以还是推荐使用第一种方式</p>
<h2 id="too-many-open-files"><a href="#too-many-open-files" class="headerlink" title="too many open files"></a>too many open files</h2><p>在Linux系统下有打开文件数的限制，可以使用以下命令设置最大可打开文件数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">ulimit</span> -a 可以查看当前限制</span></span><br><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/26/android/view/%E8%B5%B0%E9%A9%AC%E7%81%AF%E5%BC%8F%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84TextView/">走马灯式横向滚动的TextView</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/TextView/">TextView</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们可以设置<code>TextView</code>的<code>android:ellipsize=&quot;marquee&quot;</code>属性，来做到当文字超出一行的时候呈现跑马灯效果。但<code>TextView</code>的这个走马灯效果需要获取焦点，而同一时间只有一个控件可以获得焦点，更重要的是产品要求无论文字内容是否超出一行，都要滚动效果。</p>
<p>这里先贴一下最后实现的Github地址和效果图</p>
<p><a href="https://github.com/dreamgyf/MarqueeTextView" target="_blank" rel="noopener">https://github.com/dreamgyf/MarqueeTextView</a></p>
<p><img src="https://camo.githubusercontent.com/f78ec92d9270fe6a72f182090567334a5d9ecb5221f471a34cbd83905be65c6a/68747470733a2f2f647265616d6779662d636f64696e672e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f4d61727175656554657874566965772f4d61727175656554657874566965772e676966" alt="MarqueeTextView"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路其实很简单，我们只要将单行的<code>TextView</code>截成一张<code>Bitmap</code>，然后我们再自定义一个View，重写它的<code>onDraw</code>方法，每隔一段时间，将这张Bitmap画在不同的坐标上（左右两边各draw一次），这样连续起来看起来就是走马灯效果了。</p>
<p>后来和同事讨论，他提出能不能通过Canvas的平移配合<code>drawText</code>实现这个功能，我想应该也是可以的，但我没有做尝试，各位看官感兴趣的可是试一下这种方案。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们先自定义一个View继承自<code>AppCompatTextView</code>，再在初始化的时候new一个<code>TextView</code>，并重写<code>onMeasure</code>和<code>onLayout</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView = <span class="keyword">new</span> TextView(getContext(), attrs);</span><br><span class="line">    <span class="comment">//TextView如果没有设置LayoutParams，当setText的时候会引发NPE导致崩溃</span></span><br><span class="line">    mTextView.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));</span><br><span class="line">    mTextView.setMaxLines(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">//宽度不设限制</span></span><br><span class="line">    mTextView.measure(MeasureSpec.UNSPECIFIED, heightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="comment">//保证布局包含完整的Text内容</span></span><br><span class="line">    mTextView.layout(left, top, left + mTextView.getMeasuredWidth(), bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做是为了利用这个内部<code>TextView</code>生成我们需要的<code>Bitmap</code>，同时借用<code>TextView</code>写好的<code>onMeasure</code>方法，这样我们就不用再那么复杂的重写<code>onMeasure</code>方法了</p>
<p>接下来是生成<code>Bitmap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBitmap = Bitmap.createBitmap(mTextView.getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(mBitmap);</span><br><span class="line">    mTextView.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单，需要注意的是长度要使用内部持有的<code>TextView</code>的<code>getMeasuredWidth</code>，如果使用<code>getWidth</code>的话，最大值为屏幕的宽度，很可能导致生成出的<code>Bitmap</code>不全，高度用谁的倒是无所谓</p>
<p>在每次<code>setText</code>或<code>setTextSize</code>的时候都需要更新<code>Bitmap</code>并重新布局绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView.addOnLayoutChangeListener(<span class="keyword">new</span> OnLayoutChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChange</span><span class="params">(View v, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">int</span> oldLeft, <span class="keyword">int</span> oldTop, <span class="keyword">int</span> oldRight, <span class="keyword">int</span> oldBottom)</span> </span>&#123;</span><br><span class="line">            updateBitmap();</span><br><span class="line">            restartScroll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setText(text, type);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有text参数会先调用setText，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextView.setText(text);</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSize</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setTextSize(unit, size);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有textSize参数会先调用setTextSize，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextView.setTextSize(size);</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我给这个<code>MarqueeTextView</code>定义了一些参数，一个是<code>space</code>（文字滚动时，头尾的最小间隔距离），另一个是<code>speed</code>（文字滚动的速度）</p>
<p>先看一下<code>onDraw</code>的实现吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当文字内容不超过一行</span></span><br><span class="line">        <span class="keyword">if</span> (mTextView.getMeasuredWidth() &lt;= getWidth()) &#123;</span><br><span class="line">            <span class="comment">//计算头尾需要间隔的宽度</span></span><br><span class="line">            <span class="keyword">int</span> space = mSpace - (getWidth() - mTextView.getMeasuredWidth());</span><br><span class="line">            <span class="keyword">if</span> (space &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                space = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了显示宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -getWidth() - space) &#123;</span><br><span class="line">                mLeftX += getWidth() + space;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为最右边的坐标-左边bitmap已消失的宽度+间隔宽度</span></span><br><span class="line">                canvas.drawBitmap(mBitmap, getWidth() + mLeftX + space, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当文字内容超过一行</span></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了内容宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -mTextView.getMeasuredWidth() - mSpace) &#123;</span><br><span class="line">                mLeftX += mTextView.getMeasuredWidth() + mSpace;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="comment">//当尾部已经显示出来的时候</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX + (mTextView.getMeasuredWidth() - getWidth()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为尾部的坐标+间隔宽度</span></span><br><span class="line">                canvas.drawBitmap(mBitmap, mTextView.getMeasuredWidth() + mLeftX + mSpace, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是基本的绘制思路</p>
<p>接下来需要让他动起来，这里使用的<code>Choreographer</code>，每次收到<code>Vsync</code>信号系统绘制新帧时都更新一下坐标并重绘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> BASE_FPS = <span class="number">60f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mFps = BASE_FPS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前屏幕刷新率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class="line">        mFps = context.getDisplay().getRefreshRate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WindowManager windowManager =</span><br><span class="line">                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        mFps = windowManager.getDefaultDisplay().getRefreshRate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Choreographer.FrameCallback frameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="comment">//保证在不同刷新率的屏幕上，视觉上的速度一致</span></span><br><span class="line">        <span class="keyword">int</span> speed = (<span class="keyword">int</span>) (BASE_FPS / mFps * mSpeed);</span><br><span class="line">        mLeftX -= speed;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Choreographer.getInstance().postFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLeftX = <span class="number">0</span>;</span><br><span class="line">    Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restartScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopScroll();</span><br><span class="line">    startScroll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>View</code>可见性发生变化时，需要控制一下动画的启停</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisibilityChanged</span><span class="params">(@NonNull View changedView, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visibility == VISIBLE) &#123;</span><br><span class="line">        updateFps();</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(frameCallback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/android/common/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">Android开发常见问题总结（持续更新）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="透明与方向"><a href="#透明与方向" class="headerlink" title="透明与方向"></a>透明与方向</h2><p>当且仅当<code>Android 8.0</code>系统中，不能对一个<code>Activity</code>同时设置透明（<code>windowIsTranslucent</code>和<code>windowIsFloating</code>）和方向（<code>screenOrientation</code>），否则会抛出<code>Only fullscreen opaque activities can request orientation</code>异常崩溃</p>
<p>解决方法：</p>
<p>在代码中先判断系统版本，再设置方向</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="meta-string">"SourceLockedOrientationActivity"</span>)</span></span><br><span class="line">        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h1><h2 id="重新布局"><a href="#重新布局" class="headerlink" title="重新布局"></a>重新布局</h2><p><code>TextView</code>在调用<code>setText</code>后不一定会走<code>requestLayout</code>方法，在某些情况下会导致显示异常，比如因<code>RecyclerView</code>复用导致长度不符合预期的问题</p>
<p>解决方案：简单来说当<code>TextView</code>的<code>width</code>属性不为<code>WRAP_CONTENT</code>且文字高度没发生变化的情况下，它就不会重新布局，如果你需要它重新计算宽高的话，注意以上的条件，设置合适的属性即可，具体的源码分析可以参考 <a href="https://zhuanlan.zhihu.com/p/381485429" target="_blank" rel="noopener">从 TextView.setText() 看 requestLayout 和 invalidate 方法有什么不同</a> 这篇文章</p>
<h2 id="ellipse"><a href="#ellipse" class="headerlink" title="ellipse"></a>ellipse</h2><p><code>TextView</code>在某些情况下，<code>ellipse</code>属性会失效</p>
<ul>
<li><p><code>setText</code>设置了<code>BufferType</code>为<code>NORMAL</code>以外的其他值</p>
</li>
<li><p><code>TextView</code>设置了<code>MovementMethod</code></p>
</li>
</ul>
<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>通过<code>TextView</code>中的<code>android.text.Layout</code>，我们可以通过它计算很多东西，比如通过x ,y坐标去获取字符下标呀，或者通过字符下标去计算这个文字x坐标等等，但需要注意的是，<code>android.text.Layout</code>在计算的过程中不会去考虑<code>TextView</code>的<code>padding</code>，所以在开发的过程中我们自己需要进行一些处理，比如说通过x ,y坐标去获取字符下标的时候，传入的x, y值要减去<code>paddingLeft</code>，<code>paddingTop</code>，当通过字符下标去计算文字x坐标后，要再加上<code>paddingLeft</code>才是正确的x坐标</p>
<hr>
<h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><ol>
<li>滑动嵌套</li>
</ol>
<p>滑动组件的嵌套可能会产生以下一些问题：</p>
<ul>
<li>滑动冲突</li>
</ul>
<p>解决方法：使用<code>NestedScrollView</code>替代<code>ScrollView</code>，<code>RecyclerView</code>可以设置属性<code>android:nestedScrollingEnabled=&quot;false&quot;</code>或代码里<code>setNestedScrollingEnabled(false);</code>来禁用组件自身的滑动</p>
<p>注意：如果<code>RecyclerView</code>只能显示一个Item的话，需要设置<code>NestedScrollView</code>的属性<code>android:fillViewport=&quot;true&quot;</code></p>
<ul>
<li>滑动失效</li>
</ul>
<p><code>ScrollView</code>设置<code>fillViewport=&quot;true&quot;</code>的情况下，如果对<code>ScrollView</code>的直接子view设置上下margin，在超出内容的高度小于设置的margin的情况下，可能会导致整个<code>ScrollView</code>滑动失效</p>
<ol start="2">
<li>焦点抢占</li>
</ol>
<p><code>ScrollView</code>、<code>RecyclerView</code>等滑动组件可能会抢占焦点，导致界面显示时直接滑动到对应组件的位置，而不是顶部</p>
<p>解决方法：在顶部View(或者其他你所期望的初始位置)加上属性<code>android:focusable=&quot;true&quot;</code>和<code>android:focusableInTouchMode=&quot;true&quot;</code></p>
<p>新解决方法：在顶部View上加<code>android:descendantFocusability</code>属性，该属性是用来定义父布局与子布局之间的关系的，它有三种值：</p>
<ul>
<li><code>beforeDescendants</code>：父布局会优先其子类控件而获取到焦点</li>
<li><code>afterDescendants</code>：父布局只有当其子类控件不需要获取焦点时才获取焦点</li>
<li><code>blocksDescendants</code>：父布局会覆盖子类控件而直接获得焦点</li>
</ul>
<p>使用<code>blocksDescendants</code>覆盖子布局焦点以解决焦点抢占问题</p>
<hr>
<h1 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h1><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><ol>
<li>在<code>onBindViewHolder</code>中设置子View回调时需要注意</li>
</ol>
<p>如果回调的参数包括position时，需要注意有没有地方会调用<code>notifyItemRemoved</code>或<code>notifyItemRangeRemoved</code>，如果有，需要使用<code>holder.getAdapterPosition()</code>来代替<code>onBindViewHolder</code>方法的position参数</p>
<p>原因：<code>notifyItemRemoved</code>不会对其他的Item重新调用<code>onBindViewHolder</code>，这样可能会导致position错位。<code>holder.getAdapterPosition()</code>方法会返回数据在 Adapter 中的位置（即使位置的变化还未刷新到布局中）</p>
<ol start="2">
<li>如何在更新数据后重新定位到顶部</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写父类方法，获得绑定的RecyclerView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(@NonNull RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">	mRecyclerView = recyclerView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数据更新后调用</span></span><br><span class="line"><span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span> &amp;&amp; mRecyclerView.getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	mRecyclerView.scrollToPosition(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前尝试过<code>mRecyclerView.scrollTo(0, 0);</code>但没有起效，不清楚为什么</p>
<ol start="3">
<li>动态部分更新数据时</li>
</ol>
<p>如果<code>RecyclerView</code>需要动态更新<strong>部分</strong>数据，并且在<code>onBindViewHolder</code>时对某些view设置了事件或者回调等，如果此时使用到了position参数需要注意，如果你只notify了部分数据更新，可能会导致更新后部分ViewHolder中的回调里的position不正确，建议：</p>
<ul>
<li>使用<code>notifyDataSetChanged()</code></li>
<li>使用<code>notifyItem</code>，但是在<code>onBindViewHolder</code>中设置回调时不要使用position参数，而是使用<code>holder.getAdapterPosition()</code>替代（注意这个方法在<code>ViewHolder</code>没有和<code>RecyclerView</code>绑定时会返回-1 <code>NO_POSITION</code>）</li>
</ul>
<h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h2><ol>
<li><code>StaggeredGridLayoutManager</code>下<code>ItemDecoration</code>的<code>offset</code>计算错误</li>
</ol>
<p>主要是因为<code>RecyclerView</code>动态更新数据时，会执行多次<code>measure</code>，但只会在第一次<code>measure</code>的时候调用<code>ItemDecoration.getItemOffsets</code>（因为<code>LP</code>里的<code>mInsetsDirty</code>变量），此时获得的<code>spanIndex</code>是一个错误值</p>
<p>这个问题的具体分析可以看<a href="https://blog.kyleduo.com/2017/07/27/recyclerview-wrong-decoration-inset/" target="_blank" rel="noopener">这篇文章</a>，暂时没有什么好的解决方案，不建议大家使用反射，毕竟你不知道<code>Android</code>会不会更改这个变量</p>
<h2 id="嵌套ViewPager"><a href="#嵌套ViewPager" class="headerlink" title="嵌套ViewPager"></a>嵌套ViewPager</h2><p>在<code>RecyclerView</code>中嵌套<code>ViewPager</code>的情况下，当你将一个<code>ViewPager</code>滑动出视野再滑回来，这个<code>ViewPager</code>的下一个切换会没有动画</p>
<p>原因：当<code>RecyclerView</code>的<code>Item</code>滑入滑出屏幕时分别会调用子<code>View</code>的<code>onAttachedToWindow</code>和<code>onDetachedFromWindow</code>方法，当<code>ViewPager</code>触发<code>onAttachedToWindow</code>后，会将其里面的一个表示是否为第一次布局的成员变量<code>mFirstLayout</code>赋值为<code>true</code>，当这个变量为<code>true</code>时，<code>ViewPager</code>会以无动画的方式显示当前<code>Item</code></p>
<p>解决方法：重写<code>RecyclerView.Adapter</code>的<code>onViewAttachedToWindow</code>方法，在里面对<code>ViewPager</code>调用其<code>requestLayout</code>方法，在<code>ViewPager.onLayout</code>方法最后，会将<code>mFirstLayout</code>变量重新赋值为<code>false</code></p>
<hr>
<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><h2 id="RenderScript高斯模糊"><a href="#RenderScript高斯模糊" class="headerlink" title="RenderScript高斯模糊"></a>RenderScript高斯模糊</h2><p>在使用<code>RenderScript</code>做高斯模糊时，需要注意，它只支持格式为<code>ALPHA_8</code>、<code>ARGB_4444</code>、<code>ARGB_8888</code>、<code>RGB_565</code>的<code>Bitmap</code>，对于其他格式的<code>Bitmap</code>，可以尝试使用<code>Bitmap.reconfigure</code>方法转换格式（这个方法不能将<code>Bitmap</code>从小格式转换成大格式，比如不能从占用32个bits的<code>ARGB_8888</code>转换成占用64个bits的<code>RGBA_F16</code>）</p>
<hr>
<h1 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h1><ol>
<li>生命周期</li>
</ol>
<ul>
<li>初始化时需要注意</li>
</ul>
<p>Dialog在第一次调用<code>show()</code>方法后才会执行<code>onCreate(Bundle savedInstanceState)</code>方法，因此建议自定义Dialog时将<code>findViewById</code>等初始化操作放在构造函数中进行，避免外部使用时因在<code>show()</code>之前设置视图数据导致NPE</p>
<hr>
<h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><ol>
<li>点击没反应</li>
</ol>
<p><code>PopupWindow</code>如果不设置背景的话，在某些5.x以下系统机型上会出现点击没反应的问题</p>
<p>解决方法：给PopupWindow设置一个空背景<code>popupWindow.setBackgroundDrawable(new BitmapDrawable(mContext.getResources(), (Bitmap) null));</code></p>
<p>详见：<a href="https://juejin.cn/post/6844903761488379912" target="_blank" rel="noopener">https://juejin.cn/post/6844903761488379912</a></p>
<hr>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><ol>
<li>隐式广播</li>
</ol>
<p>在Android8.0以上的系统，大部分的隐式广播都被限制不可使用。</p>
<p>解决方法：</p>
<ol>
<li>使用动态广播</li>
<li>使用显示广播<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 设置Component</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(context, SomeReceiver<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 设置Package</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setPackage(<span class="string">"com.dreamgyf.xxx"</span>);</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不知道包名的话可以通过PackageManager获取所有注册了指定action的广播的package</span></span><br><span class="line">Intent actionIntent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">List&lt;ResolveInfo&gt; matches = pm.queryBroadcastReceivers(actionIntent, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : matches) &#123;            </span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(actionIntent);            </span><br><span class="line">    intent.setPackage(resolveInfo.activityInfo.applicationInfo.packageName);            </span><br><span class="line">    intent.setAction(SOME_ACTION);            </span><br><span class="line">    context.sendBroadcast(intent);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="软键盘"><a href="#软键盘" class="headerlink" title="软键盘"></a>软键盘</h1><ol>
<li>弹起软键盘</li>
</ol>
<p>网上大部分文章所写的弹起软键盘的方法并不完美，大部分文章让你在<code>onResume</code>时再弹起，有的文章甚至让你<code>postDelayed</code>，非常不靠谱，经过本人分析，软键盘的弹起需要满足以下几个条件：</p>
<ul>
<li><p>控件为<code>EditText</code>或其子类</p>
</li>
<li><p>控件所在的<code>window</code>要获得焦点</p>
</li>
<li><p>控件本身要获得焦点</p>
</li>
</ul>
<p>根据以上几个条件，我写了一个完美弹起软键盘的方法，<code>onCreate</code>时也可以照常使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showKeyboard</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ims = context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span>? InputMethodManager ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus()) &#123;</span><br><span class="line">        requestFocus()</span><br><span class="line">        ims.showSoftInput(<span class="keyword">this</span>, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewTreeObserver.addOnWindowFocusChangeListener(<span class="keyword">object</span> : OnWindowFocusChangeListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onWindowFocusChanged</span><span class="params">(hasFocus: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">                    viewTreeObserver.removeOnWindowFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                    requestFocus()</span><br><span class="line">                    ims.showSoftInput(<span class="keyword">this</span><span class="symbol">@showKeyboard</span>, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实体键盘"><a href="#实体键盘" class="headerlink" title="实体键盘"></a>实体键盘</h1><ol>
<li><code>EditText</code>有焦点时会拦截键盘的数字键</li>
</ol>
<p>解决方法：使用<code>TextWatcher</code>等监听<code>EditText</code>输入</p>
<hr>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ol>
<li>动画</li>
</ol>
<p>在Activity销毁之前如果没有cancel掉，会导致这个Activity内存泄漏</p>
<ol start="2">
<li><code>ClickableSpan</code></li>
</ol>
<p>使用<code>SpannableString.setSpan</code>方法设置<code>ClickableSpan</code>可能导致内存泄漏</p>
<p>原因：<code>TextView</code>在<code>onSaveInstanceState</code>时会将<code>ClickableSpan</code>复制一份，由于某些原因，<code>SpannableString</code>不会删除这个<code>ClickableSpan</code>，从而导致内存泄漏，详见：<br><a href="https://stackoverflow.com/questions/28539216/android-textview-leaks-with-setmovementmethod" target="_blank" rel="noopener">StackOverflow</a></p>
<p>解决方法：自定义一个抽象类同时继承<code>ClickableSpan</code>和实现<code>NoCopySpan</code>接口，外部<code>setSpan</code>时使用这个抽象类</p>
<hr>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><ol>
<li><code>Fragment</code>尽量不要使用带参构造函数，一定要保证有一个不含参的构造函数，否则在<code>Activity</code>重建时尝试反射<code>newInstance</code>恢复<code>Fragment</code>时会抛出<code>Could not find Fragment constructor</code>异常</li>
</ol>
<hr>
<h1 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h1><ol>
<li>反射</li>
</ol>
<p>如果使用到了反射，需要特别注意需不需要在<code>proguard-rules</code>中加入keep规则</p>
<ol start="2">
<li>module混淆</li>
</ol>
<p>如果是多module项目，想要在module中增加混淆规则，<code>proguardFiles</code>属性是无效的，应该使用<code>consumerProguardFiles</code>属性</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        versionName repo.version</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">        consumerProguardFiles <span class="string">'proguard-rules.pro'</span> <span class="comment">//这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="相机开发"><a href="#相机开发" class="headerlink" title="相机开发"></a>相机开发</h1><ol>
<li>拍照角度</li>
</ol>
<p>相机的方向一般是以手机横向作为正方向，这样如果我们以竖屏的方式拍照，拍出来的照片可能会出现旋转了90度的情况，这时候就需要在拍照完后处理一下图片，旋转到正确位置。</p>
<p>具体介绍与算法在Android SDK中<code>CaptureRequest.JPEG_ORIENTATION</code>的注释中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getJpegOrientation</span><span class="params">(CameraCharacteristics c, <span class="keyword">int</span> deviceOrientation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得相机方向与设备方向间的夹角</span></span><br><span class="line">    <span class="keyword">int</span> sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round device orientation to a multiple of 90</span></span><br><span class="line">    deviceOrientation = (deviceOrientation + <span class="number">45</span>) / <span class="number">90</span> * <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse device orientation for front-facing cameras</span></span><br><span class="line">    <span class="keyword">boolean</span> facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;</span><br><span class="line">    <span class="keyword">if</span> (facingFront) deviceOrientation = -deviceOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate desired JPEG orientation relative to camera orientation to make</span></span><br><span class="line">    <span class="comment">// the image upright relative to the device orientation</span></span><br><span class="line">    <span class="keyword">int</span> jpegOrientation = (sensorOrientation + deviceOrientation + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jpegOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算好角度后就可以对图片做旋转了，网上有很多文章都说使用这种方式做旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>但实际上在某些系统上 (MIUI)，设置的这个参数并不会生效，所以我的方案是，获得拍摄好的照片Bitmap后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/01/android/common/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB/">Android对Java的修改-SimpleDateFormat类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SimpleDateFormat/">SimpleDateFormat</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android会对部分OpenJDK中的代码进行一些修改，本篇记录一下因为这些修改而踩过的一些坑。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个在线上运行良好的Date工具类在写单元测试时一直报ParseException，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">utc2Local</span><span class="params">(String utcTime)</span> </span>&#123;</span><br><span class="line">    String utcTimePatten = <span class="string">"yyyy-MM-dd'T'HH:mm:ssZZZZZ"</span>;</span><br><span class="line">    String localTimePatten = <span class="string">"yyyy.MM.dd"</span>;</span><br><span class="line">    SimpleDateFormat utcFormater = <span class="keyword">new</span> SimpleDateFormat(utcTimePatten);</span><br><span class="line">    utcFormater.setTimeZone(TimeZone.getTimeZone(<span class="string">"UTC"</span>));<span class="comment">//时区定义并进行时间获取</span></span><br><span class="line">    Date gpsUTCDate = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        gpsUTCDate = utcFormater.parse(formatTimeStr(utcTime));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> utcTime;</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleDateFormat localFormater = <span class="keyword">new</span> SimpleDateFormat(localTimePatten);</span><br><span class="line">    localFormater.setTimeZone(TimeZone.getDefault());</span><br><span class="line">    String localTime = localFormater.format(gpsUTCDate.getTime());</span><br><span class="line">    <span class="keyword">return</span> localTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的参数utcTime为”2020-01-01 08:00:00+08:00”</p>
<p>这段代码在Android环境下运行良好，但在单元测试下一直报错</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Android对OpenJDK中的<code>SimpleDateFormat</code>进行了修改，具体在<code>subParseNumericZone</code>方法中：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB.png" alt=""></p>
<p>可以看到，OpenJDK原本是不支持带冒号的写法的，而在Android中修改了<code>subParseNumericZone</code>方法，使其可以解析带冒号的写法。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决方法也很简单，在测试时直接修改入参，去掉入参中的冒号就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (MockedStatic&lt;DateUtils&gt; mockedDateUtils = Mockito.mockStatic(DateUtils<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">CallsRealMethods</span>())) </span>&#123;</span><br><span class="line">    mockedDateUtils.when(() -&gt; &#123;</span><br><span class="line">       	DateUtils.utc2Local(argThat((argument) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> index = argument.length() - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> argument.charAt(index) == <span class="string">':'</span>;</span><br><span class="line">        ));</span><br><span class="line">    &#125;).then((invocation) -&gt; &#123;</span><br><span class="line">        String utcTime = invocation.getArgument(<span class="number">0</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String fixedDate = formatDate;</span><br><span class="line">        <span class="keyword">int</span> index = formatDate.length() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (formatDate.charAt(index) == <span class="string">':'</span>) &#123;</span><br><span class="line">            fixedDate = formatDate.substring(<span class="number">0</span>, index) + formatDate.substring(index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DateUtils.utc2Local(fixedDate);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/24/android/unit-test/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0/">Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着Kotlin语言在Android开发中越来越流行，自然也会遇到各种各样的问题。</p>
<p>本篇主要是针对我个人在Android单元测试Kotlin类时遇到的一些问题的思考和解决方案。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>我们都知道Kotlin给开发者提供了很多语法糖，其中之一就是<strong>顶层函数</strong>，我们可以直接把函数放在代码文件的顶层，让它不从属于任何类。</p>
<p>它的使用很简单，直接在kotlin代码的任意位置直接当作一个普通函数调用就行了，而在java中，需要像使用静态方法一样，以<strong>文件名+Kt</strong>为类名调用 (默认配置)</p>
<p>在java单元测试中，如果想mock这个顶层函数，只需要像对待一个静态方法一样，使用mockStatic方法即可</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E6%AD%A3%E5%B8%B8mock.png" alt=""></p>
<p>而在kotlin单元测试中，我们却无法找到这个class</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E9%94%99%E8%AF%AFmock.png" alt=""></p>
<h1 id="确定路线"><a href="#确定路线" class="headerlink" title="确定路线"></a>确定路线</h1><p>我们先建立一个文件来写一个顶层函数，再建立一个单元测试类去测试它: </p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E5%BB%BA%E7%AB%8B%E6%B5%8B%E8%AF%95%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>其实从上文中已经可以看出，kotlin的顶层函数在编译之后实际上就变成了一个被class包起来的static方法。对此，我们可以简单验证一下:</p>
<p>在Android Studio中点击菜单中的Tools-&gt;Kotlin-&gt;Show Kotlin ByteCode，会弹出对应类的字节码，再点击Decompile按钮，我们会看到确实被编译成了一个类中的静态方法</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E5%8F%8D%E7%BC%96%E8%AF%91%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>确定了这一点后，我们只需要在kotlin中拿到这个顶层函数的所属类，就可以像java里一样使用mockStatic来模拟了。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>既然涉及到了运行时类型分析，自然而然就想到了<strong>反射</strong>，我们先引入kotlin的反射库</p>
<p><code>implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot;</code></p>
<p>其实我对kotlin的反射并不熟悉，去文档里查阅了一下发现了<code>::sampleTopFun</code>这种写法，它的返回值为一个叫<code>KFunction</code>的接口类，我们先看看它有哪些方法可以供我们调用</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E7%9A%84%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>从字面上看好像没有什么方法和我们的需求有关，怎么办呢？那我们再看一下它的实现类吧，说不定会有一些私有变量保存了我们需要的信息。</p>
<p>那么怎么找到它的实现类呢？直接分析源码错综复杂的关系是很耗时且低效的，这里我采取了了一种取巧的方法，利用Android Studio的Debug功能:</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=""></p>
<p>和预料的不同，为什么这里拿到的类型是这么个奇葩玩意儿呢？我们看一下这个文件的字节码</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AD%97%E8%8A%82%E7%A0%81.png" alt=""></p>
<p>再往下看</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AD%97%E8%8A%82%E7%A0%812.png" alt=""></p>
<p>我们发现，这个奇葩的类型是在kotlin编译后自动生成的，它继承自<code>FunctionReference</code>，同时，在Debugger里，我们获得了一个重要的信息: <code>KFunctionImpl</code></p>
<p>根据名字猜测，它应该才是<code>KFunction</code>真正功能实现的地方，我们将它的信息展开</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E7%9C%9F%E6%AD%A3%E5%AE%9E%E7%8E%B0.png" alt=""></p>
<p>可以发现，我们已经找到我们想要的那个类了，只要拿到它，后续的mock工作就很简单了~</p>
<h1 id="开始Mock"><a href="#开始Mock" class="headerlink" title="开始Mock"></a>开始Mock</h1><p>根据上文，我们已经得知了我们需要获取的<code>jClass</code>的路径</p>
<p>我们先从<code>FunctionReference</code>去获取被<code>reflected</code>引用的<code>KFunctionImpl</code>，这个<code>reflected</code>实际是被<code>FunctionReference</code>继承的<code>CallableReference</code>中的一个变量，在<code>FunctionReference</code>提供了一个<code>getReflected</code>方法，我们通过反射调用这个方法即可得到这个对象，当然，我们也可以通过反射Field获得它，但注意到<code>getReflected</code>方法处理了一些空对象的情况，为了保险起见，我们还是采取反射调用<code>getReflected</code>的方法获取<code>KFunctionImpl</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction2.png" alt=""></p>
<p>反射调用<code>getReflected</code>方法获取<code>KFunctionImpl</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction3.png" alt=""></p>
<p>第一步没问题，接下来开始反射获取<code>container</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96container.png" alt=""></p>
<p>第二步也没什么问题，接下来就是反射获取<code>jClass</code>了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96jclass.png" alt=""></p>
<p>ok，一切正常，接下来和java一样，让我们试试用这个我们获取到的类mockStatic吧</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_mockStatic.png" alt=""></p>
<p>可以看到，测试成功通过，至此，我们成功解决了Mockito模拟顶层函数的问题。为了方便使用，可以将以上代码封装成一个函数，这里就不再赘述了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/31/common/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0/">汇编指令笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></span><div class="content"><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p>AX: AH-AL (数据累加器, 可用于乘、 除、输入/输出等操作)</p>
<p>BX: BH-BL (基址寄存器, 可作为存储器指针来使用)</p>
<p>CX: CH-CL (计数寄存器, 可用来控制循环次数)</p>
<p>DX: DH-DL (数据寄存器, 在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址)</p>
<h2 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h2><blockquote>
<p>主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。</p>
</blockquote>
<p>ESI: 32bit == SI: 16bit (源变址寄存器, 与DS联用, 指示数据段中某操作的偏移量. 在做串处理时, SI指示源操作数地址, 并有自动增量或自动减量的功能。 变址寻址时, SI与某一位移量共同构成操作数的偏移量)</p>
<p>EDI: 32bit == DI: 16bit (与DS联用, 指示数据段中某操作数的偏移量, 或与某一位移量共同构成操作数的偏移量. 串处理操作时, DI指示附加段中目的地址, 并有自动增量或减量的功能)</p>
<h2 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h2><blockquote>
<p>主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。</p>
</blockquote>
<p>EBP: 32bit == BP: 16bit (基指针寄存器, 用它可直接存取堆栈中的数据)</p>
<p>ESP: 32bit == SP: 16bit (堆栈指针寄存器, 始终只是栈顶的位置, 与SS寄存器一起组成栈顶数据的物理地址)</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成<br>的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p>
</blockquote>
<ul>
<li><p>16位</p>
<p>  CS——代码段寄存器，存放当前程序的指令代码</p>
<p>  DS——数据段寄存器，存放程序所涉及的源数据或结果</p>
<p>  ES——附加段寄存器，辅助数据区, 存放串或其他数据</p>
<p>  SS——堆栈段寄存器，其值为堆栈段的段值</p>
</li>
<li><p>32位</p>
<p>  FS——附加段寄存器，其值为附加数据段的段值</p>
<p>  GS——附加段寄存器，其值为附加数据段的段值</p>
</li>
</ul>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="cmp-配合jz-jnz"><a href="#cmp-配合jz-jnz" class="headerlink" title="cmp (配合jz, jnz)"></a>cmp (配合jz, jnz)</h2><p>算数运算指令，比较两个值，如果相等则设置ZF(零标志)为1, 可用jz(jump if zero)或jnz(jump if not zero)指令检查ZF位, jz(ZF零标志为1)即相等, jnz(ZF零标志为1)即不相等</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"></span><br><span class="line"><span class="symbol">compare:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>x1000, %ax</span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">$0</span>x1000, %ax    <span class="comment">;判断ax寄存器中的值是否为0x1000</span></span><br><span class="line">    <span class="keyword">jz</span> is_equal         <span class="comment">;如果相等，则跳转到代码段is_equal</span></span><br><span class="line">    <span class="keyword">jnz</span> is_not_equal    <span class="comment">;如果不相等，则跳转到代码段is_not_equal</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">is_equal:</span></span><br><span class="line">    <span class="comment">;do something</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">is_not_equal:</span></span><br><span class="line">    <span class="comment">;do something</span></span><br></pre></td></tr></table></figure>

<h2 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h2><p>重复执行后面的指令，直到cx寄存器中的值为0</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="symbol">example:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>, %ax         //将<span class="built_in">ax</span>寄存器置<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>x1000, %cx</span><br><span class="line">    <span class="keyword">rep</span> <span class="keyword">add</span> <span class="number">$1</span>, %ax     //使<span class="built_in">ax</span>寄存器加<span class="number">1</span>，执行<span class="number">1000</span>次</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/19/android/view/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">自定义EditView时踩过的坑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/EditView/">EditView</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这次的需求是一个单词拼写的输入框，要求每个字母分割开来输入，每个字母下面有一个下划线，就类似于验证码输入或者支付密码输入的效果</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91_%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图" title="效果图"></p>
<p>最终成品是一个自定义View，实现参考了<a href="https://github.com/JingYeoh/VercodeEditText" target="_blank" rel="noopener">VercodeEditText</a></p>
<hr>
<h1 id="EditView还是TextView？"><a href="#EditView还是TextView？" class="headerlink" title="EditView还是TextView？"></a>EditView还是TextView？</h1><p>刚开始的时候，我选择了继承<code>AppCompatEditText</code>，但在我试着draw on canvas的时候，奇怪的发现绘制的东西并没有在界面上显示，然后我尝试将视图的高度调大，当到达了一个临界点后，内容突然显示出来了。</p>
<p>为了得知这个问题的成因，我试着画一个占满整个画布的矩形，打开开发者选项里的显示布局边界后发现，这个矩形并没有占满整个布局。一开始猜想可能是因为画布的高度小于视图的高度，于是打开debug调试断点发现，两者是一致的；然后猜测是不是画布因为什么原因产生了偏移？但怎么尝试都没有得到确定性的结论，直到某次我打开了EditText的背景，并随便滑动了几下发现，在向下滑动的时候，原本绘制的内容便从视图最上方滚动了下来。原来是因为当EditText高度小于1行时，EditText会自动适配并滚动到最下方。</p>
<p>既然知道了问题的成因，那就开始着手解决他，最直接的办法就是禁止EditText的滚动。为此，我尝试了<code>setMinHeight()</code>，<code>setMinLines()</code>都没有用。然后我退而求其次，尝试使用<code>scrollTo(0, 0)</code>，将视图固定滑动到最顶部，发现效果并不是很理想。然后在查资料的过程中我发现了<code>MovementMethod</code>这么一个东西。</p>
<p>网上关于<code>MovementMethod</code>的资料比较少，我查询了一下Google的官方文档里面介绍：</p>
<blockquote>
<p>Provides cursor positioning, scrolling and text selection functionality in a TextView.<br>即：在 TextView提供了光标定位，滚动和文本选择功能。</p>
</blockquote>
<p>找到了产生滚动的元凶，那问题就好办了，在源码里可以看到，EditText的<code>getDefaultMovementMethod()</code>返回了一个<code>ArrowKeyMovementMethod</code>，我们直接<code>setMovementMethod(null)</code>或者重写父类的<code>getDefaultMovementMethod()</code>使其返回值为null，滚动的问题便解决了。</p>
<p>解决完这一步后，又发现了一个新问题，EditText的上下左右有一定的padding，点击到这部分padding的区域是不会触发EditText的获取焦点弹出输入法的，当然也可以直接重写<code>onTouchEvent</code>方法加上<code>requestFocus()</code>方法解决，但考虑到继承EditText要重设背景，又要setMovementMethod，还要处理边缘点击事件，感觉太麻烦，不如直接继承TextView，处理的事情会稍微少一些。</p>
<p>于是我选择继承<code>AppCompatTextView</code>，重写<code>getDefaultEditable()</code>使其返回true以打开编辑功能，<code>setFocusableInTouchMode(true)</code>使其能获取焦点，重写<code>onTouchEvent</code>方法加上<code>requestFocus()</code>方法使其点击能够直接获取焦点，<code>setCursorVisible(false)</code>隐藏光标，<code>setLongClickable(false)</code>禁止长按弹出编辑菜单，到这一步，基本难点已经解决了。</p>
<hr>
<h1 id="onTextChanged多次调用？"><a href="#onTextChanged多次调用？" class="headerlink" title="onTextChanged多次调用？"></a>onTextChanged多次调用？</h1><p>为了监听文本改变的事件，我一开始选择了自定义View直接implements TextWatcher，然后<code>addTextChangedListener(this)</code>，这样在断点调试的时候发现，<code>onTextChanged()</code>方法被执行了多次，但<code>beforeTextChanged()</code>和<code>afterTextChanged()</code>执行次数却是正常的。原来，在TextView内部已经有了一个可重写的<code>onTextChanged()</code>方法，和TextWatcher里的<code>onTextChanged()</code>一模一样，当<code>addTextChangedListener(this)</code>后，TextView会先执行TextWatcher的<code>onTextChanged()</code>，再执行自己内部的<code>onTextChanged()</code>。解决方法很简单，将implements TextWatcher去掉，改为addTextChangedListener一个匿名内部类就好了。</p>
<hr>
<h1 id="长度超过限制了怎么办？"><a href="#长度超过限制了怎么办？" class="headerlink" title="长度超过限制了怎么办？"></a>长度超过限制了怎么办？</h1><p>刚开始，我在<code>onTextChanged()</code>里增加了对Text长度的判断，如果长度超长，就把原Text截断到最大长度，然后重新setText进去。这样做有一个问题，这样并不能保证<code>afterTextChanged()</code>回调里的Text参数长度合法。当这么做后，TextView首先会触发截断Text的<code>afterTextChanged()</code>，然后再触发超长Text的<code>afterTextChanged()</code>。后来在搜索资料的时候发现，TextView内部持有了一个<code>InputFilter</code>数组，这个接口可以很好的帮助我们在触发回调之前对输入的字符串进行过滤操作。</p>
<ul>
<li>InputFilter接口方法</li>
</ul>
<blockquote>
<p>public CharSequence filter(CharSequence source, int start, int end,Spanned dest, int dstart, int dend);</p>
</blockquote>
<p>其中，InputFilter已经内置实现了长度过滤功能，只需要在设置新answer的时候，重新<code>setFilters()</code>就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputFilter[] filters = <span class="keyword">new</span> InputFilter[]&#123;</span><br><span class="line">		<span class="keyword">new</span> InputFilter.LengthFilter(answer.length())</span><br><span class="line">&#125;;</span><br><span class="line">setFilters(filters);</span><br></pre></td></tr></table></figure>

<h1 id="具体的绘制实现？"><a href="#具体的绘制实现？" class="headerlink" title="具体的绘制实现？"></a>具体的绘制实现？</h1><h2 id="计算预留位置"><a href="#计算预留位置" class="headerlink" title="计算预留位置"></a>计算预留位置</h2><p>我定义了一个变量<code>String ALL_CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</code>用来计算用户输入的预留宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> width = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">	Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ALL_CHARS.length(); i++) &#123;</span><br><span class="line">		mTextPaint.getTextBounds(ALL_CHARS, i, i + <span class="number">1</span>, rect);</span><br><span class="line">		width = Math.max(width, rect.width());</span><br><span class="line">		height = Math.max(height, rect.height());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCharWidth = width;</span><br><span class="line">	mCharHeight = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onMeasure()里计算好布局宽高后，根据宽高和间隔距离平均分配一下每个字母的坐标。</p>
<h2 id="自适应宽度"><a href="#自适应宽度" class="headerlink" title="自适应宽度"></a>自适应宽度</h2><p>这次的需求还要求当布局的宽度超过父布局时，自动缩小字体大小以适应父布局宽度。这个其实也很简单，计算一下绘制需要的宽度，如果超过父布局宽度，就减小字号，循环一下即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (answerWidth &gt; width - getPaddingLeft() - getPaddingRight()) &#123;</span><br><span class="line">	mTextPaint.setTextSize(--mTextSize);</span><br><span class="line">	measureChar();</span><br><span class="line">	answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户输入文字的绘制"><a href="#用户输入文字的绘制" class="headerlink" title="用户输入文字的绘制"></a>用户输入文字的绘制</h2><p>由于每个字母的宽高可能不同，所以不能直接使用之前计算好的坐标绘制，需要使用之前测量好的预留的宽度减去用户实际输入字母的宽度除以2，然后加上这个预留位置的起始坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">computeCharX</span><span class="params">(CharCoordinate coordinate, <span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">	mTextPaint.getTextBounds(String.valueOf(letter), <span class="number">0</span>, <span class="number">1</span>, mTempRect);</span><br><span class="line">	<span class="keyword">int</span> realCharWidth = mTempRect.width();</span><br><span class="line">	<span class="keyword">return</span> coordinate.start + (<span class="keyword">float</span>) (mCharWidth - realCharWidth) / <span class="number">2</span> - mTempRect.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里减去mTempRect.left是因为绘制出来的字符有些向右偏离</p>
</blockquote>
<h2 id="绘制光标"><a href="#绘制光标" class="headerlink" title="绘制光标"></a>绘制光标</h2><p>TextView原本的光标不符合我们的需求，我们需要绘制一下自定义的光标。</p>
<p>先定义一下光标闪烁时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_CURSOR_DURATION = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCursorDuration = DEFAULT_CURSOR_DURATION;</span><br></pre></td></tr></table></figure>

<p>再定义一个Handler和Runnable用来间隔执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable mCursorRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mNeedCursorShow) &#123;</span><br><span class="line">			mIsCursorShowing = !mIsCursorShowing;</span><br><span class="line">			invalidate();</span><br><span class="line">		&#125;</span><br><span class="line">		mHandler.postDelayed(mCursorRunnable, mCursorDuration);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样通过设置一个bool值和定时任务每隔一段时间刷新一下视图就可以轻松实现光标的闪烁。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/01/common/Git%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/">Git命令简介</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 'dreamgyf' //设置用户名</span><br><span class="line">git config --global user.email g2409197994@gmail.com //设置邮箱</span><br></pre></td></tr></table></figure>



<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git init //在当前目录创建版本库</span><br><span class="line">git add README.md //将文件添加到暂存区</span><br><span class="line">git commit //提交暂存区中的修改 -m"xxx":本次提交的说明 -a:相当多加了一步于git add .</span><br><span class="line">git branch 分支名 //创建分支，不加分支名可以查看所有分支 -d:删除指定分支</span><br><span class="line">git checkout 分支名 //切换分支 -b:创建并切换分支，相当于多加了一步git branch 分支名</span><br><span class="line">git remote add https://github.com/xxx/xxx.git //添加远程仓库，一般支持https和ssh两种协议</span><br><span class="line">git fetch //将远程主机的更新全部取回本地，后面加分支名的话只会取回指定分支</span><br><span class="line">git merge 分支名 //将选中分支合并到当前分支</span><br><span class="line">git pull 分支名 //相当于git fetch 分支名 + git merge 分支名</span><br><span class="line">git push //将当前本地分支推送至远程分支，如果是第一次推送则需要-u参数指定远程分支并建立联系，如git push -u origin master，下一次便可不加参数直接推送 -f:强制推送，会覆盖远程分支</span><br></pre></td></tr></table></figure>

<h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><ul>
<li><p>合并commit记录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  [startpoint]  [endpoint]</span><br></pre></td></tr></table></figure>

<p>其中<code>-i</code>的意思是<code>--interactive</code>，即弹出交互式的界面让用户编辑完成合并操作，<code>[startpoint] [endpoint]</code>则指定了一个编辑区间，如果不指定<code>[endpoint]</code>，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。</p>
<p>命令可以按如下方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [commit id]</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>然后会出现一个vi编辑器界面，会提供给我们一个命令列表：</p>
<blockquote>
<p>pick：保留该commit（缩写:p）</p>
<p>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</p>
<p>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</p>
<p>squash：将该commit和前一个commit合并（缩写:s）</p>
<p>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</p>
<p>exec：执行shell命令（缩写:x）</p>
<p>drop：丢弃该commit（缩写:d）</p>
</blockquote>
<p>然后我们就可以在里面修改提交了，例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick d2cf1f9 fix: 第一次提交</span><br><span class="line">s 47971f6 第二次提交</span><br><span class="line">s fb28c8d 第三次提交</span><br></pre></td></tr></table></figure>

<p>将第二、三次的commit合并到第一次上</p>
<p>编辑完保存退出vi就可以完成对commit的合并了</p>
<p>如果保存时出现错误，输入<code>git rebase --edit-todo</code>便会回到编辑模式里，修改完后保存，<code>git rebase --continue</code></p>
<p><a href="https://juejin.im/entry/6844903600976576519" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p>合并分支</p>
<p><code>rebase</code>和<code>merge</code>都是合并分支的操作</p>
<p><code>merge</code>会在合并分支时产生一个新的commit记录，而<code>rebase</code>会以指定分支作为基础分支，之前所做的改动全部会在指定分支的基础上提交，不会产生新的commit记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>分析一下上面命令进行的操作：</p>
<p>首先，切换到<code>dev</code>分支上；</p>
<p>然后，<code>git</code> 会把 <code>dev</code> 分支里面的每个 <code>commit</code> 取消掉；</p>
<p>其次，把之前的<code>commit</code>临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下；</p>
<p>然后，把<code>dev</code>分支更新到最新的 <code>master</code> 分支；</p>
<p>最后，把上面保存的 <code>patch</code> 文件应用到 <code>dev</code> 分支上；</p>
<ul>
<li>使用场景<ol>
<li>想要干净简洁的分支树</li>
<li>在一个过时的分支上面开发的时候，执行 <code>rebase</code> 以同步 <code>master</code> 分支最新变动</li>
</ol>
</li>
</ul>
<p><strong>注意：当同一个分支有多个人使用的情况下，谨慎使用rebase，因为它改变了历史，可能会出现丢失commit的情况</strong></p>
<p><a href="http://jartto.wang/2018/12/11/git-rebase/" target="_blank" rel="noopener">参考链接</a></p>
</li>
</ul>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>