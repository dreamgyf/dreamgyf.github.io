<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">43</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/">各厂商Android系统碰到的奇奇怪怪问题的记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><h2 id="MIUI"><a href="#MIUI" class="headerlink" title="MIUI"></a>MIUI</h2><h3 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h3><p><code>CaptureRequest.Builder</code>的<code>set</code>方法，对部分<code>key</code>不生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIUI中，CaptureRequest.Builder设置图片方向不生效</span></span><br><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>解决方法：获得拍摄好的照片<code>Bitmap</code>后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h1><h2 id="HarmonyOs"><a href="#HarmonyOs" class="headerlink" title="HarmonyOs"></a>HarmonyOs</h2><h3 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h3><p>华为ROM（EMUI不确定有没有这种情况）计算<code>TextureView</code>边界的代码似乎有bug</p>
<p>现象：</p>
<ol>
<li>相机预览和拍摄时有概率画面畸形</li>
<li>渲染超过一屏的文本会渲染空白</li>
</ol>
<p>解决方法：手动管理<code>TextureView</code>的销毁和创建</p>
<p>第一步：在对<code>TextureView</code>设置<code>TextureView.SurfaceTextureListener</code>时，另<code>onSurfaceTextureDestroyed</code>返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mTextureView.setSurfaceTextureListener(<span class="keyword">new</span> TextureView.SurfaceTextureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里默认是返回true，代表系统自动管理，我们把它设为false手动管理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二步：在<code>TextureView</code>不渲染的时候手动<code>release</code>掉其中的<code>SurfaceTexture</code>，后面再渲染时，系统调用draw方法后，会自动重新<code>new</code>一个<code>SurfaceTexture</code>出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SurfaceTexture surfaceTexture = mTextureView.getSurfaceTexture();</span><br><span class="line"><span class="keyword">if</span> (surfaceTexture != <span class="keyword">null</span>) &#123;</span><br><span class="line">    surfaceTexture.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VIVO"><a href="#VIVO" class="headerlink" title="VIVO"></a>VIVO</h1><h2 id="OriginOS"><a href="#OriginOS" class="headerlink" title="OriginOS"></a>OriginOS</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>OriginOS中，<code>TextView</code>设置了<code>android:fontFamily</code>后，不能在设置<code>android:textStyle</code>属性，否则会导致使用的字体被系统默认字体覆盖</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/18/android/aosp/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA/">AOSP的编译及刷机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/AOSP/">AOSP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AOSP/">AOSP</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>众所周知，Android是开源的，AOSP（Android Open Source Project）为Android开源项目的缩写。作为一名Android开发，掌握Android系统的工作机制是技术成长中的必经之路，第一步就是自己编译Android系统。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>一台可以解BL锁（BootLoader），并且厂商提供了硬件驱动的设备，这里推荐使用Google亲儿子手机（Nexus、Pixel系列），可以解BL锁，Google官方会提供硬件驱动，并且AOSP里会提供对应机型的配置</li>
<li>一块剩余空间至少大于300GB的硬盘（Android11源码-150GB左右，编译产物-150GB左右）</li>
<li><del>系统最好为Linux，MacOS也可（Windows可以用WSL）</del></li>
<li>系统需要使用Ubuntu（我不确定别的Linux发行版可不可用），自2021年6月22日起，AOSP不再支持在Windows或MacOS上构建（Windows可以使用WSL，详见<a href="https://juejin.cn/post/7196869815596286008" target="_blank" rel="noopener">WSL编译AOSP必要的几个前置工作</a>）</li>
<li>内存至少要16GB，过小的内存会导致生成build.ninja文件失败</li>
</ul>
<p>这里是Google官方的推荐要求：<a href="https://source.android.com/setup/build/requirements?hl=zh-cN" target="_blank" rel="noopener">https://source.android.com/setup/build/requirements?hl=zh-cN</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>参考文档：<a href="https://source.android.com/source/initializing?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/initializing?hl=zh-cn</a></p>
<p>主要就是下载各种编译工具，像jdk，gcc，g++等，还有各种动态库以及辅助工具</p>
<p>注：此文档中部分环境安装有误，缺失了一些必要的库安装，可能会编译中途报错，可以参考下文的环境安装，如果编译还是出现了依赖缺失，安装好继续编译即可</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>以Ubuntu系统为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<p>注：现在AOSP编译要求JDK版本&gt;=9</p>
<h2 id="安装其他程序包"><a href="#安装其他程序包" class="headerlink" title="安装其他程序包"></a>安装其他程序包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5</span><br></pre></td></tr></table></figure>

<p>注：官方文档中缺失了libncurses5，会导致编译中途找不到libncurses.so.5库</p>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>Android源码是由非常多的Git仓库组成的，为了可以统一管理这么多个Git仓库，Google出了一款工具，叫Repo</p>
<p>参考文档：<a href="https://source.android.com/source/downloading?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/downloading?hl=zh-cn</a></p>
<p>因为Google在国内访问的问题，建议使用镜像下载源码，下面提供几个镜像地址：</p>
<ul>
<li>清华大学</li>
</ul>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</a></p>
<ul>
<li>中科大</li>
</ul>
<p>git://mirrors.ustc.edu.cn/aosp/platform/manifest</p>
<p>repo init的时候可以指定分支：<a href="https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds</a> 在这里可以找到对应系统分支所支持的设备，比如说我的设备是Pixel2，在这张表上可以看到android-11.0.0_r25这个分支下的代码支持我的设备，所以可以执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r25</span><br></pre></td></tr></table></figure>

<p>然后开始进行同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync -j8 #j8代表使用8个线程</span><br></pre></td></tr></table></figure>

<p>AOSP代码下载是个漫长的过程，需要耐心等待</p>
<h1 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h1><p>在<a href="https://developers.google.com/android/drivers?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/android/drivers?hl=zh-cn</a>这个网站可以找到Nexus、Pixel系列的驱动，要注意每个驱动后面会有一串代号，需要和你下载的AOSP源码的build号相对应</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A82.png" alt=""></p>
<p>将他们解压后会得到两个shell文件</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E8%A7%A3%E5%8E%8B.png" alt=""></p>
<p>将他们复制到下载好的aosp源码的根目录</p>
<p>注：网上很多教程说终端要选用bash不要使用zsh，我亲测使用zsh没有问题，如果在编译过程中出现问题，可以尝试切换shell</p>
<ol>
<li>先将shell切换到aosp源码根目录</li>
<li>执行两个解压出来的驱动shell，记得要同意License</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.png" alt=""></p>
<ol start="3">
<li>执行source build/envsetup.sh，这会向shell中写入一些环境变量</li>
<li>先make clean一下</li>
<li>使用lunch命令选择构建目标</li>
</ol>
<p>这里是该命令的规则：<a href="https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch aosp_walleye-userdebug</span><br></pre></td></tr></table></figure>

<p>后面跟随的的参数可以在这里找到：<a href="https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build" target="_blank" rel="noopener">https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build</a></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>你也可以在lunch后不加参数，这样会弹出一个菜单提示您选择目标</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>指定完成后会弹出这样一个信息提示</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E5%AE%8C%E6%88%90.png" alt=""></p>
<h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>构建部分的文档在这里：<a href="https://source.android.com/setup/build/building?hl=zh-cn#build-the-code" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#build-the-code</a><br>如果是初次编译，我们就直接使用<code>m</code>命令就可以了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -j8 #开启8线程编译</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>现在直接使用<code>make</code>命令会提示<code>Calling make directly is no longer supported</code>然后退出编译，所以使用<code>m</code>命令替代<code>make</code></li>
<li>不能使用root账号编译</li>
</ul>
<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><ol>
<li>先将手机的BL锁解开（每个机型都不同，网上会有对应的教程），进入fastboot模式\</li>
<li>配置fastboot工具（现在Google好像推出了在线刷写工具<a href="https://flash.android.com/" target="_blank" rel="noopener">https://flash.android.com/</a>，可以尝试使用），可以在aosp目录下通过make fastboot命令编译出来，也可以直接从网上下载：<a href="https://developer.android.com/studio/releases/platform-tools" target="_blank" rel="noopener">https://developer.android.com/studio/releases/platform-tools</a></li>
<li>进入编译后产生的镜像的目录…./aosp/out/target/product/walleye(这个是你机型的代号，每种机器都不一样)</li>
<li>执行命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启即可看到，我们编译的Android系统已经运行到了手机上</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot #重启命令</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="MacOS上找不到SDK"><a href="#MacOS上找不到SDK" class="headerlink" title="MacOS上找不到SDK"></a>MacOS上找不到SDK</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_MacOS%E6%89%BE%E4%B8%8D%E5%88%B0SDK.png" alt=""></p>
<p>去这里<a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a>下载对应版本的sdk，然后将它放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs目录下，然后重新编译</p>
<p>除此之外，也可以在Finder中查看</p>
<p>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p>
<p>这个目录下存在哪个版本的sdk，确定后去修改…./aosp/build/soong/cc/config/x86_darwin_host.go文件，在darwinSupportedSdkVersions这个数组中加上你使用的sdk的版本</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>保存后重新编译，这个方式可能当前编译脚本不支持你所用的sdk，可能会编译报错，所以还是推荐使用第一种方式</p>
<h2 id="too-many-open-files"><a href="#too-many-open-files" class="headerlink" title="too many open files"></a>too many open files</h2><p>在Linux系统下有打开文件数的限制，可以使用以下命令设置最大可打开文件数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">ulimit</span> -a 可以查看当前限制</span></span><br><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/26/android/view/%E8%B5%B0%E9%A9%AC%E7%81%AF%E5%BC%8F%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84TextView/">走马灯式横向滚动的TextView</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/TextView/">TextView</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们可以设置<code>TextView</code>的<code>android:ellipsize=&quot;marquee&quot;</code>属性，来做到当文字超出一行的时候呈现跑马灯效果。但<code>TextView</code>的这个走马灯效果需要获取焦点，而同一时间只有一个控件可以获得焦点，更重要的是产品要求无论文字内容是否超出一行，都要滚动效果。</p>
<p>这里先贴一下最后实现的Github地址和效果图</p>
<p><a href="https://github.com/dreamgyf/MarqueeTextView" target="_blank" rel="noopener">https://github.com/dreamgyf/MarqueeTextView</a></p>
<p><img src="https://camo.githubusercontent.com/f78ec92d9270fe6a72f182090567334a5d9ecb5221f471a34cbd83905be65c6a/68747470733a2f2f647265616d6779662d636f64696e672e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f4d61727175656554657874566965772f4d61727175656554657874566965772e676966" alt="MarqueeTextView"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路其实很简单，我们只要将单行的<code>TextView</code>截成一张<code>Bitmap</code>，然后我们再自定义一个View，重写它的<code>onDraw</code>方法，每隔一段时间，将这张Bitmap画在不同的坐标上（左右两边各draw一次），这样连续起来看起来就是走马灯效果了。</p>
<p>后来和同事讨论，他提出能不能通过Canvas的平移配合<code>drawText</code>实现这个功能，我想应该也是可以的，但我没有做尝试，各位看官感兴趣的可是试一下这种方案。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们先自定义一个View继承自<code>AppCompatTextView</code>，再在初始化的时候new一个<code>TextView</code>，并重写<code>onMeasure</code>和<code>onLayout</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView = <span class="keyword">new</span> TextView(getContext(), attrs);</span><br><span class="line">    <span class="comment">//TextView如果没有设置LayoutParams，当setText的时候会引发NPE导致崩溃</span></span><br><span class="line">    mTextView.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));</span><br><span class="line">    mTextView.setMaxLines(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">//宽度不设限制</span></span><br><span class="line">    mTextView.measure(MeasureSpec.UNSPECIFIED, heightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="comment">//保证布局包含完整的Text内容</span></span><br><span class="line">    mTextView.layout(left, top, left + mTextView.getMeasuredWidth(), bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做是为了利用这个内部<code>TextView</code>生成我们需要的<code>Bitmap</code>，同时借用<code>TextView</code>写好的<code>onMeasure</code>方法，这样我们就不用再那么复杂的重写<code>onMeasure</code>方法了</p>
<p>接下来是生成<code>Bitmap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBitmap = Bitmap.createBitmap(mTextView.getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(mBitmap);</span><br><span class="line">    mTextView.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单，需要注意的是长度要使用内部持有的<code>TextView</code>的<code>getMeasuredWidth</code>，如果使用<code>getWidth</code>的话，最大值为屏幕的宽度，很可能导致生成出的<code>Bitmap</code>不全，高度用谁的倒是无所谓</p>
<p>在每次<code>setText</code>或<code>setTextSize</code>的时候都需要更新<code>Bitmap</code>并重新布局绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView.addOnLayoutChangeListener(<span class="keyword">new</span> OnLayoutChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChange</span><span class="params">(View v, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">int</span> oldLeft, <span class="keyword">int</span> oldTop, <span class="keyword">int</span> oldRight, <span class="keyword">int</span> oldBottom)</span> </span>&#123;</span><br><span class="line">            updateBitmap();</span><br><span class="line">            restartScroll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setText(text, type);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有text参数会先调用setText，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextView.setText(text);</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSize</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setTextSize(unit, size);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有textSize参数会先调用setTextSize，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTextView.setTextSize(size);</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我给这个<code>MarqueeTextView</code>定义了一些参数，一个是<code>space</code>（文字滚动时，头尾的最小间隔距离），另一个是<code>speed</code>（文字滚动的速度）</p>
<p>先看一下<code>onDraw</code>的实现吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当文字内容不超过一行</span></span><br><span class="line">        <span class="keyword">if</span> (mTextView.getMeasuredWidth() &lt;= getWidth()) &#123;</span><br><span class="line">            <span class="comment">//计算头尾需要间隔的宽度</span></span><br><span class="line">            <span class="keyword">int</span> space = mSpace - (getWidth() - mTextView.getMeasuredWidth());</span><br><span class="line">            <span class="keyword">if</span> (space &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                space = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了显示宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -getWidth() - space) &#123;</span><br><span class="line">                mLeftX += getWidth() + space;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为最右边的坐标-左边bitmap已消失的宽度+间隔宽度</span></span><br><span class="line">                canvas.drawBitmap(mBitmap, getWidth() + mLeftX + space, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当文字内容超过一行</span></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了内容宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -mTextView.getMeasuredWidth() - mSpace) &#123;</span><br><span class="line">                mLeftX += mTextView.getMeasuredWidth() + mSpace;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="comment">//当尾部已经显示出来的时候</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX + (mTextView.getMeasuredWidth() - getWidth()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为尾部的坐标+间隔宽度</span></span><br><span class="line">                canvas.drawBitmap(mBitmap, mTextView.getMeasuredWidth() + mLeftX + mSpace, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是基本的绘制思路</p>
<p>接下来需要让他动起来，这里使用的<code>Choreographer</code>，每次收到<code>Vsync</code>信号系统绘制新帧时都更新一下坐标并重绘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> BASE_FPS = <span class="number">60f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mFps = BASE_FPS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前屏幕刷新率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateFps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.R) &#123;</span><br><span class="line">        mFps = context.getDisplay().getRefreshRate();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WindowManager windowManager =</span><br><span class="line">                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        mFps = windowManager.getDefaultDisplay().getRefreshRate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Choreographer.FrameCallback frameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="comment">//保证在不同刷新率的屏幕上，视觉上的速度一致</span></span><br><span class="line">        <span class="keyword">int</span> speed = (<span class="keyword">int</span>) (BASE_FPS / mFps * mSpeed);</span><br><span class="line">        mLeftX -= speed;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Choreographer.getInstance().postFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLeftX = <span class="number">0</span>;</span><br><span class="line">    Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restartScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopScroll();</span><br><span class="line">    startScroll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在<code>View</code>可见性发生变化时，需要控制一下动画的启停</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisibilityChanged</span><span class="params">(@NonNull View changedView, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visibility == VISIBLE) &#123;</span><br><span class="line">        updateFps();</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(frameCallback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Choreographer.getInstance().removeFrameCallback(frameCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/android/common/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">Android开发常见问题总结（持续更新）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="透明与方向"><a href="#透明与方向" class="headerlink" title="透明与方向"></a>透明与方向</h2><p>当且仅当<code>Android 8.0</code>系统中，不能对一个<code>Activity</code>同时设置透明（<code>windowIsTranslucent</code>和<code>windowIsFloating</code>）和方向（<code>screenOrientation</code>），否则会抛出<code>Only fullscreen opaque activities can request orientation</code>异常崩溃</p>
<p>解决方法：</p>
<p>在代码中先判断系统版本，再设置方向</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT != Build.VERSION_CODES.O) &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="meta-string">"SourceLockedOrientationActivity"</span>)</span></span><br><span class="line">        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><ol>
<li>滑动嵌套</li>
</ol>
<p>滑动组件的嵌套可能会产生以下一些问题：</p>
<ul>
<li>滑动冲突</li>
</ul>
<p>解决方法：使用<code>NestedScrollView</code>替代<code>ScrollView</code>，<code>RecyclerView</code>可以设置属性<code>android:nestedScrollingEnabled=&quot;false&quot;</code>或代码里<code>setNestedScrollingEnabled(false);</code>来禁用组件自身的滑动</p>
<p>注意：如果<code>RecyclerView</code>只能显示一个Item的话，需要设置<code>NestedScrollView</code>的属性<code>android:fillViewport=&quot;true&quot;</code></p>
<ul>
<li>滑动失效</li>
</ul>
<p><code>ScrollView</code>设置<code>fillViewport=&quot;true&quot;</code>的情况下，如果对<code>ScrollView</code>的直接子view设置上下margin，在超出内容的高度小于设置的margin的情况下，可能会导致整个<code>ScrollView</code>滑动失效</p>
<ol start="2">
<li>焦点抢占</li>
</ol>
<p><code>ScrollView</code>、<code>RecyclerView</code>等滑动组件可能会抢占焦点，导致界面显示时直接滑动到对应组件的位置，而不是顶部</p>
<p>解决方法：在顶部View(或者其他你所期望的初始位置)加上属性<code>android:focusable=&quot;true&quot;</code>和<code>android:focusableInTouchMode=&quot;true&quot;</code></p>
<p>新解决方法：在顶部View上加<code>android:descendantFocusability</code>属性，该属性是用来定义父布局与子布局之间的关系的，它有三种值：</p>
<ul>
<li><code>beforeDescendants</code>：父布局会优先其子类控件而获取到焦点</li>
<li><code>afterDescendants</code>：父布局只有当其子类控件不需要获取焦点时才获取焦点</li>
<li><code>blocksDescendants</code>：父布局会覆盖子类控件而直接获得焦点</li>
</ul>
<p>使用<code>blocksDescendants</code>覆盖子布局焦点以解决焦点抢占问题</p>
<hr>
<h1 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h1><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><ol>
<li>在<code>onBindViewHolder</code>中设置子View回调时需要注意</li>
</ol>
<p>如果回调的参数包括position时，需要注意有没有地方会调用<code>notifyItemRemoved</code>或<code>notifyItemRangeRemoved</code>，如果有，需要使用<code>holder.getAdapterPosition()</code>来代替<code>onBindViewHolder</code>方法的position参数</p>
<p>原因：<code>notifyItemRemoved</code>不会对其他的Item重新调用<code>onBindViewHolder</code>，这样可能会导致position错位。<code>holder.getAdapterPosition()</code>方法会返回数据在 Adapter 中的位置（即使位置的变化还未刷新到布局中）</p>
<ol start="2">
<li>如何在更新数据后重新定位到顶部</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写父类方法，获得绑定的RecyclerView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(@NonNull RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">	mRecyclerView = recyclerView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数据更新后调用</span></span><br><span class="line"><span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span> &amp;&amp; mRecyclerView.getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	mRecyclerView.scrollToPosition(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前尝试过<code>mRecyclerView.scrollTo(0, 0);</code>但没有起效，不清楚为什么</p>
<ol start="3">
<li>动态部分更新数据时</li>
</ol>
<p>如果<code>RecyclerView</code>需要动态更新<strong>部分</strong>数据，并且在<code>onBindViewHolder</code>时对某些view设置了事件或者回调等，如果此时使用到了position参数需要注意，如果你只notify了部分数据更新，可能会导致更新后部分ViewHolder中的回调里的position不正确，建议：</p>
<ul>
<li>使用<code>notifyDataSetChanged()</code></li>
<li>使用<code>notifyItem</code>，但是在<code>onBindViewHolder</code>中设置回调时不要使用position参数，而是使用<code>holder.getAdapterPosition()</code>替代（注意这个方法在<code>ViewHolder</code>没有和<code>RecyclerView</code>绑定时会返回-1 <code>NO_POSITION</code>）</li>
</ul>
<h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h2><ol>
<li><code>StaggeredGridLayoutManager</code>下<code>ItemDecoration</code>的<code>offset</code>计算错误</li>
</ol>
<p>主要是因为<code>RecyclerView</code>动态更新数据时，会执行多次<code>measure</code>，但只会在第一次<code>measure</code>的时候调用<code>ItemDecoration.getItemOffsets</code>（因为<code>LP</code>里的<code>mInsetsDirty</code>变量），此时获得的<code>spanIndex</code>是一个错误值</p>
<p>这个问题的具体分析可以看<a href="https://blog.kyleduo.com/2017/07/27/recyclerview-wrong-decoration-inset/" target="_blank" rel="noopener">这篇文章</a>，暂时没有什么好的解决方案，不建议大家使用反射，毕竟你不知道<code>Android</code>会不会更改这个变量</p>
<h2 id="嵌套ViewPager"><a href="#嵌套ViewPager" class="headerlink" title="嵌套ViewPager"></a>嵌套ViewPager</h2><p>在<code>RecyclerView</code>中嵌套<code>ViewPager</code>的情况下，当你将一个<code>ViewPager</code>滑动出视野再滑回来，这个<code>ViewPager</code>的下一个切换会没有动画</p>
<p>原因：当<code>RecyclerView</code>的<code>Item</code>滑入滑出屏幕时分别会调用子<code>View</code>的<code>onAttachedToWindow</code>和<code>onDetachedFromWindow</code>方法，当<code>ViewPager</code>触发<code>onAttachedToWindow</code>后，会将其里面的一个表示是否为第一次布局的成员变量<code>mFirstLayout</code>赋值为<code>true</code>，当这个变量为<code>true</code>时，<code>ViewPager</code>会以无动画的方式显示当前<code>Item</code></p>
<p>解决方法：重写<code>RecyclerView.Adapter</code>的<code>onViewAttachedToWindow</code>方法，在里面对<code>ViewPager</code>调用其<code>requestLayout</code>方法，在<code>ViewPager.onLayout</code>方法最后，会将<code>mFirstLayout</code>变量重新赋值为<code>false</code></p>
<hr>
<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><h2 id="RenderScript高斯模糊"><a href="#RenderScript高斯模糊" class="headerlink" title="RenderScript高斯模糊"></a>RenderScript高斯模糊</h2><p>在使用<code>RenderScript</code>做高斯模糊时，需要注意，它只支持格式为<code>ALPHA_8</code>、<code>ARGB_4444</code>、<code>ARGB_8888</code>、<code>RGB_565</code>的<code>Bitmap</code>，对于其他格式的<code>Bitmap</code>，可以尝试使用<code>Bitmap.reconfigure</code>方法转换格式（这个方法不能将<code>Bitmap</code>从小格式转换成大格式，比如不能从占用32个bits的<code>ARGB_8888</code>转换成占用64个bits的<code>RGBA_F16</code>）</p>
<hr>
<h1 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h1><ol>
<li>生命周期</li>
</ol>
<ul>
<li>初始化时需要注意</li>
</ul>
<p>Dialog在第一次调用<code>show()</code>方法后才会执行<code>onCreate(Bundle savedInstanceState)</code>方法，因此建议自定义Dialog时将<code>findViewById</code>等初始化操作放在构造函数中进行，避免外部使用时因在<code>show()</code>之前设置视图数据导致NPE</p>
<hr>
<h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><ol>
<li>点击没反应</li>
</ol>
<p><code>PopupWindow</code>如果不设置背景的话，在某些5.x以下系统机型上会出现点击没反应的问题</p>
<p>解决方法：给PopupWindow设置一个空背景<code>popupWindow.setBackgroundDrawable(new BitmapDrawable(mContext.getResources(), (Bitmap) null));</code></p>
<p>详见：<a href="https://juejin.cn/post/6844903761488379912" target="_blank" rel="noopener">https://juejin.cn/post/6844903761488379912</a></p>
<hr>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><ol>
<li>隐式广播</li>
</ol>
<p>在Android8.0以上的系统，大部分的隐式广播都被限制不可使用。</p>
<p>解决方法：</p>
<ol>
<li>使用动态广播</li>
<li>使用显示广播<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 设置Component</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(context, SomeReceiver<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 设置Package</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setPackage(<span class="string">"com.dreamgyf.xxx"</span>);</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不知道包名的话可以通过PackageManager获取所有注册了指定action的广播的package</span></span><br><span class="line">Intent actionIntent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">List&lt;ResolveInfo&gt; matches = pm.queryBroadcastReceivers(actionIntent, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : matches) &#123;            </span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(actionIntent);            </span><br><span class="line">    intent.setPackage(resolveInfo.activityInfo.applicationInfo.packageName);            </span><br><span class="line">    intent.setAction(SOME_ACTION);            </span><br><span class="line">    context.sendBroadcast(intent);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="软键盘"><a href="#软键盘" class="headerlink" title="软键盘"></a>软键盘</h1><ol>
<li>弹起软键盘</li>
</ol>
<p>网上大部分文章所写的弹起软键盘的方法并不完美，大部分文章让你在<code>onResume</code>时再弹起，有的文章甚至让你<code>postDelayed</code>，非常不靠谱，经过本人分析，软键盘的弹起需要满足以下几个条件：</p>
<ul>
<li><p>控件为<code>EditText</code>或其子类</p>
</li>
<li><p>控件所在的<code>window</code>要获得焦点</p>
</li>
<li><p>控件本身要获得焦点</p>
</li>
</ul>
<p>根据以上几个条件，我写了一个完美弹起软键盘的方法，<code>onCreate</code>时也可以照常使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showKeyboard</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ims = context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span>? InputMethodManager ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus()) &#123;</span><br><span class="line">        requestFocus()</span><br><span class="line">        ims.showSoftInput(<span class="keyword">this</span>, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewTreeObserver.addOnWindowFocusChangeListener(<span class="keyword">object</span> : OnWindowFocusChangeListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onWindowFocusChanged</span><span class="params">(hasFocus: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">                    viewTreeObserver.removeOnWindowFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                    requestFocus()</span><br><span class="line">                    ims.showSoftInput(<span class="keyword">this</span><span class="symbol">@showKeyboard</span>, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实体键盘"><a href="#实体键盘" class="headerlink" title="实体键盘"></a>实体键盘</h1><ol>
<li><code>EditText</code>有焦点时会拦截键盘的数字键</li>
</ol>
<p>解决方法：使用<code>TextWatcher</code>等监听<code>EditText</code>输入</p>
<hr>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ol>
<li>动画</li>
</ol>
<p>在Activity销毁之前如果没有cancel掉，会导致这个Activity内存泄漏</p>
<ol start="2">
<li><code>ClickableSpan</code></li>
</ol>
<p>使用<code>SpannableString.setSpan</code>方法设置<code>ClickableSpan</code>可能导致内存泄漏</p>
<p>原因：<code>TextView</code>在<code>onSaveInstanceState</code>时会将<code>ClickableSpan</code>复制一份，由于某些原因，<code>SpannableString</code>不会删除这个<code>ClickableSpan</code>，从而导致内存泄漏，详见：<br><a href="https://stackoverflow.com/questions/28539216/android-textview-leaks-with-setmovementmethod" target="_blank" rel="noopener">StackOverflow</a></p>
<p>解决方法：自定义一个抽象类同时继承<code>ClickableSpan</code>和实现<code>NoCopySpan</code>接口，外部<code>setSpan</code>时使用这个抽象类</p>
<hr>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><ol>
<li><code>Fragment</code>尽量不要使用带参构造函数，一定要保证有一个不含参的构造函数，否则在<code>Activity</code>重建时尝试反射<code>newInstance</code>恢复<code>Fragment</code>时会抛出<code>Could not find Fragment constructor</code>异常</li>
</ol>
<hr>
<h1 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h1><ol>
<li>反射</li>
</ol>
<p>如果使用到了反射，需要特别注意需不需要在<code>proguard-rules</code>中加入keep规则</p>
<ol start="2">
<li>module混淆</li>
</ol>
<p>如果是多module项目，想要在module中增加混淆规则，<code>proguardFiles</code>属性是无效的，应该使用<code>consumerProguardFiles</code>属性</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        versionName repo.version</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">        consumerProguardFiles <span class="string">'proguard-rules.pro'</span> <span class="comment">//这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="相机开发"><a href="#相机开发" class="headerlink" title="相机开发"></a>相机开发</h1><ol>
<li>拍照角度</li>
</ol>
<p>相机的方向一般是以手机横向作为正方向，这样如果我们以竖屏的方式拍照，拍出来的照片可能会出现旋转了90度的情况，这时候就需要在拍照完后处理一下图片，旋转到正确位置。</p>
<p>具体介绍与算法在Android SDK中<code>CaptureRequest.JPEG_ORIENTATION</code>的注释中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getJpegOrientation</span><span class="params">(CameraCharacteristics c, <span class="keyword">int</span> deviceOrientation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得相机方向与设备方向间的夹角</span></span><br><span class="line">    <span class="keyword">int</span> sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round device orientation to a multiple of 90</span></span><br><span class="line">    deviceOrientation = (deviceOrientation + <span class="number">45</span>) / <span class="number">90</span> * <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse device orientation for front-facing cameras</span></span><br><span class="line">    <span class="keyword">boolean</span> facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;</span><br><span class="line">    <span class="keyword">if</span> (facingFront) deviceOrientation = -deviceOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate desired JPEG orientation relative to camera orientation to make</span></span><br><span class="line">    <span class="comment">// the image upright relative to the device orientation</span></span><br><span class="line">    <span class="keyword">int</span> jpegOrientation = (sensorOrientation + deviceOrientation + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jpegOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算好角度后就可以对图片做旋转了，网上有很多文章都说使用这种方式做旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>但实际上在某些系统上 (MIUI)，设置的这个参数并不会生效，所以我的方案是，获得拍摄好的照片Bitmap后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/03/01/android/common/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB/">Android对Java的修改-SimpleDateFormat类</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SimpleDateFormat/">SimpleDateFormat</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android会对部分OpenJDK中的代码进行一些修改，本篇记录一下因为这些修改而踩过的一些坑。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>一个在线上运行良好的Date工具类在写单元测试时一直报ParseException，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">utc2Local</span><span class="params">(String utcTime)</span> </span>&#123;</span><br><span class="line">    String utcTimePatten = <span class="string">"yyyy-MM-dd'T'HH:mm:ssZZZZZ"</span>;</span><br><span class="line">    String localTimePatten = <span class="string">"yyyy.MM.dd"</span>;</span><br><span class="line">    SimpleDateFormat utcFormater = <span class="keyword">new</span> SimpleDateFormat(utcTimePatten);</span><br><span class="line">    utcFormater.setTimeZone(TimeZone.getTimeZone(<span class="string">"UTC"</span>));<span class="comment">//时区定义并进行时间获取</span></span><br><span class="line">    Date gpsUTCDate = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        gpsUTCDate = utcFormater.parse(formatTimeStr(utcTime));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> utcTime;</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleDateFormat localFormater = <span class="keyword">new</span> SimpleDateFormat(localTimePatten);</span><br><span class="line">    localFormater.setTimeZone(TimeZone.getDefault());</span><br><span class="line">    String localTime = localFormater.format(gpsUTCDate.getTime());</span><br><span class="line">    <span class="keyword">return</span> localTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的参数utcTime为”2020-01-01 08:00:00+08:00”</p>
<p>这段代码在Android环境下运行良好，但在单元测试下一直报错</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Android对OpenJDK中的<code>SimpleDateFormat</code>进行了修改，具体在<code>subParseNumericZone</code>方法中：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E5%AF%B9Java%E7%9A%84%E4%BF%AE%E6%94%B9-SimpleDateFormat%E7%B1%BB.png" alt=""></p>
<p>可以看到，OpenJDK原本是不支持带冒号的写法的，而在Android中修改了<code>subParseNumericZone</code>方法，使其可以解析带冒号的写法。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>解决方法也很简单，在测试时直接修改入参，去掉入参中的冒号就好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (MockedStatic&lt;DateUtils&gt; mockedDateUtils = Mockito.mockStatic(DateUtils<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">CallsRealMethods</span>())) </span>&#123;</span><br><span class="line">    mockedDateUtils.when(() -&gt; &#123;</span><br><span class="line">       	DateUtils.utc2Local(argThat((argument) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> index = argument.length() - <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> argument.charAt(index) == <span class="string">':'</span>;</span><br><span class="line">        ));</span><br><span class="line">    &#125;).then((invocation) -&gt; &#123;</span><br><span class="line">        String utcTime = invocation.getArgument(<span class="number">0</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String fixedDate = formatDate;</span><br><span class="line">        <span class="keyword">int</span> index = formatDate.length() - <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (formatDate.charAt(index) == <span class="string">':'</span>) &#123;</span><br><span class="line">            fixedDate = formatDate.substring(<span class="number">0</span>, index) + formatDate.substring(index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DateUtils.utc2Local(fixedDate);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/02/24/android/unit-test/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0/">Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-24</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>随着Kotlin语言在Android开发中越来越流行，自然也会遇到各种各样的问题。</p>
<p>本篇主要是针对我个人在Android单元测试Kotlin类时遇到的一些问题的思考和解决方案。</p>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>我们都知道Kotlin给开发者提供了很多语法糖，其中之一就是<strong>顶层函数</strong>，我们可以直接把函数放在代码文件的顶层，让它不从属于任何类。</p>
<p>它的使用很简单，直接在kotlin代码的任意位置直接当作一个普通函数调用就行了，而在java中，需要像使用静态方法一样，以<strong>文件名+Kt</strong>为类名调用 (默认配置)</p>
<p>在java单元测试中，如果想mock这个顶层函数，只需要像对待一个静态方法一样，使用mockStatic方法即可</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E6%AD%A3%E5%B8%B8mock.png" alt=""></p>
<p>而在kotlin单元测试中，我们却无法找到这个class</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E9%94%99%E8%AF%AFmock.png" alt=""></p>
<h1 id="确定路线"><a href="#确定路线" class="headerlink" title="确定路线"></a>确定路线</h1><p>我们先建立一个文件来写一个顶层函数，再建立一个单元测试类去测试它: </p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E5%BB%BA%E7%AB%8B%E6%B5%8B%E8%AF%95%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>其实从上文中已经可以看出，kotlin的顶层函数在编译之后实际上就变成了一个被class包起来的static方法。对此，我们可以简单验证一下:</p>
<p>在Android Studio中点击菜单中的Tools-&gt;Kotlin-&gt;Show Kotlin ByteCode，会弹出对应类的字节码，再点击Decompile按钮，我们会看到确实被编译成了一个类中的静态方法</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E5%8F%8D%E7%BC%96%E8%AF%91%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>确定了这一点后，我们只需要在kotlin中拿到这个顶层函数的所属类，就可以像java里一样使用mockStatic来模拟了。</p>
<h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>既然涉及到了运行时类型分析，自然而然就想到了<strong>反射</strong>，我们先引入kotlin的反射库</p>
<p><code>implementation &quot;org.jetbrains.kotlin:kotlin-reflect:$kotlin_version&quot;</code></p>
<p>其实我对kotlin的反射并不熟悉，去文档里查阅了一下发现了<code>::sampleTopFun</code>这种写法，它的返回值为一个叫<code>KFunction</code>的接口类，我们先看看它有哪些方法可以供我们调用</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E7%9A%84%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>从字面上看好像没有什么方法和我们的需求有关，怎么办呢？那我们再看一下它的实现类吧，说不定会有一些私有变量保存了我们需要的信息。</p>
<p>那么怎么找到它的实现类呢？直接分析源码错综复杂的关系是很耗时且低效的，这里我采取了了一种取巧的方法，利用Android Studio的Debug功能:</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt=""></p>
<p>和预料的不同，为什么这里拿到的类型是这么个奇葩玩意儿呢？我们看一下这个文件的字节码</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AD%97%E8%8A%82%E7%A0%81.png" alt=""></p>
<p>再往下看</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E5%AD%97%E8%8A%82%E7%A0%812.png" alt=""></p>
<p>我们发现，这个奇葩的类型是在kotlin编译后自动生成的，它继承自<code>FunctionReference</code>，同时，在Debugger里，我们获得了一个重要的信息: <code>KFunctionImpl</code></p>
<p>根据名字猜测，它应该才是<code>KFunction</code>真正功能实现的地方，我们将它的信息展开</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_kFunction%E7%9C%9F%E6%AD%A3%E5%AE%9E%E7%8E%B0.png" alt=""></p>
<p>可以发现，我们已经找到我们想要的那个类了，只要拿到它，后续的mock工作就很简单了~</p>
<h1 id="开始Mock"><a href="#开始Mock" class="headerlink" title="开始Mock"></a>开始Mock</h1><p>根据上文，我们已经得知了我们需要获取的<code>jClass</code>的路径</p>
<p>我们先从<code>FunctionReference</code>去获取被<code>reflected</code>引用的<code>KFunctionImpl</code>，这个<code>reflected</code>实际是被<code>FunctionReference</code>继承的<code>CallableReference</code>中的一个变量，在<code>FunctionReference</code>提供了一个<code>getReflected</code>方法，我们通过反射调用这个方法即可得到这个对象，当然，我们也可以通过反射Field获得它，但注意到<code>getReflected</code>方法处理了一些空对象的情况，为了保险起见，我们还是采取反射调用<code>getReflected</code>的方法获取<code>KFunctionImpl</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction2.png" alt=""></p>
<p>反射调用<code>getReflected</code>方法获取<code>KFunctionImpl</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96kFunction3.png" alt=""></p>
<p>第一步没问题，接下来开始反射获取<code>container</code></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96container.png" alt=""></p>
<p>第二步也没什么问题，接下来就是反射获取<code>jClass</code>了</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_%E8%8E%B7%E5%8F%96jclass.png" alt=""></p>
<p>ok，一切正常，接下来和java一样，让我们试试用这个我们获取到的类mockStatic吧</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android-Kotlin%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88Mockito%E6%A8%A1%E6%8B%9F%E9%A1%B6%E5%B1%82%E5%87%BD%E6%95%B0_mockStatic.png" alt=""></p>
<p>可以看到，测试成功通过，至此，我们成功解决了Mockito模拟顶层函数的问题。为了方便使用，可以将以上代码封装成一个函数，这里就不再赘述了。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/31/common/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%AC%94%E8%AE%B0/">汇编指令笔记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></span><div class="content"><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h2 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h2><p>AX: AH-AL (数据累加器, 可用于乘、 除、输入/输出等操作)</p>
<p>BX: BH-BL (基址寄存器, 可作为存储器指针来使用)</p>
<p>CX: CH-CL (计数寄存器, 可用来控制循环次数)</p>
<p>DX: DH-DL (数据寄存器, 在进行乘、除运算时，它可作为默认的操作数参与运算，也可用于存放I/O的端口地址)</p>
<h2 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h2><blockquote>
<p>主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。它们可作一般的存储器指针使用。</p>
</blockquote>
<p>ESI: 32bit == SI: 16bit (源变址寄存器, 与DS联用, 指示数据段中某操作的偏移量. 在做串处理时, SI指示源操作数地址, 并有自动增量或自动减量的功能。 变址寻址时, SI与某一位移量共同构成操作数的偏移量)</p>
<p>EDI: 32bit == DI: 16bit (与DS联用, 指示数据段中某操作数的偏移量, 或与某一位移量共同构成操作数的偏移量. 串处理操作时, DI指示附加段中目的地址, 并有自动增量或减量的功能)</p>
<h2 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h2><blockquote>
<p>主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便， 也可存储算术逻辑运算的操作数和运算结果。</p>
</blockquote>
<p>EBP: 32bit == BP: 16bit (基指针寄存器, 用它可直接存取堆栈中的数据)</p>
<p>ESP: 32bit == SP: 16bit (堆栈指针寄存器, 始终只是栈顶的位置, 与SS寄存器一起组成栈顶数据的物理地址)</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成<br>的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。</p>
</blockquote>
<ul>
<li><p>16位</p>
<p>  CS——代码段寄存器，存放当前程序的指令代码</p>
<p>  DS——数据段寄存器，存放程序所涉及的源数据或结果</p>
<p>  ES——附加段寄存器，辅助数据区, 存放串或其他数据</p>
<p>  SS——堆栈段寄存器，其值为堆栈段的段值</p>
</li>
<li><p>32位</p>
<p>  FS——附加段寄存器，其值为附加数据段的段值</p>
<p>  GS——附加段寄存器，其值为附加数据段的段值</p>
</li>
</ul>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="cmp-配合jz-jnz"><a href="#cmp-配合jz-jnz" class="headerlink" title="cmp (配合jz, jnz)"></a>cmp (配合jz, jnz)</h2><p>算数运算指令，比较两个值，如果相等则设置ZF(零标志)为1, 可用jz(jump if zero)或jnz(jump if not zero)指令检查ZF位, jz(ZF零标志为1)即相等, jnz(ZF零标志为1)即不相等</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"></span><br><span class="line"><span class="symbol">compare:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>x1000, %ax</span><br><span class="line">	<span class="keyword">cmp</span> <span class="number">$0</span>x1000, %ax    <span class="comment">;判断ax寄存器中的值是否为0x1000</span></span><br><span class="line">    <span class="keyword">jz</span> is_equal         <span class="comment">;如果相等，则跳转到代码段is_equal</span></span><br><span class="line">    <span class="keyword">jnz</span> is_not_equal    <span class="comment">;如果不相等，则跳转到代码段is_not_equal</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">is_equal:</span></span><br><span class="line">    <span class="comment">;do something</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">is_not_equal:</span></span><br><span class="line">    <span class="comment">;do something</span></span><br></pre></td></tr></table></figure>

<h2 id="rep"><a href="#rep" class="headerlink" title="rep"></a>rep</h2><p>重复执行后面的指令，直到cx寄存器中的值为0</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例:</span><br><span class="line"><span class="symbol">example:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>, %ax         //将<span class="built_in">ax</span>寄存器置<span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="number">$0</span>x1000, %cx</span><br><span class="line">    <span class="keyword">rep</span> <span class="keyword">add</span> <span class="number">$1</span>, %ax     //使<span class="built_in">ax</span>寄存器加<span class="number">1</span>，执行<span class="number">1000</span>次</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/10/19/android/view/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/">自定义EditView时踩过的坑</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/EditView/">EditView</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这次的需求是一个单词拼写的输入框，要求每个字母分割开来输入，每个字母下面有一个下划线，就类似于验证码输入或者支付密码输入的效果</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/%E8%87%AA%E5%AE%9A%E4%B9%89EditView%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91_%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图" title="效果图"></p>
<p>最终成品是一个自定义View，实现参考了<a href="https://github.com/JingYeoh/VercodeEditText" target="_blank" rel="noopener">VercodeEditText</a></p>
<hr>
<h1 id="EditView还是TextView？"><a href="#EditView还是TextView？" class="headerlink" title="EditView还是TextView？"></a>EditView还是TextView？</h1><p>刚开始的时候，我选择了继承<code>AppCompatEditText</code>，但在我试着draw on canvas的时候，奇怪的发现绘制的东西并没有在界面上显示，然后我尝试将视图的高度调大，当到达了一个临界点后，内容突然显示出来了。</p>
<p>为了得知这个问题的成因，我试着画一个占满整个画布的矩形，打开开发者选项里的显示布局边界后发现，这个矩形并没有占满整个布局。一开始猜想可能是因为画布的高度小于视图的高度，于是打开debug调试断点发现，两者是一致的；然后猜测是不是画布因为什么原因产生了偏移？但怎么尝试都没有得到确定性的结论，直到某次我打开了EditText的背景，并随便滑动了几下发现，在向下滑动的时候，原本绘制的内容便从视图最上方滚动了下来。原来是因为当EditText高度小于1行时，EditText会自动适配并滚动到最下方。</p>
<p>既然知道了问题的成因，那就开始着手解决他，最直接的办法就是禁止EditText的滚动。为此，我尝试了<code>setMinHeight()</code>，<code>setMinLines()</code>都没有用。然后我退而求其次，尝试使用<code>scrollTo(0, 0)</code>，将视图固定滑动到最顶部，发现效果并不是很理想。然后在查资料的过程中我发现了<code>MovementMethod</code>这么一个东西。</p>
<p>网上关于<code>MovementMethod</code>的资料比较少，我查询了一下Google的官方文档里面介绍：</p>
<blockquote>
<p>Provides cursor positioning, scrolling and text selection functionality in a TextView.<br>即：在 TextView提供了光标定位，滚动和文本选择功能。</p>
</blockquote>
<p>找到了产生滚动的元凶，那问题就好办了，在源码里可以看到，EditText的<code>getDefaultMovementMethod()</code>返回了一个<code>ArrowKeyMovementMethod</code>，我们直接<code>setMovementMethod(null)</code>或者重写父类的<code>getDefaultMovementMethod()</code>使其返回值为null，滚动的问题便解决了。</p>
<p>解决完这一步后，又发现了一个新问题，EditText的上下左右有一定的padding，点击到这部分padding的区域是不会触发EditText的获取焦点弹出输入法的，当然也可以直接重写<code>onTouchEvent</code>方法加上<code>requestFocus()</code>方法解决，但考虑到继承EditText要重设背景，又要setMovementMethod，还要处理边缘点击事件，感觉太麻烦，不如直接继承TextView，处理的事情会稍微少一些。</p>
<p>于是我选择继承<code>AppCompatTextView</code>，重写<code>getDefaultEditable()</code>使其返回true以打开编辑功能，<code>setFocusableInTouchMode(true)</code>使其能获取焦点，重写<code>onTouchEvent</code>方法加上<code>requestFocus()</code>方法使其点击能够直接获取焦点，<code>setCursorVisible(false)</code>隐藏光标，<code>setLongClickable(false)</code>禁止长按弹出编辑菜单，到这一步，基本难点已经解决了。</p>
<hr>
<h1 id="onTextChanged多次调用？"><a href="#onTextChanged多次调用？" class="headerlink" title="onTextChanged多次调用？"></a>onTextChanged多次调用？</h1><p>为了监听文本改变的事件，我一开始选择了自定义View直接implements TextWatcher，然后<code>addTextChangedListener(this)</code>，这样在断点调试的时候发现，<code>onTextChanged()</code>方法被执行了多次，但<code>beforeTextChanged()</code>和<code>afterTextChanged()</code>执行次数却是正常的。原来，在TextView内部已经有了一个可重写的<code>onTextChanged()</code>方法，和TextWatcher里的<code>onTextChanged()</code>一模一样，当<code>addTextChangedListener(this)</code>后，TextView会先执行TextWatcher的<code>onTextChanged()</code>，再执行自己内部的<code>onTextChanged()</code>。解决方法很简单，将implements TextWatcher去掉，改为addTextChangedListener一个匿名内部类就好了。</p>
<hr>
<h1 id="长度超过限制了怎么办？"><a href="#长度超过限制了怎么办？" class="headerlink" title="长度超过限制了怎么办？"></a>长度超过限制了怎么办？</h1><p>刚开始，我在<code>onTextChanged()</code>里增加了对Text长度的判断，如果长度超长，就把原Text截断到最大长度，然后重新setText进去。这样做有一个问题，这样并不能保证<code>afterTextChanged()</code>回调里的Text参数长度合法。当这么做后，TextView首先会触发截断Text的<code>afterTextChanged()</code>，然后再触发超长Text的<code>afterTextChanged()</code>。后来在搜索资料的时候发现，TextView内部持有了一个<code>InputFilter</code>数组，这个接口可以很好的帮助我们在触发回调之前对输入的字符串进行过滤操作。</p>
<ul>
<li>InputFilter接口方法</li>
</ul>
<blockquote>
<p>public CharSequence filter(CharSequence source, int start, int end,Spanned dest, int dstart, int dend);</p>
</blockquote>
<p>其中，InputFilter已经内置实现了长度过滤功能，只需要在设置新answer的时候，重新<code>setFilters()</code>就行了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputFilter[] filters = <span class="keyword">new</span> InputFilter[]&#123;</span><br><span class="line">		<span class="keyword">new</span> InputFilter.LengthFilter(answer.length())</span><br><span class="line">&#125;;</span><br><span class="line">setFilters(filters);</span><br></pre></td></tr></table></figure>

<h1 id="具体的绘制实现？"><a href="#具体的绘制实现？" class="headerlink" title="具体的绘制实现？"></a>具体的绘制实现？</h1><h2 id="计算预留位置"><a href="#计算预留位置" class="headerlink" title="计算预留位置"></a>计算预留位置</h2><p>我定义了一个变量<code>String ALL_CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</code>用来计算用户输入的预留宽高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> width = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">	Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ALL_CHARS.length(); i++) &#123;</span><br><span class="line">		mTextPaint.getTextBounds(ALL_CHARS, i, i + <span class="number">1</span>, rect);</span><br><span class="line">		width = Math.max(width, rect.width());</span><br><span class="line">		height = Math.max(height, rect.height());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mCharWidth = width;</span><br><span class="line">	mCharHeight = height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onMeasure()里计算好布局宽高后，根据宽高和间隔距离平均分配一下每个字母的坐标。</p>
<h2 id="自适应宽度"><a href="#自适应宽度" class="headerlink" title="自适应宽度"></a>自适应宽度</h2><p>这次的需求还要求当布局的宽度超过父布局时，自动缩小字体大小以适应父布局宽度。这个其实也很简单，计算一下绘制需要的宽度，如果超过父布局宽度，就减小字号，循环一下即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (answerWidth &gt; width - getPaddingLeft() - getPaddingRight()) &#123;</span><br><span class="line">	mTextPaint.setTextSize(--mTextSize);</span><br><span class="line">	measureChar();</span><br><span class="line">	answerWidth = mCharWidth * getLength() + mSpacingPx * (getLength() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户输入文字的绘制"><a href="#用户输入文字的绘制" class="headerlink" title="用户输入文字的绘制"></a>用户输入文字的绘制</h2><p>由于每个字母的宽高可能不同，所以不能直接使用之前计算好的坐标绘制，需要使用之前测量好的预留的宽度减去用户实际输入字母的宽度除以2，然后加上这个预留位置的起始坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">computeCharX</span><span class="params">(CharCoordinate coordinate, <span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">	mTextPaint.getTextBounds(String.valueOf(letter), <span class="number">0</span>, <span class="number">1</span>, mTempRect);</span><br><span class="line">	<span class="keyword">int</span> realCharWidth = mTempRect.width();</span><br><span class="line">	<span class="keyword">return</span> coordinate.start + (<span class="keyword">float</span>) (mCharWidth - realCharWidth) / <span class="number">2</span> - mTempRect.left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里减去mTempRect.left是因为绘制出来的字符有些向右偏离</p>
</blockquote>
<h2 id="绘制光标"><a href="#绘制光标" class="headerlink" title="绘制光标"></a>绘制光标</h2><p>TextView原本的光标不符合我们的需求，我们需要绘制一下自定义的光标。</p>
<p>先定义一下光标闪烁时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_CURSOR_DURATION = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCursorDuration = DEFAULT_CURSOR_DURATION;</span><br></pre></td></tr></table></figure>

<p>再定义一个Handler和Runnable用来间隔执行任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable mCursorRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mNeedCursorShow) &#123;</span><br><span class="line">			mIsCursorShowing = !mIsCursorShowing;</span><br><span class="line">			invalidate();</span><br><span class="line">		&#125;</span><br><span class="line">		mHandler.postDelayed(mCursorRunnable, mCursorDuration);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样通过设置一个bool值和定时任务每隔一段时间刷新一下视图就可以轻松实现光标的闪烁。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/08/01/common/Git%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/">Git命令简介</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/git/">git</a></span><div class="content"><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 'dreamgyf' //设置用户名</span><br><span class="line">git config --global user.email g2409197994@gmail.com //设置邮箱</span><br></pre></td></tr></table></figure>



<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git init //在当前目录创建版本库</span><br><span class="line">git add README.md //将文件添加到暂存区</span><br><span class="line">git commit //提交暂存区中的修改 -m"xxx":本次提交的说明 -a:相当多加了一步于git add .</span><br><span class="line">git branch 分支名 //创建分支，不加分支名可以查看所有分支 -d:删除指定分支</span><br><span class="line">git checkout 分支名 //切换分支 -b:创建并切换分支，相当于多加了一步git branch 分支名</span><br><span class="line">git remote add https://github.com/xxx/xxx.git //添加远程仓库，一般支持https和ssh两种协议</span><br><span class="line">git fetch //将远程主机的更新全部取回本地，后面加分支名的话只会取回指定分支</span><br><span class="line">git merge 分支名 //将选中分支合并到当前分支</span><br><span class="line">git pull 分支名 //相当于git fetch 分支名 + git merge 分支名</span><br><span class="line">git push //将当前本地分支推送至远程分支，如果是第一次推送则需要-u参数指定远程分支并建立联系，如git push -u origin master，下一次便可不加参数直接推送 -f:强制推送，会覆盖远程分支</span><br></pre></td></tr></table></figure>

<h1 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h1><ul>
<li><p>合并commit记录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  [startpoint]  [endpoint]</span><br></pre></td></tr></table></figure>

<p>其中<code>-i</code>的意思是<code>--interactive</code>，即弹出交互式的界面让用户编辑完成合并操作，<code>[startpoint] [endpoint]</code>则指定了一个编辑区间，如果不指定<code>[endpoint]</code>，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。</p>
<p>命令可以按如下方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i [commit id]</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>

<p>然后会出现一个vi编辑器界面，会提供给我们一个命令列表：</p>
<blockquote>
<p>pick：保留该commit（缩写:p）</p>
<p>reword：保留该commit，但我需要修改该commit的注释（缩写:r）</p>
<p>edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</p>
<p>squash：将该commit和前一个commit合并（缩写:s）</p>
<p>fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</p>
<p>exec：执行shell命令（缩写:x）</p>
<p>drop：丢弃该commit（缩写:d）</p>
</blockquote>
<p>然后我们就可以在里面修改提交了，例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick d2cf1f9 fix: 第一次提交</span><br><span class="line">s 47971f6 第二次提交</span><br><span class="line">s fb28c8d 第三次提交</span><br></pre></td></tr></table></figure>

<p>将第二、三次的commit合并到第一次上</p>
<p>编辑完保存退出vi就可以完成对commit的合并了</p>
<p>如果保存时出现错误，输入<code>git rebase --edit-todo</code>便会回到编辑模式里，修改完后保存，<code>git rebase --continue</code></p>
<p><a href="https://juejin.im/entry/6844903600976576519" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p>合并分支</p>
<p><code>rebase</code>和<code>merge</code>都是合并分支的操作</p>
<p><code>merge</code>会在合并分支时产生一个新的commit记录，而<code>rebase</code>会以指定分支作为基础分支，之前所做的改动全部会在指定分支的基础上提交，不会产生新的commit记录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p>分析一下上面命令进行的操作：</p>
<p>首先，切换到<code>dev</code>分支上；</p>
<p>然后，<code>git</code> 会把 <code>dev</code> 分支里面的每个 <code>commit</code> 取消掉；</p>
<p>其次，把之前的<code>commit</code>临时保存成 <code>patch</code> 文件，存在 <code>.git/rebase</code> 目录下；</p>
<p>然后，把<code>dev</code>分支更新到最新的 <code>master</code> 分支；</p>
<p>最后，把上面保存的 <code>patch</code> 文件应用到 <code>dev</code> 分支上；</p>
<ul>
<li>使用场景<ol>
<li>想要干净简洁的分支树</li>
<li>在一个过时的分支上面开发的时候，执行 <code>rebase</code> 以同步 <code>master</code> 分支最新变动</li>
</ol>
</li>
</ul>
<p><strong>注意：当同一个分支有多个人使用的情况下，谨慎使用rebase，因为它改变了历史，可能会出现丢失commit的情况</strong></p>
<p><a href="http://jartto.wang/2018/12/11/git-rebase/" target="_blank" rel="noopener">参考链接</a></p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/06/26/common/Markdown%E8%AF%AD%E6%B3%95/">Markdown语法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Markdown/">Markdown</a></span><div class="content"><p><strong>Markdown</strong>是一种轻量级标记语言，它以<strong>纯文本</strong>形式编写文档，并最终以<strong>HTML格式</strong>发布。</p>
<blockquote>
<p>先推荐一款Markdown编辑器<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>，支持 Windows、OS X 和 Linux，支持即时渲染技术，所见即所得，界面简洁大方，非常好用。</p>
</blockquote>
<p><strong>注：因为本站使用了主题，所以部分Markdown呈现的效果与原来不同</strong></p>
<hr>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>文字前加几个<strong>#</strong>即为几级标题</p>
<p>注：<strong>#</strong>与文字之间需要有<strong>空格</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>在文字两侧加上特殊符号</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*倾斜*</span></span><br><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="strong">***倾斜加粗**</span>*</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<p><em>倾斜</em><br><strong>加粗</strong><br><strong><em>倾斜加粗</em></strong><br><del>删除线</del></p>
<hr>
<h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><p>在特殊符号之前加上<strong>\</strong>转义字符</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\\ 反斜杠</span><br><span class="line">\* 星号</span><br><span class="line">\_ 下划线</span><br><span class="line">\&#123;\&#125; \[\] \(\) 括号</span><br><span class="line">\+ 加号</span><br></pre></td></tr></table></figure>

<p>\ 反斜杠<br>* 星号<br>_ 下划线<br>{} [] () 括号<br>+ 加号</p>
<hr>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><p>连续两个以上的空格+回车，或两个以上的回车</p>
<hr>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><p>在一行中用三个以上的<strong>星号、减号、底线</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span>*</span><br><span class="line">---</span><br><span class="line">-----------</span><br><span class="line"><span class="emphasis">___</span></span><br><span class="line"><span class="strong">_____</span><span class="strong">_____</span>_</span><br></pre></td></tr></table></figure>

<p>可在中间插入空格，效果相同</p>
<hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在引用文字前加 <strong>&gt;</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是一行引用文字</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一行引用文字</p>
</blockquote>
<p>引用可以嵌套</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一行引用文字</span><br><span class="line">&gt;&gt; 这是一行引用文字</span><br><span class="line">&gt;&gt;&gt; 这是一行引用文字</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是一行引用文字</p>
<blockquote>
<p>这是一行引用文字</p>
<blockquote>
<p>这是一行引用文字</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>在文字前加入<strong>- + * 任意一个</strong>符号</p>
<p>注：符号与文字之间需要有<strong>空格</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表1</span><br><span class="line"><span class="bullet">+ </span>列表2</span><br><span class="line"><span class="bullet">* </span>列表3</span><br></pre></td></tr></table></figure>

<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>在文字前加入<strong>数字和点</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>列表1</span><br><span class="line"><span class="bullet">2. </span>列表2</span><br><span class="line"><span class="bullet">3. </span>列表3</span><br></pre></td></tr></table></figure>

<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<hr>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>格式 <code>![图片alt](图片地址 &quot;图片title&quot;) Title可选</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Fate</span>](<span class="link">/images/cover.jpg "Fate"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/cover.jpg" alt="Fate" title="Fate"></p>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>Markdown的超链接支持三种写法</p>
<h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><p>格式 <code>[超链接名](超链接地址 &quot;超链接title&quot;) 其中Title可选</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">始终都是梦的Github-1</span>](<span class="link">https://github.com/dreamgyf "始终都是梦的Github"</span>)</span><br><span class="line">超链接名也可以嵌套图片</span><br><span class="line">如 [<span class="string">![始终都是梦的Github-1</span>](<span class="link">/images/avatar.jpeg</span>)](<span class="link">https://github.com/dreamgyf</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/dreamgyf" target="_blank" rel="noopener" title="始终都是梦的Github-1">始终都是梦的Github 1</a></p>
<h2 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h2><p>可以对一个链接进行多次引用</p>
<ol>
<li><p>使用 <code>[超链接名][超链接标记]</code></p>
</li>
<li><p>定义 <code>[超链接标记]:超链接地址 &quot;超链接title&quot; 其中Title可选,可定义在任意位置</code></p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">始终都是梦的Github-2</span>][<span class="symbol">2</span>]</span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">https://github.com/dreamgyf</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/dreamgyf" target="_blank" rel="noopener">始终都是梦的Github-2</a></p>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>将链接直接用<strong>&lt;&gt;</strong>包裹起来</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">github.com</span>/<span class="attr">dreamgyf</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/dreamgyf" target="_blank" rel="noopener">https://github.com/dreamgyf</a></p>
<hr>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><ol>
<li><p>在需要添加注脚的文字后加上<code>[^脚注名]</code></p>
</li>
<li><p>在文本的任意位置(一般在最后)定义脚注 <code>[^脚注名]:脚注内容</code></p>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例文本[^1]</span><br><span class="line">[<span class="symbol">^1</span>]:<span class="link">我是示例文本的脚注</span></span><br></pre></td></tr></table></figure>

<p><font color=gray>由于本站主题原因不做演示</font></p>
<hr>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h2><p>将代码用特殊字符<strong>`</strong>包裹(一般为Esc下面的键)</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf("hello world");`</span></span><br></pre></td></tr></table></figure>

<p><code>printf(&quot;hello world&quot;);</code></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>使用两组三个特殊字符<strong>`</strong>包裹代码块</p>
<p>可以在第一组<strong>```</strong>后添加语言名</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">​<span class="code">```</span>c++</span><br><span class="line"><span class="section">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"><span class="code">	std::cout &gt;&gt; "hello world" &gt;&gt; endl;</span></span><br><span class="line"><span class="code">	return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">​<span class="code">```</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &gt;&gt; <span class="string">"hello world"</span> &gt;&gt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>