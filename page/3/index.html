<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">41</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">44</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/22/interview/B%E7%AB%99Android%E9%9D%A2%E8%AF%95%E5%B0%8F%E8%AE%B0/">B站Android面试小记</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E9%9D%A2%E8%AF%95/">面试</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></span><div class="content"><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>看着我同学最近也在到处投简历，我想着我也投一下看看行情，于是在<strong>2022-02-28</strong>号，我向B站投出了第一封简历，说实话当初只是想练练手，没想到最后接了B站的offer，也是造化弄人了</p>
<h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>技术面，45min左右，基本围绕你简历上写的亮点和你的工作经历展开</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>你在项目中负责什么</p>
</li>
<li><p>用过什么设计模式，或在<code>Android</code>中常常会碰见的设计模式</p>
<p>  单例模式，策略模式，责任链模式（问了一下使用场景），工厂模式等</p>
<p>  <code>Android</code>中的观察者模式，适配器模式等</p>
</li>
<li><p>有没有做过什么比较有难度的模块</p>
<p>  <code>camera2</code>，自定义照片裁剪<code>View</code></p>
</li>
<li><p>你对自定义<code>View</code>有什么了解</p>
<p>  回答了一些<code>Path</code>绘制以及触摸事件的处理</p>
</li>
<li><p><code>Android</code>动画</p>
<p>  属性动画，<code>ObjectAnimator</code></p>
</li>
<li><p>多线程并发（锁、信号量、<code>syncnorized</code>），<code>syncnorized</code>对象和class有什么区别</p>
</li>
<li><p><code>ConcurrentHashMap</code>线程安全的原理</p>
<p>  1.8之前用的分段式锁，1.8之后用的<code>synchronized</code>，至于具体的细节没有答上来，因为确实也没看过这边源码</p>
</li>
<li><p><code>jni</code>，如何定位<code>jni</code>崩溃</p>
<p>  这个我当时回答的是打log，因为项目中用到<code>jni</code>的地方确实不多，当然<code>jni</code>也是可以断点调试的</p>
</li>
<li><p>你所开发的应用有多进程吗？进程间是怎么通信的</p>
<p>  这个我当时只回答了<code>mmap</code>，稍微聊了一下<code>mmap</code>原理和<code>binder</code>性能对比，后来复盘想起来项目中用到的<code>Broadcast</code>和<code>aidl binder</code>通信都没有回答</p>
</li>
<li><p><code>Webview</code>和<code>native</code>怎么交互的</p>
<ul>
<li><p><code>onUrlLoading</code>拦截<code>Schema</code></p>
</li>
<li><p>注册js方法（<code>addJavascriptInterface</code>）</p>
</li>
</ul>
</li>
<li><p><code>Android</code>编译打包过程</p>
<p>  aapt -&gt; class -&gt; dex -&gt; 签名</p>
</li>
<li><p>插桩</p>
<p>  ASM插桩，字节码操作</p>
</li>
<li><p>性能监控</p>
<p>  因为我之前做过一个性能监控库，<code>cpu</code>和<code>mem</code>使用<code>TOP</code>命令解析，<code>Anr</code>通过给<code>MainLooper</code>设置<code>Printer</code></p>
</li>
<li><p><code>LeakCanary</code>原理</p>
<p>  <code>WeakReference</code> + <code>ReferenceQueue</code>，加了一些改进点：<code>new</code>一个弱引用的<code>Object</code>，等这个<code>Object</code>确认被回收后再确认<code>Activity</code>是否正常被回收</p>
</li>
<li><p><code>Jetpack Compose</code></p>
<p>  稍微谈了一下看法，是否在项目中用过</p>
</li>
<li><p>算法题：最长公共前缀</p>
<p>  LeetCode 14题，easy难度：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
</li>
</ul>
<h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>一面结束后5min左右，B站HR就给我打电话过来约了二面</p>
<p>二面也是技术面，20min左右，因为是晚上8点面的，估计人家急着想下班（笑）</p>
<ul>
<li><p>自我介绍</p>
</li>
<li><p>工作职责</p>
</li>
<li><p>工作中有什么亮点</p>
<ul>
<li><p>拍照裁剪业务</p>
</li>
<li><p>单元测试库</p>
</li>
<li><p>性能监控</p>
</li>
<li><p>内存泄漏检测</p>
</li>
</ul>
</li>
<li><p>单元测试的库是怎么做的</p>
<p>  基于<code>Mockito</code>和<code>Robolectric</code>:</p>
<ol>
<li>封装了一个反射库用来方便测试</li>
<li>做了一个<code>AutoCloser</code>类用来自动关闭释放mock的资源，这里提到了使用<code>MockedStatic</code>，如果在使用完后没有释放，那在下一次使用到同一个类的<code>MockedStatic</code>的时候会报错，这里我自定义了一个注解<code>@MockedStatic</code>用来自动mock和释放资源</li>
<li>针对kotlin做了一些mock工具，比如说顶层函数的mock（这个在我以前的文章<a href="https://juejin.cn/post/6932738373522030600" target="_blank" rel="noopener">Android-Kotlin单元测试之 如何配合Mockito模拟顶层函数</a>中介绍过）</li>
</ol>
</li>
<li><p>开发模式（流程规范）：</p>
<p>  开发规范参考了阿里的<code>Java</code>规范和<code>Android</code>规范，选取了一些比较重要的条例和一些自己长时间开发的经验做成了一篇文档</p>
</li>
<li><p>崩溃率的优化，做了哪些事情</p>
<p>  感觉这里没答好，有点答非所问的意思，我就说了说目前处理bug的一个流程，没有谈到怎么解决一个bug</p>
</li>
<li><p>数据打点是怎么做的</p>
<p>  我们用的是神策第三方服务</p>
</li>
<li><p>内存泄漏工具是怎么做的</p>
<p>  这部分同一面<code>LeakCanary</code>原理</p>
</li>
<li><p>看你之前做过一个<code>MQTT</code>协议的客户端，是出于个人兴趣吗</p>
<p>  是的，当时是想要做一个<code>IM</code>应用</p>
</li>
<li><p>在项目中有遇到需要3D渲染展示的内容吗</p>
<p>  目前没有</p>
</li>
<li><p>两个<code>Activity</code>跳转时方法执行的顺序</p>
<p>  一个<code>Activity</code>创建是：onCreate -&gt; onStart -&gt; onResume（之后便在屏幕上显示了）</p>
<p>  假设从<code>A Activity</code>跳转到<code>B Activity</code>：A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt; B.onResume -&gt; A.onStop</p>
<p>  从<code>B</code>返回到<code>A</code>：B.onPause -&gt; A.onRestart -&gt; A.onResume -&gt; B.onStop -&gt; B.onDestory</p>
</li>
<li><p>两个<code>Activity</code>传递数据可以通过什么方式</p>
<ul>
<li><p><code>Intent</code></p>
</li>
<li><p>如果是同一个进程的话，可以用全局变量或者单例等</p>
</li>
<li><p><code>SharedPreference</code></p>
</li>
<li><p>文件</p>
</li>
</ul>
</li>
<li><p>什么时候使用<code>Service</code></p>
<p>  后台任务，比如说后台播放音乐等，这里提了一下<code>IntentService</code>是开了一个子线程的</p>
</li>
<li><p><code>Service</code>怎么启动，怎么停止</p>
<ul>
<li><p><code>startService</code> &lt;—&gt; <code>stopService</code></p>
</li>
<li><p><code>bindService</code> &lt;—&gt; <code>unbindService</code></p>
</li>
</ul>
</li>
<li><p>包体积优化</p>
<p>  清理资源（字体、图片、代码等）</p>
</li>
</ul>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>二面结束后过了2-3天，HR发微信过来恭喜我进入下一轮面试，我问她接下来是还有三面和HR面吗，她回答我说后面就直接是HR面了，说实话我还是挺惊讶的</p>
<p>HR面15min左右，大概就问了一下，为什么要从上家公司离职，我们是一个新部门，处于项目初期，有什么看法之类的，然后问了一下目前的薪资和期望薪资，over~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说实话感觉这次面试太简单了，有点白瞎了我准备了那么多，还做了查漏补缺 ㄟ( ▔, ▔ )ㄏ ，最后祝大家都能找到心仪的工作 (๑•̀ㅂ•́)و✧</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/11/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - Binder驱动（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7069675794028560391" target="_blank" rel="noopener" title="https://juejin.cn/post/7069675794028560391">Android源码分析 - Binder驱动（中）</a>，我们分析了<code>binder_ioctl</code>中的写操作<code>binder_thread_write</code>部分，了解了<code>binder</code>请求的发起与调度，接下来我们就进行<code>binder</code>驱动的最后一部分分析，<code>binder_thread_read</code></p>
<h1 id="binder-ioctl-write-read"><a href="#binder-ioctl-write-read" class="headerlink" title="binder_ioctl_write_read"></a>binder_ioctl_write_read</h1><p>我们还是先从<code>binder_ioctl</code>后的<code>BINDER_WRITE_READ</code>命令码开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将用户空间ubuf拷贝至内核空间bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//当读缓存中有数据，执行binder读操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="comment">//如果todo队列中有未处理的任务，唤醒等待状态下的线程</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">            binder_wakeup_proc_ilocked(proc);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="binder-thread-read"><a href="#binder-thread-read" class="headerlink" title="binder_thread_read"></a>binder_thread_read</h1><p>这是进行<code>binder</code>读操作的函数，这个函数也是比较长，我们同样将它分成几个部分：</p>
<ol>
<li>等待可用的<code>binder_work</code></li>
<li>循环获取<code>todo</code>队列中的<code>binder_work</code>，并根据<code>binder_work</code>的<code>type</code>，执行一定的处理</li>
<li>处理<code>binder_transaction</code>以及<code>binder_transaction_data</code>，并将<code>binder_transaction_data</code>拷贝回用户空间</li>
</ol>
<h2 id="第一部分：等待工作"><a href="#第一部分：等待工作" class="headerlink" title="第一部分：等待工作"></a>第一部分：等待工作</h2><h3 id="binder-thread-looper"><a href="#binder-thread-looper" class="headerlink" title="binder_thread.looper"></a>binder_thread.looper</h3><p>在此之前我们需要先看一下之前提到的，在<code>binder_thread</code>中的域成员<code>looper</code>，前面我们只是注释了这个域表示线程状态，这里我们介绍一下它有哪些取值：</p>
<ul>
<li><code>BINDER_LOOPER_STATE_REGISTERED</code>：表示该<code>binder</code>线程是非主<code>binder</code>线程</li>
<li><code>BINDER_LOOPER_STATE_ENTERED</code>：表示该<code>binder</code>线程是主<code>binder</code>线程</li>
<li><code>BINDER_LOOPER_STATE_EXITED</code>：表示该<code>binder</code>线程马上就要退出了</li>
<li><code>BINDER_LOOPER_STATE_INVALID</code>：表示该<code>binder</code>线程是无效的（比如原来是<code>binder</code>主线程，后续用户又发送了一个<code>BC_REGISTER_LOOPER</code>请求）</li>
<li><code>BINDER_LOOPER_STATE_WAITING</code>：表示当前<code>binder</code>线程正在等待请求</li>
<li><code>BINDER_LOOPER_STATE_NEED_RETURN</code>：表示该<code>binder</code>线程在处理完<code>transaction</code>后需要返回到用户态</li>
</ul>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//向用户空间写一个binder响应码，该响应码不做任何操作</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="comment">//检查是否有可用的工作需要处理</span></span><br><span class="line">    wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程的状态置为等待中</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有可用的工作，可以等待进程todo队列中的工作</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        <span class="comment">//这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">        <span class="comment">//这里条件在binder_available_for_proc_work_ilocked中已经做了判断</span></span><br><span class="line">        <span class="comment">//似乎永远不会进入到这个case中？</span></span><br><span class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"%d:%d ERROR: Thread waiting for process work before calling BC_REGISTER_LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">            <span class="comment">//进程进入休眠状态，等待唤醒</span></span><br><span class="line">            wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复优先级</span></span><br><span class="line">        binder_restore_priority(current, proc-&gt;default_priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (non_block) &#123;    <span class="comment">//如果是非阻塞模式（这里似乎不会执行到）</span></span><br><span class="line">        <span class="comment">//线程和进程的todo队列中都没有工作</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果是阻塞模式</span></span><br><span class="line">        <span class="comment">//等待binder工作到来</span></span><br><span class="line">        ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将线程的等待中状态解除</span></span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分先检查是否有可用的<code>binder_work</code>待处理，如果有的话进入到下一部分，如果没有的话则需要等待</p>
<p>具体的，我们先看这个函数中的<code>wait_for_proc_work</code>变量，这个变量表示是否需要等待<code>binder_proc</code>中的工作，当在<code>binder_thread</code>中找不到事务栈并且<code>todo</code>队列为空时，此变量值为<code>true</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_available_for_proc_work_ilocked</span><span class="params">(struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !thread-&gt;transaction_stack &amp;&amp;</span><br><span class="line">        binder_worklist_empty_ilocked(&amp;thread-&gt;todo) &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_ENTERED |</span><br><span class="line">                   BINDER_LOOPER_STATE_REGISTERED));    <span class="comment">//这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>，我们分析过是有分支会将<code>binder_work</code>直接添加到<code>binder_proc</code>的<code>todo</code>队列中的，当<code>binder_thread</code>中找不到工作的话，可能就需要从<code>binder_proc</code>中找了</p>
<p>然后会将当前线程的状态置为等待中，等到有可处理的<code>binder_work</code>后再解除这个状态</p>
<p>之后会判断传入的参数是否为阻塞模式，这个是由<code>framework</code>层执行<code>ioctl</code>时传入的<code>flags</code>所决定的，根据<code>framework</code>中的<code>binder</code>代码，这里应该恒为阻塞模式，在阻塞模式下，会调用<code>binder_wait_for_work</code>函数，等待存在可用的<code>binder_work</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_wait_for_work</span><span class="params">(struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">bool</span> do_proc_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个等待队列项</span></span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    freezer_do_not_count();</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//准备睡眠等待</span></span><br><span class="line">        prepare_to_wait(&amp;thread-&gt;wait, &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">//检查确认是否有binder_work可以处理</span></span><br><span class="line">        <span class="keyword">if</span> (binder_has_work_ilocked(thread, do_proc_work))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//可以处理binder_proc.todo中的工作的话</span></span><br><span class="line">        <span class="keyword">if</span> (do_proc_work)</span><br><span class="line">            <span class="comment">//将该binder线程加入到binder_proc中的等待线程中</span></span><br><span class="line">            list_add(&amp;thread-&gt;waiting_thread_node,</span><br><span class="line">                 &amp;proc-&gt;waiting_threads);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//睡眠</span></span><br><span class="line">        schedule();</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//将该binder线程从binder_proc中的等待线程中移除</span></span><br><span class="line">        list_del_init(&amp;thread-&gt;waiting_thread_node);</span><br><span class="line">        <span class="comment">//检查当前系统调用进程是否有信号处理</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束等待</span></span><br><span class="line">    finish_wait(&amp;thread-&gt;wait, &amp;wait);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    freezer_count();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_has_work_ilocked</span><span class="params">(struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">bool</span> do_proc_work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//thread-&gt;process_todo为false时会延时执行</span></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;process_todo ||</span><br><span class="line">        thread-&gt;looper_need_return ||</span><br><span class="line">        (do_proc_work &amp;&amp;</span><br><span class="line">         !binder_worklist_empty_ilocked(&amp;thread-&gt;proc-&gt;todo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的结构和<code>Linux</code>函数<code>wait_event_interruptible</code>非常相似，我们先来看看它是怎么做到阻塞等待的</p>
<hr>
<h3 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h3><h4 id="DEFINE-WAIT"><a href="#DEFINE-WAIT" class="headerlink" title="DEFINE_WAIT"></a>DEFINE_WAIT</h4><p>这是一个宏，它定义了一个<code>wait_queue_t</code>结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_WAIT_FUNC(name, function)				\</span></span><br><span class="line">	<span class="keyword">wait_queue_t</span> name = &#123;						\</span><br><span class="line">		.<span class="keyword">private</span>	= current,				\</span><br><span class="line">		.func		= function,				\</span><br><span class="line">		.task_list	= LIST_HEAD_INIT((name).task_list),	\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</span><br></pre></td></tr></table></figure>

<p>这个结构体中的<code>private</code>域指向的即是当前执行系统调用所在进程的描述结构体，<code>func</code>域指向唤醒这个队列项进程所执行的函数</p>
<h4 id="prepare-to-wait"><a href="#prepare-to-wait" class="headerlink" title="prepare_to_wait"></a>prepare_to_wait</h4><p>这个函数将我们刚刚定义的<code>wait</code>队列项加入到一个等待队列中（在<code>binder</code>中即是加入到<code>thread-&gt;wait</code>中），然后将进程的状态设置为我们指定的状态，在这里为<code>TASK_INTERRUPTIBLE</code>（可中断的睡眠状态）</p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><p><code>schedule</code>是真正执行进程调度的地方，由于之前进程状态已经被设置成<code>TASK_INTERRUPTIBLE</code>状态，在调用<code>schedule</code>后，该进程就会让出<code>CPU</code>，不再调度运行，直到该进程恢复<code>TASK_RUNNING</code>状态</p>
<h4 id="wake-up-interruptible"><a href="#wake-up-interruptible" class="headerlink" title="wake_up_interruptible"></a>wake_up_interruptible</h4><p>我们在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>中提到过，当<code>binder_transaction</code>工作处理完后，会调用<code>wake_up_interruptible</code>函数唤醒目标<code>binder</code>线程的等待队列</p>
<p>这个函数会唤醒<code>TASK_INTERRUPTIBLE</code>状态下的进程，它会循环遍历等待队列中的每个元素，分别执行其唤醒函数，也就对应着我们<code>DEFINE_WAIT</code>定义出来的结构体中的<code>func</code>域，即<code>autoremove_wake_function</code>，它最终会调用<code>try_to_wake_up</code>函数将进程置为<code>TASK_RUNNING</code>状态，这样后面的进程调度便会调度到该进程，从而唤醒该进程继续执行</p>
<h4 id="signal-pending"><a href="#signal-pending" class="headerlink" title="signal_pending"></a>signal_pending</h4><p>这个函数是用来检查当前系统调用进程是否有信号需要处理的，当一个进程陷入系统调用并处于等待状态时，如果此时产生了一个信号，仅仅是在该进程的<code>thread_info</code>中标识了一下，所以我们唤醒进程后需要检查一下是否有信号需要处理，如果有的话，返回<code>-ERESTARTSYS</code>，先处理信号，后续<code>Linux</code>上层库函数会根据<code>-ERESTARTSYS</code>此返回值重新执行这个系统调用</p>
<h4 id="finish-wait"><a href="#finish-wait" class="headerlink" title="finish_wait"></a>finish_wait</h4><p>最后一步，当进程被唤醒后，调用<code>finish_wait</code>函数执行清理工作，将当前进程置为<code>TASK_RUNNING</code>状态，并把当前<code>wait</code>队列项从等待队列中移除</p>
<hr>
<p>了解了上面这些知识，我们再看<code>binder_wait_for_work</code>函数应该比较清晰了，这里有一点需要注意，我们在上一篇文章<a href="https://juejin.cn/post/7069675794028560391#heading-30" target="_blank" rel="noopener">Android源码分析 - Binder驱动（中）</a>提到，在没有<code>TF_ONE_WAY</code>标志的情况下，会使用<code>binder_enqueue_deferred_thread_work_ilocked</code>函数将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，这个函数区别于<code>binder_enqueue_thread_work_ilocked</code>函数，它没有将<code>thread-&gt;process_todo</code>设为<code>true</code>，所以结合着<code>binder_has_work_ilocked</code>函数看，我们可以发现，当<code>thread-&gt;process_todo</code>为<code>false</code>时，整个<code>binder_has_work_ilocked</code>返回<code>false</code>，即会进入到睡眠状态，延迟执行<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，这么设计可以让<code>binder</code>接收端优先处理事务，提高了性能</p>
<h2 id="第二部分：获取工作，根据type做一定的处理"><a href="#第二部分：获取工作，根据type做一定的处理" class="headerlink" title="第二部分：获取工作，根据type做一定的处理"></a>第二部分：获取工作，根据type做一定的处理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//循环处理todo队列中的工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">trd</span> = &amp;<span class="title">tr</span>.<span class="title">transaction_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> trsize = <span class="keyword">sizeof</span>(*trd);</span><br><span class="line"></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//找到需要处理的todo队列</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">            <span class="built_in">list</span> = &amp;thread-&gt;todo;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp;</span><br><span class="line">               wait_for_proc_work)</span><br><span class="line">            <span class="built_in">list</span> = &amp;proc-&gt;todo;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* no data added */</span></span><br><span class="line">            <span class="comment">//只跳过了数据头部的命令码，没有读取任何数据</span></span><br><span class="line">            <span class="keyword">if</span> (ptr - <span class="built_in">buffer</span> == <span class="number">4</span> &amp;&amp; !thread-&gt;looper_need_return)</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传输过来的数据大小不符合</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span> - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) &#123;</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从todo队列中出队一项binder_work</span></span><br><span class="line">        w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">            thread-&gt;process_todo = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">                binder_inner_proc_unlock(proc);</span><br><span class="line">                <span class="comment">//根据binder_work找到binder_transaction结构</span></span><br><span class="line">                t = container_of(w, struct binder_transaction, work);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_RETURN_ERROR: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">                binder_inner_proc_unlock(proc);</span><br><span class="line">                cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">                <span class="comment">//回复给用户进程BR_TRANSACTION_COMPLETE响应码</span></span><br><span class="line">                <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                    <span class="keyword">return</span> -EFAULT;</span><br><span class="line">                ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新统计数据</span></span><br><span class="line">                binder_stat_br(proc, thread, cmd);</span><br><span class="line">                <span class="comment">//释放</span></span><br><span class="line">                kfree(w);</span><br><span class="line">                binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_NODE: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER:</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先创建了一个<code>binder_transaction_data_secctx</code>结构体，后续会将它拷贝到用户空间去，然后创建了一个指针<code>trd</code>指向<code>tr.transaction_data</code>的地址，这样后续操作<code>trd</code>就相当于操作<code>tr.transaction_data</code>了</p>
<p>当进程从睡眠中唤醒，意味着有可用的<code>binder_work</code>了，这时候理论上来说，<code>binder_thread</code>和<code>binder_proc</code>其中总有一个<code>todo</code>队列不为空，这里优先处理<code>binder_thread</code>的<code>todo</code>队列，如果两者都为空，且还未读取过任何数据，重新<code>goto</code>到<code>retry</code>处等待</p>
<p>接着就是将<code>binder_work</code>从相应的<code>todo</code>队列中出队，再根据其类型执行不同的处理操作，这里我们只针对<code>BINDER_WORK_TRANSACTION</code>和<code>BINDER_WORK_TRANSACTION_COMPLETE</code>这两种最重要的类型分析</p>
<p>当类型为<code>BINDER_WORK_TRANSACTION</code>时，表示是别的进程向自己发起<code>binder</code>请求，此时，我们根据<code>binder_work</code>找到对应的<code>binder_transaction</code>结构</p>
<p>当类型为<code>BINDER_WORK_TRANSACTION_COMPLETE</code>时，表示发起的请求<code>BC_TRANSACTION</code>已经完成了，此时将回复给用户空间<code>BR_TRANSACTION_COMPLETE</code>响应码，然后更新统计数据，释放资源</p>
<h2 id="第三部分：处理binder-transaction，拷贝回用户空间"><a href="#第三部分：处理binder-transaction，拷贝回用户空间" class="headerlink" title="第三部分：处理binder_transaction，拷贝回用户空间"></a>第三部分：处理<code>binder_transaction</code>，拷贝回用户空间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">binder_size_t</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用户空间传进来的需要将数据读到的地址</span></span><br><span class="line">    <span class="comment">//实际上只是传输一些命令码和一个binder_transaction_data_secctx结构体</span></span><br><span class="line">    <span class="comment">//真正的数据已经映射到用户虚拟内存空间中了，根据binder_transaction_data中所给的地址直接读就可以了</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="comment">//起始地址 = 读数据的首地址 + 已读数据大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="comment">//结束地址 = 读数据的首地址 + 读数据的总大小</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    ...</span><br><span class="line">retry:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//循环处理todo队列中的工作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data_secctx</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">trd</span> = &amp;<span class="title">tr</span>.<span class="title">transaction_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> trsize = <span class="keyword">sizeof</span>(*trd);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//只有在type == BINDER_WORK_TRANSACTION的情况下，t才会被赋值</span></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;<span class="built_in">buffer</span>-&gt;target_node) &#123;    <span class="comment">//binder实体不为NULL，对应着BC_TRANSACTION请求</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//binder实体在用户空间中的地址</span></span><br><span class="line">            trd-&gt;target.ptr = target_node-&gt;ptr;</span><br><span class="line">            <span class="comment">//携带的额外数据</span></span><br><span class="line">            trd-&gt;cookie =  target_node-&gt;cookie;</span><br><span class="line">            <span class="comment">//优先级</span></span><br><span class="line">            node_prio.sched_policy = target_node-&gt;sched_policy;</span><br><span class="line">            node_prio.prio = target_node-&gt;min_priority;</span><br><span class="line">            binder_transaction_priority(current, t, node_prio,</span><br><span class="line">                            target_node-&gt;inherit_rt);</span><br><span class="line">            <span class="comment">//设置响应码</span></span><br><span class="line">            cmd = BR_TRANSACTION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//binder实体为NULL，对应着BC_REPLY请求</span></span><br><span class="line">            trd-&gt;target.ptr = <span class="number">0</span>;</span><br><span class="line">            trd-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//设置响应码</span></span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//表示要对目标对象请求的命令代码</span></span><br><span class="line">        trd-&gt;code = t-&gt;code;</span><br><span class="line">        <span class="comment">//事务标志，详见enum transaction_flags</span></span><br><span class="line">        trd-&gt;flags = t-&gt;flags;</span><br><span class="line">        <span class="comment">//请求发起进程的uid</span></span><br><span class="line">        trd-&gt;sender_euid = from_kuid(current_user_ns(), t-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取发起请求的binder线程</span></span><br><span class="line">        t_from = binder_get_txn_from(t);</span><br><span class="line">        <span class="keyword">if</span> (t_from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t_from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            <span class="comment">//设置发起请求的进程pid</span></span><br><span class="line">            trd-&gt;sender_pid =</span><br><span class="line">                task_tgid_nr_ns(sender,</span><br><span class="line">                        task_active_pid_ns(current));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            trd-&gt;sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据大小</span></span><br><span class="line">        trd-&gt;data_size = t-&gt;<span class="built_in">buffer</span>-&gt;data_size;</span><br><span class="line">        <span class="comment">//偏移数组大小</span></span><br><span class="line">        trd-&gt;offsets_size = t-&gt;<span class="built_in">buffer</span>-&gt;offsets_size;</span><br><span class="line">        <span class="comment">//设置数据区首地址（这里通过内核空间地址和user_buffer_offset计算得出用户空间地址）</span></span><br><span class="line">        trd-&gt;data.ptr.<span class="built_in">buffer</span> = (<span class="keyword">binder_uintptr_t</span>)</span><br><span class="line">            ((<span class="keyword">uintptr_t</span>)t-&gt;<span class="built_in">buffer</span>-&gt;data +</span><br><span class="line">            binder_alloc_get_user_buffer_offset(&amp;proc-&gt;alloc));</span><br><span class="line">        <span class="comment">//偏移数组紧挨着数据区，所以它的首地址就为数据区地址加上数据大小</span></span><br><span class="line">        trd-&gt;data.ptr.offsets = trd-&gt;data.ptr.<span class="built_in">buffer</span> +</span><br><span class="line">                    ALIGN(t-&gt;<span class="built_in">buffer</span>-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        tr.secctx = t-&gt;security_ctx;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;security_ctx) &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_SEC_CTX;</span><br><span class="line">            trsize = <span class="keyword">sizeof</span>(tr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回复给用户进程对应的响应码</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr)) &#123;</span><br><span class="line">            ... <span class="comment">//Error</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="comment">//将binder_transaction_data拷贝至用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, trsize)) &#123;</span><br><span class="line">            ... <span class="comment">//Error</span></span><br><span class="line">        &#125;</span><br><span class="line">        ptr += trsize;</span><br><span class="line">        <span class="comment">//更新数据统计</span></span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时引用计数减1</span></span><br><span class="line">        <span class="keyword">if</span> (t_from)</span><br><span class="line">            binder_thread_dec_tmpref(t_from);</span><br><span class="line">        <span class="comment">//允许释放这个buffer</span></span><br><span class="line">        t-&gt;<span class="built_in">buffer</span>-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmd != BR_REPLY &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            <span class="comment">//非异步处理</span></span><br><span class="line">            binder_inner_proc_lock(thread-&gt;proc);</span><br><span class="line">            <span class="comment">//将这个事务插入到事务栈中</span></span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="comment">//设置目标处理线程</span></span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">            binder_inner_proc_unlock(thread-&gt;proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            binder_free_transaction(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//更新已读数据大小</span></span><br><span class="line">    *consumed = ptr - <span class="built_in">buffer</span>;</span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    <span class="comment">//请求线程数为0且没有等待线程，已启动线程数小于最大线程数</span></span><br><span class="line">    <span class="comment">//且这个binder线程既不是主线程，也没有被注册成binder子线程</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></span><br><span class="line">         <span class="comment">/*spawn a new thread if we leave this out */</span>) &#123;</span><br><span class="line">        <span class="comment">//向用户空间发送BR_SPAWN_LOOPER响应码，创建新binder线程</span></span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (<span class="keyword">uint32_t</span> __user *)<span class="built_in">buffer</span>))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">//更新统计信息</span></span><br><span class="line">        binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当<code>type == BINDER_WORK_TRANSACTION</code>的情况下，才会走后面的这些逻辑，这一部分主要做的工作是，将处理事务所需要的信息（命令码、PID等）和数据（数据区首地址和偏移数组地址）准备好，拷贝到用户空间，交给用户空间处理这个事务，还有一些细节都在上面代码注释中标出来了，应该还是比较清晰的</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>到这里，从<code>client</code>向<code>binder</code>驱动发起请求，到<code>binder</code>驱动找到<code>server</code>并将请求传递给<code>server</code>这一整个流程我们基本上是看完了，对于被<code>TF_ONE_WAY</code>标记的事务（无需返回），在<code>server</code>中处理完，这一整条<code>binder</code>进程通信流程也就结束了，而对于需要返回的事务，则还需要<code>server</code>向<code>binder</code>驱动发起<code>BC_REPLY</code>事务请求，进行一次进程间通信，将处理后的返回值传给<code>client</code>进程</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们已经将<code>binder</code>驱动所承担的工作分析的七七八八了，但肯定还有很多地方大家云里雾里（实际上我也是这样的），这是因为<code>binder</code>进程间通信不仅需要<code>binder</code>驱动的处理，还需要<code>framework</code>层的协助，很多事情，比如说<code>binder</code>对象的压扁打包就是在<code>framework</code>层做的，我们在<code>binder</code>驱动层只关注了传输，但却不知道传输的是什么，结构是怎样的，当然会产生各种各样的疑惑，后面我们就将会对<code>framework</code>层对<code>binder</code>提供的支持接着做分析</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/03/01/android/stub/AndroidASM%E6%8F%92%E6%A1%A9/">Android ASM插桩</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%8F%92%E6%A1%A9/">插桩</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E6%8F%92%E6%A1%A9/">插桩</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ASM插桩在网上其实已经有很多资料了，我之所以再写这篇文章呢，一是因为好久前学习的ASM，现在已经忘的差不多了，需要再回顾一下，二来是记录一下学习过程，以后如果再有细节记不清楚可以很方便的就能查到，三来再学习的过程中也踩了一些坑，收获了一些心得，这些也需要一个地方记录一下。</p>
<p>好了，废话就说到这里，接下来开始正文。</p>
<p>插桩技术指在保证原有程序逻辑完整性的基础上，在程序中插入探针，通过探针采集代码中的信息（方法本身、方法参数值、返回值等）在特定的位置插入代码段，从而收集程序运行时的动态上下文信息。</p>
<p>插桩技术大体可以分为两类：</p>
<ul>
<li><p><code>APT</code>（Annotation Process Tools），在编译的时候，动态生成 <code>Java</code> 文件，之后编译器将生成的 <code>Java</code> 文件编译成 <code>class</code> 文件，像 <code>ButterKnife</code>、<code>Dagger</code> 就是通过 <code>APT</code> 的方式生成代码的。</p>
<ul>
<li>代表工具：<code>ButterKnife</code></li>
</ul>
</li>
<li><p><code>AOP</code>（Aspect Oriented Programming），生成 <code>class</code> 文件后，修改 <code>class</code> 文件的字节码，达到修改代码的目的。</p>
<ul>
<li>代表工具：听云</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>我们这次选用<code>AOP</code>技术，我们看看有哪些工具可以帮助我们完成插桩工作：</p>
<ul>
<li><p><code>AspectJ</code>，成熟稳定，使用者不需要对字节码文件有深入的理解，使用简单。但是其切入点相对固定，对于字节码文件的操作自由度以及开发的掌控度就大打折扣。并且，他会额外生成一些包装代码，对性能以及包大小有一定影响。</p>
</li>
<li><p><code>ASM</code>，可以修改现有的字节码文件，也可以动态生成字节码文件，完全从字节码去操作字节码的框架，更加灵活，功能更加强大，可以根据需求自定义修改、插入、删除，性能也十分出色，但是要对字节码文件有比较深入的了解，上手也更难。</p>
</li>
</ul>
<p>我们使用<code>ASM</code>来完成插桩，在介绍<code>Android</code>字节码插桩之前，需要先了解一下<code>Java</code>字节码的概念和<code>Android</code>程序打包过程。</p>
<h1 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h1><p>我们知道，<code>Java</code>程序是运行在<code>JVM</code>（<code>Java</code>虚拟机）上的，<code>Java</code>源代码首先会由编译器（<code>Java Compiler</code>）编译成包含了<code>Bytecode</code>（字节码）的<code>.class</code>文件，程序执行时，由类加载器(<code>class loader</code>)将该类的字节码加载到<code>JVM</code>中，<code>JVM</code>会解释执行相应的<code>Bytecode</code>。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E5%AD%97%E8%8A%82%E7%A0%81.png" alt="Java编译执行过程"></p>
<p>为什么不直接彻底编译成机器码，而需要字节码这个中间产物呢？<code>Java</code>是一门跨平台的语言，为了实现一份源码，处处运行的效果，每个平台都有对应不同的<code>JVM</code>，它会将源码对应的指令翻译成对应平台能够理解的机器指令。那为什么不从源码直接解释执行呢，我个人认为这是因为直接从源码开始的编译，速度非常慢，出于性能的考虑，先将源码做一些预处理，处理为字节码，来减轻运行前的编译的性能开销。</p>
<p>在做插桩之前，我们先要记住一点：<code>Java</code> 字节码指令是基于堆栈操作的，因为大部分的<code>Java</code>虚拟机对字节码的执行是基于堆栈的（<code>Android</code>的<code>Dalvik</code>虚拟机是基于寄存器的，不过不影响我们的插桩，因为在我们对<code>java</code>字节码插完桩后，才会执行从<code>java</code>字节码转换到<code>dex</code>文件的过程）</p>
<h1 id="Android打包过程"><a href="#Android打包过程" class="headerlink" title="Android打包过程"></a>Android打包过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B.png" alt="Android打包过程"></p>
<h1 id="Android插桩过程"><a href="#Android插桩过程" class="headerlink" title="Android插桩过程"></a>Android插桩过程</h1><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B.png" alt="Android插桩点"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E6%A1%A9%E8%BF%87%E7%A8%8B2.png" alt="Android插桩点"></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><p>这次，我们模仿听云，做一个<code>Activity</code>生命周期执行时间检测的插件。</p>
<p>我们先梳理一下功能点：</p>
<ol>
<li>针对<code>Activity</code>类</li>
<li>针对生命周期方法</li>
<li>支持插件自定义配置</li>
</ol>
<p>我们用<code>Java</code>代码把我们想要插入的逻辑写一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里取这个名字是为了防止和代码本身的成员变量产生冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> _$_timeRecorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向实际代码前插入代码</span></span><br><span class="line">	_$_timeRecorder = -System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">	... <span class="comment">//这里是实际代码</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向实际代码后插入代码</span></span><br><span class="line">	_$_timeRecorder += System.currentTimeMillis();</span><br><span class="line">	System.err.println(<span class="string">"Time spent: "</span> + _$_timeRecorder + <span class="string">"ms, when "</span> + className + <span class="string">".onCreate"</span>);</span><br><span class="line">	StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();</span><br><span class="line">	<span class="keyword">for</span> (StackTraceElement element : stackTraceElements) &#123;</span><br><span class="line">		System.err.println(element.getClassName() + <span class="string">"."</span> + element.getMethodName() + <span class="string">":"</span> + element.getLineNumber());</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来正式开始编写插件</p>
<h2 id="新建插件工程"><a href="#新建插件工程" class="headerlink" title="新建插件工程"></a>新建插件工程</h2><p>由于<code>Android Studio</code>没有新建<code>gradle</code>脚本的选项，我们先新建一个<code>Empty Activity Project</code>，在此基础上进行改造。</p>
<ol>
<li>新建<code>module</code></li>
<li>更改<code>module</code>的<code>build.gradle</code>文件</li>
<li>新建<code>groovy</code>源代码目录</li>
<li>新建<code>groovy</code>类实现<code>Plugin&lt;Project&gt;</code>接口</li>
<li>新建<code>resource/META_INF/xxx.properites</code>文件（xxx为插件的id名）</li>
<li>在<code>properites</code>文件中声明插件的实现类</li>
</ol>
<h2 id="为插件提供可配置的功能"><a href="#为插件提供可配置的功能" class="headerlink" title="为插件提供可配置的功能"></a>为插件提供可配置的功能</h2><ol>
<li>新建一个实体类用来保存配置信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsmConfigModel</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 以此参数为开头的类（全限定类名）才插桩</span></span><br><span class="line"><span class="comment">	 * 如果不配此参数则代表所有类都可插桩</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; startWithPatterns;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; excludes;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 排除列表（全限定类名）</span></span><br><span class="line"><span class="comment">	 * 以文件形式</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> File excludesByFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在插件<code>apply</code>的时候创建这个配置类，以提供给使用者配置</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    mConfig = project.extensions.create(<span class="string">"asmConfig"</span>, AsmConfigModel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在使用该插件的<code>module</code>下的<code>build.gradle</code>文件中配置</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asmConfig &#123;</span><br><span class="line">    startWithPatterns = [<span class="string">'com.shanbay'</span>]</span><br><span class="line">    excludesByFile = <span class="keyword">new</span> <span class="keyword">File</span>(projectDir, <span class="string">"asm-excludes.txt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新建asm-excludes.txt文件，配置exclude信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com&#x2F;xxx&#x2F;xxx&#x2F;BaseActivity</span><br></pre></td></tr></table></figure>

<p>这里是举个例子，在工程中很有可能有的<code>Activity</code>继承自一些基类<code>Activity</code>，对这些类插桩就重复了</p>
<h2 id="使用Transform-Api"><a href="#使用Transform-Api" class="headerlink" title="使用Transform Api"></a>使用Transform Api</h2><p>根据<a href="http://tools.android.com/tech-docs/new-build-system/transform-api" target="_blank" rel="noopener">官网</a>介绍，<code>Transform Api</code>允许第三方 <code>Plugin</code> 在打包 <code>dex</code> 文件之前的编译过程中操作<code>.class</code> 文件，下图是<code>Transform Api</code>的工作流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E8%BF%87%E7%A8%8B.png" alt="Transform Api工作流程"></p>
<p>可以看到，一次<code>App</code>的编译打包可能会经历多次<code>Transform</code>，<code>Transform</code>将输入进行处理，然后写入到指定的目录下作为下一个 <code>Transform</code> 的输入源。</p>
<p>使用插桩工具，我们需要借助于<code>Transform Api</code>实现</p>
<ol>
<li>首先，我们需要让我们的插件继承自<code>Transform</code></li>
<li>然后，我们要在插件<code>apply</code>时注册<code>Transform</code></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">    println <span class="string">'apply AsmPlugin'</span></span><br><span class="line">    <span class="keyword">def</span> android = project.extensions.getByType(AppExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">android</span>.<span class="title">registerTransform</span>(<span class="title">this</span>)</span></span><br><span class="line"><span class="class">    <span class="title">mConfig</span> = <span class="title">project</span>.<span class="title">extensions</span>.<span class="title">create</span>("<span class="title">asmConfig</span>", <span class="title">AsmConfigModel</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>最后，需要实现<code>Transform</code>类中的抽象方法</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_Transform%E7%B1%BB.png" alt="Transform抽象方法"></p>
<ul>
<li><code>getName</code> 这个方法是指定这个<code>Transform</code>的名称</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">String getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'AsmPlugin'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getInputTypes</code> 这个方法是指定输入类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes.png" alt="Transform输入类型"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getInputTypes2.png" alt="Transform输入类型"></p>
<p>这里，我们选用<code>TransformManager.CONTENT_CLASS</code>就可以了</p>
<ul>
<li><code>getScopes</code> 这个方法是指定插桩的作用域</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes.png" alt="Transform作用域"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_getScopes2.png" alt="Transform作用域"></p>
<p>这里我们选择<code>TransformManager.SCOPE_FULL_PROJECT</code>，代表插桩范围包括此工程和它依赖的所有包</p>
<ul>
<li><code>isIncremental</code> 这个方法代表是否开启增量编译</li>
</ul>
<p>如果开启的话可以减少编译时间，但需要增加额外的判断条件，所以这里就先不开启了</p>
<ul>
<li><code>transform</code> 这个方法是核心方法，我们要对输入内容进行处理然后输出</li>
</ul>
<p><code>transform()</code>方法的参数 <code>TransformInvocation</code> 是一个接口，提供了一些关于输入输出的一些基本信息。下图是<code>transform</code>中我们需要走的流程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_transform%E6%B5%81%E7%A8%8B.png" alt="Transform流程"></p>
<p>这里以<code>directoryInputs</code>举例，<code>directoryInputs</code>就是本地源码编译后产生的<code>class</code>文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> handleDirectory(DirectoryInput input, TransformOutputProvider outputProvider) &#123;</span><br><span class="line">    File file = input.file</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">//递归遍历该文件夹下面所有的子文件夹以及子文件</span></span><br><span class="line">        file.eachFileRecurse &#123; subFile -&gt;</span><br><span class="line">            <span class="keyword">def</span> fileName = subFile.name</span><br><span class="line">            <span class="comment">//初步判断这个文件（或文件夹）是否可插桩</span></span><br><span class="line">            <span class="keyword">if</span> (fileName.endsWith(<span class="string">".class"</span>) &amp;&amp; !fileName.startsWith(<span class="string">"R$"</span>)</span><br><span class="line">                    &amp;&amp; <span class="string">"R.class"</span> != fileName &amp;&amp; <span class="string">"BuildConfig.class"</span> != fileName) &#123;</span><br><span class="line">                <span class="comment">//ClassReader: 字节码的读取与分析引擎</span></span><br><span class="line">                ClassReader classReader = <span class="keyword">new</span> ClassReader(subFile.bytes)</span><br><span class="line">                <span class="comment">//ClassWriter: 它实现了ClassVisitor接口，用于拼接字节码</span></span><br><span class="line">                <span class="comment">//COMPUTE_MAXS: 自动计算栈的最大值以及本地变量的最大数量</span></span><br><span class="line">                <span class="comment">//COMPUTE_FRAMES: 包含COMPUTE_MAXS，且会自动计算方法的栈桢</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(classReader, ClassWriter.COMPUTE_MAXS)</span><br><span class="line">                <span class="comment">//ClassVisitor: 定义在读取Class字节码时会触发的事件，如类头解析完成、注解解析、字段解析、方法解析等</span></span><br><span class="line">                ClassVisitor cv = <span class="keyword">new</span> AsmClassVisitor(api, classWriter, mConfig)</span><br><span class="line">                <span class="comment">//使给定的ClassVisitor访问传递给此构造函数的jvm类文件结构</span></span><br><span class="line">                <span class="comment">//EXPAND_FRAMES: 展开栈帧的标志位</span></span><br><span class="line">                classReader.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">                        subFile.parentFile.absolutePath + File.separator + fileName)</span><br><span class="line">                fos.write(classWriter.toByteArray())</span><br><span class="line">                fos.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> dest = outputProvider.getContentLocation(</span><br><span class="line">            input.name,</span><br><span class="line">            input.contentTypes,</span><br><span class="line">            input.scopes,</span><br><span class="line">            Format.DIRECTORY</span><br><span class="line">    )</span><br><span class="line">    FileUtils.copyDirectoryToDirectory(file, dest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用以下流程图大概描述一下一个<code>class</code>文件的修改过程</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_class%E4%BF%AE%E6%94%B9%E8%BF%87%E7%A8%8B.png" alt="class文件修改流程"></p>
<h2 id="自定义ClassVisitor"><a href="#自定义ClassVisitor" class="headerlink" title="自定义ClassVisitor"></a>自定义ClassVisitor</h2><p>我们开始继承<code>ClassVisitor</code>来实现我们对类的修改</p>
<h3 id="读取配置"><a href="#读取配置" class="headerlink" title="读取配置"></a>读取配置</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE.png" alt="读取配置"></p>
<h3 id="访问类"><a href="#访问类" class="headerlink" title="访问类"></a>访问类</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB.png" alt="访问类方法"></p>
<p>通过这个方法我们可以获得这个类的访问控制，全限定类名，父类名，实现的接口名等信息</p>
<p>这里，我们通过全限定类名和读取出的配置做比对，进一步验证是否需要对此类进行插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB.png" alt="验证类是否可插桩"></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E7%B1%BB2.png" alt="验证类是否可插桩"></p>
<h3 id="访问类内方法"><a href="#访问类内方法" class="headerlink" title="访问类内方法"></a>访问类内方法</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%86%85%E6%96%B9%E6%B3%95.png" alt="访问类内方法"></p>
<p>通过这个方法我们可以获得这个类的所有方法的名称和描述符，我们通过它们来判断该方法是否需要插桩</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E7%AD%9B%E9%80%89%E6%96%B9%E6%B3%95.png" alt="判断方法是否需要插桩"></p>
<p>如果有需要插桩的方法，就将<code>mNeedStubClass</code>标志位置为true，这个标识是为了我们后续判断是否要在该类中插入成员变量，然后使用我们自定义的<code>MethodVisitor</code>替换原始的<code>MethodVisitor</code>。</p>
<h3 id="插入成员变量"><a href="#插入成员变量" class="headerlink" title="插入成员变量"></a>插入成员变量</h3><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%20ASM%E6%8F%92%E6%A1%A9_%E6%8F%92%E5%85%A5%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F.png" alt="插入成员变量"></p>
<p>在最后，如果有需要插桩的方法，我们需要将<code>private long _$_timeRecorder</code>这个成员变量插入到类中去</p>
<h2 id="自定义MethodVisitor"><a href="#自定义MethodVisitor" class="headerlink" title="自定义MethodVisitor"></a>自定义MethodVisitor</h2><p>之前说了，<code>Java</code> 字节码指令是基于栈操作的，基本上任何操作都会改变栈状态</p>
<h3 id="在方法执行之前插入代码"><a href="#在方法执行之前插入代码" class="headerlink" title="在方法执行之前插入代码"></a>在方法执行之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* 此时，this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设此时栈为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">    mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//invokestatic: 调用静态方法System.currentTimeMillis()，返回值为基础类型long</span></span><br><span class="line">    <span class="comment">//第二个参数代表类的全限定名，第三个参数代表方法名，第四个参数代表函数签名，()J的意思是不接受参数，返回值为J (J在字节码里代表基础类型long)</span></span><br><span class="line">    mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lneg: 将栈顶的long类型取负并将结果压入栈顶</span></span><br><span class="line">    mv.visitInsn(Opcodes.LNEG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        此时栈内容:</span></span><br><span class="line"><span class="comment">        [System.currentTimeMillis()的结果值取负, this]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//putfield: 为该类的此实例变量赋值</span></span><br><span class="line">    <span class="comment">//以(栈顶 - 1)为执行对象，为其赋值为栈顶值 (this._$_timeRecorder = -System.currentTimeMillis())</span></span><br><span class="line">    mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line">    <span class="keyword">super</span>.visitCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在方法return之前插入代码"><a href="#在方法return之前插入代码" class="headerlink" title="在方法return之前插入代码"></a>在方法return之前插入代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 以下代码会以栈的形式注释出来，以左边为栈顶，右边为栈底</span></span><br><span class="line"><span class="comment">* 示例：[栈顶 &lt;------------------&gt; 栈底]</span></span><br><span class="line"><span class="comment">* [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">* this为栈顶，System.out为栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opcode == Opcodes.RETURN) &#123;</span><br><span class="line">        Label labelEnd = <span class="keyword">new</span> Label();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//aload_0: 将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//dup: 将栈顶的值复制一份压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行System.currentTimeMillis()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"currentTimeMillis"</span>, <span class="string">"()J"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis()执行后的结果值, this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶两long值相加，并将结果压入栈顶</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitInsn(Opcodes.LADD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.currentTimeMillis() + this._$_timeRecorder, this]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将栈顶的值存入(栈顶 - 1)._$_timeRecorder中</span></span><br><span class="line">        <span class="comment">//即this._$_timeRecorder = this._$_timeRecorder + System.currentTimeMillis</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.PUTFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//L: 对象类型，以分号结尾，如Ljava/lang/Object;</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建字符串</span></span><br><span class="line">        <span class="comment">//创建一个StringBuilder对象，此时还并没有执行构造方法</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        <span class="comment">//因为执行构造函数会将栈顶的StringBuilder对象弹出，为了后续能继续使用这个对象，所以这里需要先复制一份</span></span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的StringBuilder调用构造方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"Time spent: "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            ["Time spent: ", StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将this压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以当前栈顶的值为主体，获取当前类的成员变量_$_timeRecorder，类型为long</span></span><br><span class="line">        <span class="comment">//相当于this._$_timeRecorder</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETFIELD, mClassName, TIMER_NAME, <span class="string">"J"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [this._$_timeRecorder, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(J)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量压入栈顶</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"ms, when "</span> + mFormatClassName + <span class="string">"."</span> + mMethodName + <span class="string">":"</span> + mMethodDescriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [字符串常量, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行StringBuilder.append()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行StringBuilder.toString()方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为参数，(栈顶 - 1)的引用为主体执行PrintStream.println()方法</span></span><br><span class="line">        <span class="comment">//相当于System.out.println(String)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Thread.currentThread()，并将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, <span class="string">"java/lang/Thread"</span>, <span class="string">"currentThread"</span>, <span class="string">"()Ljava/lang/Thread;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [Thread.currentThread()执行的结果]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以栈顶的值为主体，执行getStackTrace()方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//相当于Thread.currentThread().getStackTrace()</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/Thread"</span>, <span class="string">"getStackTrace"</span>, <span class="string">"()[Ljava/lang/StackTraceElement;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//astore: 将一个引用类型对象保存到局部变量表index为2的位置（index1: this, index2: onCreate方法的参数）</span></span><br><span class="line">        <span class="comment">//使用一个临时变量保存StackTraceElement数组</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//将局部变量表index2处的引用对象压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//StackTraceElement数组备份</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">3</span>);</span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得栈顶位置数组的长度</span></span><br><span class="line">        mv.visitInsn(Opcodes.ARRAYLENGTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3           ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数组length保存至局部变量表index4的位置</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4   ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将int常量0压入栈顶</span></span><br><span class="line">        mv.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">        <span class="comment">//将栈顶的0取出保存（用作循环下标index）</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ISTORE, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环开始处</span></span><br><span class="line">        <span class="comment">//插入一个label用来做后续循环跳转的标志</span></span><br><span class="line">        Label labelLoop = <span class="keyword">new</span> Label();</span><br><span class="line">        mv.visitLabel(labelLoop);</span><br><span class="line">        <span class="comment">//将循环标志位的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//将数组长度值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环标志位, 数组长度]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//if_icmpge: 比较栈顶两int型数值大小, 当结果大于等于0时跳转</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.IF_ICMPGE, labelEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将循环index的值压入栈顶</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ILOAD, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [循环index, StackTraceElement数组]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将引用类型数组指定索引的值推送至栈顶（var3[var5]）</span></span><br><span class="line">        mv.visitInsn(Opcodes.AALOAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5    ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将该索引下的值保存</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ASTORE, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈为空</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将System.out入栈</span></span><br><span class="line">        mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//new StringBuilder()</span></span><br><span class="line">        mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>);</span><br><span class="line">        mv.visitInsn(Opcodes.DUP);</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出StackTraceElement数组中的某个值(以循环index作为下标)</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StackTraceElement数组中的某个值(以循环index作为下标), StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用栈顶对象，执行getClassName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getClassName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [ClassName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以ClassName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        <span class="comment">//即StringBuilder.append(ClassName)</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">"."</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getMethodName方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getMethodName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [MethodName, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以MethodName作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将常量入栈</span></span><br><span class="line">        mv.visitLdcInsn(<span class="string">":"</span>);</span><br><span class="line">        <span class="comment">//以常量作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将StackTraceElement数组中的某个值(以循环index作为下标)入栈</span></span><br><span class="line">        mv.visitVarInsn(Opcodes.ALOAD, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用它的getLineNumber方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StackTraceElement"</span>, <span class="string">"getLineNumber"</span>, <span class="string">"()I"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [LineNumber, StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以LineNumber作为参数，执行(栈顶 - 1)对象的append方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"append"</span>, <span class="string">"(I)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [StringBuilder, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用栈顶对象的toString方法，将返回值压入栈顶</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此时栈内容:</span></span><br><span class="line"><span class="comment">            [String, System.out]</span></span><br><span class="line"><span class="comment">            此时局部变量表中:</span></span><br><span class="line"><span class="comment">            [ 0        1             2                       3                 4          5                             6                         ]</span></span><br><span class="line"><span class="comment">            [this | Bundle | StackTraceElement数组 | StackTraceElement数组 | 数组长度 | 循环index | StackTraceElement数组中的某个值(以循环index作为下标)]</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以String作为参数，执行(栈顶 - 1)对象System.out的println方法</span></span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//iinc: 将指定int型变量增加指定值(index++)</span></span><br><span class="line">        mv.visitIincInsn(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//跳转到labelLoop插入的位置</span></span><br><span class="line">        mv.visitJumpInsn(Opcodes.GOTO, labelLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入结束Label，作为循环终止的跳转标志</span></span><br><span class="line">        mv.visitLabel(labelEnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的方法插桩工作就完成了，接下来我们运行一下看看</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先<code>clean build</code>，再<code>build</code>，查看控制台信息，<code>build</code>完成后查看<code>class</code>文件</p>
<p>运行<code>App</code>，查看<code>Logcat</code>信息，可以看到打印出来了我们想要的信息。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这样我们就通过插桩的方式，实现了一个简单的无任何代码侵入的性能检测工具</p>
<p>通过这一次实践，我对<code>java</code>的编译运行字节码，<code>Android</code>的打包流程有了更深的理解</p>
<p>完整项目地址：<a href="https://github.com/dreamgyf/AsmPluginDemo" target="_blank" rel="noopener">https://github.com/dreamgyf/AsmPluginDemo</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/28/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89/">Android源码分析 - Binder驱动（中）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-28</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="https://juejin.cn/post/7059601252367204365">Android源码分析 - Binder驱动（上）</a>，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，接下来我们继续分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h1><p>我们先简单介绍一下<code>ioctl</code>函数，这个函数是用来控制设备的，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd , <span class="keyword">unsigned</span> <span class="keyword">long</span> cmd , ...<span class="comment">/* args */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数<code>fd</code>为设备的文件描述符</p>
<p>第二个参数<code>cmd</code>为命令码，它由驱动方自定义，用户通过命令码告诉设备驱动想要它做什么</p>
<p>后面为可选参数，具体内容和<code>cmd</code>有关，是传入驱动层的参数</p>
<h2 id="命令码"><a href="#命令码" class="headerlink" title="命令码"></a>命令码</h2><p><code>Linux</code>内核是这么定义一个命令码的</p>
<table>
<thead>
<tr>
<th>设备类型</th>
<th>序列号</th>
<th>方向</th>
<th>数据尺寸</th>
</tr>
</thead>
<tbody><tr>
<td>8 bit</td>
<td>8 bit</td>
<td>2 bit</td>
<td>8~14 bit</td>
</tr>
</tbody></table>
<p>这样，一个命令就变成了一个整数形式的命令码了，为了使用起来方便，<code>Linux</code>定义了一些生成命令码的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO(type,nr)        <span class="comment">//没有参数的命令</span></span><br><span class="line">_IOR(type,nr,<span class="built_in">size</span>)  <span class="comment">//从驱动中读数据</span></span><br><span class="line">_IOW(type,nr,<span class="built_in">size</span>)  <span class="comment">//写数据到驱动中</span></span><br><span class="line">_IOWR(type,nr,<span class="built_in">size</span>) <span class="comment">//双向读写</span></span><br></pre></td></tr></table></figure>

<h1 id="binder驱动命令码"><a href="#binder驱动命令码" class="headerlink" title="binder驱动命令码"></a>binder驱动命令码</h1><p>了解了<code>ioctl</code>和它的命令码后，我们来看看<code>binder</code>驱动定义了哪些命令码，以及它们分别有什么作用</p>
<p><code>binder</code>驱动命令码被定义在<code>include/uapi/linux/android/binder.h</code>中，其中有几个貌似未使用，我就不列出来了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ		_IOWR(<span class="meta-string">'b'</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS		_IOW(<span class="meta-string">'b'</span>, 5, __u32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR		_IOW(<span class="meta-string">'b'</span>, 7, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT		_IOW(<span class="meta-string">'b'</span>, 8, __s32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION			_IOWR(<span class="meta-string">'b'</span>, 9, struct binder_version)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_DEBUG_INFO	_IOWR(<span class="meta-string">'b'</span>, 11, struct binder_node_debug_info)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_GET_NODE_INFO_FOR_REF	_IOWR(<span class="meta-string">'b'</span>, 12, struct binder_node_info_for_ref)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR_EXT	_IOW(<span class="meta-string">'b'</span>, 13, struct flat_binder_object)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>BINDER_WRITE_READ</code>：读写命令，用于数据传输，<code>binder IPC</code>通信中的核心</li>
<li><code>BINDER_SET_MAX_THREADS</code>：设置最大线程数</li>
<li><code>BINDER_SET_CONTEXT_MGR</code>：设置成为<code>binder</code>上下文管理者</li>
<li><code>BINDER_THREAD_EXIT</code>：<code>binder</code>线程退出命令，释放相关资源</li>
<li><code>BINDER_VERSION</code>：获取<code>binder</code>驱动版本号</li>
<li><code>BINDER_GET_NODE_DEBUG_INFO</code>：获得<code>binder</code>节点的<code>debug</code>信息</li>
<li><code>BINDER_GET_NODE_INFO_FOR_REF</code>：从<code>binder</code>引用获得<code>binder</code>节点信息</li>
<li><code>BINDER_SET_CONTEXT_MGR_EXT</code>：和<code>BINDER_SET_CONTEXT_MGR</code>作用相同，携带额外参数</li>
</ul>
<p>了解了这些<code>binder</code>驱动命令码，我们就可以开始正式分析<code>binder_ioctl</code></p>
<h1 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h1><p>这个函数位于<code>drivers/android/binder.c</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="comment">//从命令参数中解析出用户数据大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//进入休眠状态，等待被唤醒</span></span><br><span class="line">    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> err_unlocked;</span><br><span class="line">    <span class="comment">//根据请求系统调用的线程的pid，查找对应的binder_thread，没有则新建一个</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_MAX_THREADS: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_INFO_FOR_REF: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> BINDER_GET_NODE_DEBUG_INFO: &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体上来看还是比较清晰的，我们对一些点做一下详解</p>
<h2 id="user"><a href="#user" class="headerlink" title="__user"></a>__user</h2><p><code>__user</code>是一个宏，它告诉编译器不应该解除这个指针的引用（因为在当前地址空间中它是没有意义的），<code>(void __user *)arg</code>表示<code>arg</code>是一个用户空间的地址，不能直接进行拷贝等，要使用<code>copy_from_user</code>，<code>copy_to_user</code>等函数。</p>
<h2 id="wait-event-interruptible"><a href="#wait-event-interruptible" class="headerlink" title="wait_event_interruptible"></a>wait_event_interruptible</h2><p><code>wait_event_interruptible(wq, condition)</code>是一个宏，它是用来挂起进程直到满足判断条件的</p>
<p><code>binder_stop_on_user_error</code>是一个全局变量，它的初始值为0，<code>binder_user_error_wait</code>是一个等待队列</p>
<p>在正常情况下，<code>binder_stop_on_user_error &lt; 2</code>这个条件是成立的，所以不会进入挂起状态，而当<code>binder</code>因为错误而停止后，调用<code>binder_ioctl</code>，则会挂起进程，直到其他进程通过<code>wake_up_interruptible</code>来唤醒<code>binder_user_error_wait</code>队列，并且满足<code>binder_stop_on_user_error &lt; 2</code>这个条件，<code>binder_ioctl</code>才会继续往后运行</p>
<h2 id="binder-thread结构体"><a href="#binder-thread结构体" class="headerlink" title="binder_thread结构体"></a>binder_thread结构体</h2><p>我们需要关注一个重要的结构体<code>binder_thread</code>，它在后续的代码中会频繁的出现，这个结构体描述了进程中的工作线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="comment">//binder线程所属的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="comment">//链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_thread_node</span>;</span></span><br><span class="line">    <span class="comment">//进程pid</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//描述了线程当前的状态</span></span><br><span class="line">    <span class="keyword">int</span> looper;              <span class="comment">/* only modified by this thread */</span></span><br><span class="line">    <span class="keyword">bool</span> looper_need_return; <span class="comment">/* can be written by other thread */</span></span><br><span class="line">    <span class="comment">//binder事务栈（链表形式，内部存在前后节点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">    <span class="comment">//todo队列，为需要处理的工作的链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="comment">//binder_thread_write后是否立即执行完成binder_thread_read</span></span><br><span class="line">    <span class="comment">//false的情况下会在binder_thread_read中休眠，延迟执行BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    <span class="keyword">bool</span> process_todo;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">return_error</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_error</span> <span class="title">reply_error</span>;</span></span><br><span class="line">    <span class="comment">//等待队列，当处理binder事务需要依赖别的binder事务的时候，则会以此等待队列睡眠</span></span><br><span class="line">    <span class="comment">//直到它所依赖的binder事务完成后唤醒</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="comment">//统计信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="comment">//临时引用计数</span></span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="comment">//是否死亡</span></span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//线程信息结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="binder-get-thread"><a href="#binder-get-thread" class="headerlink" title="binder_get_thread"></a>binder_get_thread</h2><p>接下来我们看一下<code>binder_ioctl</code>是怎么获得<code>binder_thread</code>的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">new_thread</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line">    thread = binder_get_thread_ilocked(proc, <span class="literal">NULL</span>);</span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    <span class="keyword">if</span> (!thread) &#123;</span><br><span class="line">        new_thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (new_thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        thread = binder_get_thread_ilocked(proc, new_thread);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (thread != new_thread)</span><br><span class="line">            kfree(new_thread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到里面有锁操作，使用的就是上一章<a href="https://juejin.cn/post/7062654742329032740#heading-10" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中所介绍过的<code>spinlock</code>，使用的是<code>binder_proc</code>结构体中的<code>inner_lock</code></p>
<p>简单浏览一下代码我们就可以知道，<code>binder_get_thread</code>首先试着从<code>binder_proc</code>获得<code>binder_thread</code>，如果没能获得，就新建一个，这两种情况都调用了<code>binder_get_thread_ilocked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread_ilocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc *proc, struct binder_thread *new_thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!new_thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    thread = new_thread;</span><br><span class="line">    <span class="comment">//binder_thread对象创建计数加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">    thread-&gt;proc = proc;</span><br><span class="line">    thread-&gt;pid = current-&gt;pid;</span><br><span class="line">    <span class="comment">//引用计数加1</span></span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    thread-&gt;task = current;</span><br><span class="line">    atomic_set(&amp;thread-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">    <span class="comment">//初始化todo队列</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">//插入红黑树</span></span><br><span class="line">    rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">    thread-&gt;looper_need_return = <span class="literal">true</span>;</span><br><span class="line">    thread-&gt;return_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;return_error.cmd = BR_OK;</span><br><span class="line">    thread-&gt;reply_error.work.type = BINDER_WORK_RETURN_ERROR;</span><br><span class="line">    thread-&gt;reply_error.cmd = BR_OK;</span><br><span class="line">    INIT_LIST_HEAD(&amp;new_thread-&gt;waiting_thread_node);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数分为前后两个部分，前半部分通过<code>binder_proc-&gt;threads</code>这个红黑树查找当前系统调用进程<code>pid</code>所对应的<code>binder_thread</code>，后半部分初始化了传入的<code>new_thread</code>，并将其插入到红黑树中（<code>binder_proc-&gt;threads</code>）</p>
<hr>
<p>接下来就是判断命令码<code>cmd</code>，来执行相应的工作了，我们只分析比较重要的几个命令码</p>
<h1 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h1><p><code>binder</code>驱动中最重要的命令码肯定非<code>BINDER_WRITE_READ</code>莫属了，这个命令用来进行<code>binder</code>读写交互</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        ret = binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch case命令码后，直接调用了<code>binder_ioctl_write_read</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span> = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验用户传入arg数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将用户空间ubuf拷贝至内核空间bwr</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//当写缓存中有数据，执行binder写操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        trace_binder_write_done(ret);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有错误发生，将已读数据大小设为0</span></span><br><span class="line">            bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当读缓存中有数据，执行binder读操作</span></span><br><span class="line">    <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret = binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        <span class="comment">//如果todo队列中有未处理的任务，唤醒等待状态下的线程</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo))</span><br><span class="line">            binder_wakeup_proc_ilocked(proc);</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将内核空间修改后的bwr拷贝至用户空间ubuf</span></span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="binder-write-read结构体"><a href="#binder-write-read结构体" class="headerlink" title="binder_write_read结构体"></a>binder_write_read结构体</h2><p><code>BINDER_WRITE_READ</code>命令码所接受的参数为一个<code>binder_write_read</code>结构体，我们先来了解一下它</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_size;        <span class="comment">/* bytes to write */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        write_consumed;    <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     write_buffer;</span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_size;         <span class="comment">/* bytes to read */</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>        read_consumed;     <span class="comment">/* bytes consumed by driver */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>     read_buffer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>write_size</code>：写数据的总大小</li>
<li><code>write_consumed</code>：已写数据大小</li>
<li><code>write_buffer</code>：写数据的虚拟内存地址</li>
<li><code>read_size</code>：读数据的总大小</li>
<li><code>read_consumed</code>：已读数据大小</li>
<li><code>read_buffer</code>：读数据的虚拟内存地址</li>
</ul>
<hr>
<p>整个<code>binder_ioctl_write_read</code>函数结构是比较简单的，首先校验了一下用户空间所传的参数<code>arg</code>为<code>binder_write_read</code>结构体，接着将其从用户空间拷贝至内核空间<code>bwr</code>，接下来便是分别检查写缓存读缓存中是否有数据，有的话则执行相应的写读操作。这里需要注意的是，读写操作所传入的<code>write_consumed</code>和<code>read_consumed</code>是以地址的形式，即会对这两个值进行修改，不管读写操作是否执行，成功或者失败，最后都会调用<code>copy_to_user</code>将<code>bwr</code>从内核空间复制到用户空间<code>ubuf</code></p>
<p>看到这里，可能有些同学会觉得有些奇怪，说好<code>binder</code>只进行一次复制的呢？其实是这样的没错，这里的<code>copy_from_user</code>或者<code>copy_to_user</code>只是复制了<code>binder_write_read</code>结构体，得到了需要IPC数据的虚拟内存地址而已，真正的复制操作是在<code>binder</code>读写操作中进行的</p>
<h2 id="binder-thread-write"><a href="#binder-thread-write" class="headerlink" title="binder_thread_write"></a>binder_thread_write</h2><p>先看<code>binder</code>写操作，这个函数首先从传入的参数中，计算出待写的起始地址和结束地址，因为可能数据中含有多个命令和对应数据要处理，所以这里开了一个循环，在循环中，首先调用<code>get_user</code>，从用户空间读取一个值到内核空间中来，这个值就是<code>binder</code>请求码，然后将指针向后移动32位，使其指向对应请求码的数据头，接着根据<code>binder</code>请求码去完成不同的工作，处理完后修改已写数据大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">buffer</span> = (<span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)binder_buffer;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = <span class="built_in">buffer</span> + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *<span class="built_in">end</span> = <span class="built_in">buffer</span> + <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">//可能含有多个命令和对应数据要处理</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; <span class="built_in">end</span> &amp;&amp; thread-&gt;return_error.cmd == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得binder请求码</span></span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">//使指针指向数据头</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        <span class="comment">//记录binder数据信息</span></span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            atomic_inc(&amp;binder_stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;proc-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">            atomic_inc(&amp;thread-&gt;stats.bc[_IOC_NR(cmd)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据binder请求码，执行不同工作</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BC_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BC_DECREFS: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_INCREFS_DONE:</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_ATTEMPT_ACQUIRE:</span><br><span class="line">            pr_err(<span class="string">"BC_ATTEMPT_ACQUIRE not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">case</span> BC_ACQUIRE_RESULT:</span><br><span class="line">            pr_err(<span class="string">"BC_ACQUIRE_RESULT not supported\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION_SG:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY_SG: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">        <span class="keyword">case</span> BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_DEAD_BINDER_DONE: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">"%d:%d unknown command %d\n"</span>,</span><br><span class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置已写数据大小</span></span><br><span class="line">        *consumed = ptr - <span class="built_in">buffer</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="binder请求码"><a href="#binder请求码" class="headerlink" title="binder请求码"></a>binder请求码</h3><p><code>binder</code>请求码用于用户空间程序向<code>binder</code>驱动发送请求消息，以<code>BC</code>开头，被定义在<code>enum</code> <code>binder_driver_command_protocol</code>中（<code>include/uapi/linux/android/binder.h</code>）</p>
<p>命令                            | 说明                           | 参数类型                    |<br>| —————————– | —————————- | ——————– |<br>| BC_TRANSACTION                | Binder事务，即：Client对于Server的请求 | binder_transaction_data |<br>| BC_REPLY                      | 事务的应答，即：Server对于Client的回复    | binder_transaction_data |<br>| BC_FREE_BUFFER                | 通知驱动释放Buffer                 | binder_uintptr_t |<br>| BC_ACQUIRE                    | 强引用计数+1                      | __u32             |<br>| BC_RELEASE                    | 强引用计数-1                      | __u32             |<br>| BC_INCREFS                    | 弱引用计数+1                      | __u32             |<br>| BC_DECREFS                    | 弱引用计数-1                      | __u32             |<br>| BC_ACQUIRE_DONE               | BR_ACQUIRE的回复                | binder_ptr_cookie  |<br>| BC_INCREFS_DONE               | BR_INCREFS的回复                | binder_ptr_cookie  |<br>| BC_ENTER_LOOPER               | 通知驱动主线程ready                 | void            |<br>| BC_REGISTER_LOOPER            | 通知驱动子线程ready                 | void            |<br>| BC_EXIT_LOOPER                | 通知驱动线程已经退出                   | void          |<br>| BC_REQUEST_DEATH_NOTIFICATION | 请求接收死亡通知             | binder_handle_cookie    |<br>| BC_CLEAR_DEATH_NOTIFICATION   | 去除接收死亡通知             | binder_handle_cookie    |<br>| BC_DEAD_BINDER_DONE           | 已经处理完死亡通知            | binder_uintptr_t       |<br>| BC_ATTEMPT_ACQUIRE            | 暂不支持                         | -                 |<br>| BC_ACQUIRE_RESULT             | 暂不支持                         | -                 |</p>
<p>其中，最重要且最频繁的操作为<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>，我们就只分析一下这两个请求码做了什么事</p>
<h3 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a>binder_transaction</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_uintptr_t</span> binder_buffer, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">binder_size_t</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">                       cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这两个请求码，首先从用户空间中复制了一份<code>binder_transaction_data</code>到内核空间，接着就调用<code>binder_transaction</code>函数继续处理</p>
<h4 id="binder-transaction-data结构体"><a href="#binder-transaction-data结构体" class="headerlink" title="binder_transaction_data结构体"></a>binder_transaction_data结构体</h4><p>在分析<code>binder_transaction</code>函数前，我们需要先了解一些结构体</p>
<p><code>binder_transaction_data</code>结构体就是<code>BC_TRANSACTION</code>/<code>BC_REPLY</code>所对应的参数类型，它被定义在<code>include/uapi/linux/android/binder.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象非本地binder实体时，用handle表示对目标binder的引用</span></span><br><span class="line">        __u32	handle;</span><br><span class="line">        <span class="comment">//当BINDER_WRITE_READ命令的目标对象是本地binder实体时，用此域成员变量表示这个对象在本进程中的内存地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span> ptr;</span><br><span class="line">    &#125; target;</span><br><span class="line">    <span class="comment">//目标binder实体所带的附加数据</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">    <span class="comment">//表示要对目标对象请求的命令代码</span></span><br><span class="line">    __u32		code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务标志，详见enum transaction_flags</span></span><br><span class="line">    __u32	        flags;</span><br><span class="line">    <span class="comment">//发起请求的进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span>		sender_pid;</span><br><span class="line">    <span class="comment">//发起请求的进程uid</span></span><br><span class="line">    <span class="keyword">uid_t</span>		sender_euid;</span><br><span class="line">    <span class="comment">//真正要传输的数据的大小</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	data_size;</span><br><span class="line">    <span class="comment">//偏移数组大小，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">    <span class="keyword">binder_size_t</span>	offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">//数据区的首地址</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	<span class="built_in">buffer</span>;</span><br><span class="line">            <span class="comment">//偏移数组的首地址，这个偏移数组是用来描述数据区中，每一个binder对象的位置的</span></span><br><span class="line">            <span class="comment">//数组的每一项为一个binder_size_t，这个值对应着每一个binder对象相对buffer首地址的偏移</span></span><br><span class="line">            <span class="keyword">binder_uintptr_t</span>	offsets;</span><br><span class="line">        &#125; ptr;</span><br><span class="line">        <span class="comment">//数据较小的时候可以直接装在这个数组里</span></span><br><span class="line">        __u8	buf[<span class="number">8</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，真正需要拷贝的数据的地址是保存在<code>data</code>域中的，可能文字描述的<code>data</code>结构不是特别清晰，可以结合下图理解：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data.png" alt="data结构"></p>
<p>这里我用一个例子来解释一下<code>binder_transaction_data</code>传输的数据是什么样子的</p>
<p>小伙伴们应该都了解<code>Parcel</code>吧，它是一个存放读取数据的容器，我们<code>binder_transaction_data</code>中实际传输的数据就是通过它组合而成的，它可以传输基本数据类型，<code>Parcelable</code>类型和<code>binder</code>类型</p>
<p>其中基本数据类型就不用说了，每种基本类型所占用的大小是固定的，<code>Parcelable</code>类型实际上也是传输基本数据类型，它是通过实现<code>Parcelable</code>接口将一个复杂对象中的成员序列化成了一个个基本数据类型传输，而<code>binder</code>类型的传输有点特别，它会将这个<code>binder</code>对象 “压扁” 成一个<code>flat_binder_object</code>结构体传输</p>
<p>假设我们有一个客户端<code>client</code>，一个服务端<code>server</code>，<code>client</code>想要向<code>binder</code>驱动发起一个事物，调用<code>server</code>的某个方法，我们该怎么构建<code>binder_transaction_data</code>的数据区呢？</p>
<p>一般来说，我们需要先写一个<code>token</code>，这个<code>token</code>是为了进行校验的，两端需要保持一致。接着我们需要按顺序依次写入参数，假设我们想要调用<code>server</code>的<code>callMe(int, Parcelable, IBinder)</code>函数，那我们就需要先写入一个<code>int</code>，再写入一个<code>Parcelable</code>，最后再将<code>IBinder</code> “压扁” 成一个<code>flat_binder_object</code>写入。</p>
<p>此时数据布局如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%AD%EF%BC%89_binder_transaction_data2.png" alt="data结构"></p>
<p>从图中我们可以看出来，<code>offsets</code>指示出了<code>buffer</code>中传输的<code>binder</code>对象的位置，有几个<code>binder</code>对象，就会有几个<code>offset</code>与之对应</p>
<h5 id="transaction-flags"><a href="#transaction-flags" class="headerlink" title="transaction_flags"></a>transaction_flags</h5><p>我们再看一下有哪些事务标志，他们分别代表什么意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> transaction_flags &#123;</span><br><span class="line">    <span class="comment">//单向调用，异步操作，无返回</span></span><br><span class="line">    TF_ONE_WAY	        = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个组件的根对象，对应类型为本地binder</span></span><br><span class="line">    TF_ROOT_OBJECT	= <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">//reply内容是一个32位的状态码，对应类型为远程binder引用的句柄</span></span><br><span class="line">    TF_STATUS_CODE	= <span class="number">0x08</span>,</span><br><span class="line">    <span class="comment">//可以接收一个文件描述符，对应的类型为文件（BINDER_TYPE_FD），即handle中存储的为文件描述符</span></span><br><span class="line">    TF_ACCEPT_FDS	= <span class="number">0x10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-transaction结构体"><a href="#binder-transaction结构体" class="headerlink" title="binder_transaction结构体"></a>binder_transaction结构体</h4><p><code>binder_transaction</code>结构体用来描述进程间通信过程（事务），它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="comment">//用来描述需要处理的工作事项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="comment">//发起事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line">    <span class="comment">//事务所依赖的另一个事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="comment">//处理该事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="comment">//目标线程下一个需要处理的事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="comment">//1: 表示同步事务，需要等待对方回复</span></span><br><span class="line">    <span class="comment">//0: 表示异步事务</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向为该事务分配的内核缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>	flags;</span><br><span class="line">    <span class="comment">//发起事务线程的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">priority</span>;</span></span><br><span class="line">    <span class="comment">//线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求</span></span><br><span class="line">    <span class="comment">//在修改之前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span>	<span class="title">saved_priority</span>;</span></span><br><span class="line">    <span class="keyword">bool</span>    set_priority_called;</span><br><span class="line">    <span class="keyword">kuid_t</span>	sender_euid;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span> security_ctx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-work结构体"><a href="#binder-work结构体" class="headerlink" title="binder_work结构体"></a>binder_work结构体</h4><p><code>binder_work</code>结构体用来描述需要处理的工作事项，它被定义在<code>drivers/android/binder.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> &#123;</span></span><br><span class="line">    <span class="comment">//双向链表中的一个节点，这个链表储存了所有的binder_work</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作项类型</span></span><br><span class="line">    <span class="keyword">enum</span> binder_work_type &#123;</span><br><span class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</span><br><span class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</span><br><span class="line">        BINDER_WORK_RETURN_ERROR,</span><br><span class="line">        BINDER_WORK_NODE,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</span><br><span class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</span><br><span class="line">    &#125; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>简单看完了一些必要的结构体后，我们把目光转回<code>binder_transaction</code>函数上</p>
<p><code>binder_transaction</code>函数的代码很长，我们精简一下，然后再分段来看，从整体上，我们可以将它分为几个部分：</p>
<ol>
<li>获得目标进程/线程信息</li>
<li>将数据拷贝到目标进程所映射的内存中（此时会建立实际的映射关系）</li>
<li>将待处理的任务加入<code>todo</code>队列，唤醒目标线程</li>
</ol>
<h4 id="第一部分：获得目标进程-线程信息"><a href="#第一部分：获得目标进程-线程信息" class="headerlink" title="第一部分：获得目标进程/线程信息"></a>第一部分：获得目标进程/线程信息</h4><p>这里根据是否为<code>reply</code>，分成了两种情况</p>
<h5 id="BC-TRANSACTION"><a href="#BC-TRANSACTION" class="headerlink" title="BC_TRANSACTION"></a>BC_TRANSACTION</h5><p>我们先看<code>BC_TRANSACTION</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span> = <span class="title">proc</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line"></span><br><span class="line">            binder_proc_lock(proc);</span><br><span class="line">            <span class="comment">//查找binder引用</span></span><br><span class="line">            ref = binder_get_ref_olocked(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">            target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                    ref-&gt;node, &amp;target_proc,</span><br><span class="line">                    &amp;return_error);</span><br><span class="line">            binder_proc_unlock(proc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//handle为0代表目标target是ServiceManager</span></span><br><span class="line">            mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="comment">//ServiceManager为binder驱动的context，所以可以直接从context中获取binder实体</span></span><br><span class="line">            target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">            <span class="keyword">if</span> (target_node)</span><br><span class="line">                <span class="comment">//通过目标binder实体获取目标进程信息</span></span><br><span class="line">                target_node = binder_get_node_refs_for_txn(</span><br><span class="line">                        target_node, &amp;target_proc,</span><br><span class="line">                        &amp;return_error);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                return_error = BR_DEAD_REPLY;</span><br><span class="line">            mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">            <span class="keyword">if</span> (target_node &amp;&amp; target_proc == proc) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//使用LSM进行安全检查</span></span><br><span class="line">        <span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk,</span><br><span class="line">                        target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//flags不带TF_ONE_WAY（即需要reply）并且当前线程存在binder事务栈</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">                ... <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找一个合适的目标binder线程</span></span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">                spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">                from = tmp-&gt;from;</span><br><span class="line">                <span class="keyword">if</span> (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">                    atomic_inc(&amp;from-&gt;tmp_ref);</span><br><span class="line">                    target_thread = from;</span><br><span class="line">                    spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然整个函数很长很复杂，但经过我们的拆分精简，逻辑就清晰很多了</p>
<p><code>binder_transaction_data.target.handle</code>用一个<code>int</code>值表示目标<code>binder</code>引用，当它不为0时，调用<code>binder_get_ref_olocked</code>函数查找<code>binder_ref</code></p>
<h6 id="binder-get-ref-olocked"><a href="#binder-get-ref-olocked" class="headerlink" title="binder_get_ref_olocked"></a>binder_get_ref_olocked</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_ref *<span class="title">binder_get_ref_olocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                         u32 desc, <span class="keyword">bool</span> need_strong_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">proc</span>-&gt;<span class="title">refs_by_desc</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desc &lt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; ref-&gt;data.desc) &#123;</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (need_strong_ref &amp;&amp; !ref-&gt;data.strong) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"tried to use weak ref as strong ref\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个函数就是从<code>binder_proc.refs_by_desc</code>这个红黑树中，通过<code>desc</code>句柄查找到对应的<code>binder</code>引用<code>binder_ref</code>，这样就可以通过<code>binder_ref.node</code>获得到<code>binder</code>实体<code>binder_node</code></p>
<p>接着再调用<code>binder_get_node_refs_for_txn</code>函数通过目标<code>binder</code>实体获取目标进程信息</p>
<h6 id="binder-get-node-refs-for-txn"><a href="#binder-get-node-refs-for-txn" class="headerlink" title="binder_get_node_refs_for_txn"></a>binder_get_node_refs_for_txn</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_get_node_refs_for_txn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_proc **procp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_node_inner_lock(node);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc) &#123;</span><br><span class="line">        target_node = node;</span><br><span class="line">        <span class="comment">//binder_node强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//binder_node临时引用计数加1</span></span><br><span class="line">        binder_inc_node_tmpref_ilocked(node);</span><br><span class="line">        <span class="comment">//binder_proc临时引用计数加1</span></span><br><span class="line">        atomic_inc(&amp;node-&gt;proc-&gt;tmp_ref);</span><br><span class="line">        <span class="comment">//使外部传入的proc指针指向binder_proc地址</span></span><br><span class="line">        *procp = node-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *error = BR_DEAD_REPLY;</span><br><span class="line">    binder_node_inner_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数第二个参数接受一个<code>binder_proc **</code>类型，即指向指针的指针，调用方对<code>proc</code>取地址，即指向<code>proc</code>指针分配在栈上的地址，这样函数中对<code>procp</code>解引用就得到了<code>proc</code>指针本身的地址，即可使<code>proc</code>指针指向<code>binder_proc</code>的地址</p>
<p>当<code>binder_transaction_data.target.handle</code>为0时，表示目标是<code>ServiceManager</code>，而<code>ServiceManager</code>是<code>binder</code>驱动的<code>context</code>，所以可以直接从<code>context</code>中获取<code>binder</code>实体，关于<code>ServiceManager</code>是怎么成为<code>binder</code>驱动的<code>context</code>的，我们会在后面的章节进行分析</p>
<p>接下来做一下安全检查，当<code>flags</code>不带<code>TF_ONE_WAY</code>（即需要<code>reply</code>）并且当前线程存在<code>binder</code>事务栈时，寻找一个合适的目标<code>binder</code>工作线程用来处理此事务（线程复用）</p>
<p>这里<code>client</code>端可能是第一次请求服务，此时<code>binder_thread</code>里是不存在<code>binder</code>事务栈，所以是没法找到目标<code>binder</code>线程的</p>
<h5 id="BC-REPLY"><a href="#BC-REPLY" class="headerlink" title="BC_REPLY"></a>BC_REPLY</h5><p>接着，我们再看<code>BC_REPLY</code>的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//这个事务是发起事务，也就是说我们需要对这个事务做应答</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改指向下一个需要处理的事务，即将这个事务移出链表</span></span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//目标线程即为需要回应的事务的发起线程</span></span><br><span class="line">        target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过binder_thread获得binder_proc</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">        atomic_inc(&amp;target_proc-&gt;tmp_ref);</span><br><span class="line">        binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_txn_from_and_acq_inner</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        struct binder_transaction *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于 from = t-&gt;from; 内部加了锁和引用计数操作</span></span><br><span class="line">    from = binder_get_txn_from(t);</span><br><span class="line">    <span class="keyword">if</span> (!from)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_inner_proc_lock(from-&gt;proc);</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">        BUG_ON(from != t-&gt;from);</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_inner_proc_unlock(from-&gt;proc);</span><br><span class="line">    binder_thread_dec_tmpref(from);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BC_REPLY</code>获取目标进程/线程信息就更简单了，<code>BC_TRANSACTION</code>中我们还需要根据<code>binder</code>句柄来获取各种信息，<code>BC_REPLY</code>我们只需要找到需要回应的那个事务，那个事务所在的线程和进程即为<code>reply</code>事务的目标线程和目标进程</p>
<h4 id="第二部分：数据拷贝，建立映射"><a href="#第二部分：数据拷贝，建立映射" class="headerlink" title="第二部分：数据拷贝，建立映射"></a>第二部分：数据拷贝，建立映射</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">binder_size_t</span> *offp, *off_end, *off_start;</span><br><span class="line">    <span class="keyword">binder_size_t</span> off_min;</span><br><span class="line">    u8 *sg_bufp, *sg_buf_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span></span></span><br><span class="line"><span class="class">    <span class="title">u32</span> <span class="title">secctx_sz</span> = 0;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为目标进程binder事务分配空间（后续会加到目标进程/线程的todo队列中，由目标进程/线程处理这个事务）</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = t_debug_id;</span><br><span class="line">    <span class="comment">//设置事务发起线程</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    t-&gt;sender_euid = task_euid(proc-&gt;tsk);</span><br><span class="line">    <span class="comment">//设置事务处理进程</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">//设置事务处理线程</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">        binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        <span class="comment">/* Inherit supported policies for synchronous transactions */</span></span><br><span class="line">        t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">        t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Otherwise, fall back to the default priority */</span></span><br><span class="line">        t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安全相关</span></span><br><span class="line">    <span class="keyword">if</span> (target_node &amp;&amp; target_node-&gt;txn_security_ctx) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分配缓存，建立映射</span></span><br><span class="line">    t-&gt;<span class="built_in">buffer</span> = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">        !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;transaction = t;</span><br><span class="line">    t-&gt;<span class="built_in">buffer</span>-&gt;target_node = target_node;</span><br><span class="line">    </span><br><span class="line">    off_start = (<span class="keyword">binder_size_t</span> *)(t-&gt;<span class="built_in">buffer</span>-&gt;data +</span><br><span class="line">                      ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    offp = off_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是真正的一次复制</span></span><br><span class="line">    copy_from_user(t-&gt;<span class="built_in">buffer</span>-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.<span class="built_in">buffer</span>, tr-&gt;data_size);</span><br><span class="line">    copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">               tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查数据对齐</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(extra_buffers_size, <span class="keyword">sizeof</span>(u64))) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">    sg_bufp = (u8 *)(PTR_ALIGN(off_end, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    sg_buf_end = sg_bufp + extra_buffers_size -</span><br><span class="line">        ALIGN(secctx_sz, <span class="keyword">sizeof</span>(u64));</span><br><span class="line">    off_min = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环遍历每一个binder对象</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> object_size = binder_validate_object(t-&gt;<span class="built_in">buffer</span>, *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (object_size == <span class="number">0</span> || *offp &lt; off_min) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hdr = (struct binder_object_header *)(t-&gt;<span class="built_in">buffer</span>-&gt;data + *offp);</span><br><span class="line">        off_min = *offp + object_size;</span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">        <span class="comment">//需要对binder类型进行转换</span></span><br><span class="line">        <span class="comment">//因为在A进程中为本地binder对象，对于B进程则为远程binder对象，反之亦然</span></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">            fp = to_flat_binder_object(hdr);</span><br><span class="line">            ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_PTR: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置工作类型</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">//设置目标进程的事务类型</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将这一部分再细分成几个部分：</p>
<ol>
<li>分配缓存，建立映射</li>
<li>数据拷贝</li>
<li><code>binder</code>类型转换</li>
</ol>
<h5 id="分配缓存，建立映射"><a href="#分配缓存，建立映射" class="headerlink" title="分配缓存，建立映射"></a>分配缓存，建立映射</h5><p>我们首先看分配缓存，建立映射是怎么做的，它调用了<code>binder_alloc_new_buf</code>函数，这个函数定义在<code>drivers/android/binder_alloc.c</code>中，内部加了锁后调用了<code>binder_alloc_new_buf_locked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_buffer *<span class="title">binder_alloc_new_buf_locked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> data_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> offsets_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">size_t</span> extra_buffers_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> is_async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> = <span class="title">alloc</span>-&gt;<span class="title">free_buffers</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">best_fit</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *has_page_addr;</span><br><span class="line">    <span class="keyword">void</span> *end_page_addr;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>, data_offsets_size;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc-&gt;vma == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算需要的缓冲区大小</span></span><br><span class="line">    <span class="comment">//这里需要将size对齐void *（32位下占用4字节，64位下占用8字节）</span></span><br><span class="line">    data_offsets_size = ALIGN(data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) +</span><br><span class="line">        ALIGN(offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = data_offsets_size + ALIGN(extra_buffers_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">max</span>(<span class="built_in">size</span>, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从binder_alloc的空闲缓冲红黑树中找到一个大小最合适的binder_buffer</span></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="comment">//当找到一个需求大小和缓存区大小刚好相同的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer就正好指向这个空闲缓存区</span></span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">        BUG_ON(!<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span>);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当只找到一个比需求大小稍大一点的空闲缓存区时</span></span><br><span class="line">        <span class="comment">//此时buffer指向的是这个空闲缓存区所在节点的父节点</span></span><br><span class="line">        <span class="comment">//然后n指向NULL</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span> &lt; buffer_size) &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span> &gt; buffer_size)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            best_fit = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (best_fit == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时buffer指向的是所需求的空闲缓存区所在红黑树节点的父节点</span></span><br><span class="line">    <span class="comment">//需要让其指向真正需求的那个空闲缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">buffer</span> = rb_entry(best_fit, struct binder_buffer, rb_node);</span><br><span class="line">        buffer_size = binder_alloc_buffer_size(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出buffer的终点，向下对齐（不能超过可用的buffer_size）</span></span><br><span class="line">    has_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)(((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + buffer_size) &amp; PAGE_MASK);</span><br><span class="line">    WARN_ON(n &amp;&amp; buffer_size != <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//计算出实际上我们接收数据需要的空间的终点，向上映射</span></span><br><span class="line">    end_page_addr =</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>);</span><br><span class="line">    <span class="comment">//如果超出了可用的buffer_size，恢复到正常可用的结束地址</span></span><br><span class="line">    <span class="keyword">if</span> (end_page_addr &gt; has_page_addr)</span><br><span class="line">        end_page_addr = has_page_addr;</span><br><span class="line">    <span class="comment">//分配物理页，建立映射</span></span><br><span class="line">    ret = binder_update_page_range(alloc, <span class="number">1</span>,</span><br><span class="line">        (<span class="keyword">void</span> *)PAGE_ALIGN((<span class="keyword">uintptr_t</span>)<span class="built_in">buffer</span>-&gt;data), end_page_addr);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有空余空间的话，分隔这个buffer，剩余的buffer加入到空闲缓存区红黑树中（合理利用空间）</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_size != <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span>;</span></span><br><span class="line"></span><br><span class="line">        new_buffer = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">        new_buffer-&gt;data = (u8 *)<span class="built_in">buffer</span>-&gt;data + <span class="built_in">size</span>;</span><br><span class="line">        list_add(&amp;new_buffer-&gt;entry, &amp;<span class="built_in">buffer</span>-&gt;entry);</span><br><span class="line">        new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        binder_insert_free_buffer(alloc, new_buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们已经使用了这个buffer，要将其从空闲缓存区红黑树中移除</span></span><br><span class="line">    rb_erase(best_fit, &amp;alloc-&gt;free_buffers);</span><br><span class="line">    <span class="comment">//标记为非空闲</span></span><br><span class="line">    <span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//插入到已分配缓存区红黑树中</span></span><br><span class="line">    binder_insert_allocated_buffer_locked(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;data_size = data_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;offsets_size = offsets_size;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;async_transaction = is_async;</span><br><span class="line">    <span class="built_in">buffer</span>-&gt;extra_buffers_size = extra_buffers_size;</span><br><span class="line">    <span class="comment">//如果是异步事件, 那么更新binder_alloc的异步事件空闲buffer</span></span><br><span class="line">    <span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">        alloc-&gt;free_async_space -= <span class="built_in">size</span> + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">buffer</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的整体逻辑分为三个部分：</p>
<ol>
<li>找到可用的空闲内核缓存区，计算我们需要分配的大小</li>
<li>分配物理页，建立映射</li>
<li>初始化新分配的<code>buffer</code></li>
</ol>
<p>其中1、3部分已经用注释标出来了，应该还是比较好理解的，我们终点看一下第2部分：怎么分配物理页，建立映射</p>
<p>我们在上一章<a href="https://juejin.cn/post/7062654742329032740#heading-16" target="_blank" rel="noopener">Android源码分析 - Binder驱动（上）</a>中说到，<code>binder_mmap</code>并没有立即将内核虚拟内存和进程虚拟内存与物理内存做映射，实际上这个映射操作是在<code>binder_update_page_range</code>这里做的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_alloc *alloc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_lru_page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> need_mm = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">end</span> &lt;= start)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_range;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否有页框需要分配</span></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        page = &amp;alloc-&gt;pages[(page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE];</span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            need_mm = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向目标用户进程的内存空间描述体</span></span><br><span class="line">    <span class="keyword">if</span> (need_mm &amp;&amp; atomic_inc_not_zero(&amp;alloc-&gt;vma_vm_mm-&gt;mm_users))</span><br><span class="line">        mm = alloc-&gt;vma_vm_mm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//获取mm_struct的读信号量</span></span><br><span class="line">        down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        <span class="comment">//检查mm是否有效</span></span><br><span class="line">        <span class="keyword">if</span> (!mmget_still_valid(mm)) &#123;</span><br><span class="line">            <span class="comment">//释放</span></span><br><span class="line">            <span class="keyword">if</span> (allocate == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> free_range;</span><br><span class="line">            <span class="comment">//错误</span></span><br><span class="line">            <span class="keyword">goto</span> err_no_vma;</span><br><span class="line">        &#125;</span><br><span class="line">        vma = alloc-&gt;vma;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma &amp;&amp; need_mm) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; <span class="built_in">end</span>; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">bool</span> on_lru;</span><br><span class="line">        <span class="keyword">size_t</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指向对应页框地址，为后面赋值做准备</span></span><br><span class="line">        index = (page_addr - alloc-&gt;<span class="built_in">buffer</span>) / PAGE_SIZE;</span><br><span class="line">        page = &amp;alloc-&gt;pages[index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//page-&gt;page_ptr不为NULL说明之前已经分配并映射过了</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;page_ptr) &#123;</span><br><span class="line">            on_lru = list_lru_del(&amp;binder_alloc_lru, &amp;page-&gt;lru);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配一个页的物理内存</span></span><br><span class="line">        page-&gt;page_ptr = alloc_page(GFP_KERNEL |</span><br><span class="line">                        __GFP_HIGHMEM |</span><br><span class="line">                        __GFP_ZERO);</span><br><span class="line">        <span class="comment">//未分配成功</span></span><br><span class="line">        <span class="keyword">if</span> (!page-&gt;page_ptr) &#123;</span><br><span class="line">            ... <span class="comment">//error</span></span><br><span class="line">        &#125;</span><br><span class="line">        page-&gt;alloc = alloc;</span><br><span class="line">        INIT_LIST_HEAD(&amp;page-&gt;lru);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将物理内存空间映射到内核虚拟内存空间</span></span><br><span class="line">        ret = map_kernel_range_noflush((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                           PAGE_SIZE, PAGE_KERNEL,</span><br><span class="line">                           &amp;page-&gt;page_ptr);</span><br><span class="line">        flush_cache_vmap((<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>)page_addr + PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据之前计算的user_buffer_offset可以直接得到目标用户空间进程虚拟内存地址</span></span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + alloc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">//将物理内存空间映射到目标用户进程虚拟内存空间</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>].page_ptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index + <span class="number">1</span> &gt; alloc-&gt;pages_high)</span><br><span class="line">            alloc-&gt;pages_high = index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">//释放mm_struct的读信号量</span></span><br><span class="line">        up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的注释写的应该比较清楚了，总之就是先分配<code>物理内存</code>，再将这块<code>物理内存</code>分别映射到<code>内核虚拟空间</code>和<code>用户进程虚拟空间</code>，这样<code>内核虚拟空间</code>与<code>用户进程虚拟空间</code>相当于也间接的建立了映射关系</p>
<p>关于物理内存的分配以及映射，就是<code>Linux</code>内核层的事情了，感兴趣的同学可以再深入往里看看，这里就不再多说了</p>
<h5 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h5><p>关于数据拷贝这部分就不用多说了，物理内存已经分配好了，映射也建立了，接下来直接调用<code>copy_from_user</code>将数据从用户空间拷贝至映射的那块内存就可以了</p>
<h5 id="binder类型转换"><a href="#binder类型转换" class="headerlink" title="binder类型转换"></a>binder类型转换</h5><p>最后循环遍历每一个<code>binder</code>对象，对其中每一个<code>binder</code>对象类型做转换，因为在一个进程中为本地<code>binder</code>对象，对于另一个进程则为远程<code>binder</code>对象，反之亦然</p>
<h6 id="flat-binder-object结构体"><a href="#flat-binder-object结构体" class="headerlink" title="flat_binder_object结构体"></a>flat_binder_object结构体</h6><p>这里就是我们之前提到的，<code>binder</code>对象在传输过程中会被 “压扁” 的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    <span class="comment">//描述了binder对象的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span>	<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="comment">//和binder_transaction_data中flags含义相同</span></span><br><span class="line">    __u32				flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_BINDER时，表示是一个binder实体对象，指向binder实体在用户空间的地址</span></span><br><span class="line">        <span class="keyword">binder_uintptr_t</span>	binder;	<span class="comment">/* local object */</span></span><br><span class="line">        <span class="comment">//当hdr.type == BINDER_TYPE_HANDLE，表示是一个binder引用句柄</span></span><br><span class="line">        __u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////当hdr.type == BINDER_TYPE_BINDER时才有值，表示携带的额外数据</span></span><br><span class="line">    <span class="comment">/* extra data associated with local object */</span></span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-binder"><a href="#binder-translate-binder" class="headerlink" title="binder_translate_binder"></a>binder_translate_binder</h6><p><code>BINDER_TYPE_BINDER</code>表示是一个<code>binder</code>实体对象，需要将它转换成<code>binder</code>引用句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_binder</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过proc-&gt;nodes.rb_node红黑树查找binder_node</span></span><br><span class="line">    node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">    <span class="comment">//如果没有找到，新建一个binder_node并将其插入红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        node = binder_new_node(proc, fp);</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">        ... <span class="comment">//error</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找binder_ref并将其引用计数加1，如果没有查找到则创建一个，并将其插入红黑树</span></span><br><span class="line">    ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">            &amp;thread-&gt;todo, &amp;rdata);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//转换binder类型</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//binder引用句柄赋值</span></span><br><span class="line">    fp-&gt;handle = rdata.desc;</span><br><span class="line">    fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="binder-translate-handle"><a href="#binder-translate-handle" class="headerlink" title="binder_translate_handle"></a>binder_translate_handle</h6><p><code>BINDER_TYPE_HANDLE</code>表示是一个<code>binder</code>引用句柄，，需要将它转换成<code>binder</code>实体对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_translate_handle</span><span class="params">(struct flat_binder_object *fp,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">thread</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span> = <span class="title">t</span>-&gt;<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">src_rdata</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从proc-&gt;refs_by_desc.rb_node红黑树中查找binder_node，并将其临时引用计数加1</span></span><br><span class="line">    node = binder_get_node_from_ref(proc, fp-&gt;handle,</span><br><span class="line">            fp-&gt;hdr.type == BINDER_TYPE_HANDLE, &amp;src_rdata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    <span class="comment">//如果binder实体所在的进程为事务处理进程</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;proc == target_proc) &#123;</span><br><span class="line">        <span class="comment">//binder类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_HANDLE)</span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp-&gt;hdr.type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">        fp-&gt;binder = node-&gt;ptr;</span><br><span class="line">        fp-&gt;cookie = node-&gt;cookie;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_lock(node-&gt;proc);</span><br><span class="line">        <span class="comment">//binder强引用计数加1</span></span><br><span class="line">        binder_inc_node_nilocked(node,</span><br><span class="line">                     fp-&gt;hdr.type == BINDER_TYPE_BINDER,</span><br><span class="line">                     <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;proc)</span><br><span class="line">            binder_inner_proc_unlock(node-&gt;proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//重新查找binder_ref</span></span><br><span class="line">        struct binder_ref_data dest_rdata;</span><br><span class="line"></span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        ret = binder_inc_ref_for_node(target_proc, node,</span><br><span class="line">                fp-&gt;hdr.type == BINDER_TYPE_HANDLE,</span><br><span class="line">                <span class="literal">NULL</span>, &amp;dest_rdata);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">        fp-&gt;binder = <span class="number">0</span>;</span><br><span class="line">        fp-&gt;handle = dest_rdata.desc;</span><br><span class="line">        fp-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">//binder_node临时引用计数减1</span></span><br><span class="line">    binder_put_node(node);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第三部分：加入todo队列，唤醒目标线程"><a href="#第三部分：加入todo队列，唤醒目标线程" class="headerlink" title="第三部分：加入todo队列，唤醒目标线程"></a>第三部分：加入todo队列，唤醒目标线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;    <span class="comment">//如果请求码为BC_REPLY</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        binder_inner_proc_lock(target_proc);</span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">            binder_inner_proc_unlock(target_proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将发起事务从目标binder线程的事务链表中移除</span></span><br><span class="line">        binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">        binder_inner_proc_unlock(target_proc);</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">        <span class="comment">//恢复发起事务的优先级</span></span><br><span class="line">        binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">        <span class="comment">//释放发起事务</span></span><br><span class="line">        binder_free_transaction(in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且不为异步操作，需要返回</span></span><br><span class="line">        binder_inner_proc_lock(proc);</span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中（这里会延迟执行BINDER_WORK_TRANSACTION_COMPLETE）</span></span><br><span class="line">        binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">        <span class="comment">//设置为需要回应</span></span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//插入事务链表中</span></span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标线程的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">            binder_inner_proc_lock(proc);</span><br><span class="line">            <span class="comment">//出错后，移除该事务</span></span><br><span class="line">            binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">            binder_inner_proc_unlock(proc);</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//如果请求码为BC_TRANSACTION并且为异步操作，不需要返回</span></span><br><span class="line">        <span class="comment">//将tcomplete插入到事务发起binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入目标进程的某个线程（或目标进程）的todo队列中并唤醒目标进程</span></span><br><span class="line">        <span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>))</span><br><span class="line">            <span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减临时引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread)</span><br><span class="line">        binder_thread_dec_tmpref(target_thread);</span><br><span class="line">    binder_proc_dec_tmpref(target_proc);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_dec_node_tmpref(target_node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一块的代码基本上格式都是一样的，都是将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，<code>t-&gt;work</code>插入到目标<code>binder</code>线程的<code>todo</code>队列中，最后唤醒目标进程</p>
<p>这里需要注意的是，在<code>BC_TRANSACTION</code>的情况下，需要区分事务的<code>flags</code>中是否包含<code>TF_ONE_WAY</code>，这意味着这个事务是否需要回应</p>
<p>在没有<code>TF_ONE_WAY</code>的情况下，会使用<code>binder_enqueue_deferred_thread_work_ilocked</code>函数将<code>tcomplete</code>插入到事务发起<code>binder</code>线程的<code>todo</code>队列中，这个函数区别于<code>binder_enqueue_thread_work_ilocked</code>函数，它没有将<code>thread-&gt;process_todo</code>设为<code>true</code>，这个标记在之前介绍<code>binder_thread</code>结构体的时候提到了，当其为<code>false</code>的情况下会在<code>binder_thread_read</code>中休眠，延迟执行<code>BINDER_WORK_TRANSACTION_COMPLETE</code>，具体是怎么操作的，我们会在后续的<code>binder_thread_read</code>函数中进行分析</p>
<p>在<code>TF_ONE_WAY</code>的情况下，我们是没有去寻找合适的目标处理<code>binder</code>线程的，关于这一点，我们需要看一下<code>binder_proc_transaction</code>函数是怎么处理没有传入<code>binder_thread</code>的情况的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">binder_proc_transaction</span><span class="params">(struct binder_transaction *t,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">node_prio</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> oneway = !!(t-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    <span class="keyword">bool</span> pending_async = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    binder_node_lock(node);</span><br><span class="line">    node_prio.prio = node-&gt;min_priority;</span><br><span class="line">    node_prio.sched_policy = node-&gt;sched_policy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了TF_ONE_WAY标志</span></span><br><span class="line">    <span class="keyword">if</span> (oneway) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;has_async_transaction) &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象正在处理一个异步事务，做一个标记</span></span><br><span class="line">            pending_async = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果binder实体对象没有正在处理一个异步事务，将has_async_transaction置为true，表示接下来要处理一个异步任务</span></span><br><span class="line">            node-&gt;has_async_transaction = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_lock(proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果目标进程死亡或者目标线程不为NULL且死亡</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;is_dead || (thread &amp;&amp; thread-&gt;is_dead)) &#123;</span><br><span class="line">        binder_inner_proc_unlock(proc);</span><br><span class="line">        binder_node_unlock(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有传入目标线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!thread &amp;&amp; !pending_async)</span><br><span class="line">        <span class="comment">//从proc-&gt;waiting_threads链表中取出第一个节点元素（没有的话则为NULL）</span></span><br><span class="line">        thread = binder_select_thread_ilocked(proc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;    <span class="comment">//当找到了合适的binder线程</span></span><br><span class="line">        <span class="comment">//设置事务优先级</span></span><br><span class="line">        binder_transaction_priority(thread-&gt;task, t, node_prio,</span><br><span class="line">                        node-&gt;inherit_rt);</span><br><span class="line">        <span class="comment">//将t-&gt;work插入到目标binder线程的todo队列中</span></span><br><span class="line">        binder_enqueue_thread_work_ilocked(thread, &amp;t-&gt;work);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_async) &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder进程的todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;proc-&gt;todo);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//没有找到合适的binder线程，且目标binder实体对象正在处理一个异步事务</span></span><br><span class="line">        <span class="comment">//将t-&gt;work加入到目标binder实体的async_todo队列中</span></span><br><span class="line">        binder_enqueue_work_ilocked(&amp;t-&gt;work, &amp;node-&gt;async_todo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标binder实体对象没有正在处理一个异步事务</span></span><br><span class="line">    <span class="keyword">if</span> (!pending_async)</span><br><span class="line">        <span class="comment">//唤醒目标binder线程的等待队列</span></span><br><span class="line">        binder_wakeup_thread_ilocked(proc, thread, !oneway <span class="comment">/* sync */</span>);</span><br><span class="line"></span><br><span class="line">    binder_inner_proc_unlock(proc);</span><br><span class="line">    binder_node_unlock(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有传入目标<code>binder</code>线程时，从目标进程的等待线程链表中取出第一个<code>binder_thread</code>作为处理线程处理该事务，如果没找到合适的空闲线程，分为两种情况：</p>
<ol>
<li>目标<code>binder</code>实体对象正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>实体的<code>async_todo</code>队列中</li>
<li>目标<code>binder</code>实体对象没有正在处理一个异步事务：将相应的<code>binder_work</code>插入到目标<code>binder</code>进程的<code>todo</code>队列中</li>
</ol>
<p>关于<code>binder</code>驱动是怎么从这些<code>todo</code>队列取出<code>binder_work</code>并处理的，我们马上在后面<code>binder_thread_read</code>里分析，这里我们最后再看一下如何唤醒目标<code>binder</code>线程的等待队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_thread_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                     struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert_spin_locked(&amp;proc-&gt;inner_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sync)</span><br><span class="line">            wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有找到一个可用的等待线程，可能在两种情况下发生：</span></span><br><span class="line">    <span class="comment">//1. 所有线程都忙于处理事务</span></span><br><span class="line">    <span class="comment">//在这种情况下，这些线程中的一个应该很快回调到内核驱动程序并执行这项工作</span></span><br><span class="line">    <span class="comment">//2. 线程正在使用epoll轮询，在这种情况下，它们可能在没有被添加到waiting_threads的情况下被阻塞在等待队列上</span></span><br><span class="line">    <span class="comment">//对于这种情况，我们只循环获取所有不处理事务工作的线程，并将它们全部唤醒</span></span><br><span class="line">    binder_wakeup_poll_threads_ilocked(proc, sync);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数也有可能<code>binder_thread</code>参数传入NULL，在这种情况下，我们需要循环获取目标进程下的所有<code>binder</code>线程，对所有不处理事务工作的线程全部执行唤醒操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_wakeup_poll_threads_ilocked</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> sync)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;threads); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        thread = rb_entry(n, struct binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_POLL &amp;&amp;</span><br><span class="line">            binder_available_for_proc_work_ilocked(thread)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sync)</span><br><span class="line">                wake_up_interruptible_sync(&amp;thread-&gt;wait);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                wake_up_interruptible(&amp;thread-&gt;wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经分析了<code>binder_ioctl</code>函数的一半<code>binder_thread_write</code>，了解了一些相关的数据结构，并且补充了<code>binder_mmap</code>篇未完成的内存映射的分析，大家应该对<code>binder</code>请求的发起与调度有了一个初步的认识了</p>
<p>本来这一篇是打算把整个<code>binder_ioctl</code>分析完的，但没想到写到后面内容这么多，只好再分一篇，下一篇我们将分析<code>binder_thread_read</code>，将<code>binder</code>驱动篇完结</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/09/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - Binder驱动（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-09</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以aosp分支<code>android-11.0.0_r25</code>，kernel分支<code>android-msm-wahoo-4.4-android11</code>作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7059601252367204365" target="_blank" rel="noopener" title="Android源码分析 - Binder概述">Android源码分析 - Binder概述</a>我们大概了解了一下<code>Android</code>选用<code>Binder</code>的原因，以及<code>Binder</code>的基本结构和通信过程。今天，我们便开始从<code>Binder</code>驱动层代码开始分析<code>Binder</code>的机制</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><code>Binder</code>驱动部分代码不在<code>AOSP</code>项目中，所以我们需要单独<code>clone</code>一份驱动代码</p>
<p>由于我的开发设备是pixel2，查了<code>Linux</code>内核版本号为<code>4.4.223</code>，对应的分支为<code>android-msm-wahoo-4.4-android11</code>，所以今天的分析我们也是基于此分支</p>
<p>我是从清华大学镜像站<code>clone</code>的代码，高通的设备，所以地址为：<a href="https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git" target="_blank" rel="noopener">https://aosp.tuna.tsinghua.edu.cn/android/kernel/msm.git</a></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p><code>binder</code>驱动的源码位于<code>drivers/android</code>目录下，我们从<code>binder.c</code>文件看起</p>
<h2 id="Linux-initcall机制"><a href="#Linux-initcall机制" class="headerlink" title="Linux initcall机制"></a>Linux initcall机制</h2><p>在<code>binder.c</code>的最底下，我们可以看到这一行代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>

<p>在<code>Linux</code>内核中，驱动程序通常是用<code>xxx_initcall(fn)</code>启动的，这实际上是一个宏定义，被定义在平台对应的<code>init.h</code>文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> early_initcall(fn) __define_initcall(fn, early)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pure_initcall(fn) __define_initcall(fn, 0) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall(fn) __define_initcall(fn, 1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> core_initcall_sync(fn) __define_initcall(fn, 1s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall(fn) __define_initcall(fn, 2) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> postcore_initcall_sync(fn) __define_initcall(fn, 2s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall(fn) __define_initcall(fn, 3) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arch_initcall_sync(fn) __define_initcall(fn, 3s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall(fn) __define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> subsys_initcall_sync(fn) __define_initcall(fn, 4s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall(fn) __define_initcall(fn, 5) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fs_initcall_sync(fn) __define_initcall(fn, 5s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rootfs_initcall(fn) __define_initcall(fn, rootfs) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall(fn) __define_initcall(fn, 6) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> device_initcall_sync(fn) __define_initcall(fn, 6s) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall(fn) __define_initcall(fn, 7) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> late_initcall_sync(fn) __define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，实际上调用的是<code>__define_initcall()</code>函数，这个函数的第二个参数表示优先级，数字越小，优先级越高，带s的优先级低于不带s的优先级</p>
<p>在Linux内核启动过程中，需要调用各种函数，在底层实现是通过在内核镜像文件中，自定义一个段，这个段里面专门用来存放这些初始化函数的地址，内核启动时，只需要在这个段地址处取出函数指针，一个个执行即可，而<code>__define_initcall()</code>函数，就是将自定义的init函数添加到上述段中</p>
<h2 id="binder-init"><a href="#binder-init" class="headerlink" title="binder_init"></a>binder_init</h2><p>了解了以上函数定义后，我们再回头看<code>device_initcall(binder_init)</code>就可以知道，在<code>Linux</code>内核启动时，会调用<code>binder_init</code>这么一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *device_name, *device_names, *device_tmp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">device</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化binder内存回收</span></span><br><span class="line">    ret = binder_alloc_shrinker_init();</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个单线程工作队列，用于处理异步任务</span></span><br><span class="line">    binder_deferred_workqueue = create_singlethread_workqueue(<span class="string">"binder"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!binder_deferred_workqueue)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建binder/proc目录</span></span><br><span class="line">    binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">        binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>,</span><br><span class="line">                         binder_debugfs_dir_entry_root);</span><br><span class="line">    <span class="comment">//在binder目录下创建5个文件</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">        debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_state_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"stats"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_stats_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transactions"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;binder_transactions_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">        debugfs_create_file(<span class="string">"failed_transaction_log"</span>,</span><br><span class="line">                    <span class="number">0444</span>,</span><br><span class="line">                    binder_debugfs_dir_entry_root,</span><br><span class="line">                    &amp;binder_transaction_log_failed,</span><br><span class="line">                    &amp;binder_transaction_log_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//"binder,hwbinder,vndbinder"</span></span><br><span class="line">    device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">    device_tmp = device_names;</span><br><span class="line">    <span class="comment">//用binder,hwbinder,vndbinder分别调用init_binder_device函数</span></span><br><span class="line">    <span class="keyword">while</span> ((device_name = strsep(&amp;device_tmp, <span class="string">","</span>))) &#123;</span><br><span class="line">        ret = init_binder_device(device_name);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            <span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err_init_binder_device_failed:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">err_alloc_device_names_failed:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将重点放在<code>init_binder_device</code>函数上</p>
<h2 id="init-binder-device"><a href="#init-binder-device" class="headerlink" title="init_binder_device"></a>init_binder_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">    binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!binder_device)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//binder注册虚拟字符设备所对应的file_operations</span></span><br><span class="line">    binder_device-&gt;miscdev.fops = &amp;binder_fops;</span><br><span class="line">    <span class="comment">//动态分配次设备号</span></span><br><span class="line">    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">    binder_device-&gt;miscdev.name = name;</span><br><span class="line"></span><br><span class="line">    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">    binder_device-&gt;context.name = name;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line">    <span class="comment">//注册misc设备</span></span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(binder_device);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将binder设备加入链表（头插法）</span></span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先构造了一个结构体用来存放<code>binder</code>参数，然后通过<code>misc_register</code>函数，以<code>misc</code>设备进行注册<code>binder</code>，作为虚拟字符设备</p>
<h3 id="注册misc设备"><a href="#注册misc设备" class="headerlink" title="注册misc设备"></a>注册misc设备</h3><p>我们先学习一下在<code>Linux</code>中如何注册一个<code>misc</code>设备</p>
<p>在Linux驱动中把无法归类的五花八门的设备定义为<code>misc</code>设备，<code>Linux</code>内核所提供的<code>misc</code>设备有很强的包容性，各种无法归结为标准字符设备的类型都可以定义为<code>misc</code>设备，譬如NVRAM，看门狗，实时时钟，字符LCD等</p>
<p>在<code>Linux</code>内核里把所有的<code>misc</code>设备组织在一起，构成了一个子系统(<code>subsys</code>)，统一进行管理。在这个子系统里的所有<code>miscdevice</code>类型的设备共享一个主设备号<code>MISC_MAJOR</code>(10)，但次设备号不同</p>
<p>在内核中用<code>miscdevice</code>结构体表示<code>misc</code>设备，具体的定义在<code>include/linux/miscdevice.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span>  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">this_device</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *nodename;</span><br><span class="line">    <span class="keyword">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们自己注册<code>misc</code>设备时只需要填入前3项即可：</p>
<ul>
<li><code>minor</code>：次设备号，如果填充<code>MISC_DYNAMIC_MINOR</code>，则由内核动态分配次设备号</li>
<li><code>name</code>：设备名</li>
<li><code>fops</code>：<code>file_operations</code>结构体，用于定义自己<code>misc</code>设备的文件操作函数，如果不填此项则会使用默认的<code>misc_fops</code></li>
</ul>
<p><code>file_operations</code>结构体被定义在<code>include/linux/fs.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">flush</span>) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">    <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">              <span class="keyword">loff_t</span> len);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>file_operation</code>是把系统调用和驱动程序关联起来的关键结构，这个结构的每一个成员都对应着一个系统调用，<code>Linux</code>系统调用通过读取<code>file_operation</code>中相应的函数指针，接着把控制权转交给函数，从而完成<code>Linux</code>设备驱动程序的工作</p>
<p>最后调用<code>misc_register</code>函数注册<code>misc</code>设备，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">misc_register</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br><span class="line"><span class="comment">//卸载misc设备</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">misc_deregister</span><span class="params">(struct miscdevice *misc)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="注册binder设备"><a href="#注册binder设备" class="headerlink" title="注册binder设备"></a>注册binder设备</h3><p>了解了<code>misc</code>设备的注册，我们就可以看一下<code>binder</code>的注册过程了，代码中先构建了一个<code>binder_device</code>结构体，我们先观察一下这个结构体长什么样子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>hlist_node</code>是链表中的一个节点，<code>miscdevice</code>就是上文所描述的注册<code>misc</code>所必要的结构体参数，<code>binder_context</code>用于保存<code>binder</code>上下文管理者的信息</p>
<p>回到代码中，首先给<code>miscdevice</code>赋了值，指定了<code>file_operation</code>，设置了<code>minor</code>动态分配次设备号，<code>binder_context</code>则是简单初始化了一下，然后便调用<code>misc_register</code>函数注册<code>misc</code>设备，最后将这个<code>binder</code>设备使用头插法加入到一个全局链表中</p>
<p>我们看一下它指定的<code>file_operation</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .<span class="built_in">open</span> = binder_open,</span><br><span class="line">    .<span class="built_in">flush</span> = binder_flush,</span><br><span class="line">    .<span class="built_in">release</span> = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>binder</code>驱动支持以上7种系统调用，接下来，我们就逐一分析这些系统调用</p>
<h1 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a>binder_proc</h1><p>在分析这些系统调用前，我们有必要先了解一下在<code>binder</code>中非常重要的结构体<code>binder_proc</code>，它是用来描述进程上下文信息以及管理IPC的一个结构体，被定义在<code>drivers/android/binder.c</code>中，是一个私有的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="comment">//hash链表中的一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="comment">//处理用户请求的线程组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="comment">//binder实体组成的红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以句柄来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="comment">//binder引用组成的红黑树，以它对应的binder实体的地址来排序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_threads</span>;</span></span><br><span class="line">    <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">//进程描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="comment">//进程打开的所有文件数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">files_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> deferred_work;</span><br><span class="line">    <span class="keyword">bool</span> is_dead;</span><br><span class="line">    <span class="comment">//待处理事件队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;</span><br><span class="line">    <span class="keyword">atomic_t</span> tmp_ref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">default_priority</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">    <span class="comment">//用来记录mmap分配的用户虚拟地址空间和内核虚拟地址空间等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_alloc</span> <span class="title">alloc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> inner_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> outer_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h1><p>我们先从打开<code>binder</code>驱动设备开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//管理IPC和保存进程信息的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_dev</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//初始化内核同步自旋锁</span></span><br><span class="line">    spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">    <span class="comment">//原子操作赋值</span></span><br><span class="line">    atomic_set(&amp;proc-&gt;tmp_ref, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//使执行当前系统调用进程的task_struct.usage加1</span></span><br><span class="line">    get_task_struct(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">//使binder_proc中的tsk指向执行当前系统调用的进程</span></span><br><span class="line">    proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">//初始化文件锁</span></span><br><span class="line">    mutex_init(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//初始化todo列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">//设置优先级</span></span><br><span class="line">    <span class="keyword">if</span> (binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">        proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">        proc-&gt;default_priority.prio = NICE_TO_PRIO(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到binder_device结构体的首地址</span></span><br><span class="line">    binder_dev = container_of(filp-&gt;private_data, struct binder_device,</span><br><span class="line">                  miscdev);</span><br><span class="line">    <span class="comment">//使binder_proc的上下文指向binder_device的上下文</span></span><br><span class="line">    proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">    <span class="comment">//初始化binder缓冲区</span></span><br><span class="line">    binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">//全局binder_stats结构体中，BINDER_STAT_PROC类型的对象创建数量加1</span></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">//设置当前进程id</span></span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    <span class="comment">//初始化已分发的死亡通知列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    <span class="comment">//初始化等待线程列表</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line">    <span class="comment">//保存binder_proc数据</span></span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为binder支持多线程，所以需要加锁</span></span><br><span class="line">    mutex_lock(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">//将binder_proc添加到binder_procs全局链表中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在binder/proc目录下创建文件，以执行当前系统调用的进程id为名</span></span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">        <span class="keyword">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(strbuf, <span class="keyword">sizeof</span>(strbuf), <span class="string">"%u"</span>, proc-&gt;pid);</span><br><span class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">            binder_debugfs_dir_entry_proc,</span><br><span class="line">            (<span class="keyword">void</span> *)(<span class="keyword">unsigned</span> <span class="keyword">long</span>)proc-&gt;pid,</span><br><span class="line">            &amp;binder_proc_fops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>binder_open</code>函数创建了<code>binder_proc</code>结构体，并把初始化并将当前进程等信息保存到<code>binder_proc</code>结构体中，然后将<code>binder_proc</code>结构体保存到文件指针<code>filp</code>的<code>private_data</code>中，再将<code>binder_proc</code>加入到全局链表<code>binder_procs</code>中</p>
<p>这里面有一些关于<code>Linux</code>的知识需要解释一下</p>
<h2 id="spinlock"><a href="#spinlock" class="headerlink" title="spinlock"></a>spinlock</h2><p><code>spinlock</code>是内核中提供的一种自旋锁机制。在<code>Linux</code>内核实现中，常常会碰到共享数据被中断上下文和进程上下文访问的场景，如果只有进程上下文的话，我们可以使用互斥锁或者信号量解决，将未获得锁的进程置为睡眠状态等待，但由于中断上下文不是一个进程，它不存在<code>task_struct</code>，所以不可被调度，当然也就不可睡眠，这时候就可以通过<code>spinlock</code>自旋锁的忙等待机制来达成睡眠同样的效果</p>
<h2 id="current"><a href="#current" class="headerlink" title="current"></a>current</h2><p>在<code>Linux</code>内核中，定义了一个叫<code>current</code>的宏，它被定义在<code>asm/current.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct task_struct *<span class="title">get_current</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(current_thread_info()-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	current	get_current()</span></span><br></pre></td></tr></table></figure>

<p>它返回一个<code>task_struct</code>指针，指向执行当前这段内核代码的进程</p>
<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p><code>container_of</code>也是<code>Linux</code>中定义的一个宏，它的作用是根据一个结构体变量中的一个域成员变量的指针来获取指向整个结构体变量的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER)	((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;              \         </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \         </span><br><span class="line">    (type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="fd-amp-filp"><a href="#fd-amp-filp" class="headerlink" title="fd&amp;filp"></a>fd&amp;filp</h2><p><code>filp-&gt;private_data</code>保存了<code>binder_proc</code>结构体，当进程调用<code>open</code>系统函数时，内核会返回一个文件描述符<code>fd</code>，这个<code>fd</code>指向文件指针<code>filp</code>，在后续调用<code>mmap</code>，<code>ioctl</code>等函数与<code>binder</code>驱动交互时，会传入这个<code>fd</code>，内核就会以这个<code>fd</code>指向文件指针<code>filp</code>作为参数调用<code>binder_mmap</code>，<code>binder_ioctl</code>等函数，这样这些函数就可以通过<code>filp-&gt;private_data</code>取出<code>binder_proc</code>结构体</p>
<h1 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h1><h2 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h2><p>在分析<code>mmap</code>前，我们需要先了解一下<code>vm_area_struct</code>这个结构体，它被定义在<code>include/linux/mm_types.h</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//当前vma的首地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;</span><br><span class="line">    <span class="comment">//当前vma的末地址后第一个字节的地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="comment">//红黑树中对应节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma前面还有多少空闲空间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_gap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma所属的内存地址空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="comment">//vma标识集，定义在 include/linux/mm.h 中</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> rb_subtree_last;</span><br><span class="line">        &#125; shared;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> __user *anon_name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma操作函数集指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前vma起始地址在vm_file中的文件偏移，单位为物理页面PAGE_SIZE</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;</span><br><span class="line">    <span class="comment">//被映射的文件（如果使用文件映射）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vm_area_struct</code>结构体描述了一段虚拟内存空间，通常，进程所使用到的虚拟内存空间不连续，且各部分虚存空间的访问属性也可能不同，所以一个进程的虚拟内存空间需要多个<code>vm_area_struct</code>结构来描述（后面简称<code>vma</code>）</p>
<p>每个进程都有一个对应的<code>task_struct</code>结构描述，这个<code>task_struct</code>结构中有一个<code>mm_struct</code>结构用于描述进程的内存空间，<code>mm_struct</code>结构中有两个域成员变量分别指向了<code>vma</code>链表头和红黑树根</p>
<p><code>vma</code>所描述的虚拟内存空间范围由<code>vm_start</code>和<code>vm_end</code>表示，<code>vm_start</code>代表当前<code>vma</code>的首地址，<code>vm_end</code>代表当前<code>vma</code>的末地址后第一个字节的地址，即虚拟内存空间范围为<code>[vm_start, vm_end)</code></p>
<p><code>vm_operations_struct</code>和上文中的<code>file_operations</code>类似，用来定义虚拟内存的操作函数</p>
<hr>
<p>介绍完<code>vma</code>，接下来我们便看一下<code>binder_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验进程信息</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将虚拟内存地址大小限制在4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//检查用户空间是否可写（FORBIDDEN_MMAP_FLAGS == VM_WRITE）</span></span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">        ret = -EPERM;</span><br><span class="line">        failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//VM_DONTCOPY表示此vma不可被fork所复制</span></span><br><span class="line">    vma-&gt;vm_flags |= VM_DONTCOPY | VM_MIXEDMAP;</span><br><span class="line">    <span class="comment">//用户空间不可设置该vma的VM_WRITE标志</span></span><br><span class="line">    vma-&gt;vm_flags &amp;= ~VM_MAYWRITE;</span><br><span class="line">    <span class="comment">//设置此vma操作函数集</span></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    <span class="comment">//指向binder_proc</span></span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理进程虚拟内存空间与内核虚拟地址空间的映射关系</span></span><br><span class="line">    ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    mutex_lock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="comment">//获取进程的打开文件信息结构体files_struct，并将引用计数加1</span></span><br><span class="line">    proc-&gt;files = get_files_struct(current);</span><br><span class="line">    mutex_unlock(&amp;proc-&gt;files_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">    pr_err(<span class="string">"%s: %d %lx-%lx %s failed %d\n"</span>, __func__,</span><br><span class="line">           proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先从<code>filp</code>中获取对应的<code>binder_proc</code>信息</li>
<li>将它的进程<code>task_struct</code>和执行当前这段内核代码的进程<code>task_struct</code>对比校验</li>
<li>限制了用户空间虚拟内存的大小在4M以内</li>
<li>检查用户空间是否可写（<code>binder</code>驱动为进程分配的缓冲区在用户空间中只可以读，不可以写）</li>
<li>设置<code>vm_flags</code>，令<code>vma</code>不可写，不可复制</li>
<li>设置<code>vma</code>的操作函数集</li>
<li>将<code>vm_area_struct</code>中的成员变量<code>vm_private_data</code>指向<code>binder_proc</code>，使得<code>vma</code>设置的操作函数中可以拿到<code>binder_proc</code></li>
<li>处理进程虚拟内存空间与内核虚拟地址空间的映射关系</li>
<li>获取进程的打开文件信息结构体<code>files_struct</code>，令<code>binder_proc</code>的<code>files</code>指向它，并将引用计数加1</li>
</ol>
<h2 id="binder-alloc-mmap-handler"><a href="#binder-alloc-mmap-handler" class="headerlink" title="binder_alloc_mmap_handler"></a>binder_alloc_mmap_handler</h2><p><code>binder_alloc_mmap_handler</code>将进程虚拟内存空间与内核虚拟地址空间做映射，它被实现在<code>drivers/android/binder_alloc.c</code>中</p>
<p>这里先介绍一下<code>vm_struct</code>，之前我们已经了解了<code>vm_area_struct</code>表示用户进程中的虚拟地址空间，而相对应的，<code>vm_struct</code>则表示内核中的虚拟地址空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_alloc_mmap_handler</span><span class="params">(struct binder_alloc *alloc,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        <span class="comment">//检查是否已经分配过内核缓冲区</span></span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		failure_string = <span class="string">"already mapped"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_already_mapped;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//获得一个内核虚拟空间</span></span><br><span class="line">	area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_ALLOC);</span><br><span class="line">	<span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//alloc-&gt;buffer指向内核虚拟内存空间地址</span></span><br><span class="line">	alloc-&gt;<span class="built_in">buffer</span> = area-&gt;addr;</span><br><span class="line">        <span class="comment">//计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量</span></span><br><span class="line">	alloc-&gt;user_buffer_offset =</span><br><span class="line">		vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">	mutex_unlock(&amp;binder_alloc_mmap_lock);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//申请内存</span></span><br><span class="line">	alloc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(alloc-&gt;pages[<span class="number">0</span>]) *</span><br><span class="line">				   ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE),</span><br><span class="line">			       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (alloc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//buffer大小等于vma大小</span></span><br><span class="line">	alloc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">buffer</span> = kzalloc(<span class="keyword">sizeof</span>(*<span class="built_in">buffer</span>), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">buffer</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		failure_string = <span class="string">"alloc buffer struct"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_buf_struct_failed;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//指向内核虚拟空间地址</span></span><br><span class="line">	<span class="built_in">buffer</span>-&gt;data = alloc-&gt;<span class="built_in">buffer</span>;</span><br><span class="line">        <span class="comment">//将buffer添加到链表中</span></span><br><span class="line">	list_add(&amp;<span class="built_in">buffer</span>-&gt;entry, &amp;alloc-&gt;buffers);</span><br><span class="line">	<span class="built_in">buffer</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将此内核缓冲区加入到binder_alloc的空闲缓冲红黑树中</span></span><br><span class="line">	binder_insert_free_buffer(alloc, <span class="built_in">buffer</span>);</span><br><span class="line">        <span class="comment">//设置进程最大可用异步事务缓冲区大小（防止异步事务消耗过多内核缓冲区，影响同步事务）</span></span><br><span class="line">	alloc-&gt;free_async_space = alloc-&gt;buffer_size / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//内存屏障，保证指令顺序执行</span></span><br><span class="line">	barrier();</span><br><span class="line">        <span class="comment">//设置binder_alloc</span></span><br><span class="line">	alloc-&gt;vma = vma;</span><br><span class="line">	alloc-&gt;vma_vm_mm = vma-&gt;vm_mm;</span><br><span class="line">	<span class="comment">//引用计数+1</span></span><br><span class="line">	atomic_inc(&amp;alloc-&gt;vma_vm_mm-&gt;mm_count);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ... <span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>检查是否已经分配过内核缓冲区</li>
<li>从内核中寻找一块可用的虚拟内存地址</li>
<li>将此内核虚拟内存空间地址保存至<code>binder_alloc</code></li>
<li>计算出用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量（这样就可以非常方便的在用户虚拟内存空间与内核虚拟内存空间间切换）</li>
<li>为<code>alloc-&gt;pages</code>数组申请内存，申请的大小等于<code>vma</code>能分配多少个页框</li>
<li>设置<code>buffer</code>大小等于<code>vma</code>大小</li>
<li>为<code>binder_buffer</code>申请内存，填充参数，使其指向内核虚拟空间地址，并将其添加到链表和红黑树中</li>
<li>设置<code>binder_alloc</code>其他参数</li>
</ol>
<p>这里要注意，虽然我们计算出了用户虚拟空间线性地址到内核虚拟空间线性地址的偏移量，但并没有建立映射关系。在旧版内核中，这里会调用<code>binder_update_page_range</code>函数分别将内核虚拟内存和进程虚拟内存与物理内存做映射，这样内核虚拟内存和进程虚拟内存也相当于间接建立了映射关系，而在<code>4.4.223</code>中，这件事将会延迟到<code>binder_ioctl</code>后</p>
<p>当完成物理内存的映射后，以32位系统，缓冲区大小4M为例，效果应该如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E9%A9%B1%E5%8A%A8%EF%BC%88%E4%B8%8A%EF%BC%89_mmap.png" alt="binder_mmap"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这里，我们已经了解了<code>binder</code>驱动设备是如何注册的，并且分析了<code>binder_open</code>和<code>binder_mmap</code>操作函数，了解了一些重要的结构体，明白了<code>mmap</code>是如何映射用户空间和内核空间的，由于篇幅原因，下一章我们会分析<code>binder</code>驱动中最重要的部分<code>binder_ioctl</code></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://unicornx.github.io/2016/02/14/20160214-lk-drv-miscdevice/" target="_blank" rel="noopener">linux中的misc设备</a></li>
<li><a href="https://blog.csdn.net/u012142460/article/details/90344951" target="_blank" rel="noopener">内存映射与VMA</a></li>
<li><a href="https://www.jianshu.com/p/4399aedb4d42" target="_blank" rel="noopener">Android 重学系列 Binder驱动的初始化 映射原理(二)</a></li>
<li><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></li>
<li><a href="https://segmentfault.com/a/1190000014643994" target="_blank" rel="noopener">Linux 4.16 Binder驱动学习笔记——–接口简析</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E6%A6%82%E8%BF%B0/">Android源码分析 - Binder概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇无源码分析，只对Binder做通信过程和基础架构的介绍</strong></p>
<p><code>Binder</code>是<code>Android</code>中最重要的一种进程间通信机制，基于开源的<code>OpenBinder</code></p>
<p><strong>George Hoffman</strong>当时任<strong>Be</strong>公司的工程师，他启动了一个名为<code>OpenBinder</code>的项目，在<strong>Be</strong>公司被<strong>ParmSource</strong>公司收购后，<code>OpenBinder</code>由<strong>Dinnie Hackborn</strong>继续开发，后来成为管理<code>ParmOS6 Cobalt OS</code>的进程的基础。在<strong>Hackborn</strong>加入谷歌后，他在<code>OpenBinder</code>的基础上开发出了<code>Android Binder</code>(以下简称<code>Binder</code>)，用来完成<code>Android</code>的进程通信。</p>
<h1 id="为什么需要学习Binder"><a href="#为什么需要学习Binder" class="headerlink" title="为什么需要学习Binder"></a>为什么需要学习Binder</h1><p>作为一名<code>Android</code>开发，我们每天都在和<code>Binder</code>打交道，虽然可能有的时候不会注意到，譬如：</p>
<ul>
<li><code>startActivity</code>的时候，会获取AMS服务，调用AMS服务的<code>startActivity</code>方法</li>
<li><code>startActivity</code>传递的对象为什么需要序列化</li>
<li><code>bindService</code>为什么回调的是一个<code>Ibinder</code>对象</li>
<li>多进程应用，各个进程之间如何通信</li>
<li><code>AIDL</code>的使用</li>
<li>…</li>
</ul>
<p>它们都和<code>Binder</code>有着莫切关系，当碰到上面的场景，或者一些疑难问题的时候，理解<code>Binder</code>机制是非常有必要的</p>
<h1 id="为什么Android选择Binder"><a href="#为什么Android选择Binder" class="headerlink" title="为什么Android选择Binder"></a>为什么Android选择Binder</h1><p>这就要从进程间通信开始说起了，我们先看看比较常见的几种进程间通信方式</p>
<h2 id="常见进程间通信"><a href="#常见进程间通信" class="headerlink" title="常见进程间通信"></a>常见进程间通信</h2><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是进程间通信中最简单的方式之一，共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" alt="共享内存"></p>
<p>因为共享内存是访问同一块内存，所以数据不需要进行任何复制，是IPC几种方式中最快，性能最好的方式。但相对应的，共享内存未提供同步机制，需要我们手动控制内存间的互斥操作，较容易发生问题。同时共享内存由于能任意的访问和修改内存中的数据，如果有恶意程序去针对某个程序设计代码，很可能导致隐私泄漏或者程序崩溃，所以安全性较差。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道分为命名管道和无名管道，它是以一种特殊的文件作为中间介质，我们称为管道文件，它具有固定的读端和写端，写进程通过写段向管道文件里写入数据，读进程通过读段从读进程中读出数据，构成一条数据传递的流水线，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E7%AE%A1%E9%81%93.png" alt="管道"></p>
<p>管道一次通信需要经历2次数据复制（进程A -&gt; 管道文件，管道文件 -&gt; 进程B）。管道的读写分阻塞和非阻塞，管道创建会分配一个缓冲区，而这个缓冲区是有限的，如果传输的数据大小超过缓冲区上限，或者在阻塞模式下没有安排好数据的读写，会出现阻塞的情况。管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列允许多个进程同时读写消息，发送方与接收方要约定好，消息体的数据类型与大小。消息队列克服了信号承载信息量少、管道只能承载无格式字节流等缺点，消息队列一次通信同样需要经历2次数据复制（进程A -&gt; 消息队列，消息队列 -&gt; 进程B），它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="消息队列"></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><code>Socket</code>原本是为了网络设计的，但也可以通过本地回环地址 (<code>127.0.0.1</code>) 进行进程间通信，后来在<code>Socket</code>的框架上更是发展出一种IPC机制，名叫<code>UNIX Domain Socket</code>。<code>Socket</code>是一种典型的<code>C/S</code>架构，一个<code>Socket</code>会拥有两个缓冲区，一读一写，由于发送/接收消息需要将一个<code>Socket</code>缓冲区中的内容拷贝至另一个<code>Socket</code>缓冲区，所以<code>Socket</code>一次通信也是需要经历2次数据复制，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Socket.png" alt="Socket"></p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>了解了常见进程间通信的方式，我们再来看一下<code>Binder</code>的原理</p>
<p><code>Binder</code>是基于内存映射<code>mmap</code>设计实现的，我们需要先了解一下<code>mmap</code>的概念</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><code>mmap</code>是一种内存映射的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read</code>,<code>write</code>等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>Linux</code>内核不会主动将<code>mmap</code>修改后的内容同步到磁盘文件中，有4个时机会触发<code>mmap</code>映射同步到磁盘：</p>
<ul>
<li>调用 <code>msync</code> 函数主动进行数据同步（主动）</li>
<li>调用 <code>munmap</code> 函数对文件进行解除映射关系时（主动）</li>
<li>进程退出时（被动）</li>
<li>系统关机时（被动）</li>
</ul>
<p>通过这种方式，直接操作映射的这一部分内存，可以避免一些数据复制，从而获得更好的性能</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一次<code>Binder</code> IPC通信的过程分为以下几个步骤：</p>
<ol>
<li>首先，<code>Binder</code>驱动在内核空间中开辟出一个<code>数据接收缓冲区</code></li>
<li>接着，在内核空间中开辟出一个<code>内核缓冲区</code></li>
<li>将<code>内核缓冲区</code>与<code>数据接收缓冲区</code>建立映射关系</li>
<li>将<code>数据接收缓冲区</code>与<code>接收进程的用户空间地址</code>建立映射关系</li>
<li>发送方进程通过<code>copy_from_user</code>将数据从用户空间复制到<code>内核缓冲区</code></li>
<li>由于<code>内核缓冲区</code>与<code>数据接收缓冲区</code>有映射关系，同时<code>数据接收缓冲区</code>与<code>接收进程的用户空间地址</code>有映射关系，所以在接收进程中可以直接获取到这段数据</li>
</ol>
<p>这样便完成了一次<code>Binder</code> IPC通信，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png" alt="Binder"></p>
<p>可以看到，通过<code>mmap</code>，<code>Binder</code>通信时，只需要经历一次数据复制，性能要优于管道/消息队列/socket等方式，在安全性，易用性方面又优于共享内存。鉴于上述原因，<code>Android</code>选择了这种折中的IPC方式，来满足系统对稳定性、传输性能和安全性方面的要求</p>
<h1 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h1><p><code>Binder</code>也是一种<code>C/S</code>架构，分为<code>BpBinder</code>（客户端）和<code>BBinder</code>（服务端），他们都派生自<code>IBinder</code>。其中<code>BpBinder</code>中的p表示proxy，即代理。<code>BpBinder</code>通过<code>transact</code>来发送事务请求，<code>BBinder</code>通过<code>onTransact</code>来接收相应的事务</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E6%9E%B6%E6%9E%84.png" alt="Ibinder"></p>
<p>Binder一次通信的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F.png" alt="Binder通信"></p>
<p>Binder采用分层架构设计</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="Binder分层架构"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大概了解了一下<code>Android</code>选用<code>Binder</code>的原因，以及<code>Binder</code>的基本结构和通信过程，为之后深入源码层分析<code>Binder</code>做了准备</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></li>
<li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></li>
<li><a href="https://bbs.huaweicloud.com/blogs/308646" target="_blank" rel="noopener">Android Binder原理图解</a></li>
<li><a href="https://www.jianshu.com/p/45563980bf61" target="_blank" rel="noopener">Binder和AIDL实例及原理解析</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/29/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - SystemServer（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SystemServer/">SystemServer</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7054154169761923085" target="_blank" rel="noopener">Android源码分析 - SystemServer（上）</a>我们分析了<code>SystemServer</code>进程是怎么被启动起来的，今天这篇，我们来分析<code>SystemServer</code>进程启动后做了什么</p>
<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>我们上一章中讲到，<code>Zygote</code>进程<code>fork</code>出子进程后，最终调用了<code>SystemServer.main</code>方法，<code>SystemServer</code>源代码在<code>frameworks/base/services/java/com/android/server/SystemServer.java</code>中，我们来看看做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>非常简单，就是先new了一个<code>SystemServer</code>对象，然后调用它的<code>run</code>方法，我们先看一下构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工厂模式</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录启动信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录是否经历过重启</span></span><br><span class="line">    mRuntimeRestart = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>首先，先从系统属性中获取工厂模式级别，有三种属性：</p>
<ul>
<li><code>FACTORY_TEST_OFF</code>：正常模式</li>
<li><code>FACTORY_TEST_LOW_LEVEL</code>：低级别工厂模式，在此模式下，很多Service不会启动</li>
<li><code>FACTORY_TEST_HIGH_LEVEL</code>：高级别工厂模式，此模式与正常模式基本相同，略有区别</li>
</ul>
<p>它们被定义在<code>frameworks/base/core/java/android/os/FactoryTest.java</code>中</p>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>紧接着便开始执行<code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//记录启动信息</span></span><br><span class="line">    <span class="comment">//如果没有设置时区，将时区设置为GMT</span></span><br><span class="line">    String timezoneProperty = SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置区域与语言</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Binder事务发生阻塞时发出警告</span></span><br><span class="line">    Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//PackageManager相关</span></span><br><span class="line">    PackageItemInfo.forceSafeLabels();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置虚拟机库文件libart.so</span></span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line">    <span class="comment">//清除虚拟机内存增长上限，以获得更多内存</span></span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">    <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">    <span class="comment">// we've defined it before booting further.</span></span><br><span class="line">    Build.ensureFingerprintProperty();</span><br><span class="line">    <span class="comment">//设置在访问环境变量前，需要明确指定用户</span></span><br><span class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置标记，当发生BadParcelableException异常时保守处理，不要抛出异常</span></span><br><span class="line">    BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置异常跟踪</span></span><br><span class="line">    Parcel.setStackTraceParceling(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//确保Binder调用优先级总为前台优先级</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置Binder线程池最大数量</span></span><br><span class="line">    BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line">    <span class="comment">//设置进程优先级为前台进程</span></span><br><span class="line">    <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">    android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//以当前线程作为MainLooper准备</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    Looper.getMainLooper().setSlowLogThresholdMs(</span><br><span class="line">            SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class="line"></span><br><span class="line">    SystemServiceRegistry.sEnableServiceNotFoundWtf = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库</span></span><br><span class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">//标记该进程的堆可分析</span></span><br><span class="line">    initZygoteChildHeapProfiling();</span><br><span class="line">    <span class="comment">//Debug选项 - 开启一个线程用来监测FD泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">        spawnFdLeakCheckThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查上次关机过程中是否失败</span></span><br><span class="line">    performPendingShutdown();</span><br><span class="line">    <span class="comment">//初始化System Context</span></span><br><span class="line">    createSystemContext();</span><br><span class="line">    <span class="comment">//创建并设置一些每个进程启动时都需要的一些模块 (TelephonyServiceManager, StatsServiceManager)</span></span><br><span class="line">    ActivityThread.initializeMainlineModules();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建SystemServiceManager（管理所有的系统Service）</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">            mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">    <span class="comment">//将SystemServiceManager作为本地进程Service使用</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager<span class="class">.<span class="keyword">class</span>, <span class="title">mSystemServiceManager</span>)</span>;</span><br><span class="line">    <span class="comment">//为初始化任务准备线程池</span></span><br><span class="line">    SystemServerInitThreadPool.start();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置默认异常处理程序</span></span><br><span class="line">    RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动引导服务</span></span><br><span class="line">    startBootstrapServices(t);</span><br><span class="line">    <span class="comment">//启动核心服务</span></span><br><span class="line">    startCoreServices(t);</span><br><span class="line">    <span class="comment">//启动其他服务</span></span><br><span class="line">    startOtherServices(t);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格模式初始化虚拟机策略</span></span><br><span class="line">    StrictMode.initVmDefaults(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//进入Looper死循环，等待Handler事件</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>run</code>方法主要做了以下工作</p>
<ol>
<li>检查并设置各种参数handler</li>
<li>创建<code>SystemContext</code></li>
<li>创建<code>SystemServiceManager</code></li>
<li>启动服务</li>
<li><code>Looper</code>循环</li>
</ol>
<p>其中，创建<code>SystemContext</code>这一步是由<code>ContextImpl</code>完成的，等后面分析到的时候在详细去看，<code>Looper</code>也是，我们将重点放在启动服务上</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>启动服务分为三步，首先是启动引导服务，其次是启动核心服务，最后是启动其他服务，我们先从引导服务开始</p>
<p><strong>由于启动的服务太多了，我们只介绍一些我们比较熟悉的服务</strong></p>
<h2 id="startBootstrapServices"><a href="#startBootstrapServices" class="headerlink" title="startBootstrapServices"></a>startBootstrapServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//看门狗</span></span><br><span class="line">    <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">    watchdog.start();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> String TAG_SYSTEM_CONFIG = <span class="string">"ReadingSystemConfig"</span>;</span><br><span class="line">    <span class="comment">//读取系统配置</span></span><br><span class="line">    SystemServerInitThreadPool.submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Installer服务（实际上是与installd跨进程通信）</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建 ATMS &amp; AMS</span></span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">            ActivityTaskManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">            mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//电源管理服务，后面有其他服务依赖它，所以需要较早启动</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//灯光服务</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//显示管理服务</span></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//阶段100</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建PMS</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">"packagemanagermain"</span>);</span><br><span class="line">        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">"packagemanagermain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获dex load行为</span></span><br><span class="line">    SystemServerDexLoadReporter.configureSystemServerDexReporter(mPackageManagerService);</span><br><span class="line">    <span class="comment">//是否首次启动</span></span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    <span class="comment">//获取PMS</span></span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//用户管理服务</span></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化属性缓存</span></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册各种系统服务</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//使用AMS完成看门狗的设置，并监听重新启动</span></span><br><span class="line">    watchdog.init(mSystemContext, mActivityManagerService);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置调度策略</span></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在单独线程中启动传感器服务</span></span><br><span class="line">    mSensorServiceStart = SystemServerInitThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog();</span><br><span class="line">        traceLog.traceBegin(START_SENSOR_SERVICE);</span><br><span class="line">        startSensorService();</span><br><span class="line">        traceLog.traceEnd();</span><br><span class="line">    &#125;, START_SENSOR_SERVICE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startCoreServices"><a href="#startCoreServices" class="headerlink" title="startCoreServices"></a>startCoreServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//电池电量服务，依赖LightsService</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//应用统计服务</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startOtherServices"><a href="#startOtherServices" class="headerlink" title="startOtherServices"></a>startOtherServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//AccountManagerService - 账户管理</span></span><br><span class="line">    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//ContentService - 内容服务</span></span><br><span class="line">    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//加载SettingProvider</span></span><br><span class="line">    mActivityManagerService.installSystemProviders();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//DropBox日志服务</span></span><br><span class="line">    mSystemServiceManager.startService(DropBoxManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//震动服务</span></span><br><span class="line">    vibrator = <span class="keyword">new</span> VibratorService(context);</span><br><span class="line">    ServiceManager.addService(<span class="string">"vibrator"</span>, vibrator);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//时钟/闹钟服务</span></span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> AlarmManagerService(context));</span><br><span class="line">    <span class="comment">//输入服务</span></span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//等待传感器服务准备完毕</span></span><br><span class="line">    ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">    mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//启动WindowManagerService</span></span><br><span class="line">    wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">            <span class="keyword">new</span> PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService.setWindowManager(wm);</span><br><span class="line">    ...</span><br><span class="line">    wm.onInitReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//HIDL services</span></span><br><span class="line">    SystemServerInitThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        startHidlServices();</span><br><span class="line">    &#125;, START_HIDL_SERVICES);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//关联WMS，启动输入服务</span></span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());</span><br><span class="line">    inputManager.start();</span><br><span class="line">    ...</span><br><span class="line">    mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//有蓝牙功能且非低级工厂模式，启动蓝牙服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context.getPackageManager().hasSystemFeature</span><br><span class="line">            (PackageManager.FEATURE_BLUETOOTH)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSystemServiceManager.startService(BluetoothService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//输入法/无障碍服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) &#123;</span><br><span class="line">            mSystemServiceManager.startService(</span><br><span class="line">                    MultiClientInputMethodManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSystemServiceManager.startService(InputMethodManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mSystemServiceManager.startService(ACCESSIBILITY_MANAGER_SERVICE_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wm.displayReady();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储相关服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"0"</span>.equals(SystemProperties.get(<span class="string">"system_init.startmountservice"</span>))) &#123;</span><br><span class="line">            mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);</span><br><span class="line">            storageManager = IStorageManager.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"mount"</span>));</span><br><span class="line">            mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UIMode服务（夜间模式，驾驶模式等）</span></span><br><span class="line">    mSystemServiceManager.startService(UiModeManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//执行磁盘清理工作，释放磁盘空间</span></span><br><span class="line">    mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(<span class="string">""</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (hasPdb || OemLockService.isHalPresent()) &#123;</span><br><span class="line">            <span class="comment">//OEM锁服务</span></span><br><span class="line">            mSystemServiceManager.startService(OemLockService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!isWatch) &#123;</span><br><span class="line">            <span class="comment">//状态栏管理服务</span></span><br><span class="line">            statusBar = <span class="keyword">new</span> StatusBarManagerService(context);</span><br><span class="line">            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//网络相关服务</span></span><br><span class="line">        ConnectivityModuleConnector.getInstance().init(context);</span><br><span class="line">        NetworkStackClient.getInstance().init();</span><br><span class="line">        networkManagement = NetworkManagementService.create(context);</span><br><span class="line">        ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">        ipSecService = IpSecService.create(context, networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//文本服务</span></span><br><span class="line">        mSystemServiceManager.startService(TextServicesManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mSystemServiceManager</span><br><span class="line">                    .startService(TextClassificationManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网络相关服务</span></span><br><span class="line">        mSystemServiceManager.startService(NetworkScoreService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        networkStats = NetworkStatsService.create(context, networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);</span><br><span class="line">        networkPolicy = <span class="keyword">new</span> NetworkPolicyManagerService(context, mActivityManagerService,</span><br><span class="line">                    networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_SCANNING_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_RTT)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_RTT_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_AWARE)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_AWARE_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_DIRECT)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_LOWPAN)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) ||</span><br><span class="line">                mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        connectivity = <span class="keyword">new</span> ConnectivityService(</span><br><span class="line">                    context, networkManagement, networkStats, networkPolicy);</span><br><span class="line">        ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity,</span><br><span class="line">                    <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                    DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL);</span><br><span class="line">        networkPolicy.bindConnectivityManager(connectivity);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//系统更新服务</span></span><br><span class="line">        ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE,</span><br><span class="line">                    <span class="keyword">new</span> SystemUpdateManagerService(context));</span><br><span class="line">        ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,</span><br><span class="line">                    <span class="keyword">new</span> UpdateLockService(context));</span><br><span class="line">        <span class="comment">//通知服务</span></span><br><span class="line">        mSystemServiceManager.startService(NotificationManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        SystemNotificationChannels.removeDeprecated(context);</span><br><span class="line">        SystemNotificationChannels.createAll(context);</span><br><span class="line">        notification = INotificationManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.NOTIFICATION_SERVICE));</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//位置服务</span></span><br><span class="line">        mSystemServiceManager.startService(LocationManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//墙纸服务</span></span><br><span class="line">        <span class="keyword">if</span> (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//音频服务</span></span><br><span class="line">        <span class="keyword">if</span> (!isArc) &#123;</span><br><span class="line">            mSystemServiceManager.startService(AudioService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String className = context.getResources()</span><br><span class="line">                    .getString(R.string.config_deviceSpecificAudioService);</span><br><span class="line">            mSystemServiceManager.startService(className + <span class="string">"$Lifecycle"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ADB服务</span></span><br><span class="line">        mSystemServiceManager.startService(ADB_SERVICE_CLASS);</span><br><span class="line">        <span class="comment">//USB服务</span></span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)</span><br><span class="line">                || mPackageManager.hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_USB_ACCESSORY)</span><br><span class="line">                || isEmulator) &#123;</span><br><span class="line">            mSystemServiceManager.startService(USB_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//微件（小组件）服务</span></span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)</span><br><span class="line">                || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Android10新增，用于报告来自运行时模块的信息</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"runtime"</span>, <span class="keyword">new</span> RuntimeService(context));</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//App后台Dex优化</span></span><br><span class="line">        BackgroundDexOptService.schedule(context);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//相机服务</span></span><br><span class="line">    <span class="keyword">if</span> (!disableCameraService) &#123;</span><br><span class="line">        mSystemServiceManager.startService(CameraServiceProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入安全模式</span></span><br><span class="line">    <span class="keyword">if</span> (safeMode) &#123;</span><br><span class="line">        mActivityManagerService.enterSafeMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//短信服务</span></span><br><span class="line">    mmsService = mSystemServiceManager.startService(MmsServiceBroker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//剪贴板服务</span></span><br><span class="line">    mSystemServiceManager.startService(ClipboardService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用各大服务的systemReady方法</span></span><br><span class="line"></span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">    lockSettings.systemReady();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阶段480</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">    <span class="comment">//阶段500</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line"></span><br><span class="line">    wm.systemReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//手动更新Context Configuration</span></span><br><span class="line">    <span class="keyword">final</span> Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY);</span><br><span class="line">    DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    context.getDisplay().getMetrics(metrics);</span><br><span class="line">    context.getResources().updateConfiguration(config, metrics);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Theme systemTheme = context.getTheme();</span><br><span class="line">    <span class="keyword">if</span> (systemTheme.getChangingConfigurations() != <span class="number">0</span>) &#123;</span><br><span class="line">        systemTheme.rebase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());</span><br><span class="line">    ...</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(safeMode, mOnlyCore);</span><br><span class="line">    </span><br><span class="line">    mSystemServiceManager.setSafeMode(safeMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶段520</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//最后运行AMS.systemReady</span></span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//阶段550</span></span><br><span class="line">        mSystemServiceManager.startBootPhase(t, SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//阶段600</span></span><br><span class="line">        mSystemServiceManager.startBootPhase(t, SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">        ...</span><br><span class="line">    &#125;, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务的启动是分阶段完成的，从0-100-480-500-520-550-600-1000，最后的阶段1000，是在AMS调用<code>finishBooting</code>方法后进入</p>
<p>可以看到，启动的服务非常之多，不可能全看得完，其中最重要的几个：<code>ActivityManagerService</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>和<code>InputManagerService</code>，后面我们会慢慢看过去，在此之前，我们还是先看看服务启动的方式</p>
<h1 id="SystemServiceManager"><a href="#SystemServiceManager" class="headerlink" title="SystemServiceManager"></a>SystemServiceManager</h1><p>绝大部分的服务是通过<code>SystemServiceManager</code>启动的，它的源码路径为<code>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</code></p>
<h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>我们来看看这个类里的启动服务方法</p>
<p>这个类中有三个方法用于启动Serivce，分别是：</p>
<ul>
<li><code>public SystemService startService(String className)</code></li>
<li><code>public SystemService startServiceFromJar(String className, String path)</code></li>
<li><code>public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass)</code></li>
<li><code>public void startService(@NonNull final SystemService service)</code></li>
</ul>
<p>实际上最后都是调用了最后一个方法</p>
<p>先看参数为<code>String</code>的<code>startService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startService</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,</span><br><span class="line">            <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;SystemService&gt; <span class="title">loadClassFromLoader</span><span class="params">(String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Class&lt;SystemService&gt;) Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是通过反射拿到类名对应的<code>Class</code>，再调用<code>Class</code>为参的<code>startService</code>方法</p>
<p><code>startServiceFromJar</code>实际上也是一样，只不过是先通过<code>PathClassLoader</code>加载了jar而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startServiceFromJar</span><span class="params">(String className, String path)</span> </span>&#123;</span><br><span class="line">    PathClassLoader pathClassLoader = mLoadedPaths.get(path);</span><br><span class="line">    <span class="keyword">if</span> (pathClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// NB: the parent class loader should always be the system server class loader.</span></span><br><span class="line">        <span class="comment">// Changing it has implications that require discussion with the mainline team.</span></span><br><span class="line">        pathClassLoader = <span class="keyword">new</span> PathClassLoader(path, <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        mLoadedPaths.put(path, pathClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, pathClassLoader);</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看看<code>Class</code>为参数的<code>startService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the service.</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemService<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">serviceClass</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to create "</span> + name</span><br><span class="line">                + <span class="string">": service must extend "</span> + SystemService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> T service;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        service = constructor.newInstance(mContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startService(service);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看函数泛型我们就可以知道，这个方法只接受<code>SystemService</code>的子类，并且在方法的开头，还使用了<code>isAssignableFrom</code>方法做了类型校验，避免通过<code>String</code>反射获取的<code>Class</code>非<code>SystemService</code>的子类</p>
<p>之后的逻辑也很简单，反射实例化对象，然后调用另一个以<code>SystemService</code>对象为参数的重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">    mServices.add(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to start service "</span> + service.getClass().getName()</span><br><span class="line">                + <span class="string">": onStart threw an exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会将<code>SystemService</code>对象加入一个<code>List</code>中，然后调用它的<code>onStart</code>方法，通知<code>SystemService</code>自行处理启动</p>
<h2 id="startBootPhase"><a href="#startBootPhase" class="headerlink" title="startBootPhase"></a>startBootPhase</h2><p>因为各种服务之间是存在依赖关系的，所以Android将服务的启动划分了8个阶段：0-100-480-500-520-550-600-1000，而<code>startBootPhase</code>方法便是用来通知各个服务进行到哪一阶段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startBootPhase</span><span class="params">(@NonNull TimingsTraceAndSlog t, <span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase &lt;= mCurrentPhase) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Next phase must be larger than previous"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentPhase = phase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> serviceLen = mServices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serviceLen; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> SystemService service = mServices.get(i);</span><br><span class="line">        service.onBootPhase(mCurrentPhase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phase == SystemService.PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每进入到一个阶段，便会调用Service List中所有<code>SystemService</code>的<code>onBootPhase</code>方法，通知<code>SystemService</code>阶段变换，而当阶段达到1000 (PHASE_BOOT_COMPLETED) 时，就代表着所有的服务都已准备完毕，关闭<code>SystemServerInitThreadPool</code>线程池</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>当服务被创建出来后，会调用<code>ServiceManager.addService</code>方法添加服务，以供其他地方使用这些服务</p>
<p><code>addService</code>有三个重载，最终调用的为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getIServiceManager().addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in addService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceManager is never local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">        mServiceManager = IServiceManager.Stub.asInterface(remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IServiceManager mServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就能看出来<code>ServiceManager</code>实际上是一个单独的进程，名为<code>servicemanager</code>，它负责管理所有服务，使用了<code>Binder</code> IPC机制，我们调用<code>addService</code>方法实际上是调用了Binder Proxy的方法，他向<code>/dev/binder</code>中写入消息，在<code>servicemanager</code>进程中接收到了这个消息并处理这个请求</p>
<p>关于<code>Binder</code>机制，我们随后便会分析它</p>
<p>最终调用了<code>frameworks/native/cmds/servicemanager/ServiceManager.cpp</code>中的<code>addService</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//添加服务</span></span><br><span class="line">    <span class="keyword">auto</span> entry = mNameToService.emplace(name, Service &#123;</span><br><span class="line">        .binder = binder,</span><br><span class="line">        .allowIsolated = allowIsolated,</span><br><span class="line">        .dumpPriority = dumpPriority,</span><br><span class="line">        .debugPid = ctx.debugPid,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mNameToRegistrationCallback.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != mNameToRegistrationCallback.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123;</span><br><span class="line">            entry.first-&gt;second.guaranteeClient = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// permission checked in registerForNotifications</span></span><br><span class="line">            cb-&gt;onRegistration(name, binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终通过<code>service name</code>和传过来的<code>binder</code>对象构造出一个<code>Service</code>结构体，并将其保存至<code>mNameToService</code>这个Map中，以供后面使用</p>
<h1 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h1><p><code>SystemServer</code>启动的服务大多都运行在<code>systemserver</code>进程中，但也有一些例外</p>
<p>譬如<code>Installer</code>服务，便是从<code>init</code>进程单独<code>fork</code>出了一个<code>installd</code>进程</p>
<p>下面是它的rc文件，<code>frameworks/native/cmds/installd/installd.rc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service installd &#x2F;system&#x2F;bin&#x2F;installd</span><br><span class="line">class main</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>而在<code>SystemServer</code>进程中start的<code>Installer</code>，便是通过<code>binder</code>连接到<code>installd</code>进程提供服务</p>
<p>源码路径<code>frameworks/base/services/core/java/com/android/server/pm/Installer.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsolated) &#123;</span><br><span class="line">        mInstalld = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IBinder binder = ServiceManager.getService(<span class="string">"installd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            binder.linkToDeath(<span class="keyword">new</span> DeathRecipient() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"installd died; reconnecting"</span>);</span><br><span class="line">                    connect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            binder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInstalld = IInstalld.Stub.asInterface(binder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            invalidateMounts();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstallerException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"installd not found; trying again"</span>);</span><br><span class="line">        BackgroundThread.getHandler().postDelayed(() -&gt; &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;, DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p><code>SystemServer</code>启动了非常多的服务，并将这些服务添加到了<code>ServiceManager</code>中，我们又从中引申出了<code>Binder</code>机制，我们下一章便开始分析<code>Binder</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/17/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - SystemServer（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SystemServer/">SystemServer</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7051507161955827720" target="_blank" rel="noopener" title="Android源码分析 - Zygote进程">Android源码分析 - Zygote进程</a>，我们分析了Android <code>Zygote</code>进程的启动和之后是如何接收消息创建App进程的</p>
<p>在上一章中，我们说了，<code>Zygote</code>的一大作用就是启动<code>SystemServer</code>，那么<code>SystemServer</code>是怎么启动的呢？启动后又做了些什么呢？我们分上下两篇来分析，本篇介绍<code>SystemServer</code>是如何启动的</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>SystemServer</code>主要是用来创建系统服务的，譬如我们熟知的<code>ActivityManagerService</code>，<code>PackageManagerService</code>都是由它创建的</p>
<h1 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h1><p>我们从上一篇文章的<code>ZygoteInit</code>开始，<code>ZygoteInit</code>类的源码路径为<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="comment">//参数中有start-system-server</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动SystemServer</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程中才会满足r != null</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此时执行这个Runnable</span></span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前在c++代码中JNI调用Java函数的时候，带了参数<code>start-system-server</code>，在这里就会通过这个参数判断是否启动<code>SystemServer</code>，接下来调用<code>forkSystemServer</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置Linux capabilities</span></span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">            OsConstants.CAP_IPC_LOCK,</span><br><span class="line">            OsConstants.CAP_KILL,</span><br><span class="line">            OsConstants.CAP_NET_ADMIN,</span><br><span class="line">            OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">            OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">            OsConstants.CAP_NET_RAW,</span><br><span class="line">            OsConstants.CAP_SYS_MODULE,</span><br><span class="line">            OsConstants.CAP_SYS_NICE,</span><br><span class="line">            OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">            OsConstants.CAP_SYS_TIME,</span><br><span class="line">            OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">            OsConstants.CAP_WAKE_ALARM,</span><br><span class="line">            OsConstants.CAP_BLOCK_SUSPEND</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//移除一些当前线程都不可用的特权</span></span><br><span class="line">    StructCapUserHeader header = <span class="keyword">new</span> StructCapUserHeader(</span><br><span class="line">            OsConstants._LINUX_CAPABILITY_VERSION_3, <span class="number">0</span>);</span><br><span class="line">    StructCapUserData[] data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data = Os.capget(header);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to capget()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//data[0].effective为当前线程所可用的特权，data[1].effective貌似为0</span></span><br><span class="line">    capabilities &amp;= ((<span class="keyword">long</span>) data[<span class="number">0</span>].effective) | (((<span class="keyword">long</span>) data[<span class="number">1</span>].effective) &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fork参数</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">            <span class="string">"--setuid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span></span><br><span class="line">                    + <span class="string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"</span>,</span><br><span class="line">            <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">            <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">            <span class="string">"--runtime-args"</span>,</span><br><span class="line">            <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteArguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析设置的参数</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line">        ... <span class="comment">//进一步设置参数</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                parsedArgs.mGids,</span><br><span class="line">                parsedArgs.mRuntimeFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.mPermittedCapabilities,</span><br><span class="line">                parsedArgs.mEffectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SystemServer子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zygote server socket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p>这里需要先了解一下Linux Capabilities机制：<a href="https://juejin.cn/post/7052933216948191269" target="_blank" rel="noopener">Linux Capabilities机制</a></p>
<p>这里先定义了<code>SystemServer</code>进程的<code>Permitted</code>和<code>Effective</code>能力集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">posixCapabilitiesAsBits</span><span class="params">(<span class="keyword">int</span>... capabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> capability : capabilities) &#123;</span><br><span class="line">        <span class="comment">//非法capability，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> ((capability &lt; <span class="number">0</span>) || (capability &gt; OsConstants.CAP_LAST_CAP)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.valueOf(capability));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为或操作，构建capabilities集合</span></span><br><span class="line">        result |= (<span class="number">1L</span> &lt;&lt; capability);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下有无非法<code>capability</code>，然后做位或运算，构建出一个<code>capabilities</code>集合</p>
<p>然后通过<code>Os.capget</code>方法获取当前线程的<code>capabilities</code>集合，上一篇文章中我们已经分析过了Os的作用，最终通过<code>Linux_capget</code>JNI函数调用Linux<code>capget</code>函数，通过返回回来的值，剔除一些当前线程不支持的特权</p>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>接着设置一些fork参数，通过<code>ZygoteArguments</code>去解析它</p>
<p>然后调用<code>Zygote.forkSystemServer</code>方法，这个和上一章里说的fork App的过程差不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止其他线程</span></span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits,</span><br><span class="line">            permittedCapabilities, effectiveCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置默认线程优先级</span></span><br><span class="line">    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="comment">//恢复其他线程</span></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把子线程都停止掉，fork完后再恢复，调用native函数<code>nativeForkSystemServer</code>，路径为<code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effective_capabilities)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">true</span>,</span><br><span class="line">                         fds_to_close,</span><br><span class="line">                         fds_to_ignore,</span><br><span class="line">                         <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// System server prcoess does not need data isolation so no need to</span></span><br><span class="line">      <span class="comment">// know pkg_data_info_list.</span></span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       permitted_capabilities, effective_capabilities,</span><br><span class="line">                       MOUNT_EXTERNAL_DEFAULT, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">true</span>,</span><br><span class="line">                       <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="comment">/* is_top_app= */</span> <span class="literal">false</span>,</span><br><span class="line">                       <span class="comment">/* pkg_data_info_list */</span> <span class="literal">nullptr</span>,</span><br><span class="line">                       <span class="comment">/* whitelisted_data_info_list */</span> <span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="comment">//检查SystemServer进程状态</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//如果SystemServer进程死亡，重启整个Zygote</span></span><br><span class="line">          ALOGE(<span class="string">"System server process %d has died. Restarting Zygote!"</span>, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"System server process has died. Restarting Zygote!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是低内存设备，限制SystemServer进程使用内存大小</span></span><br><span class="line">      <span class="keyword">if</span> (UsePerAppMemcg()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!SetTaskProfiles(pid, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"SystemMemoryProcess"</span>&#125;)) &#123;</span><br><span class="line">              ALOGE(<span class="string">"couldn't add process %d into system memcg group"</span>, pid);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkCommon"><a href="#ForkCommon" class="headerlink" title="ForkCommon"></a>ForkCommon</h3><p>我们先看<code>ForkCommon</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkCommon</span><span class="params">(JNIEnv* env, bool is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; fds_to_close,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; fds_to_ignore,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bool is_priority_fork)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程信号处理器</span></span><br><span class="line">  SetSignalHandlers();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//C++中的一种可调用对象，ZygoteFailure函数接收4个参数，前三个参数都已提供，最后一个参数占位等待调用方填入</span></span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>,</span><br><span class="line">                           nullptr, _1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在fork期间阻塞住SIGCHLD信号，避免在SIGCHLD信号处理函数中打印log，导致后面关闭的日志fd重新被打开</span></span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭所有日志相关fd</span></span><br><span class="line">  __android_log_close();</span><br><span class="line">  AStatsSocket_close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//SystemServer是Zygote进程起来后第一个fork的出来进程，创建打开的文件描述符表</span></span><br><span class="line">  <span class="keyword">if</span> (gOpenFdTable == nullptr) &#123;</span><br><span class="line">    gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立即清除任何未使用的内存</span></span><br><span class="line">  mallopt(M_PURGE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//fork SystemServer时，此参数为true</span></span><br><span class="line">    <span class="keyword">if</span> (is_priority_fork) &#123;</span><br><span class="line">      <span class="comment">//设置最高进程优先级</span></span><br><span class="line">      setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_MAX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_MIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The child process.</span></span><br><span class="line">    PreApplicationInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除所有需要立即关闭的fd</span></span><br><span class="line">    DetachDescriptors(env, fds_to_close, fail_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//USAP机制我们现在不关注</span></span><br><span class="line">    ClearUsapTable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新打开剩余打开的文件描述符，避免文件描述符通过fork在SystemServer和Zygote之间共享</span></span><br><span class="line">    gOpenFdTable-&gt;ReopenOrDetach(fail_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sanitizer机制，用来检测程序异常</span></span><br><span class="line">    android_fdsan_set_error_level(fdsan_error_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the fd to the unsolicited zygote socket</span></span><br><span class="line">    gSystemServerSocketFd = -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ALOGD(<span class="string">"Forked child process %d"</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消之前阻塞的SIGCHLD信号</span></span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理子进程信号"><a href="#处理子进程信号" class="headerlink" title="处理子进程信号"></a>处理子进程信号</h4><p>先设置子进程信号处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    struct sigaction sig_chld = &#123;.sa_flags = SA_SIGINFO, .sa_sigaction = SigChldHandler&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sig_chld, nullptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error setting SIGCHLD handler: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  struct sigaction sig_hup = &#123;&#125;;</span><br><span class="line">  sig_hup.sa_handler = SIG_IGN;</span><br><span class="line">  <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sig_hup, nullptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGW(<span class="string">"Error setting SIGHUP handler: %s"</span>, strerror(errno));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于信号的处理，我们在<a href="https://juejin.cn/post/7049277873877680142#heading-31" target="_blank" rel="noopener">Android源码分析 - init进程</a>中已经了解过一次，<code>SA_SIGINFO</code>这个flag代表调用信号处理函数<code>sa_sigaction</code>的时候，会将信号的信息通过参数<code>siginfo_t</code>传入</p>
<p><code>SIGHUP</code>表示终端断开信号，<code>SIG_IGN</code>表示忽略信号，即忽略终端断开信号</p>
<p>我们看一下<code>Zygote</code>是怎么处理其子进程信号的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>, siginfo_t* info, <span class="keyword">void</span>* <span class="comment">/*ucontext*/</span>)</span> </span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(-<span class="number">1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通知SystemServer，Zygote收到了一个SIGCHLD信号</span></span><br><span class="line">        sendSigChildStatus(pid, info-&gt;si_uid, status);</span><br><span class="line">        ... <span class="comment">//打印子进程状态日志</span></span><br><span class="line">        <span class="comment">//如果崩溃的进程是SystemServer，整个Zygote都会退出，再通过init进程重启</span></span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            async_safe_format_log(ANDROID_LOG_ERROR, LOG_TAG,</span><br><span class="line">                                  <span class="string">"Exit zygote because system server (pid %d) has terminated"</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    errno = saved_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果检测到有子进程退出，通知<code>SystemServer</code>，如果这个进程是<code>SystemServer</code>进程，杀掉<code>Zygote</code>进程重启</p>
<h4 id="ZygoteFailure"><a href="#ZygoteFailure" class="headerlink" title="ZygoteFailure"></a>ZygoteFailure</h4><p>这里先需要理解一下<a href="https://www.jianshu.com/p/f191e88dcc80" target="_blank" rel="noopener">C++11 中的std::function和std::bind</a></p>
<p>简单来说，<code>std::bind</code>返回了一个<code>std::function</code>对象，它是一个可调用对象，实际调用的就是传入的第一个参数：<code>ZygoteFailure</code>函数，这个函数接受4个参数，前三个参数都在<code>std::bind</code>时提供好了，第四个参数以<code>_1</code>占位符替代（<code>std::placeholders::_1</code>）</p>
<p>实际上调用<code>fail_fn(msg)</code>就相当于调用函数<code>ZygoteFailure(env, &quot;system_server&quot;, nullptr, msg)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteFailure</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span>* process_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          jstring managed_process_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;ScopedUtfChars&gt; scoped_managed_process_name_ptr = nullptr;</span><br><span class="line">  <span class="keyword">if</span> (managed_process_name != nullptr) &#123;</span><br><span class="line">    scoped_managed_process_name_ptr.reset(<span class="keyword">new</span> ScopedUtfChars(env, managed_process_name));</span><br><span class="line">    <span class="keyword">if</span> (scoped_managed_process_name_ptr-&gt;c_str() != nullptr) &#123;</span><br><span class="line">      process_name = scoped_managed_process_name_ptr-&gt;c_str();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> std::string&amp; error_msg =</span><br><span class="line">      (process_name == nullptr) ? msg : StringPrintf(<span class="string">"(%s) %s"</span>, process_name, msg.c_str());</span><br><span class="line">  <span class="comment">//抛出异常</span></span><br><span class="line">  env-&gt;FatalError(error_msg.c_str());</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生错误后，最终向Java层抛出了一个异常</p>
<h4 id="BlockSignal-amp-UnblockSignal"><a href="#BlockSignal-amp-UnblockSignal" class="headerlink" title="BlockSignal &amp; UnblockSignal"></a>BlockSignal &amp; UnblockSignal</h4><p>在<code>fork</code>期间需要阻塞住<code>SIGCHLD</code>信号，避免在<code>SIGCHLD</code>信号处理函数中打印log，导致后面关闭的日志fd重新被打开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BlockSignal</span><span class="params">(<span class="keyword">int</span> signum, fail_fn_t fail_fn)</span> </span>&#123;</span><br><span class="line">  sigset_t sigs;</span><br><span class="line">  sigemptyset(&amp;sigs);</span><br><span class="line">  sigaddset(&amp;sigs, signum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigs, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"Failed to block signal %s: %s"</span>, strsignal(signum), strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等<code>fork</code>结束，取消阻塞<code>SIGCHLD</code>信号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnblockSignal</span><span class="params">(<span class="keyword">int</span> signum, fail_fn_t fail_fn)</span> </span>&#123;</span><br><span class="line">  sigset_t sigs;</span><br><span class="line">  sigemptyset(&amp;sigs);</span><br><span class="line">  sigaddset(&amp;sigs, signum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigs, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"Failed to un-block signal %s: %s"</span>, strsignal(signum), strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号集函数我们之前已经在<a href="https://juejin.cn/post/7049277873877680142#heading-32" target="_blank" rel="noopener">Android源码分析 - init进程</a>中介绍过了，很简单，就是将<code>SIGCHLD</code>信号添加到屏蔽集中，<code>fork</code>完后再将这个信号从屏蔽集中移除</p>
<h3 id="SpecializeCommon"><a href="#SpecializeCommon" class="headerlink" title="SpecializeCommon"></a>SpecializeCommon</h3><p>至此，fork操作结束，我们看一下在SystemServer进程中执行的<code>SpecializeCommon</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong permitted_capabilities, jlong effective_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint mount_external, jstring managed_se_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_nice_name, bool is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_child_zygote, jstring managed_instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_app_data_dir, bool is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool mount_data_dirs, bool mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//process_name = "system_server"</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>;</span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1);</span><br><span class="line">  auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//均为nullptr</span></span><br><span class="line">  auto se_info = extract_fn(managed_se_info);</span><br><span class="line">  auto nice_name = extract_fn(managed_nice_name);</span><br><span class="line">  auto instruction_set = extract_fn(managed_instruction_set);</span><br><span class="line">  auto app_data_dir = extract_fn(managed_app_data_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当UID发生改变时（root-&gt;非root）保留capabilities</span></span><br><span class="line">  <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">    EnableKeepCapabilities(fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置Inheritable集合</span></span><br><span class="line">  SetInheritable(permitted_capabilities, fail_fn);</span><br><span class="line">  <span class="comment">//从Bounding集合中移除调用线程相关能力</span></span><br><span class="line">  DropCapabilitiesBoundingSet(fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建私有挂载命名空间，挂载虚拟存储</span></span><br><span class="line">  MountEmulatedStorage(uid, mount_external, need_pre_initialize_native_bridge, fail_fn);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置GroupId</span></span><br><span class="line">  SetGids(env, gids, is_child_zygote, fail_fn);</span><br><span class="line">  <span class="comment">//设置资源Limit</span></span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置gid及访问权限</span></span><br><span class="line">  <span class="keyword">if</span> (setresgid(gid, gid, gid) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"setresgid(%d) failed: %s"</span>, gid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//capabilities集合中仍然存在CAP_SYS_ADMIN，需要过滤系统调用</span></span><br><span class="line">  SetUpSeccompFilter(uid, is_child_zygote);</span><br><span class="line">  <span class="comment">//设置调度策略</span></span><br><span class="line">  SetSchedulerPolicy(fail_fn, is_top_app);</span><br><span class="line">  <span class="comment">//设置uid及访问权限</span></span><br><span class="line">  <span class="keyword">if</span> (setresuid(uid, uid, uid) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"setresuid(%d) failed: %s"</span>, uid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置Capabilities</span></span><br><span class="line">  SetCapabilities(permitted_capabilities, effective_capabilities, permitted_capabilities, fail_fn);</span><br><span class="line">  <span class="comment">//关闭所有日志相关fd</span></span><br><span class="line">  __android_log_close();</span><br><span class="line">  AStatsSocket_close();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置线程名</span></span><br><span class="line">  <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123; <span class="comment">//nice_name为nullptr, 进入此分支</span></span><br><span class="line">    SetThreadName(<span class="string">"system_server"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消掉之前设置的SIGCHID信号处理函数</span></span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">    <span class="comment">//调用ZygoteHooks.postForkSystemServer(runtime_flags);</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      fail_fn(<span class="string">"Error calling post fork system server hooks."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//调用ZygoteHooks.postForkChild(runtime_flags, true, false, null);</span></span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认进程优先级</span></span><br><span class="line">  setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了很多工作，有<code>Capabilities</code>相关，<code>selinux</code>相关，权限相关等等，有点太多了，我标了注释，就不再一一分析了</p>
<p>接下来回到<code>nativeForkSystemServer</code>中，在<code>Zygote</code>进程中继续执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effective_capabilities)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="comment">//检查SystemServer进程状态</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//如果SystemServer进程死亡，重启整个Zygote</span></span><br><span class="line">          ALOGE(<span class="string">"System server process %d has died. Restarting Zygote!"</span>, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"System server process has died. Restarting Zygote!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是低内存设备，限制SystemServer进程使用内存大小</span></span><br><span class="line">      <span class="keyword">if</span> (UsePerAppMemcg()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!SetTaskProfiles(pid, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"SystemMemoryProcess"</span>&#125;)) &#123;</span><br><span class="line">              ALOGE(<span class="string">"couldn't add process %d into system memcg group"</span>, pid);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Linux函数<code>waitpid</code>检查<code>SystemServer</code>进程状态，这个函数和之前在<a href="https://juejin.cn/post/7049277873877680142#heading-38" target="_blank" rel="noopener">Android源码分析 - init进程</a>中提过的<code>waitid</code>函数类似，<code>WNOHANG</code>表示非阻塞等待</p>
<p>如果<code>SystemServer</code>进程死亡，重启整个<code>Zygote</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//SystemServer子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zygote server socket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><p>如果是小内存设备，使用Linux的<code>cgroups</code>机制，限制<code>SystemServer</code>进程使用内存大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UsePerAppMemcg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> low_ram_device = GetBoolProperty(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> GetBoolProperty(<span class="string">"ro.config.per_app_memcg"</span>, low_ram_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Linux的<code>cgroups</code>机制，可以查看这篇文档：<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank" rel="noopener">cgroups(7) — Linux manual page</a></p>
<p>关于Android的<code>Cgroups</code>机制，可以看这篇官方文档：<a href="https://source.android.google.cn/devices/tech/perf/cgroups?hl=zh-cn" target="_blank" rel="noopener">Cgroup 抽象层</a></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将umask设置为0077，这样新的文件和目录将默认为仅属于所有者的权限</span></span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mNiceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.mNiceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对classpath中的apk，分别进行dex优化操作，由installd真正执行</span></span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//SystemServer进入这个分支</span></span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                parsedArgs.mRemainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理一些初始化操作，然后调用<code>ZygoteInit.zygoteInit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通用初始化</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    <span class="comment">//开启binder线程池</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">            classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RuntimeInit</code>的路径为<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>，先执行通用初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置默认线程异常处理器</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="string">"persist.sys.timezone"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置Log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置网络UA信息</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    ...</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行<code>RuntimeInit.applicationInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置虚拟机参数</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查找startClass中的main方法</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>我们看一下它是怎么解析参数的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Arguments(String args[]) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    parseArgs(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseArgs</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curArg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; curArg &lt; args.length; curArg++) &#123;</span><br><span class="line">        String arg = args[curArg];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arg.equals(<span class="string">"--"</span>)) &#123;</span><br><span class="line">            curArg++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!arg.startsWith(<span class="string">"--"</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curArg == args.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Missing classname argument to RuntimeInit!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startClass = args[curArg++];</span><br><span class="line">    startArgs = <span class="keyword">new</span> String[args.length - curArg];</span><br><span class="line">    System.arraycopy(args, curArg, startArgs, <span class="number">0</span>, startArgs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环读参数直到有一项参数为”–”或者不以”–”开头，然后以下一个参数作为<code>startClass</code>，用再下一个参数到args数组结尾生成一个新的数组作为<code>startArgs</code>，我们观察一下<code>forkSystemServer</code>方法中设置的args</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String args[] = &#123;</span><br><span class="line">                <span class="string">"--setuid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span></span><br><span class="line">                        + <span class="string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"</span>,</span><br><span class="line">                <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">                <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">                <span class="string">"--runtime-args"</span>,</span><br><span class="line">                <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">                <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>startClass</code>应该为<code>com.android.server.SystemServer</code>，<code>startArgs</code>数组为空</p>
<h3 id="反射执行"><a href="#反射执行" class="headerlink" title="反射执行"></a>反射执行</h3><p>接着调用<code>findStaticMain</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Java中的反射，找到了<code>SystemServer</code>中对应的<code>main</code>方法，并用其创建了一个<code>Runnable</code>对象<code>MethodAndArgsCaller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行SystemServer.main方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后再回到<code>ZygoteInit</code>的<code>main</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动SystemServer</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程中才会满足r != null</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此时执行这个Runnable</span></span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这个在子进程中返回出去的<code>Runnable</code>：<code>MethodAndArgsCaller</code>，反射调用<code>SystemServer.main</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，<code>SystemServer</code>的启动我们就分析完了，下一篇我们将分析<code>SystemServer</code>启动后做了什么</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/14/linux/LinuxCapabilities%E6%9C%BA%E5%88%B6/">Linux Capabilities机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Capabilities/">Capabilities</a></span><div class="content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>传统的Linux权限控制粒度太粗，以<code>passwd</code>命令为例，修改用户密码是需要root权限的，但普通用户应该是能够修改自己密码的才对，这时候Linux就使用了<code>SUID</code>、<code>EUID</code>机制，使<code>passwd</code>进程以它的所有者root权限运行这样就可以以root权限修改密码了</p>
<p><code>SUID</code>机制是有安全隐患的，<code>passwd</code>进程只需要修改密码的就可以了，却在整个运行周期内获得了root权限，一旦出现漏洞，很有可能会被利用</p>
<p>所以，Linux内核在2.2后引入了<code>Capabilities</code>机制，细粒度化了权限控制，可以做到按需授权</p>
<p>这里是文档：<a href="https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>首先，<code>Capabilities</code>是有一个集合的概念的，即一个进程或可执行文件，它可以拥有哪些特权的集合</p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p>可执行文件有三种Capabilities集合：</p>
<h3 id="Permitted"><a href="#Permitted" class="headerlink" title="Permitted"></a>Permitted</h3><p>当文件执行时，这个集合的内容会被添加到进程的Permitted集合中</p>
<h3 id="Inheritable"><a href="#Inheritable" class="headerlink" title="Inheritable"></a>Inheritable</h3><p>当文件执行后，这个集合会与进程的<code>Inheritable</code>集合做位与操作(&amp;)，以确定进程在执行<code>execve</code>函数后哪些<code>capabilites</code>可以被继承</p>
<h3 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h3><p>这不是一个集合，而是一个位(bit)，如果此bit设为1，则<code>Permitted</code>集合中新增的<code>capabilites</code>会在执行<code>execve</code>函数后添加到进程的<code>Effective</code>集合中</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>设置<code>capabilites</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setcap [capability,capability,...]+[ep] [文件]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"></span><br><span class="line">setcap [capability+ep capability+ep ...] [文件]</span><br></pre></td></tr></table></figure>

<p><code>capability</code>就是某个特权值，+ep代表加入<code>Effective</code>和<code>Permitted</code>集合中</p>
<ul>
<li>获取<code>capabilites</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getcap [文件]</span><br></pre></td></tr></table></figure>

<h2 id="线程（进程）"><a href="#线程（进程）" class="headerlink" title="线程（进程）"></a>线程（进程）</h2><p>线程（进程）有五种Capabilities集合：</p>
<h3 id="Permitted-1"><a href="#Permitted-1" class="headerlink" title="Permitted"></a>Permitted</h3><p>这个集合定义了线程所能够拥有的特权的上限，是<code>Inheritable</code>和<code>Effective</code>集合的的超集</p>
<h3 id="Inheritable-1"><a href="#Inheritable-1" class="headerlink" title="Inheritable"></a>Inheritable</h3><p>包含了当执行<code>execve</code> 函数时，能够被新的可执行文件继承的<code>capabilities</code>（执行<code>execve</code> 函数后会被添加到<code>Permitted</code>集合中）</p>
<h3 id="Effective-1"><a href="#Effective-1" class="headerlink" title="Effective"></a>Effective</h3><p>内核检查特权操作时，实际检查的集合（可以通过执行操作前增/删<code>Effective</code>中的<code>capabilities</code>，以达到临时开/关权限的功能）</p>
<h3 id="Bounding-内核2-6-25以后"><a href="#Bounding-内核2-6-25以后" class="headerlink" title="Bounding (内核2.6.25以后)"></a>Bounding (内核2.6.25以后)</h3><p>这个集合是 <code>Inheritable</code> 集合的超集，如果某个<code>capability</code>不在<code>Bounding</code>集合中，即使它在<code>Permitted</code>集合中，该线程也不能将该<code>capability</code>添加到它的<code>Inheritable</code>集合中，该集合在<code>execve</code>后不可再添加<code>capabilities</code></p>
<h3 id="Ambient-内核4-3以后"><a href="#Ambient-内核4-3以后" class="headerlink" title="Ambient (内核4.3以后)"></a>Ambient (内核4.3以后)</h3><p>这个集合是<code>Permitted</code>和<code>Inheritable</code>的子集，当<code>Permitted</code>和<code>Inheritable</code>删除某个<code>capability</code>时，也会自动删除该集合中对应的<code>capability</code>，子进程会自动继承这个集合中的<code>capabilities</code>，子进程的<code>Permitted</code>、<code>Effective</code>和<code>Ambient</code>都会拥有这些<code>capabilities</code></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="capset"><a href="#capset" class="headerlink" title="capset"></a>capset</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capset</span><span class="params">(<span class="keyword">cap_user_header_t</span> hdrp, <span class="keyword">const</span> <span class="keyword">cap_user_data_t</span> datap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://linux.die.net/man/2/capset" target="_blank" rel="noopener">https://linux.die.net/man/2/capset</a></p>
<h4 id="capget"><a href="#capget" class="headerlink" title="capget"></a>capget</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capget</span><span class="params">(<span class="keyword">cap_user_header_t</span> hdrp , <span class="keyword">cap_user_data_t</span> datap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://linux.die.net/man/2/capget" target="_blank" rel="noopener">https://linux.die.net/man/2/capget</a></p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_header_struct</span> &#123;</span></span><br><span class="line">    __u32 version;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"> &#125; *<span class="keyword">cap_user_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_data_struct</span> &#123;</span></span><br><span class="line">    __u32 effective;</span><br><span class="line">    __u32 permitted;</span><br><span class="line">    __u32 inheritable;</span><br><span class="line"> &#125; *<span class="keyword">cap_user_data_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h1><p>我们用 <code>P</code> 代表执行 <code>execve()</code> 前线程的 capabilities，<code>P&#39;</code> 代表执行 <code>execve()</code> 后线程的 <code>capabilities</code>，<code>F</code> 代表可执行文件的 <code>capabilities</code>，那么：</p>
<blockquote>
<p>P’(ambient) = (file is privileged) ? 0 : P(ambient)</p>
<p>P’(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding))) | P’(ambient)</p>
<p>P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)</p>
<p>P’(inheritable) = P(inheritable) [i.e., unchanged]</p>
<p>P’(bounding) = P(bounding) [i.e., unchanged]</p>
</blockquote>
<p>我们一条一条来解释：</p>
<ul>
<li><p>如果用户是 root 用户，那么执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合是空集；如果是普通用户，那么执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合将会继承执行 <code>execve()</code> 前线程的 <code>Ambient</code> 集合。</p>
</li>
<li><p>执行 <code>execve()</code> 前线程的 <code>Inheritable</code> 集合与可执行文件的 <code>Inheritable</code> 集合取交集，会被添加到执行 <code>execve()</code> 后线程的 <code>Permitted</code> 集合；可执行文件的 capability bounding 集合与可执行文件的 <code>Permitted</code> 集合取交集，也会被添加到执行 <code>execve()</code> 后线程的 <code>Permitted</code> 集合；同时执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合中的 capabilities 会被自动添加到该线程的 <code>Permitted</code> 集合中。</p>
</li>
<li><p>如果可执行文件开启了 Effective 标志位，那么在执行完 <code>execve()</code> 后，线程 <code>Permitted</code> 集合中的 capabilities 会自动添加到它的 <code>Effective</code> 集合中。</p>
</li>
<li><p>执行 <code>execve()</code> 前线程的 <code>Inheritable</code> 集合会继承给执行 <code>execve()</code> 后线程的 <code>Inheritable</code> 集合。</p>
</li>
</ul>
<p>这里有几点需要着重强调：</p>
<ol>
<li><p>上面的公式是针对系统调用 <code>execve()</code> 的，如果是 <code>fork()</code>，那么子线程的 capabilities 信息完全复制父进程的 capabilities 信息。</p>
</li>
<li><p>可执行文件的 <code>Inheritable</code> 集合与线程的 <code>Inheritable</code> 集合并没有什么关系，可执行文件 <code>Inheritable</code> 集合中的 capabilities 不会被添加到执行 <code>execve()</code> 后线程的 <code>Inheritable</code> 集合中。如果想让新线程的 <code>Inheritable</code> 集合包含某个 capability，只能通过 <code>capset()</code> 将该 capability 添加到当前线程的 <code>Inheritable</code> 集合中（因为 P’(inheritable) = P(inheritable)）。</p>
</li>
<li><p>如果想让当前线程 <code>Inheritable</code> 集合中的 capabilities 传递给新的可执行文件，该文件的 <code>Inheritable</code> 集合中也必须包含这些 capabilities（因为 P’(permitted)   = (P(inheritable) &amp; F(inheritable))|…）。</p>
</li>
<li><p>将当前线程的 capabilities 传递给新的可执行文件时，仅仅只是传递给新线程的 <code>Permitted</code> 集合。如果想让其生效，新线程必须通过 <code>capset()</code> 将 capabilities 添加到 <code>Effective</code> 集合中。或者开启新的可执行文件的 Effective 标志位（因为 P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)）。</p>
</li>
<li><p>在没有 <code>Ambient</code> 集合之前，如果某个脚本不能调用 <code>capset()</code>，但想让脚本中的线程都能获得该脚本的 <code>Permitted</code> 集合中的 capabilities，只能将 <code>Permitted</code> 集合中的 capabilities 添加到 <code>Inheritable</code> 集合中（P’(permitted)  = P(inheritable) &amp; F(inheritable)|…），同时开启 Effective 标志位（P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)）。有 有 <code>Ambient</code> 集合之后，事情就变得简单多了，后续的文章会详细解释。</p>
</li>
<li><p>如果某个 UID 非零（普通用户）的线程执行了 <code>execve()</code>，那么 <code>Permitted</code> 和 <code>Effective</code> 集合中的 capabilities 都会被清空。</p>
</li>
<li><p>从 root 用户切换到普通用户，那么 <code>Permitted</code> 和 <code>Effective</code> 集合中的 capabilities 都会被清空，除非设置了 SECBIT_KEEP_CAPS 或者更宽泛的 SECBIT_NO_SETUID_FIXUP。</p>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Capabilities表"><a href="#Capabilities表" class="headerlink" title="Capabilities表"></a>Capabilities表</h2><table>
<thead>
<tr>
<th>Capability</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CAP_AUDIT_CONTROL</td>
<td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td>CAP_AUDIT_READ</td>
<td>允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td>CAP_AUDIT_WRITE</td>
<td>将记录写入内核审计日志</td>
</tr>
<tr>
<td>CAP_BLOCK_SUSPEND</td>
<td>使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td>CAP_BPF (5.8)</td>
<td>从CAP_SYS_ADMIN分离一部分BFP功能，控制了一些BPF特定的操作，包括创建BPF maps、使用一些高级的BPF程序功能、访问BPF type format（BTF）数据等</td>
</tr>
<tr>
<td>CAP_CHECKPOINT_RESTORE (5.9)</td>
<td>允许更新/proc/sys/kernel/ns_last_pid，使用set_tid特性，读其他进程的/proc/[pid]/map_files</td>
</tr>
<tr>
<td>CAP_CHOWN</td>
<td>修改文件所有者的权限</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>允许设置文件的 setuid 位</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许锁定共享内存片段</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>忽略 IPC 所有权检查</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td>CAP_LEASE</td>
<td>允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td>CAP_MAC_ADMIN</td>
<td>允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td>CAP_MAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_MKNOD</td>
<td>允许使用 mknod() 系统调用</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许执行网络管理任务</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和多播访问</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用原始套接字</td>
</tr>
<tr>
<td>CAP_PERFMON (5.8)</td>
<td>管理性能监控task</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许改变进程的 GID</td>
</tr>
<tr>
<td>CAP_SETFCAP</td>
<td>允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>允许设置其他进程的 capabilities</td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许改变进程的 UID</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许重新启动系统</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用 chroot() 系统调用</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许插入和删除内核模块</td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许跟踪任何进程</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略资源限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许改变系统时钟</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置 TTY 设备</td>
</tr>
<tr>
<td>CAP_SYSLOG</td>
<td>允许使用 syslog() 系统调用</td>
</tr>
<tr>
<td>CAP_WAKE_ALARM</td>
<td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/sparkdev/p/11417781.html" target="_blank" rel="noopener">Linux Capabilities 简介</a></p>
<p><a href="http://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank" rel="noopener">Linux的capabilities机制</a></p>
<p><a href="https://fuckcloudnative.io/posts/linux-capabilities-why-they-exist-and-how-they-work/" target="_blank" rel="noopener">Linux Capabilities 入门教程：概念篇</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/10/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Zygote%E8%BF%9B%E7%A8%8B/">Android源码分析 - Zygote进程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Zygote/">Zygote</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7049277873877680142" target="_blank" rel="noopener">Android源码分析 - init进程</a>，我们分析了Android第一个用户进程init进程的启动过程和之后的守护服务</p>
<p>init进程启动了很多服务，例如Zygote，ServiceManager，MediaServer，SurfaceFlinger等，我们平常写Android应用都是使用Java语言，这次我们就先从Java世界的半边天：Zygote进程 开始分析</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Zygote意为受精卵，它有两大作用，一是启动SystemServer，二是孵化启动App</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>我们已经知道了init进程会从<code>init.rc</code>文件中解析并启动服务，那zygote是在哪定义的呢，<code>init.rc</code>的头几行就有一个import：<code>import /system/etc/init/hw/init.${ro.zygote}.rc</code></p>
<p>我们在init.rc同目录下就能找到几个对应的文件：<code>init.zygote32_64.rc</code> <code>init.zygote32.rc</code> <code>init.zygote64_32.rc</code> <code>init.zygote64.rc</code>，具体import哪个文件与具体设备硬件有关，现在64位手机这么普及了，我们就以<code>init.zygote64.rc</code>为目标分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p>下面的子项我们暂时不用关心，先记住<code>app_process64</code>的启动参数<code>-Xzygote /system/bin --zygote --start-system-server</code>即可</p>
<p>Zygote启动的源文件为<code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建了一个AppRuntime，继承自AndroidRuntime，重写了一些回调方法</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    <span class="comment">//在启动服务时，传进来的参数是包含文件路径的</span></span><br><span class="line">    <span class="comment">//我们不需要这个参数，就减一下个数，移一下指针</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理参数，这里只添加了一个-Xzygote参数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过参数/system/bin，这个参数目前没有被使用</span></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有--zygote参数</span></span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//ZYGOTE_NICE_NAME在64位下为zygote64，32位下为zygote</span></span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有-start-system-server参数</span></span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//这个分支不会进入Zygote模式</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        <span class="comment">//新建Dalvik缓存目录</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加启动参数</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="comment">//Zygote模式下没有其他参数了</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//设置程序名以及进程名</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//执行AndroidRuntime::start方法</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体结构还是比较简单的，就是处理一下参数，进入zygote对应的分支，执行AndroidRuntime::start方法，第一个参数传的是ZygoteInit在Java中的类名，第二个参数传了一些选项（start-system-server和abi-list），第三个参数传了true，代表启动虚拟机的时候需要额外添加一些JVM参数</p>
<h1 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime::start"></a>AndroidRuntime::start</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Whether this is the primary zygote, meaning the zygote which will fork system server.</span></span><br><span class="line">    <span class="comment">//64_32位兼容设备上会启动两个Zygote，一个叫zygote，一个叫zygote_secondary</span></span><br><span class="line">    <span class="keyword">bool</span> primary_zygote = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有start-system-server选项则代表是主Zygote</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查和配置一些环境变量</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    <span class="comment">//加载libart.so</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//启动JVM</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调AppRuntime中重写的方法</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//注册Android JNI函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断选项中是否携带参数start-system-server，如有，则将它视为主Zygote，接着就开始启动JVM了</p>
<h1 id="启动JVM"><a href="#启动JVM" class="headerlink" title="启动JVM"></a>启动JVM</h1><h2 id="JniInvocation"><a href="#JniInvocation" class="headerlink" title="JniInvocation"></a>JniInvocation</h2><p>使用JniInvocation初始化Android ART虚拟机环境，它的路径是<code>libnativehelper/include_platform/nativehelper/JniInvocation.h</code>，我们来看一下它是怎么做的</p>
<p>我们首先看一下它的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libnativehelper/include_platform/nativehelper/JniInvocation.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JniInvocation</span> <span class="title">final</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    JniInvocation() &#123;</span><br><span class="line">        impl_ = JniInvocationCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~JniInvocation() &#123;</span><br><span class="line">        JniInvocationDestroy(impl_);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>JniInvocationCreate</code>方法创建了一个JniInvocationImpl实例对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JniInvocationImpl* <span class="title">JniInvocationCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JniInvocationImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>JniInvocation::Init</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JniInvocationInit(impl_, library) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JniInvocationInit</span><span class="params">(JniInvocationImpl* instance, <span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;Init(library) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JniInvocation</code>实际上是个代理类，内部实现是交给<code>JniInvocationImpl</code>的，路径为<code>libnativehelper/JniInvocation.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//非debug一律为libart.so</span></span><br><span class="line">  library = GetLibrary(library, <span class="built_in">buffer</span>);</span><br><span class="line">  <span class="comment">//加载libart.so库</span></span><br><span class="line">  handle_ = OpenLibrary(library);</span><br><span class="line">  <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是加载libart.so库失败，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(library, kLibraryFallback) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Nothing else to try.</span></span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果是加载其他库失败，尝试回退加载libart.so库</span></span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    handle_ = OpenLibrary(library);</span><br><span class="line">    <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从libart.so库获得三个JVM相关的函数地址</span></span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_),</span><br><span class="line">                  <span class="string">"JNI_GetDefaultJavaVMInitArgs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_CreateJavaVM_),</span><br><span class="line">                  <span class="string">"JNI_CreateJavaVM"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetCreatedJavaVMs_),</span><br><span class="line">                  <span class="string">"JNI_GetCreatedJavaVMs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载libart-so库"><a href="#加载libart-so库" class="headerlink" title="加载libart.so库"></a>加载libart.so库</h3><p>我们先看<code>GetLibrary</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* kLibraryFallback = <span class="string">"libart.so"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">JniInvocationImpl::GetLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">char</span>* <span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">bool</span> (*is_debuggable)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> (*get_library_system_property)(<span class="keyword">char</span>* <span class="built_in">buffer</span>))</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ANDROID__</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_debuggable()) &#123;</span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    default_library = kLibraryFallback;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library = kLibraryFallback;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (library == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    library = default_library;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> library;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在debug模式或<code>library</code>参数为<code>NULL</code>的情况下都是直接返回的<code>libart.so</code></p>
<p>而<code>OpenLibrary</code>方法是使用了<code>dlopen</code>函数，加载<code>libart.so</code>库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">OpenLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> kDlopenFlags = RTLD_NOW | RTLD_NODELETE;</span><br><span class="line">  <span class="keyword">return</span> dlopen(filename, kDlopenFlags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen"></a>dlopen</h4><p>原型：<code>void *dlopen(const char *filename, int flags);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlopen.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlopen.3.html</a></p>
<p>这是一个Linux函数，用来加载一个动态链接库，当加载成功时，会返回一个句柄</p>
<p>上面的这两个参数，<code>RTLD_NOW</code>代表立即计算库的依赖性，<code>RTLD_NODELETE</code>代表不要再<code>dlclose</code>期间卸载库，这样当再次加载库的时候不会重新初始化对象的静态全局变量，使用这个flag是为了确保<code>libart.so</code>在关闭时不会被取消映射。因为即使在 <code>JNI_DeleteJavaVM</code> 调用之后，某些线程仍可能尚未完成退出，如果卸载该库，则可能导致段错误</p>
<h3 id="从libart-so库中寻找函数地址"><a href="#从libart-so库中寻找函数地址" class="headerlink" title="从libart.so库中寻找函数地址"></a>从libart.so库中寻找函数地址</h3><p>接着调用<code>FindSymbol</code>函数查找函数地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_POINTER void*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::FindSymbol</span><span class="params">(FUNC_POINTER* pointer, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得函数地址</span></span><br><span class="line">  *pointer = GetSymbol(handle_, symbol);</span><br><span class="line">  <span class="comment">//获取失败，卸载libart.so库</span></span><br><span class="line">  <span class="keyword">if</span> (*pointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Failed to find symbol %s: %s\n"</span>, symbol, GetError().c_str());</span><br><span class="line">    CloseLibrary(handle_);</span><br><span class="line">    handle_ = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FUNC_POINTER <span class="title">GetSymbol</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> dlsym(handle, symbol);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym"></a>dlsym</h4><p>原型：<code>void *dlsym(void *restrict handle , const char *restrict symbol);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlsym.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlsym.3.html</a></p>
<p>也是一个Linux函数，用来从已加载的动态链接库中获取一个函数的地址</p>
<p>传入的第一个参数为之前加载库时返回的句柄，第二个参数为函数名</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下全局，<code>JniInvocationImpl::Init</code>的作用是，加载<code>libart.so</code>库，并从中获取三个函数指针：</p>
<ul>
<li>JNI_GetDefaultJavaVMInitArgs：获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM：创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs：获取创建的虚拟机实例</li>
</ul>
<p>这几个函数被定义在<code>jni.h</code>中，后面我们创建JVM的时候会用到这些函数</p>
<h2 id="AndroidRuntime-startVm"><a href="#AndroidRuntime-startVm" class="headerlink" title="AndroidRuntime::startVm"></a>AndroidRuntime::startVm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote, <span class="keyword">bool</span> primary_zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaVMInitArgs initArgs;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//配置了一大堆JVM选项</span></span><br><span class="line">    </span><br><span class="line">    initArgs.version = JNI_VERSION_1_4;</span><br><span class="line">    initArgs.options = mOptions.editArray();</span><br><span class="line">    initArgs.nOptions = mOptions.<span class="built_in">size</span>();</span><br><span class="line">    initArgs.ignoreUnrecognized = JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并初始化JVM</span></span><br><span class="line">    <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JNI_CreateJavaVM failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JNI_CreateJavaVM</code>方法就是我们之前从<code>libart.so</code>里获得的方法，被编译进<code>libart.so</code>前，源码的路径为<code>art/runtime/jni/java_vm_ext.cc</code>，接下来属于ART虚拟机的工作，我们就不再往下深究了</p>
<p>后面有一个<code>onVmCreated</code>回调，但在zygote模式下没做任何事</p>
<h1 id="注册JNI函数"><a href="#注册JNI函数" class="headerlink" title="注册JNI函数"></a>注册JNI函数</h1><p>接着调用<code>startReg</code>函数注册Android JNI函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register android native functions with the VM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置Native创建线程的函数，通过javaCreateThreadEtc这个函数创建的线程</span></span><br><span class="line">    <span class="comment">//会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建局部引用栈帧</span></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册jni函数</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前栈帧出栈，释放其中所有局部引用</span></span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先hook了Native创建线程的函数，之后创建线程便会调用我们设置的<code>javaCreateThreadEtc</code>函数，<br>会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码。这个等之后看到Android线程创建的时候再分析</p>
<p><code>PushLocalFrame</code>和<code>PopLocalFrame</code>是一对函数，它们是用来管理JNI的局部引用的</p>
<p>首先，<code>PushLocalFrame</code>会创建出一个局部引用栈帧，之后JNI创建出来的局部引用都会放在这个栈帧里，等使用结束后调用PopLocalFrame函数，会将当前栈帧出栈，并且释放其中所有的局部引用</p>
<p>接下来我们看<code>register_jni_procs</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是循环执行<code>gRegJNI</code>数组中所有的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">        REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">        REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),</span><br><span class="line">        REG_JNI(register_android_os_SystemClock),</span><br><span class="line">        REG_JNI(register_android_util_EventLog),</span><br><span class="line">        REG_JNI(register_android_util_Log),</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>gRegJNI</code>数组中存放着很多Java类注册JNI函数的函数，后面大家如果阅读源码看到了Android中的native方法可以来这边找它所对应的c++实现</p>
<p>这边注册的类非常多，我们就取第一个<code>register_com_android_internal_os_RuntimeInit</code>为例分析一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="keyword">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">            &#123;<span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeFinishInit&#125;,</span><br><span class="line">            &#123;<span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">"com/android/internal/os/RuntimeInit"</span>,</span><br><span class="line">        methods, NELEM(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个JNINativeMethod结构体，第一个成员是Java中的方法名，第二个成员是Java中对应方法的签名，第三个成员是Java方法对应native函数的函数指针，然后调用<code>jniRegisterNativeMethods</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(C_JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Registering %s's %d native methods..."</span>, className, numMethods);</span><br><span class="line"></span><br><span class="line">    <span class="function">scoped_local_ref&lt;jclass&gt; <span class="title">c</span><span class="params">(env, findClass(env, className))</span></span>;</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(c.<span class="built_in">get</span>() == <span class="literal">NULL</span>,</span><br><span class="line">                         <span class="string">"Native registration unable to find class '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = e-&gt;RegisterNatives(c.<span class="built_in">get</span>(), gMethods, numMethods);</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"RegisterNatives failed for '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数先通过Java类名获得一个jclass对象，接着调用<code>JNIEnv::RegisterNatives</code>函数，这个函数定义在<code>jni.h</code>中，实现在<code>libart.so</code>库中，我们在平时开发jni的时候，动态注册native方法的时候就会使用到它，这里就不再往下分析了</p>
<h1 id="进入JAVA世界"><a href="#进入JAVA世界" class="headerlink" title="进入JAVA世界"></a>进入JAVA世界</h1><p>JVM启动好了，JNI函数也注册完毕了，接下来就该进入到JAVA世界了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看不懂的自己先补一下JNI知识，总之就是调用了<code>com.android.internal.os.ZygoteInit</code>类的静态方法<code>main</code>，以<code>com.android.internal.os.ZygoteInit</code>，<code>start-system-server</code>和<code>abi-list</code>作为参数</p>
<h1 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h1><p><code>ZygoteInit</code>类的源码路径为<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<p>我们这就开始分析它的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="comment">//标记着zygote开始启动，不允许创建线程（Zygote必须保证单线程）</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    <span class="comment">//设置进程组id</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//配置参数</span></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String zygoteSocketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public static final String PRIMARY_SOCKET_NAME = "zygote";</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//预加载</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Java层的垃圾回收</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//回调AppRRuntime中的onZygoteInit函数</span></span><br><span class="line">        Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除创建线程限制（马上就要执行fork了，子进程要有能力创建线程）</span></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动SystemServer</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        <span class="comment">//执行死循环监听socket，负责接收事件，启动App</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="comment">//接收到AMS的启动App请求后，fork出子进程，处理App启动</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ZygoteHooks.startZygoteNoThreadCreation()</code>禁止创建线程，Zygote必须保证单线程，这和<code>fork</code>机制有关，<code>fork</code>函数只会将当前线程复制到子进程，同时，<code>fork</code>会将锁也复制到子进程中，如果在<code>fork</code>之前，有一个线程持有了锁，但是<code>fork</code>的时候没把这个线程复制到子进程中，这把锁就被永久持有了，会造成死锁</p>
<h2 id="android-system-Os"><a href="#android-system-Os" class="headerlink" title="android.system.Os"></a>android.system.Os</h2><p>我们看一下<code>Os</code>是什么，根据import我们知道它的全限定类名为<code>android.system.Os</code>，它的源码路径为<code>libcore/luni/src/main/java/android/system/Os.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> libcore.io.Libcore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Os</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; Libcore.os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面全是这种形式的静态代理方法，实际调用<code>Libcore.os</code>执行，我们就以<code>setpgid</code>方法去追踪一下</p>
<p><code>Libcore</code>位于<code>libcore/luni/src/main/java/libcore/io/Libcore.java</code>，<code>os</code>是其中的一个静态变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Direct access to syscalls. Code should strongly prefer using &#123;<span class="doctag">@link</span> #os&#125;</span></span><br><span class="line"><span class="comment">     * unless it has a strong reason to bypass the helpful checks/guards that it</span></span><br><span class="line"><span class="comment">     * provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Access to syscalls with helpful checks/guards.</span></span><br><span class="line"><span class="comment">     * For read access only; the only supported way to update this field is via</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #compareAndSetOs&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Os <span class="title">getOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os</code>的类型为<code>BlockGuardOs</code>，以<code>Linux</code>类型的常量<code>rawOs</code>作为构造方法参数实例化，它继承自<code>ForwardingOs</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingOs</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Os os;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="meta">@libcore</span>.api.CorePlatformApi</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForwardingOs</span><span class="params">(Os os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.os = Objects.requireNonNull(os);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这其实又是一个代理类，实际上是直接调用了<code>Linux</code>类的方法，至于<code>BlockGuardOs</code>，它在部分方法上做了一些回调监听，除此之外也是直接调用了<code>Linux</code>类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    Linux() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">int</span> pid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面基本上都是JNI调用native方法，对应的c++源码路径为<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>，下面是注册JNI函数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE_METHOD(className, functionName, signature)                \</span></span><br><span class="line">  MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_JNI_NATIVE_METHOD(name, signature, function)                      \</span></span><br><span class="line">  _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \</span></span><br><span class="line">  MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \</span></span><br><span class="line">  ([]() &#123;                                                                \</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> nativehelper::detail;  <span class="comment">/* NOLINT(google-build-using-namespace) */</span> \</span><br><span class="line">    <span class="keyword">static_assert</span>(                                                       \</span><br><span class="line">        MatchJniDescriptorWithFunctionType&lt;native_kind,                  \</span><br><span class="line">                                           <span class="keyword">decltype</span>(fn),                 \</span><br><span class="line">                                           fn,                           \</span><br><span class="line">                                           <span class="keyword">sizeof</span>(signature_)&gt;(signature_),\</span><br><span class="line">        <span class="string">"JNI signature doesn't match C++ function type."</span>);               \</span><br><span class="line">    <span class="comment">/* Suppress implicit cast warnings by explicitly casting. */</span>         \</span><br><span class="line">    <span class="keyword">return</span> JNINativeMethod &#123;                                             \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::name)&gt;(name_),              \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::signature)&gt;(signature_),    \</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;(fn))&#125;;                                 \</span><br><span class="line">  &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    NATIVE_METHOD(Linux, setpgid, <span class="string">"(II)V"</span>),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_libcore_io_Linux</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jniRegisterNativeMethods(env, <span class="string">"libcore/io/Linux"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Java层方法对应native方法的格式为<code>Linux_方法名</code>，我们通过这种规则找到<code>setpgid</code>方法对应的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Linux_setpgid</span><span class="params">(JNIEnv* env, jobject, jint pid, <span class="keyword">int</span> pgid)</span> </span>&#123;</span><br><span class="line">    throwIfMinusOne(env, <span class="string">"setpgid"</span>, TEMP_FAILURE_RETRY(setpgid(pid, pgid)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是直接调用了Linux系统层函数</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>综上所述，<code>android.system.Os</code>类存在的意义是可以使Java层能够方便的调用Linux系统方法</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>接下来就是一些参数配置工作，然后调用<code>preload</code>预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载Java类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//加载三个jar文件</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.base-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.manager-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.test.base.jar */</span></span><br><span class="line">    cacheNonBootClasspathClassLoaders();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载系统资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载硬件抽象层？</span></span><br><span class="line">    nativePreloadAppProcessHALs();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载opengl</span></span><br><span class="line">    maybePreloadGraphicsDriver();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载动态库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    <span class="comment">//TextView预加载Font</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line">    <span class="comment">//预加载webviewchromium</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preloadClasses"><a href="#preloadClasses" class="headerlink" title="preloadClasses"></a>preloadClasses</h3><p>我们看看Java类的预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRELOADED_CLASSES = <span class="string">"/system/etc/preloaded-classes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(PRELOADED_CLASSES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Couldn't find "</span> + PRELOADED_CLASSES + <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">            line = line.trim();</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//Java类加载器加载类</span></span><br><span class="line">            Class.forName(line, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            count++;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"...preloaded "</span> + count + <span class="string">" classes in "</span></span><br><span class="line">                + (SystemClock.uptimeMillis() - startTime) + <span class="string">"ms."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error reading "</span> + PRELOADED_CLASSES + <span class="string">"."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的代码就是从<code>/system/etc/preloaded-classes</code>这个文件中读取出需要预加载的类，再通过<code>Class.forName</code>使用类加载器加载一遍，编译前的路径为<code>frameworks/base/config/preloaded-classes</code></p>
<h3 id="为什么需要预加载"><a href="#为什么需要预加载" class="headerlink" title="为什么需要预加载"></a>为什么需要预加载</h3><p>Zygote进程的一大作用就是孵化App，那是怎么孵化的呢？这过程中肯定要使用到<code>fork</code>，我们知道，<code>fork</code>后，父子进程是可以共享资源的，既然我们每启动一个App，都需要使用虚拟机、加载一些View等必要的类等等，那为何不在父进程中加载好这些，fork后子进程不就可以直接使用它们了吗？这就是Zygote进程预加载的原因</p>
<h2 id="启动binder线程池"><a href="#启动binder线程池" class="headerlink" title="启动binder线程池"></a>启动binder线程池</h2><p>预加载结束后，会先清理一下Java层的垃圾，然后调用<code>Zygote.initNativeState(isPrimaryZygote)</code>方法，这个方法调用了native方法<code>nativeInitNativeState</code>，这个方法是在<code>AndroidRuntime</code>中注册的，同时也实现在<code>AndroidRuntime</code>中，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前分析过，执行的是<code>AndroidRuntime</code>的子类<code>AppRuntime</code>的<code>onZygoteInit</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数启动Binder线程池，至于Binder的细节，我们留到以后再分析</p>
<h2 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h2><p><code>Zygote</code>进程孵化的第一个进程便是<code>SystemServer</code>，具体怎么孵化的，孵化后SystemServer又做了什么，留在下一节我们再分析</p>
<h1 id="ZygoteServer"><a href="#ZygoteServer" class="headerlink" title="ZygoteServer"></a>ZygoteServer</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们知道，我们App都是从<code>Zygote</code>孵化而来的，App启动是从<code>ActivityManagerService</code>的<code>startActivity</code>方法开始的，那么AMS是怎么和Zygote通信的呢，答案是通过socket</p>
<p>我们先从ZygoteServer的构造方法开始看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZygoteServer(<span class="keyword">boolean</span> isPrimaryZygote) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一些东西是和USAP机制有关的，但在AOSP中默认是关闭的，关于USAP机制我们以后再分析，现在只需要关注<code>mZygoteSocket</code>就可以了，它是通过调用<code>Zygote.createManagedSocketFromInitSocket</code>赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalServerSocket <span class="title">createManagedSocketFromInitSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fileDesc;</span><br><span class="line">    <span class="comment">//ANDROID_SOCKET_zygote</span></span><br><span class="line">    <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得文件描述符</span></span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Socket unset or invalid: "</span> + fullSocketName, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.setInt$(fileDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Error building socket from file descriptor: "</span> + fileDesc, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是从系统属性中获取一个fd，然后实例化<code>LocalServerSocket</code>，路径为<code>frameworks/base/core/java/android/net/LocalServerSocket.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LocalServerSocket</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    impl = <span class="keyword">new</span> LocalSocketImpl(fd);</span><br><span class="line">    impl.listen(LISTEN_BACKLOG);</span><br><span class="line">    localAddress = impl.getSockAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部创建了一个<code>LocalSocketImpl</code>，然后调用了<code>listen</code>方法声明开始监听这个fd，内部调用了Linux的<code>listen</code>函数</p>
<h2 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h2><p>然后我们来看在<code>ZygoteInit</code>中调用的<code>runSelectLoop</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; socketFDs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将server socket fd加到列表头（后面需要判断是否为server socket）</span></span><br><span class="line">    socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        StructPollfd[] pollFDs;</span><br><span class="line">        ...</span><br><span class="line">        pollFDs = <span class="keyword">new</span> StructPollfd[socketFDs.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pollIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class="line">            pollFDs[pollIndex] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFDs[pollIndex].fd = socketFD;</span><br><span class="line">            pollFDs[pollIndex].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            ++pollIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//上面一大段都与USAP机制有关，这里先不关注</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pollReturnValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待文件描述符上的事件</span></span><br><span class="line">            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollReturnValue == <span class="number">0</span>) &#123; <span class="comment">//没有接收到事件（超时），从循环开头重新开始等待事件</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有要读取的数据，跳过</span></span><br><span class="line">                <span class="keyword">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pollIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//pollIndex == 0说明这个fd是ZygoteServer socket的fd</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//接受并建立一个socket连接</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    <span class="comment">//将client socket fd加入列表</span></span><br><span class="line">                    socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class="line">                    <span class="comment">//不使用USAP机制的话，pollIndex &lt; usapPoolEventFDIndex条件一定成立</span></span><br><span class="line">                    <span class="comment">//进入这边说明是client socket</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//内部执行fork，返回一个待执行Runnable用于处理子进程后续任务</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(pollIndex);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//fork后，在子进程中会将这个变量设为true</span></span><br><span class="line">                        <span class="keyword">if</span> (mIsForkChild) &#123; <span class="comment">//子进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//return出去，由ZygoteInit执行这个Runnable</span></span><br><span class="line">                            <span class="keyword">return</span> command;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//读取完了，关闭这个socket，清理列表</span></span><br><span class="line">                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                                connection.closeSocket();</span><br><span class="line">                                peers.remove(pollIndex);</span><br><span class="line">                                socketFDs.remove(pollIndex);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ... <span class="comment">//不开启USAP机制不会走到这个分支</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个列表，<code>socketFDs</code>和<code>peers</code>的下标是一一对应的，首先将server socket fd添加到列表头，方便后续判断事件是来自client或是server socker，<code>peers</code>列表也要添加一个<code>null</code>作为<code>socketFDs</code>的对应</p>
<p>接着就开始执行死循环，<code>Zygote</code>进程永远不会退出这个循环，只有<code>fork</code>出子进程后，子进程会主动return</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>为了理解后面的内容，我们先要学习一下poll函数</p>
<p>poll是Linux中的字符设备驱动中的一个函数，它的作用是等待文件描述符上的某个事件</p>
<p>原型：<code>int poll(struct pollfd * fds , nfds_t nfds , int timeout );</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/poll.2.html</a></p>
<p>第一个参数是一个<code>pollfd</code>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fd不用多说，就是文件描述符</li>
<li>event代表关注哪些事件，<code>POLLIN</code>代表可读，<code>POLLOUT</code>代表可写等等</li>
<li>revents是由内核通知的，函数返回的时候，会设置对应的fd实际发生的事件，比如fd有可读的事件，设置<code>POLLIN</code></li>
</ul>
<p>第二个参数<code>nfds</code>表示fd的个数，即<code>pollfd</code>数组的size</p>
<p>第三个参数表示超时时间</p>
<p>返回值：</p>
<ul>
<li>大于0：表示有fd事件产生，值为有产生事件的fd的个数</li>
<li>等于0：表示超时</li>
<li>小于0：表示有错误产生</li>
</ul>
<h4 id="StructPollfd-amp-pollfd"><a href="#StructPollfd-amp-pollfd" class="headerlink" title="StructPollfd &amp; pollfd"></a>StructPollfd &amp; pollfd</h4><p>弄懂poll是干嘛的后，我们再来接着看<code>runSelectLoop</code>方法</p>
<p>死循环中首先创建了一个<code>StructPollfd</code>数组，它根据<code>socketFDs</code>依次创建出一个个<code>StructPollfd</code>对象，并将他们的事件都设为<code>POLLIN</code>可读</p>
<p><code>StructPollfd</code>和c中的结构体<code>pollfd</code>是对应的，目的是为了方便Java层调用Linux的<code>poll</code>函数</p>
<p><code>StructPollfd</code>的路径为<code>libcore/luni/src/main/java/android/system/StructPollfd.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StructPollfd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> FileDescriptor fd;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> events;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> revents;</span><br><span class="line">    <span class="keyword">public</span> Object userData;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>然后调用<code>Os.poll</code>方法</p>
<p>关于<code>Os</code>我们上面刚分析过，知道他调用了JNI函数，native函数命名格式为<code>Linux_函数名</code>，我们去<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>中找一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Linux_poll</span><span class="params">(JNIEnv* env, jobject, jobjectArray javaStructs, jint timeoutMs)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//把Java对象StructPollfd数组转换成c中的struct pollfd数组</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        rc = poll(fds.get(), count, timeoutMs);</span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= <span class="number">0</span> || errno != EINTR) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">        throwErrnoException(env, <span class="string">"poll"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//设置Java对象StructPollfd的revents值</span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看一下，就是把传进去的<code>StructPollfd</code>数组转换成了<code>struct pollfd</code>数组，然后调用Linux <code>poll</code>函数，再把<code>revents</code>写进<code>StructPollfd</code>对象中，最后返回</p>
<p>再看回<code>runSelectLoop</code>方法，如果poll执行返回值为-1，会直接引发一个Java异常，其他情况先判断一下<code>poll</code>的返回值，如果为0，则没有事件产生，否则会从后向前依次判断<code>pollFDs</code>的<code>revents</code>，如果为<code>POLLIN</code>可读，则处理，不可读则跳过</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>我们先看第一次<code>poll</code>到事件的情况，这时候，<code>pollFDs</code>中只有一个zygote socket fd，收到可读事件，说明有客户端socket向zygote socket请求发起连接，这时候我们调用<code>acceptCommandPeer</code>方法建立新连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createNewConnection(mZygoteSocket.accept(), abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>mZygoteSocket.accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalSocket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LocalSocketImpl acceptedImpl = <span class="keyword">new</span> LocalSocketImpl();</span><br><span class="line"></span><br><span class="line">    impl.accept(acceptedImpl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LocalSocket.createLocalSocketForAccept(acceptedImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个<code>LocalSocketImpl</code>(client socket) 实例，然后调用<code>LocalSocketImpl</code>(zygote socket) 的<code>accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(LocalSocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"socket not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s.fd = Os.accept(fd, <span class="keyword">null</span> <span class="comment">/* address */</span>);</span><br><span class="line">        s.mFdCreatedInternally = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsIOException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了Linux的accept函数，接受建立连接，并返回了一个新的client socket fd，将<code>LocalSocketImpl</code>中的fd变量设置为这个fd，接着调用<code>LocalSocket.createLocalSocketForAccept</code>将<code>LocalSocketImpl</code>包装成<code>LocalSocket</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalSocket <span class="title">createLocalSocketForAccept</span><span class="params">(LocalSocketImpl impl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createConnectedLocalSocket(impl, SOCKET_UNKNOWN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LocalSocket <span class="title">createConnectedLocalSocket</span><span class="params">(LocalSocketImpl impl, <span class="keyword">int</span> sockType)</span> </span>&#123;</span><br><span class="line">    LocalSocket socket = <span class="keyword">new</span> LocalSocket(impl, sockType);</span><br><span class="line">    socket.isConnected = <span class="keyword">true</span>;</span><br><span class="line">    socket.isBound = <span class="keyword">true</span>;</span><br><span class="line">    socket.implCreated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用这个<code>LocalSocket</code>创建了一个<code>ZygoteConnection</code>包装socket连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ZygoteConnection <span class="title">createNewConnection</span><span class="params">(LocalSocket socket, String abiList)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(socket, abiList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下构造方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZygoteConnection(LocalSocket socket, String abiList) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    mSocket = socket;</span><br><span class="line">    <span class="keyword">this</span>.abiList = abiList;</span><br><span class="line"></span><br><span class="line">    mSocketOutStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">    mSocketReader =</span><br><span class="line">            <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream()), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line">    ...</span><br><span class="line">    isEof = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开了client socket的输入输出流，准备读写数据了</p>
<p>然后将这个连接和fd分别添加进<code>peers</code>和<code>socketFDs</code></p>
<h3 id="执行client-socket命令"><a href="#执行client-socket命令" class="headerlink" title="执行client socket命令"></a>执行client socket命令</h3><p>在第二次循环中<code>pollFDs</code>数组中便包括了新建立连接的client socket了，这时调用<code>Os.poll</code>，可以获得到这个client socket的可读事件，此时调用<code>connection.processOneCommand</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取从client socket传来的参数</span></span><br><span class="line">        args = Zygote.readArgumentList(mSocketReader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"IOException on command socket"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    ZygoteArguments parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//一系列参数校验工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,</span><br><span class="line">            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,</span><br><span class="line">            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,</span><br><span class="line">            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp,</span><br><span class="line">            parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList,</span><br><span class="line">            parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程中</span></span><br><span class="line">            <span class="comment">//设置mIsForkChild = true</span></span><br><span class="line">            zygoteServer.setForkChild();</span><br><span class="line">            <span class="comment">//子进程中关闭fork复制来的zygote socket</span></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleParentProc(pid, serverPipeFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动APP进程"><a href="#启动APP进程" class="headerlink" title="启动APP进程"></a>启动APP进程</h1><p>首先读取从client socket传来的参数，然后校验这些参数，完毕后调用<code>Zygote.forkAndSpecialize</code>方法fork出子进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] fdsToIgnore, <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isTopApp, String[] pkgDataInfoList, String[] whitelistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> bindMountAppDataDirs, <span class="keyword">boolean</span> bindMountAppStorageDirs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止其他线程</span></span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fork进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, whitelistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//恢复其他线程</span></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程启动了4个线程：</p>
<ul>
<li>HeapTaskDaemon</li>
<li>ReferenceQueueDaemon</li>
<li>FinalizerDaemon</li>
<li>FinalizerWatchdogDaemon</li>
</ul>
<p>之前上面也分析过了多线程对fork会产生影响，所以这里先把其他线程停了，等fork完了再重新启动</p>
<p>然后执行native函数<code>nativeForkAndSpecialize</code>，路径为<code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint mount_external, jstring se_info, jstring nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring instruction_set, jstring app_data_dir, jboolean is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean mount_data_dirs, jboolean mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">false</span>, fds_to_close, fds_to_ignore, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       capabilities, capabilities,</span><br><span class="line">                       mount_external, se_info, nice_name, <span class="literal">false</span>,</span><br><span class="line">                       is_child_zygote == JNI_TRUE, instruction_set, app_data_dir,</span><br><span class="line">                       is_top_app == JNI_TRUE, pkg_data_info_list,</span><br><span class="line">                       whitelisted_data_info_list,</span><br><span class="line">                       mount_data_dirs == JNI_TRUE,</span><br><span class="line">                       mount_storage_dirs == JNI_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ForkCommon</code>，再在子进程调用<code>SpecializeCommon</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkCommon</span><span class="params">(JNIEnv* env, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_close,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_ignore,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> is_priority_fork)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程信号处理函数</span></span><br><span class="line">  SetSignalHandlers();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//fork前先阻塞SIGCHLD信号</span></span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//执行fork</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//恢复SIGCHLD信号</span></span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong permitted_capabilities, jlong effective_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint mount_external, jstring managed_se_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_nice_name, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> is_child_zygote, jstring managed_instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_app_data_dir, <span class="keyword">bool</span> is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> mount_data_dirs, <span class="keyword">bool</span> mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建进程组</span></span><br><span class="line">  <span class="keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">      ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, <span class="comment">/* pid= */</span> <span class="number">0</span>, strerror(-rc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置GroupId</span></span><br><span class="line">  SetGids(env, gids, is_child_zygote, fail_fn);</span><br><span class="line">  <span class="comment">//设置资源Limit</span></span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置调度策略</span></span><br><span class="line">  SetSchedulerPolicy(fail_fn, is_top_app);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置线程名</span></span><br><span class="line">  <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">    SetThreadName(<span class="string">"system_server"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子进程中不再处理SIGCHLD信号</span></span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_child_zygote) &#123;</span><br><span class="line">      initUnsolSocketToSystemServer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用Zygote.callPostForkChildHooks方法</span></span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认进程优先级</span></span><br><span class="line">  setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程创建完成后，<code>ZygoteConnection</code>在子进程中会返回<code>handleChildProc</code>，在父进程中会返回<code>null</code></p>
<p>在<code>ZygoteServer</code>中做了判断，如果为子进程且command不为null，返回common到<code>ZygoteInit</code>，如果是父进程，继续socket poll循环</p>
<p>在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>（对应<code>ZygoteServer</code>中的<code>command</code>）不为<code>null</code>，则执行这个<code>Runnable</code></p>
<p>我们看一下<code>handleChildProc</code>做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(ZygoteArguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在子进程中关闭发起启动App请求的client socket</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    Zygote.setAppProcessName(parsedArgs, TAG);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//和进程内存泄露或溢出有关？</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.mRemainingArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should not get here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"WrapperInit.execApplication unexpectedly returned"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">            <span class="comment">//根据参数，执行这个方法</span></span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>ZygoteInit.zygoteInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//重定向Log</span></span><br><span class="line">    RuntimeInit.redirectLogStreams();</span><br><span class="line">    <span class="comment">//通用初始化</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    <span class="comment">//之前有提到，开启binder线程池</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">            classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RuntimeInit</code>的路径为<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>，先执行通用初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置默认线程异常处理器</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="string">"persist.sys.timezone"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置Log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置网络UA信息</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    ...</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>RuntimeInit.applicationInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置虚拟机参数</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查找startClass中的main方法</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的startClass为<code>android.app.ActivityThread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Java中的反射，找到了<code>ActivityThread</code>中对应的<code>main</code>方法，并用其创建了一个<code>Runnable</code>对象<code>MethodAndArgsCaller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行ActivityThread.main方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说了，在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>不为<code>null</code>，则执行这个<code>Runnable</code>，即执行<code>MethodAndArgsCaller</code>的<code>run</code>方法，反射调用<code>ActivityThread.main</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，Zygote进程部分的分析就到此为止了，后面fork出App进程那段讲的很粗糙，后面写到App启动那块的时候，我会重新梳理一遍这里的逻辑，补充上去</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2025 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>