<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="dreamgyf"><meta name="copyright" content="dreamgyf"><title>始终都是梦</title><link rel="shortcut icon" href="/images/avatar.jpeg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/images/avatar.jpeg"></div><div class="author-info__name text-center">dreamgyf</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">36</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div></div></div><nav id="nav" style="background-image: url(/images/background.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">始终都是梦</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="site-info"><div id="site-title">始终都是梦</div><div id="site-sub-title"></div><div id="site-social-icons"><a class="social-icon" href="https://github.com/dreamgyf" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-github fab"></i></a><a class="social-icon" href="https://juejin.cn/user/501033033793543" target="_blank" rel="noreferrer noopener nofollow"><i class="fa-blog fas"></i></a></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2022/02/01/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Binder%E6%A6%82%E8%BF%B0/">Android源码分析 - Binder概述</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/Binder/">Binder</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder/">Binder</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇无源码分析，只对Binder做通信过程和基础架构的介绍</strong></p>
<p><code>Binder</code>是<code>Android</code>中最重要的一种进程间通信机制，基于开源的<code>OpenBinder</code></p>
<p><strong>George Hoffman</strong>当时任<strong>Be</strong>公司的工程师，他启动了一个名为<code>OpenBinder</code>的项目，在<strong>Be</strong>公司被<strong>ParmSource</strong>公司收购后，<code>OpenBinder</code>由<strong>Dinnie Hackborn</strong>继续开发，后来成为管理<code>ParmOS6 Cobalt OS</code>的进程的基础。在<strong>Hackborn</strong>加入谷歌后，他在<code>OpenBinder</code>的基础上开发出了<code>Android Binder</code>(以下简称<code>Binder</code>)，用来完成<code>Android</code>的进程通信。</p>
<h1 id="为什么需要学习Binder"><a href="#为什么需要学习Binder" class="headerlink" title="为什么需要学习Binder"></a>为什么需要学习Binder</h1><p>作为一名<code>Android</code>开发，我们每天都在和<code>Binder</code>打交道，虽然可能有的时候不会注意到，譬如：</p>
<ul>
<li><code>startActivity</code>的时候，会获取AMS服务，调用AMS服务的<code>startActivity</code>方法</li>
<li><code>startActivity</code>传递的对象为什么需要序列化</li>
<li><code>bindService</code>为什么回调的是一个<code>Ibinder</code>对象</li>
<li>多进程应用，各个进程之间如何通信</li>
<li><code>AIDL</code>的使用</li>
<li>…</li>
</ul>
<p>它们都和<code>Binder</code>有着莫切关系，当碰到上面的场景，或者一些疑难问题的时候，理解<code>Binder</code>机制是非常有必要的</p>
<h1 id="为什么Android选择Binder"><a href="#为什么Android选择Binder" class="headerlink" title="为什么Android选择Binder"></a>为什么Android选择Binder</h1><p>这就要从进程间通信开始说起了，我们先看看比较常见的几种进程间通信方式</p>
<h2 id="常见进程间通信"><a href="#常见进程间通信" class="headerlink" title="常见进程间通信"></a>常见进程间通信</h2><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是进程间通信中最简单的方式之一，共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" alt="共享内存"></p>
<p>因为共享内存是访问同一块内存，所以数据不需要进行任何复制，是IPC几种方式中最快，性能最好的方式。但相对应的，共享内存未提供同步机制，需要我们手动控制内存间的互斥操作，较容易发生问题。同时共享内存由于能任意的访问和修改内存中的数据，如果有恶意程序去针对某个程序设计代码，很可能导致隐私泄漏或者程序崩溃，所以安全性较差。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道分为命名管道和无名管道，它是以一种特殊的文件作为中间介质，我们称为管道文件，它具有固定的读端和写端，写进程通过写段向管道文件里写入数据，读进程通过读段从读进程中读出数据，构成一条数据传递的流水线，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E7%AE%A1%E9%81%93.png" alt="管道"></p>
<p>管道一次通信需要经历2次数据复制（进程A -&gt; 管道文件，管道文件 -&gt; 进程B）。管道的读写分阻塞和非阻塞，管道创建会分配一个缓冲区，而这个缓冲区是有限的，如果传输的数据大小超过缓冲区上限，或者在阻塞模式下没有安排好数据的读写，会出现阻塞的情况。管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。消息队列允许多个进程同时读写消息，发送方与接收方要约定好，消息体的数据类型与大小。消息队列克服了信号承载信息量少、管道只能承载无格式字节流等缺点，消息队列一次通信同样需要经历2次数据复制（进程A -&gt; 消息队列，消息队列 -&gt; 进程B），它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="消息队列"></p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><code>Socket</code>原本是为了网络设计的，但也可以通过本地回环地址 (<code>127.0.0.1</code>) 进行进程间通信，后来在<code>Socket</code>的框架上更是发展出一种IPC机制，名叫<code>UNIX Domain Socket</code>。<code>Socket</code>是一种典型的<code>C/S</code>架构，一个<code>Socket</code>会拥有两个缓冲区，一读一写，由于发送/接收消息需要将一个<code>Socket</code>缓冲区中的内容拷贝至另一个<code>Socket</code>缓冲区，所以<code>Socket</code>一次通信也是需要经历2次数据复制，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Socket.png" alt="Socket"></p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>了解了常见进程间通信的方式，我们再来看一下<code>Binder</code>的原理</p>
<p><code>Binder</code>是基于内存映射<code>mmap</code>设计实现的，我们需要先了解一下<code>mmap</code>的概念</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><code>mmap</code>是一种内存映射的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用<code>read</code>,<code>write</code>等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p><code>Linux</code>内核不会主动将<code>mmap</code>修改后的内容同步到磁盘文件中，有4个时机会触发<code>mmap</code>映射同步到磁盘：</p>
<ul>
<li>调用 <code>msync</code> 函数主动进行数据同步（主动）</li>
<li>调用 <code>munmap</code> 函数对文件进行解除映射关系时（主动）</li>
<li>进程退出时（被动）</li>
<li>系统关机时（被动）</li>
</ul>
<p>通过这种方式，直接操作映射的这一部分内存，可以避免一些数据复制，从而获得更好的性能</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一次<code>Binder</code> IPC通信的过程分为以下几个步骤：</p>
<ol>
<li>首先，<code>Binder</code>驱动在内核空间中开辟出一个<code>数据接收缓冲区</code></li>
<li>接着，在内核空间中开辟出一个<code>内核缓冲区</code></li>
<li>将<code>内核缓冲区</code>与<code>数据接收缓冲区</code>建立映射关系</li>
<li>将<code>数据接收缓冲区</code>与<code>接收进程的用户空间地址</code>建立映射关系</li>
<li>发送方进程通过<code>copy_from_user</code>将数据从用户空间复制到<code>内核缓冲区</code></li>
<li>由于<code>内核缓冲区</code>与<code>数据接收缓冲区</code>有映射关系，同时<code>数据接收缓冲区</code>与<code>接收进程的用户空间地址</code>有映射关系，所以在接收进程中可以直接获取到这段数据</li>
</ol>
<p>这样便完成了一次<code>Binder</code> IPC通信，它的原理如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86.png" alt="Binder"></p>
<p>可以看到，通过<code>mmap</code>，<code>Binder</code>通信时，只需要经历一次数据复制，性能要优于管道/消息队列/socket等方式，在安全性，易用性方面又优于共享内存。鉴于上述原因，<code>Android</code>选择了这种折中的IPC方式，来满足系统对稳定性、传输性能和安全性方面的要求</p>
<h1 id="Binder架构"><a href="#Binder架构" class="headerlink" title="Binder架构"></a>Binder架构</h1><p><code>Binder</code>也是一种<code>C/S</code>架构，分为<code>BpBinder</code>（客户端）和<code>BBinder</code>（服务端），他们都派生自<code>IBinder</code>。其中<code>BpBinder</code>中的p表示proxy，即代理。<code>BpBinder</code>通过<code>transact</code>来发送事务请求，<code>BBinder</code>通过<code>onTransact</code>来接收相应的事务</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E6%9E%B6%E6%9E%84.png" alt="Ibinder"></p>
<p>Binder一次通信的时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E9%80%9A%E4%BF%A1%E6%97%B6%E5%BA%8F.png" alt="Binder通信"></p>
<p>Binder采用分层架构设计</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Binder%E6%A6%82%E8%BF%B0_Binder%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png" alt="Binder分层架构"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们大概了解了一下<code>Android</code>选用<code>Binder</code>的原因，以及<code>Binder</code>的基本结构和通信过程，为之后深入源码层分析<code>Binder</code>做了准备</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/35519585" target="_blank" rel="noopener">写给 Android 应用工程师的 Binder 原理剖析</a></li>
<li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></li>
<li><a href="https://bbs.huaweicloud.com/blogs/308646" target="_blank" rel="noopener">Android Binder原理图解</a></li>
<li><a href="https://www.jianshu.com/p/45563980bf61" target="_blank" rel="noopener">Binder和AIDL实例及原理解析</a></li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/29/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8B%EF%BC%89/">Android源码分析 - SystemServer（下）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SystemServer/">SystemServer</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7054154169761923085" target="_blank" rel="noopener">Android源码分析 - SystemServer（上）</a>我们分析了<code>SystemServer</code>进程是怎么被启动起来的，今天这篇，我们来分析<code>SystemServer</code>进程启动后做了什么</p>
<h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>我们上一章中讲到，<code>Zygote</code>进程<code>fork</code>出子进程后，最终调用了<code>SystemServer.main</code>方法，<code>SystemServer</code>源代码在<code>frameworks/base/services/java/com/android/server/SystemServer.java</code>中，我们来看看做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>非常简单，就是先new了一个<code>SystemServer</code>对象，然后调用它的<code>run</code>方法，我们先看一下构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工厂模式</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//记录启动信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录是否经历过重启</span></span><br><span class="line">    mRuntimeRestart = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>首先，先从系统属性中获取工厂模式级别，有三种属性：</p>
<ul>
<li><code>FACTORY_TEST_OFF</code>：正常模式</li>
<li><code>FACTORY_TEST_LOW_LEVEL</code>：低级别工厂模式，在此模式下，很多Service不会启动</li>
<li><code>FACTORY_TEST_HIGH_LEVEL</code>：高级别工厂模式，此模式与正常模式基本相同，略有区别</li>
</ul>
<p>它们被定义在<code>frameworks/base/core/java/android/os/FactoryTest.java</code>中</p>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>紧接着便开始执行<code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//记录启动信息</span></span><br><span class="line">    <span class="comment">//如果没有设置时区，将时区设置为GMT</span></span><br><span class="line">    String timezoneProperty = SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">    <span class="keyword">if</span> (timezoneProperty == <span class="keyword">null</span> || timezoneProperty.isEmpty()) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Timezone not set; setting to GMT."</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.timezone"</span>, <span class="string">"GMT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置区域与语言</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemProperties.get(<span class="string">"persist.sys.language"</span>).isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> String languageTag = Locale.getDefault().toLanguageTag();</span><br><span class="line"></span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.locale"</span>, languageTag);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.language"</span>, <span class="string">""</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.country"</span>, <span class="string">""</span>);</span><br><span class="line">        SystemProperties.set(<span class="string">"persist.sys.localevar"</span>, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Binder事务发生阻塞时发出警告</span></span><br><span class="line">    Binder.setWarnOnBlocking(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//PackageManager相关</span></span><br><span class="line">    PackageItemInfo.forceSafeLabels();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置虚拟机库文件libart.so</span></span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line">    <span class="comment">//清除虚拟机内存增长上限，以获得更多内存</span></span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">    <span class="comment">// Some devices rely on runtime fingerprint generation, so make sure</span></span><br><span class="line">    <span class="comment">// we've defined it before booting further.</span></span><br><span class="line">    Build.ensureFingerprintProperty();</span><br><span class="line">    <span class="comment">//设置在访问环境变量前，需要明确指定用户</span></span><br><span class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置标记，当发生BadParcelableException异常时保守处理，不要抛出异常</span></span><br><span class="line">    BaseBundle.setShouldDefuse(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置异常跟踪</span></span><br><span class="line">    Parcel.setStackTraceParceling(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//确保Binder调用优先级总为前台优先级</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置Binder线程池最大数量</span></span><br><span class="line">    BinderInternal.setMaxThreads(sMaxBinderThreads);</span><br><span class="line">    <span class="comment">//设置进程优先级为前台进程</span></span><br><span class="line">    <span class="comment">// Prepare the main looper thread (this thread).</span></span><br><span class="line">    android.os.Process.setThreadPriority(</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//以当前线程作为MainLooper准备</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    Looper.getMainLooper().setSlowLogThresholdMs(</span><br><span class="line">            SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);</span><br><span class="line"></span><br><span class="line">    SystemServiceRegistry.sEnableServiceNotFoundWtf = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库</span></span><br><span class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line">    <span class="comment">//标记该进程的堆可分析</span></span><br><span class="line">    initZygoteChildHeapProfiling();</span><br><span class="line">    <span class="comment">//Debug选项 - 开启一个线程用来监测FD泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (Build.IS_DEBUGGABLE) &#123;</span><br><span class="line">        spawnFdLeakCheckThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查上次关机过程中是否失败</span></span><br><span class="line">    performPendingShutdown();</span><br><span class="line">    <span class="comment">//初始化System Context</span></span><br><span class="line">    createSystemContext();</span><br><span class="line">    <span class="comment">//创建并设置一些每个进程启动时都需要的一些模块 (TelephonyServiceManager, StatsServiceManager)</span></span><br><span class="line">    ActivityThread.initializeMainlineModules();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建SystemServiceManager（管理所有的系统Service）</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">            mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">    <span class="comment">//将SystemServiceManager作为本地进程Service使用</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager<span class="class">.<span class="keyword">class</span>, <span class="title">mSystemServiceManager</span>)</span>;</span><br><span class="line">    <span class="comment">//为初始化任务准备线程池</span></span><br><span class="line">    SystemServerInitThreadPool.start();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置默认异常处理程序</span></span><br><span class="line">    RuntimeInit.setDefaultApplicationWtfHandler(SystemServer::handleEarlySystemWtf);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动引导服务</span></span><br><span class="line">    startBootstrapServices(t);</span><br><span class="line">    <span class="comment">//启动核心服务</span></span><br><span class="line">    startCoreServices(t);</span><br><span class="line">    <span class="comment">//启动其他服务</span></span><br><span class="line">    startOtherServices(t);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格模式初始化虚拟机策略</span></span><br><span class="line">    StrictMode.initVmDefaults(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//进入Looper死循环，等待Handler事件</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>run</code>方法主要做了以下工作</p>
<ol>
<li>检查并设置各种参数handler</li>
<li>创建<code>SystemContext</code></li>
<li>创建<code>SystemServiceManager</code></li>
<li>启动服务</li>
<li><code>Looper</code>循环</li>
</ol>
<p>其中，创建<code>SystemContext</code>这一步是由<code>ContextImpl</code>完成的，等后面分析到的时候在详细去看，<code>Looper</code>也是，我们将重点放在启动服务上</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>启动服务分为三步，首先是启动引导服务，其次是启动核心服务，最后是启动其他服务，我们先从引导服务开始</p>
<p><strong>由于启动的服务太多了，我们只介绍一些我们比较熟悉的服务</strong></p>
<h2 id="startBootstrapServices"><a href="#startBootstrapServices" class="headerlink" title="startBootstrapServices"></a>startBootstrapServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//看门狗</span></span><br><span class="line">    <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">    watchdog.start();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> String TAG_SYSTEM_CONFIG = <span class="string">"ReadingSystemConfig"</span>;</span><br><span class="line">    <span class="comment">//读取系统配置</span></span><br><span class="line">    SystemServerInitThreadPool.submit(SystemConfig::getInstance, TAG_SYSTEM_CONFIG);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Installer服务（实际上是与installd跨进程通信）</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建 ATMS &amp; AMS</span></span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">            ActivityTaskManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>).<span class="title">getService</span>()</span>;</span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">            mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//电源管理服务，后面有其他服务依赖它，所以需要较早启动</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//灯光服务</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//显示管理服务</span></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//阶段100</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建PMS</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">"packagemanagermain"</span>);</span><br><span class="line">        mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">"packagemanagermain"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获dex load行为</span></span><br><span class="line">    SystemServerDexLoadReporter.configureSystemServerDexReporter(mPackageManagerService);</span><br><span class="line">    <span class="comment">//是否首次启动</span></span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    <span class="comment">//获取PMS</span></span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//用户管理服务</span></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化属性缓存</span></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册各种系统服务</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//使用AMS完成看门狗的设置，并监听重新启动</span></span><br><span class="line">    watchdog.init(mSystemContext, mActivityManagerService);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置调度策略</span></span><br><span class="line">    mDisplayManagerService.setupSchedulerPolicies();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//在单独线程中启动传感器服务</span></span><br><span class="line">    mSensorServiceStart = SystemServerInitThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        TimingsTraceAndSlog traceLog = TimingsTraceAndSlog.newAsyncLog();</span><br><span class="line">        traceLog.traceBegin(START_SENSOR_SERVICE);</span><br><span class="line">        startSensorService();</span><br><span class="line">        traceLog.traceEnd();</span><br><span class="line">    &#125;, START_SENSOR_SERVICE);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startCoreServices"><a href="#startCoreServices" class="headerlink" title="startCoreServices"></a>startCoreServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//电池电量服务，依赖LightsService</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//应用统计服务</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="startOtherServices"><a href="#startOtherServices" class="headerlink" title="startOtherServices"></a>startOtherServices</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//AccountManagerService - 账户管理</span></span><br><span class="line">    mSystemServiceManager.startService(ACCOUNT_SERVICE_CLASS);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//ContentService - 内容服务</span></span><br><span class="line">    mSystemServiceManager.startService(CONTENT_SERVICE_CLASS);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//加载SettingProvider</span></span><br><span class="line">    mActivityManagerService.installSystemProviders();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//DropBox日志服务</span></span><br><span class="line">    mSystemServiceManager.startService(DropBoxManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//震动服务</span></span><br><span class="line">    vibrator = <span class="keyword">new</span> VibratorService(context);</span><br><span class="line">    ServiceManager.addService(<span class="string">"vibrator"</span>, vibrator);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//时钟/闹钟服务</span></span><br><span class="line">    mSystemServiceManager.startService(<span class="keyword">new</span> AlarmManagerService(context));</span><br><span class="line">    <span class="comment">//输入服务</span></span><br><span class="line">    inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//等待传感器服务准备完毕</span></span><br><span class="line">    ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">    mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//启动WindowManagerService</span></span><br><span class="line">    wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">            <span class="keyword">new</span> PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">    ...</span><br><span class="line">    mActivityManagerService.setWindowManager(wm);</span><br><span class="line">    ...</span><br><span class="line">    wm.onInitReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//HIDL services</span></span><br><span class="line">    SystemServerInitThreadPool.submit(() -&gt; &#123;</span><br><span class="line">        startHidlServices();</span><br><span class="line">    &#125;, START_HIDL_SERVICES);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//关联WMS，启动输入服务</span></span><br><span class="line">    inputManager.setWindowManagerCallbacks(wm.getInputManagerCallback());</span><br><span class="line">    inputManager.start();</span><br><span class="line">    ...</span><br><span class="line">    mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//有蓝牙功能且非低级工厂模式，启动蓝牙服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context.getPackageManager().hasSystemFeature</span><br><span class="line">            (PackageManager.FEATURE_BLUETOOTH)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSystemServiceManager.startService(BluetoothService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//输入法/无障碍服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InputMethodSystemProperty.MULTI_CLIENT_IME_ENABLED) &#123;</span><br><span class="line">            mSystemServiceManager.startService(</span><br><span class="line">                    MultiClientInputMethodManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSystemServiceManager.startService(InputMethodManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mSystemServiceManager.startService(ACCESSIBILITY_MANAGER_SERVICE_CLASS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wm.displayReady();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储相关服务</span></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"0"</span>.equals(SystemProperties.get(<span class="string">"system_init.startmountservice"</span>))) &#123;</span><br><span class="line">            mSystemServiceManager.startService(STORAGE_MANAGER_SERVICE_CLASS);</span><br><span class="line">            storageManager = IStorageManager.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"mount"</span>));</span><br><span class="line">            mSystemServiceManager.startService(STORAGE_STATS_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UIMode服务（夜间模式，驾驶模式等）</span></span><br><span class="line">    mSystemServiceManager.startService(UiModeManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//执行磁盘清理工作，释放磁盘空间</span></span><br><span class="line">    mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasPdb = !SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(<span class="string">""</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (hasPdb || OemLockService.isHalPresent()) &#123;</span><br><span class="line">            <span class="comment">//OEM锁服务</span></span><br><span class="line">            mSystemServiceManager.startService(OemLockService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!isWatch) &#123;</span><br><span class="line">            <span class="comment">//状态栏管理服务</span></span><br><span class="line">            statusBar = <span class="keyword">new</span> StatusBarManagerService(context);</span><br><span class="line">            ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//网络相关服务</span></span><br><span class="line">        ConnectivityModuleConnector.getInstance().init(context);</span><br><span class="line">        NetworkStackClient.getInstance().init();</span><br><span class="line">        networkManagement = NetworkManagementService.create(context);</span><br><span class="line">        ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);</span><br><span class="line">        ipSecService = IpSecService.create(context, networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//文本服务</span></span><br><span class="line">        mSystemServiceManager.startService(TextServicesManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mSystemServiceManager</span><br><span class="line">                    .startService(TextClassificationManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网络相关服务</span></span><br><span class="line">        mSystemServiceManager.startService(NetworkScoreService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        networkStats = NetworkStatsService.create(context, networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);</span><br><span class="line">        networkPolicy = <span class="keyword">new</span> NetworkPolicyManagerService(context, mActivityManagerService,</span><br><span class="line">                    networkManagement);</span><br><span class="line">        ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_SCANNING_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_RTT)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_RTT_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_AWARE)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_AWARE_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_WIFI_DIRECT)) &#123;</span><br><span class="line">            mSystemServiceManager.startServiceFromJar(</span><br><span class="line">                    WIFI_P2P_SERVICE_CLASS, WIFI_APEX_SERVICE_JAR_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageManager().hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_LOWPAN)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(LOWPAN_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) ||</span><br><span class="line">                mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        connectivity = <span class="keyword">new</span> ConnectivityService(</span><br><span class="line">                    context, networkManagement, networkStats, networkPolicy);</span><br><span class="line">        ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity,</span><br><span class="line">                    <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                    DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL);</span><br><span class="line">        networkPolicy.bindConnectivityManager(connectivity);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//系统更新服务</span></span><br><span class="line">        ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE,</span><br><span class="line">                    <span class="keyword">new</span> SystemUpdateManagerService(context));</span><br><span class="line">        ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,</span><br><span class="line">                    <span class="keyword">new</span> UpdateLockService(context));</span><br><span class="line">        <span class="comment">//通知服务</span></span><br><span class="line">        mSystemServiceManager.startService(NotificationManagerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        SystemNotificationChannels.removeDeprecated(context);</span><br><span class="line">        SystemNotificationChannels.createAll(context);</span><br><span class="line">        notification = INotificationManager.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.NOTIFICATION_SERVICE));</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//位置服务</span></span><br><span class="line">        mSystemServiceManager.startService(LocationManagerService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//墙纸服务</span></span><br><span class="line">        <span class="keyword">if</span> (context.getResources().getBoolean(R.bool.config_enableWallpaperService)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(WALLPAPER_SERVICE_CLASS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//音频服务</span></span><br><span class="line">        <span class="keyword">if</span> (!isArc) &#123;</span><br><span class="line">            mSystemServiceManager.startService(AudioService.Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String className = context.getResources()</span><br><span class="line">                    .getString(R.string.config_deviceSpecificAudioService);</span><br><span class="line">            mSystemServiceManager.startService(className + <span class="string">"$Lifecycle"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//ADB服务</span></span><br><span class="line">        mSystemServiceManager.startService(ADB_SERVICE_CLASS);</span><br><span class="line">        <span class="comment">//USB服务</span></span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)</span><br><span class="line">                || mPackageManager.hasSystemFeature(</span><br><span class="line">                PackageManager.FEATURE_USB_ACCESSORY)</span><br><span class="line">                || isEmulator) &#123;</span><br><span class="line">            mSystemServiceManager.startService(USB_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//微件（小组件）服务</span></span><br><span class="line">        <span class="keyword">if</span> (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)</span><br><span class="line">                || context.getResources().getBoolean(R.bool.config_enableAppWidgetService)) &#123;</span><br><span class="line">            mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Android10新增，用于报告来自运行时模块的信息</span></span><br><span class="line">        ServiceManager.addService(<span class="string">"runtime"</span>, <span class="keyword">new</span> RuntimeService(context));</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//App后台Dex优化</span></span><br><span class="line">        BackgroundDexOptService.schedule(context);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//相机服务</span></span><br><span class="line">    <span class="keyword">if</span> (!disableCameraService) &#123;</span><br><span class="line">        mSystemServiceManager.startService(CameraServiceProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入安全模式</span></span><br><span class="line">    <span class="keyword">if</span> (safeMode) &#123;</span><br><span class="line">        mActivityManagerService.enterSafeMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//短信服务</span></span><br><span class="line">    mmsService = mSystemServiceManager.startService(MmsServiceBroker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//剪贴板服务</span></span><br><span class="line">    mSystemServiceManager.startService(ClipboardService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用各大服务的systemReady方法</span></span><br><span class="line"></span><br><span class="line">    vibrator.systemReady();</span><br><span class="line">    lockSettings.systemReady();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//阶段480</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">    <span class="comment">//阶段500</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line"></span><br><span class="line">    wm.systemReady();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//手动更新Context Configuration</span></span><br><span class="line">    <span class="keyword">final</span> Configuration config = wm.computeNewConfiguration(DEFAULT_DISPLAY);</span><br><span class="line">    DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    context.getDisplay().getMetrics(metrics);</span><br><span class="line">    context.getResources().updateConfiguration(config, metrics);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Theme systemTheme = context.getTheme();</span><br><span class="line">    <span class="keyword">if</span> (systemTheme.getChangingConfigurations() != <span class="number">0</span>) &#123;</span><br><span class="line">        systemTheme.rebase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());</span><br><span class="line">    ...</span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    mDisplayManagerService.systemReady(safeMode, mOnlyCore);</span><br><span class="line">    </span><br><span class="line">    mSystemServiceManager.setSafeMode(safeMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶段520</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(t, SystemService.PHASE_DEVICE_SPECIFIC_SERVICES_READY);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//最后运行AMS.systemReady</span></span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//阶段550</span></span><br><span class="line">        mSystemServiceManager.startBootPhase(t, SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//阶段600</span></span><br><span class="line">        mSystemServiceManager.startBootPhase(t, SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">        ...</span><br><span class="line">    &#125;, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务的启动是分阶段完成的，从0-100-480-500-520-550-600-1000，最后的阶段1000，是在AMS调用<code>finishBooting</code>方法后进入</p>
<p>可以看到，启动的服务非常之多，不可能全看得完，其中最重要的几个：<code>ActivityManagerService</code>、<code>WindowManagerService</code>、<code>PackageManagerService</code>和<code>InputManagerService</code>，后面我们会慢慢看过去，在此之前，我们还是先看看服务启动的方式</p>
<h1 id="SystemServiceManager"><a href="#SystemServiceManager" class="headerlink" title="SystemServiceManager"></a>SystemServiceManager</h1><p>绝大部分的服务是通过<code>SystemServiceManager</code>启动的，它的源码路径为<code>frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</code></p>
<h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><p>我们来看看这个类里的启动服务方法</p>
<p>这个类中有三个方法用于启动Serivce，分别是：</p>
<ul>
<li><code>public SystemService startService(String className)</code></li>
<li><code>public SystemService startServiceFromJar(String className, String path)</code></li>
<li><code>public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass)</code></li>
<li><code>public void startService(@NonNull final SystemService service)</code></li>
</ul>
<p>实际上最后都是调用了最后一个方法</p>
<p>先看参数为<code>String</code>的<code>startService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startService</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,</span><br><span class="line">            <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;SystemService&gt; <span class="title">loadClassFromLoader</span><span class="params">(String className,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Class&lt;SystemService&gt;) Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是通过反射拿到类名对应的<code>Class</code>，再调用<code>Class</code>为参的<code>startService</code>方法</p>
<p><code>startServiceFromJar</code>实际上也是一样，只不过是先通过<code>PathClassLoader</code>加载了jar而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startServiceFromJar</span><span class="params">(String className, String path)</span> </span>&#123;</span><br><span class="line">    PathClassLoader pathClassLoader = mLoadedPaths.get(path);</span><br><span class="line">    <span class="keyword">if</span> (pathClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// NB: the parent class loader should always be the system server class loader.</span></span><br><span class="line">        <span class="comment">// Changing it has implications that require discussion with the mainline team.</span></span><br><span class="line">        pathClassLoader = <span class="keyword">new</span> PathClassLoader(path, <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        mLoadedPaths.put(path, pathClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className, pathClassLoader);</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们看看<code>Class</code>为参数的<code>startService</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the service.</span></span><br><span class="line">    <span class="keyword">if</span> (!SystemService<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">serviceClass</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to create "</span> + name</span><br><span class="line">                + <span class="string">": service must extend "</span> + SystemService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> T service;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        service = constructor.newInstance(mContext);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startService(service);</span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看函数泛型我们就可以知道，这个方法只接受<code>SystemService</code>的子类，并且在方法的开头，还使用了<code>isAssignableFrom</code>方法做了类型校验，避免通过<code>String</code>反射获取的<code>Class</code>非<code>SystemService</code>的子类</p>
<p>之后的逻辑也很简单，反射实例化对象，然后调用另一个以<code>SystemService</code>对象为参数的重载方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(@NonNull <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">    mServices.add(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to start service "</span> + service.getClass().getName()</span><br><span class="line">                + <span class="string">": onStart threw an exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会将<code>SystemService</code>对象加入一个<code>List</code>中，然后调用它的<code>onStart</code>方法，通知<code>SystemService</code>自行处理启动</p>
<h2 id="startBootPhase"><a href="#startBootPhase" class="headerlink" title="startBootPhase"></a>startBootPhase</h2><p>因为各种服务之间是存在依赖关系的，所以Android将服务的启动划分了8个阶段：0-100-480-500-520-550-600-1000，而<code>startBootPhase</code>方法便是用来通知各个服务进行到哪一阶段了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startBootPhase</span><span class="params">(@NonNull TimingsTraceAndSlog t, <span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase &lt;= mCurrentPhase) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Next phase must be larger than previous"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentPhase = phase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> serviceLen = mServices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serviceLen; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> SystemService service = mServices.get(i);</span><br><span class="line">        service.onBootPhase(mCurrentPhase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phase == SystemService.PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每进入到一个阶段，便会调用Service List中所有<code>SystemService</code>的<code>onBootPhase</code>方法，通知<code>SystemService</code>阶段变换，而当阶段达到1000 (PHASE_BOOT_COMPLETED) 时，就代表着所有的服务都已准备完毕，关闭<code>SystemServerInitThreadPool</code>线程池</p>
<h1 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h1><p>当服务被创建出来后，会调用<code>ServiceManager.addService</code>方法添加服务，以供其他地方使用这些服务</p>
<p><code>addService</code>有三个重载，最终调用的为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getIServiceManager().addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"error in addService"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the service manager</span></span><br><span class="line">    sServiceManager = ServiceManagerNative</span><br><span class="line">            .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">    <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ServiceManager is never local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManagerProxy</span> <span class="keyword">implements</span> <span class="title">IServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceManagerProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">        mServiceManager = IServiceManager.Stub.asInterface(remote);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated, <span class="keyword">int</span> dumpPriority)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mServiceManager.addService(name, service, allowIsolated, dumpPriority);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> IBinder mRemote;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IServiceManager mServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里就能看出来<code>ServiceManager</code>实际上是一个单独的进程，名为<code>servicemanager</code>，它负责管理所有服务，使用了<code>Binder</code> IPC机制，我们调用<code>addService</code>方法实际上是调用了Binder Proxy的方法，他向<code>/dev/binder</code>中写入消息，在<code>servicemanager</code>进程中接收到了这个消息并处理这个请求</p>
<p>关于<code>Binder</code>机制，我们随后便会分析它</p>
<p>最终调用了<code>frameworks/native/cmds/servicemanager/ServiceManager.cpp</code>中的<code>addService</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ctx = mAccess-&gt;getCallingContext();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//添加服务</span></span><br><span class="line">    <span class="keyword">auto</span> entry = mNameToService.emplace(name, Service &#123;</span><br><span class="line">        .binder = binder,</span><br><span class="line">        .allowIsolated = allowIsolated,</span><br><span class="line">        .dumpPriority = dumpPriority,</span><br><span class="line">        .debugPid = ctx.debugPid,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mNameToRegistrationCallback.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it != mNameToRegistrationCallback.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;IServiceCallback&gt;&amp; cb : it-&gt;second) &#123;</span><br><span class="line">            entry.first-&gt;second.guaranteeClient = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// permission checked in registerForNotifications</span></span><br><span class="line">            cb-&gt;onRegistration(name, binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终通过<code>service name</code>和传过来的<code>binder</code>对象构造出一个<code>Service</code>结构体，并将其保存至<code>mNameToService</code>这个Map中，以供后面使用</p>
<h1 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h1><p><code>SystemServer</code>启动的服务大多都运行在<code>systemserver</code>进程中，但也有一些例外</p>
<p>譬如<code>Installer</code>服务，便是从<code>init</code>进程单独<code>fork</code>出了一个<code>installd</code>进程</p>
<p>下面是它的rc文件，<code>frameworks/native/cmds/installd/installd.rc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service installd &#x2F;system&#x2F;bin&#x2F;installd</span><br><span class="line">class main</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>而在<code>SystemServer</code>进程中start的<code>Installer</code>，便是通过<code>binder</code>连接到<code>installd</code>进程提供服务</p>
<p>源码路径<code>frameworks/base/services/core/java/com/android/server/pm/Installer.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsolated) &#123;</span><br><span class="line">        mInstalld = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IBinder binder = ServiceManager.getService(<span class="string">"installd"</span>);</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            binder.linkToDeath(<span class="keyword">new</span> DeathRecipient() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"installd died; reconnecting"</span>);</span><br><span class="line">                    connect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            binder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInstalld = IInstalld.Stub.asInterface(binder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            invalidateMounts();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstallerException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"installd not found; trying again"</span>);</span><br><span class="line">        BackgroundThread.getHandler().postDelayed(() -&gt; &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;, DateUtils.SECOND_IN_MILLIS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p><code>SystemServer</code>启动了非常多的服务，并将这些服务添加到了<code>ServiceManager</code>中，我们又从中引申出了<code>Binder</code>机制，我们下一章便开始分析<code>Binder</code></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/17/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-SystemServer%EF%BC%88%E4%B8%8A%EF%BC%89/">Android源码分析 - SystemServer（上）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-17</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/SystemServer/">SystemServer</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7051507161955827720" target="_blank" rel="noopener" title="Android源码分析 - Zygote进程">Android源码分析 - Zygote进程</a>，我们分析了Android <code>Zygote</code>进程的启动和之后是如何接收消息创建App进程的</p>
<p>在上一章中，我们说了，<code>Zygote</code>的一大作用就是启动<code>SystemServer</code>，那么<code>SystemServer</code>是怎么启动的呢？启动后又做了些什么呢？我们分上下两篇来分析，本篇介绍<code>SystemServer</code>是如何启动的</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>SystemServer</code>主要是用来创建系统服务的，譬如我们熟知的<code>ActivityManagerService</code>，<code>PackageManagerService</code>都是由它创建的</p>
<h1 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h1><p>我们从上一篇文章的<code>ZygoteInit</code>开始，<code>ZygoteInit</code>类的源码路径为<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">        <span class="comment">//参数中有start-system-server</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">            startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动SystemServer</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程中才会满足r != null</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此时执行这个Runnable</span></span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前在c++代码中JNI调用Java函数的时候，带了参数<code>start-system-server</code>，在这里就会通过这个参数判断是否启动<code>SystemServer</code>，接下来调用<code>forkSystemServer</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置Linux capabilities</span></span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">            OsConstants.CAP_IPC_LOCK,</span><br><span class="line">            OsConstants.CAP_KILL,</span><br><span class="line">            OsConstants.CAP_NET_ADMIN,</span><br><span class="line">            OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">            OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">            OsConstants.CAP_NET_RAW,</span><br><span class="line">            OsConstants.CAP_SYS_MODULE,</span><br><span class="line">            OsConstants.CAP_SYS_NICE,</span><br><span class="line">            OsConstants.CAP_SYS_PTRACE,</span><br><span class="line">            OsConstants.CAP_SYS_TIME,</span><br><span class="line">            OsConstants.CAP_SYS_TTY_CONFIG,</span><br><span class="line">            OsConstants.CAP_WAKE_ALARM,</span><br><span class="line">            OsConstants.CAP_BLOCK_SUSPEND</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//移除一些当前线程都不可用的特权</span></span><br><span class="line">    StructCapUserHeader header = <span class="keyword">new</span> StructCapUserHeader(</span><br><span class="line">            OsConstants._LINUX_CAPABILITY_VERSION_3, <span class="number">0</span>);</span><br><span class="line">    StructCapUserData[] data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        data = Os.capget(header);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to capget()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//data[0].effective为当前线程所可用的特权，data[1].effective貌似为0</span></span><br><span class="line">    capabilities &amp;= ((<span class="keyword">long</span>) data[<span class="number">0</span>].effective) | (((<span class="keyword">long</span>) data[<span class="number">1</span>].effective) &lt;&lt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fork参数</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">            <span class="string">"--setuid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgid=1000"</span>,</span><br><span class="line">            <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span></span><br><span class="line">                    + <span class="string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"</span>,</span><br><span class="line">            <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">            <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">            <span class="string">"--runtime-args"</span>,</span><br><span class="line">            <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">            <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteArguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析设置的参数</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line">        ... <span class="comment">//进一步设置参数</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.mUid, parsedArgs.mGid,</span><br><span class="line">                parsedArgs.mGids,</span><br><span class="line">                parsedArgs.mRuntimeFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.mPermittedCapabilities,</span><br><span class="line">                parsedArgs.mEffectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SystemServer子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zygote server socket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p>这里需要先了解一下Linux Capabilities机制：<a href="https://juejin.cn/post/7052933216948191269" target="_blank" rel="noopener">Linux Capabilities机制</a></p>
<p>这里先定义了<code>SystemServer</code>进程的<code>Permitted</code>和<code>Effective</code>能力集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">posixCapabilitiesAsBits</span><span class="params">(<span class="keyword">int</span>... capabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> capability : capabilities) &#123;</span><br><span class="line">        <span class="comment">//非法capability，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> ((capability &lt; <span class="number">0</span>) || (capability &gt; OsConstants.CAP_LAST_CAP)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.valueOf(capability));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为或操作，构建capabilities集合</span></span><br><span class="line">        result |= (<span class="number">1L</span> &lt;&lt; capability);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查一下有无非法<code>capability</code>，然后做位或运算，构建出一个<code>capabilities</code>集合</p>
<p>然后通过<code>Os.capget</code>方法获取当前线程的<code>capabilities</code>集合，上一篇文章中我们已经分析过了Os的作用，最终通过<code>Linux_capget</code>JNI函数调用Linux<code>capget</code>函数，通过返回回来的值，剔除一些当前线程不支持的特权</p>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>接着设置一些fork参数，通过<code>ZygoteArguments</code>去解析它</p>
<p>然后调用<code>Zygote.forkSystemServer</code>方法，这个和上一章里说的fork App的过程差不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止其他线程</span></span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits,</span><br><span class="line">            permittedCapabilities, effectiveCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置默认线程优先级</span></span><br><span class="line">    Thread.currentThread().setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="comment">//恢复其他线程</span></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把子线程都停止掉，fork完后再恢复，调用native函数<code>nativeForkSystemServer</code>，路径为<code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effective_capabilities)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">true</span>,</span><br><span class="line">                         fds_to_close,</span><br><span class="line">                         fds_to_ignore,</span><br><span class="line">                         <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// System server prcoess does not need data isolation so no need to</span></span><br><span class="line">      <span class="comment">// know pkg_data_info_list.</span></span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       permitted_capabilities, effective_capabilities,</span><br><span class="line">                       MOUNT_EXTERNAL_DEFAULT, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">true</span>,</span><br><span class="line">                       <span class="literal">false</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="comment">/* is_top_app= */</span> <span class="literal">false</span>,</span><br><span class="line">                       <span class="comment">/* pkg_data_info_list */</span> <span class="literal">nullptr</span>,</span><br><span class="line">                       <span class="comment">/* whitelisted_data_info_list */</span> <span class="literal">nullptr</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="comment">//检查SystemServer进程状态</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//如果SystemServer进程死亡，重启整个Zygote</span></span><br><span class="line">          ALOGE(<span class="string">"System server process %d has died. Restarting Zygote!"</span>, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"System server process has died. Restarting Zygote!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是低内存设备，限制SystemServer进程使用内存大小</span></span><br><span class="line">      <span class="keyword">if</span> (UsePerAppMemcg()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!SetTaskProfiles(pid, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"SystemMemoryProcess"</span>&#125;)) &#123;</span><br><span class="line">              ALOGE(<span class="string">"couldn't add process %d into system memcg group"</span>, pid);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ForkCommon"><a href="#ForkCommon" class="headerlink" title="ForkCommon"></a>ForkCommon</h3><p>我们先看<code>ForkCommon</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkCommon</span><span class="params">(JNIEnv* env, bool is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; fds_to_close,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; fds_to_ignore,</span></span></span><br><span class="line"><span class="function"><span class="params">                        bool is_priority_fork)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程信号处理器</span></span><br><span class="line">  SetSignalHandlers();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//C++中的一种可调用对象，ZygoteFailure函数接收4个参数，前三个参数都已提供，最后一个参数占位等待调用方填入</span></span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>,</span><br><span class="line">                           nullptr, _1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在fork期间阻塞住SIGCHLD信号，避免在SIGCHLD信号处理函数中打印log，导致后面关闭的日志fd重新被打开</span></span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭所有日志相关fd</span></span><br><span class="line">  __android_log_close();</span><br><span class="line">  AStatsSocket_close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//SystemServer是Zygote进程起来后第一个fork的出来进程，创建打开的文件描述符表</span></span><br><span class="line">  <span class="keyword">if</span> (gOpenFdTable == nullptr) &#123;</span><br><span class="line">    gOpenFdTable = FileDescriptorTable::Create(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gOpenFdTable-&gt;Restat(fds_to_ignore, fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  android_fdsan_error_level fdsan_error_level = android_fdsan_get_error_level();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立即清除任何未使用的内存</span></span><br><span class="line">  mallopt(M_PURGE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//fork SystemServer时，此参数为true</span></span><br><span class="line">    <span class="keyword">if</span> (is_priority_fork) &#123;</span><br><span class="line">      <span class="comment">//设置最高进程优先级</span></span><br><span class="line">      setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_MAX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_MIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The child process.</span></span><br><span class="line">    PreApplicationInit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除所有需要立即关闭的fd</span></span><br><span class="line">    DetachDescriptors(env, fds_to_close, fail_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//USAP机制我们现在不关注</span></span><br><span class="line">    ClearUsapTable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新打开剩余打开的文件描述符，避免文件描述符通过fork在SystemServer和Zygote之间共享</span></span><br><span class="line">    gOpenFdTable-&gt;ReopenOrDetach(fail_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sanitizer机制，用来检测程序异常</span></span><br><span class="line">    android_fdsan_set_error_level(fdsan_error_level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the fd to the unsolicited zygote socket</span></span><br><span class="line">    gSystemServerSocketFd = -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ALOGD(<span class="string">"Forked child process %d"</span>, pid);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消之前阻塞的SIGCHLD信号</span></span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理子进程信号"><a href="#处理子进程信号" class="headerlink" title="处理子进程信号"></a>处理子进程信号</h4><p>先设置子进程信号处理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetSignalHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    struct sigaction sig_chld = &#123;.sa_flags = SA_SIGINFO, .sa_sigaction = SigChldHandler&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(SIGCHLD, &amp;sig_chld, nullptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Error setting SIGCHLD handler: %s"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  struct sigaction sig_hup = &#123;&#125;;</span><br><span class="line">  sig_hup.sa_handler = SIG_IGN;</span><br><span class="line">  <span class="keyword">if</span> (sigaction(SIGHUP, &amp;sig_hup, nullptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGW(<span class="string">"Error setting SIGHUP handler: %s"</span>, strerror(errno));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于信号的处理，我们在<a href="https://juejin.cn/post/7049277873877680142#heading-31" target="_blank" rel="noopener">Android源码分析 - init进程</a>中已经了解过一次，<code>SA_SIGINFO</code>这个flag代表调用信号处理函数<code>sa_sigaction</code>的时候，会将信号的信息通过参数<code>siginfo_t</code>传入</p>
<p><code>SIGHUP</code>表示终端断开信号，<code>SIG_IGN</code>表示忽略信号，即忽略终端断开信号</p>
<p>我们看一下<code>Zygote</code>是怎么处理其子进程信号的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SigChldHandler</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*signal_number*/</span>, siginfo_t* info, <span class="keyword">void</span>* <span class="comment">/*ucontext*/</span>)</span> </span>&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(-<span class="number">1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//通知SystemServer，Zygote收到了一个SIGCHLD信号</span></span><br><span class="line">        sendSigChildStatus(pid, info-&gt;si_uid, status);</span><br><span class="line">        ... <span class="comment">//打印子进程状态日志</span></span><br><span class="line">        <span class="comment">//如果崩溃的进程是SystemServer，整个Zygote都会退出，再通过init进程重启</span></span><br><span class="line">        <span class="keyword">if</span> (pid == gSystemServerPid) &#123;</span><br><span class="line">            async_safe_format_log(ANDROID_LOG_ERROR, LOG_TAG,</span><br><span class="line">                                  <span class="string">"Exit zygote because system server (pid %d) has terminated"</span>, pid);</span><br><span class="line">            kill(getpid(), SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    errno = saved_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果检测到有子进程退出，通知<code>SystemServer</code>，如果这个进程是<code>SystemServer</code>进程，杀掉<code>Zygote</code>进程重启</p>
<h4 id="ZygoteFailure"><a href="#ZygoteFailure" class="headerlink" title="ZygoteFailure"></a>ZygoteFailure</h4><p>这里先需要理解一下<a href="https://www.jianshu.com/p/f191e88dcc80" target="_blank" rel="noopener">C++11 中的std::function和std::bind</a></p>
<p>简单来说，<code>std::bind</code>返回了一个<code>std::function</code>对象，它是一个可调用对象，实际调用的就是传入的第一个参数：<code>ZygoteFailure</code>函数，这个函数接受4个参数，前三个参数都在<code>std::bind</code>时提供好了，第四个参数以<code>_1</code>占位符替代（<code>std::placeholders::_1</code>）</p>
<p>实际上调用<code>fail_fn(msg)</code>就相当于调用函数<code>ZygoteFailure(env, &quot;system_server&quot;, nullptr, msg)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteFailure</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">char</span>* process_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          jstring managed_process_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">  std::unique_ptr&lt;ScopedUtfChars&gt; scoped_managed_process_name_ptr = nullptr;</span><br><span class="line">  <span class="keyword">if</span> (managed_process_name != nullptr) &#123;</span><br><span class="line">    scoped_managed_process_name_ptr.reset(<span class="keyword">new</span> ScopedUtfChars(env, managed_process_name));</span><br><span class="line">    <span class="keyword">if</span> (scoped_managed_process_name_ptr-&gt;c_str() != nullptr) &#123;</span><br><span class="line">      process_name = scoped_managed_process_name_ptr-&gt;c_str();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> std::string&amp; error_msg =</span><br><span class="line">      (process_name == nullptr) ? msg : StringPrintf(<span class="string">"(%s) %s"</span>, process_name, msg.c_str());</span><br><span class="line">  <span class="comment">//抛出异常</span></span><br><span class="line">  env-&gt;FatalError(error_msg.c_str());</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生错误后，最终向Java层抛出了一个异常</p>
<h4 id="BlockSignal-amp-UnblockSignal"><a href="#BlockSignal-amp-UnblockSignal" class="headerlink" title="BlockSignal &amp; UnblockSignal"></a>BlockSignal &amp; UnblockSignal</h4><p>在<code>fork</code>期间需要阻塞住<code>SIGCHLD</code>信号，避免在<code>SIGCHLD</code>信号处理函数中打印log，导致后面关闭的日志fd重新被打开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BlockSignal</span><span class="params">(<span class="keyword">int</span> signum, fail_fn_t fail_fn)</span> </span>&#123;</span><br><span class="line">  sigset_t sigs;</span><br><span class="line">  sigemptyset(&amp;sigs);</span><br><span class="line">  sigaddset(&amp;sigs, signum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigs, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"Failed to block signal %s: %s"</span>, strsignal(signum), strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等<code>fork</code>结束，取消阻塞<code>SIGCHLD</code>信号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnblockSignal</span><span class="params">(<span class="keyword">int</span> signum, fail_fn_t fail_fn)</span> </span>&#123;</span><br><span class="line">  sigset_t sigs;</span><br><span class="line">  sigemptyset(&amp;sigs);</span><br><span class="line">  sigaddset(&amp;sigs, signum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigs, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"Failed to un-block signal %s: %s"</span>, strsignal(signum), strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号集函数我们之前已经在<a href="https://juejin.cn/post/7049277873877680142#heading-32" target="_blank" rel="noopener">Android源码分析 - init进程</a>中介绍过了，很简单，就是将<code>SIGCHLD</code>信号添加到屏蔽集中，<code>fork</code>完后再将这个信号从屏蔽集中移除</p>
<h3 id="SpecializeCommon"><a href="#SpecializeCommon" class="headerlink" title="SpecializeCommon"></a>SpecializeCommon</h3><p>至此，fork操作结束，我们看一下在SystemServer进程中执行的<code>SpecializeCommon</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong permitted_capabilities, jlong effective_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint mount_external, jstring managed_se_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_nice_name, bool is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool is_child_zygote, jstring managed_instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_app_data_dir, bool is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             bool mount_data_dirs, bool mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//process_name = "system_server"</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>;</span><br><span class="line">  auto fail_fn = std::bind(ZygoteFailure, env, process_name, managed_nice_name, _1);</span><br><span class="line">  auto extract_fn = std::bind(ExtractJString, env, process_name, managed_nice_name, _1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//均为nullptr</span></span><br><span class="line">  auto se_info = extract_fn(managed_se_info);</span><br><span class="line">  auto nice_name = extract_fn(managed_nice_name);</span><br><span class="line">  auto instruction_set = extract_fn(managed_instruction_set);</span><br><span class="line">  auto app_data_dir = extract_fn(managed_app_data_dir);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当UID发生改变时（root-&gt;非root）保留capabilities</span></span><br><span class="line">  <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">    EnableKeepCapabilities(fail_fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置Inheritable集合</span></span><br><span class="line">  SetInheritable(permitted_capabilities, fail_fn);</span><br><span class="line">  <span class="comment">//从Bounding集合中移除调用线程相关能力</span></span><br><span class="line">  DropCapabilitiesBoundingSet(fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建私有挂载命名空间，挂载虚拟存储</span></span><br><span class="line">  MountEmulatedStorage(uid, mount_external, need_pre_initialize_native_bridge, fail_fn);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置GroupId</span></span><br><span class="line">  SetGids(env, gids, is_child_zygote, fail_fn);</span><br><span class="line">  <span class="comment">//设置资源Limit</span></span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置gid及访问权限</span></span><br><span class="line">  <span class="keyword">if</span> (setresgid(gid, gid, gid) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"setresgid(%d) failed: %s"</span>, gid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//capabilities集合中仍然存在CAP_SYS_ADMIN，需要过滤系统调用</span></span><br><span class="line">  SetUpSeccompFilter(uid, is_child_zygote);</span><br><span class="line">  <span class="comment">//设置调度策略</span></span><br><span class="line">  SetSchedulerPolicy(fail_fn, is_top_app);</span><br><span class="line">  <span class="comment">//设置uid及访问权限</span></span><br><span class="line">  <span class="keyword">if</span> (setresuid(uid, uid, uid) == -<span class="number">1</span>) &#123;</span><br><span class="line">    fail_fn(CREATE_ERROR(<span class="string">"setresuid(%d) failed: %s"</span>, uid, strerror(errno)));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置Capabilities</span></span><br><span class="line">  SetCapabilities(permitted_capabilities, effective_capabilities, permitted_capabilities, fail_fn);</span><br><span class="line">  <span class="comment">//关闭所有日志相关fd</span></span><br><span class="line">  __android_log_close();</span><br><span class="line">  AStatsSocket_close();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置线程名</span></span><br><span class="line">  <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123; <span class="comment">//nice_name为nullptr, 进入此分支</span></span><br><span class="line">    SetThreadName(<span class="string">"system_server"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取消掉之前设置的SIGCHID信号处理函数</span></span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">    <span class="comment">//调用ZygoteHooks.postForkSystemServer(runtime_flags);</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkSystemServerHooks, runtime_flags);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      fail_fn(<span class="string">"Error calling post fork system server hooks."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//调用ZygoteHooks.postForkChild(runtime_flags, true, false, null);</span></span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认进程优先级</span></span><br><span class="line">  setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了很多工作，有<code>Capabilities</code>相关，<code>selinux</code>相关，权限相关等等，有点太多了，我标了注释，就不再一一分析了</p>
<p>接下来回到<code>nativeForkSystemServer</code>中，在<code>Zygote</code>进程中继续执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits, jlong permitted_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effective_capabilities)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="comment">//检查SystemServer进程状态</span></span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//如果SystemServer进程死亡，重启整个Zygote</span></span><br><span class="line">          ALOGE(<span class="string">"System server process %d has died. Restarting Zygote!"</span>, pid);</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"System server process has died. Restarting Zygote!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是低内存设备，限制SystemServer进程使用内存大小</span></span><br><span class="line">      <span class="keyword">if</span> (UsePerAppMemcg()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!SetTaskProfiles(pid, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&#123;<span class="string">"SystemMemoryProcess"</span>&#125;)) &#123;</span><br><span class="line">              ALOGE(<span class="string">"couldn't add process %d into system memcg group"</span>, pid);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Linux函数<code>waitpid</code>检查<code>SystemServer</code>进程状态，这个函数和之前在<a href="https://juejin.cn/post/7049277873877680142#heading-38" target="_blank" rel="noopener">Android源码分析 - init进程</a>中提过的<code>waitid</code>函数类似，<code>WNOHANG</code>表示非阻塞等待</p>
<p>如果<code>SystemServer</code>进程死亡，重启整个<code>Zygote</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">forkSystemServer</span><span class="params">(String abiList, String socketName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//SystemServer子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭zygote server socket</span></span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">        <span class="keyword">return</span> handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h3><p>如果是小内存设备，使用Linux的<code>cgroups</code>机制，限制<code>SystemServer</code>进程使用内存大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UsePerAppMemcg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> low_ram_device = GetBoolProperty(<span class="string">"ro.config.low_ram"</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> GetBoolProperty(<span class="string">"ro.config.per_app_memcg"</span>, low_ram_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Linux的<code>cgroups</code>机制，可以查看这篇文档：<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank" rel="noopener">cgroups(7) — Linux manual page</a></p>
<p>关于Android的<code>Cgroups</code>机制，可以看这篇官方文档：<a href="https://source.android.google.cn/devices/tech/perf/cgroups?hl=zh-cn" target="_blank" rel="noopener">Cgroup 抽象层</a></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Runnable <span class="title">handleSystemServerProcess</span><span class="params">(ZygoteArguments parsedArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将umask设置为0077，这样新的文件和目录将默认为仅属于所有者的权限</span></span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mNiceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.mNiceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对classpath中的apk，分别进行dex优化操作，由installd真正执行</span></span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//SystemServer进入这个分支</span></span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.mTargetSdkVersion);</span><br><span class="line"></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                parsedArgs.mRemainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理一些初始化操作，然后调用<code>ZygoteInit.zygoteInit</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通用初始化</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    <span class="comment">//开启binder线程池</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">            classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RuntimeInit</code>的路径为<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>，先执行通用初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置默认线程异常处理器</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="string">"persist.sys.timezone"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置Log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置网络UA信息</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    ...</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行<code>RuntimeInit.applicationInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置虚拟机参数</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查找startClass中的main方法</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>我们看一下它是怎么解析参数的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Arguments(String args[]) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    parseArgs(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseArgs</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curArg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; curArg &lt; args.length; curArg++) &#123;</span><br><span class="line">        String arg = args[curArg];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arg.equals(<span class="string">"--"</span>)) &#123;</span><br><span class="line">            curArg++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!arg.startsWith(<span class="string">"--"</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (curArg == args.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Missing classname argument to RuntimeInit!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startClass = args[curArg++];</span><br><span class="line">    startArgs = <span class="keyword">new</span> String[args.length - curArg];</span><br><span class="line">    System.arraycopy(args, curArg, startArgs, <span class="number">0</span>, startArgs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环读参数直到有一项参数为”–”或者不以”–”开头，然后以下一个参数作为<code>startClass</code>，用再下一个参数到args数组结尾生成一个新的数组作为<code>startArgs</code>，我们观察一下<code>forkSystemServer</code>方法中设置的args</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String args[] = &#123;</span><br><span class="line">                <span class="string">"--setuid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgid=1000"</span>,</span><br><span class="line">                <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,"</span></span><br><span class="line">                        + <span class="string">"1024,1032,1065,3001,3002,3003,3006,3007,3009,3010,3011"</span>,</span><br><span class="line">                <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">                <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">                <span class="string">"--runtime-args"</span>,</span><br><span class="line">                <span class="string">"--target-sdk-version="</span> + VMRuntime.SDK_VERSION_CUR_DEVELOPMENT,</span><br><span class="line">                <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>startClass</code>应该为<code>com.android.server.SystemServer</code>，<code>startArgs</code>数组为空</p>
<h3 id="反射执行"><a href="#反射执行" class="headerlink" title="反射执行"></a>反射执行</h3><p>接着调用<code>findStaticMain</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Java中的反射，找到了<code>SystemServer</code>中对应的<code>main</code>方法，并用其创建了一个<code>Runnable</code>对象<code>MethodAndArgsCaller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行SystemServer.main方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们最后再回到<code>ZygoteInit</code>的<code>main</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//启动SystemServer</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子进程中才会满足r != null</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//此时执行这个Runnable</span></span><br><span class="line">            r.run();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行这个在子进程中返回出去的<code>Runnable</code>：<code>MethodAndArgsCaller</code>，反射调用<code>SystemServer.main</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，<code>SystemServer</code>的启动我们就分析完了，下一篇我们将分析<code>SystemServer</code>启动后做了什么</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/14/linux/LinuxCapabilities%E6%9C%BA%E5%88%B6/">Linux Capabilities机制</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-14</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Capabilities/">Capabilities</a></span><div class="content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>传统的Linux权限控制粒度太粗，以<code>passwd</code>命令为例，修改用户密码是需要root权限的，但普通用户应该是能够修改自己密码的才对，这时候Linux就使用了<code>SUID</code>、<code>EUID</code>机制，使<code>passwd</code>进程以它的所有者root权限运行这样就可以以root权限修改密码了</p>
<p><code>SUID</code>机制是有安全隐患的，<code>passwd</code>进程只需要修改密码的就可以了，却在整个运行周期内获得了root权限，一旦出现漏洞，很有可能会被利用</p>
<p>所以，Linux内核在2.2后引入了<code>Capabilities</code>机制，细粒度化了权限控制，可以做到按需授权</p>
<p>这里是文档：<a href="https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/capabilities.7.html</a></p>
<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>首先，<code>Capabilities</code>是有一个集合的概念的，即一个进程或可执行文件，它可以拥有哪些特权的集合</p>
<h2 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h2><p>可执行文件有三种Capabilities集合：</p>
<h3 id="Permitted"><a href="#Permitted" class="headerlink" title="Permitted"></a>Permitted</h3><p>当文件执行时，这个集合的内容会被添加到进程的Permitted集合中</p>
<h3 id="Inheritable"><a href="#Inheritable" class="headerlink" title="Inheritable"></a>Inheritable</h3><p>当文件执行后，这个集合会与进程的<code>Inheritable</code>集合做位与操作(&amp;)，以确定进程在执行<code>execve</code>函数后哪些<code>capabilites</code>可以被继承</p>
<h3 id="Effective"><a href="#Effective" class="headerlink" title="Effective"></a>Effective</h3><p>这不是一个集合，而是一个位(bit)，如果此bit设为1，则<code>Permitted</code>集合中新增的<code>capabilites</code>会在执行<code>execve</code>函数后添加到进程的<code>Effective</code>集合中</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>设置<code>capabilites</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setcap [capability,capability,...]+[ep] [文件]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line"></span><br><span class="line">setcap [capability+ep capability+ep ...] [文件]</span><br></pre></td></tr></table></figure>

<p><code>capability</code>就是某个特权值，+ep代表加入<code>Effective</code>和<code>Permitted</code>集合中</p>
<ul>
<li>获取<code>capabilites</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getcap [文件]</span><br></pre></td></tr></table></figure>

<h2 id="线程（进程）"><a href="#线程（进程）" class="headerlink" title="线程（进程）"></a>线程（进程）</h2><p>线程（进程）有五种Capabilities集合：</p>
<h3 id="Permitted-1"><a href="#Permitted-1" class="headerlink" title="Permitted"></a>Permitted</h3><p>这个集合定义了线程所能够拥有的特权的上限，是<code>Inheritable</code>和<code>Effective</code>集合的的超集</p>
<h3 id="Inheritable-1"><a href="#Inheritable-1" class="headerlink" title="Inheritable"></a>Inheritable</h3><p>包含了当执行<code>execve</code> 函数时，能够被新的可执行文件继承的<code>capabilities</code>（执行<code>execve</code> 函数后会被添加到<code>Permitted</code>集合中）</p>
<h3 id="Effective-1"><a href="#Effective-1" class="headerlink" title="Effective"></a>Effective</h3><p>内核检查特权操作时，实际检查的集合（可以通过执行操作前增/删<code>Effective</code>中的<code>capabilities</code>，以达到临时开/关权限的功能）</p>
<h3 id="Bounding-内核2-6-25以后"><a href="#Bounding-内核2-6-25以后" class="headerlink" title="Bounding (内核2.6.25以后)"></a>Bounding (内核2.6.25以后)</h3><p>这个集合是 <code>Inheritable</code> 集合的超集，如果某个<code>capability</code>不在<code>Bounding</code>集合中，即使它在<code>Permitted</code>集合中，该线程也不能将该<code>capability</code>添加到它的<code>Inheritable</code>集合中，该集合在<code>execve</code>后不可再添加<code>capabilities</code></p>
<h3 id="Ambient-内核4-3以后"><a href="#Ambient-内核4-3以后" class="headerlink" title="Ambient (内核4.3以后)"></a>Ambient (内核4.3以后)</h3><p>这个集合是<code>Permitted</code>和<code>Inheritable</code>的子集，当<code>Permitted</code>和<code>Inheritable</code>删除某个<code>capability</code>时，也会自动删除该集合中对应的<code>capability</code>，子进程会自动继承这个集合中的<code>capabilities</code>，子进程的<code>Permitted</code>、<code>Effective</code>和<code>Ambient</code>都会拥有这些<code>capabilities</code></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="capset"><a href="#capset" class="headerlink" title="capset"></a>capset</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capset</span><span class="params">(<span class="keyword">cap_user_header_t</span> hdrp, <span class="keyword">const</span> <span class="keyword">cap_user_data_t</span> datap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://linux.die.net/man/2/capset" target="_blank" rel="noopener">https://linux.die.net/man/2/capset</a></p>
<h4 id="capget"><a href="#capget" class="headerlink" title="capget"></a>capget</h4><p>原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capget</span><span class="params">(<span class="keyword">cap_user_header_t</span> hdrp , <span class="keyword">cap_user_data_t</span> datap)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文档：<a href="https://linux.die.net/man/2/capget" target="_blank" rel="noopener">https://linux.die.net/man/2/capget</a></p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_header_struct</span> &#123;</span></span><br><span class="line">    __u32 version;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line"> &#125; *<span class="keyword">cap_user_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">user_cap_data_struct</span> &#123;</span></span><br><span class="line">    __u32 effective;</span><br><span class="line">    __u32 permitted;</span><br><span class="line">    __u32 inheritable;</span><br><span class="line"> &#125; *<span class="keyword">cap_user_data_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h1><p>我们用 <code>P</code> 代表执行 <code>execve()</code> 前线程的 capabilities，<code>P&#39;</code> 代表执行 <code>execve()</code> 后线程的 <code>capabilities</code>，<code>F</code> 代表可执行文件的 <code>capabilities</code>，那么：</p>
<blockquote>
<p>P’(ambient) = (file is privileged) ? 0 : P(ambient)</p>
<p>P’(permitted) = (P(inheritable) &amp; F(inheritable)) | (F(permitted) &amp; P(bounding))) | P’(ambient)</p>
<p>P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)</p>
<p>P’(inheritable) = P(inheritable) [i.e., unchanged]</p>
<p>P’(bounding) = P(bounding) [i.e., unchanged]</p>
</blockquote>
<p>我们一条一条来解释：</p>
<ul>
<li><p>如果用户是 root 用户，那么执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合是空集；如果是普通用户，那么执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合将会继承执行 <code>execve()</code> 前线程的 <code>Ambient</code> 集合。</p>
</li>
<li><p>执行 <code>execve()</code> 前线程的 <code>Inheritable</code> 集合与可执行文件的 <code>Inheritable</code> 集合取交集，会被添加到执行 <code>execve()</code> 后线程的 <code>Permitted</code> 集合；可执行文件的 capability bounding 集合与可执行文件的 <code>Permitted</code> 集合取交集，也会被添加到执行 <code>execve()</code> 后线程的 <code>Permitted</code> 集合；同时执行 <code>execve()</code> 后线程的 <code>Ambient</code> 集合中的 capabilities 会被自动添加到该线程的 <code>Permitted</code> 集合中。</p>
</li>
<li><p>如果可执行文件开启了 Effective 标志位，那么在执行完 <code>execve()</code> 后，线程 <code>Permitted</code> 集合中的 capabilities 会自动添加到它的 <code>Effective</code> 集合中。</p>
</li>
<li><p>执行 <code>execve()</code> 前线程的 <code>Inheritable</code> 集合会继承给执行 <code>execve()</code> 后线程的 <code>Inheritable</code> 集合。</p>
</li>
</ul>
<p>这里有几点需要着重强调：</p>
<ol>
<li><p>上面的公式是针对系统调用 <code>execve()</code> 的，如果是 <code>fork()</code>，那么子线程的 capabilities 信息完全复制父进程的 capabilities 信息。</p>
</li>
<li><p>可执行文件的 <code>Inheritable</code> 集合与线程的 <code>Inheritable</code> 集合并没有什么关系，可执行文件 <code>Inheritable</code> 集合中的 capabilities 不会被添加到执行 <code>execve()</code> 后线程的 <code>Inheritable</code> 集合中。如果想让新线程的 <code>Inheritable</code> 集合包含某个 capability，只能通过 <code>capset()</code> 将该 capability 添加到当前线程的 <code>Inheritable</code> 集合中（因为 P’(inheritable) = P(inheritable)）。</p>
</li>
<li><p>如果想让当前线程 <code>Inheritable</code> 集合中的 capabilities 传递给新的可执行文件，该文件的 <code>Inheritable</code> 集合中也必须包含这些 capabilities（因为 P’(permitted)   = (P(inheritable) &amp; F(inheritable))|…）。</p>
</li>
<li><p>将当前线程的 capabilities 传递给新的可执行文件时，仅仅只是传递给新线程的 <code>Permitted</code> 集合。如果想让其生效，新线程必须通过 <code>capset()</code> 将 capabilities 添加到 <code>Effective</code> 集合中。或者开启新的可执行文件的 Effective 标志位（因为 P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)）。</p>
</li>
<li><p>在没有 <code>Ambient</code> 集合之前，如果某个脚本不能调用 <code>capset()</code>，但想让脚本中的线程都能获得该脚本的 <code>Permitted</code> 集合中的 capabilities，只能将 <code>Permitted</code> 集合中的 capabilities 添加到 <code>Inheritable</code> 集合中（P’(permitted)  = P(inheritable) &amp; F(inheritable)|…），同时开启 Effective 标志位（P’(effective)   = F(effective) ? P’(permitted) : P’(ambient)）。有 有 <code>Ambient</code> 集合之后，事情就变得简单多了，后续的文章会详细解释。</p>
</li>
<li><p>如果某个 UID 非零（普通用户）的线程执行了 <code>execve()</code>，那么 <code>Permitted</code> 和 <code>Effective</code> 集合中的 capabilities 都会被清空。</p>
</li>
<li><p>从 root 用户切换到普通用户，那么 <code>Permitted</code> 和 <code>Effective</code> 集合中的 capabilities 都会被清空，除非设置了 SECBIT_KEEP_CAPS 或者更宽泛的 SECBIT_NO_SETUID_FIXUP。</p>
</li>
</ol>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Capabilities表"><a href="#Capabilities表" class="headerlink" title="Capabilities表"></a>Capabilities表</h2><table>
<thead>
<tr>
<th>Capability</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CAP_AUDIT_CONTROL</td>
<td>启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td>CAP_AUDIT_READ</td>
<td>允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td>CAP_AUDIT_WRITE</td>
<td>将记录写入内核审计日志</td>
</tr>
<tr>
<td>CAP_BLOCK_SUSPEND</td>
<td>使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td>CAP_BPF (5.8)</td>
<td>从CAP_SYS_ADMIN分离一部分BFP功能，控制了一些BPF特定的操作，包括创建BPF maps、使用一些高级的BPF程序功能、访问BPF type format（BTF）数据等</td>
</tr>
<tr>
<td>CAP_CHECKPOINT_RESTORE (5.9)</td>
<td>允许更新/proc/sys/kernel/ns_last_pid，使用set_tid特性，读其他进程的/proc/[pid]/map_files</td>
</tr>
<tr>
<td>CAP_CHOWN</td>
<td>修改文件所有者的权限</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>允许设置文件的 setuid 位</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许锁定共享内存片段</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>忽略 IPC 所有权检查</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td>CAP_LEASE</td>
<td>允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td>CAP_MAC_ADMIN</td>
<td>允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td>CAP_MAC_OVERRIDE</td>
<td>忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td>CAP_MKNOD</td>
<td>允许使用 mknod() 系统调用</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许执行网络管理任务</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和多播访问</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用原始套接字</td>
</tr>
<tr>
<td>CAP_PERFMON (5.8)</td>
<td>管理性能监控task</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许改变进程的 GID</td>
</tr>
<tr>
<td>CAP_SETFCAP</td>
<td>允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>允许设置其他进程的 capabilities</td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许改变进程的 UID</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许重新启动系统</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用 chroot() 系统调用</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许插入和删除内核模块</td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许跟踪任何进程</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略资源限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许改变系统时钟</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置 TTY 设备</td>
</tr>
<tr>
<td>CAP_SYSLOG</td>
<td>允许使用 syslog() 系统调用</td>
</tr>
<tr>
<td>CAP_WAKE_ALARM</td>
<td>允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/sparkdev/p/11417781.html" target="_blank" rel="noopener">Linux Capabilities 简介</a></p>
<p><a href="http://rk700.github.io/2016/10/26/linux-capabilities/" target="_blank" rel="noopener">Linux的capabilities机制</a></p>
<p><a href="https://fuckcloudnative.io/posts/linux-capabilities-why-they-exist-and-how-they-work/" target="_blank" rel="noopener">Linux Capabilities 入门教程：概念篇</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/10/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Zygote%E8%BF%9B%E7%A8%8B/">Android源码分析 - Zygote进程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Zygote/">Zygote</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>上一篇文章<a href="https://juejin.cn/post/7049277873877680142" target="_blank" rel="noopener">Android源码分析 - init进程</a>，我们分析了Android第一个用户进程init进程的启动过程和之后的守护服务</p>
<p>init进程启动了很多服务，例如Zygote，ServiceManager，MediaServer，SurfaceFlinger等，我们平常写Android应用都是使用Java语言，这次我们就先从Java世界的半边天：Zygote进程 开始分析</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Zygote意为受精卵，它有两大作用，一是启动SystemServer，二是孵化启动App</p>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><p>我们已经知道了init进程会从<code>init.rc</code>文件中解析并启动服务，那zygote是在哪定义的呢，<code>init.rc</code>的头几行就有一个import：<code>import /system/etc/init/hw/init.${ro.zygote}.rc</code></p>
<p>我们在init.rc同目录下就能找到几个对应的文件：<code>init.zygote32_64.rc</code> <code>init.zygote32.rc</code> <code>init.zygote64_32.rc</code> <code>init.zygote64.rc</code>，具体import哪个文件与具体设备硬件有关，现在64位手机这么普及了，我们就以<code>init.zygote64.rc</code>为目标分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    writepid &#x2F;dev&#x2F;cpuset&#x2F;foreground&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p>下面的子项我们暂时不用关心，先记住<code>app_process64</code>的启动参数<code>-Xzygote /system/bin --zygote --start-system-server</code>即可</p>
<p>Zygote启动的源文件为<code>frameworks/base/cmds/app_process/app_main.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建了一个AppRuntime，继承自AndroidRuntime，重写了一些回调方法</span></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    <span class="comment">//在启动服务时，传进来的参数是包含文件路径的</span></span><br><span class="line">    <span class="comment">//我们不需要这个参数，就减一下个数，移一下指针</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理参数，这里只添加了一个-Xzygote参数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳过参数/system/bin，这个参数目前没有被使用</span></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有--zygote参数</span></span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//ZYGOTE_NICE_NAME在64位下为zygote64，32位下为zygote</span></span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//有-start-system-server参数</span></span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//这个分支不会进入Zygote模式</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">        <span class="comment">//新建Dalvik缓存目录</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加启动参数</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="comment">//Zygote模式下没有其他参数了</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//设置程序名以及进程名</span></span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>(), <span class="literal">true</span> <span class="comment">/* setProcName */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">//执行AndroidRuntime::start方法</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体结构还是比较简单的，就是处理一下参数，进入zygote对应的分支，执行AndroidRuntime::start方法，第一个参数传的是ZygoteInit在Java中的类名，第二个参数传了一些选项（start-system-server和abi-list），第三个参数传了true，代表启动虚拟机的时候需要额外添加一些JVM参数</p>
<h1 id="AndroidRuntime-start"><a href="#AndroidRuntime-start" class="headerlink" title="AndroidRuntime::start"></a>AndroidRuntime::start</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Whether this is the primary zygote, meaning the zygote which will fork system server.</span></span><br><span class="line">    <span class="comment">//64_32位兼容设备上会启动两个Zygote，一个叫zygote，一个叫zygote_secondary</span></span><br><span class="line">    <span class="keyword">bool</span> primary_zygote = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有start-system-server选项则代表是主Zygote</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查和配置一些环境变量</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    <span class="comment">//加载libart.so</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="comment">//启动JVM</span></span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回调AppRuntime中重写的方法</span></span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//注册Android JNI函数</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断选项中是否携带参数start-system-server，如有，则将它视为主Zygote，接着就开始启动JVM了</p>
<h1 id="启动JVM"><a href="#启动JVM" class="headerlink" title="启动JVM"></a>启动JVM</h1><h2 id="JniInvocation"><a href="#JniInvocation" class="headerlink" title="JniInvocation"></a>JniInvocation</h2><p>使用JniInvocation初始化Android ART虚拟机环境，它的路径是<code>libnativehelper/include_platform/nativehelper/JniInvocation.h</code>，我们来看一下它是怎么做的</p>
<p>我们首先看一下它的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* libnativehelper/include_platform/nativehelper/JniInvocation.h */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JniInvocation</span> <span class="title">final</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    JniInvocation() &#123;</span><br><span class="line">        impl_ = JniInvocationCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~JniInvocation() &#123;</span><br><span class="line">        JniInvocationDestroy(impl_);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>JniInvocationCreate</code>方法创建了一个JniInvocationImpl实例对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JniInvocationImpl* <span class="title">JniInvocationCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JniInvocationImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用<code>JniInvocation::Init</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JniInvocationInit(impl_, library) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">JniInvocationInit</span><span class="params">(JniInvocationImpl* instance, <span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance-&gt;Init(library) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>JniInvocation</code>实际上是个代理类，内部实现是交给<code>JniInvocationImpl</code>的，路径为<code>libnativehelper/JniInvocation.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//非debug一律为libart.so</span></span><br><span class="line">  library = GetLibrary(library, <span class="built_in">buffer</span>);</span><br><span class="line">  <span class="comment">//加载libart.so库</span></span><br><span class="line">  handle_ = OpenLibrary(library);</span><br><span class="line">  <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//如果是加载libart.so库失败，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(library, kLibraryFallback) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Nothing else to try.</span></span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果是加载其他库失败，尝试回退加载libart.so库</span></span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    handle_ = OpenLibrary(library);</span><br><span class="line">    <span class="keyword">if</span> (handle_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"Failed to dlopen %s: %s"</span>, library, GetError().c_str());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从libart.so库获得三个JVM相关的函数地址</span></span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetDefaultJavaVMInitArgs_),</span><br><span class="line">                  <span class="string">"JNI_GetDefaultJavaVMInitArgs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_CreateJavaVM_),</span><br><span class="line">                  <span class="string">"JNI_CreateJavaVM"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!FindSymbol(<span class="keyword">reinterpret_cast</span>&lt;FUNC_POINTER*&gt;(&amp;JNI_GetCreatedJavaVMs_),</span><br><span class="line">                  <span class="string">"JNI_GetCreatedJavaVMs"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载libart-so库"><a href="#加载libart-so库" class="headerlink" title="加载libart.so库"></a>加载libart.so库</h3><p>我们先看<code>GetLibrary</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* kLibraryFallback = <span class="string">"libart.so"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">JniInvocationImpl::GetLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* library,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">char</span>* <span class="built_in">buffer</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">bool</span> (*is_debuggable)(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> (*get_library_system_property)(<span class="keyword">char</span>* <span class="built_in">buffer</span>))</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ANDROID__</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_debuggable()) &#123;</span><br><span class="line">    library = kLibraryFallback;</span><br><span class="line">    default_library = kLibraryFallback;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* default_library = kLibraryFallback;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (library == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    library = default_library;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> library;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在debug模式或<code>library</code>参数为<code>NULL</code>的情况下都是直接返回的<code>libart.so</code></p>
<p>而<code>OpenLibrary</code>方法是使用了<code>dlopen</code>函数，加载<code>libart.so</code>库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">OpenLibrary</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> kDlopenFlags = RTLD_NOW | RTLD_NODELETE;</span><br><span class="line">  <span class="keyword">return</span> dlopen(filename, kDlopenFlags);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen"></a>dlopen</h4><p>原型：<code>void *dlopen(const char *filename, int flags);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlopen.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlopen.3.html</a></p>
<p>这是一个Linux函数，用来加载一个动态链接库，当加载成功时，会返回一个句柄</p>
<p>上面的这两个参数，<code>RTLD_NOW</code>代表立即计算库的依赖性，<code>RTLD_NODELETE</code>代表不要再<code>dlclose</code>期间卸载库，这样当再次加载库的时候不会重新初始化对象的静态全局变量，使用这个flag是为了确保<code>libart.so</code>在关闭时不会被取消映射。因为即使在 <code>JNI_DeleteJavaVM</code> 调用之后，某些线程仍可能尚未完成退出，如果卸载该库，则可能导致段错误</p>
<h3 id="从libart-so库中寻找函数地址"><a href="#从libart-so库中寻找函数地址" class="headerlink" title="从libart.so库中寻找函数地址"></a>从libart.so库中寻找函数地址</h3><p>接着调用<code>FindSymbol</code>函数查找函数地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNC_POINTER void*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">JniInvocationImpl::FindSymbol</span><span class="params">(FUNC_POINTER* pointer, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得函数地址</span></span><br><span class="line">  *pointer = GetSymbol(handle_, symbol);</span><br><span class="line">  <span class="comment">//获取失败，卸载libart.so库</span></span><br><span class="line">  <span class="keyword">if</span> (*pointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Failed to find symbol %s: %s\n"</span>, symbol, GetError().c_str());</span><br><span class="line">    CloseLibrary(handle_);</span><br><span class="line">    handle_ = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FUNC_POINTER <span class="title">GetSymbol</span><span class="params">(<span class="keyword">void</span>* handle, <span class="keyword">const</span> <span class="keyword">char</span>* symbol)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> dlsym(handle, symbol);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym"></a>dlsym</h4><p>原型：<code>void *dlsym(void *restrict handle , const char *restrict symbol);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/dlsym.3.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/dlsym.3.html</a></p>
<p>也是一个Linux函数，用来从已加载的动态链接库中获取一个函数的地址</p>
<p>传入的第一个参数为之前加载库时返回的句柄，第二个参数为函数名</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回顾一下全局，<code>JniInvocationImpl::Init</code>的作用是，加载<code>libart.so</code>库，并从中获取三个函数指针：</p>
<ul>
<li>JNI_GetDefaultJavaVMInitArgs：获取虚拟机的默认初始化参数</li>
<li>JNI_CreateJavaVM：创建虚拟机实例</li>
<li>JNI_GetCreatedJavaVMs：获取创建的虚拟机实例</li>
</ul>
<p>这几个函数被定义在<code>jni.h</code>中，后面我们创建JVM的时候会用到这些函数</p>
<h2 id="AndroidRuntime-startVm"><a href="#AndroidRuntime-startVm" class="headerlink" title="AndroidRuntime::startVm"></a>AndroidRuntime::startVm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote, <span class="keyword">bool</span> primary_zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaVMInitArgs initArgs;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//配置了一大堆JVM选项</span></span><br><span class="line">    </span><br><span class="line">    initArgs.version = JNI_VERSION_1_4;</span><br><span class="line">    initArgs.options = mOptions.editArray();</span><br><span class="line">    initArgs.nOptions = mOptions.<span class="built_in">size</span>();</span><br><span class="line">    initArgs.ignoreUnrecognized = JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并初始化JVM</span></span><br><span class="line">    <span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JNI_CreateJavaVM failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JNI_CreateJavaVM</code>方法就是我们之前从<code>libart.so</code>里获得的方法，被编译进<code>libart.so</code>前，源码的路径为<code>art/runtime/jni/java_vm_ext.cc</code>，接下来属于ART虚拟机的工作，我们就不再往下深究了</p>
<p>后面有一个<code>onVmCreated</code>回调，但在zygote模式下没做任何事</p>
<h1 id="注册JNI函数"><a href="#注册JNI函数" class="headerlink" title="注册JNI函数"></a>注册JNI函数</h1><p>接着调用<code>startReg</code>函数注册Android JNI函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register android native functions with the VM.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*static*/</span> <span class="function"><span class="keyword">int</span> <span class="title">AndroidRuntime::startReg</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置Native创建线程的函数，通过javaCreateThreadEtc这个函数创建的线程</span></span><br><span class="line">    <span class="comment">//会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"--- registering native functions ---\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建局部引用栈帧</span></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册jni函数</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前栈帧出栈，释放其中所有局部引用</span></span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先hook了Native创建线程的函数，之后创建线程便会调用我们设置的<code>javaCreateThreadEtc</code>函数，<br>会把创建的线程attach到JVM中，使其既能执行c/c++代码，也能执行Java代码。这个等之后看到Android线程创建的时候再分析</p>
<p><code>PushLocalFrame</code>和<code>PopLocalFrame</code>是一对函数，它们是用来管理JNI的局部引用的</p>
<p>首先，<code>PushLocalFrame</code>会创建出一个局部引用栈帧，之后JNI创建出来的局部引用都会放在这个栈帧里，等使用结束后调用PopLocalFrame函数，会将当前栈帧出栈，并且释放其中所有的局部引用</p>
<p>接下来我们看<code>register_jni_procs</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是循环执行<code>gRegJNI</code>数组中所有的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">        REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">        REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit),</span><br><span class="line">        REG_JNI(register_android_os_SystemClock),</span><br><span class="line">        REG_JNI(register_android_util_EventLog),</span><br><span class="line">        REG_JNI(register_android_util_Log),</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>gRegJNI</code>数组中存放着很多Java类注册JNI函数的函数，后面大家如果阅读源码看到了Android中的native方法可以来这边找它所对应的c++实现</p>
<p>这边注册的类非常多，我们就取第一个<code>register_com_android_internal_os_RuntimeInit</code>为例分析一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">    <span class="keyword">void</span>*       fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">            &#123;<span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeFinishInit&#125;,</span><br><span class="line">            &#123;<span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">             (<span class="keyword">void</span>*)com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">"com/android/internal/os/RuntimeInit"</span>,</span><br><span class="line">        methods, NELEM(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个JNINativeMethod结构体，第一个成员是Java中的方法名，第二个成员是Java中对应方法的签名，第三个成员是Java方法对应native函数的函数指针，然后调用<code>jniRegisterNativeMethods</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jniRegisterNativeMethods</span><span class="params">(C_JNIEnv* env, <span class="keyword">const</span> <span class="keyword">char</span>* className,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> JNINativeMethod* gMethods, <span class="keyword">int</span> numMethods)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* e = <span class="keyword">reinterpret_cast</span>&lt;JNIEnv*&gt;(env);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Registering %s's %d native methods..."</span>, className, numMethods);</span><br><span class="line"></span><br><span class="line">    <span class="function">scoped_local_ref&lt;jclass&gt; <span class="title">c</span><span class="params">(env, findClass(env, className))</span></span>;</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(c.<span class="built_in">get</span>() == <span class="literal">NULL</span>,</span><br><span class="line">                         <span class="string">"Native registration unable to find class '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = e-&gt;RegisterNatives(c.<span class="built_in">get</span>(), gMethods, numMethods);</span><br><span class="line">    ALOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"RegisterNatives failed for '%s'; aborting..."</span>,</span><br><span class="line">                         className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数先通过Java类名获得一个jclass对象，接着调用<code>JNIEnv::RegisterNatives</code>函数，这个函数定义在<code>jni.h</code>中，实现在<code>libart.so</code>库中，我们在平时开发jni的时候，动态注册native方法的时候就会使用到它，这里就不再往下分析了</p>
<h1 id="进入JAVA世界"><a href="#进入JAVA世界" class="headerlink" title="进入JAVA世界"></a>进入JAVA世界</h1><p>JVM启动好了，JNI函数也注册完毕了，接下来就该进入到JAVA世界了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建一个Java层的String数组用来装参数</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line"></span><br><span class="line">    stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">    assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(options.<span class="built_in">size</span>() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">    assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//第一个参数是类名com.android.internal.os.ZygoteInit</span></span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下来参数分别是start-system-server和abi-list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">        assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//将Java类名中的"."替换成"/"，这是JNI中的类名规则</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取ZygoteInit中的main方法，参数为String类型，返回值为void</span></span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//执行ZygoteInit的main方法</span></span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后面的代码除非JVM挂了，否则不会执行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看不懂的自己先补一下JNI知识，总之就是调用了<code>com.android.internal.os.ZygoteInit</code>类的静态方法<code>main</code>，以<code>com.android.internal.os.ZygoteInit</code>，<code>start-system-server</code>和<code>abi-list</code>作为参数</p>
<h1 id="ZygoteInit"><a href="#ZygoteInit" class="headerlink" title="ZygoteInit"></a>ZygoteInit</h1><p><code>ZygoteInit</code>类的源码路径为<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code></p>
<p>我们这就开始分析它的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="comment">//标记着zygote开始启动，不允许创建线程（Zygote必须保证单线程）</span></span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">    <span class="comment">//设置进程组id</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//配置参数</span></span><br><span class="line">        <span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">        String zygoteSocketName = <span class="string">"zygote"</span>;</span><br><span class="line">        String abiList = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> enableLazyPreload = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argv.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"start-system-server"</span>.equals(argv[i])) &#123;</span><br><span class="line">                startSystemServer = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--enable-lazy-preload"</span>.equals(argv[i])) &#123;</span><br><span class="line">                enableLazyPreload = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span><br><span class="line">                abiList = argv[i].substring(ABI_LIST_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span><br><span class="line">                zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown command line argument: "</span> + argv[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public static final String PRIMARY_SOCKET_NAME = "zygote";</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPrimaryZygote = zygoteSocketName.equals(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!enableLazyPreload) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//预加载</span></span><br><span class="line">            preload(bootTimingsTraceLog);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用Java层的垃圾回收</span></span><br><span class="line">        gcAndFinalize();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//回调AppRRuntime中的onZygoteInit函数</span></span><br><span class="line">        Zygote.initNativeState(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除创建线程限制（马上就要执行fork了，子进程要有能力创建线程）</span></span><br><span class="line">        ZygoteHooks.stopZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        zygoteServer = <span class="keyword">new</span> ZygoteServer(isPrimaryZygote);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动SystemServer</span></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">            <span class="comment">// child (system_server) process.</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The select loop returns early in the child process after a fork and</span></span><br><span class="line">        <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">        <span class="comment">//执行死循环监听socket，负责接收事件，启动App</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zygoteServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the child process and have exited the select loop. Proceed to execute the</span></span><br><span class="line">    <span class="comment">// command.</span></span><br><span class="line">    <span class="comment">//接收到AMS的启动App请求后，fork出子进程，处理App启动</span></span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ZygoteHooks.startZygoteNoThreadCreation()</code>禁止创建线程，Zygote必须保证单线程，这和<code>fork</code>机制有关，<code>fork</code>函数只会将当前线程复制到子进程，同时，<code>fork</code>会将锁也复制到子进程中，如果在<code>fork</code>之前，有一个线程持有了锁，但是<code>fork</code>的时候没把这个线程复制到子进程中，这把锁就被永久持有了，会造成死锁</p>
<h2 id="android-system-Os"><a href="#android-system-Os" class="headerlink" title="android.system.Os"></a>android.system.Os</h2><p>我们看一下<code>Os</code>是什么，根据import我们知道它的全限定类名为<code>android.system.Os</code>，它的源码路径为<code>libcore/luni/src/main/java/android/system/Os.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">import</span> libcore.io.Libcore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Os</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; Libcore.os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它里面全是这种形式的静态代理方法，实际调用<code>Libcore.os</code>执行，我们就以<code>setpgid</code>方法去追踪一下</p>
<p><code>Libcore</code>位于<code>libcore/luni/src/main/java/libcore/io/Libcore.java</code>，<code>os</code>是其中的一个静态变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Direct access to syscalls. Code should strongly prefer using &#123;<span class="doctag">@link</span> #os&#125;</span></span><br><span class="line"><span class="comment">     * unless it has a strong reason to bypass the helpful checks/guards that it</span></span><br><span class="line"><span class="comment">     * provides.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Os rawOs = <span class="keyword">new</span> Linux();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Access to syscalls with helpful checks/guards.</span></span><br><span class="line"><span class="comment">     * For read access only; the only supported way to update this field is via</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #compareAndSetOs&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Os os = <span class="keyword">new</span> BlockGuardOs(rawOs);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Os <span class="title">getOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>os</code>的类型为<code>BlockGuardOs</code>，以<code>Linux</code>类型的常量<code>rawOs</code>作为构造方法参数实例化，它继承自<code>ForwardingOs</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingOs</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Os os;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="meta">@libcore</span>.api.CorePlatformApi</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ForwardingOs</span><span class="params">(Os os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.os = Objects.requireNonNull(os);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> pgid)</span> <span class="keyword">throws</span> ErrnoException </span>&#123; os.setpgid(pid, pgid); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这其实又是一个代理类，实际上是直接调用了<code>Linux</code>类的方法，至于<code>BlockGuardOs</code>，它在部分方法上做了一些回调监听，除此之外也是直接调用了<code>Linux</code>类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Linux</span> <span class="keyword">implements</span> <span class="title">Os</span> </span>&#123;</span><br><span class="line">    Linux() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">int</span> pid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面基本上都是JNI调用native方法，对应的c++源码路径为<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>，下面是注册JNI函数的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NATIVE_METHOD(className, functionName, signature)                \</span></span><br><span class="line">  MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_JNI_NATIVE_METHOD(name, signature, function)                      \</span></span><br><span class="line">  _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \</span></span><br><span class="line">  MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn)</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \</span></span><br><span class="line">  ([]() &#123;                                                                \</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> nativehelper::detail;  <span class="comment">/* NOLINT(google-build-using-namespace) */</span> \</span><br><span class="line">    <span class="keyword">static_assert</span>(                                                       \</span><br><span class="line">        MatchJniDescriptorWithFunctionType&lt;native_kind,                  \</span><br><span class="line">                                           <span class="keyword">decltype</span>(fn),                 \</span><br><span class="line">                                           fn,                           \</span><br><span class="line">                                           <span class="keyword">sizeof</span>(signature_)&gt;(signature_),\</span><br><span class="line">        <span class="string">"JNI signature doesn't match C++ function type."</span>);               \</span><br><span class="line">    <span class="comment">/* Suppress implicit cast warnings by explicitly casting. */</span>         \</span><br><span class="line">    <span class="keyword">return</span> JNINativeMethod &#123;                                             \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::name)&gt;(name_),              \</span><br><span class="line">        <span class="keyword">const_cast</span>&lt;<span class="keyword">decltype</span>(JNINativeMethod::signature)&gt;(signature_),    \</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;(fn))&#125;;                                 \</span><br><span class="line">  &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    NATIVE_METHOD(Linux, setpgid, <span class="string">"(II)V"</span>),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_libcore_io_Linux</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jniRegisterNativeMethods(env, <span class="string">"libcore/io/Linux"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Java层方法对应native方法的格式为<code>Linux_方法名</code>，我们通过这种规则找到<code>setpgid</code>方法对应的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Linux_setpgid</span><span class="params">(JNIEnv* env, jobject, jint pid, <span class="keyword">int</span> pgid)</span> </span>&#123;</span><br><span class="line">    throwIfMinusOne(env, <span class="string">"setpgid"</span>, TEMP_FAILURE_RETRY(setpgid(pid, pgid)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是直接调用了Linux系统层函数</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>综上所述，<code>android.system.Os</code>类存在的意义是可以使Java层能够方便的调用Linux系统方法</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>接下来就是一些参数配置工作，然后调用<code>preload</code>预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载Java类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//加载三个jar文件</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.base-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.hidl.manager-V1.0-java.jar */</span></span><br><span class="line">    <span class="comment">/* /system/framework/android.test.base.jar */</span></span><br><span class="line">    cacheNonBootClasspathClassLoaders();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载系统资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载硬件抽象层？</span></span><br><span class="line">    nativePreloadAppProcessHALs();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载opengl</span></span><br><span class="line">    maybePreloadGraphicsDriver();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//预加载动态库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line">    <span class="comment">//TextView预加载Font</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line">    <span class="comment">//预加载webviewchromium</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preloadClasses"><a href="#preloadClasses" class="headerlink" title="preloadClasses"></a>preloadClasses</h3><p>我们看看Java类的预加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRELOADED_CLASSES = <span class="string">"/system/etc/preloaded-classes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(PRELOADED_CLASSES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Couldn't find "</span> + PRELOADED_CLASSES + <span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br =</span><br><span class="line">                <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">            line = line.trim();</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//Java类加载器加载类</span></span><br><span class="line">            Class.forName(line, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            count++;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"...preloaded "</span> + count + <span class="string">" classes in "</span></span><br><span class="line">                + (SystemClock.uptimeMillis() - startTime) + <span class="string">"ms."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error reading "</span> + PRELOADED_CLASSES + <span class="string">"."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的代码就是从<code>/system/etc/preloaded-classes</code>这个文件中读取出需要预加载的类，再通过<code>Class.forName</code>使用类加载器加载一遍，编译前的路径为<code>frameworks/base/config/preloaded-classes</code></p>
<h3 id="为什么需要预加载"><a href="#为什么需要预加载" class="headerlink" title="为什么需要预加载"></a>为什么需要预加载</h3><p>Zygote进程的一大作用就是孵化App，那是怎么孵化的呢？这过程中肯定要使用到<code>fork</code>，我们知道，<code>fork</code>后，父子进程是可以共享资源的，既然我们每启动一个App，都需要使用虚拟机、加载一些View等必要的类等等，那为何不在父进程中加载好这些，fork后子进程不就可以直接使用它们了吗？这就是Zygote进程预加载的原因</p>
<h2 id="启动binder线程池"><a href="#启动binder线程池" class="headerlink" title="启动binder线程池"></a>启动binder线程池</h2><p>预加载结束后，会先清理一下Java层的垃圾，然后调用<code>Zygote.initNativeState(isPrimaryZygote)</code>方法，这个方法调用了native方法<code>nativeInitNativeState</code>，这个方法是在<code>AndroidRuntime</code>中注册的，同时也实现在<code>AndroidRuntime</code>中，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_ZygoteInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们之前分析过，执行的是<code>AndroidRuntime</code>的子类<code>AppRuntime</code>的<code>onZygoteInit</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个函数启动Binder线程池，至于Binder的细节，我们留到以后再分析</p>
<h2 id="启动SystemServer"><a href="#启动SystemServer" class="headerlink" title="启动SystemServer"></a>启动SystemServer</h2><p><code>Zygote</code>进程孵化的第一个进程便是<code>SystemServer</code>，具体怎么孵化的，孵化后SystemServer又做了什么，留在下一节我们再分析</p>
<h1 id="ZygoteServer"><a href="#ZygoteServer" class="headerlink" title="ZygoteServer"></a>ZygoteServer</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们知道，我们App都是从<code>Zygote</code>孵化而来的，App启动是从<code>ActivityManagerService</code>的<code>startActivity</code>方法开始的，那么AMS是怎么和Zygote通信的呢，答案是通过socket</p>
<p>我们先从ZygoteServer的构造方法开始看起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ZygoteServer(<span class="keyword">boolean</span> isPrimaryZygote) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isPrimaryZygote) &#123;</span><br><span class="line">        mZygoteSocket = Zygote.createManagedSocketFromInitSocket(Zygote.PRIMARY_SOCKET_NAME);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一些东西是和USAP机制有关的，但在AOSP中默认是关闭的，关于USAP机制我们以后再分析，现在只需要关注<code>mZygoteSocket</code>就可以了，它是通过调用<code>Zygote.createManagedSocketFromInitSocket</code>赋值的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalServerSocket <span class="title">createManagedSocketFromInitSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fileDesc;</span><br><span class="line">    <span class="comment">//ANDROID_SOCKET_zygote</span></span><br><span class="line">    <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得文件描述符</span></span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Socket unset or invalid: "</span> + fullSocketName, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.setInt$(fileDesc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalServerSocket(fd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Error building socket from file descriptor: "</span> + fileDesc, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，就是从系统属性中获取一个fd，然后实例化<code>LocalServerSocket</code>，路径为<code>frameworks/base/core/java/android/net/LocalServerSocket.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LocalServerSocket</span><span class="params">(FileDescriptor fd)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    impl = <span class="keyword">new</span> LocalSocketImpl(fd);</span><br><span class="line">    impl.listen(LISTEN_BACKLOG);</span><br><span class="line">    localAddress = impl.getSockAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内部创建了一个<code>LocalSocketImpl</code>，然后调用了<code>listen</code>方法声明开始监听这个fd，内部调用了Linux的<code>listen</code>函数</p>
<h2 id="runSelectLoop"><a href="#runSelectLoop" class="headerlink" title="runSelectLoop"></a>runSelectLoop</h2><p>然后我们来看在<code>ZygoteInit</code>中调用的<code>runSelectLoop</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; socketFDs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将server socket fd加到列表头（后面需要判断是否为server socket）</span></span><br><span class="line">    socketFDs.add(mZygoteSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        StructPollfd[] pollFDs;</span><br><span class="line">        ...</span><br><span class="line">        pollFDs = <span class="keyword">new</span> StructPollfd[socketFDs.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pollIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileDescriptor socketFD : socketFDs) &#123;</span><br><span class="line">            pollFDs[pollIndex] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFDs[pollIndex].fd = socketFD;</span><br><span class="line">            pollFDs[pollIndex].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            ++pollIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        ... <span class="comment">//上面一大段都与USAP机制有关，这里先不关注</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pollReturnValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待文件描述符上的事件</span></span><br><span class="line">            pollReturnValue = Os.poll(pollFDs, pollTimeoutMs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pollReturnValue == <span class="number">0</span>) &#123; <span class="comment">//没有接收到事件（超时），从循环开头重新开始等待事件</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">while</span> (--pollIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有要读取的数据，跳过</span></span><br><span class="line">                <span class="keyword">if</span> ((pollFDs[pollIndex].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pollIndex == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//pollIndex == 0说明这个fd是ZygoteServer socket的fd</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//接受并建立一个socket连接</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    <span class="comment">//将client socket fd加入列表</span></span><br><span class="line">                    socketFDs.add(newPeer.getFileDescriptor());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pollIndex &lt; usapPoolEventFDIndex) &#123;</span><br><span class="line">                    <span class="comment">//不使用USAP机制的话，pollIndex &lt; usapPoolEventFDIndex条件一定成立</span></span><br><span class="line">                    <span class="comment">//进入这边说明是client socket</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//内部执行fork，返回一个待执行Runnable用于处理子进程后续任务</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(pollIndex);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//fork后，在子进程中会将这个变量设为true</span></span><br><span class="line">                        <span class="keyword">if</span> (mIsForkChild) &#123; <span class="comment">//子进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//return出去，由ZygoteInit执行这个Runnable</span></span><br><span class="line">                            <span class="keyword">return</span> command;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">                            <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//读取完了，关闭这个socket，清理列表</span></span><br><span class="line">                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                                connection.closeSocket();</span><br><span class="line">                                peers.remove(pollIndex);</span><br><span class="line">                                socketFDs.remove(pollIndex);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ... <span class="comment">//不开启USAP机制不会走到这个分支</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建两个列表，<code>socketFDs</code>和<code>peers</code>的下标是一一对应的，首先将server socket fd添加到列表头，方便后续判断事件是来自client或是server socker，<code>peers</code>列表也要添加一个<code>null</code>作为<code>socketFDs</code>的对应</p>
<p>接着就开始执行死循环，<code>Zygote</code>进程永远不会退出这个循环，只有<code>fork</code>出子进程后，子进程会主动return</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>为了理解后面的内容，我们先要学习一下poll函数</p>
<p>poll是Linux中的字符设备驱动中的一个函数，它的作用是等待文件描述符上的某个事件</p>
<p>原型：<code>int poll(struct pollfd * fds , nfds_t nfds , int timeout );</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/poll.2.html</a></p>
<p>第一个参数是一个<code>pollfd</code>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fd不用多说，就是文件描述符</li>
<li>event代表关注哪些事件，<code>POLLIN</code>代表可读，<code>POLLOUT</code>代表可写等等</li>
<li>revents是由内核通知的，函数返回的时候，会设置对应的fd实际发生的事件，比如fd有可读的事件，设置<code>POLLIN</code></li>
</ul>
<p>第二个参数<code>nfds</code>表示fd的个数，即<code>pollfd</code>数组的size</p>
<p>第三个参数表示超时时间</p>
<p>返回值：</p>
<ul>
<li>大于0：表示有fd事件产生，值为有产生事件的fd的个数</li>
<li>等于0：表示超时</li>
<li>小于0：表示有错误产生</li>
</ul>
<h4 id="StructPollfd-amp-pollfd"><a href="#StructPollfd-amp-pollfd" class="headerlink" title="StructPollfd &amp; pollfd"></a>StructPollfd &amp; pollfd</h4><p>弄懂poll是干嘛的后，我们再来接着看<code>runSelectLoop</code>方法</p>
<p>死循环中首先创建了一个<code>StructPollfd</code>数组，它根据<code>socketFDs</code>依次创建出一个个<code>StructPollfd</code>对象，并将他们的事件都设为<code>POLLIN</code>可读</p>
<p><code>StructPollfd</code>和c中的结构体<code>pollfd</code>是对应的，目的是为了方便Java层调用Linux的<code>poll</code>函数</p>
<p><code>StructPollfd</code>的路径为<code>libcore/luni/src/main/java/android/system/StructPollfd.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StructPollfd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> FileDescriptor fd;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> events;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">short</span> revents;</span><br><span class="line">    <span class="keyword">public</span> Object userData;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>然后调用<code>Os.poll</code>方法</p>
<p>关于<code>Os</code>我们上面刚分析过，知道他调用了JNI函数，native函数命名格式为<code>Linux_函数名</code>，我们去<code>libcore/luni/src/main/native/libcore_io_Linux.cpp</code>中找一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Linux_poll</span><span class="params">(JNIEnv* env, jobject, jobjectArray javaStructs, jint timeoutMs)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//把Java对象StructPollfd数组转换成c中的struct pollfd数组</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        rc = poll(fds.get(), count, timeoutMs);</span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= <span class="number">0</span> || errno != EINTR) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">        throwErrnoException(env, <span class="string">"poll"</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">//设置Java对象StructPollfd的revents值</span></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看一下，就是把传进去的<code>StructPollfd</code>数组转换成了<code>struct pollfd</code>数组，然后调用Linux <code>poll</code>函数，再把<code>revents</code>写进<code>StructPollfd</code>对象中，最后返回</p>
<p>再看回<code>runSelectLoop</code>方法，如果poll执行返回值为-1，会直接引发一个Java异常，其他情况先判断一下<code>poll</code>的返回值，如果为0，则没有事件产生，否则会从后向前依次判断<code>pollFDs</code>的<code>revents</code>，如果为<code>POLLIN</code>可读，则处理，不可读则跳过</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>我们先看第一次<code>poll</code>到事件的情况，这时候，<code>pollFDs</code>中只有一个zygote socket fd，收到可读事件，说明有客户端socket向zygote socket请求发起连接，这时候我们调用<code>acceptCommandPeer</code>方法建立新连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createNewConnection(mZygoteSocket.accept(), abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了<code>mZygoteSocket.accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LocalSocket <span class="title">accept</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LocalSocketImpl acceptedImpl = <span class="keyword">new</span> LocalSocketImpl();</span><br><span class="line"></span><br><span class="line">    impl.accept(acceptedImpl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LocalSocket.createLocalSocketForAccept(acceptedImpl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个<code>LocalSocketImpl</code>(client socket) 实例，然后调用<code>LocalSocketImpl</code>(zygote socket) 的<code>accept</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(LocalSocketImpl s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"socket not created"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s.fd = Os.accept(fd, <span class="keyword">null</span> <span class="comment">/* address */</span>);</span><br><span class="line">        s.mFdCreatedInternally = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowAsIOException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了Linux的accept函数，接受建立连接，并返回了一个新的client socket fd，将<code>LocalSocketImpl</code>中的fd变量设置为这个fd，接着调用<code>LocalSocket.createLocalSocketForAccept</code>将<code>LocalSocketImpl</code>包装成<code>LocalSocket</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LocalSocket <span class="title">createLocalSocketForAccept</span><span class="params">(LocalSocketImpl impl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createConnectedLocalSocket(impl, SOCKET_UNKNOWN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LocalSocket <span class="title">createConnectedLocalSocket</span><span class="params">(LocalSocketImpl impl, <span class="keyword">int</span> sockType)</span> </span>&#123;</span><br><span class="line">    LocalSocket socket = <span class="keyword">new</span> LocalSocket(impl, sockType);</span><br><span class="line">    socket.isConnected = <span class="keyword">true</span>;</span><br><span class="line">    socket.isBound = <span class="keyword">true</span>;</span><br><span class="line">    socket.implCreated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用这个<code>LocalSocket</code>创建了一个<code>ZygoteConnection</code>包装socket连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ZygoteConnection <span class="title">createNewConnection</span><span class="params">(LocalSocket socket, String abiList)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(socket, abiList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下构造方法做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZygoteConnection(LocalSocket socket, String abiList) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    mSocket = socket;</span><br><span class="line">    <span class="keyword">this</span>.abiList = abiList;</span><br><span class="line"></span><br><span class="line">    mSocketOutStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">    mSocketReader =</span><br><span class="line">            <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                    <span class="keyword">new</span> InputStreamReader(socket.getInputStream()), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line">    ...</span><br><span class="line">    isEof = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开了client socket的输入输出流，准备读写数据了</p>
<p>然后将这个连接和fd分别添加进<code>peers</code>和<code>socketFDs</code></p>
<h3 id="执行client-socket命令"><a href="#执行client-socket命令" class="headerlink" title="执行client socket命令"></a>执行client socket命令</h3><p>在第二次循环中<code>pollFDs</code>数组中便包括了新建立连接的client socket了，这时调用<code>Os.poll</code>，可以获得到这个client socket的可读事件，此时调用<code>connection.processOneCommand</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    String[] args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取从client socket传来的参数</span></span><br><span class="line">        args = Zygote.readArgumentList(mSocketReader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"IOException on command socket"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    ZygoteArguments parsedArgs = <span class="keyword">new</span> ZygoteArguments(args);</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//一系列参数校验工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, parsedArgs.mGids,</span><br><span class="line">            parsedArgs.mRuntimeFlags, rlimits, parsedArgs.mMountExternal, parsedArgs.mSeInfo,</span><br><span class="line">            parsedArgs.mNiceName, fdsToClose, fdsToIgnore, parsedArgs.mStartChildZygote,</span><br><span class="line">            parsedArgs.mInstructionSet, parsedArgs.mAppDataDir, parsedArgs.mIsTopApp,</span><br><span class="line">            parsedArgs.mPkgDataInfoList, parsedArgs.mWhitelistedDataInfoList,</span><br><span class="line">            parsedArgs.mBindMountAppDataDirs, parsedArgs.mBindMountAppStorageDirs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">//子进程中</span></span><br><span class="line">            <span class="comment">//设置mIsForkChild = true</span></span><br><span class="line">            zygoteServer.setForkChild();</span><br><span class="line">            <span class="comment">//子进程中关闭fork复制来的zygote socket</span></span><br><span class="line">            zygoteServer.closeServerSocket();</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> handleChildProc(parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程中</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">            handleParentProc(pid, serverPipeFd);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动APP进程"><a href="#启动APP进程" class="headerlink" title="启动APP进程"></a>启动APP进程</h1><p>首先读取从client socket传来的参数，然后校验这些参数，完毕后调用<code>Zygote.forkAndSpecialize</code>方法fork出子进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> runtimeFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] fdsToIgnore, <span class="keyword">boolean</span> startChildZygote, String instructionSet, String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isTopApp, String[] pkgDataInfoList, String[] whitelistedDataInfoList,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> bindMountAppDataDirs, <span class="keyword">boolean</span> bindMountAppStorageDirs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//停止其他线程</span></span><br><span class="line">    ZygoteHooks.preFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fork进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">            uid, gid, gids, runtimeFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">            fdsToIgnore, startChildZygote, instructionSet, appDataDir, isTopApp,</span><br><span class="line">            pkgDataInfoList, whitelistedDataInfoList, bindMountAppDataDirs,</span><br><span class="line">            bindMountAppStorageDirs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//恢复其他线程</span></span><br><span class="line">    ZygoteHooks.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程启动了4个线程：</p>
<ul>
<li>HeapTaskDaemon</li>
<li>ReferenceQueueDaemon</li>
<li>FinalizerDaemon</li>
<li>FinalizerWatchdogDaemon</li>
</ul>
<p>之前上面也分析过了多线程对fork会产生影响，所以这里先把其他线程停了，等fork完了再重新启动</p>
<p>然后执行native函数<code>nativeForkAndSpecialize</code>，路径为<code>frameworks/base/core/jni/com_android_internal_os_Zygote.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint mount_external, jstring se_info, jstring nice_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jintArray managed_fds_to_close, jintArray managed_fds_to_ignore, jboolean is_child_zygote,</span></span></span><br><span class="line"><span class="function"><span class="params">        jstring instruction_set, jstring app_data_dir, jboolean is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobjectArray pkg_data_info_list, jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean mount_data_dirs, jboolean mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pid_t</span> pid = ForkCommon(env, <span class="literal">false</span>, fds_to_close, fds_to_ignore, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      SpecializeCommon(env, uid, gid, gids, runtime_flags, rlimits,</span><br><span class="line">                       capabilities, capabilities,</span><br><span class="line">                       mount_external, se_info, nice_name, <span class="literal">false</span>,</span><br><span class="line">                       is_child_zygote == JNI_TRUE, instruction_set, app_data_dir,</span><br><span class="line">                       is_top_app == JNI_TRUE, pkg_data_info_list,</span><br><span class="line">                       whitelisted_data_info_list,</span><br><span class="line">                       mount_data_dirs == JNI_TRUE,</span><br><span class="line">                       mount_storage_dirs == JNI_TRUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>ForkCommon</code>，再在子进程调用<code>SpecializeCommon</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ForkCommon</span><span class="params">(JNIEnv* env, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_close,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; fds_to_ignore,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> is_priority_fork)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//设置子进程信号处理函数</span></span><br><span class="line">  SetSignalHandlers();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//fork前先阻塞SIGCHLD信号</span></span><br><span class="line">  BlockSignal(SIGCHLD, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//执行fork</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//恢复SIGCHLD信号</span></span><br><span class="line">  UnblockSignal(SIGCHLD, fail_fn);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpecializeCommon</span><span class="params">(JNIEnv* env, <span class="keyword">uid_t</span> uid, <span class="keyword">gid_t</span> gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint runtime_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jlong permitted_capabilities, jlong effective_capabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jint mount_external, jstring managed_se_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_nice_name, <span class="keyword">bool</span> is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> is_child_zygote, jstring managed_instruction_set,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jstring managed_app_data_dir, <span class="keyword">bool</span> is_top_app,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray pkg_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             jobjectArray whitelisted_data_info_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">bool</span> mount_data_dirs, <span class="keyword">bool</span> mount_storage_dirs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* process_name = is_system_server ? <span class="string">"system_server"</span> : <span class="string">"zygote"</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//创建进程组</span></span><br><span class="line">  <span class="keyword">if</span> (!is_system_server &amp;&amp; getuid() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">      ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, <span class="comment">/* pid= */</span> <span class="number">0</span>, strerror(-rc));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置GroupId</span></span><br><span class="line">  SetGids(env, gids, is_child_zygote, fail_fn);</span><br><span class="line">  <span class="comment">//设置资源Limit</span></span><br><span class="line">  SetRLimits(env, rlimits, fail_fn);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置调度策略</span></span><br><span class="line">  SetSchedulerPolicy(fail_fn, is_top_app);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//设置线程名</span></span><br><span class="line">  <span class="keyword">if</span> (nice_name.has_value()) &#123;</span><br><span class="line">    SetThreadName(nice_name.value());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_system_server) &#123;</span><br><span class="line">    SetThreadName(<span class="string">"system_server"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//子进程中不再处理SIGCHLD信号</span></span><br><span class="line">  UnsetChldSignalHandler();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_child_zygote) &#123;</span><br><span class="line">      initUnsolSocketToSystemServer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用Zygote.callPostForkChildHooks方法</span></span><br><span class="line">  env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, runtime_flags,</span><br><span class="line">                            is_system_server, is_child_zygote, managed_instruction_set);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认进程优先级</span></span><br><span class="line">  setpriority(PRIO_PROCESS, <span class="number">0</span>, PROCESS_PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">    fail_fn(<span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程创建完成后，<code>ZygoteConnection</code>在子进程中会返回<code>handleChildProc</code>，在父进程中会返回<code>null</code></p>
<p>在<code>ZygoteServer</code>中做了判断，如果为子进程且command不为null，返回common到<code>ZygoteInit</code>，如果是父进程，继续socket poll循环</p>
<p>在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>（对应<code>ZygoteServer</code>中的<code>command</code>）不为<code>null</code>，则执行这个<code>Runnable</code></p>
<p>我们看一下<code>handleChildProc</code>做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(ZygoteArguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在子进程中关闭发起启动App请求的client socket</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    Zygote.setAppProcessName(parsedArgs, TAG);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.mInvokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//和进程内存泄露或溢出有关？</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.mInvokeWith,</span><br><span class="line">                parsedArgs.mNiceName, parsedArgs.mTargetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.mRemainingArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should not get here.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"WrapperInit.execApplication unexpectedly returned"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">            <span class="comment">//根据参数，执行这个方法</span></span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mDisabledCompatChanges,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.mTargetSdkVersion,</span><br><span class="line">                    parsedArgs.mRemainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>ZygoteInit.zygoteInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//重定向Log</span></span><br><span class="line">    RuntimeInit.redirectLogStreams();</span><br><span class="line">    <span class="comment">//通用初始化</span></span><br><span class="line">    RuntimeInit.commonInit();</span><br><span class="line">    <span class="comment">//之前有提到，开启binder线程池</span></span><br><span class="line">    ZygoteInit.nativeZygoteInit();</span><br><span class="line">    <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, disabledCompatChanges, argv,</span><br><span class="line">            classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RuntimeInit</code>的路径为<code>frameworks/base/core/java/com/android/internal/os/RuntimeInit.java</code>，先执行通用初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置默认线程异常处理器</span></span><br><span class="line">    LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler();</span><br><span class="line">    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> KillApplicationHandler(loggingHandler));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    RuntimeHooks.setTimeZoneIdSupplier(() -&gt; SystemProperties.get(<span class="string">"persist.sys.timezone"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置Log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置网络UA信息</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">    ...</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行<code>RuntimeInit.applicationInit</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, <span class="keyword">long</span>[] disabledCompatChanges,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果应用程序调用System.exit()，则立即终止该进程，不运行任何hook函数</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//设置虚拟机参数</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line">    VMRuntime.getRuntime().setDisabledCompatChanges(disabledCompatChanges);</span><br><span class="line">    <span class="comment">//解析参数</span></span><br><span class="line">    <span class="keyword">final</span> Arguments args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查找startClass中的main方法</span></span><br><span class="line">    <span class="keyword">return</span> findStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的startClass为<code>android.app.ActivityThread</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Runnable <span class="title">findStaticMain</span><span class="params">(String className, String[] argv,</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[]<span class="class">.<span class="keyword">class</span> &#125;)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This throw gets caught in ZygoteInit.main(), which responds</span></span><br><span class="line"><span class="comment">        * by invoking the exception's run() method. This arrangement</span></span><br><span class="line"><span class="comment">        * clears up all the stack frames that were required in setting</span></span><br><span class="line"><span class="comment">        * up the process.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了Java中的反射，找到了<code>ActivityThread</code>中对应的<code>main</code>方法，并用其创建了一个<code>Runnable</code>对象<code>MethodAndArgsCaller</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行ActivityThread.main方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前说了，在<code>ZygoteInit.runSelectLoop</code>后，如果返回值<code>caller</code>不为<code>null</code>，则执行这个<code>Runnable</code>，即执行<code>MethodAndArgsCaller</code>的<code>run</code>方法，反射调用<code>ActivityThread.main</code>方法</p>
<h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>至此，Zygote进程部分的分析就到此为止了，后面fork出App进程那段讲的很粗糙，后面写到App启动那块的时候，我会重新梳理一遍这里的逻辑，补充上去</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2022/01/04/android/aosp/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-init%E8%BF%9B%E7%A8%8B/">Android源码分析 - init进程</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-01-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81/">Android源码</a><span class="article-meta__link">-</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/init%E8%BF%9B%E7%A8%8B/">init进程</a></span><div class="content"><h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p><strong>本篇以android-11.0.0_r25作为基础解析</strong></p>
<p>PC启动会通过BIOS引导，从0x7c00处找到以0xaa55为结尾的引导程序启动。而Android通常使用在移动设备上，没有PC的BIOS，取而代之的是BootLoader。</p>
<h1 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h1><p>在CPU上电复位完成后，会从一个固定的地址加载一段程序，即BootLoader，不同的CPU可能这个地址不同。BootLoader是一段引导程序，其中最为常见的为U-boot，它一般会先检测用户是否按下某些特别按键，这些特别按键是uboot在编译时预先被约定好的，用于进入调试模式。如果用户没有按这些特别的按键，则uboot会从NAND Flash中装载Linux内核，装载的地址是在编译uboot时预先约定好的。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="idle"><a href="#idle" class="headerlink" title="idle"></a>idle</h2><p>Linux内核启动后，便会创建第一个进程idle。idle进程是Linux中的第一个进程，pid为0，是唯一一个没有通过fork产生的进程，它的优先级非常低，用于CPU没有任务的时候进行空转。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>init进程由idle进程创建，是Linux系统的第一个用户进程，pid为1，是系统所有用户进程的直接或间接父进程，本篇重点讲的就是它。</p>
<h2 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h2><p>kthreadd进程同样由idle进程创建，pid为2，它始终运行在内核空间，负责所有内核线程的调度与管理。</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><p>Android的init进程代码在<code>system/core/init/main.cpp</code>中，以main方法作为入口，分为几个阶段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"selinux_setup"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"second_stage"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> FirstStageMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的ueventd和subcontext，都是在各自守护进程中执行的，不在init进程中执行，这里就不多介绍了</p>
<h2 id="FirstStageMain"><a href="#FirstStageMain" class="headerlink" title="FirstStageMain"></a>FirstStageMain</h2><p>默认不加任何参数启动init的话，便会开始init第一阶段，进入到FirstStageMain函数中，代码在<code>system/core/init/first_stage_init.cpp</code>中</p>
<h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>文档：<a href="https://man7.org/linux/man-pages/man2/umask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/umask.2.html</a></p>
<p>原型：<code>mode_t umask(mode_t mask);</code></p>
<p>这个方法是用来设置创建目录或文件时所应该赋予权限的掩码</p>
<p>Linux中，文件默认最大权限是666，目录最大权限是777，当创建目录时，假设掩码为022，那赋予它的权限为（777 &amp; ~022）= 755</p>
<p>在执行init第一阶段时，先执行umask(0)，使创建的目录或文件的默认权限为最高</p>
<h3 id="创建目录、设备节点，挂载"><a href="#创建目录、设备节点，挂载" class="headerlink" title="创建目录、设备节点，挂载"></a>创建目录、设备节点，挂载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKCALL(x) \</span></span><br><span class="line">    <span class="keyword">if</span> ((x) != <span class="number">0</span>) errors.emplace_back(#x <span class="string">" failed"</span>, errno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear the umask.</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CHECKCALL(clearenv());</span><br><span class="line">    CHECKCALL(setenv(<span class="string">"PATH"</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    CHECKCALL(mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    CHECKCALL(chmod(<span class="string">"/proc/cmdline"</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmdline;</span><br><span class="line">    android::base::ReadFileToString(<span class="string">"/proc/cmdline"</span>, &amp;cmdline);</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    CHECKCALL(setgroups(arraysize(groups), groups));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"selinuxfs"</span>, <span class="string">"/sys/fs/selinux"</span>, <span class="string">"selinuxfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/kmsg"</span>, S_IFCHR | <span class="number">0600</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(WORLD_WRITABLE_KMSG)</span> </span>&#123;</span><br><span class="line">        CHECKCALL(mknod(<span class="string">"/dev/kmsg_debug"</span>, S_IFCHR | <span class="number">0622</span>, makedev(<span class="number">1</span>, <span class="number">11</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/random"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">8</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/urandom"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">9</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/ptmx"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">5</span>, <span class="number">2</span>)));</span><br><span class="line">    CHECKCALL(mknod(<span class="string">"/dev/null"</span>, S_IFCHR | <span class="number">0666</span>, makedev(<span class="number">1</span>, <span class="number">3</span>)));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/mnt"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=1000"</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/vendor"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(<span class="built_in">mkdir</span>(<span class="string">"/mnt/product"</span>, <span class="number">0755</span>));</span><br><span class="line">    CHECKCALL(mount(<span class="string">"tmpfs"</span>, <span class="string">"/debug_ramdisk"</span>, <span class="string">"tmpfs"</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,</span><br><span class="line">                    <span class="string">"mode=0755,uid=0,gid=0"</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CHECKCALL</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化日志"><a href="#初始化日志" class="headerlink" title="初始化日志"></a>初始化日志</h3><h4 id="SetStdioToDevNull"><a href="#SetStdioToDevNull" class="headerlink" title="SetStdioToDevNull"></a>SetStdioToDevNull</h4><p>由于Linux内核打开了/dev/console作为标准输入输出流（stdin/stdout/stderr）的文件描述符，而init进程在用户空间，无权访问/dev/console，后续如果执行printf的话可能会导致错误，所以先调用<code>SetStdioToDevNull</code>函数来将标准输入输出流（stdin/stdout/stderr）用/dev/null文件描述符替换</p>
<p>/dev/null被称为空设备，是一个特殊的设备文件，它会丢弃一切写入其中的数据，读取它会立即得到一个EOF</p>
<h4 id="InitKernelLogging"><a href="#InitKernelLogging" class="headerlink" title="InitKernelLogging"></a>InitKernelLogging</h4><p>接着调用<code>InitKernelLogging</code>函数，初始化了一个简单的kernel日志系统</p>
<h3 id="创建设备，挂载分区"><a href="#创建设备，挂载分区" class="headerlink" title="创建设备，挂载分区"></a>创建设备，挂载分区</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> want_console = ALLOW_FIRST_STAGE_CONSOLE ? FirstStageConsole(cmdline) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LoadKernelModules(IsRecoveryMode() &amp;&amp; !ForceNormalBoot(cmdline), want_console)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (want_console != FirstStageConsoleParam::DISABLED) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"Failed to load kernel modules, starting console"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Failed to load kernel modules"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (want_console == FirstStageConsoleParam::CONSOLE_ON_FAILURE) &#123;</span><br><span class="line">        StartConsole();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ForceNormalBoot(cmdline)) &#123;</span><br><span class="line">        <span class="built_in">mkdir</span>(<span class="string">"/first_stage_ramdisk"</span>, <span class="number">0755</span>);</span><br><span class="line">        <span class="comment">// SwitchRoot() must be called with a mount point as the target, so we bind mount the</span></span><br><span class="line">        <span class="comment">// target directory to itself here.</span></span><br><span class="line">        <span class="keyword">if</span> (mount(<span class="string">"/first_stage_ramdisk"</span>, <span class="string">"/first_stage_ramdisk"</span>, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; <span class="string">"Could not bind mount /first_stage_ramdisk to itself"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SwitchRoot(<span class="string">"/first_stage_ramdisk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!DoFirstStageMount()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to mount required partitions early ..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>至此，第一阶段的init结束，通过execv函数带参执行init文件，进入<code>SetupSelinux</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"selinux_setup"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> fd = <span class="built_in">open</span>(<span class="string">"/dev/kmsg"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line">dup2(fd, STDOUT_FILENO);</span><br><span class="line">dup2(fd, STDERR_FILENO);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line">execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line"><span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line"><span class="comment">// panic and never fall through this conditional.</span></span><br><span class="line">PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br></pre></td></tr></table></figure>

<h4 id="exec系列函数"><a href="#exec系列函数" class="headerlink" title="exec系列函数"></a>exec系列函数</h4><p>用exec系列函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。</p>
<p>这里在末尾直接打log是因为，exec系列函数如果执行正常是不会返回的，所以只要执行到下面就代表exec执行出错了</p>
<h2 id="SetupSelinux"><a href="#SetupSelinux" class="headerlink" title="SetupSelinux"></a>SetupSelinux</h2><p>启动Selinux安全机制，初始化selinux，加载SELinux规则，配置SELinux相关log输出，并启动第二阶段：<code>SecondStageMain</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        InstallRebootSignalHandlers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boot_clock::time_point start_time = boot_clock::now();</span><br><span class="line"></span><br><span class="line">    MountMissingSystemPartitions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up SELinux, loading the SELinux policy.</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelinuxInitialize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're in the kernel domain and want to transition to the init domain.  File systems that</span></span><br><span class="line">    <span class="comment">// store SELabels in their xattrs, such as ext4 do not need an explicit restorecon here,</span></span><br><span class="line">    <span class="comment">// but other file systems do.  In particular, this is needed for ramdisks such as the</span></span><br><span class="line">    <span class="comment">// recovery image for A/B devices.</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_restorecon(<span class="string">"/system/bin/init"</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"restorecon failed of /system/bin/init failed"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setenv(kEnvSelinuxStartedAt, <span class="built_in">std</span>::to_string(start_time.time_since_epoch().count()).c_str(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">"/system/bin/init"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">"second_stage"</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    execv(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    PLOG(FATAL) &lt;&lt; <span class="string">"execv(\""</span> &lt;&lt; path &lt;&lt; <span class="string">"\") failed"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecondStageMain"><a href="#SecondStageMain" class="headerlink" title="SecondStageMain"></a>SecondStageMain</h2><p>使用<code>second_stage</code>参数启动init的话，便会开始init第二阶段，进入到<code>SecondStageMain</code>函数中，代码在<code>system/core/init/init.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//和第一阶段一样，初始化日志</span></span><br><span class="line">    SetStdioToDevNull(argv);</span><br><span class="line">    InitKernelLogging(argv);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"init second stage started!"</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set init and its forked children's oom_adj.</span></span><br><span class="line">    <span class="comment">//设置init进程和以后fork出来的进程的OOM等级，这里的值为-1000，保证进程不会因为OOM被杀死</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                WriteFile(<span class="string">"/proc/1/oom_score_adj"</span>, StringPrintf(<span class="string">"%d"</span>, DEFAULT_OOM_SCORE_ADJUST));</span><br><span class="line">        !result.ok()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Unable to write "</span> &lt;&lt; DEFAULT_OOM_SCORE_ADJUST</span><br><span class="line">                   &lt;&lt; <span class="string">" to /proc/1/oom_score_adj: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    <span class="comment">//设置一个标记，代表正在启动过程中</span></span><br><span class="line">    <span class="built_in">close</span>(<span class="built_in">open</span>(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化系统属性</span></span><br><span class="line">    PropertyInit();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Mount extra filesystems required during second stage init</span></span><br><span class="line">    <span class="comment">//挂载额外的文件系统</span></span><br><span class="line">    MountExtraFilesystems();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now set up SELinux for second stage.</span></span><br><span class="line">    <span class="comment">//设置SELinux</span></span><br><span class="line">    SelinuxSetupKernelLogging();</span><br><span class="line">    SelabelInitialize();</span><br><span class="line">    SelinuxRestoreContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用epoll，注册信号处理函数，守护进程服务</span></span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">    <span class="comment">//启动系统属性服务</span></span><br><span class="line">    StartPropertyService(&amp;property_fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//解析init.rc脚本</span></span><br><span class="line">    ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::GetInstance();</span><br><span class="line"></span><br><span class="line">    LoadBootScripts(am, sm);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构建了一些Action，Trigger等事件对象加入事件队列中</span></span><br><span class="line">    am.QueueBuiltinAction(SetupCgroupsAction, <span class="string">"SetupCgroups"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetKptrRestrictAction, <span class="string">"SetKptrRestrict"</span>);</span><br><span class="line">    am.QueueBuiltinAction(TestPerfEventSelinuxAction, <span class="string">"TestPerfEventSelinux"</span>);</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">    am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line">    <span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line">    am.QueueBuiltinAction(SetMmapRndBitsAction, <span class="string">"SetMmapRndBits"</span>);</span><br><span class="line">    Keychords keychords;</span><br><span class="line">    am.QueueBuiltinAction(</span><br><span class="line">            [&amp;epoll, &amp;keychords](<span class="keyword">const</span> BuiltinArguments&amp; args) -&gt; Result&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; svc : ServiceList::GetInstance()) &#123;</span><br><span class="line">                    keychords.Register(svc-&gt;keycodes());</span><br><span class="line">                &#125;</span><br><span class="line">                keychords.Start(&amp;epoll, HandleKeychord);</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"KeychordInit"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">    am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line">    <span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">    am.QueueBuiltinAction(MixHwrngIntoLinuxRngAction, <span class="string">"MixHwrngIntoLinuxRng"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootmode = GetProperty(<span class="string">"ro.bootmode"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环，等待事件处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Linux-OOM-Killer机制"><a href="#Linux-OOM-Killer机制" class="headerlink" title="Linux OOM Killer机制"></a>Linux OOM Killer机制</h3><p>Linux下有一种 OOM KILLER 的机制，它会在系统内存耗尽的情况下，启用自己算法有选择性的杀掉一些进程，这个算法和三个值有关：</p>
<ul>
<li>/proc/PID/oom_score ,OOM 最终得分，值越大越有可能被杀掉</li>
<li>/proc/PID/oom_score_adj ，取值范围为-1000到1000，计算oom_score时会加上该参数</li>
<li>/proc/PID/oom_adj ，取值是-17到+15，该参数主要是为兼容旧版内核</li>
</ul>
<p>在init过程中，代码设置了init进程和以后fork出来的进程的OOM等级，这里的值为-1000，设置为这个值就可以保证进程永远不会因为OOM被杀死</p>
<h3 id="解析init-rc脚本"><a href="#解析init-rc脚本" class="headerlink" title="解析init.rc脚本"></a>解析init.rc脚本</h3><h4 id="Android-Init-Language"><a href="#Android-Init-Language" class="headerlink" title="Android Init Language"></a>Android Init Language</h4><p>rc文件，是用<code>Android Init Language</code>编写的特殊文件。用这种语法编写的文件，统一用”.rc”后缀</p>
<p>它的语法说明可以在aosp源码<code>system/core/init/README.md</code>中找到，这里就简单说明一下语法规则</p>
<h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h5><p><code>Actions</code>是一系列命令的开始，一个<code>Action</code>会有一个触发器，用于确定<code>Action</code>何时执行。当一个与<code>Action</code>的触发器匹配的事件发生时，该动作被添加到待执行队列的尾部</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]* </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt; </span><br><span class="line">    &lt;command&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Triggers（触发器）"><a href="#Triggers（触发器）" class="headerlink" title="Triggers（触发器）"></a>Triggers（触发器）</h5><p>触发器作用于<code>Actions</code>，可用于匹配某些类型的事件，并用于导致操作发生</p>
<h5 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h5><p><code>Commands</code>就是一个个命令的集合了</p>
<p><code>Action</code>, <code>Triggers</code>, <code>Commands</code>共同组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state&#x3D;unencrypted </span><br><span class="line">    # A&#x2F;B update verifier that marks a successful boot. </span><br><span class="line">    exec_start update_verifier_nonencrypted </span><br><span class="line">    start statsd </span><br><span class="line">    start netd </span><br><span class="line">    start zygote </span><br><span class="line">    start zygote_secondary</span><br></pre></td></tr></table></figure>

<h5 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h5><p><code>Services</code>是对一些程序的定义，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    &lt;option&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>name：定义的服务名</li>
<li>pathname：这个程序的路径</li>
<li>argument：程序运行的参数</li>
<li>option：服务选项，后文将介绍</li>
</ul>
<h5 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h5><p><code>Options</code>是对<code>Services</code>的修饰，它们影响着服务运行的方式和时间</p>
<p><code>Services</code>, <code>Options</code>组成了一个单元，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service zygote &#x2F;system&#x2F;bin&#x2F;app_process64 -Xzygote &#x2F;system&#x2F;bin --zygote --start-system-server --socket-name&#x3D;zygote</span><br><span class="line">    class main</span><br><span class="line">    priority -20</span><br><span class="line">    user root</span><br><span class="line">    group root readproc reserved_disk</span><br><span class="line">    socket zygote stream 660 root system</span><br><span class="line">    socket usap_pool_primary stream 660 root system</span><br><span class="line">    onrestart exec_background - system system -- &#x2F;system&#x2F;bin&#x2F;vdc volume abort_fuse</span><br><span class="line">    onrestart write &#x2F;sys&#x2F;power&#x2F;state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    onrestart restart wificond</span><br><span class="line">    task_profiles ProcessCapacityHigh MaxPerformance</span><br></pre></td></tr></table></figure>

<h5 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h5><p>导入其他的rc文件或目录解析，如果path是一个目录，目录中的每个文件都被解析为一个rc文件。它不是递归的，嵌套的目录将不会被解析。</p>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &lt;path&gt;</span><br></pre></td></tr></table></figure>

<p><code>Imports</code>的内容会放到最后解析</p>
<p>上文所述的<code>Commands</code>，<code>Options</code>等具体命令，可以网上搜索一下，或者自己看<code>system/core/init/README.md</code></p>
<p><code>Commands</code>的定义可以在<code>system/core/init/builtins.cpp</code>中找到</p>
<p><code>Options</code>的定义可以在<code>system/core/init/service_parser.cpp</code>中找到</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = CreateParser(action_manager, service_list);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bootscript = GetProperty(<span class="string">"ro.boot.init_rc"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.empty()) &#123;</span><br><span class="line">        parser.ParseConfig(<span class="string">"/system/etc/init/hw/init.rc"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/system/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/system/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// late_import is available only in Q and earlier release. As we don't</span></span><br><span class="line">        <span class="comment">// have system_ext in those versions, skip late_import for system_ext.</span></span><br><span class="line">        parser.ParseConfig(<span class="string">"/system_ext/etc/init"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/product/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/product/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/odm/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/odm/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.ParseConfig(<span class="string">"/vendor/etc/init"</span>)) &#123;</span><br><span class="line">            late_import_paths.emplace_back(<span class="string">"/vendor/etc/init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.ParseConfig(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会从这些地方寻找rc文件解析，<code>/system/etc/init/hw/init.rc</code>是主rc文件，剩下的目录，如果system分区尚未挂载的话，就把它们加入到<code>late_import_paths</code>中，等到后面<code>mount_all</code>时再加载</p>
<p>主rc文件在编译前的位置为<code>system/core/rootdir/init.rc</code></p>
<p>简单分析一下：</p>
<p>首先，以<code>ActionManager</code>和<code>ServiceList</code>作为参数创建了一个Parser解析器，解析后的结果会存放在<code>ActionManager</code>和<code>ServiceList</code>中，这里的两个传进来的参数都是单例模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Parser <span class="title">CreateParser</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser;</span><br><span class="line"></span><br><span class="line">    parser.AddSectionParser(<span class="string">"service"</span>, <span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;(</span><br><span class="line">                                               &amp;service_list, GetSubcontext(), <span class="built_in">std</span>::nullopt));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;(&amp;action_manager, GetSubcontext()));</span><br><span class="line">    parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;(&amp;parser));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建了一个<code>Parser</code>对象，然后往里面添加了<code>ServiceParser</code>、<code>ActionParser</code>以及<code>ImportParser</code>，这三个类都是继承自<code>ServiceParser</code>，这里的<code>std::make_unique</code>是new了一个对象，并用其原始指针构造出了一个智能指针</p>
<p>接着走到<code>Parser::ParseConfig</code>方法中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfig</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断是否是目录，如果是目录，就把目录中的所有文件加入容器中排序后依次解析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigDir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing directory "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    std::unique_ptr&lt;DIR, decltype(&amp;closedir)&gt; config_dir(opendir(path.c_str()), closedir);</span><br><span class="line">    <span class="keyword">if</span> (!config_dir) &#123;</span><br><span class="line">        PLOG(INFO) &lt;&lt; <span class="string">"Could not import directory '"</span> &lt;&lt; path &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dirent* current_file;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files;</span><br><span class="line">    <span class="keyword">while</span> ((current_file = readdir(config_dir.<span class="built_in">get</span>()))) &#123;</span><br><span class="line">        <span class="comment">// Ignore directories and only process regular files.</span></span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> current_path =</span><br><span class="line">                android::base::StringPrintf(<span class="string">"%s/%s"</span>, path.c_str(), current_file-&gt;d_name);</span><br><span class="line">            files.emplace_back(current_path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sort first so we load files in a consistent order (bug 31996208)</span></span><br><span class="line">    <span class="built_in">std</span>::sort(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ParseConfigFile(file)) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"could not import file '"</span> &lt;&lt; file &lt;&lt; <span class="string">"'"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终都调用了<code>Parser::ParseConfigFile</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing file "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="keyword">auto</span> config_contents = ReadFile(path);</span><br><span class="line">    <span class="keyword">if</span> (!config_contents.ok()) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Unable to read config file '"</span> &lt;&lt; path &lt;&lt; <span class="string">"': "</span> &lt;&lt; config_contents.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; <span class="string">"(Parsing "</span> &lt;&lt; path &lt;&lt; <span class="string">" took "</span> &lt;&lt; t &lt;&lt; <span class="string">".)"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从文件中读取出字符串，并继续调用<code>Parser::ParseData</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parser::ParseData</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="built_in">std</span>::<span class="built_in">string</span>* data)</span> </span>&#123;</span><br><span class="line">    data-&gt;push_back(<span class="string">'\n'</span>);  <span class="comment">// <span class="doctag">TODO:</span> fix tokenizer</span></span><br><span class="line">    data-&gt;push_back(<span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    parse_state state;</span><br><span class="line">    state.<span class="built_in">line</span> = <span class="number">0</span>;</span><br><span class="line">    state.ptr = data-&gt;data();</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    SectionParser* section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> section_start_line = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we encounter a bad section start, there is no valid parser object to parse the subsequent</span></span><br><span class="line">    <span class="comment">// sections, so we must suppress errors until the next valid section is found.</span></span><br><span class="line">    <span class="keyword">bool</span> bad_section_found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end_section = [&amp;] &#123;</span><br><span class="line">        bad_section_found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (section_parser == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;EndSection(); !result.ok()) &#123;</span><br><span class="line">            parse_error_count_++;</span><br><span class="line">            LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; section_start_line &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">        section_start_line = <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">            <span class="keyword">case</span> T_EOF:</span><br><span class="line">                end_section();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [section_name, section_parser] : section_parsers_) &#123;</span><br><span class="line">                    section_parser-&gt;EndFile();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> T_NEWLINE: &#123;</span><br><span class="line">                state.<span class="built_in">line</span>++;</span><br><span class="line">                <span class="keyword">if</span> (args.empty()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// If we have a line matching a prefix we recognize, call its callback and unset any</span></span><br><span class="line">                <span class="comment">// current section parsers.  This is meant for /sys/ and /dev/ line entries for</span></span><br><span class="line">                <span class="comment">// uevent.</span></span><br><span class="line">                <span class="keyword">auto</span> line_callback = <span class="built_in">std</span>::find_if(</span><br><span class="line">                    line_callbacks_.<span class="built_in">begin</span>(), line_callbacks_.<span class="built_in">end</span>(),</span><br><span class="line">                    [&amp;args](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c) &#123; <span class="keyword">return</span> android::base::StartsWith(args[<span class="number">0</span>], c.first); &#125;);</span><br><span class="line">                <span class="keyword">if</span> (line_callback != line_callbacks_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = line_callback-&gt;second(<span class="built_in">std</span>::<span class="built_in">move</span>(args)); !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">                    end_section();</span><br><span class="line">                    section_parser = section_parsers_[args[<span class="number">0</span>]].<span class="built_in">get</span>();</span><br><span class="line">                    section_start_line = state.<span class="built_in">line</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result =</span><br><span class="line">                                section_parser-&gt;ParseSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), filename, state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                        section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">                        bad_section_found = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">auto</span> result = section_parser-&gt;ParseLineSection(<span class="built_in">std</span>::<span class="built_in">move</span>(args), state.<span class="built_in">line</span>);</span><br><span class="line">                        !result.ok()) &#123;</span><br><span class="line">                        parse_error_count_++;</span><br><span class="line">                        LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span> &lt;&lt; <span class="string">": "</span> &lt;&lt; result.error();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bad_section_found) &#123;</span><br><span class="line">                    parse_error_count_++;</span><br><span class="line">                    LOG(ERROR) &lt;&lt; filename &lt;&lt; <span class="string">": "</span> &lt;&lt; state.<span class="built_in">line</span></span><br><span class="line">                               &lt;&lt; <span class="string">": Invalid section keyword found"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                args.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> T_TEXT:</span><br><span class="line">                args.emplace_back(state.<span class="built_in">text</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里新建了一个<code>parse_state</code>结构体，用来以行为单位，分割整个文件字符串，根据分割出来的结果返回相应的TYPE，<code>Parser::ParseData</code>方法再通过TYPE来做逐行解析</p>
<p>这个结构体以及TPYE和分割分割方法的定义在<code>system/core/init/tokenizer.h</code>中，在<code>system/core/init/tokenizer.cpp</code>中实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_token</span><span class="params">(struct parse_state *state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *x = state-&gt;ptr;</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;nexttoken) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = state-&gt;nexttoken;</span><br><span class="line">        state-&gt;nexttoken = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_EOF;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            state-&gt;ptr = x;</span><br><span class="line">            <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'#'</span>:</span><br><span class="line">            <span class="keyword">while</span> (*x &amp;&amp; (*x != <span class="string">'\n'</span>)) x++;</span><br><span class="line">            <span class="keyword">if</span> (*x == <span class="string">'\n'</span>) &#123;</span><br><span class="line">                state-&gt;ptr = x+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> T_NEWLINE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state-&gt;ptr = x;</span><br><span class="line">                <span class="keyword">return</span> T_EOF;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">text</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">textdone:</span><br><span class="line">    state-&gt;ptr = x;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T_TEXT;</span><br><span class="line"><span class="built_in">text</span>:</span><br><span class="line">    state-&gt;<span class="built_in">text</span> = s = x;</span><br><span class="line">textresume:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">            state-&gt;nexttoken = T_NEWLINE;</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">goto</span> textdone;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        <span class="comment">/* unterminated quoted thing */</span></span><br><span class="line">                    state-&gt;ptr = x;</span><br><span class="line">                    <span class="keyword">return</span> T_EOF;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">goto</span> textresume;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    *s++ = *x++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">            x++;</span><br><span class="line">            <span class="keyword">switch</span> (*x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">goto</span> textdone;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'n'</span>:</span><br><span class="line">                *s++ = <span class="string">'\n'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>:</span><br><span class="line">                *s++ = <span class="string">'\r'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                *s++ = <span class="string">'\t'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\\'</span>:</span><br><span class="line">                *s++ = <span class="string">'\\'</span>;</span><br><span class="line">                x++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\r'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;cr&gt; &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                <span class="keyword">if</span> (x[<span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">                    x++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                x++;</span><br><span class="line">                FALLTHROUGH_INTENDED;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="comment">/* \ &lt;lf&gt; -&gt; line continuation */</span></span><br><span class="line">                state-&gt;<span class="built_in">line</span>++;</span><br><span class="line">                x++;</span><br><span class="line">                    <span class="comment">/* eat any extra whitespace */</span></span><br><span class="line">                <span class="keyword">while</span>((*x == <span class="string">' '</span>) || (*x == <span class="string">'\t'</span>)) x++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">/* unknown escape -- just copy */</span></span><br><span class="line">                *s++ = *x++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            *s++ = *x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T_EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说就是先看看有没有遇到结束符（换行 \n 或者EOF \0）或者注释（#）如果遇到了就返回<code>T_NEWLINE</code>或者<code>T_EOF</code>代表这上一行结束了或者整个文件读取完了，没有遇到的话说明读取的是可解析的正文，跳到text段，将文本内容写到<code>state.text</code>中，直到碰到换行符或空格等分割标志（以空格或换行等作为分隔符，一小段一小段的进行分割），将读取到的最后一个正文的位置+1处的字符置为\0，<code>state.text</code>里的内容便称为了完整一段的内容，接着返回<code>T_TEXT</code>表示已读入一段文本</p>
<p>接着回到<code>Parser::ParseData</code>方法中，如果读到的TYPE是<code>T_TEXT</code>，就将这一段内容先添加到容器中，当读到<code>T_NEWLINE</code>时，解析之前读入的一整行内容，先用args[0]（一行的开头）去寻找我们之前添加的<code>SectionParser</code>，如果能找到，说明这一行是service、on或者import，将<code>section_parser</code>赋值为相应<code>SectionParser</code>子类的指针，调用其<code>ParseSection</code>方法解析，如果读入的一行里，不是以service、on或者import开头，并且之前定义的<code>section_parser</code>不为空指针，说明是service或者on参数的子参数，调用<code>ParseLineSection</code>方法解析子参数，并加入到父参数中。</p>
<p>最后，每次读取完都会执行<code>args.clear()</code>清楚这一行的数据，当读取到新的service、on或者import时，需要先执行<code>EndSection</code>方法，将之前解析好的结构添加到列表中</p>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>回到<code>SecondStageMain</code>中，可以看到，最后有一个死循环，用来等待事件处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// By default, sleep until something happens.</span></span><br><span class="line">        <span class="keyword">auto</span> epoll_timeout = <span class="built_in">std</span>::optional&lt;<span class="built_in">std</span>::chrono::milliseconds&gt;&#123;&#125;;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//执行从init.rc脚本解析出来的每条指令</span></span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            am.ExecuteOneCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) &#123;</span><br><span class="line">            <span class="comment">// If there's more work to do, wake up again immediately.</span></span><br><span class="line">            <span class="keyword">if</span> (am.HasMoreCommands()) epoll_timeout = <span class="number">0</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> pending_functions = epoll.Wait(epoll_timeout);</span><br><span class="line">        <span class="keyword">if</span> (!pending_functions.ok()) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; pending_functions.error();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pending_functions-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">// We always reap children before responding to the other pending functions. This is to</span></span><br><span class="line">            <span class="comment">// prevent a race where other daemons see that a service has exited and ask init to</span></span><br><span class="line">            <span class="comment">// start it again via ctl.start before init has reaped it.</span></span><br><span class="line">            <span class="comment">//处理子进程退出后的相关事项</span></span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; function : *pending_functions) &#123;</span><br><span class="line">                (*function)();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>am.ExecuteOneCommand()</code>方法便是执行从rc文件中解析出来的指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ActionManager::ExecuteOneCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> lock = <span class="built_in">std</span>::lock_guard&#123;event_queue_lock_&#125;;</span><br><span class="line">        <span class="comment">// Loop through the event queue until we have an action to execute</span></span><br><span class="line">        <span class="comment">//当前正在执行的action队列为空，但等待执行的事件队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> (current_executing_actions_.empty() &amp;&amp; !event_queue_.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">                <span class="comment">//从等待执行的事件队列头取出一个元素event， </span></span><br><span class="line">                <span class="comment">//然后调用action的CheckEvent检查此event是否匹配当前action </span></span><br><span class="line">                <span class="comment">//如果匹配，将这个action加入到正在执行的actions队列的队尾</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">std</span>::visit([&amp;action](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; event) &#123; <span class="keyword">return</span> action-&gt;CheckEvent(event); &#125;,</span><br><span class="line">                               event_queue_.front())) &#123;</span><br><span class="line">                    current_executing_actions_.emplace(action.<span class="built_in">get</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            event_queue_.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从队列头取一个action（front不会使元素出队）</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.front();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是第一次执行这个action</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = action-&gt;BuildTriggersString();</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"processing action ("</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">") from ("</span> &lt;&lt; action-&gt;filename()</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; action-&gt;<span class="built_in">line</span>() &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个current_command_是个成员变量，标志着执行到了哪一行</span></span><br><span class="line">    action-&gt;ExecuteOneCommand(current_command_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this was the last command in the current action, then remove</span></span><br><span class="line">    <span class="comment">// the action from the executing list.</span></span><br><span class="line">    <span class="comment">// If this action was oneshot, then also remove it from actions_.</span></span><br><span class="line">    ++current_command_;</span><br><span class="line">    <span class="comment">//current_command_等于action的commands数量，说明这个action以及全部执行完了</span></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == action-&gt;NumCommands()) &#123;</span><br><span class="line">        <span class="comment">//此action出队</span></span><br><span class="line">        current_executing_actions_.pop();</span><br><span class="line">        <span class="comment">//重置计数器</span></span><br><span class="line">        current_command_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (action-&gt;oneshot()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> eraser = [&amp;action](<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123; <span class="keyword">return</span> a.<span class="built_in">get</span>() == action; &#125;;</span><br><span class="line">            actions_.erase(<span class="built_in">std</span>::remove_if(actions_.<span class="built_in">begin</span>(), actions_.<span class="built_in">end</span>(), eraser),</span><br><span class="line">                           actions_.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面会执行<code>Action::ExecuteOneCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteOneCommand</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We need a copy here since some Command execution may result in</span></span><br><span class="line">    <span class="comment">// changing commands_ vector by importing .rc files through parser</span></span><br><span class="line">    Command cmd = commands_[command];</span><br><span class="line">    ExecuteCommand(cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用到了<code>Action::ExecuteCommand</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Action::ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command&amp; command)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="comment">//这一行是具体的执行</span></span><br><span class="line">    <span class="keyword">auto</span> result = command.InvokeFunc(subcontext_);</span><br><span class="line">    <span class="keyword">auto</span> duration = t.duration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Any action longer than 50ms will be warned to user as slow operation</span></span><br><span class="line">    <span class="comment">//失败、超时或者debug版本都需要打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (!result.has_value() || duration &gt; <span class="number">50</span>ms ||</span><br><span class="line">        android::base::GetMinimumLogSeverity() &lt;= android::base::DEBUG) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = BuildTriggersString();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> cmd_str = command.BuildCommandString();</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Command '"</span> &lt;&lt; cmd_str &lt;&lt; <span class="string">"' action="</span> &lt;&lt; trigger_name &lt;&lt; <span class="string">" ("</span> &lt;&lt; filename_</span><br><span class="line">                  &lt;&lt; <span class="string">":"</span> &lt;&lt; command.<span class="built_in">line</span>() &lt;&lt; <span class="string">") took "</span> &lt;&lt; duration.count() &lt;&lt; <span class="string">"ms and "</span></span><br><span class="line">                  &lt;&lt; (result.ok() ? <span class="string">"succeeded"</span> : <span class="string">"failed: "</span> + result.error().message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会调用<code>Command::InvokeFunc</code>方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Command::InvokeFunc</span><span class="params">(Subcontext* subcontext)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从 /vendor 或 /oem 解析出来的rc文件都会走这里 </span></span><br><span class="line">    <span class="comment">//涉及到selinux权限问题，Google为了保证安全 </span></span><br><span class="line">    <span class="comment">//队对厂商定制的rc文件中的命令执行，以及由此启动的服务的权限都会有一定限制</span></span><br><span class="line">    <span class="keyword">if</span> (subcontext) &#123;</span><br><span class="line">        <span class="keyword">if</span> (execute_in_subcontext_) &#123;</span><br><span class="line">            <span class="keyword">return</span> subcontext-&gt;Execute(args_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> expanded_args = subcontext-&gt;ExpandArgs(args_);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_args.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_args.error();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RunBuiltinFunction(func_, *expanded_args, subcontext-&gt;context());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//系统原生的rc文件命令都会走这里</span></span><br><span class="line">    <span class="keyword">return</span> RunBuiltinFunction(func_, args_, kInitContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统原生的rc文件命令都会走到<code>RunBuiltinFunction</code>方法中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">RunBuiltinFunction</span><span class="params">(<span class="keyword">const</span> BuiltinFunction&amp; function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> builtin_arguments = BuiltinArguments(context);</span><br><span class="line"></span><br><span class="line">    builtin_arguments.args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    builtin_arguments.args[<span class="number">0</span>] = args[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        builtin_arguments.args[i] = <span class="built_in">std</span>::<span class="built_in">move</span>(*expanded_arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> function(builtin_arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>function</code>是一个以<code>BuiltinArguments</code>为参数的<code>std::function</code>函数包装器模板，可以包装函数、函数指针、类成员函数指针或任意类型的函数对象，在Command对象new出来的时候构造函数就指定了这个func_，我们可以看一下<code>Action::AddCommand</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Action::AddCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp;&amp; args, <span class="keyword">int</span> <span class="built_in">line</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!function_map_) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"no function map available"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从function_map_中进行键值对查找</span></span><br><span class="line">    <span class="keyword">auto</span> map_result = function_map_-&gt;Find(args);</span><br><span class="line">    <span class="keyword">if</span> (!map_result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error() &lt;&lt; map_result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commands_.emplace_back(map_result-&gt;function, map_result-&gt;run_in_subcontext, <span class="built_in">std</span>::<span class="built_in">move</span>(args),</span><br><span class="line">                           <span class="built_in">line</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，是通过rc文件中的字符串去一个<code>function_map_</code>常量中查找得到的，而这个<code>function_map_</code>是在哪赋值的呢，答案是在<code>SecondStageMain</code>函数中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置commands指令所对应的函数map</span></span><br><span class="line">    <span class="keyword">const</span> BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap();</span><br><span class="line">    Action::set_function_map(&amp;function_map);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个在前文代码中有提及，map的定义在<code>system/core/init/builtins.cpp</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> BuiltinFunctionMap&amp; <span class="title">GetBuiltinFunctionMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> BuiltinFunctionMap builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">"bootchart"</span>,               &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_bootchart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chmod"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_chmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chown"</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    &#123;<span class="literal">true</span>,   do_chown&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_reset_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_restart"</span>,           &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start_post_data"</span>,   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_start_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_stop"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_class_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"copy"</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_copy&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"domainname"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_domainname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enable"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_enable&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec"</span>,                    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_background"</span>,         &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">false</span>,  do_exec_background&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec_start"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_exec_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"export"</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_export&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"hostname"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_hostname&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ifup"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_ifup&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"init_user0"</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_init_user0&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"insmod"</span>,                  &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_insmod&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"installkey"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_installkey&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_restart"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_start"</span>,         &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"interface_stop"</span>,          &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_interface_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_persist_props"</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_persist_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_system_props"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_load_system_props&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"loglevel"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_loglevel&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mark_post_data"</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_mark_post_data&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mkdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">6</span>,    &#123;<span class="literal">true</span>,   do_mkdir&#125;&#125;&#125;,</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do mount operations in vendor_init.</span></span><br><span class="line">        <span class="comment">// mount_all is currently too complex to run in vendor_init as it queues action triggers,</span></span><br><span class="line">        <span class="comment">// imports rc scripts, etc.  It should be simplified and run in vendor_init context.</span></span><br><span class="line">        <span class="comment">// mount and umount are run in the same context as mount_all for symmetry.</span></span><br><span class="line">        &#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">0</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount"</span>,                   &#123;<span class="number">3</span>,     kMax, &#123;<span class="literal">false</span>,  do_mount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"perform_apex_config"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_perform_apex_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"umount_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_umount_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"update_linker_config"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_update_linker_config&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"readahead"</span>,               &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_readahead&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"remount_userdata"</span>,        &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_remount_userdata&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restart"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_restart&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon"</span>,              &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon_recursive"</span>,    &#123;<span class="number">1</span>,     kMax, &#123;<span class="literal">true</span>,   do_restorecon_recursive&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rm"</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rm&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rmdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">true</span>,   do_rmdir&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setprop"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_setprop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setrlimit"</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    &#123;<span class="literal">false</span>,  do_setrlimit&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"start"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_start&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"stop"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_stop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"swapon_all"</span>,              &#123;<span class="number">0</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_swapon_all&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enter_default_mount_ns"</span>,  &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_enter_default_mount_ns&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"symlink"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_symlink&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"sysclktz"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_sysclktz&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"trigger"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    &#123;<span class="literal">false</span>,  do_trigger&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_update_state"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &#123;<span class="literal">false</span>,  do_verity_update_state&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait"</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_wait&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait_for_prop"</span>,           &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">false</span>,  do_wait_for_prop&#125;&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"write"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    &#123;<span class="literal">true</span>,   do_write&#125;&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>以下面一段rc脚本为例，我们看一下一个服务是怎么启动的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on zygote-start </span><br><span class="line">    start zygote</span><br></pre></td></tr></table></figure>

<p>首先这是一个action，当init进程在死循环中执行到<code>ActionManager::ExecuteOneCommand</code>方法时，检查到这个action刚好符合<code>event_queue_</code>队首的<code>EventTrigger</code>，便会执行这个<code>action</code>下面的<code>commands</code>。<code>commands</code>怎么执行在上面已经分析过了，我们去<code>system/core/init/builtins.cpp</code>里的map中找key-value对应关系，发现start对应着<code>do_start</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Result&lt;<span class="keyword">void</span>&gt; <span class="title">do_start</span><span class="params">(<span class="keyword">const</span> BuiltinArguments&amp; args)</span> </span>&#123;</span><br><span class="line">    Service* svc = ServiceList::GetInstance().FindService(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!svc) <span class="keyword">return</span> Error() &lt;&lt; <span class="string">"service "</span> &lt;&lt; args[<span class="number">1</span>] &lt;&lt; <span class="string">" not found"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = svc-&gt;Start(); !result.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrorIgnoreEnoent() &lt;&lt; <span class="string">"Could not start service: "</span> &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServiceList</code>通过<code>args[1]</code>即定义的服务名去寻找之前解析好的service，并执行<code>Service::Start</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result&lt;<span class="keyword">void</span>&gt; <span class="title">Service::Start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//上面基本上是一些检查和准备工作，这里先忽略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//通过namespaces_.flags判断使用哪种方式创建进程</span></span><br><span class="line">    <span class="keyword">if</span> (namespaces_.flags) &#123;</span><br><span class="line">        pid = clone(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, namespaces_.flags | SIGCHLD, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//设置权限掩码</span></span><br><span class="line">        umask(<span class="number">077</span>);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//内部调用execv函数启动文件</span></span><br><span class="line">        <span class="keyword">if</span> (!ExpandArgsAndExecv(args_, sigstop_)) &#123;</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"cannot execv('"</span> &lt;&lt; args_[<span class="number">0</span>]</span><br><span class="line">                        &lt;&lt; <span class="string">"'). See the 'Debugging init' section of init's README.md for tips"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pid_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ErrnoError() &lt;&lt; <span class="string">"Failed to fork"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ExpandArgsAndExecv</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="keyword">bool</span> sigstop)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; expanded_args;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; c_strings;</span><br><span class="line"></span><br><span class="line">    expanded_args.resize(args.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">//将要执行的文件路径先加入容器</span></span><br><span class="line">    c_strings.push_back(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(args[<span class="number">0</span>].data()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; args.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> expanded_arg = ExpandProps(args[i]);</span><br><span class="line">        <span class="keyword">if</span> (!expanded_arg.ok()) &#123;</span><br><span class="line">            LOG(FATAL) &lt;&lt; args[<span class="number">0</span>] &lt;&lt; <span class="string">": cannot expand arguments': "</span> &lt;&lt; expanded_arg.error();</span><br><span class="line">        &#125;</span><br><span class="line">        expanded_args[i] = *expanded_arg;</span><br><span class="line">        c_strings.push_back(expanded_args[i].data());</span><br><span class="line">    &#125;</span><br><span class="line">    c_strings.push_back(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigstop) &#123;</span><br><span class="line">        kill(getpid(), SIGSTOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用execv函数，带参执行文件</span></span><br><span class="line">    <span class="keyword">return</span> execv(c_strings[<span class="number">0</span>], c_strings.data()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先<code>fork</code>（或<code>clone</code>）出了一个子进程，再在这个子进程中调用<code>execv</code>函数执行文件</p>
<p>到此为止，一个服务便被启动起来了</p>
<h3 id="守护服务"><a href="#守护服务" class="headerlink" title="守护服务"></a>守护服务</h3><p>当服务启动起来后，<code>init</code>进程也要负责服务的守护，为什么呢？</p>
<p>假设<code>zygote</code>进程挂了，那<code>zygote</code>进程下的所有子进程都可能会被杀，整个<code>Android</code>系统会出现大问题，那怎么办呢？得把<code>zygote</code>进程重启起来呀。<code>init</code>进程守护服务做的就是这些事，当接收到子进程退出信号，就会触发对应的函数进行处理，去根据这个进程所对应的服务，处理后事（重启等）</p>
<p>代码在这个位置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll.Open(); !result.ok()) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InstallSignalFdHandler(&amp;epoll);</span><br><span class="line">    InstallInitNotifier(&amp;epoll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建出来一个epoll句柄，再用它去<code>InstallSignalFdHandler</code>装载信号handler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InstallSignalFdHandler</span><span class="params">(Epoll* epoll)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Applying SA_NOCLDSTOP to a defaulted SIGCHLD handler prevents the signalfd from receiving</span></span><br><span class="line">    <span class="comment">// SIGCHLD when a child process stops or continues (b/77867680#comment9).</span></span><br><span class="line">    <span class="comment">//设置SIGCHLD信号的处理方式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDSTOP &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在init进程中屏蔽SIGCHLD、SIGTERM信号</span></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IsRebootCapable()) &#123;</span><br><span class="line">        <span class="comment">// If init does not have the CAP_SYS_BOOT capability, it is running in a container.</span></span><br><span class="line">        <span class="comment">// In that case, receiving SIGTERM will cause the system to shut down.</span></span><br><span class="line">        sigaddset(&amp;mask, SIGTERM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to block signals"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a handler to unblock signals in the child processes.</span></span><br><span class="line">    <span class="comment">//在子进程中取消SIGCHLD、SIGTERM信号屏蔽</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> result = pthread_atfork(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;UnblockSignals);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Failed to register a fork handler: "</span> &lt;&lt; strerror(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建用于接受信号的文件描述符</span></span><br><span class="line">    signal_fd = signalfd(<span class="number">-1</span>, &amp;mask, SFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (signal_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to create signalfd"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册信号处理器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> result = epoll-&gt;RegisterHandler(signal_fd, HandleSignalFd); !result.ok()) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><p>先介绍一下<code>sigaction</code>函数，它是用来检查和设置一个信号的处理方式的</p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigaction.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigaction.2.html</a></p>
<p>第一个参数<code>signum</code>，定义在<code>signal.h</code>中，用来指定信号的编号（需要设置哪个信号）</p>
<p>第二个参数<code>act</code>是一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<code>sa_handler</code>表示信号的处理方式，<code>sa_flags</code>用来设置信号处理的其他相关操作</p>
<p>第三个参数<code>oldact</code>，如果不为<code>null</code>，会将此信号原来的处理方式保存进去</p>
<p>对应一下<code>InstallSignalFdHandler</code>里的调用，<code>.sa_handler = SIG_DFL</code>表示使用默认的信号处理，<code>.sa_flags = SA_NOCLDSTOP</code>当参数<code>signum</code>为<code>SIGCHLD</code>的时候生效，表示当子进程暂停时不会通知父进程</p>
<h4 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h4><p>接下来<code>InstallSignalFdHandler</code>函数调用了一些信号集函数</p>
<h5 id="sigemptyset"><a href="#sigemptyset" class="headerlink" title="sigemptyset"></a>sigemptyset</h5><p>原型：<code>int sigemptyset(sigset_t *set);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigemptyset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigemptyset.3p.html</a></p>
<p>该函数的作用是将信号集初始化为空</p>
<h5 id="sigaddset"><a href="#sigaddset" class="headerlink" title="sigaddset"></a>sigaddset</h5><p>原型：<code>int sigaddset(sigset_t *set, int signo);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/sigaddset.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/sigaddset.3p.html</a></p>
<p>该函数的作用是把信号signo添加到信号集set中</p>
<h5 id="sigpromask"><a href="#sigpromask" class="headerlink" title="sigpromask"></a>sigpromask</h5><p>原型：<code>int sigpromask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/sigprocmask.2.html</a></p>
<p>该函数可以根据参数指定的方法修改进程的信号屏蔽字</p>
<p>第一个参数<code>how</code>有3种取值：</p>
<ul>
<li><code>SIG_BLOCK</code>：将set中的信号添加到信号屏蔽字中（不改变原有已存在信号屏蔽字，相当于用set中的信号与原有信号取并集设置）</li>
<li><code>SIG_UNBLOCK</code>：将set中的信号移除信号屏蔽字（相当于用set中的信号的补集与原有信号取交集设置）</li>
<li><code>SIG_SETMASK</code>：使用set中的信号直接代替原有信号屏蔽字中的信号</li>
</ul>
<p>第二个参数<code>set</code>是一个信号集，怎么使用和参数how相关</p>
<p>第三个参数<code>oldset</code>，如果不为null，会将原有信号屏蔽字的信号集保存进去</p>
<p>为什么init进程要屏蔽这些信号呢？因为它后面会特殊处理这些信号</p>
<h4 id="pthread-atfork"><a href="#pthread-atfork" class="headerlink" title="pthread_atfork"></a>pthread_atfork</h4><p>这也是一个Linux函数，用来注册fork的handlers</p>
<p>原型：<code>int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));</code></p>
<p>调用这个函数后，当进程再调用fork时，内部创建子进程钱会先在父进程中调用<code>prepare</code>函数，创建子进程成功后，会在父进程中调用<code>parent</code>函数，子进程中调用<code>child</code>函数</p>
<p>对应到<code>InstallSignalFdHandler</code>里来，即当init进程fork出子进程后调用<code>UnblockSignals</code>函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnblockSignals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> &#123;</span> .sa_handler = SIG_DFL &#125;;</span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGTERM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        PLOG(FATAL) &lt;&lt; <span class="string">"failed to unblock signals for PID "</span> &lt;&lt; getpid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是，先在init进程中屏蔽了<code>SIGCHLD</code>、<code>SIGTERM</code>信号，再在子进程中解除了这两个信号的屏蔽</p>
<h4 id="signalfd函数"><a href="#signalfd函数" class="headerlink" title="signalfd函数"></a>signalfd函数</h4><p>同样也是Linux函数，用来创建用于接受信号的文件描述符</p>
<p>原型：<code>int signalfd(int fd, const sigset_t *mask, int flags);</code></p>
<p>参数fd如果为-1，则该函数会创建一个新的文件描述符与mask信号集相关联，如果不为-1，则该函数会用mask替换之前与这个fd相关联的信号集</p>
<p>flags：</p>
<ul>
<li>SFD_NONBLOCK：给新打开的文件描述符设置<code>O_NONBLOCK</code>标志，非阻塞I/O模式</li>
<li>SFD_CLOEXEC：给新打开的文件描述符设置<code>O_CLOEXEC</code>标志，当exec函数执行成功后，会自动关闭这个文件描述符</li>
</ul>
<p>对应到<code>InstallSignalFdHandler</code>中，它创建了一个用于接受<code>SIGCHLD</code>、<code>SIGTERM</code>信号的文件描述符。回忆一下之前对启动服务的分析，是先调用fork创建进程，在exec执行文件，将flags设置为<code>SFD_CLOEXEC</code>，这样就可以保证在子进程中关闭由fork得到的接收信号的文件描述符</p>
<p>注册信号处理器</p>
<p>最后调用<code>Epoll::RegisterHandler</code>方法注册处理器，内部调用了<code>epoll_ctl</code>函数，感兴趣可以自己看一下，文档：<a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/epoll_ctl.2.html</a></p>
<p>这样，当init进程接收到<code>SIGCHLD</code>、<code>SIGTERM</code>信号时便会调用<code>HandleSignalFd</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HandleSignalFd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    signalfd_siginfo siginfo;</span><br><span class="line">    <span class="comment">//从信号集文件描述符中读取信息</span></span><br><span class="line">    <span class="keyword">ssize_t</span> bytes_read = TEMP_FAILURE_RETRY(<span class="built_in">read</span>(signal_fd, &amp;siginfo, <span class="keyword">sizeof</span>(siginfo)));</span><br><span class="line">    <span class="keyword">if</span> (bytes_read != <span class="keyword">sizeof</span>(siginfo)) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"Failed to read siginfo from signal_fd"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (siginfo.ssi_signo) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">            ReapAnyOutstandingChildren();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">            HandleSigtermSignal(siginfo);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            PLOG(ERROR) &lt;&lt; <span class="string">"signal_fd: received unexpected signal "</span> &lt;&lt; siginfo.ssi_signo;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里主要看<code>SIGCHLD</code>，当子进程退出，init进程便会捕获到<code>SIGCHLD</code>，执行<code>ReapAnyOutstandingChildren</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapAnyOutstandingChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (ReapOneProcess() != <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">ReapOneProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">siginfo_t</span> siginfo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// This returns a zombie pid or informs us that there are no zombies left to be reaped.</span></span><br><span class="line">    <span class="comment">// It does NOT reap the pid; that is done below.</span></span><br><span class="line">    <span class="comment">//获取一个已经退出的子进程，但暂时先不销毁</span></span><br><span class="line">    <span class="keyword">if</span> (TEMP_FAILURE_RETRY(waitid(P_ALL, <span class="number">0</span>, &amp;siginfo, WEXITED | WNOHANG | WNOWAIT)) != <span class="number">0</span>) &#123;</span><br><span class="line">        PLOG(ERROR) &lt;&lt; <span class="string">"waitid failed"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pid = siginfo.si_pid;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point we know we have a zombie pid, so we use this scopeguard to reap the pid</span></span><br><span class="line">    <span class="comment">// whenever the function returns from this point forward.</span></span><br><span class="line">    <span class="comment">// We do NOT want to reap the zombie earlier as in Service::Reap(), we kill(-pid, ...) and we</span></span><br><span class="line">    <span class="comment">// want the pid to remain valid throughout that (and potentially future) usages.</span></span><br><span class="line">    <span class="comment">//最后，销毁这个子进程</span></span><br><span class="line">    <span class="keyword">auto</span> reaper = make_scope_guard([pid] &#123; TEMP_FAILURE_RETRY(waitpid(pid, <span class="literal">nullptr</span>, WNOHANG)); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> wait_string;</span><br><span class="line">    Service* service = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SubcontextChildReap(pid)) &#123;</span><br><span class="line">        name = <span class="string">"Subcontext"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过pid获得service</span></span><br><span class="line">        service = ServiceList::GetInstance().FindService(pid, &amp;Service::pid);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!service) <span class="keyword">return</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理service后事</span></span><br><span class="line">    service-&gt;Reap(siginfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service-&gt;flags() &amp; SVC_TEMPORARY) &#123;</span><br><span class="line">        ServiceList::GetInstance().RemoveService(*service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="waitid函数"><a href="#waitid函数" class="headerlink" title="waitid函数"></a>waitid函数</h5><p>Linux函数，用于等待一个子进程状态的改变</p>
<p>原型：<code>int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</code></p>
<p>文档：<a href="https://man7.org/linux/man-pages/man3/waitid.3p.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man3/waitid.3p.html</a></p>
<p>第一个参数<code>idtype</code>：</p>
<ul>
<li>P_PID：等待的子进程的pid必须和参数id匹配</li>
<li>P_GID：等待的子进程的组id必须和参数id匹配</li>
<li>P_ADD：等待所有子进程，此时，参数id被忽略</li>
</ul>
<p>这个函数会将执行的结果保存在第三个参数infop中</p>
<p><code>options</code>：</p>
<ul>
<li>WCONTINUED：等待那些由SIGCONT重新启动的子进程</li>
<li>WEXITED：等待那些已经退出的子进程</li>
<li>WSTOPPED：等待那些被信号暂停的子进程</li>
<li>WNOHANG：非阻塞等待</li>
<li>WNOWAIT：保持返回的子进程处于可等待状态（后续可以再对这个子进程进行wait）</li>
</ul>
<p>回到<code>ReapOneProcess</code>函数中来，它先调用<code>waitid</code>函数，获得一个状态发生改变的子进程（options设置了<code>WEXITED</code>，即已退出的子进程），使用了<code>WNOWAIT</code>参数，也就是暂时先不销毁子进程，使用非阻塞的方式获取</p>
<p>ScopeGuard</p>
<p><code>ScopeGuard</code>的意思是，出作用域后，自动执行某段代码</p>
<p>函数中那段<code>make_scope_guard</code>的意思是，当这个函数执行完后，使用<code>waitpid</code>函数销毁子进程</p>
<p>之后会从<code>ServiceList</code>中通过pid去查找service，查到后调用<code>Service::Reap</code>处理后事</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Service::Reap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">siginfo_t</span>&amp; siginfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当service的参数没有oneshot或者restart时，kill整个进程组</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">        KillProcessGroup(SIGKILL, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Legacy behavior from ~2007 until Android R: this else branch did not exist and we did not</span></span><br><span class="line">        <span class="comment">// kill the process group in this case.</span></span><br><span class="line">        <span class="keyword">if</span> (SelinuxGetVendorAndroidVersion() &gt;= __ANDROID_API_R__) &#123;</span><br><span class="line">            <span class="comment">// The new behavior in Android R is to kill these process groups in all cases.  The</span></span><br><span class="line">            <span class="comment">// 'true' parameter instructions KillProcessGroup() to report a warning message where it</span></span><br><span class="line">            <span class="comment">// detects a difference in behavior has occurred.</span></span><br><span class="line">            KillProcessGroup(SIGKILL, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove any socket resources we may have created.</span></span><br><span class="line">    <span class="comment">//移除已创建的sockets</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; socket : sockets_) &#123;</span><br><span class="line">        <span class="keyword">auto</span> path = ANDROID_SOCKET_DIR <span class="string">"/"</span> + socket.name;</span><br><span class="line">        unlink(path.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行回调</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : reap_callbacks_) &#123;</span><br><span class="line">        f(siginfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果进程接收信号异常或被终止的状态异常，并且包含reboot_on_failure标志，重启系统</span></span><br><span class="line">    <span class="keyword">if</span> ((siginfo.si_code != CLD_EXITED || siginfo.si_status != <span class="number">0</span>) &amp;&amp; on_failure_reboot_target_) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Service with 'reboot_on_failure' option failed, shutting down system."</span>;</span><br><span class="line">        trigger_shutdown(*on_failure_reboot_target_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当service参数为exec时，释放相应服务资源</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_EXEC) UnSetExec();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; SVC_TEMPORARY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    pid_ = <span class="number">0</span>;</span><br><span class="line">    flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line">    start_order_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Oneshot processes go into the disabled state on exit,</span></span><br><span class="line">    <span class="comment">// except when manually restarted.</span></span><br><span class="line">    <span class="comment">//当service参数有oneshot，没有restart和reset时，将service状态置为disable</span></span><br><span class="line">    <span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART) &amp;&amp; !(flags_ &amp; SVC_RESET)) &#123;</span><br><span class="line">        flags_ |= SVC_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line">    <span class="comment">//禁用和重置的服务，都不能自动重启</span></span><br><span class="line">    <span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">        NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//将标志置为重启中</span></span><br><span class="line">    flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">    flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line">    <span class="comment">//执行该service下的所有onrestart命令</span></span><br><span class="line">    onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">    NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service相关的参数可以去<code>system/core/init/README.md</code>中自行查看</p>
<p>这个函数检查了一堆service的标志和状态，判断如何处理这个service，如果需要重启，则调用<code>onrestart_.ExecuteAllCommands()</code>执行该service下的所有<code>onrestart</code>命令，具体的执行过程之前在启动服务那边已经分析过了，这里就不再往下看了</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，整个init进程的启动过程最重要的部分基本都已分析完成，我也是一边从网上搜集资料一边对照着源码磕磕绊绊看过来的，有什么错误或者遗漏的部分欢迎指正，谢谢～</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/23/android/common/%E5%90%84%E5%8E%82%E5%95%86Android%E7%B3%BB%E7%BB%9F%E7%A2%B0%E5%88%B0%E7%9A%84%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B0%E5%BD%95/">各厂商Android系统碰到的奇奇怪怪问题的记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h1><h2 id="MIUI"><a href="#MIUI" class="headerlink" title="MIUI"></a>MIUI</h2><h3 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h3><p><code>CaptureRequest.Builder</code>的<code>set</code>方法，对部分<code>key</code>不生效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MIUI中，CaptureRequest.Builder设置图片方向不生效</span></span><br><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION,getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>解决方法：获得拍摄好的照片<code>Bitmap</code>后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h1><h2 id="HarmonyOs"><a href="#HarmonyOs" class="headerlink" title="HarmonyOs"></a>HarmonyOs</h2><h3 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h3><p>华为ROM（EMUI不确定有没有这种情况）计算<code>TextureView</code>边界的代码似乎有bug</p>
<p>现象：</p>
<ol>
<li>相机预览和拍摄时有概率画面畸形</li>
<li>渲染超过一屏的文本会渲染空白</li>
</ol>
<p>解决方法：手动管理<code>TextureView</code>的销毁和创建</p>
<p>第一步：在对<code>TextureView</code>设置<code>TextureView.SurfaceTextureListener</code>时，另<code>onSurfaceTextureDestroyed</code>返回<code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mTextureView.setSurfaceTextureListener(<span class="keyword">new</span> TextureView.SurfaceTextureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(@NonNull SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里默认是返回true，代表系统自动管理，我们把它设为false手动管理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(@NonNull SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>第二步：在<code>TextureView</code>不渲染的时候手动<code>release</code>掉其中的<code>SurfaceTexture</code>，后面再渲染时，系统调用draw方法后，会自动重新<code>new</code>一个<code>SurfaceTexture</code>出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SurfaceTexture surfaceTexture = mTextureView.getSurfaceTexture();</span><br><span class="line"><span class="keyword">if</span> (surfaceTexture != <span class="keyword">null</span>) &#123;</span><br><span class="line">    surfaceTexture.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="VIVO"><a href="#VIVO" class="headerlink" title="VIVO"></a>VIVO</h1><h2 id="OriginOS"><a href="#OriginOS" class="headerlink" title="OriginOS"></a>OriginOS</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>OriginOS中，<code>TextView</code>设置了<code>android:fontFamily</code>后，不能在设置<code>android:textStyle</code>属性，否则会导致使用的字体被系统默认字体覆盖</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/12/18/android/aosp/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA/">AOSP的编译及刷机</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-18</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/AOSP/">AOSP</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/AOSP/">AOSP</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>众所周知，Android是开源的，AOSP（Android Open Source Project）为Android开源项目的缩写。作为一名Android开发，掌握Android系统的工作机制是技术成长中的必经之路，第一步就是自己编译Android系统。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>一台可以解BL锁（BootLoader），并且厂商提供了硬件驱动的设备，这里推荐使用Google亲儿子手机（Nexus、Pixel系列），可以解BL锁，Google官方会提供硬件驱动，并且AOSP里会提供对应机型的配置</li>
<li>一块剩余空间至少大于300GB的硬盘（Android11源码-150GB左右，编译产物-150GB左右）</li>
<li><del>系统最好为Linux，MacOS也可（Windows可以用WSL）</del></li>
<li>系统需要使用Ubuntu（我不确定别的Linux发行版可不可用），自2021年6月22日起，AOSP不再支持在Windows或MacOS上构建（Windows可以使用WSL，详见<a href="https://juejin.cn/post/7196869815596286008" target="_blank" rel="noopener">WSL编译AOSP必要的几个前置工作</a>）</li>
<li>内存至少要16GB，过小的内存会导致生成build.ninja文件失败</li>
</ul>
<p>这里是Google官方的推荐要求：<a href="https://source.android.com/setup/build/requirements?hl=zh-cN" target="_blank" rel="noopener">https://source.android.com/setup/build/requirements?hl=zh-cN</a></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>参考文档：<a href="https://source.android.com/source/initializing?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/initializing?hl=zh-cn</a></p>
<p>主要就是下载各种编译工具，像jdk，gcc，g++等，还有各种动态库以及辅助工具</p>
<p>注：此文档中部分环境安装有误，缺失了一些必要的库安装，可能会编译中途报错，可以参考下文的环境安装，如果编译还是出现了依赖缺失，安装好继续编译即可</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>以Ubuntu系统为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-11-jdk</span><br></pre></td></tr></table></figure>

<p>注：现在AOSP编译要求JDK版本&gt;=9</p>
<h2 id="安装其他程序包"><a href="#安装其他程序包" class="headerlink" title="安装其他程序包"></a>安装其他程序包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5</span><br></pre></td></tr></table></figure>

<p>注：官方文档中缺失了libncurses5，会导致编译中途找不到libncurses.so.5库</p>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>Android源码是由非常多的Git仓库组成的，为了可以统一管理这么多个Git仓库，Google出了一款工具，叫Repo</p>
<p>参考文档：<a href="https://source.android.com/source/downloading?hl=zh-cn" target="_blank" rel="noopener">https://source.android.com/source/downloading?hl=zh-cn</a></p>
<p>因为Google在国内访问的问题，建议使用镜像下载源码，下面提供几个镜像地址：</p>
<ul>
<li>清华大学</li>
</ul>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest</a></p>
<ul>
<li>中科大</li>
</ul>
<p>git://mirrors.ustc.edu.cn/aosp/platform/manifest</p>
<p>repo init的时候可以指定分支：<a href="https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds" target="_blank" rel="noopener">https://source.android.com/setup/start/build-numbers?hl=zh-cn#source-code-tags-and-builds</a> 在这里可以找到对应系统分支所支持的设备，比如说我的设备是Pixel2，在这张表上可以看到android-11.0.0_r25这个分支下的代码支持我的设备，所以可以执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r25</span><br></pre></td></tr></table></figure>

<p>然后开始进行同步：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync -j8 #j8代表使用8个线程</span><br></pre></td></tr></table></figure>

<p>AOSP代码下载是个漫长的过程，需要耐心等待</p>
<h1 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h1><p>在<a href="https://developers.google.com/android/drivers?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/android/drivers?hl=zh-cn</a>这个网站可以找到Nexus、Pixel系列的驱动，要注意每个驱动后面会有一串代号，需要和你下载的AOSP源码的build号相对应</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A8.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A82.png" alt=""></p>
<p>将他们解压后会得到两个shell文件</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E8%A7%A3%E5%8E%8B.png" alt=""></p>
<p>将他们复制到下载好的aosp源码的根目录</p>
<p>注：网上很多教程说终端要选用bash不要使用zsh，我亲测使用zsh没有问题，如果在编译过程中出现问题，可以尝试切换shell</p>
<ol>
<li>先将shell切换到aosp源码根目录</li>
<li>执行两个解压出来的驱动shell，记得要同意License</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85.png" alt=""></p>
<ol start="3">
<li>执行source build/envsetup.sh，这会向shell中写入一些环境变量</li>
<li>先make clean一下</li>
<li>使用lunch命令选择构建目标</li>
</ol>
<p>这里是该命令的规则：<a href="https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#choose-a-target</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch aosp_walleye-userdebug</span><br></pre></td></tr></table></figure>

<p>后面跟随的的参数可以在这里找到：<a href="https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build" target="_blank" rel="noopener">https://source.android.com/setup/build/running?hl=zh-cn#selecting-device-build</a></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>你也可以在lunch后不加参数，这样会弹出一个菜单提示您选择目标</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87.png" alt=""></p>
<p>指定完成后会弹出这样一个信息提示</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E5%AE%8C%E6%88%90.png" alt=""></p>
<h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>构建部分的文档在这里：<a href="https://source.android.com/setup/build/building?hl=zh-cn#build-the-code" target="_blank" rel="noopener">https://source.android.com/setup/build/building?hl=zh-cn#build-the-code</a><br>如果是初次编译，我们就直接使用<code>m</code>命令就可以了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m -j8 #开启8线程编译</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>现在直接使用<code>make</code>命令会提示<code>Calling make directly is no longer supported</code>然后退出编译，所以使用<code>m</code>命令替代<code>make</code></li>
<li>不能使用root账号编译</li>
</ul>
<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><ol>
<li>先将手机的BL锁解开（每个机型都不同，网上会有对应的教程），进入fastboot模式\</li>
<li>配置fastboot工具（现在Google好像推出了在线刷写工具<a href="https://flash.android.com/" target="_blank" rel="noopener">https://flash.android.com/</a>，可以尝试使用），可以在aosp目录下通过make fastboot命令编译出来，也可以直接从网上下载：<a href="https://developer.android.com/studio/releases/platform-tools" target="_blank" rel="noopener">https://developer.android.com/studio/releases/platform-tools</a></li>
<li>进入编译后产生的镜像的目录…./aosp/out/target/product/walleye(这个是你机型的代号，每种机器都不一样)</li>
<li>执行命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>重启即可看到，我们编译的Android系统已经运行到了手机上</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot reboot #重启命令</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="MacOS上找不到SDK"><a href="#MacOS上找不到SDK" class="headerlink" title="MacOS上找不到SDK"></a>MacOS上找不到SDK</h2><p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_MacOS%E6%89%BE%E4%B8%8D%E5%88%B0SDK.png" alt=""></p>
<p>去这里<a href="https://github.com/phracker/MacOSX-SDKs/releases" target="_blank" rel="noopener">https://github.com/phracker/MacOSX-SDKs/releases</a>下载对应版本的sdk，然后将它放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs目录下，然后重新编译</p>
<p>除此之外，也可以在Finder中查看</p>
<p>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</p>
<p>这个目录下存在哪个版本的sdk，确定后去修改…./aosp/build/soong/cc/config/x86_darwin_host.go文件，在darwinSupportedSdkVersions这个数组中加上你使用的sdk的版本</p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/dreamgyf/ImageStorage/master/AOSP%E7%9A%84%E7%BC%96%E8%AF%91%E5%8F%8A%E5%88%B7%E6%9C%BA_%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9C%AC.png" alt=""></p>
<p>保存后重新编译，这个方式可能当前编译脚本不支持你所用的sdk，可能会编译报错，所以还是推荐使用第一种方式</p>
<h2 id="too-many-open-files"><a href="#too-many-open-files" class="headerlink" title="too many open files"></a>too many open files</h2><p>在Linux系统下有打开文件数的限制，可以使用以下命令设置最大可打开文件数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">ulimit</span> -a 可以查看当前限制</span></span><br><span class="line">ulimit -n 2048</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/05/26/android/view/%E8%B5%B0%E9%A9%AC%E7%81%AF%E5%BC%8F%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8%E7%9A%84TextView/">走马灯式横向滚动的TextView</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/TextView/">TextView</a></span><div class="content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们可以设置<code>TextView</code>的<code>android:ellipsize=&quot;marquee&quot;</code>属性，来做到当文字超出一行的时候呈现跑马灯效果。但<code>TextView</code>的这个走马灯效果需要获取焦点，而同一时间只有一个控件可以获得焦点，更重要的是产品要求无论文字内容是否超出一行，都要滚动效果。</p>
<p>这里先贴一下最后实现的Github地址和效果图</p>
<p><a href="https://github.com/dreamgyf/MarqueeTextView" target="_blank" rel="noopener">https://github.com/dreamgyf/MarqueeTextView</a></p>
<p><img src="https://camo.githubusercontent.com/f78ec92d9270fe6a72f182090567334a5d9ecb5221f471a34cbd83905be65c6a/68747470733a2f2f647265616d6779662d636f64696e672e6f73732d636e2d7368616e676861692e616c6979756e63732e636f6d2f4d61727175656554657874566965772f4d61727175656554657874566965772e676966" alt="MarqueeTextView"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>思路其实很简单，我们只要将单行的<code>TextView</code>截成一张<code>Bitmap</code>，然后我们再自定义一个View，重写它的<code>onDraw</code>方法，每隔一段时间，将这张Bitmap画在不同的坐标上（左右两边各draw一次），这样连续起来看起来就是走马灯效果了。</p>
<p>后来和同事讨论，他提出能不能通过Canvas的平移配合<code>drawText</code>实现这个功能，我想应该也是可以的，但我没有做尝试，各位看官感兴趣的可是试一下这种方案。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们先自定义一个View继承自<code>AppCompatTextView</code>，再在初始化的时候new一个<code>TextView</code>，并重写<code>onMeasure</code>和<code>onLayout</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView = <span class="keyword">new</span> TextView(getContext(), attrs);</span><br><span class="line">    <span class="comment">//TextView如果没有设置LayoutParams，当setText的时候会引发NPE导致崩溃</span></span><br><span class="line">    mTextView.setLayoutParams(<span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));</span><br><span class="line">    mTextView.setMaxLines(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="comment">//宽度不设限制</span></span><br><span class="line">    mTextView.measure(MeasureSpec.UNSPECIFIED, heightMeasureSpec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</span><br><span class="line">    <span class="comment">//保证布局包含完整的Text内容</span></span><br><span class="line">    mTextView.layout(left, top, left + mTextView.getMeasuredWidth(), bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做是为了利用这个内部<code>TextView</code>生成我们需要的<code>Bitmap</code>，同时借用<code>TextView</code>写好的<code>onMeasure</code>方法，这样我们就不用再那么复杂的重写<code>onMeasure</code>方法了</p>
<p>接下来是生成<code>Bitmap</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBitmap = Bitmap.createBitmap(mTextView.getMeasuredWidth(), getMeasuredHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">    Canvas canvas = <span class="keyword">new</span> Canvas(mBitmap);</span><br><span class="line">    mTextView.draw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单，需要注意的是长度要使用内部持有的<code>TextView</code>的<code>getMeasuredWidth</code>，如果使用<code>getWidth</code>的话，最大值为屏幕的宽度，很可能导致生成出的<code>Bitmap</code>不全，高度用谁的倒是无所谓</p>
<p>在每次<code>setText</code>或<code>setTextSize</code>的时候都需要更新<code>Bitmap</code>并重新布局绘制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTextView.addOnLayoutChangeListener(<span class="keyword">new</span> OnLayoutChangeListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChange</span><span class="params">(View v, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">int</span> oldLeft, <span class="keyword">int</span> oldTop, <span class="keyword">int</span> oldRight, <span class="keyword">int</span> oldBottom)</span> </span>&#123;</span><br><span class="line">            updateBitmap();</span><br><span class="line">            restartScroll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(CharSequence text, BufferType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setText(text, type);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有text参数会先调用setText，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">	mTextView.setText(text);</span><br><span class="line">	requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSize</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setTextSize(unit, size);</span><br><span class="line">    <span class="comment">//执行父类构造函数时，如果AttributeSet中有textSize参数会先调用setTextSize，此时mTextView尚未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (mTextView != <span class="keyword">null</span>) &#123;</span><br><span class="line">	mTextView.setTextSize(size);</span><br><span class="line">	requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我给这个<code>MarqueeTextView</code>定义了一些参数，一个是<code>space</code>（文字滚动时，头尾的最小间隔距离），另一个是<code>speed</code>（文字滚动的速度）</p>
<p>先看一下<code>onDraw</code>的实现吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当文字内容不超过一行</span></span><br><span class="line">	<span class="keyword">if</span> (mTextView.getMeasuredWidth() &lt;= getWidth()) &#123;</span><br><span class="line">            <span class="comment">//计算头尾需要间隔的宽度</span></span><br><span class="line">            <span class="keyword">int</span> space = mSpace - (getWidth() - mTextView.getMeasuredWidth());</span><br><span class="line">            <span class="keyword">if</span> (space &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                space = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了显示宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -getWidth() - space) &#123;</span><br><span class="line">                mLeftX += getWidth() + space;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为最右边的坐标-左边bitmap已消失的宽度+间隔宽度</span></span><br><span class="line">                canvas.drawBitmap(mBitmap, getWidth() + mLeftX + space, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当文字内容超过一行</span></span><br><span class="line">            <span class="comment">//当左边的drawBitmap的坐标超过了内容宽度+间隔宽度，即走完一个循环，右边的Bitmap已经挪到了最左边，将坐标重置</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX &lt; -mTextView.getMeasuredWidth() - mSpace) &#123;</span><br><span class="line">		mLeftX += mTextView.getMeasuredWidth() + mSpace;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//画左边的bitmap</span></span><br><span class="line">            canvas.drawBitmap(mBitmap, mLeftX, <span class="number">0</span>, getPaint());</span><br><span class="line">            <span class="comment">//当尾部已经显示出来的时候</span></span><br><span class="line">            <span class="keyword">if</span> (mLeftX + (mTextView.getMeasuredWidth() - getWidth()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//画右边的bitmap，位置为尾部的坐标+间隔宽度</span></span><br><span class="line">		canvas.drawBitmap(mBitmap, mTextView.getMeasuredWidth() + mLeftX + mSpace, <span class="number">0</span>, getPaint());</span><br><span class="line">            &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是基本的绘制思路</p>
<p>接下来需要让他动起来，我这里使用的是Handler，每隔一段时间更新一下坐标并重绘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mMarqueeRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	invalidate();</span><br><span class="line">	mLeftX -= mSpeed;</span><br><span class="line">	mHandler.postDelayed(<span class="keyword">this</span>, <span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.post(mMarqueeRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.removeCallbacks(mMarqueeRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLeftX = <span class="number">0</span>;</span><br><span class="line">    mHandler.removeCallbacks(mMarqueeRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restartScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopScroll();</span><br><span class="line">    startScroll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在View移除Window时，把HandlerMessage取消掉</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">    mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/04/19/android/common/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">Android开发常见问题总结（持续更新）</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Android/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">常见问题</a></span><div class="content"><h1 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h1><ol>
<li>滑动嵌套</li>
</ol>
<p>滑动组件的嵌套可能会产生以下一些问题：</p>
<ul>
<li>滑动冲突</li>
</ul>
<p>解决方法：使用<code>NestedScrollView</code>替代<code>ScrollView</code>，<code>RecyclerView</code>可以设置属性<code>android:nestedScrollingEnabled=&quot;false&quot;</code>或代码里<code>setNestedScrollingEnabled(false);</code>来禁用组件自身的滑动</p>
<p>注意：如果<code>RecyclerView</code>只能显示一个Item的话，需要设置<code>NestedScrollView</code>的属性<code>android:fillViewport=&quot;true&quot;</code></p>
<ul>
<li>滑动失效</li>
</ul>
<p><code>ScrollView</code>设置<code>fillViewport=&quot;true&quot;</code>的情况下，如果对<code>ScrollView</code>的直接子view设置上下margin，在超出内容的高度小于设置的margin的情况下，可能会导致整个<code>ScrollView</code>滑动失效</p>
<ol start="2">
<li>焦点抢占</li>
</ol>
<p><code>ScrollView</code>、<code>RecyclerView</code>等滑动组件可能会抢占焦点，导致界面显示时直接滑动到对应组件的位置，而不是顶部</p>
<p>解决方法：在顶部View(或者其他你所期望的初始位置)加上属性<code>android:focusable=&quot;true&quot;</code>和<code>android:focusableInTouchMode=&quot;true&quot;</code></p>
<p>新解决方法：在顶部View上加<code>android:descendantFocusability</code>属性，该属性是用来定义父布局与子布局之间的关系的，它有三种值：</p>
<ul>
<li><code>beforeDescendants</code>：父布局会优先其子类控件而获取到焦点</li>
<li><code>afterDescendants</code>：父布局只有当其子类控件不需要获取焦点时才获取焦点</li>
<li><code>blocksDescendants</code>：父布局会覆盖子类控件而直接获得焦点</li>
</ul>
<p>使用<code>blocksDescendants</code>覆盖子布局焦点以解决焦点抢占问题</p>
<hr>
<h1 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h1><h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><ol>
<li>在<code>onBindViewHolder</code>中设置子View回调时需要注意</li>
</ol>
<p>如果回调的参数包括position时，需要注意有没有地方会调用<code>notifyItemRemoved</code>或<code>notifyItemRangeRemoved</code>，如果有，需要使用<code>holder.getAdapterPosition()</code>来代替<code>onBindViewHolder</code>方法的position参数</p>
<p>原因：<code>notifyItemRemoved</code>不会对其他的Item重新调用<code>onBindViewHolder</code>，这样可能会导致position错位。<code>holder.getAdapterPosition()</code>方法会返回数据在 Adapter 中的位置（即使位置的变化还未刷新到布局中）</p>
<ol start="2">
<li>如何在更新数据后重新定位到顶部</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写父类方法，获得绑定的RecyclerView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToRecyclerView</span><span class="params">(@NonNull RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">	mRecyclerView = recyclerView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当数据更新后调用</span></span><br><span class="line"><span class="keyword">if</span> (mRecyclerView != <span class="keyword">null</span> &amp;&amp; mRecyclerView.getChildCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	mRecyclerView.scrollToPosition(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前尝试过<code>mRecyclerView.scrollTo(0, 0);</code>但没有起效，不清楚为什么</p>
<ol start="3">
<li>动态部分更新数据时</li>
</ol>
<p>如果<code>RecyclerView</code>需要动态更新<strong>部分</strong>数据，并且在<code>onBindViewHolder</code>时对某些view设置了事件或者回调等，如果此时使用到了position参数需要注意，如果你只notify了部分数据更新，可能会导致更新后部分ViewHolder中的回调里的position不正确，建议：</p>
<ul>
<li>使用<code>notifyDataSetChanged()</code></li>
<li>使用<code>notifyItem</code>，但是在<code>onBindViewHolder</code>中设置回调时不要使用position参数，而是使用<code>holder.getAdapterPosition()</code>替代（注意这个方法在<code>ViewHolder</code>没有和<code>RecyclerView</code>绑定时会返回-1 <code>NO_POSITION</code>）</li>
</ul>
<h2 id="ItemDecoration"><a href="#ItemDecoration" class="headerlink" title="ItemDecoration"></a>ItemDecoration</h2><ol>
<li><code>StaggeredGridLayoutManager</code>下<code>ItemDecoration</code>的<code>offset</code>计算错误</li>
</ol>
<p>主要是因为<code>RecyclerView</code>动态更新数据时，会执行多次<code>measure</code>，但只会在第一次<code>measure</code>的时候调用<code>ItemDecoration.getItemOffsets</code>（因为<code>LP</code>里的<code>mInsetsDirty</code>变量），此时获得的<code>spanIndex</code>是一个错误值</p>
<p>这个问题的具体分析可以看<a href="https://blog.kyleduo.com/2017/07/27/recyclerview-wrong-decoration-inset/" target="_blank" rel="noopener">这篇文章</a>，暂时没有什么好的解决方案，不建议大家使用反射，毕竟你不知道<code>Android</code>会不会更改这个变量</p>
<hr>
<h1 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h1><ol>
<li>生命周期</li>
</ol>
<ul>
<li>初始化时需要注意</li>
</ul>
<p>Dialog在第一次调用<code>show()</code>方法后才会执行<code>onCreate(Bundle savedInstanceState)</code>方法，因此建议自定义Dialog时将<code>findViewById</code>等初始化操作放在构造函数中进行，避免外部使用时因在<code>show()</code>之前设置视图数据导致NPE</p>
<hr>
<h1 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h1><ol>
<li>点击没反应</li>
</ol>
<p><code>PopupWindow</code>如果不设置背景的话，在某些5.x以下系统机型上会出现点击没反应的问题</p>
<p>解决方法：给PopupWindow设置一个空背景<code>popupWindow.setBackgroundDrawable(new BitmapDrawable(mContext.getResources(), (Bitmap) null));</code></p>
<p>详见：<a href="https://juejin.cn/post/6844903761488379912" target="_blank" rel="noopener">https://juejin.cn/post/6844903761488379912</a></p>
<hr>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><ol>
<li>隐式广播</li>
</ol>
<p>在Android8.0以上的系统，大部分的隐式广播都被限制不可使用。</p>
<p>解决方法：</p>
<ol>
<li>使用动态广播</li>
<li>使用显示广播<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一: 设置Component</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(context, SomeReceiver<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二: 设置Package</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">intent.setPackage(<span class="string">"com.dreamgyf.xxx"</span>);</span><br><span class="line">context.sendBroadcast(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不知道包名的话可以通过PackageManager获取所有注册了指定action的广播的package</span></span><br><span class="line">Intent actionIntent = <span class="keyword">new</span> Intent(SOME_ACTION);</span><br><span class="line">PackageManager pm = context.getPackageManager();</span><br><span class="line">List&lt;ResolveInfo&gt; matches = pm.queryBroadcastReceivers(actionIntent, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (ResolveInfo resolveInfo : matches) &#123;            </span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(actionIntent);            </span><br><span class="line">    intent.setPackage(resolveInfo.activityInfo.applicationInfo.packageName);            </span><br><span class="line">    intent.setAction(SOME_ACTION);            </span><br><span class="line">    context.sendBroadcast(intent);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="软键盘"><a href="#软键盘" class="headerlink" title="软键盘"></a>软键盘</h1><ol>
<li>弹起软键盘</li>
</ol>
<p>网上大部分文章所写的弹起软键盘的方法并不完美，大部分文章让你在<code>onResume</code>时再弹起，有的文章甚至让你<code>postDelayed</code>，非常不靠谱，经过本人分析，软键盘的弹起需要满足以下几个条件：</p>
<ul>
<li><p>控件为<code>EditText</code>或其子类</p>
</li>
<li><p>控件所在的<code>window</code>要获得焦点</p>
</li>
<li><p>控件本身要获得焦点</p>
</li>
</ul>
<p>根据以上几个条件，我写了一个完美弹起软键盘的方法，<code>onCreate</code>时也可以照常使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">showKeyboard</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ims = context.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span>? InputMethodManager ?: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus()) &#123;</span><br><span class="line">        requestFocus()</span><br><span class="line">        ims.showSoftInput(<span class="keyword">this</span>, <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewTreeObserver.addOnWindowFocusChangeListener(<span class="keyword">object</span> : OnWindowFocusChangeListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onWindowFocusChanged</span><span class="params">(hasFocus: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasFocus) &#123;</span><br><span class="line">                    viewTreeObserver.removeOnWindowFocusChangeListener(<span class="keyword">this</span>)</span><br><span class="line">                    requestFocus()</span><br><span class="line">                    ims.showSoftInput(<span class="keyword">this</span><span class="symbol">@showKeyboard</span>, <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实体键盘"><a href="#实体键盘" class="headerlink" title="实体键盘"></a>实体键盘</h1><ol>
<li><code>EditText</code>有焦点时会拦截键盘的数字键</li>
</ol>
<p>解决方法：使用<code>TextWatcher</code>等监听<code>EditText</code>输入</p>
<hr>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><ol>
<li>动画</li>
</ol>
<p>在Activity销毁之前如果没有cancel掉，会导致这个Activity内存泄漏</p>
<ol start="2">
<li><code>ClickableSpan</code></li>
</ol>
<p>使用<code>SpannableString.setSpan</code>方法设置<code>ClickableSpan</code>可能导致内存泄漏</p>
<p>原因：<code>TextView</code>在<code>onSaveInstanceState</code>时会将<code>ClickableSpan</code>复制一份，由于某些原因，<code>SpannableString</code>不会删除这个<code>ClickableSpan</code>，从而导致内存泄漏，详见：<br><a href="https://stackoverflow.com/questions/28539216/android-textview-leaks-with-setmovementmethod" target="_blank" rel="noopener">StackOverflow</a></p>
<p>解决方法：自定义一个抽象类同时继承<code>ClickableSpan</code>和实现<code>NoCopySpan</code>接口，外部<code>setSpan</code>时使用这个抽象类</p>
<hr>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><ol>
<li><code>Fragment</code>尽量不要使用带参构造函数，一定要保证有一个不含参的构造函数，否则在<code>Activity</code>重建时尝试反射<code>newInstance</code>恢复<code>Fragment</code>时会抛出<code>Could not find Fragment constructor</code>异常</li>
</ol>
<hr>
<h1 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h1><ol>
<li>反射</li>
</ol>
<p>如果使用到了反射，需要特别注意需不需要在<code>proguard-rules</code>中加入keep规则</p>
<ol start="2">
<li>module混淆</li>
</ol>
<p>如果是多module项目，想要在module中增加混淆规则，<code>proguardFiles</code>属性是无效的，应该使用<code>consumerProguardFiles</code>属性</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">21</span></span><br><span class="line">        targetSdkVersion <span class="number">28</span></span><br><span class="line">        versionName repo.version</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line"></span><br><span class="line">        consumerProguardFiles <span class="string">'proguard-rules.pro'</span> <span class="comment">//这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="相机开发"><a href="#相机开发" class="headerlink" title="相机开发"></a>相机开发</h1><ol>
<li>拍照角度</li>
</ol>
<p>相机的方向一般是以手机横向作为正方向，这样如果我们以竖屏的方式拍照，拍出来的照片可能会出现旋转了90度的情况，这时候就需要在拍照完后处理一下图片，旋转到正确位置。</p>
<p>具体介绍与算法在Android SDK中<code>CaptureRequest.JPEG_ORIENTATION</code>的注释中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getJpegOrientation</span><span class="params">(CameraCharacteristics c, <span class="keyword">int</span> deviceOrientation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deviceOrientation == android.view.OrientationEventListener.ORIENTATION_UNKNOWN)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获得相机方向与设备方向间的夹角</span></span><br><span class="line">    <span class="keyword">int</span> sensorOrientation = c.get(CameraCharacteristics.SENSOR_ORIENTATION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Round device orientation to a multiple of 90</span></span><br><span class="line">    deviceOrientation = (deviceOrientation + <span class="number">45</span>) / <span class="number">90</span> * <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reverse device orientation for front-facing cameras</span></span><br><span class="line">    <span class="keyword">boolean</span> facingFront = c.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_FRONT;</span><br><span class="line">    <span class="keyword">if</span> (facingFront) deviceOrientation = -deviceOrientation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate desired JPEG orientation relative to camera orientation to make</span></span><br><span class="line">    <span class="comment">// the image upright relative to the device orientation</span></span><br><span class="line">    <span class="keyword">int</span> jpegOrientation = (sensorOrientation + deviceOrientation + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jpegOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算好角度后就可以对图片做旋转了，网上有很多文章都说使用这种方式做旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getJpegOrientation(deviceRotation));</span><br></pre></td></tr></table></figure>

<p>但实际上在某些系统上 (MIUI)，设置的这个参数并不会生效，所以我的方案是，获得拍摄好的照片Bitmap后，再对其进行旋转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">rotateBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> angle)</span> </span>&#123;</span><br><span class="line">   Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">   matrix.setRotate(angle);</span><br><span class="line">   <span class="keyword">return</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.getWidth(), bitmap.getHeight(), matrix, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/background.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By dreamgyf</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>